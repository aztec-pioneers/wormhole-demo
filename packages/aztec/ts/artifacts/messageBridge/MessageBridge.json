{
  "file_map": {
    "101": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::macros::{\n    dispatch::generate_public_dispatch,\n    functions::{stub_registry, utils::check_each_fn_macroified},\n    notes::NOTES,\n    storage::STORAGE_LAYOUT_NAME,\n    utils::{get_trait_impl_method, module_has_storage},\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_private_state` utility function.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[external(...)], #[contract_library_method], or #[test] are not allowed in contracts.\n    check_each_fn_macroified(m);\n\n    // We generate `_compute_note_hash_and_nullifier`, `sync_private_state` and `process_message`\n    // functions only if they are not already implemented. If they are implemented we just insert empty\n    // quotes.\n    let contract_library_method_compute_note_hash_and_nullifier = if !m.functions().any(|f| {\n        f.name() == quote { _compute_note_hash_and_nullifier }\n    }) {\n        generate_contract_library_method_compute_note_hash_and_nullifier()\n    } else {\n        quote {}\n    };\n    let sync_private_state = if !m.functions().any(|f| f.name() == quote { sync_private_state }) {\n        generate_sync_private_state()\n    } else {\n        quote {}\n    };\n    let process_message = if !m.functions().any(|f| f.name() == quote { process_message }) {\n        generate_process_message()\n    } else {\n        quote {}\n    };\n    let public_dispatch = generate_public_dispatch(m);\n\n    quote {\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_private_state\n        $process_message\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    if NOTES.len() > 0 {\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..NOTES.len() {\n            let typ = NOTES.get(i);\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret its raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = <$typ as $crate::protocol_types::traits::Packable>::N;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided note nonce.\n                        let note_hash_for_nullification = aztec::note::utils::compute_note_hash_for_nullification(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(note_nonce).into()\n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullification);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `note_nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_message` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                note_nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_sync_private_state() -> Quoted {\n    // We obtain the `external` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::external(\"utility\")]` in the returned quote because the latter would result in\n    // the function attribute having the full path in the ABI. This is undesirable because we use the information in\n    // the ABI only to determine whether a function is `external(\"private\")`, `external(\"public\")`, or `external(\"utility\")`.\n    let external = crate::macros::functions::external;\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[external(\"utility\")] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[$external(\"utility\")]\n        unconstrained fn sync_private_state() {\n        }\n    }\n}\n\ncomptime fn generate_process_message() -> Quoted {\n    // We obtain the `external` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::external(\"utility\")]` in the returned quote because the latter would result in\n    // the function attribute having the full path in the ABI. This is undesirable because we use the information in\n    // the ABI only to determine whether a function is `external(\"private\")`, `external(\"public\")`, or `external(\"utility\")`.\n    let external = crate::macros::functions::external;\n\n    quote {\n        #[$external(\"utility\")]\n        unconstrained fn process_message(\n            message_ciphertext: BoundedVec<Field, aztec::messages::encoding::MESSAGE_CIPHERTEXT_LEN>,\n            message_context: aztec::messages::processing::message_context::MessageContext,\n        ) {\n            aztec::messages::discovery::process_message::process_message_ciphertext(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n                message_ciphertext,\n                message_context,\n            );\n        }\n    }\n}\n"
    },
    "102": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr",
      "source": "use super::utils::compute_fn_selector;\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::utils::get_params_len_quote;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault, panic};\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let seen_selectors =\n        &mut UHashMap::<Field, Quoted, BuildHasherDefault<Poseidon2Hasher>>::default();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n        let fn_name = function.name();\n\n        // Since function selectors are computed as the first 4 bytes of the hash of the function signature,\n        // it's possible to have collisions. With the following check, we ensure it doesn't happen within\n        // the same contract.\n        if seen_selectors.contains_key(selector) {\n            let existing_fn = seen_selectors.get(selector).unwrap();\n            panic(\n                f\"Public function selector collision detected between functions '{fn_name}' and '{existing_fn}'\",\n            );\n        }\n        seen_selectors.insert(selector, fn_name);\n\n        let params_len_quote = get_params_len_quote(parameters);\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $params_len_quote] = dep::aztec::context::public_context::calldata_copy(1, $params_len_quote);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index: &mut u32 = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[external(\"public\")]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "106": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/macros/functions/call_interface_stubs.nr",
      "source": "//! Stubs are auto-generated wrapper functions that provide an ergonomic interface for cross-contract calls.\n//! Instead of manually serializing arguments and creating call interfaces, stubs allow natural syntax, e.g. for\n//! enqueuing calls to public functions:\n//!\n//!   ExternalContract.at(address).some_method(arg1, arg2).enqueue()\n\nuse crate::macros::utils::{AsStrQuote, compute_fn_selector, is_fn_view};\nuse super::stub_registry;\nuse protocol_types::meta::utils::derive_serialization_quotes;\nuse std::meta::unquote;\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\npub comptime fn register_private_fn_stub(f: FunctionDefinition) {\n    let stub = if is_fn_view(f) {\n        create_private_static_stub(f)\n    } else {\n        create_private_stub(f)\n    };\n    stub_registry::register(f.module(), stub);\n}\n\npub comptime fn register_public_fn_stub(f: FunctionDefinition) {\n    let stub = if is_fn_view(f) {\n        create_public_static_stub(f)\n    } else {\n        create_public_stub(f)\n    };\n    stub_registry::register(f.module(), stub);\n}\n\npub comptime fn register_utility_fn_stub(f: FunctionDefinition) {\n    let stub = create_utility_stub(f);\n    stub_registry::register(f.module(), stub);\n}\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, Quoted, u32, Field) {\n    // Dear privacy adventurer,\n    // Chances are, you've command+clicked on the name of an external function\n    // call -- seeking to view that function -- only to end up here.\n    // Here's an explanation:\n    // The external contract that you're calling was likely annotated with the `#[aztec]`\n    // annotation -- as all good aztec contracts are. This triggers a macro which generates\n    // a \"contract interface\" for that contract, which is effectively a pretty interface\n    // that gives natural contract calling semantics:\n    //\n    // `MyImportedContract.at(some_address).my_method(arg1, arg2).enqueue();\n    //\n    // Unfortunately, the usage of macros makes it a bit of a black box.\n    // To actually view the target function, you could instead command+click on\n    // `MyImportedContract`, or you can just manually search it.\n    // If you want to view the noir code that gets generated by this macro, you can\n    // use `nargo expand` on your contract.\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n\n    let (serialized_args_array_construction, _, serialized_args_array_name) =\n        derive_serialization_quotes(fn_parameters, false);\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name,\n        fn_name_str, fn_name_len, fn_selector,\n    )\n}\n\ncomptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, serialized_args_array_name, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            )\n        }\n    }\n}\n\ncomptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, serialized_args_array_name, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, serialized_args_array_name, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            )\n        }\n    }\n}\n\ncomptime fn create_utility_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, serialized_args_array_name, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::UtilityCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::UtilityCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            )\n        }\n    }\n}\n"
    },
    "107": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\n// Used by `create_mark_as_initialized` (you won't find it through searching)\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\n// Used by `create_mark_as_initialized` (you won't find it through searching)\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\n// Used by `create_init_check` (you won't find it through searching)\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\n// Used by `create_init_check` (you won't find it through searching)\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\n// Used by `create_assert_correct_initializer_args` (you won't find it through searching)\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender().unwrap()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n// Used by `create_assert_correct_initializer_args` (you won't find it through searching)\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender().unwrap()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "110": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{\n        auth_registry::AUTHORIZE_ONCE_REGISTRY,\n        call_interface_stubs::{\n            register_private_fn_stub, register_public_fn_stub, register_utility_fn_stub,\n        },\n    },\n    notes::NOTES,\n    utils::{\n        fn_has_authorize_once, fn_has_noinitcheck, is_fn_contract_library_method, is_fn_external,\n        is_fn_initializer, is_fn_internal, is_fn_test, is_fn_view, modify_fn_body,\n        module_has_initializer, module_has_storage,\n    },\n};\nuse dep::protocol_types::meta::utils::derive_serialization_quotes;\nuse std::meta::{ctstring::AsCtString, type_of};\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) {\n    register_private_fn_stub(f);\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    let (args_serialization, _, serialized_args_name) =\n        derive_serialization_quotes(original_params, false);\n\n    let context_creation = quote {\n        $args_serialization\n        let args_hash = dep::aztec::hash::hash_args_array($serialized_args_name);\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, args_hash);\n    };\n\n    let function_name = f.name();\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        let assertion_message = f\"Function {function_name} can only be called internally\";\n        quote { assert(context.msg_sender().unwrap() == context.this_address(), $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        let assertion_message =\n            f\"Function {function_name} can only be called statically\".as_ctstring().as_quoted_str();\n        quote { assert(context.inputs.call_context.is_static_call, $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (\n            quote { aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_private(context); },\n            quote { aztec::macros::functions::initialization_utils::mark_as_initialized_private(&mut context); },\n        )\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        quote { aztec::macros::functions::initialization_utils::assert_is_initialized_private(&mut context); }\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any. Note that the message\n    // discovery call syncs private events as well. We do not sync those here if there are no notes because we don't\n    // have an API that would access events from private functions.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f, true)\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is serialized and hashed before being passed to the context.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n\n        let (return_serialization, _, serialized_return_name) =\n            derive_serialization_quotes([(return_value_var_name, return_value_type)], false);\n\n        body = body_without_return;\n\n        quote {\n            $return_value_assignment\n            $return_serialization\n            context.set_return_hash($serialized_return_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    // A quote to be injected at the beginning of the function body.\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) {\n    register_public_fn_stub(f);\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n\n    let args_len_quote = if original_params.len() == 0 {\n        // If the function has no parameters, we set the args_len to 0.\n        quote { 0 }\n    } else {\n        // The following will give us <type_of_struct_member_1 as Serialize>::N + <type_of_struct_member_2 as Serialize>::N + ...\n        original_params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n            <$param_type as $crate::protocol_types::traits::Serialize>::N\n        }\n            })\n            .join(quote {+})\n    };\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len_quote] = dep::aztec::context::public_context::calldata_copy(1, $args_len_quote);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    let name = f.name();\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        let assertion_message = f\"Function {name} can only be called internally\";\n        quote { assert(context.msg_sender().unwrap() == context.this_address(), $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        let name = f.name();\n        let assertion_message =\n            f\"Function {name} can only be called statically\".as_ctstring().as_quoted_str();\n        quote { assert(context.is_static_call(), $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (\n            quote { aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_public(context); },\n            quote { aztec::macros::functions::initialization_utils::mark_as_initialized_public(&mut context); },\n        )\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        quote { aztec::macros::functions::initialization_utils::assert_is_initialized_public(&mut context); }\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f, false)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    register_utility_fn_stub(f);\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage(f.module()) {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process or they may be used to sync private events from TypeScript\n    // (`sync_private_state` function gets invoked by PXE::getPrivateEvents function).\n    let message_discovery_call = create_message_discovery_call();\n\n    // A quote to be injected at the beginning of the function body.\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Injects an authwit verification check of the form:\n/// ```\n///   if (!from.eq(context.msg_sender().unwrap())) {\n///         assert_current_call_valid_authwit::<N>(&mut context, from);\n///     } else {\n///         assert(authwit_nonce, \"Invalid authwit nonce. When 'from' and 'msg_sender' are the same, authwit_nonce must be zero\");\n///     }\n/// ```\n/// where `from` and `authwit_nonce` are the names of the parameters that are expected to be present in the function definition.\n/// This check is injected by the `#[authorize_once(\"from_arg_name\", \"nonce_arg_name\")]`, which allows the user to define\n/// which parameters to use.\n///\n/// # Arguments\n/// * `f` - The function definition to inject the authwit verification check into. The function must have parameters\n///         matching the names specified in the `#[authorize_once]` attribute.\n/// * `is_private` - Whether the function is a private function (`true`) or a public function (`false`). This determines\n///                  which authwit verification method to use: `assert_current_call_valid_authwit` for private functions\n///                  or `assert_current_call_valid_authwit_public` for public functions.\npub(crate) comptime fn create_authorize_once_check(\n    f: FunctionDefinition,\n    is_private: bool,\n) -> Quoted {\n    let maybe_authorize_once_args = AUTHORIZE_ONCE_REGISTRY.get(f);\n    let authorize_once_args = if maybe_authorize_once_args.is_some() {\n        maybe_authorize_once_args.unwrap()\n    } else {\n        // We need to for authorize_once to have already executed so that we can retrieve its params - this depends on\n        // the order in which the attributes are applied.\n        panic(\n            f\"Functions marked with #[authorize_once] must have the #[external(\\\"private\\\")] or #[external(\\\"public\\\")] attribute placed last\",\n        )\n    };\n\n    let (from_arg_name, nonce_arg_name) = authorize_once_args;\n    let name: Quoted = f.name();\n\n    let from_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{from_arg_name}\".quoted_contents());\n    let (from_arg_name_quoted, from_arg_type) = if from_arg_candidates.len() == 1 {\n        from_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {from_arg_name} parameter. Please specify which one to use in #[authorize_once(\\\"...\\\", \\\"authwit_nonce\\\")]\",\n        )\n    };\n    if from_arg_type\n        != quote { dep::protocol_types::address::aztec_address::AztecAddress }.as_type() {\n        panic(\n            f\"Argument {from_arg_name_quoted} in function {name} must be of type AztecAddress, but is of type {from_arg_type}\",\n        )\n    }\n\n    let nonce_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{nonce_arg_name}\".quoted_contents());\n    let (nonce_arg_name_quoted, nonce_arg_type) = if nonce_arg_candidates.len() == 1 {\n        nonce_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {nonce_arg_name}. Please specify which one to use in #[authorize_once(\\\"from\\\", \\\"...\\\")]\",\n        )\n    };\n    if nonce_arg_type != quote { Field }.as_type() {\n        panic(\n            f\"Argument {nonce_arg_name_quoted} in function {name} must be of type Field, but is of type {nonce_arg_type}\",\n        );\n    }\n\n    let nonce_check_quote = f\"{nonce_arg_name_quoted} == 0\".quoted_contents();\n\n    let fn_call = if is_private {\n        // At this point, the original args of the fn have already been altered by the macro\n        // to include PrivateContextInputs, so we need to adjust the args_len accordingly.\n        let args_len = f.parameters().len() - 1;\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit::<$args_len> }\n    } else {\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit_public }\n    };\n    let invalid_nonce_message = f\"Invalid authwit nonce. When '{from_arg_name}' and 'msg_sender' are the same, '{nonce_arg_name}' must be zero\"\n        .as_ctstring()\n        .as_quoted_str();\n    quote {         \n        if (!$from_arg_name_quoted.eq(context.msg_sender().unwrap())) {\n            $fn_call(&mut context, $from_arg_name_quoted);\n        } else {\n            assert($nonce_check_quote, $invalid_nonce_message);\n        }\n    }\n}\n\n/// Checks if each function in the module is marked with either #[external(...)], #[contract_library_method], or #[test].\n/// Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_external(f) & !is_fn_contract_library_method(f) & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[external(...)], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "112": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/macros/notes.nr",
      "source": "use crate::note::note_getter_options::PropertySelector;\nuse std::{collections::bounded_vec::BoundedVec, meta::{ctstring::AsCtString, type_of}};\n\n/// Maximum number of note types within 1 contract.\ncomptime global MAX_NOTE_TYPES: u32 = 128;\n\n/// A BoundedVec containing all the note types within this contract.\npub comptime mut global NOTES: BoundedVec<Type, MAX_NOTE_TYPES> = BoundedVec::new();\n\ncomptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < MAX_NOTE_TYPES,\n        f\"A contract can contain at most {MAX_NOTE_TYPES} different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_type_impl(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n    let typ = s.as_type();\n    let note_type_name: str<_> = f\"{name}\".as_ctstring().as_quoted_str!();\n    let max_note_packed_len = crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                // This static assertion ensures the note's packed length doesn't exceed the maximum allowed size.\n                // While this check would ideally live in the Packable trait implementation, we place it here since\n                // this function is always generated by our macros and the Packable trait implementation is not.\n                // Note: We set the note type name and max packed length as local variables because injecting them\n                // directly into the error message doesn't work.\n                let note_type_name = $note_type_name;\n                let max_note_packed_len: u32 = $max_note_packed_len; // Casting to u32 to avoid the value to be printed in hex.\n                let note_packed_len = <$typ as Packable>::N;\n                std::static_assert(note_packed_len <= $max_note_packed_len, f\"{note_type_name} has a packed length of {note_packed_len} fields, which exceeds the maximum allowed length of {max_note_packed_len} fields\");\n\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullification: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullification: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::traits::Packable::pack(self).concat( [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::context::PrivateContext,\n                note_hash_for_nullification: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullification, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullification: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullification, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _, _)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates the core note functionality for a struct:\n///\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - NoteHash trait implementation: Handles note hash and nullifier computation\n///\n/// # Requirements\n///\n/// The note struct must:\n/// - Have an `owner` field\n/// - Implement the `Packable` trait\n/// - Not exceed `MAX_NOTE_PACKED_LEN` when packed\n///\n/// # Registration\n///\n/// Registers the note in the global `NOTES` BoundedVec to enable note processing functionality.\n///\n/// # Generated Code\n///\n/// For detailed documentation on the generated implementations, see:\n/// - `generate_note_properties()`\n/// - `generate_note_type_impl()`\n/// - `generate_note_hash_trait_impl()`\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n    assert_has_packable(s);\n\n    // We register the note in the global `NOTES` BoundedVec because we need that information inside the #[aztec] macro\n    // to generate note processing functionality.\n    NOTES.push(s.as_type());\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_type_impl = generate_note_type_impl(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n\n    quote {\n        $note_properties\n        $note_type_impl\n        $note_hash_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n///\n/// # Requirements\n///\n/// The note struct must:\n/// - Implement the `Packable` trait\n/// - Not exceed `MAX_NOTE_PACKED_LEN` when packed\n///\n/// Unlike the `#[note]` macro, there is no requirement for an `owner` field.\n///\n/// # Registration\n///\n/// Registers the note in the global `NOTES` BoundedVec to enable note processing functionality.\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    assert_has_packable(s);\n\n    // We register the note in the global `NOTES` BoundedVec because we need that information inside the #[aztec] macro\n    // to generate note processing functionality.\n    NOTES.push(s.as_type());\n\n    let note_type_id = get_next_note_type_id();\n    let note_properties = generate_note_properties(s);\n    let note_type_impl = generate_note_type_impl(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_type_impl\n    }\n}\n\n/// Asserts that the given note implements the `Packable` trait.\n///\n/// We require that notes have the `Packable` trait implemented because it is used when emitting a note in a log or as\n/// an offchain message.\ncomptime fn assert_has_packable(note: TypeDefinition) {\n    let packable_constraint =\n        quote { crate::protocol_types::traits::Packable }.as_trait_constraint();\n    let note_name = note.name();\n\n    assert(\n        note.as_type().implements(packable_constraint),\n        f\"{note_name} does not implement Packable trait. Either implement it manually or place #[derive(Packable)] on the note struct before #[note] macro invocation.\",\n    );\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    let note_name = note.name();\n\n    assert(\n        has_owner,\n        f\"{note_name} does not have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "113": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/macros/storage.nr",
      "source": "use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract should have this macro (or `storage_no_init`) applied to it, and the\n/// struct has to be called 'Storage'.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    let struct_name = s.name();\n    if struct_name != quote { Storage } {\n        panic(\n            f\"The #[storage] macro can only be applied to a struct with name 'Storage', got '{struct_name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage_no_init\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ, _) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot });\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields = storage_layout_fields.push_back(\n            quote { pub $name: dep::aztec::state_vars::storage::Storable },\n        );\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::state_vars::storage::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract can have this macro (or storage_no_init) applied to it, and the struct\n/// has to be called 'Storage'.\npub comptime fn storage_no_init(s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n\n    // We do need to make sure that the type is called Storage, since we'll do `Storage::init` later on.\n\n    if s.name() != quote { Storage } {\n        let name = s.name();\n        panic(\n            f\"The #[storage_no_init] macro can only be applied to a struct with name 'Storage', got '{name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(typ: Type, slot: Quoted) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    let constructor = if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot });\n\n        quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }\n    } else {\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        quote { $struct_name::new(context, $slot)}\n    };\n\n    (constructor, get_storage_size(typ))\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n"
    },
    "115": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod private_events;\npub mod private_notes;\npub mod process_message;\n\nuse crate::{\n    messages::{\n        discovery::{\n            private_notes::MAX_NOTE_PACKED_LEN, process_message::process_message_ciphertext,\n        },\n        processing::{\n            get_private_logs, pending_tagged_log::PendingTaggedLog,\n            validate_enqueued_notes_and_events,\n        },\n    },\n    utils::array,\n};\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, note nonce, storage slot and note\n/// type ID and attempts to compute its note hash (not hashed by note nonce nor siloed by address) and inner nullifier\n/// (not siloed by address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, note_nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullification = aztec::note::utils::compute_note_hash_for_nullification(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(note_nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullification);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\npub type ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* note nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private logs are downloaded and inspected to find new private\n/// notes, partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Note that the state is synchronized up to the latest block synchronized by PXE. That should be close to the chain\n/// tip as block synchronization is performed before contract function simulation is done.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    // First we process all private logs, which can contain different kinds of messages e.g. private notes, partial\n    // notes, private events, etc.\n    let mut logs = get_private_logs(contract_address);\n    logs.for_each(|i, pending_tagged_log: PendingTaggedLog| {\n        debug_log_format(\n            \"Processing log with tag {0}\",\n            [pending_tagged_log.log.get(0)],\n        );\n\n        // We remove the tag from the pending tagged log and process the message ciphertext contained in it.\n        let message_ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n        process_message_ciphertext(\n            contract_address,\n            compute_note_hash_and_nullifier,\n            message_ciphertext,\n            pending_tagged_log.context,\n        );\n        logs.remove(i);\n    });\n\n    // Then we process all pending partial notes, regardless of whether they were found in the current or previous\n    // executions.\n    partial_notes::fetch_and_process_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    // Finally we validate all notes and events that were found as part of the previous processes, resulting in them\n    // being added to PXE's database and retrievable via oracles (get_notes) and our TS API (PXE::getPrivateEvents).\n    validate_enqueued_notes_and_events(contract_address);\n}\n"
    },
    "116": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub note_nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given note nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    note_nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Found valid nonces for a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullification,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        note_nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullification = compute_note_hash_for_nullification(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(note_nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullification);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        note_nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let note_nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(note_nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash = compute_unique_note_hash(\n            note_nonce,\n            compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash),\n        );\n        let inner_nullifier = note.compute_nullifier_unconstrained(\n            compute_note_hash_for_nullification(retrieved_note, STORAGE_SLOT),\n        );\n\n        NoteAndData { note, note_nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.note_nonce, note_and_data.note_nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == first_note_and_data.note_nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == second_note_and_data.note_nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "117": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::{\n            enqueue_note_for_validation, get_pending_partial_notes_completion_logs,\n            log_retrieval_response::LogRetrievalResponse,\n        },\n    },\n    utils::array,\n};\n\nuse protocol_types::{\n    address::AztecAddress,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for logs that would result in the completion of pending partial notes, ultimately resulting in the notes\n/// being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    // Each of the pending partial notes might get completed by a log containing its public values. For performance\n    // reasons, we fetch all of these logs concurrently and then process them one by one, minimizing the amount of time\n    // waiting for the node roundtrip.\n    let maybe_completion_logs =\n        get_pending_partial_notes_completion_logs(contract_address, pending_partial_notes);\n\n    // Each entry in the maybe completion logs array corresponds to the entry in the pending partial notes array at the\n    // same index. This means we can use the same index as we iterate through the responses to get both the partial note\n    // and the log that might complete it.\n    assert_eq(maybe_completion_logs.len(), pending_partial_notes.len());\n\n    maybe_completion_logs.for_each(|i, maybe_log: Option<LogRetrievalResponse>| {\n        // We clear the completion logs as we read them so that the array is empty by the time we next query it.\n        // TODO(#14943): use volatile arrays to avoid having to manually clear this.\n        maybe_completion_logs.remove(i);\n\n        let pending_partial_note = pending_partial_notes.get(i);\n\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log plaintext to get\n            // the complete packed content.\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                log.log_payload,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            // TODO(#11627): is there anything reasonable we can do if we get a log but it doesn't result in a note\n            // being found?\n            if discovered_notes.len() == 0 {\n                panic(\n                    f\"A partial note's completion log did not result in any notes being found - this should never happen\",\n                );\n            }\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                enqueue_note_for_validation(\n                    contract_address,\n                    pending_partial_note.storage_slot,\n                    discovered_note.note_nonce,\n                    complete_packed_note,\n                    discovered_note.note_hash,\n                    discovered_note.inner_nullifier,\n                    log.tx_hash,\n                    pending_partial_note.recipient,\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
    },
    "118": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/discovery/private_events.nr",
      "source": "use crate::{\n    event::event_selector::EventSelector,\n    messages::{encoding::MAX_MESSAGE_CONTENT_LEN, processing::enqueue_event_for_validation},\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::GENERATOR_INDEX__EVENT_COMMITMENT,\n    hash::poseidon2_hash_with_separator_bounded_vec, traits::FromField,\n};\n\n/// The number of fields in a private event message content that are not the event's serialized representation\n/// (1 field for randomness).\nglobal PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of an event's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, randomness, etc.).\npub global MAX_EVENT_SERIALIZED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN;\n\npub unconstrained fn process_private_event_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n) {\n    // In the case of events, the msg metadata is the event selector.\n    let event_type_id = EventSelector::from_field(msg_metadata as Field);\n\n    assert(\n        msg_content.len() > PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n        f\"Invalid private event message: all private event messages must have at least {PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private event message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN\",\n    );\n\n    let serialized_event_with_randomness = msg_content;\n\n    let event_commitment = poseidon2_hash_with_separator_bounded_vec(\n        serialized_event_with_randomness,\n        GENERATOR_INDEX__EVENT_COMMITMENT,\n    );\n\n    // Randomness was injected into the event payload in `emit_event_in_private` but we have already used it\n    // to compute the event commitment, so we can safely discard it now.\n    let serialized_event = array::subbvec(\n        serialized_event_with_randomness,\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n    );\n\n    enqueue_event_for_validation(\n        contract_address,\n        event_type_id,\n        serialized_event,\n        event_commitment,\n        tx_hash,\n        recipient,\n    );\n}\n"
    },
    "119": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::enqueue_note_for_validation,\n    },\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\n// See the call to `std::static_assert` below to see what's in these fields.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        enqueue_note_for_validation(\n            contract_address,\n            storage_slot,\n            discovered_note.note_nonce,\n            packed_note,\n            discovered_note.note_hash,\n            discovered_note.inner_nullifier,\n            tx_hash,\n            recipient,\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u16 {\n    fn from(value: u8) -> u16 {\n        value as u16\n    }\n}\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u16> for u32 {\n    fn from(value: u16) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u16> for u64 {\n    fn from(value: u16) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u16> for u128 {\n    fn from(value: u16) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u16> for Field {\n    fn from(value: u16) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i16 {\n    fn from(value: i8) -> i16 {\n        value as i16\n    }\n}\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i16> for i32 {\n    fn from(value: i16) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\n\nimpl From<i16> for i64 {\n    fn from(value: i16) -> i64 {\n        value as i64\n    }\n}\n\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u16 {\n    fn from(value: bool) -> u16 {\n        value as u16\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for u128 {\n    fn from(value: bool) -> u128 {\n        value as u128\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i16 {\n    fn from(value: bool) -> i16 {\n        value as i16\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            let body = if type1 == type2 {\n                quote { self }\n            } else if type1 == quote { bool } {\n                quote { self != 0 }\n            } else {\n                quote { self as $type1 }\n            };\n\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        $body\n                    }\n                }\n            },\n            );\n        }\n    }\n\n    let u_types =\n        [quote { bool }, quote { u8 }, quote { u16 }, quote { u32 }, quote { u64 }, quote { u128 }];\n\n    for type2 in u_types {\n        let body = quote { self as Field };\n\n        impls = impls.push_back(\n            quote {\n                impl AsPrimitive<Field> for $type2 {\n                    fn as_(self) -> Field {\n                        $body\n                    }\n                }\n            },\n        );\n    }\n\n    for type1 in u_types {\n        let body = if type1 == quote { bool } {\n            quote { self != 0 }\n        } else {\n            quote { self as $type1 }\n        };\n\n        impls = impls.push_back(\n            quote {\n                impl AsPrimitive<$type1> for Field {\n                    fn as_(self) -> $type1 {\n                        $body\n                    }\n                }\n            },\n        );\n    }\n\n    impls.join(quote {})\n}\n"
    },
    "120": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/discovery/process_message.nr",
      "source": "use crate::messages::{\n    discovery::{\n        ComputeNoteHashAndNullifier, partial_notes::process_partial_note_private_msg,\n        private_events::process_private_event_msg, private_notes::process_private_note_msg,\n    },\n    encoding::{decode_message, MESSAGE_CIPHERTEXT_LEN, MESSAGE_PLAINTEXT_LEN},\n    encryption::{aes128::AES128, message_encryption::MessageEncryption},\n    msg_type::{\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n    },\n    processing::message_context::MessageContext,\n};\n\nuse protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\n/// Processes a message that can contain notes, partial notes, or events.\n///\n/// Notes result in nonce discovery being performed prior to delivery, which requires knowledge of the transaction hash\n/// in which the notes would've been created (typically the same transaction in which the log was emitted), along with\n/// the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier` function. Once\n/// discovered, the notes are enqueued for validation.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\n///\n/// Events are processed by computing an event commitment from the serialized event data and its randomness field, then\n/// enqueueing the event data and commitment for validation.\npub unconstrained fn process_message_ciphertext<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_ciphertext: BoundedVec<Field, MESSAGE_CIPHERTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    process_message_plaintext(\n        contract_address,\n        compute_note_hash_and_nullifier,\n        AES128::decrypt(message_ciphertext, message_context.recipient),\n        message_context,\n    );\n}\n\npub unconstrained fn process_message_plaintext<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_plaintext: BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    // The first thing to do after decrypting the message is to determine what type of message we're processing. We\n    // have 3 message types: private notes, partial notes and events.\n\n    // We decode the message to obtain the message type id, metadata and content.\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(message_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            message_context.tx_hash,\n            message_context.unique_note_hashes_in_tx,\n            message_context.first_nullifier_in_tx,\n            message_context.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        process_private_event_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n            message_context.tx_hash,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "121": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::utils::array;\nuse protocol_types::constants::PRIVATE_LOG_CIPHERTEXT_LEN;\n\n// We reassign to the constant here to communicate the distinction between a log and a message. In Aztec.nr, unlike in\n// protocol circuits, we have a concept of a message that can be emitted either as a private log or as an offchain\n// message. Message is a piece of data that is to be eventually delivered to a contract via the `process_message(...)`\n// utility function function that is injected by the #[aztec] macro.\npub global MESSAGE_CIPHERTEXT_LEN: u32 = PRIVATE_LOG_CIPHERTEXT_LEN;\n\n// TODO(#12750): The global variables below should not be here as they are AES128 specific.\n// ciphertext_length (2) + 14 bytes pkcs#7 AES padding.\npub(crate) global HEADER_CIPHERTEXT_SIZE_IN_BYTES: u32 = 16;\n\npub global EPH_PK_X_SIZE_IN_FIELDS: u32 = 1;\npub global EPH_PK_SIGN_BYTE_SIZE_IN_BYTES: u32 = 1;\n\n// (17 - 1) * 31 - 16 - 1 = 479\nglobal MESSAGE_PLAINTEXT_SIZE_IN_BYTES: u32 = (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS)\n    * 31\n    - HEADER_CIPHERTEXT_SIZE_IN_BYTES\n    - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES;\n// Each field of the original note log was serialized to 32 bytes. Below we convert the bytes back to fields.\n// 479 / 32 = 15\npub global MESSAGE_PLAINTEXT_LEN: u32 = MESSAGE_PLAINTEXT_SIZE_IN_BYTES / 32;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MESSAGE_PLAINTEXT_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "122": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encoding::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, MESSAGE_CIPHERTEXT_LEN, MESSAGE_PLAINTEXT_LEN,\n        },\n        encryption::message_encryption::MessageEncryption,\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__message_bytes__from_PT,\n            get_arr_of_size__message_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\n/**\n * Computes N close-to-uniformly-random 256 bits from a given ECDH shared_secret.\n *\n * NEVER re-use the same iv and sym_key.\n * DO NOT call this function more than once with the same shared_secret.\n *\n * This function is only known to be safe if shared_secret is computed by combining a \n * random ephemeral key with an address point. See big comment within the body of the function.\n * See big comment within the body of the function.\n */\nfn extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [[u8; 32]; N] {\n    /*\n     * Unsafe because of https://eprint.iacr.org/2010/264.pdf Page 13, Lemma 2 (and the * two paragraphs below it).\n     *\n     * If you call this function, you need to be careful and aware of how the arg\n     * `shared_secret` has been derived.\n     *\n     * The paper says that the way you derive aes keys and IVs should be fine with poseidon2\n     * (modelled as a RO), as long as you _don't_ use Poseidon2 as a PRG to generate the * two exponents x & y which multiply to the shared secret S:\n     *\n     * S = [x*y]*G.\n     *\n     * (Otherwise, you would have to \"key\" poseidon2, i.e. generate a uniformly string K\n     * which can be public and compute Hash(x) as poseidon(K,x)).\n     * In that lemma, k would be 2*254=508, and m would be the number of points on the * grumpkin curve (which is close to r according to the Hasse bound).\n     *\n     * Our shared secret S is [esk * address_sk] * G, and the question is: * Can we compute hash(S) using poseidon2 instead of sha256?\n     *\n     * Well, esk is random and not generated with poseidon2, so that's good.\n     * What about address_sk?\n     * Well, address_sk = poseidon2(stuff) + ivsk, so there was some\n     * discussion about whether address_sk is independent of poseidon2.\n     * Given that ivsk is random and independent of poseidon2, the address_sk is also\n     * independent of poseidon2.\n     *\n     * Tl;dr: we believe it's safe to hash S = [esk * address_sk] * G using poseidon2,\n     * in order to derive a symmetric key.\n     *\n     * If you're calling this function for a differently-derived `shared_secret`, be\n     * careful.\n     *\n     */\n\n    /* The output of this function needs to be 32 random bytes.\n     * A single field won't give us 32 bytes of entropy.\n     * So we compute two \"random\" fields, by poseidon-hashing with two different\n     * generators.\n     * We then extract the last 16 (big endian) bytes of each \"random\" field.\n     * Note: we use to_be_bytes because it's slightly more efficient. But we have to\n     * be careful not to take bytes from the \"big end\", because the \"big\" byte is\n     * not uniformly random over the byte: it only has < 6 bits of randomness, because\n     * it's the big end of a 254-bit field element.\n     */\n\n    let mut all_bytes: [[u8; 32]; N] = std::mem::zeroed();\n    // We restrict N to be < 2^8, because of how we compute the domain separator\n    // from k below (where k <= N must be 8 bits). In practice, it's extremely\n    // unlikely that an app will want to compute >= 256 ciphertexts.\n    std::static_assert(N < 256, \"N too large\");\n    for k in 0..N {\n        // We augment the domain separator with the loop index, so that we can\n        // generate N lots of randomness.\n        let k_shift = (k as u16 << 8);\n        let separator_1 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY as u16;\n        let separator_2 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY_2 as u16;\n\n        let rand1: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_1);\n        let rand2: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_2);\n\n        let rand1_bytes: [u8; 32] = rand1.to_be_bytes();\n        let rand2_bytes: [u8; 32] = rand2.to_be_bytes();\n\n        let mut bytes: [u8; 32] = [0; 32];\n        for i in 0..16 {\n            // We take bytes from the \"little end\" of the be-bytes arrays:\n            let j = 32 - i - 1;\n            bytes[i] = rand1_bytes[j];\n            bytes[16 + i] = rand2_bytes[j];\n        }\n\n        all_bytes[k] = bytes;\n    }\n\n    all_bytes\n}\n\nfn derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits<let N: u32>(\n    many_random_256_bits: [[u8; 32]; N],\n) -> [([u8; 16], [u8; 16]); N] {\n    // Many (sym_key, iv) pairs:\n    let mut many_pairs: [([u8; 16], [u8; 16]); N] = std::mem::zeroed();\n    for k in 0..N {\n        let random_256_bits = many_random_256_bits[k];\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n        for i in 0..16 {\n            sym_key[i] = random_256_bits[i];\n            iv[i] = random_256_bits[i + 16];\n        }\n        many_pairs[k] = (sym_key, iv);\n    }\n\n    many_pairs\n}\n\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [([u8; 16], [u8; 16]); N] {\n    let many_random_256_bits: [[u8; 32]; N] = extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe(\n        shared_secret,\n    );\n\n    derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits(many_random_256_bits)\n}\n\npub struct AES128 {}\n\nimpl MessageEncryption for AES128 {\n    fn encrypt<let PlaintextLen: u32>(\n        plaintext: [Field; PlaintextLen],\n        recipient: AztecAddress,\n    ) -> [Field; MESSAGE_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the message in `do_process_message`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        // TODO (#17158): Currently we unwrap the Option returned by derive_ecdh_shared_secret_using_aztec_address.\n        // We need to handle the case where the ephemeral public key is invalid to prevent potential DoS vectors.\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient).unwrap();\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        // It is safe to call the `unsafe` function here, because we know the `shared_secret`\n        // was derived using an AztecAddress (the recipient). See the block comment\n        // at the start of this unsafe target function for more info.\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, body_iv, body_sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        std::static_assert(\n            ciphertext_bytes.len() == 16 * (1 + (PlaintextLen * 32) / 16),\n            \"unexpected ciphertext length\",\n        );\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, header_iv, header_sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        std::static_assert(\n            header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES,\n            \"unexpected ciphertext header length\",\n        );\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut message_bytes_padding_to_mult_31 =\n            get_arr_of_size__message_bytes_padding__from_PT::<PlaintextLen * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        message_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut message_bytes = get_arr_of_size__message_bytes__from_PT::<PlaintextLen * 32>();\n\n        std::static_assert(\n            message_bytes.len() % 31 == 0,\n            \"Unexpected error: message_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        message_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            message_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            message_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..message_bytes_padding_to_mult_31.len() {\n            message_bytes[offset + i] = message_bytes_padding_to_mult_31[i];\n        }\n        offset += message_bytes_padding_to_mult_31.len();\n\n        // Ideally we would be able to have a static assert where we check that the offset would be such that we've\n        // written to the entire log_bytes array, but we cannot since Noir does not treat the offset as a comptime\n        // value (despite the values that it goes through being known at each stage). We instead check that the\n        // computation used to obtain the offset computes the expected value (which we _can_ do in a static check), and\n        // then add a cheap runtime check to also validate that the offset matches this.\n        std::static_assert(\n            1\n                + header_ciphertext_bytes.len()\n                + ciphertext_bytes.len()\n                + message_bytes_padding_to_mult_31.len()\n                == message_bytes.len(),\n            \"unexpected message length\",\n        );\n        assert(offset == message_bytes.len(), \"unexpected encrypted message length\");\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make messages produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let message_bytes_as_fields = bytes_to_fields(message_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final message\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; MESSAGE_CIPHERTEXT_LEN] = [0; MESSAGE_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..message_bytes_as_fields.len() {\n            ciphertext[offset + i] = message_bytes_as_fields[i];\n        }\n        offset += message_bytes_as_fields.len();\n\n        for i in offset..MESSAGE_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the message\n            // (all the \"real\" message fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the message to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt(\n        ciphertext: BoundedVec<Field, MESSAGE_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, MESSAGE_PLAINTEXT_LEN> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, MESSAGE_CIPHERTEXT_LEN, MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) != 0;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret\n        // TODO(#17158): handle invalid ephemeral keys when decrypting to prevent DoS vectors\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk.unwrap());\n\n        // Derive symmetric keys:\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with messages with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext =\n            aes128_decrypt_oracle(header_ciphertext_bvec, header_iv, header_sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, body_iv, body_sym_key);\n\n        // Each field of the original note message was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::{\n            encoding::MESSAGE_PLAINTEXT_LEN, encryption::message_encryption::MessageEncryption,\n        },\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{address::AztecAddress, traits::FromField};\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt() {\n        let env = TestEnvironment::new();\n\n        // Message decryption requires oracles that are only available during private execution\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3];\n\n            let recipient = AztecAddress::from_field(\n                0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n            );\n\n            // Mock random values for deterministic test\n            let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(eph_sk).times(1);\n\n            let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(randomness).times(1000000);\n\n            let _ = OracleMock::mock(\"privateGetNextAppTagAsSender\").returns(42);\n\n            // Encrypt the message\n            let encrypted_message = BoundedVec::from_array(AES128::encrypt(plaintext, recipient));\n\n            // Mock shared secret for deterministic test\n            let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n                EmbeddedCurveScalar::from_field(eph_sk),\n                recipient,\n            );\n\n            let _ = OracleMock::mock(\"utilityGetSharedSecret\").returns(shared_secret.unwrap());\n\n            // Decrypt the message\n            let decrypted = AES128::decrypt(encrypted_message, recipient);\n\n            // The decryption function spits out a BoundedVec because it's designed to work with messages with unknown length\n            // at compile time. For this reason we need to convert the original input to a BoundedVec.\n            let plaintext_bvec = BoundedVec::<Field, MESSAGE_PLAINTEXT_LEN>::from_array(plaintext);\n\n            // Verify decryption matches original plaintext\n            assert_eq(\n                decrypted,\n                plaintext_bvec,\n                \"Decrypted bytes should match original plaintext\",\n            );\n\n            // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n            // static methods of the struct).\n            let _ = AES128 {};\n        });\n    }\n}\n"
    },
    "139": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/processing/mod.nr",
      "source": "pub(crate) mod event_validation_request;\npub mod message_context;\npub(crate) mod note_validation_request;\npub(crate) mod log_retrieval_request;\npub(crate) mod log_retrieval_response;\npub(crate) mod pending_tagged_log;\n\nuse crate::{\n    capsules::CapsuleArray,\n    event::event_selector::EventSelector,\n    messages::{\n        discovery::{\n            partial_notes::DeliveredPendingPartialNote, private_events::MAX_EVENT_SERIALIZED_LEN,\n            private_notes::MAX_NOTE_PACKED_LEN,\n        },\n        processing::{\n            log_retrieval_request::LogRetrievalRequest,\n            log_retrieval_response::LogRetrievalResponse,\n            note_validation_request::NoteValidationRequest, pending_tagged_log::PendingTaggedLog,\n        },\n    },\n    oracle,\n};\nuse event_validation_request::EventValidationRequest;\nuse protocol_types::{address::AztecAddress, hash::sha256_to_field};\n\n// Base slot for the pending tagged log array to which the fetch_tagged_logs oracle inserts found private logs.\nglobal PENDING_TAGGED_LOG_ARRAY_BASE_SLOT: Field =\n    sha256_to_field(\"AZTEC_NR::PENDING_TAGGED_LOG_ARRAY_BASE_SLOT\".as_bytes());\n\nglobal NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\n/// Searches for private logs emitted by `contract_address` that might contain messages for one of the local accounts,\n/// and stores them in a `CapsuleArray` which is then returned.\npub(crate) unconstrained fn get_private_logs(\n    contract_address: AztecAddress,\n) -> CapsuleArray<PendingTaggedLog> {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `fetchTaggedLogs`\n    // oracle. This makes PXE synchronize tags, download logs and store the pending tagged logs in a capsule array.\n    oracle::message_processing::fetch_tagged_logs(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    CapsuleArray::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT)\n}\n\n/// Enqueues a note for validation by PXE, so that it becomes aware of a note's existence allowing for later retrieval\n/// via `get_notes` oracle. The note will be scoped to `contract_address`, meaning other contracts will not be able to\n/// access it unless authorized.\n///\n/// In order for the note validation and insertion to occur, `validate_enqueued_notes_and_events` must be later called.\n/// For optimal performance, accumulate as many note validation requests as possible and then validate them all at the\n/// end (which results in PXE minimizing the number of network round-trips).\n///\n/// The `packed_note` is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\npub(crate) unconstrained fn enqueue_note_for_validation(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `NoteValidationRequest`\n    CapsuleArray::at(contract_address, NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        NoteValidationRequest {\n            contract_address,\n            storage_slot,\n            note_nonce,\n            packed_note,\n            note_hash,\n            nullifier,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Enqueues an event for validation by PXE, so that it can be efficiently validated and then inserted into the event\n/// store.\n///\n/// In order for the event validation and insertion to occur, `validate_enqueued_notes_and_events` must be later\n/// called. For optimal performance, accumulate as many event validation requests as possible and then validate them\n/// all at the end (which results in PXE minimizing the number of network round-trips).\npub(crate) unconstrained fn enqueue_event_for_validation(\n    contract_address: AztecAddress,\n    event_type_id: EventSelector,\n    serialized_event: BoundedVec<Field, MAX_EVENT_SERIALIZED_LEN>,\n    event_commitment: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `EventValidationRequest`\n    CapsuleArray::at(contract_address, EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        EventValidationRequest {\n            contract_address,\n            event_type_id,\n            serialized_event,\n            event_commitment,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Validates all note and event validation requests enqueued via `enqueue_note_for_validation` and\n/// `enqueue_event_for_validation`, inserting them into the note database and event store respectively, making them\n/// queryable via `get_notes` oracle and our TS API (PXE::getPrivateEvents).\n///\n/// This automatically clears both validation request queues, so no further work needs to be done by the caller.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(contract_address: AztecAddress) {\n    oracle::message_processing::validate_enqueued_notes_and_events(\n        contract_address,\n        NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n        EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n    );\n}\n\n/// Efficiently queries the node for logs that result in the completion of all `DeliveredPendingPartialNote`s stored in\n/// a `CapsuleArray` by performing all node communication concurrently. Returns a second `CapsuleArray` with Options for\n/// the responses that correspond to the pending partial notes at the same index.\n///\n/// For example, given an array with pending partial notes `[ p1, p2, p3 ]`, where `p1` and `p3` have corresponding\n/// completion logs but `p2` does not, the returned `CapsuleArray` will have contents\n/// `[some(p1_log), none(), some(p3_log)]`.\npub(crate) unconstrained fn get_pending_partial_notes_completion_logs(\n    contract_address: AztecAddress,\n    pending_partial_notes: CapsuleArray<DeliveredPendingPartialNote>,\n) -> CapsuleArray<Option<LogRetrievalResponse>> {\n    let log_retrieval_requests =\n        CapsuleArray::at(contract_address, LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT);\n\n    // We create a LogRetrievalRequest for each PendingPartialNote in the CapsuleArray. Because we need the indices in\n    // the request array to match the indices in the partial note array, we can't use CapsuleArray::for_each, as that\n    // function has arbitrary iteration order. Instead, we manually iterate the array from the beginning and push into\n    // the requests array, which we expect to be empty.\n    let mut i = 0;\n    let pending_partial_notes_count = pending_partial_notes.len();\n    while i < pending_partial_notes_count {\n        let pending_partial_note = pending_partial_notes.get(i);\n        log_retrieval_requests.push(\n            LogRetrievalRequest {\n                contract_address,\n                unsiloed_tag: pending_partial_note.note_completion_log_tag,\n            },\n        );\n        i += 1;\n    }\n\n    oracle::message_processing::bulk_retrieve_logs(\n        contract_address,\n        LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT,\n        LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT,\n    );\n\n    CapsuleArray::at(contract_address, LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT)\n}\n"
    },
    "151": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::{Deserialize, Packable, Serialize};\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, note_nonce: Field },\n//   Settled{ note_nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Deserialize, Eq, Serialize, Packable)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_note_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_note_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_note_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_note_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_note_nonce }\n            }\n        } else if maybe_note_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_note_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_note_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_note_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.note_nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.note_nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    note_nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    note_nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n"
    },
    "154": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().note_nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullification<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullification_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullification`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullification_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let note_nonce = retrieved_note.metadata.to_pending_previous_phase().note_nonce();\n\n        compute_unique_note_hash(note_nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullification =\n        compute_note_hash_for_nullification(retrieved_note, storage_slot);\n    let inner_nullifier =\n        retrieved_note.note.compute_nullifier(context, note_hash_for_nullification);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "158": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(privateCallPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "159": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize,\n{\n    let serialized_option = load_oracle(contract_address, slot, <T as Deserialize>::N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(utilityStoreCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(utilityLoadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(utilityDeleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(utilityCopyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), value);\n        });\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            let new_value = MockStruct::new(7, 8);\n            store(contract_address, SLOT, new_value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n        });\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n            delete(contract_address, SLOT);\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            delete(contract_address, SLOT);\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 5;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 10;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 1;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 2;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n            assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n            assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 2;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 1;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n            assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n            assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n        });\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            copy(contract_address, SLOT, SLOT, 1);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let value = MockStruct::new(5, 6);\n            store(other_contract_address, SLOT, value);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let _: Option<MockStruct> = load(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            delete(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            copy(other_contract_address, SLOT, SLOT, 0);\n        });\n    }\n}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars, true)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n    predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        let mut result = if double_predicate {\n            // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n            embedded_curve_add_unsafe(point1, point1)\n        } else {\n            let point1_1 = EmbeddedCurvePoint {\n                x: point1.x + (x_coordinates_match as Field),\n                y: point1.y,\n                is_infinite: false,\n            };\n            let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n            // point1_1 is guaranteed to have a different abscissa than point2:\n            // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n            // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n            // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n            // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n            // therefore we only want to do this if we need the result, otherwise it needs to be eliminated as a dead instruction, lest we want the circuit to fail.\n            embedded_curve_add_unsafe(point1_1, point2_1)\n        };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n    _predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    // Ensure is_infinite is comptime\n    let point1_1 = EmbeddedCurvePoint { x: point1.x, y: point1.y, is_infinite: false };\n    let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n    embedded_curve_add_unsafe(point1_1, point2_1)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2, true)[0]\n}\n"
    },
    "160": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(privateNotifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(privateNotifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(privateNotifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "161": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use crate::context::utility_context::UtilityContext;\n\n#[oracle(utilityGetUtilityContext)]\nunconstrained fn get_utility_context_oracle() -> UtilityContext {}\n\n/// Returns a utility context built from the global variables of anchor block and the contract address of the function\n/// being executed.\npub unconstrained fn get_utility_context() -> UtilityContext {\n    get_utility_context_oracle()\n}\n"
    },
    "162": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(privateStoreInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(privateLoadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "163": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(utilityGetContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\nstruct GetContractInstanceResult {\n    exists: bool,\n    member: Field,\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n\nunconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_deployer_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_class_id_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_deployer_internal_avm(address)[0] };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_class_id_internal_avm(address)[0] };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address)[0] };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "167": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr",
      "source": "use protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\nuse protocol_types::traits::{Deserialize, Serialize};\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(utilityGetPublicDataWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> PublicDataWitness {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    get_public_data_witness_oracle(block_number, public_data_tree_index)\n}\n"
    },
    "168": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(utilityGetKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "169": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(utilityGetPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] != 0 } },\n        ivpk_m: IvpkM { inner: Point { x: result[3], y: result[4], is_infinite: result[5] != 0 } },\n        ovpk_m: OvpkM { inner: Point { x: result[6], y: result[7], is_infinite: result[8] != 0 } },\n        tpk_m: TpkM { inner: Point { x: result[9], y: result[10], is_infinite: result[11] != 0 } },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n\n    #[test]\n    fn check_decompose_edge_cases() {\n        assert_eq(decompose(0), (0, 0));\n        assert_eq(decompose(TWO_POW_128 - 1), (TWO_POW_128 - 1, 0));\n        assert_eq(decompose(TWO_POW_128 + 1), (1, 1));\n        assert_eq(decompose(TWO_POW_128 * 2), (0, 2));\n        assert_eq(decompose(TWO_POW_128 * 2 + 0x1234567890), (0x1234567890, 2));\n    }\n\n    #[test]\n    fn check_decompose_large_values() {\n        let large_field = 0xffffffffffffffff;\n        let (lo, hi) = decompose(large_field);\n        assert_eq(large_field, lo + TWO_POW_128 * hi);\n\n        let large_value = large_field - TWO_POW_128;\n        let (lo2, hi2) = decompose(large_value);\n        assert_eq(large_value, lo2 + TWO_POW_128 * hi2);\n    }\n\n    #[test]\n    fn check_lt_comprehensive() {\n        assert(lt(0, 1));\n        assert(!lt(1, 0));\n        assert(!lt(0, 0));\n        assert(!lt(42, 42));\n\n        assert(lt(TWO_POW_128 - 1, TWO_POW_128));\n        assert(!lt(TWO_POW_128, TWO_POW_128 - 1));\n    }\n}\n"
    },
    "171": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/message_processing.nr",
      "source": "use protocol_types::address::AztecAddress;\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn fetch_tagged_logs(pending_tagged_log_array_base_slot: Field) {\n    fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(utilityFetchTaggedLogs)]\nunconstrained fn fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n// This must be a single oracle and not one for notes and one for events because the entire point is to validate\n// all notes and events in one go, minimizing node round-trips.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {\n    validate_enqueued_notes_and_events_oracle(\n        contract_address,\n        note_validation_requests_array_base_slot,\n        event_validation_requests_array_base_slot,\n    );\n}\n\n#[oracle(utilityValidateEnqueuedNotesAndEvents)]\nunconstrained fn validate_enqueued_notes_and_events_oracle(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {}\n\npub(crate) unconstrained fn bulk_retrieve_logs(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {\n    bulk_retrieve_logs_oracle(\n        contract_address,\n        log_retrieval_requests_array_base_slot,\n        log_retrieval_responses_array_base_slot,\n    );\n}\n\n#[oracle(utilityBulkRetrieveLogs)]\nunconstrained fn bulk_retrieve_logs_oracle(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {}\n"
    },
    "173": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::note::{note_interface::NoteType, retrieved_note::RetrievedNote};\n\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(privateNotifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(privateNotifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(privateNotifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(utilityGetNotes)]\nunconstrained fn get_notes_oracle<Note, let M: u32, let MaxNotes: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; M],\n    _select_by_offsets: [u8; M],\n    _select_by_lengths: [u8; M],\n    _select_values: [Field; M],\n    _select_comparators: [u8; M],\n    _sort_by_indexes: [u8; M],\n    _sort_by_offsets: [u8; M],\n    _sort_by_lengths: [u8; M],\n    _sort_order: [u8; M],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    // This is always set to MAX_NOTES. We need to pass it to TS in order to correctly construct the BoundedVec\n    _max_notes: u32,\n    // This is always set to <RetrievedNote<Note> as Packable>::N. We need to pass it to TS in order to be able to\n    // correctly construct the BoundedVec there.\n    _packed_retrieved_note_length: u32,\n) -> BoundedVec<[Field; <RetrievedNote<Note> as Packable>::N], MaxNotes>\nwhere\n    // TODO(https://github.com/noir-lang/noir/issues/9399): `Note: Packable` should work here.\n    RetrievedNote<Note>: Packable,\n{}\n\npub unconstrained fn get_notes<Note, let M: u32, let MaxNotes: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Option<RetrievedNote<Note>>; MaxNotes]\nwhere\n    Note: NoteType + Packable,\n{\n    let packed_retrieved_notes: BoundedVec<[Field; <RetrievedNote<Note> as Packable>::N], MaxNotes>\n         = get_notes_oracle::<Note, M, MaxNotes>(\n            storage_slot,\n            num_selects,\n            select_by_indexes,\n            select_by_offsets,\n            select_by_lengths,\n            select_values,\n            select_comparators,\n            sort_by_indexes,\n            sort_by_offsets,\n            sort_by_lengths,\n            sort_order,\n            limit,\n            offset,\n            status,\n            MaxNotes,\n            <RetrievedNote<Note> as Packable>::N,\n        );\n\n    let mut notes = BoundedVec::<_, MaxNotes>::new();\n    for i in 0..packed_retrieved_notes.len() {\n        let retrieved_note = RetrievedNote::unpack(packed_retrieved_notes.get(i));\n        notes.push(retrieved_note);\n    }\n\n    // At last we convert the bounded vector to an array of options. We do this because that is what the filter\n    // function needs to have on the output and we've decided to have the same type on the input and output of\n    // the filter and preprocessor functions.\n    //\n    // We have decided to have the same type on the input and output of the filter and preprocessor functions because\n    // it allows us to chain multiple filters and preprocessors together.\n    //\n    // So why do we want the array of options on the output of the filter function?\n    //\n    // Filter returns an array of options rather than a BoundedVec for performance reasons. Using an array of options\n    // allows setting values at known indices in the output array which is much more efficient than pushing to a\n    // BoundedVec where the write position depends on previous iterations. The array can then be efficiently converted\n    // to a BoundedVec using utils/array/collapse.nr::collapse function from Aztec.nr. This avoids expensive dynamic\n    // memory access patterns that would be required when building up a BoundedVec incrementally. For preprocessor\n    // functions we could use BoundedVec return value as there the optimization does not matter since it is applied in\n    // an unconstrained context. We, however, use the same return value type to be able to use the same function as\n    // both a preprocessor and a filter.\n    let mut notes_array = [Option::none(); MaxNotes];\n    for i in 0..notes.len() {\n        if i < notes.len() {\n            notes_array[i] = Option::some(notes.get_unchecked(i));\n        }\n    }\n\n    notes_array\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(utilityCheckNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n// TODO: Oracles below are generic private log oracles and are not specific to notes. Move them somewhere else.\n\n/// Returns the next app tag for a given sender and recipient pair.\n///\n/// This also notifies the simulator that a tag has been used in a note, and to therefore increment the\n/// associated index so that future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub unconstrained fn get_next_app_tag_as_sender(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> Field {\n    get_next_app_tag_as_sender_oracle(sender, recipient)\n}\n\n#[oracle(privateGetNextAppTagAsSender)]\nunconstrained fn get_next_app_tag_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> Field {}\n\n/// Gets the sender for tags.\n///\n/// This unconstrained value is used as the sender when computing an unconstrained shared secret\n/// for a tag in order to emit a log. Constrained tagging should not use this as there is no\n/// guarantee that the recipient knows about the sender, and hence about the shared secret.\n///\n/// The value persists through nested calls, meaning all calls down the stack will use the same\n/// 'senderForTags' value (unless it is replaced).\npub unconstrained fn get_sender_for_tags() -> Option<AztecAddress> {\n    get_sender_for_tags_oracle()\n}\n\n#[oracle(privateGetSenderForTags)]\nunconstrained fn get_sender_for_tags_oracle() -> Option<AztecAddress> {}\n\n/// Sets the sender for tags.\n///\n/// This unconstrained value is used as the sender when computing an unconstrained shared secret\n/// for a tag in order to emit a log. Constrained tagging should not use this as there is no\n/// guarantee that the recipient knows about the sender, and hence about the shared secret.\n///\n/// Account contracts typically set this value before calling other contracts. The value persists\n/// through nested calls, meaning all calls down the stack will use the same 'senderForTags'\n/// value (unless it is replaced by another call to this setter).\npub unconstrained fn set_sender_for_tags(sender_for_tags: AztecAddress) {\n    set_sender_for_tags_oracle(sender_for_tags);\n}\n\n#[oracle(privateSetSenderForTags)]\nunconstrained fn set_sender_for_tags_oracle(_sender_for_tags: AztecAddress) {}\n"
    },
    "176": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(utilityGetSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "177": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(utilityStorageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: u32,\n    length: u32,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(address.to_field(), storage_slot, block_number, N)\n}\n\npub unconstrained fn storage_read<T>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"utilityStorageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"utilityStorageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"
    },
    "178": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/version.nr",
      "source": "/// The ORACLE_VERSION constant is used to check that the oracle interface is in sync between PXE and Aztec.nr. We need\n/// to version the oracle interface to ensure that developers get a reasonable error message if they use incompatible\n/// versions of Aztec.nr and PXE. The TypeScript counterpart is in `oracle_version.ts`.\n///\n/// @dev Whenever a contract function or Noir test is run, the `utilityAssertCompatibleOracleVersion` oracle is called and\n/// if the oracle version is incompatible an error is thrown.\npub global ORACLE_VERSION: Field = 3;\n\n/// Asserts that the version of the oracle is compatible with the version expected by the contract.\npub fn assert_compatible_oracle_version() {\n    // Safety: This oracle call returns nothing: we only call it to check Aztec.nr and Oracle interface versions are\n    // compatible. It is therefore always safe to call.\n    unsafe {\n        assert_compatible_oracle_version_wrapper();\n    }\n}\n\nunconstrained fn assert_compatible_oracle_version_wrapper() {\n    assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n}\n\n#[oracle(utilityAssertCompatibleOracleVersion)]\nunconstrained fn assert_compatible_oracle_version_oracle(version: Field) {}\n\nmod test {\n    use super::{assert_compatible_oracle_version_oracle, ORACLE_VERSION};\n\n    #[test]\n    unconstrained fn compatible_oracle_version() {\n        assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n    }\n\n    #[test(should_fail_with = \"Incompatible oracle version. TXE is using version '3', but got a request for '318183437'.\")]\n    unconstrained fn incompatible_oracle_version() {\n        let arbitrary_incorrect_version = 318183437;\n        assert_compatible_oracle_version_oracle(arbitrary_incorrect_version);\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n"
    },
    "182": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::HasStorageSlot;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\n\n/// Map\n///\n/// A key-value storage container that maps keys to state variables, similar\n/// to Solidity mappings.\n///\n/// `Map` enables you to associate keys (like addresses or other identifiers)\n/// with state variables in your Aztec smart contract. This is conceptually\n/// similar to Solidity's `mapping(K => V)` syntax, where you can store and\n/// retrieve values by their associated keys.\n///\n/// You can declare a state variable contained within a Map in your contract's\n/// #[storage] struct.\n///\n/// For example, you might use\n/// `Map<AztecAddress, PrivateMutable<ValueNote, Context>, Context>` to track\n/// token balances for different users, similar to how you'd use\n/// `mapping(address => uint256)` in Solidity.\n///\n/// > Aside: the verbose `Context` in the declaration is a consequence of\n/// > leveraging Noir's regular syntax for generics to ensure that certain\n/// > state variable methods can only be called in some contexts (private,\n/// > public, utility).\n///\n/// The methods of Map are:\n/// - `at` (access state variable for a given key)\n/// (see the method's own doc comments for more info).\n///\n/// ## Generic Parameters\n/// - `K`: The key type (must implement `ToField` trait for hashing)\n/// - `V`: The value type:\n///   - any Aztec state variable:\n///     - `PublicMutable`\n///     - `PublicImmutable`\n///     - `PrivateMutable`\n///     - `PrivateImmutable`\n///     - `PrivateSet`\n///     - `DelayedPublicMutable`\n///     - `Map`\n/// - `Context`: The execution context (handles private/public function\n///   contexts)\n///\n/// ## Usage\n/// Maps are typically declared in your contract's #[storage] struct and\n/// accessed\n/// using the `at(key)` method to get the state variable for a specific key.\n/// The resulting state variable can then be read from or written to using its\n/// own methods.\n///\n/// ## Advanced\n/// Internally, `Map` uses a single base storage slot to represent the\n/// mapping\n/// itself, similar to Solidity's approach. Individual key-value pairs are\n/// stored at derived storage slots computed by hashing the base storage\n/// slot\n/// with the key using Poseidon2. This ensures:\n/// - No storage slot collisions between different keys\n/// - Uniform distribution of storage slots across the storage space\n/// - Compatibility with Aztec's storage tree structure\n/// - Gas-efficient storage access patterns similar to Solidity mappings\n///\n/// The storage slot derivation uses `derive_storage_slot_in_map(base_slot,\n/// key)` which computes `poseidon2_hash([base_slot, key.to_field()])`,\n/// ensuring cryptographically secure slot separation.\n///\n/// docs:start:map\npub struct Map<K, V, Context> {\n    pub context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n\n// Map reserves a single storage slot regardless of what it stores because\n// nothing is stored at said slot: it is only used to derive the storage slots\n// of nested state variables, which is expected to never result in collisions\n// or slots being close to one another due to these being hashes. This mirrors\n// the strategy adopted by Solidity mappings.\nimpl<K, T, Context> HasStorageSlot<1> for Map<K, T, Context> {\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    /// Initializes a new Map state variable.\n    ///\n    /// This function is usually automatically called within the #[storage]\n    /// macro.\n    /// You typically don't need to call this directly when writing smart contracts.\n    ///\n    /// # Arguments\n    ///\n    /// * `context` - One of `PrivateContext`/`PublicContext`/`UtilityContext`.\n    ///               The Context determines which methods of this struct will\n    ///               be made available to the calling smart contract function.\n    /// * `storage_slot` - A unique identifier for this Map within the contract.\n    ///                    Usually, the #[storage] macro will determine an\n    ///                    appropriate storage_slot automatically. A smart\n    ///                    contract dev shouldn't have to worry about this, as\n    ///                    it's managed behind the scenes.\n    /// * `state_var_constructor` - A function that creates the value type (V)\n    ///                             given a context and storage slot. This is\n    ///                             typically the constructor of the state\n    ///                             variable type being stored in the Map.\n    ///\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n\n    /// Returns the state variable associated with the given key.\n    ///\n    /// This is equivalent to accessing `mapping[key]` in Solidity. It returns\n    /// the state variable instance for the specified key, which can then be\n    /// used to read or write the value at that key.\n    ///\n    /// Unlike Solidity mappings which return the value directly, this returns\n    /// the state variable wrapper (like PrivateMutable, PublicMutable, etc.)\n    /// that you then call methods on to interact with the actual value.\n    ///\n    /// # Arguments\n    ///\n    /// * `key` - The key to look up in the map. Must implement the ToField\n    ///           trait (which most basic Noir & Aztec types do).\n    ///\n    /// # Returns\n    ///\n    /// * `V` - The state variable instance for this key. You can then call\n    ///         methods like `.read()`, `.write()`, `.get_note()`, etc. on this\n    ///         depending on the specific state variable type.\n    ///\n    /// # Example\n    ///\n    /// ```noir\n    /// // Get a user's balance (assuming PrivateMutable<ValueNote>)\n    /// let user_balance = storage.balances.at(user_address);\n    /// let current_note = user_balance.get_note();\n    ///\n    /// // Update the balance\n    /// user_balance.replace(new_note);\n    /// ```\n    ///\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n}\n"
    },
    "19": {
      "path": "std/hash/mod.nr",
      "source": "// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"
    },
    "190": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr",
      "source": "use crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::storage::HasStorageSlot,\n    utils::with_hash::WithHash,\n};\nuse protocol_types::{\n    constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator,\n    traits::Packable,\n};\n\n/// # PublicImmutable\n///\n/// PublicImmutable is a public state variable type for values that are set once\n/// during initialization and remain permanently unchanged.\n///\n/// You can declare a state variable of type PublicImmutable within your contract's\n/// #[storage] struct:\n///\n/// E.g.:\n/// `your_variable: PublicImmutable<T, Context>`\n///\n/// PublicImmutable stores an immutable value in public state which can be _read_\n/// from public, utility and even _private_ execution contexts.\n///\n/// The methods of PublicImmutable are:\n/// - `initialize`\n/// - `read`\n/// (see the methods' own doc comments for more info).\n///\n/// # Generic Parameters:\n///\n/// * `T` - The type of value stored (must implement Packable).\n/// * `Context` - The execution context (PublicContext, PrivateContext, or UtilityContext).\n///\n/// # Advanced\n///\n/// PublicImmutable leverages `WithHash<T>` to enable efficient private reads of\n/// public storage. The `WithHash` wrapper optimizes reads by hashing values that would\n/// be larger than a single field into a single field, then proving inclusion of only\n/// the hash in public storage.\n///\n/// This optimization is particularly valuable when T packs to multiple fields,\n/// as it maintains \"almost constant\" verification overhead regardless of the\n/// original data size.\n///\n/// ## Optimizing private reads in your contract\n/// Since reading T from public immutable storage in private contexts has \"almost\n/// constant\" constraint costs regardless of T's size, it's recommended to group\n/// multiple values into a single struct when they are to be read together. This is\n/// typically useful for configuration data set during contract initialization. E.g.:\n///\n/// ```noir\n/// use dep::aztec::protocol_types::{address::AztecAddress, traits::Packable};\n/// use std::meta::derive;\n///\n/// #[derive(Eq, Packable)]\n/// pub struct Config \\{\n///     pub address_1: AztecAddress,\n///     pub value_1: u128,\n///     pub value_2: u64,\n///     ...\n/// }\n/// ```\n///\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\n/// `PublicImmutable` stores both the packed value (using M fields) and its hash (1 field), requiring M + 1 total\n/// fields.\nimpl<T, Context, let M: u32> HasStorageSlot<M + 1> for PublicImmutable<T, Context>\nwhere\n    T: Packable<N = M>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    /// Initializes a new PublicImmutable state variable.\n    ///\n    /// This function is usually automatically called within the #[storage] macro.\n    /// You typically don't need to call this directly when writing smart contracts.\n    ///\n    /// # Arguments\n    ///\n    /// * `context` - One of `PublicContext`/`PrivateContext`/`UtilityContext`. The\n    ///               Context determines which methods of this struct will be made\n    ///               available to the calling smart contract function.\n    /// * `storage_slot` - A unique identifier for this state variable within the\n    ///                    contract. Usually, the #[storage] macro will determine an\n    ///                    appropriate storage_slot automatically. A smart contract\n    ///                    dev shouldn't have to worry about this, as it's managed\n    ///                    behind the scenes.\n    ///\n    /// docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n        )\n    }\n}\n\nimpl<T> PublicImmutable<T, &mut PublicContext> {\n    /// Initializes a PublicImmutable state variable instance with a permanent value.\n    ///\n    /// This function sets the immutable value for this state variable. It can only\n    /// be called once per PublicImmutable. Subsequent calls will fail because the\n    /// initialization nullifier will already exist.\n    ///\n    /// # Arguments\n    /// * `value` - The permanent value to store in this PublicImmutable.\n    ///\n    /// # Panics\n    /// Panics if the value is already initialized.\n    ///\n    /// # Advanced\n    ///\n    /// This function performs the following operations:\n    /// - Creates and emits an initialization nullifier to mark this storage slot\n    ///   as initialized. This prevents double-initialization.\n    /// - Wraps the value in `WithHash<T>` for efficient private reads.\n    /// - Stores the wrapped value in Aztec's public data tree.\n    ///\n    /// docs:start:public_immutable_struct_write\n    pub fn initialize(self, value: T)\n    where\n        T: Packable + Eq,\n    {\n        // We emit an initialization nullifier to indicate that the struct is initialized. This also prevents\n        // the value from being initialized again as a nullifier can be included only once.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        self.context.storage_write(self.storage_slot, WithHash::new(value));\n    }\n\n    /// Reads the permanent value stored in this PublicImmutable state variable.\n    ///\n    /// # Returns\n    /// * `T` - The permanent value stored in this PublicImmutable.\n    ///\n    /// # Panics\n    /// Panics if the value is not initialized.\n    ///\n    /// # Advanced\n    ///\n    /// This function performs the following operations:\n    /// - Checks that the state variable has been initialized by verifying the\n    ///   initialization nullifier exists\n    /// - Reads the `WithHash<T>` wrapper from public storage\n    /// - Extracts and returns the original value T\n    ///\n    /// The function will panic if called on an uninitialized PublicImmutable.\n    ///\n    /// docs:start:public_immutable_struct_read\n    pub fn read(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        assert(self.is_initialized(), \"Trying to read from uninitialized PublicImmutable\");\n        WithHash::public_storage_read(*self.context, self.storage_slot)\n    }\n\n    /// Reads the value stored in this PublicImmutable without checking if the value\n    /// is initialized.\n    ///\n    /// This function bypasses the initialization check and directly reads from\n    /// storage.\n    /// If the PublicImmutable has not been initialized, this will return a\n    /// zeroed value.\n    /// However, if the variable is _known_ to be initialized, this is cheaper\n    /// to call than `read`.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The value stored in this PublicImmutable, or empty/default values if\n    ///         uninitialized.\n    ///\n    pub fn read_unsafe(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        WithHash::public_storage_read(*self.context, self.storage_slot)\n    }\n\n    fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.nullifier_exists(nullifier, self.context.this_address())\n    }\n}\n\nimpl<T> PublicImmutable<T, UtilityContext> {\n    /// Reads the permanent value stored in this PublicImmutable state variable.\n    ///\n    /// Notice that this function is executable only within a UtilityContext, which\n    /// is an unconstrained environment on the user's local device.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The permanent value stored in this PublicImmutable.\n    ///\n    pub unconstrained fn read(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        // TODO(#15703): this fn should fail if the variable is not initialized\n        WithHash::utility_public_storage_read(self.context, self.storage_slot)\n    }\n}\n\nimpl<T> PublicImmutable<T, &mut PrivateContext> {\n    /// Reads the permanent value stored in this PublicImmutable from the anchor\n    /// block.\n    ///\n    /// Private functions execute asynchronously and offchain. When a user begins\n    /// private execution, their view of the chain 'branches off' from the current\n    /// public state, since public state continues to advance while they execute\n    /// privately. Therefore, private functions read from a historical snapshot of\n    /// public state rather than the current state.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The permanent value stored in this PublicImmutable at the historical\n    ///         block referenced by the private context.\n    ///\n    /// # Advanced\n    ///\n    /// This function performs a historical read using the block header from the private\n    /// context. The `WithHash` optimization is particularly valuable here because it\n    /// reduces the number of required inclusion proofs by proving membership of\n    /// only the hash instead of the full packed value.\n    ///\n    /// The historical read mechanism:\n    /// - Uses an oracle to obtain the value from the anchor block\n    /// - Proves inclusion of the value's hash in the public data tree\n    /// - Proves that the root of this public data tree is correct, relative to the\n    ///   anchor block header.\n    /// - Verifies that the oracle-provided value matches the stored hash\n    ///\n    pub fn read(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        // TODO(#15703): this fn should fail if the variable is not initialized\n        WithHash::historical_public_storage_read(\n            self.context.get_anchor_block_header(),\n            self.context.this_address(),\n            self.storage_slot,\n        )\n    }\n}\n"
    },
    "192": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr",
      "source": "use crate::context::{PublicContext, UtilityContext};\nuse crate::state_vars::storage::HasStorageSlot;\nuse dep::protocol_types::traits::Packable;\n\n/// # PublicMutable\n///\n/// PublicMutable is a public state variable type for values that can be read\n/// and written within #[external(\"public\")] functions of your smart contract.\n///\n/// You can declare a state variable of type PublicMutable within your contract's\n/// #[storage] struct:\n///\n/// E.g.:\n/// `your_variable: PublicMutable<T, Context>`\n/// or:\n/// `your_mapping: Map<Field, PublicMutable<T, Context>>`\n///\n/// The methods of PublicMutable are:\n/// - `read`\n/// - `write`\n/// (see the methods' own doc comments for more info).\n///\n/// ## Example.\n///\n/// A voting contract's proposal count can be represented as a PublicMutable<u64>.\n/// The count can be read by anyone to see how many proposals exist, and incremented\n/// when new proposals are submitted.\n///\n/// # Generic Parameters:\n///\n/// * `T` - The type of value stored (must implement Packable).\n/// * `Context` - The execution context (PublicContext or UtilityContext).\n///\n/// # Advanced\n///\n/// Unlike private state variables which use notes, PublicMutable stores values\n/// directly in Aztec's public data tree. This enables direct read and write\n/// access to the current state during public function execution.\n///\n/// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\nimpl<T, Context, let M: u32> HasStorageSlot<M> for PublicMutable<T, Context>\nwhere\n    T: Packable<N = M>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    /// Initializes a new PublicMutable state variable.\n    ///\n    /// This function is usually automatically called within the #[storage] macro.\n    /// You typically don't need to call this directly when writing smart contracts.\n    ///\n    /// # Arguments\n    ///\n    /// * `context` - One of `PublicContext`/`UtilityContext`. The Context determines\n    ///               which methods of this struct will be made available to the calling\n    ///               smart contract function.\n    /// * `storage_slot` - A unique identifier for this state variable within the\n    ///                    contract. Usually, the #[storage] macro will determine an\n    ///                    appropriate storage_slot automatically. A smart contract\n    ///                    dev shouldn't have to worry about this, as it's managed\n    ///                    behind the scenes.\n    ///\n    /// docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n}\n\nimpl<T> PublicMutable<T, &mut PublicContext> {\n    /// Reads the current value stored in this PublicMutable state variable.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The current value stored in this PublicMutable.\n    ///\n    /// docs:start:public_mutable_struct_read\n    pub fn read(self) -> T\n    where\n        T: Packable,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n\n    /// Writes a new value to this PublicMutable state variable.\n    ///\n    /// # Arguments\n    ///\n    /// * `value` - The new value to store in this PublicMutable.\n    ///\n    /// # Advanced\n    ///\n    /// This function updates the value stored in Aztec's public data tree.\n    /// The new value becomes immediately available to subsequent reads within\n    /// the same transaction.\n    ///\n    /// docs:start:public_mutable_struct_write\n    pub fn write(self, value: T)\n    where\n        T: Packable,\n    {\n        self.context.storage_write(self.storage_slot, value);\n    }\n}\n\nimpl<T> PublicMutable<T, UtilityContext> {\n    /// Reads the current value stored in this PublicMutable state variable.\n    ///\n    /// Notice that this function is executable only within a UtilityContext, which\n    /// is an unconstrained environment on the user's local device.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The current value stored in this PublicMutable.\n    ///\n    pub unconstrained fn read(self) -> T\n    where\n        T: Packable,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"
    },
    "212": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends the elements of the second `BoundedVec` to the end of the first one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let ALen: u32, let BLen: u32, let DstLen: u32>(\n    a: BoundedVec<T, ALen>,\n    b: BoundedVec<T, BLen>,\n) -> BoundedVec<T, DstLen> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "215": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DstLen` elements from a source array, starting at `offset`. `DstLen` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SrcLen: u32, let DstLen: u32>(src: [T; SrcLen], offset: u32) -> [T; DstLen] {\n    assert(offset + DstLen <= SrcLen, \"DstLen too large for offset\");\n\n    let mut dst: [T; DstLen] = std::mem::zeroed();\n    for i in 0..DstLen {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DstLen to be 0, so we always get back an empty array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "216": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DstMaxLen` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DstLen` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DstLen` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SrcMaxLen: u32, let DstMaxLen: u32>(\n    bvec: BoundedVec<T, SrcMaxLen>,\n    offset: u32,\n) -> BoundedVec<T, DstMaxLen> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "218": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "219": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "222": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use protocol_types::{point::Point, utils::field::sqrt};\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\n/// Returns a `Point` in the Grumpkin curve given its x coordinate.\n///\n/// Because not all values in the field are valid x coordinates of points in the curve (i.e. there\n/// is no corresponding y value in the field that satisfies the curve equation), it may not be\n/// possible to reconstruct a `Point`. `Option::none()` is returned in such cases.\npub fn point_from_x_coord(x: Field) -> Option<Point> {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    sqrt(rhs).map(|y| Point { x, y, is_infinite: false })\n}\n\n/// Returns a `Point` in the Grumpkin curve given its x coordinate and sign for the y coordinate.\n///\n/// Because not all values in the field are valid x coordinates of points in the curve (i.e. there\n/// is no corresponding y value in the field that satisfies the curve equation), it may not be\n/// possible to reconstruct a `Point`. `Option::none()` is returned in such cases.\n///\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Option<Point> {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n\n    sqrt(rhs).map(|y| {\n        // If there is a square root, we need to ensure it has the correct \"sign\"\n        let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n        let final_y = if y_is_positive == sign { y } else { -y };\n        Point { x, y: final_y, is_infinite: false }\n    })\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord, point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n    use dep::protocol_types::utils::field::pow;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign).unwrap();\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2).unwrap();\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_valid() {\n        // x = 8 is a known quadratic residue - should give a valid point\n        let result = point_from_x_coord(Field::from(8));\n        assert(result.is_some());\n\n        let point = result.unwrap();\n        assert_eq(point.x, Field::from(8));\n        // Check curve equation y^2 = x^3 - 17\n        assert_eq(pow(point.y, 2), pow(point.x, 3) - 17);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_invalid() {\n        // x = 3 is a non-residue for this curve - should give None\n        let x = Field::from(3);\n        let maybe_point = point_from_x_coord(x);\n        assert(maybe_point.is_none());\n    }\n\n}\n"
    },
    "226": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr",
      "source": "use crate::{\n    context::{PublicContext, UtilityContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    abis::block_header::BlockHeader, address::AztecAddress, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `M` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `M`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let M: u32> {\n    value: T,\n    packed: [Field; M],\n    hash: Field,\n}\n\nimpl<T, let M: u32> WithHash<T, M>\nwhere\n    T: Packable<N = M> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn utility_public_storage_read(\n        context: UtilityContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + M as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\n// Note: I don't derive Packable on `WithHash` because `derive_serialize` function does not support setting \"N = M\"\n// as I do here 3 lines below. This could be worked around by placing the \"where\" clause directly on the `WithHash`\n// struct, but Jake mentioned that the syntax is not expected to be supported at least until Noir 1.0.\n// Relevant discussion on Slack:\n// https://aztecprotocol.slack.com/archives/C04QF64EDNV/p1752593876160699?thread_ts=1752589887.955379&cid=C04QF64EDNV\nimpl<T, let M: u32> Packable for WithHash<T, M>\nwhere\n    T: Packable<N = M>,\n{\n    let N: u32 = M + 1;\n\n    fn pack(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n        for i in 0..M {\n            result[i] = self.packed[i];\n        }\n        result[M] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; Self::N]) -> Self {\n        let mut value_packed = [0; M];\n        for i in 0..M {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[M];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::test::OracleMock;\n\n    global STORAGE_SLOT: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let env = TestEnvironment::new();\n\n        env.private_context(|context| {\n            let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n                context.anchor_block_header,\n                context.this_address(),\n                STORAGE_SLOT,\n            );\n\n            assert_eq(result, std::mem::zeroed());\n        });\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        env.public_context(|context| { context.storage_write(STORAGE_SLOT, value_with_hash); });\n\n        env.private_context(|context| {\n            let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n                context.anchor_block_header,\n                context.this_address(),\n                STORAGE_SLOT,\n            );\n            assert_eq(result, value);\n        });\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn bad_hint_uninitialized_value() {\n        let env = TestEnvironment::new();\n\n        env.private_context(|context| {\n            let block_header = context.anchor_block_header;\n            let address = context.this_address();\n\n            // Mock the oracle to return a non-zero hint/packed value\n            let value_packed = MockStruct { a: 1, b: 1 }.pack();\n            let _ = OracleMock::mock(\"utilityStorageRead\")\n                .with_params((\n                    address.to_field(), STORAGE_SLOT, block_header.global_variables.block_number,\n                    value_packed.len(),\n                ))\n                .returns(value_packed)\n                .times(1);\n\n            // This should fail because the hint value is non-zero and the hash is zero (default value of storage)\n            let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n                block_header,\n                address,\n                STORAGE_SLOT,\n            );\n        });\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn bad_hint_initialized_value() {\n        let env = TestEnvironment::new();\n\n        env.public_context(|context| {\n            // Write the value and hash separately so that the hash is wrong\n            let value = MockStruct { a: 5, b: 3 };\n            context.storage_write(STORAGE_SLOT, value);\n\n            let incorrect_hash = 13;\n            let hash_storage_slot = STORAGE_SLOT + (value.pack().len() as Field);\n            context.storage_write(hash_storage_slot, [incorrect_hash]);\n        });\n\n        env.private_context(|context| {\n            let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n                context.anchor_block_header,\n                context.this_address(),\n                STORAGE_SLOT,\n            );\n        });\n    }\n}\n"
    },
    "233": {
      "path": "/home/jpag/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr",
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "25": {
      "path": "std/meta/expr.nr",
      "source": "//! Contains methods on the built-in `Expr` type for quoted, syntactically valid expressions.\n\nuse crate::meta::op::BinaryOp;\nuse crate::meta::op::UnaryOp;\nuse crate::option::Option;\n\nimpl Expr {\n    /// If this expression is an array literal `[elem1, ..., elemN]`, this returns a slice of each element in the array.\n    #[builtin(expr_as_array)]\n    // docs:start:as_array\n    pub comptime fn as_array(self) -> Option<[Expr]> {}\n    // docs:end:as_array\n\n    /// If this expression is an assert, this returns the assert expression and the optional message.\n    #[builtin(expr_as_assert)]\n    // docs:start:as_assert\n    pub comptime fn as_assert(self) -> Option<(Expr, Option<Expr>)> {}\n    // docs:end:as_assert\n\n    /// If this expression is an assert_eq, this returns the left-hand-side and right-hand-side\n    /// expressions, together with the optional message.\n    #[builtin(expr_as_assert_eq)]\n    // docs:start:as_assert_eq\n    pub comptime fn as_assert_eq(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_assert_eq\n\n    /// If this expression is an assignment, this returns a tuple with the left hand side\n    /// and right hand side in order.\n    #[builtin(expr_as_assign)]\n    // docs:start:as_assign\n    pub comptime fn as_assign(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_assign\n\n    /// If this expression is a binary operator operation `<lhs> <op> <rhs>`,\n    /// return the left-hand side, operator, and the right-hand side of the operation.\n    #[builtin(expr_as_binary_op)]\n    // docs:start:as_binary_op\n    pub comptime fn as_binary_op(self) -> Option<(Expr, BinaryOp, Expr)> {}\n    // docs:end:as_binary_op\n\n    /// If this expression is a block `{ stmt1; stmt2; ...; stmtN }`, return\n    /// a slice containing each statement.\n    #[builtin(expr_as_block)]\n    // docs:start:as_block\n    pub comptime fn as_block(self) -> Option<[Expr]> {}\n    // docs:end:as_block\n\n    /// If this expression is a boolean literal, return that literal.\n    #[builtin(expr_as_bool)]\n    // docs:start:as_bool\n    pub comptime fn as_bool(self) -> Option<bool> {}\n    // docs:end:as_bool\n\n    /// If this expression is a cast expression `expr as type`, returns the casted\n    /// expression and the type to cast to.\n    // docs:start:as_cast\n    #[builtin(expr_as_cast)]\n    pub comptime fn as_cast(self) -> Option<(Expr, UnresolvedType)> {}\n    // docs:end:as_cast\n\n    /// If this expression is a `comptime { stmt1; stmt2; ...; stmtN }` block,\n    /// return each statement in the block.\n    #[builtin(expr_as_comptime)]\n    // docs:start:as_comptime\n    pub comptime fn as_comptime(self) -> Option<[Expr]> {}\n    // docs:end:as_comptime\n\n    /// If this expression is a constructor `Type { field1: expr1, ..., fieldN: exprN }`,\n    /// return the type and the fields.\n    #[builtin(expr_as_constructor)]\n    // docs:start:as_constructor\n    pub comptime fn as_constructor(self) -> Option<(UnresolvedType, [(Quoted, Expr)])> {}\n    // docs:end:as_constructor\n\n    /// If this expression is a for statement over a single expression, return the identifier,\n    /// the expression and the for loop body.\n    #[builtin(expr_as_for)]\n    // docs:start:as_for\n    pub comptime fn as_for(self) -> Option<(Quoted, Expr, Expr)> {}\n    // docs:end:as_for\n\n    /// If this expression is a for statement over a range, return the identifier,\n    /// the range start, the range end and the for loop body.\n    #[builtin(expr_as_for_range)]\n    // docs:start:as_for_range\n    pub comptime fn as_for_range(self) -> Option<(Quoted, Expr, Expr, Expr)> {}\n    // docs:end:as_for_range\n\n    /// If this expression is a function call `foo(arg1, ..., argN)`, return\n    /// the function and a slice of each argument.\n    #[builtin(expr_as_function_call)]\n    // docs:start:as_function_call\n    pub comptime fn as_function_call(self) -> Option<(Expr, [Expr])> {}\n    // docs:end:as_function_call\n\n    /// If this expression is an `if condition { then_branch } else { else_branch }`,\n    /// return the condition, then branch, and else branch. If there is no else branch,\n    /// `None` is returned for that branch instead.\n    #[builtin(expr_as_if)]\n    // docs:start:as_if\n    pub comptime fn as_if(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_if\n\n    /// If this expression is an index into an array `array[index]`, return the\n    /// array and the index.\n    #[builtin(expr_as_index)]\n    // docs:start:as_index\n    pub comptime fn as_index(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_index\n\n    /// If this expression is an integer literal, return the integer as a field\n    /// as well as whether the integer is negative (true) or not (false).\n    #[builtin(expr_as_integer)]\n    // docs:start:as_integer\n    pub comptime fn as_integer(self) -> Option<(Field, bool)> {}\n    // docs:end:as_integer\n\n    /// If this expression is a lambda, returns the parameters, return type and body.\n    #[builtin(expr_as_lambda)]\n    // docs:start:as_lambda\n    pub comptime fn as_lambda(\n        self,\n    ) -> Option<([(Expr, Option<UnresolvedType>)], Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_lambda\n\n    /// If this expression is a let statement, returns the let pattern as an `Expr`,\n    /// the optional type annotation, and the assigned expression.\n    #[builtin(expr_as_let)]\n    // docs:start:as_let\n    pub comptime fn as_let(self) -> Option<(Expr, Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_let\n\n    /// If this expression is a member access `foo.bar`, return the struct/tuple\n    /// expression and the field. The field will be represented as a quoted value.\n    #[builtin(expr_as_member_access)]\n    // docs:start:as_member_access\n    pub comptime fn as_member_access(self) -> Option<(Expr, Quoted)> {}\n    // docs:end:as_member_access\n\n    /// If this expression is a method call `foo.bar::<generic1, ..., genericM>(arg1, ..., argN)`, return\n    /// the receiver, method name, a slice of each generic argument, and a slice of each argument.\n    #[builtin(expr_as_method_call)]\n    // docs:start:as_method_call\n    pub comptime fn as_method_call(self) -> Option<(Expr, Quoted, [UnresolvedType], [Expr])> {}\n    // docs:end:as_method_call\n\n    /// If this expression is a repeated element array `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_array)]\n    // docs:start:as_repeated_element_array\n    pub comptime fn as_repeated_element_array(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_array\n\n    /// If this expression is a repeated element slice `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_slice)]\n    // docs:start:as_repeated_element_slice\n    pub comptime fn as_repeated_element_slice(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_slice\n\n    /// If this expression is a slice literal `&[elem1, ..., elemN]`,\n    /// return each element of the slice.\n    #[builtin(expr_as_slice)]\n    // docs:start:as_slice\n    pub comptime fn as_slice(self) -> Option<[Expr]> {}\n    // docs:end:as_slice\n\n    /// If this expression is a tuple `(field1, ..., fieldN)`,\n    /// return each element of the tuple.\n    #[builtin(expr_as_tuple)]\n    // docs:start:as_tuple\n    pub comptime fn as_tuple(self) -> Option<[Expr]> {}\n    // docs:end:as_tuple\n\n    /// If this expression is a unary operation `<op> <rhs>`,\n    /// return the unary operator as well as the right-hand side expression.\n    #[builtin(expr_as_unary_op)]\n    // docs:start:as_unary_op\n    pub comptime fn as_unary_op(self) -> Option<(UnaryOp, Expr)> {}\n    // docs:end:as_unary_op\n\n    /// If this expression is an `unsafe { stmt1; ...; stmtN }` block,\n    /// return each statement inside in a slice.\n    #[builtin(expr_as_unsafe)]\n    // docs:start:as_unsafe\n    pub comptime fn as_unsafe(self) -> Option<[Expr]> {}\n    // docs:end:as_unsafe\n\n    /// Returns `true` if this expression is trailed by a semicolon.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// comptime {\n    ///     let expr1 = quote { 1 + 2 }.as_expr().unwrap();\n    ///     let expr2 = quote { 1 + 2; }.as_expr().unwrap();\n    ///\n    ///     assert(expr1.as_binary_op().is_some());\n    ///     assert(expr2.as_binary_op().is_some());\n    ///\n    ///     assert(!expr1.has_semicolon());\n    ///     assert(expr2.has_semicolon());\n    /// }\n    /// ```\n    #[builtin(expr_has_semicolon)]\n    // docs:start:has_semicolon\n    pub comptime fn has_semicolon(self) -> bool {}\n    // docs:end:has_semicolon\n\n    /// Returns `true` if this expression is `break`.\n    #[builtin(expr_is_break)]\n    // docs:start:is_break\n    pub comptime fn is_break(self) -> bool {}\n    // docs:end:is_break\n\n    /// Returns `true` if this expression is `continue`.\n    #[builtin(expr_is_continue)]\n    // docs:start:is_continue\n    pub comptime fn is_continue(self) -> bool {}\n    // docs:end:is_continue\n\n    /// Applies a mapping function to this expression and to all of its sub-expressions.\n    /// `f` will be applied to each sub-expression first, then applied to the expression itself.\n    ///\n    /// This happens recursively for every expression within `self`.\n    ///\n    /// For example, calling `modify` on `(&[1], &[2, 3])` with an `f` that returns `Option::some`\n    /// for expressions that are integers, doubling them, would return `(&[2], &[4, 6])`.\n    // docs:start:modify\n    pub comptime fn modify<Env>(self, f: fn[Env](Expr) -> Option<Expr>) -> Expr {\n        // docs:end:modify\n        let result = modify_array(self, f);\n        let result = result.or_else(|| modify_assert(self, f));\n        let result = result.or_else(|| modify_assert_eq(self, f));\n        let result = result.or_else(|| modify_assign(self, f));\n        let result = result.or_else(|| modify_binary_op(self, f));\n        let result = result.or_else(|| modify_block(self, f));\n        let result = result.or_else(|| modify_cast(self, f));\n        let result = result.or_else(|| modify_comptime(self, f));\n        let result = result.or_else(|| modify_constructor(self, f));\n        let result = result.or_else(|| modify_if(self, f));\n        let result = result.or_else(|| modify_index(self, f));\n        let result = result.or_else(|| modify_for(self, f));\n        let result = result.or_else(|| modify_for_range(self, f));\n        let result = result.or_else(|| modify_lambda(self, f));\n        let result = result.or_else(|| modify_let(self, f));\n        let result = result.or_else(|| modify_function_call(self, f));\n        let result = result.or_else(|| modify_member_access(self, f));\n        let result = result.or_else(|| modify_method_call(self, f));\n        let result = result.or_else(|| modify_repeated_element_array(self, f));\n        let result = result.or_else(|| modify_repeated_element_slice(self, f));\n        let result = result.or_else(|| modify_slice(self, f));\n        let result = result.or_else(|| modify_tuple(self, f));\n        let result = result.or_else(|| modify_unary_op(self, f));\n        let result = result.or_else(|| modify_unsafe(self, f));\n        if result.is_some() {\n            let result = result.unwrap_unchecked();\n            let modified = f(result);\n            modified.unwrap_or(result)\n        } else {\n            f(self).unwrap_or(self)\n        }\n    }\n\n    /// Returns this expression as a `Quoted` value. It's the same as `quote { $self }`.\n    // docs:start:quoted\n    pub comptime fn quoted(self) -> Quoted {\n        // docs:end:quoted\n        quote { $self }\n    }\n\n    /// Resolves and type-checks this expression and returns the result as a `TypedExpr`.\n    ///\n    /// The `in_function` argument specifies where the expression is resolved:\n    /// - If it's `none`, the expression is resolved in the function where `resolve` was called\n    /// - If it's `some`, the expression is resolved in the given function\n    ///\n    /// If any names used by this expression are not in scope or if there are any type errors,\n    /// this will give compiler errors as if the expression was written directly into\n    /// the current `comptime` function.\n    #[builtin(expr_resolve)]\n    // docs:start:resolve\n    pub comptime fn resolve(self, in_function: Option<FunctionDefinition>) -> TypedExpr {}\n    // docs:end:resolve\n}\n\ncomptime fn modify_array<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_array().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_array(exprs)\n    })\n}\n\ncomptime fn modify_assert<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert().map(|(predicate, msg)| {\n        let predicate = predicate.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert(predicate, msg)\n    })\n}\n\ncomptime fn modify_assert_eq<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert_eq().map(|(lhs, rhs, msg)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert_eq(lhs, rhs, msg)\n    })\n}\n\ncomptime fn modify_assign<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assign().map(|expr| {\n        let (lhs, rhs) = expr;\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_assign(lhs, rhs)\n    })\n}\n\ncomptime fn modify_binary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_binary_op().map(|(lhs, op, rhs)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_binary_op(lhs, op, rhs)\n    })\n}\n\ncomptime fn modify_block<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_block().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_block(exprs)\n    })\n}\n\ncomptime fn modify_cast<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_cast().map(|(expr, typ)| {\n        let expr = expr.modify(f);\n        new_cast(expr, typ)\n    })\n}\n\ncomptime fn modify_comptime<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_comptime().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_comptime(exprs)\n    })\n}\n\ncomptime fn modify_constructor<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_constructor().map(|(typ, fields)| {\n        let fields = fields.map(|(name, value)| (name, value.modify(f)));\n        new_constructor(typ, fields)\n    })\n}\n\ncomptime fn modify_function_call<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_function_call().map(|(function, arguments)| {\n        let function = function.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_function_call(function, arguments)\n    })\n}\n\ncomptime fn modify_if<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_if().map(|(condition, consequence, alternative)| {\n        let condition = condition.modify(f);\n        let consequence = consequence.modify(f);\n        let alternative = alternative.map(|alternative| alternative.modify(f));\n        new_if(condition, consequence, alternative)\n    })\n}\n\ncomptime fn modify_index<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_index().map(|(object, index)| {\n        let object = object.modify(f);\n        let index = index.modify(f);\n        new_index(object, index)\n    })\n}\n\ncomptime fn modify_for<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for().map(|(identifier, array, body)| {\n        let array = array.modify(f);\n        let body = body.modify(f);\n        new_for(identifier, array, body)\n    })\n}\n\ncomptime fn modify_for_range<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for_range().map(|(identifier, from, to, body)| {\n        let from = from.modify(f);\n        let to = to.modify(f);\n        let body = body.modify(f);\n        new_for_range(identifier, from, to, body)\n    })\n}\n\ncomptime fn modify_lambda<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_lambda().map(|(params, return_type, body)| {\n        let params = params.map(|(name, typ)| (name.modify(f), typ));\n        let body = body.modify(f);\n        new_lambda(params, return_type, body)\n    })\n}\n\ncomptime fn modify_let<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_let().map(|(pattern, typ, expr)| {\n        let pattern = pattern.modify(f);\n        let expr = expr.modify(f);\n        new_let(pattern, typ, expr)\n    })\n}\n\ncomptime fn modify_member_access<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_member_access().map(|(object, name)| {\n        let object = object.modify(f);\n        new_member_access(object, name)\n    })\n}\n\ncomptime fn modify_method_call<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_method_call().map(|(object, name, generics, arguments)| {\n        let object = object.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_method_call(object, name, generics, arguments)\n    })\n}\n\ncomptime fn modify_repeated_element_array<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_array().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_array(expr, length)\n    })\n}\n\ncomptime fn modify_repeated_element_slice<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_slice().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_slice(expr, length)\n    })\n}\n\ncomptime fn modify_slice<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_slice().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_slice(exprs)\n    })\n}\n\ncomptime fn modify_tuple<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_tuple().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_tuple(exprs)\n    })\n}\n\ncomptime fn modify_unary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unary_op().map(|(op, rhs)| {\n        let rhs = rhs.modify(f);\n        new_unary_op(op, rhs)\n    })\n}\n\ncomptime fn modify_unsafe<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unsafe().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_unsafe(exprs)\n    })\n}\n\ncomptime fn modify_expressions<Env>(exprs: [Expr], f: fn[Env](Expr) -> Option<Expr>) -> [Expr] {\n    exprs.map(|expr| expr.modify(f))\n}\n\ncomptime fn new_array(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { [$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_assert(predicate: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert($predicate, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert($predicate) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assert_eq(lhs: Expr, rhs: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert_eq($lhs, $rhs, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert_eq($lhs, $rhs) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assign(lhs: Expr, rhs: Expr) -> Expr {\n    quote { $lhs = $rhs }.as_expr().unwrap()\n}\n\ncomptime fn new_binary_op(lhs: Expr, op: BinaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { ($lhs) $op ($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_block(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_cast(expr: Expr, typ: UnresolvedType) -> Expr {\n    quote { ($expr) as $typ }.as_expr().unwrap()\n}\n\ncomptime fn new_comptime(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { comptime { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_constructor(typ: UnresolvedType, fields: [(Quoted, Expr)]) -> Expr {\n    let fields = fields.map(|(name, value)| quote { $name: $value }).join(quote { , });\n    quote { $typ { $fields }}.as_expr().unwrap()\n}\n\ncomptime fn new_if(condition: Expr, consequence: Expr, alternative: Option<Expr>) -> Expr {\n    if alternative.is_some() {\n        let alternative = alternative.unwrap();\n        quote { if $condition { $consequence } else { $alternative }}.as_expr().unwrap()\n    } else {\n        quote { if $condition { $consequence } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_for(identifier: Quoted, array: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $array { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_for_range(identifier: Quoted, from: Expr, to: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $from .. $to { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_index(object: Expr, index: Expr) -> Expr {\n    quote { $object[$index] }.as_expr().unwrap()\n}\n\ncomptime fn new_lambda(\n    params: [(Expr, Option<UnresolvedType>)],\n    return_type: Option<UnresolvedType>,\n    body: Expr,\n) -> Expr {\n    let params = params\n        .map(|(name, typ)| {\n            if typ.is_some() {\n                let typ = typ.unwrap();\n                quote { $name: $typ }\n            } else {\n                quote { $name }\n            }\n        })\n        .join(quote { , });\n\n    if return_type.is_some() {\n        let return_type = return_type.unwrap();\n        quote { |$params| -> $return_type { $body } }.as_expr().unwrap()\n    } else {\n        quote { |$params| { $body } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_let(pattern: Expr, typ: Option<UnresolvedType>, expr: Expr) -> Expr {\n    if typ.is_some() {\n        let typ = typ.unwrap();\n        quote { let $pattern : $typ = $expr; }.as_expr().unwrap()\n    } else {\n        quote { let $pattern = $expr; }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_member_access(object: Expr, name: Quoted) -> Expr {\n    quote { $object.$name }.as_expr().unwrap()\n}\n\ncomptime fn new_function_call(function: Expr, arguments: [Expr]) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    quote { $function($arguments) }.as_expr().unwrap()\n}\n\ncomptime fn new_method_call(\n    object: Expr,\n    name: Quoted,\n    generics: [UnresolvedType],\n    arguments: [Expr],\n) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    if generics.len() == 0 {\n        quote { $object.$name($arguments) }.as_expr().unwrap()\n    } else {\n        let generics = generics.map(|generic| quote { $generic }).join(quote { , });\n        quote { $object.$name::<$generics>($arguments) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_repeated_element_array(expr: Expr, length: Expr) -> Expr {\n    quote { [$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_repeated_element_slice(expr: Expr, length: Expr) -> Expr {\n    quote { &[$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_slice(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { &[$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_tuple(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { ($exprs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unary_op(op: UnaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { $op($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unsafe(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { \n        // Safety: generated by macro\n        unsafe { $exprs }\n    }\n        .as_expr()\n        .unwrap()\n}\n\ncomptime fn join_expressions(exprs: [Expr], separator: Quoted) -> Quoted {\n    exprs.map(|expr| expr.quoted()).join(separator)\n}\n"
    },
    "255": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\nuse std::meta::derive;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct FunctionSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    pub inner: u32,\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "296": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\nuse std::meta::derive;\n\n// Aztec address\n#[derive(Deserialize, Eq, Packable, Serialize)]\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    /// Returns an address's `AddressPoint`, which can be used to create shared secrets with the owner\n    /// of the address. If the address is invalid (i.e. it is not a properly derived Aztec address), then this\n    /// returns `Option::none()`, and no shared secrets can be created.\n    pub fn to_address_point(self) -> Option<AddressPoint> {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // An invalid AztecAddress is one for which no y coordinate satisfies the curve equation, which we'll\n        // identify by proving that the square root of y_squared does not exist.\n        let mut y_opt = sqrt(y_squared);\n        if y_opt.is_none() {\n            Option::none()\n        } else {\n            let mut y = y_opt.unwrap();\n\n            // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n            // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n            // note: The field modulus is MAX_FIELD_VALUE + 1\n            if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n                y = (MAX_FIELD_VALUE + 1) - y;\n            }\n\n            Option::some(\n                AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } },\n            )\n        }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    // We use the AZTEC_ADDRESS_LENGTH constant to ensure that there is a match between the derived trait\n    // implementation and the constant.\n    let serialized: [Field; AZTEC_ADDRESS_LENGTH] = address.serialize();\n    let deserialized = AztecAddress::deserialize(serialized);\n    assert_eq(address, deserialized);\n}\n\n#[test]\nfn to_address_point_valid() {\n    // x = 8 where x^3 - 17 = 512 - 17 = 495, which is a residue in this field\n    let address = AztecAddress { inner: 8 };\n    let maybe_point = address.to_address_point();\n    assert(maybe_point.is_some());\n\n    let point = maybe_point.unwrap().inner;\n    // check that x is preserved\n    assert_eq(point.x, Field::from(8));\n\n    // check that the curve equation holds: y^2 == x^3 - 17\n    assert_eq(pow(point.y, 2), pow(point.x, 3) - 17);\n}\n\n#[test]\nunconstrained fn to_address_point_invalid() {\n    // x = 3 where x^3 - 17 = 27 - 17 = 10, which is a non-residue in this field\n    let address = AztecAddress { inner: 3 }; //\n    let maybe_point = address.to_address_point();\n    assert(maybe_point.is_none());\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n"
    },
    "309": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr",
      "source": "use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Deserialize, Empty, Hash, Serialize},\n};\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: Field,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl LeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: Field) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"
    },
    "311": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "// TODO: Expose other wrapped functions than debug (info, warn)\n// ['silent', 'fatal', 'error', 'warn', 'info', 'verbose', 'debug', 'trace']\n\npub global SILENT_LOG_LEVEL: u8 = 0;\npub global FATAL_LOG_LEVEL: u8 = 1;\npub global ERROR_LOG_LEVEL: u8 = 2;\npub global WARN_LOG_LEVEL: u8 = 3;\npub global INFO_LOG_LEVEL: u8 = 4;\npub global VERBOSE_LOG_LEVEL: u8 = 5;\npub global DEBUG_LOG_LEVEL: u8 = 6;\npub global TRACE_LOG_LEVEL: u8 = 7;\n\n/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Same as debug_log, but allows to customize the log level.\n/// Consider changing just to 'log'\npub fn debug_log_with_level<let N: u32>(log_level: u8, msg: str<N>) {\n    debug_log_format_with_level(log_level, msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_array_oracle_wrapper(DEBUG_LOG_LEVEL, msg, args) };\n}\n\n/// Same as debug_log_format, but allows to customize the log level.\n/// Consider changing just to 'log_format'\npub fn debug_log_format_with_level<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field; N],\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_array_oracle_wrapper(log_level, msg, args) };\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` slice.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole slice: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format_slice<let M: u32>(log_level: u8, msg: str<M>, args: [Field]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_slice_oracle_wrapper(log_level, msg, args) };\n}\n\n// We provide two versions of the debug log oracle: one that takes args as a slice and another one that takes args as an array.\n// We do this since conversion from array to slice generates overhead in public functions, since opcodes need to be emitted for the conversion.\n// By exposing the two flavors, we avoid conversions since the AVM is able to handle both arrays an slices in this oracle.\n\nunconstrained fn debug_log_slice_oracle_wrapper<let M: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field],\n) {\n    debug_log_slice_oracle(log_level, msg, args);\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_slice_oracle<let M: u32>(log_level: u8, msg: str<M>, args: [Field]) {}\n\nunconstrained fn debug_log_array_oracle_wrapper<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_array_oracle(log_level, msg, N, args);\n}\n\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_array_oracle<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    length: u32,\n    args: [Field; N],\n) {}\n"
    },
    "321": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "mod poseidon2_chunks;\n\nuse crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_log::{PrivateLog, PrivateLogData},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root_from_sibling_path,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    poseidon2::Poseidon2Sponge,\n    side_effect::{Counted, Scoped},\n    traits::{FromField, Hash, ToField},\n    utils::field::{field_from_bytes, field_from_bytes_32_trunc},\n};\n\npub use poseidon2_chunks::poseidon2_absorb_in_chunks_existing_sponge;\nuse poseidon2_chunks::poseidon2_absorb_in_chunks;\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(note_nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [note_nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_nonce_and_unique_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    let note_nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n    compute_unique_note_hash(note_nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        compute_nonce_and_unique_note_hash(siloed_note_hash, first_nullifier, note_index_in_tx)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: Scoped<Counted<NoteHash>>) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.innermost())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: Scoped<Counted<Nullifier>>) -> Field {\n    let value = nullifier.innermost().value;\n    // Q: shouldn't we be checking whether the _whole_ nullifier is empty?\n    // A: We don't have to. The init and inner circuits add contract address to non-empty nullifiers.\n    // So we know we should silo it if the contract address is not empty.\n    if nullifier.contract_address.is_zero() {\n        value // Return `value` instead of 0 because an already-siloed nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, value)\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<Counted<PrivateLogData>>) -> PrivateLog {\n    let log = private_log.innermost().log;\n    if private_log.contract_address.is_zero() {\n        log\n    } else {\n        let mut fields = log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, log.length)\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn compute_app_secret_key(\n    master_secret_key: EmbeddedCurveScalar,\n    app_address: AztecAddress,\n    app_secret_generator: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [master_secret_key.hi, master_secret_key.lo, app_address.to_field()],\n        app_secret_generator,\n    )\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let contract_address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    let recipient_bytes: [u8; 20] = recipient.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let rollup_version_id_bytes: [u8; 32] = rollup_version_id.to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n\n    let mut bytes: [u8; 148] = std::mem::zeroed();\n    for i in 0..32 {\n        bytes[i] = contract_address_bytes[i];\n        bytes[i + 32] = rollup_version_id_bytes[i];\n        // 64 - 84 are for recipient.\n        bytes[i + 84] = chain_id_bytes[i];\n        bytes[i + 116] = content_bytes[i];\n    }\n\n    for i in 0..20 {\n        bytes[64 + i] = recipient_bytes[i];\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: Scoped<L2ToL1Message>,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.inner.recipient,\n            msg.inner.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n/// Computes sha256 hash of 2 input fields.\n///\n/// @returns A truncated field (i.e., the first byte is always 0).\npub fn accumulate_sha256(v0: Field, v1: Field) -> Field {\n    // Concatenate two fields into 32 x 2 = 64 bytes\n    let v0_as_bytes: [u8; 32] = v0.to_be_bytes();\n    let v1_as_bytes: [u8; 32] = v1.to_be_bytes();\n    let hash_input_flattened = v0_as_bytes.concat(v1_as_bytes);\n\n    sha256_to_field(hash_input_flattened)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = [separator.to_field()].concat(inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n/// Computes a Poseidon2 hash over a dynamic-length subarray of the given input.\n/// Only the first `in_len` fields of `input` are absorbed; any remaining fields are ignored.\n/// The caller is responsible for ensuring that the input is padded with zeros if required.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_in_chunks(input, in_len);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_in_chunks(input, in_len);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n// This function is  unconstrained because it is intended to be used in unconstrained context only as\n// in constrained contexts it would be too inefficient.\npub unconstrained fn poseidon2_hash_with_separator_bounded_vec<let N: u32, T>(\n    inputs: BoundedVec<Field, N>,\n    separator: T,\n) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs.get(i));\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0x3b18c58c739716e76429634a61375c45b3b5cd470c22ab6d3e14cee23dd992);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0xaab2a5828156782b12a1dc6f336e2bc627eb1b9514b02d511f66296990c050);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        L2ToL1Message { recipient: EthAddress::from_field(1), content: 2 }.scope(\n            AztecAddress::from_field(3),\n        ),\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `yarn-project/stdlib/src/hash/hash.test.ts`\n    let hash_from_typescript = 0x0081edf209e087ad31b3fd24263698723d57190bd1d6e9fe056fc0c0a68ee661;\n\n    assert_eq(hash, hash_from_typescript);\n}\n\n#[test]\nunconstrained fn poseidon2_hash_with_separator_bounded_vec_matches_non_bounded_vec_version() {\n    let inputs = BoundedVec::<Field, 4>::from_array([1, 2, 3]);\n    let separator = 42;\n\n    // Hash using bounded vec version\n    let bounded_result = poseidon2_hash_with_separator_bounded_vec(inputs, separator);\n\n    // Hash using regular version\n    let regular_result = poseidon2_hash_with_separator([1, 2, 3], separator);\n\n    // Results should match\n    assert_eq(bounded_result, regular_result);\n}\n"
    },
    "330": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      "source": "use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_tree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n/// These values are precomputed and we run tests to ensure that they are correct.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_tree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_tree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_tree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_tree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_tree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_tree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_tree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_tree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_tree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_tree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_tree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_tree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"
    },
    "334": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use utils::derive_serialization_quotes;\n\npub mod utils;\n\n/// Generates the generic parameter declarations for a struct's trait implementation.\n///\n/// This function takes a struct type definition and generates the generic parameter declarations\n/// that go after the `impl` keyword. For example, given a struct with generics `N: u32` and `T`,\n/// it generates `<let N: u32, T>`.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate generic declarations for\n///\n/// # Returns\n/// A quoted code block containing the generic parameter declarations, or an empty quote if the struct\n/// has no generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// This function generates:\n/// ```\n/// <let N: u32, T>\n/// ```\ncomptime fn get_generics_declarations(s: TypeDefinition) -> Quoted {\n    let generics = s.generics();\n\n    if generics.len() > 0 {\n        let generics_declarations_items = generics\n            .map(|(name, maybe_integer_typ)| {\n                // The second item in the generics tuple is an Option of an integer type that is Some only if\n                // the generic is numeric.\n                if maybe_integer_typ.is_some() {\n                    // The generic is numeric, so we return a quote defined as e.g. \"let N: u32\"\n                    let integer_type = maybe_integer_typ.unwrap();\n                    quote {let $name: $integer_type}\n                } else {\n                    // The generic is not numeric, so we return a quote containing the name of the generic (e.g. \"T\")\n                    quote {$name}\n                }\n            })\n            .join(quote {,});\n        quote {<$generics_declarations_items>}\n    } else {\n        // The struct doesn't have any generics defined, so we just return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates the `where` clause for a trait implementation that constrains non-numeric generic type parameters.\n///\n/// This function takes a struct type definition and a trait name, and generates a `where` clause that\n/// requires all non-numeric generic type parameters to implement the specified trait.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the where clause for\n/// - `trait_name`: The name of the trait that non-numeric generic parameters must implement\n///\n/// # Returns\n/// A quoted code block containing the where clause, or an empty quote if the struct has no non-numeric\n/// generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// And trait name \"Serialize\", this function generates:\n/// ```\n/// where T: Serialize\n/// ```\ncomptime fn get_where_trait_clause(s: TypeDefinition, trait_name: Quoted) -> Quoted {\n    let generics = s.generics();\n\n    // The second item in the generics tuple is an Option of an integer type that is Some only if the generic is\n    // numeric.\n    let non_numeric_generics =\n        generics.filter(|(_, maybe_integer_typ)| maybe_integer_typ.is_none());\n\n    if non_numeric_generics.len() > 0 {\n        let non_numeric_generics_declarations =\n            non_numeric_generics.map(|(name, _)| quote {$name: $trait_name}).join(quote {,});\n        quote {where $non_numeric_generics_declarations}\n    } else {\n        // There are no non-numeric generics, so we return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates a `Serialize` trait implementation for a struct type.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A quoted code block containing the trait implementation\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Log<N> {\n///     fields: [Field; N],\n///     length: u32\n/// }\n/// ```\n///\n/// This function generates code equivalent to:\n/// ```\n/// impl<let N: u32> Serialize for Log<N> {\n///     let N: u32 = <[Field; N] as Serialize>::N + <u32 as Serialize>::N;\n///\n///     #[inline_always]\n///     fn serialize(self) -> [Field; Self::N] {\n///         let mut serialized_params = [0; _];\n///         let mut offset = 0;\n///\n///         let serialized_member = Serialize::serialize(self.fields);\n///         let serialized_member_len = <[Field; N] as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             serialized_params[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         let serialized_member = Serialize::serialize(self.length);\n///         let serialized_member_len = <u32 as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             serialized_params[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         serialized_params\n///     }\n/// }\n/// ```\npub comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n\n    // We care only about the name and type so we drop the last item of the tuple\n    let params = nested_struct.0.fields(nested_struct.1).map(|(name, typ, _)| (name, typ));\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Serialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_serialize_clause = get_where_trait_clause(s, quote {Serialize});\n\n    let (function_body, params_len_quote, serialized_params_name) =\n        derive_serialization_quotes(params, true);\n\n    quote {\n        impl$generics_declarations $crate::traits::Serialize for $typ\n            $where_serialize_clause\n        {\n            let N: u32 = $params_len_quote;\n\n            #[inline_always]\n            fn serialize(self) -> [Field; Self::N] {\n                $function_body\n\n                $serialized_params_name\n            }\n        }\n    }\n}\n\n/// Generates a `Deserialize` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Deserialize` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Deserialize for MyStruct {\n///     let N: u32 = <AztecAddress as Deserialize>::N + <Field as Deserialize>::N;\n///\n///     fn deserialize(serialized: [Field; Self::N]) -> Self {\n///         let mut offset = 0;\n///         let mut member_fields = [0; <AztecAddress as Deserialize>::N];\n///         for i in 0..<AztecAddress as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let x = <AztecAddress as Deserialize>::deserialize(member_fields);\n///         offset += <AztecAddress as Deserialize>::N;\n///\n///         let mut member_fields = [0; <Field as Deserialize>::N];\n///         for i in 0..<Field as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let y = <Field as Deserialize>::deserialize(member_fields);\n///         offset += <Field as Deserialize>::N;\n///\n///         Self { x, y }\n///     }\n/// }\n/// ```\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Deserialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_deserialize_clause = get_where_trait_clause(s, quote {Deserialize});\n\n    // The following will give us <type_of_struct_member_1 as Deserialize>::N + <type_of_struct_member_2 as Deserialize>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Deserialize>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly deserializing the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let function_body = if params.len() > 1 {\n        // This generates deserialization code for each struct member and concatenates them together.\n        let deserialization_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as Deserialize>::N];\n                    for i in 0..<$param_type as Deserialize>::N {\n                        member_fields[i] = serialized[i + offset];\n                    }\n                    let $param_name = <$param_type as Deserialize>::deserialize(member_fields);\n                    offset += <$param_type as Deserialize>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        // This will give us e.g. `a, b, c` for a struct with three fields named `a`, `b`, and `c`.\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n\n            $deserialization_of_struct_members\n\n            Self { $struct_members }\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Deserialize::deserialize(serialized) }\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Deserialize for $typ\n            $where_deserialize_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn deserialize(serialized: [Field; Self::N]) -> Self {\n                $function_body\n            }\n        }\n    }\n}\n\n/// Generates a `Packable` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Packable` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Packable for MyStruct {\n///     let N: u32 = 2;\n///\n///     fn pack(self) -> [Field; 2] {\n///         let mut result: [Field; 2] = [0_Field; 2];\n///         let mut offset: u32 = 0_u32;\n///         let packed_member: [Field; 1] = self.x.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         let packed_member: [Field; 1] = self.y.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         result\n///     }\n///\n///     fn unpack(packed: [Field; 2]) -> Self {\n///         let mut offset: u32 = 0_u32;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<AztecAddress as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let x: AztecAddress = <AztecAddress as Packable>::unpack(member_fields);\n///         offset = offset + <AztecAddress as Packable>::N;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<Field as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let y: Field = <Field as Packable>::unpack(member_fields);\n///         offset = offset + <Field as Packable>::N;\n///         Self { x: x, y: y }\n///     }\n/// }\n/// ```\npub comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Packable` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_packable_clause = get_where_trait_clause(s, quote {Packable});\n\n    // The following will give us <type_of_struct_member_1 as Packable>::N + <type_of_struct_member_2 as Packable>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Packable>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly returning the packed member,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let pack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate packing code that:\n        // 1. Packs each member\n        // 2. Copies the packed fields into the result array at the correct offset\n        // 3. Updates the offset for the next member\n        let packing_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let packed_member = $crate::traits::Packable::pack(self.$param_name);\n                    let packed_member_len = <$param_type as $crate::traits::Packable>::N;\n                    for i in 0..packed_member_len {\n                        result[i + offset] = packed_member[i];\n                    }\n                    offset += packed_member_len;\n                }\n            })\n            .join(quote {});\n\n        quote {\n            let mut result = [0; Self::N];\n            let mut offset = 0;\n\n            $packing_of_struct_members\n\n            result\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            $crate::traits::Packable::pack(self.$param_name)\n        }\n    };\n\n    // For structs containing a single member, we can enhance performance by directly unpacking the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let unpack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate unpacking code that:\n        // 1. Unpacks each member\n        // 2. Copies packed fields into member array at correct offset\n        // 3. Updates offset for next member\n        let unpacking_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as $crate::traits::Packable>::N];\n                    for i in 0..<$param_type as $crate::traits::Packable>::N {\n                        member_fields[i] = packed[i + offset];\n                    }\n                    let $param_name = <$param_type as $crate::traits::Packable>::unpack(member_fields);\n                    offset += <$param_type as $crate::traits::Packable>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n            $unpacking_of_struct_members\n            Self { $struct_members }\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Packable::unpack(packed) }\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Packable for $typ\n            $where_packable_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn pack(self) -> [Field; Self::N] {\n                $pack_function_body\n            }\n\n            #[inline_always]\n            fn unpack(packed: [Field; Self::N]) -> Self {\n                $unpack_function_body\n            }\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Packable, Serialize};\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct Smol {\n        a: Field,\n        b: Field,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct HasArray {\n        a: [Field; 2],\n        b: bool,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct Fancier {\n        a: Smol,\n        b: [Field; 2],\n        c: [u8; 3],\n        d: str<16>,\n    }\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct HasArrayWithGenerics<T, let N: u32> {\n        pub fields: [T; N],\n        pub length: u32,\n    }\n\n    #[test]\n    fn serde_on_smol() {\n        let smol = Smol { a: 1, b: 2 };\n        let serialized = smol.serialize();\n        assert(serialized == [1, 2], serialized);\n        let deserialized = Smol::deserialize(serialized);\n        assert(deserialized == smol);\n\n        // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n        let packed = smol.pack();\n        assert_eq(packed, serialized, \"Packed does not match serialized\");\n    }\n\n    #[test]\n    fn serde_on_has_array() {\n        let has_array = HasArray { a: [1, 2], b: true };\n        let serialized = has_array.serialize();\n        assert(serialized == [1, 2, 1], serialized);\n        let deserialized = HasArray::deserialize(serialized);\n        assert(deserialized == has_array);\n    }\n\n    #[test]\n    fn serde_on_fancier() {\n        let fancier =\n            Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n        let serialized = fancier.serialize();\n        assert(\n            serialized\n                == [\n                    1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                    0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n                ],\n            serialized,\n        );\n        let deserialized = Fancier::deserialize(serialized);\n        assert(deserialized == fancier);\n    }\n\n    #[test]\n    fn serde_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let serialized = struct_with_array_of_generics.serialize();\n        assert(serialized == [1, 2, 3, 3], serialized);\n        let deserialized = HasArrayWithGenerics::deserialize(serialized);\n        assert(deserialized == struct_with_array_of_generics);\n    }\n\n    #[test]\n    fn packable_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let packed = struct_with_array_of_generics.pack();\n        assert(packed == [1, 2, 3, 3], packed);\n\n        let unpacked = HasArrayWithGenerics::unpack(packed);\n        assert(unpacked == struct_with_array_of_generics);\n    }\n\n}\n"
    },
    "335": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/meta/utils.nr",
      "source": "/// Generates serialization code for a list of parameters and the total length of the serialized array\n///\n/// # Parameters\n/// - `params`: A list of (name, type) tuples to serialize\n/// - `use_self_prefix`: If true, parameters are accessed as `self.$param_name` (for struct members).\n///                      If false, parameters are accessed directly as `$param_name` (for function parameters).\n///\n/// # Returns\n/// A tuple containing:\n/// - Quoted code that serializes the parameters into an array named `serialized_params`\n/// - Quoted code that evaluates to the total length of the serialized array\n/// - Quoted code containing the name of the serialized array\npub comptime fn derive_serialization_quotes(\n    params: [(Quoted, Type)],\n    use_self_prefix: bool,\n) -> (Quoted, Quoted, Quoted) {\n    let prefix_quote = if use_self_prefix {\n        quote { self. }\n    } else {\n        quote {}\n    };\n\n    let params_len_quote = get_params_len_quote(params);\n    let serialized_params_name = quote { serialized_params };\n\n    let body = if params.len() == 0 {\n        quote {\n            let $serialized_params_name: [Field; 0] = [];\n        }\n    } else if params.len() == 1 {\n        // When we have only a single parameter on the input, we can enhance performance by directly returning\n        // the serialized member, bypassing the need for loop-based array construction. While this optimization yields\n        // significant benefits in Brillig where the loops are expected to not be optimized, it is not relevant in ACIR\n        // where the loops are expected to be optimized away.\n\n        let param_name = params[0].0;\n        quote {\n            let $serialized_params_name = $crate::traits::Serialize::serialize($prefix_quote$param_name);\n        }\n    } else {\n        // For multiple struct members, generate serialization code that:\n        // 1. Serializes each member\n        // 2. Copies the serialized fields into the serialize array at the correct offset\n        // 3. Updates the offset for the next member\n        let serialization_of_struct_members = params\n            .map(|(param_name, param_type): (Quoted, Type)| {\n                quote {\n                let serialized_member = $crate::traits::Serialize::serialize($prefix_quote$param_name);\n                let serialized_member_len = <$param_type as $crate::traits::Serialize>::N;\n                for i in 0..serialized_member_len {\n                    $serialized_params_name[i + offset] = serialized_member[i];\n                }\n                offset += serialized_member_len;\n            }\n            })\n            .join(quote {});\n\n        quote {\n            let mut $serialized_params_name = [0; $params_len_quote];\n            let mut offset = 0;\n\n            $serialization_of_struct_members\n        }\n    };\n\n    (body, params_len_quote, serialized_params_name)\n}\n\n/// Generates a quoted expression that computes the total serialized length of function parameters.\n///\n/// # Parameters\n/// * `params` - An array of tuples where each tuple contains a quoted parameter name and its Type. The type needs\n///              to implement the Serialize trait.\n///\n/// # Returns\n/// A quoted expression that evaluates to:\n/// * `0` if there are no parameters\n/// * `(<type1 as Serialize>::N + <type2 as Serialize>::N + ...)` for one or more parameters\npub comptime fn get_params_len_quote(params: [(Quoted, Type)]) -> Quoted {\n    if params.len() == 0 {\n        quote { 0 }\n    } else {\n        let params_quote_without_parentheses = params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n                    <$param_type as $crate::traits::Serialize>::N\n                }\n            })\n            .join(quote {+});\n        quote { ($params_quote_without_parentheses) }\n    }\n}\n"
    },
    "336": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl Serialize for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn serialize(self: Self) -> [Field; Self::N] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn deserialize(serialized: [Field; Self::N]) -> Self {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] != 0 }\n    }\n}\n\n// TODO(#11356): use compact representation here.\nimpl Packable for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn pack(self) -> [Field; Self::N] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; Self::N]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "337": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\nuse crate::traits::{Deserialize, Serialize};\nuse std::meta::derive;\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "344": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::{default::Default, meta::derive};\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nmod test {\n    use crate::{\n        point::POINT_LENGTH,\n        public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n        traits::{Deserialize, Serialize},\n    };\n    use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\n    #[test]\n    unconstrained fn compute_public_keys_hash() {\n        let keys = PublicKeys {\n            npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n            ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n            ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n            tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n        };\n\n        let actual = keys.hash();\n        let expected_public_keys_hash =\n            0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n        assert(actual.to_field() == expected_public_keys_hash);\n    }\n\n    #[test]\n    unconstrained fn compute_default_hash() {\n        let keys = PublicKeys::default();\n\n        let actual = keys.hash();\n        let test_data_default_hash =\n            0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n        assert(actual.to_field() == test_data_default_hash);\n    }\n\n    #[test]\n    unconstrained fn serde() {\n        let keys = PublicKeys {\n            npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n            ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n            ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n            tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n        };\n\n        // We use the PUBLIC_KEYS_LENGTH constant to ensure that there is a match between the derived trait\n        let serialized: [Field; POINT_LENGTH * 4] = keys.serialize();\n        let deserialized = PublicKeys::deserialize(serialized);\n\n        assert_eq(keys, deserialized);\n    }\n}\n"
    },
    "349": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "365": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty: Eq {\n    fn empty() -> Self;\n\n    fn is_empty(self) -> bool {\n        self.eq(Self::empty())\n    }\n\n    // Requires this Noir fix: https://github.com/noir-lang/noir/issues/9002\n    // fn assert_not_empty<let U: u32>(self, msg: str<U>) { // This msg version was failing with weird compiler errors.\n    //     // We provide a default impl but it's likely inefficient.\n    //     // The reason we include this function is because there's a lot of\n    //     // opportunity for optimisation on a per-struct basis.\n    //     // You only need to show one element is not empty to know that the whole thing\n    //     // is not empty.\n    //     // If you know an element of your struct which should always be nonempty,\n    //     // you can write an impl that solely checks that that element is nonempty.\n    //     assert(!self.is_empty(), msg);\n    // }\n\n    // This default impl is overwritten by types like arrays, because there's a much\n    // more efficient approach.\n    fn assert_empty<let S: u32>(self, msg: str<S>) {\n        assert(self.is_empty(), msg);\n    }\n}\n\nimpl Empty for Field {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u16 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\n\nimpl<T> Empty for [T]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty()]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\nimpl<A, B> Empty for (A, B)\nwhere\n    A: Empty,\n    B: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        (A::empty(), B::empty())\n    }\n}\n\nimpl<T> Empty for Option<T>\nwhere\n    T: Eq,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\n// pub fn is_empty<T>(item: T) -> bool\n// where\n//     T: Empty,\n// {\n//     item.eq(T::empty())\n// }\n\n// pub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\n// where\n//     T: Empty,\n// {\n//     array.all(|elem| is_empty(elem))\n// }\n\n// pub fn assert_empty<T>(item: T) -> ()\n// where\n//     T: Empty,\n// {\n//     assert(item.eq(T::empty()))\n// }\n\n// pub fn assert_empty_array<T, let N: u32>(array: [T; N]) -> ()\n// where\n//     T: Empty,\n// {\n//     // A cheaper option than `is_empty_array` for if you don't need to gracefully\n//     // handle a bool result.\n//     // Avoids the `&` operator of `is_empty_array`'s `.all()` call.\n//     for i in 0..N {\n//         assert(is_empty(array[i]));\n//     }\n// }\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u16 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value != 0\n    }\n}\nimpl FromField for u1 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u16 {\n    fn from_field(value: Field) -> Self {\n        value as u16\n    }\n}\nimpl FromField for u32 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Associated Constants\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize for str<N> {\n///     let N: u32 = N;\n///\n///     fn serialize(self) -> [Field; Self::N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; Self::N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize {\n    let N: u32;\n\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let M: u32> Serialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; Self::N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n/// Implementation of Deserialize for BoundedVec.\n///\n/// This implementation deserializes a BoundedVec from an array of Fields. The array contains:\n/// 1. The serialized items, each taking up T::N Fields\n/// 2. The length of the BoundedVec as the last Field\n///\n/// # Type Parameters\n/// * `T` - The type of items stored in the BoundedVec, must implement Deserialize\n/// * `M` - The maximum length of the BoundedVec\n///\n/// # Fields Array Layout\n/// [item1_field1, item1_field2, ..., item2_field1, item2_field2, ..., length]\n/// Where:\n/// - itemN_fieldM: The M-th Field of the N-th item (T::N Fields per item)\n/// - length: The number of items in the BoundedVec (1 Field)\n///\n/// Total length N = T::N * M + 1, where:\n/// - T::N is the number of Fields needed to deserialize one item\n/// - M is the maximum length of the BoundedVec\n/// - +1 is for storing the length\n///\n/// # Note\n/// Not deriving this because it's not supported to call derive_deserialize on a \"remote\" struct (and it will never\n/// be supported).\nimpl<T, let M: u32> Deserialize for BoundedVec<T, M>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut new_bounded_vec: BoundedVec<T, M> = BoundedVec::new();\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        let len = fields[<T as Deserialize>::N * M] as u32;\n\n        for i in 0..len {\n            let mut nested_fields = [0; <T as Deserialize>::N];\n            for j in 0..<T as Deserialize>::N {\n                nested_fields[j] = fields[i * <T as Deserialize>::N + j];\n            }\n\n            let item = T::deserialize(nested_fields);\n            new_bounded_vec.push(item);\n        }\n\n        new_bounded_vec\n    }\n}\n\n// This may cause issues if used as program input, because noir disallows empty arrays for program input.\n// I think this is okay because I don't foresee a unit type being used as input. But leaving this comment as a hint\n// if someone does run into this in the future.\nimpl Deserialize for () {\n    let N: u32 = 0;\n\n    fn deserialize(_fields: [Field; Self::N]) -> Self {\n        ()\n    }\n}\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl<T, let M: u32> Serialize for BoundedVec<T, M>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M + 1; // +1 for the length of the BoundedVec\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut fields = [0; Self::N];\n\n        let storage = self.storage();\n\n        for i in 0..M {\n            let serialized_item = storage[i].serialize();\n\n            for j in 0..<T as Serialize>::N {\n                fields[i * <T as Serialize>::N + j] = serialized_item[j];\n            }\n        }\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        fields[<T as Serialize>::N * M] = self.len() as Field;\n\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Associated Constants\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let M: u32> Deserialize for str<M> {\n///     let N: u32 = M;\n///\n///     #[inline_always]\n///     fn deserialize(fields: [Field; Self::N]) -> Self {\n///         str::<Self::N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize {\n    let N: u32;\n\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let M: u32> Deserialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        str::<Self::N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Associated Constants\n/// * `N` - The length of the Field array, known at compile time\n#[derive_via(derive_packable)]\npub trait Packable {\n    let N: u32;\n\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n\n#[test]\nunconstrained fn bounded_vec_serialization() {\n    // Test empty BoundedVec\n    let empty_vec: BoundedVec<Field, 3> = BoundedVec::from_array([]);\n    let serialized = empty_vec.serialize();\n    let deserialized = BoundedVec::<Field, 3>::deserialize(serialized);\n    assert_eq(empty_vec, deserialized);\n    assert_eq(deserialized.len(), 0);\n\n    // Test partially filled BoundedVec\n    let partial_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2]]);\n    let serialized = partial_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(partial_vec, deserialized);\n    assert_eq(deserialized.len(), 1);\n    assert_eq(deserialized.get(0), [1, 2]);\n\n    // Test full BoundedVec\n    let full_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2], [3, 4], [5, 6]]);\n    let serialized = full_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(full_vec, deserialized);\n    assert_eq(deserialized.len(), 3);\n    assert_eq(deserialized.get(0), [1, 2]);\n    assert_eq(deserialized.get(1), [3, 4]);\n    assert_eq(deserialized.get(2), [5, 6]);\n}\n"
    },
    "367": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable for bool {\n    let N: u32 = BOOL_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> bool {\n        (fields[0] as u1) != 0\n    }\n}\n\nimpl Packable for u8 {\n    let N: u32 = U8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable for u16 {\n    let N: u32 = U16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable for u32 {\n    let N: u32 = U32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable for u64 {\n    let N: u32 = U64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable for u128 {\n    let N: u32 = U128_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable for Field {\n    let N: u32 = FIELD_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable for i8 {\n    let N: u32 = I8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Packable for i16 {\n    let N: u32 = I16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Packable for i32 {\n    let N: u32 = I32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Packable for i64 {\n    let N: u32 = I64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Packable for [T; M]\nwhere\n    T: Packable,\n{\n    let N: u32 = M * <T as Packable>::N;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized = self[i].pack();\n            for j in 0..<T as Packable>::N {\n                result[i * <T as Packable>::N + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Packable>::N, M>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "368": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal U1_SERIALIZED_LEN: u32 = 1;\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> bool {\n        fields[0] != 0\n    }\n}\n\nimpl Serialize for u1 {\n    let N: u32 = U1_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u1 {\n    let N: u32 = U1_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u1\n    }\n}\n\nimpl Serialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self]\n    }\n}\n\nimpl Deserialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n}\n\nimpl Deserialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Serialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n}\n\nimpl Deserialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Serialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n}\n\nimpl Deserialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Serialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n}\n\nimpl Deserialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Serialize for [T; M]\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M;\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; _] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized_t = self[i].serialize();\n            let T_N = serialized_t.len();\n            for j in 0..T_N {\n                result[i * T_N + j] = serialized_t[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let M: u32> Deserialize for [T; M]\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Deserialize>::N, M>(Deserialize::deserialize, result)\n    }\n}\n\nimpl<T> Serialize for Option<T>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N + 1;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n\n        result[0] = if self.is_some() { 1 } else { 0 };\n\n        let value_serialized = self.unwrap_unchecked().serialize();\n        for i in 0..<T as Serialize>::N {\n            result[1 + i] = value_serialized[i];\n        }\n\n        result\n    }\n}\n\nimpl<T> Deserialize for Option<T>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        if fields[0] == 1 {\n            let mut value_fields = [0; <T as Deserialize>::N];\n            for i in 0..<T as Deserialize>::N {\n                value_fields[i] = fields[1 + i];\n            }\n\n            Option::some(T::deserialize(value_fields))\n        } else {\n            Option::none()\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Serialize};\n\n    #[test]\n    fn u16_serialization() {\n        let a: u16 = 10;\n        assert_eq(a, u16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i8_serialization() {\n        let a: i8 = -10;\n        assert_eq(a, i8::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i16_serialization() {\n        let a: i16 = -10;\n        assert_eq(a, i16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i32_serialization() {\n        let a: i32 = -10;\n        assert_eq(a, i32::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i64_serialization() {\n        let a: i64 = -10;\n        assert_eq(a, i64::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn option_field_serialization() {\n        let opt_some = Option::some(5);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n\n    #[test]\n    fn array_serialization() {\n        let array = [1, 2, 3, 4];\n\n        let serialized: [Field; 4] = array.serialize();\n        let deserialized: [Field; 4] = Deserialize::deserialize(serialized);\n        assert_eq(deserialized, array);\n    }\n\n    #[test]\n    fn nested_array_serialization() {\n        let nested_array = [[1, 2, 3, 4], [5, 6, 7, 8]];\n\n        let serialized: [Field; 8] = nested_array.serialize();\n        let deserialized: [[Field; 4]; 2] = Deserialize::deserialize(serialized);\n\n        assert_eq(deserialized, nested_array);\n    }\n\n    #[test]\n    fn option_array_serialization() {\n        let opt_some = Option::some([2, 5]);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n}\n"
    },
    "386": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "global KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\npub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO: This currently only exists to aid point compression in compress_to_blob_commitment().\n// Once compression is part of BigCurve it can either be removed or optimized to be used elsewhere.\npub fn byte_to_bits_be(byte: u8) -> [u1; 8] {\n    let mut mut_byte = byte;\n    let mut bits: [u1; 8] = [0; 8];\n    for i in 0..8 {\n        bits[7 - i] = (mut_byte & 1) as u1;\n        mut_byte >>= 1;\n    }\n    bits\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n/// Returns Option::some(sqrt) if there is a square root, and Option::none() if there isn't.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\nunconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n\n#[test]\nunconstrained fn sqrt_valid_test() {\n    let x = 16; // examples: 16, 9, 25, 81\n    let result = sqrt(x);\n    assert(result.is_some());\n    assert_eq(result.unwrap() * result.unwrap(), x);\n}\n\n#[test]\nunconstrained fn sqrt_invalid_test() {\n    let x = KNOWN_NON_RESIDUE; // has no square root in the field\n    let result = sqrt(x);\n    assert(result.is_none());\n}\n"
    },
    "390": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_u64(&mut self) -> u64 {\n        self.read() as u64\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() != 0\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert_eq(self.offset, self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "446": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/uint-note/src/uint_note.nr",
      "source": "use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    history::nullifier_inclusion::ProveNullifierInclusion,\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    messages::logs::note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{\n            GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER,\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT, PRIVATE_LOG_SIZE_IN_FIELDS,\n        },\n        hash::{compute_siloed_nullifier, poseidon2_hash_with_separator},\n        traits::{Deserialize, FromField, Hash, Packable, Serialize, ToField},\n    },\n};\n\n// UintNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the amount).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n/// A private note representing a numeric value associated to an account (e.g. a token balance).\n#[derive(Deserialize, Eq, Serialize, Packable)]\n#[custom_note]\npub struct UintNote {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintPartialNotePrivateContent, and\n    //   b) have the public field at the end\n    // Correct ordering is checked by the tests in this module.\n\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The number stored in the note.\n    value: u128,\n}\n\nimpl NoteHash for UintNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because UintNote has just one variant (where the value is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let private_content =\n            UintPartialNotePrivateContent { owner: self.owner, randomness: self.randomness };\n        let partial_note = PartialUintNote {\n            commitment: private_content.compute_partial_commitment(storage_slot),\n        };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.value)\n    }\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullification: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullification, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(\n        self,\n        note_hash_for_nullification: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullification, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: u128, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness }\n    }\n\n    pub fn get_value(self) -> u128 {\n        self.value\n    }\n\n    pub fn get_owner(self) -> AztecAddress {\n        self.owner\n    }\n\n    /// Creates a partial note that will hide the owner and storage slot but not the value, since the note will be later\n    /// completed in public. This is a powerful technique for scenarios in which the value cannot be known in private\n    /// (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// This function inserts a partial note validity commitment into the nullifier tree to be later on able to verify\n    /// that the partial note and completer are legitimate. See function docs of `compute_validity_commitment` for more\n    /// details.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` so that they can discover the\n    /// note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        completer: AztecAddress,\n    ) -> PartialUintNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = UintPartialNotePrivateContent { owner, randomness }\n            .compute_partial_commitment(storage_slot);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content =\n            UintPartialNotePrivateLogContent { owner, randomness, public_log_tag: commitment };\n\n        let encrypted_log = note::compute_partial_note_private_content_log(\n            private_log_content,\n            storage_slot,\n            recipient,\n        );\n        // Regardless of the original content size, the log is padded with random bytes up to\n        // `PRIVATE_LOG_SIZE_IN_FIELDS` to prevent leaking information about the actual size.\n        let length = encrypted_log.len();\n        context.emit_private_log(encrypted_log, length);\n\n        let partial_note = PartialUintNote { commitment };\n\n        // Now we compute the validity commitment and push it to the nullifier tree. It can be safely pushed to\n        // the nullifier tree since it uses its own separator, making collisions with actual note nullifiers\n        // practically impossible.\n        let validity_commitment = partial_note.compute_validity_commitment(completer);\n        context.push_nullifier(validity_commitment);\n\n        partial_note\n    }\n}\n\n/// The private content of a partial UintNote, i.e. the fields that will remain private. All other note fields will be\n/// made public.\n#[derive(Packable)]\nstruct UintPartialNotePrivateContent {\n    // The ordering of these fields is important given that it must match that of UintNote.\n    // Correct ordering is checked by the tests in this module.\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl UintPartialNotePrivateContent {\n    fn compute_partial_commitment(self, storage_slot: Field) -> Field {\n        // Here we commit to all private values, including the storage slot.\n        poseidon2_hash_with_separator(\n            self.pack().concat([storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\n#[derive(Packable)]\nstruct UintPartialNotePrivateLogContent {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintNote, and\n    //   b) have the public log tag at the beginning\n    // Correct ordering is checked by the tests in this module.\n    public_log_tag: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteType for UintPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        UintNote::get_id()\n    }\n}\n\n/// A partial instance of a UintNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the value field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the value to the public), resulting in a UintNote that can be used like any other one (except\n/// of course that its value is known).\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct PartialUintNote {\n    commitment: Field,\n}\n\nglobal NOTE_COMPLETION_LOG_LENGTH: u32 = 2;\n\nimpl PartialUintNote {\n    /// Completes the partial note, creating a new note that can be used like any other UintNote.\n    pub fn complete(self, context: &mut PublicContext, completer: AztecAddress, value: u128) {\n        // A note with a value of zero is valid, but we cannot currently complete a partial note with such a value\n        // because this will result in the completion log having its last field set to 0. Public logs currently do not\n        // track their length, and so trailing zeros are simply trimmed. This results in the completion log missing its\n        // last field (the value), and note discovery failing.\n        // TODO(#11636): remove this\n        assert(value != 0, \"Cannot complete a PartialUintNote with a value of 0\");\n\n        // We verify that the partial note we're completing is valid (i.e. completer is correct, it uses the correct\n        // state variable's storage slot, and it is internally consistent).\n        let validity_commitment = self.compute_validity_commitment(completer);\n        assert(\n            context.nullifier_exists(validity_commitment, context.this_address()),\n            \"Invalid partial note or completer\",\n        );\n\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the value). The contract will later find it by searching\n        //  for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(value));\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    /// Completes the partial note, creating a new note that can be used like any other UintNote. Same as `complete`\n    /// function but works from private context.\n    pub fn complete_from_private(\n        self,\n        context: &mut PrivateContext,\n        completer: AztecAddress,\n        value: u128,\n    ) {\n        // We verify that the partial note we're completing is valid (i.e. completer is correct, it uses the correct\n        // state variable's storage slot, and it is internally consistent).\n        let validity_commitment = self.compute_validity_commitment(completer);\n        // `prove_nullifier_inclusion` function expects the nullifier to be siloed (hashed with the address of\n        // the contract that emitted the nullifier) as it checks the value directly against the nullifier tree and all\n        // the nullifiers in the tree are siloed by the protocol.\n        let siloed_validity_commitment =\n            compute_siloed_nullifier(context.this_address(), validity_commitment);\n        context.get_anchor_block_header().prove_nullifier_inclusion(siloed_validity_commitment);\n\n        // We need to do two things:\n        //  - emit an unencrypted log containing the public fields (the value) via the private log channel. The\n        //  contract will later find it by searching for the expected tag (which is simply the partial note\n        //  commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_private_log(\n            self.compute_note_completion_log_padded_for_private_log(value),\n            NOTE_COMPLETION_LOG_LENGTH,\n        );\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    /// Computes a validity commitment for this partial note. The commitment cryptographically binds the note's private\n    /// data with the designated completer address. When the note is later completed in public execution, we can load\n    /// this commitment from the nullifier tree and verify that both the partial note (e.g. that the storage slot\n    /// corresponds to the correct owner, and that we're using the correct state variable) and completer are\n    /// legitimate.\n    pub fn compute_validity_commitment(self, completer: AztecAddress) -> Field {\n        poseidon2_hash_with_separator(\n            [self.commitment, completer.to_field()],\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT,\n        )\n    }\n\n    fn compute_note_completion_log(self, value: u128) -> [Field; NOTE_COMPLETION_LOG_LENGTH] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, value.to_field()]\n    }\n\n    fn compute_note_completion_log_padded_for_private_log(\n        self,\n        value: u128,\n    ) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS] {\n        let note_completion_log = self.compute_note_completion_log(value);\n        let padding = [0; PRIVATE_LOG_SIZE_IN_FIELDS - NOTE_COMPLETION_LOG_LENGTH];\n        note_completion_log.concat(padding)\n    }\n\n    fn compute_complete_note_hash(self, value: u128) -> Field {\n        // Here we finalize the note hash by including the (public) value into the partial note commitment. Note that we\n        // use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator(\n            [self.commitment, value.to_field()],\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\nimpl ToField for PartialUintNote {\n    fn to_field(self) -> Field {\n        self.commitment\n    }\n}\n\nimpl FromField for PartialUintNote {\n    fn from_field(field: Field) -> Self {\n        Self { commitment: field }\n    }\n}\n\nmod test {\n    use super::{\n        PartialUintNote, UintNote, UintPartialNotePrivateContent, UintPartialNotePrivateLogContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{address::AztecAddress, traits::{Deserialize, FromField, Packable}},\n        utils::array::subarray,\n    };\n\n    global value: u128 = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a UintNote has the same note hash as a PartialUintNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n\n        let note = UintNote { value, randomness, owner };\n        let note_hash = note.compute_note_hash(storage_slot);\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n\n        let partial_note = PartialUintNote {\n            commitment: partial_note_private_content.compute_partial_commitment(storage_slot),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(value);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular UintNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular UintNote.\n\n        let note = UintNote { value, randomness, owner };\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n        let commitment = partial_note_private_content.compute_partial_commitment(storage_slot);\n\n        let private_log_content =\n            UintPartialNotePrivateLogContent { owner, randomness, public_log_tag: commitment };\n        // The following is a misuse of the `deserialize` function, but this is just a test and it's better than\n        // letting devs manually construct it when they shouldn't be able to.\n        let partial_note = PartialUintNote::deserialize([commitment]);\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(value)[0],\n        );\n\n        // Then we extract all fields except the first of both logs (i.e. the public log tag), and combine them to\n        // produce the note's packed representation. This requires that the members of the intermediate structs are in\n        // the same order as in UintNote.\n        let private_log_without_public_tag: [_; 2] = subarray(private_log_content.pack(), 1);\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(value), 1);\n\n        assert_eq(private_log_without_public_tag.concat(public_log_without_tag), note.pack());\n    }\n}\n"
    },
    "46": {
      "path": "std/slice.nr",
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice with its index, returning a\n    // new slice containing the mapped elements.\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U] {\n        let mut ret = &[];\n        let mut index = 0;\n        for elem in self {\n            ret = ret.push_back(f(index, elem));\n            index += 1;\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for elem in self {\n            f(elem);\n        }\n    }\n\n    // Apply a function to each element of the slice with its index\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        let mut index = 0;\n        for elem in self {\n            f(index, elem);\n            index += 1;\n        }\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq(&[].map(|x| x + 1), &[]);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq(&[].mapi(|i, x| i * x + 1), &[]);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_each(|_x| assert(false));\n        assert(empty_slice == &[]);\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_eachi(|_i, _x| assert(false));\n        assert(empty_slice == &[]);\n    }\n\n    #[test]\n    fn map_example() {\n        let a = &[1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, &[2, 4, 6]);\n        assert_eq(a, &[1, 2, 3]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = &[1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, &[2, 5, 8]);\n        assert_eq(a, &[1, 2, 3]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_each(|a| { *b_ref = b_ref.push_back(a * 2); });\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { *b_ref = b_ref.push_back(i + a * 2); });\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n    #[test]\n    fn len_empty() {\n        let empty: [Field] = &[];\n        assert_eq(empty.len(), 0);\n    }\n\n    #[test]\n    fn len_single() {\n        assert_eq(&[42].len(), 1);\n    }\n\n    #[test]\n    fn len_multiple() {\n        assert_eq(&[1, 2, 3, 4, 5].len(), 5);\n    }\n\n    #[test]\n    fn push_back_empty() {\n        let empty: [Field] = &[];\n        let result = empty.push_back(42);\n        assert_eq(result.len(), 1);\n        assert_eq(result[0], 42);\n    }\n\n    #[test]\n    fn push_back_non_empty() {\n        let slice = &[1, 2, 3];\n        let result = slice.push_back(4);\n        assert_eq(result.len(), 4);\n        assert_eq(result, &[1, 2, 3, 4]);\n    }\n\n    #[test]\n    fn push_front_empty() {\n        let empty = &[];\n        let result = empty.push_front(42);\n        assert_eq(result.len(), 1);\n        assert_eq(result[0], 42);\n    }\n\n    #[test]\n    fn push_front_non_empty() {\n        let slice = &[1, 2, 3];\n        let result = slice.push_front(0);\n        assert_eq(result.len(), 4);\n        assert_eq(result, &[0, 1, 2, 3]);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds\")]\n    fn pop_back_empty() {\n        let slice: [Field] = &[];\n        let (_, _) = slice.pop_back();\n    }\n\n    #[test]\n    fn pop_back_one() {\n        let slice = &[42];\n        let (result, elem) = slice.pop_back();\n        assert_eq(result.len(), 0);\n        assert_eq(elem, 42);\n    }\n\n    #[test]\n    fn pop_back_multiple() {\n        let slice = &[1, 2, 3];\n        let (result, elem) = slice.pop_back();\n        assert_eq(result.len(), 2);\n        assert_eq(result, &[1, 2]);\n        assert_eq(elem, 3);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds\")]\n    fn pop_front_empty() {\n        let slice: [Field] = &[];\n        let (_, _) = slice.pop_front();\n    }\n\n    #[test]\n    fn pop_front_one() {\n        let slice = &[42];\n        let (elem, result) = slice.pop_front();\n        assert_eq(result.len(), 0);\n        assert_eq(elem, 42);\n    }\n\n    #[test]\n    fn pop_front_multiple() {\n        let slice = &[1, 2, 3];\n        let (elem, result) = slice.pop_front();\n        assert_eq(result.len(), 2);\n        assert_eq(result, &[2, 3]);\n        assert_eq(elem, 1);\n    }\n\n    #[test]\n    fn insert_beginning() {\n        let slice = &[1, 2, 3];\n        let result = slice.insert(0, 0);\n        assert_eq(result.len(), 4);\n        assert_eq(result, &[0, 1, 2, 3]);\n    }\n\n    #[test]\n    fn insert_middle() {\n        let slice = &[1, 2, 3];\n        let result = slice.insert(1, 99);\n        assert_eq(result.len(), 4);\n        assert_eq(result, &[1, 99, 2, 3]);\n    }\n\n    #[test]\n    fn insert_end() {\n        let slice = &[1, 2, 3];\n        let result = slice.insert(3, 4);\n        assert_eq(result.len(), 4);\n        assert_eq(result, &[1, 2, 3, 4]);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds\")]\n    fn insert_end_out_of_bounds() {\n        let slice = &[1, 2];\n        let _ = slice.insert(3, 4);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds\")]\n    fn remove_empty() {\n        let slice: [Field] = &[];\n        let (_, _) = slice.remove(0);\n    }\n\n    #[test]\n    fn remove_beginning() {\n        let slice = &[1, 2, 3];\n        let (result, elem) = slice.remove(0);\n        assert_eq(result.len(), 2);\n        assert_eq(result, &[2, 3]);\n        assert_eq(elem, 1);\n    }\n\n    #[test]\n    fn remove_middle() {\n        let slice = &[1, 2, 3];\n        let (result, elem) = slice.remove(1);\n        assert_eq(result.len(), 2);\n        assert_eq(result, &[1, 3]);\n        assert_eq(elem, 2);\n    }\n\n    #[test]\n    fn remove_end() {\n        let slice = &[1, 2, 3];\n        let (result, elem) = slice.remove(2);\n        assert_eq(result.len(), 2);\n        assert_eq(result, &[1, 2]);\n        assert_eq(elem, 3);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds\")]\n    fn remove_end_out_of_bounds() {\n        let slice = &[1, 2];\n        let (_, _) = slice.remove(2);\n    }\n\n    #[test]\n    fn fold_empty() {\n        let empty = &[];\n        let result = empty.fold(10, |acc, x| acc + x);\n        assert_eq(result, 10);\n    }\n\n    #[test]\n    fn fold_single() {\n        let slice = &[5];\n        let result = slice.fold(10, |acc, x| acc + x);\n        assert_eq(result, 15);\n    }\n\n    #[test]\n    fn fold_multiple() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.fold(0, |acc, x| acc + x);\n        assert_eq(result, 10);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds\")]\n    fn reduce_empty() {\n        let empty: [Field] = &[];\n        let _ = empty.reduce(|a, b| a + b);\n    }\n\n    #[test]\n    fn reduce_single() {\n        let slice = &[42];\n        let result = slice.reduce(|a, b| a + b);\n        assert_eq(result, 42);\n    }\n\n    #[test]\n    fn reduce_multiple() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.reduce(|a, b| a + b);\n        assert_eq(result, 10);\n    }\n\n    #[test]\n    fn filter_empty() {\n        let empty = &[];\n        let result = empty.filter(|x| x > 0);\n        assert_eq(result.len(), 0);\n    }\n\n    #[test]\n    fn filter_all_true() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.filter(|x| x > 0);\n        assert_eq(result, slice);\n    }\n\n    #[test]\n    fn filter_all_false() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.filter(|x| x > 10);\n        assert_eq(result.len(), 0);\n    }\n\n    #[test]\n    fn filter_some() {\n        let slice = &[1, 2, 3, 4, 5];\n        let result = slice.filter(|x| x % 2 == 0);\n        assert_eq(result, &[2, 4]);\n    }\n\n    #[test]\n    fn all_empty() {\n        let empty = &[];\n        let result = empty.all(|x| x > 0);\n        assert_eq(result, true);\n    }\n\n    #[test]\n    fn all_true() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.all(|x| x > 0);\n        assert_eq(result, true);\n    }\n\n    #[test]\n    fn all_false() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.all(|x| x > 2);\n        assert_eq(result, false);\n    }\n\n    #[test]\n    fn any_empty() {\n        let empty = &[];\n        let result = empty.any(|x| x > 0);\n        assert_eq(result, false);\n    }\n\n    #[test]\n    fn any_true() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.any(|x| x > 3);\n        assert_eq(result, true);\n    }\n\n    #[test]\n    fn any_false() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.any(|x| x > 10);\n        assert_eq(result, false);\n    }\n\n    // utility method tests\n    #[test]\n    fn append_empty_to_empty() {\n        let empty1: [Field] = &[];\n        let empty2: [Field] = &[];\n        let result = empty1.append(empty2);\n        assert_eq(result.len(), 0);\n    }\n\n    #[test]\n    fn append_empty_to_non_empty() {\n        let slice = &[1, 2, 3];\n        let empty = &[];\n        let result = slice.append(empty);\n        assert_eq(result, slice);\n    }\n\n    #[test]\n    fn append_non_empty_to_empty() {\n        let empty = &[];\n        let slice = &[1, 2, 3];\n        let result = empty.append(slice);\n        assert_eq(result, slice);\n    }\n\n    #[test]\n    fn append_two_non_empty() {\n        let slice1 = &[1, 2];\n        let slice2 = &[3, 4, 5];\n        let result = slice1.append(slice2);\n        assert_eq(result, &[1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    fn as_array_single() {\n        let slice = &[42];\n        let array: [Field; 1] = slice.as_array();\n        assert_eq(array[0], 42);\n    }\n\n    #[test]\n    fn as_array_multiple() {\n        let slice = &[1, 2, 3];\n        let array: [Field; 3] = slice.as_array();\n        assert_eq(array[0], 1);\n        assert_eq(array[1], 2);\n        assert_eq(array[2], 3);\n    }\n\n    // complex scenarios\n    #[test]\n    fn chain_operations() {\n        let slice = &[1, 2, 3, 4, 5];\n        let result = slice.filter(|x| x % 2 == 0).map(|x| x * 2).fold(0, |acc, x| acc + x);\n        assert_eq(result, 12); // (2*2) + (4*2) = 4 + 8 = 12\n    }\n\n    #[test]\n    fn nested_operations() {\n        let slice = &[1, 2, 3, 4];\n        let filtered = slice.filter(|x| x > 1);\n        let mapped = filtered.map(|x| x * x);\n        let sum = mapped.fold(0, |acc, x| acc + x);\n        assert_eq(sum, 29); // 2^2 + 3^2 + 4^2 = 4 + 9 + 16 = 29\n    }\n\n    #[test]\n    fn single_element_operations() {\n        let single = &[42];\n\n        // Test all operations on single element\n        assert_eq(single.len(), 1);\n\n        let pushed_back = single.push_back(99);\n        assert_eq(pushed_back, &[42, 99]);\n\n        let pushed_front = single.push_front(0);\n        assert_eq(pushed_front, &[0, 42]);\n\n        let (popped_back_slice, popped_back_elem) = single.pop_back();\n        assert_eq(popped_back_slice.len(), 0);\n        assert_eq(popped_back_elem, 42);\n\n        let (popped_front_elem, popped_front_slice) = single.pop_front();\n        assert_eq(popped_front_slice.len(), 0);\n        assert_eq(popped_front_elem, 42);\n\n        let inserted = single.insert(0, 0);\n        assert_eq(inserted, &[0, 42]);\n\n        let (removed_slice, removed_elem) = single.remove(0);\n        assert_eq(removed_slice.len(), 0);\n        assert_eq(removed_elem, 42);\n    }\n\n    #[test]\n    fn boundary_conditions() {\n        let slice = &[1, 2, 3];\n\n        // insert at boundaries\n        let at_start = slice.insert(0, 0);\n        assert_eq(at_start, &[0, 1, 2, 3]);\n\n        let at_end = slice.insert(3, 4);\n        assert_eq(at_end, &[1, 2, 3, 4]);\n\n        // remove at boundaries\n        let (removed_start, elem_start) = slice.remove(0);\n        assert_eq(removed_start, &[2, 3]);\n        assert_eq(elem_start, 1);\n\n        let (removed_end, elem_end) = slice.remove(2);\n        assert_eq(removed_end, &[1, 2]);\n        assert_eq(elem_end, 3);\n    }\n\n    #[test]\n    fn complex_predicates() {\n        let slice = &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\n        let even_greater_than_5 = slice.filter(|x| (x % 2 == 0) & (x > 5));\n        assert_eq(even_greater_than_5, &[6, 8, 10]);\n\n        let all_positive_and_less_than_20 = slice.all(|x| (x > 0) & (x < 20));\n        assert_eq(all_positive_and_less_than_20, true);\n\n        let any_divisible_by_7 = slice.any(|x| x % 7 == 0);\n        assert_eq(any_divisible_by_7, true);\n    }\n\n    #[test]\n    fn identity_operations() {\n        let slice = &[1, 2, 3, 4, 5];\n\n        let mapped_identity = slice.map(|x| x);\n        assert_eq(mapped_identity, slice);\n\n        let filtered_all = slice.filter(|_| true);\n        assert_eq(filtered_all, slice);\n\n        let filtered_none = slice.filter(|_| false);\n        assert_eq(filtered_none.len(), 0);\n    }\n\n    #[test(should_fail)]\n    fn as_array_size_mismatch() {\n        let slice = &[1, 2, 3];\n        let _: [Field; 5] = slice.as_array(); // size doesn't match\n    }\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        if result {\n            for i in 0..self.len() {\n                result &= self[i].eq(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let self_len = self.len();\n        let other_len = other.len();\n        let min_len = if self_len < other_len {\n            self_len\n        } else {\n            other_len\n        };\n\n        let mut result = Ordering::equal();\n        for i in 0..min_len {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self_len.cmp(other_len)\n        }\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use super::{Eq, max, min, Ord};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n\n    #[test]\n    fn correctly_handles_unequal_length_slices() {\n        let slice_1 = &[0, 1, 2, 3];\n        let slice_2 = &[0, 1, 2];\n        assert(!slice_1.eq(slice_2));\n    }\n\n    #[test]\n    fn lexicographic_ordering_for_slices() {\n        assert(&[2_u32].cmp(&[1_u32, 1_u32, 1_u32]) == super::Ordering::greater());\n        assert(&[1_u32, 2_u32].cmp(&[1_u32, 2_u32, 3_u32]) == super::Ordering::less());\n    }\n}\n"
    },
    "50": {
      "path": "/home/jpag/Playground/aztec/crosschain/wormhole-demo/packages/aztec/src/message_bridge/src/main.nr",
      "source": "use aztec::macros::aztec;\n\npub mod types;\npub mod utils;\n\n#[aztec]\npub contract MessageBridge {\n    use aztec::{\n        macros::{\n            functions::{initializer, external, internal},\n            storage::storage,\n        },\n        protocol_types::address::AztecAddress,\n        state_vars::{map::Map, public_mutable::PublicMutable, public_immutable::PublicImmutable},\n    };\n    use crate::{\n        types::{config::Config, emitter::Emitter},\n        utils::vaa::{encode_message_payload, decode_vaa},\n    };\n    use wormhole::Wormhole;\n\n    // ============================================================================\n    // STORAGE\n    // ============================================================================\n\n    #[storage]\n    struct Storage<Context> {\n        // Core configuration (immutable after deployment)\n        config: PublicImmutable<Config, Context>,\n\n        // Owner/admin address\n        owner: PublicMutable<AztecAddress, Context>,\n\n        // Registered emitters\n        // chain id => emitter address (one emitter per chain)\n        registered_emitters: Map<u16, PublicImmutable<Emitter, Context>, Context>,\n\n        // currently stored value\n        current_value: PublicMutable<u128, Context>,\n    }\n\n    // ============================================================================\n    // INITIALIZATION\n    // ============================================================================\n\n    #[external(\"public\")]\n    #[initializer]\n    fn constructor(\n        wormhole_address: AztecAddress,\n        chain_id: u16,\n        owner: AztecAddress,\n        message_fee: u128,\n        consistency: u8\n    ) {\n        storage.config.initialize(Config::new(\n            wormhole_address,\n            chain_id,\n            message_fee,\n            consistency\n        ));\n        storage.owner.write(owner);\n\n        // Initialize last received values to zero\n        storage.current_value.write(0);\n    }\n\n    /**\n     * Register up to 8 emitter addresses for source chains\n     *\n     * @param source_chain_id The chain ID of the source chain\n     */\n    #[external(\"public\")]\n    fn register_emitter(\n        source_chain_ids: BoundedVec<u16, 8>,\n        emitter_addresses: BoundedVec<[u8; 32], 8>,\n    ) {\n        // 1. check caller is admin\n        let owner = storage.owner.read();\n        assert(owner == context.msg_sender().unwrap(), \"Caller is not owner\");\n\n        // 2. check lengths match\n        assert(\n            source_chain_ids.len() == emitter_addresses.len(),\n            \"Source chain IDs and emitter addresses length mismatch\"\n        );\n        // 3. register emitters (store full 32-byte addresses)\n        for i in 0..8 {\n            if i < source_chain_ids.len() {\n                let source_chain_id = source_chain_ids.get_unchecked(i);\n                let emitter_address = emitter_addresses.get_unchecked(i);\n                storage.registered_emitters\n                    .at(source_chain_id)\n                    .initialize(Emitter { address: emitter_address });\n            }\n        }\n    }\n\n    // ============================================================================\n    // SEND MESSAGE (Aztec -> EVM)\n    // ============================================================================\n\n    #[external(\"public\")]\n    fn send_value_public(\n        destination_chain_id: u16,\n        value: u128,\n        fee_nonce: Field,\n    ) {\n        // no auth checks\n        let caller = context.msg_sender().unwrap();\n        let config = storage.config.read();\n\n        // 1. Encode the message payload (just destination_chain_id + value)\n        let wormhole_payload = encode_message_payload(value, destination_chain_id);\n\n        // 2. Publish message publicly through Wormhole\n        let _ = Wormhole::at(config.wormhole_address).publish_message_in_public(\n            0, // nonce\n            wormhole_payload,\n            config.message_fee,\n            config.consistency,\n            caller,\n            fee_nonce,\n        ).call(&mut context);\n    }\n\n    #[external(\"private\")]\n    fn send_value_private(\n        destination_chain_id: u16,\n        value: u128,\n        fee_nonce: Field,\n    ) {\n        // no auth checks\n        let caller = context.msg_sender().unwrap();\n        let config = storage.config.read();\n\n        // 1. Encode the message payload (just destination_chain_id + value)\n        let wormhole_payload = encode_message_payload(value, destination_chain_id);\n\n        // 2. Publish message privately through Wormhole\n        let _ = Wormhole::at(config.wormhole_address).publish_message_in_private(\n            0, // nonce\n            wormhole_payload,\n            config.message_fee,\n            config.consistency,\n            caller,\n            fee_nonce,\n        ).call(&mut context);\n    }\n\n    // ============================================================================\n    // RECEIVE MESSAGE (EVM -> Aztec)\n    // ============================================================================\n    \n    #[external(\"private\")]\n    fn receive_value(vaa: [u8; 2000], length: u32) {\n        // 1. verify the VAA through Wormhole\n        let config = storage.config.read();\n        Wormhole::at(config.wormhole_address).verify_vaa(vaa, length).call(&mut context);\n\n        // 2. decode the VAA (envelope + payload) and compute vaa nullifier\n        let (vaa_envelope, vaa_payload, vaa_nullifier) = decode_vaa(vaa);\n\n        // 3. validate destination chain is this chain\n        assert(\n            vaa_payload.destination_chain_id == config.chain_id,\n            \"Invalid destination chain ID\"\n        );\n\n        // 4. emit the nullifier to prevent replays\n        // note: will fail if nullifier has already been emitted\n        context.push_nullifier(vaa_nullifier);\n\n        // 5. validate emitter and update state (done in public to read public storage)\n        MessageBridge::at(context.this_address())\n            ._validate_emitter_and_update_value(\n                vaa_envelope.emitter_chain_id,\n                vaa_envelope.emitter_address,\n                vaa_payload.value,\n            )\n            .enqueue(&mut context);\n    }\n\n    #[external(\"public\")]\n    #[internal]\n    fn _validate_emitter_and_update_value(\n        emitter_chain_id: u16,\n        emitter_address: [u8; 32],\n        value: u128,\n    ) {\n        // Validate emitter from VAA envelope (not sender from payload)\n        let registered_emitter = storage.registered_emitters\n            .at(emitter_chain_id)\n            .read().address;\n        assert(registered_emitter == emitter_address, \"Emitter not registered\");\n\n        // Update state with received value\n        storage.current_value.write(value);\n    }\n\n    // ============================================================================\n    // VIEW FUNCTIONS\n    // ============================================================================\n\n    #[external(\"utility\")]\n    unconstrained fn get_config() -> Config {\n        storage.config.read()\n    }\n\n    #[external(\"utility\")]\n    unconstrained fn get_owner() -> AztecAddress {\n        storage.owner.read()\n    }\n\n    #[external(\"utility\")]\n    unconstrained fn is_emitter_registered(chain_id: u16, emitter_address: [u8; 32]) -> bool {\n        let registered_emitter = storage.registered_emitters\n            .at(chain_id)\n            .read().address;\n        registered_emitter == emitter_address\n    }\n\n    #[external(\"utility\")]\n    unconstrained fn get_registered_emitter(chain_id: u16) -> [u8; 32] {\n        storage.registered_emitters\n            .at(chain_id)\n            .read().address\n    }\n\n    #[external(\"utility\")]\n    unconstrained fn get_current_value() -> u128 {\n        storage.current_value.read()\n    }\n}\n"
    },
    "52": {
      "path": "/home/jpag/Playground/aztec/crosschain/wormhole-demo/packages/aztec/src/message_bridge/src/types/emitter.nr",
      "source": "use aztec::protocol_types::traits::Packable;\n\n/// Emitter address which must be packed\n#[derive(Eq)]\npub struct Emitter {\n    pub address: [u8; 32]\n}\n\nimpl Packable for Emitter {\n\n    let N: u32 = 2;\n\n    fn pack(self) -> [Field; Self::N] {\n        let mut chunk_1_bytes = [0; 31];\n        for i in 0..31 {\n            chunk_1_bytes[i] = self.address[i];\n        }\n        let chunk_1 = Field::from_be_bytes(chunk_1_bytes);\n        let chunk_2 = self.address[31] as Field;\n        [chunk_1, chunk_2]\n    }\n\n    fn unpack(packed: [Field; Self::N]) -> Self {\n        let chunk_1_bytes: [u8; 31] = Field::to_be_bytes(packed[0]);\n        let mut address = [0; 32];\n        for i in 0..31 {\n            address[i] = chunk_1_bytes[i];\n        }\n        address[31] = packed[1] as u8;\n        Self { address }\n    }\n} \n"
    },
    "54": {
      "path": "/home/jpag/Playground/aztec/crosschain/wormhole-demo/packages/aztec/src/message_bridge/src/utils/mod.nr",
      "source": "pub mod vaa;\n\n// VAA structure offsets (hardcoded for 1 signature)\npub global VAA_HEADER_SIZE: u32 = 6;        // version(1) + guardian_set(4) + num_sigs(1)\npub global VAA_SIGNATURE_SIZE: u32 = 66;    // guardian_index(1) + signature(64) + recovery(1)\npub global VAA_ENVELOPE_START: u32 = VAA_HEADER_SIZE + VAA_SIGNATURE_SIZE; // = 72\npub global VAA_ENVELOPE_SIZE: u32 = 51;     // timestamp(4) + nonce(4) + emitter_chain(2) + emitter_addr(32) + sequence(8) + consistency(1)\npub global VAA_PAYLOAD_START: u32 = VAA_ENVELOPE_START + VAA_ENVELOPE_SIZE; // = 123\n\npub global VAA_MAX_LENGTH: u32 = 2000;      // max VAA length in Wormhole spec\npub global VAA_BODY_MAX_LENGTH: u32 = 1860; // max body length in Wormhole VAA spec\n\n// Message payload structure (18 bytes): destinationChainId (2) + value (16)\npub global MESSAGE_PAYLOAD_LENGTH: u32 = 18;\npub global MESSAGE_NULLIFIER_LENGTH: u32 = VAA_ENVELOPE_SIZE + MESSAGE_PAYLOAD_LENGTH; // 51 + 18 = 69\npub global MESSAGE_NULLIFIER_PACKED_LENGTH: u32 = 3; // ceil(69 / 31) = 3\n\n/// Decoded VAA envelope (excludes header and signatures)\npub struct DecodedVAAEnvelope {\n    pub timestamp: u32,\n    pub nonce: u32,\n    pub emitter_chain_id: u16,\n    pub emitter_address: [u8; 32],\n    pub sequence: u64,\n    pub consistency_level: u8,\n}\n\n\n/// Decoded message payload (18 bytes)\npub struct DecodedVAAPayload {\n    pub destination_chain_id: u16,\n    pub value: u128,\n}\n\n// probably should just use Field::to_le_bytes but meh\npub fn u16_to_u8(value: u16) -> [u8; 2] {\n    // Safety: constrained below, use unconstrained for bitwise ops\n    let decomposed = unsafe { _u16_to_u8(value) };\n    let asserted = decomposed[0] as u16 * 256 + decomposed[1] as u16;\n    assert(asserted == value, \"u16 to u8 conversion failed\");\n    decomposed\n}\n\nunconstrained fn _u16_to_u8(value: u16) -> [u8; 2] {\n    let high = (value >> 8) as u8;\n    let low = (value & 0xFF) as u8;\n    [high, low]\n}"
    },
    "55": {
      "path": "/home/jpag/Playground/aztec/crosschain/wormhole-demo/packages/aztec/src/message_bridge/src/utils/vaa.nr",
      "source": "use keccak256::keccak256;\nuse poseidon::poseidon2::Poseidon2;\nuse crate::utils::{\n    VAA_MAX_LENGTH,\n    VAA_ENVELOPE_START,\n    VAA_PAYLOAD_START,\n    MESSAGE_NULLIFIER_LENGTH,\n    MESSAGE_NULLIFIER_PACKED_LENGTH,\n    DecodedVAAEnvelope,\n    DecodedVAAPayload,\n    u16_to_u8,\n};\nuse nodash::pack_bytes;\n\npub struct DecodedVAA {\n    pub envelope: DecodedVAAEnvelope,\n    pub payload: DecodedVAAPayload,\n}\n\n/// Parse a raw VAA and extract envelope, payload, and compute nullifier\n///\n/// VAA structure (with 1 signature):\n///   Bytes 0-5:     Header (version, guardian set, num sigs) - skipped\n///   Bytes 6-71:    Signature - skipped\n///   Bytes 72-122:  Envelope (timestamp, nonce, emitter chain, emitter addr, sequence, consistency)\n///   Bytes 123+:    Payload\npub fn decode_vaa(vaa: [u8; VAA_MAX_LENGTH]) -> (\n    DecodedVAAEnvelope,\n    DecodedVAAPayload,\n    Field,\n) {\n    let envelope = decode_vaa_envelope(vaa);\n    let payload = decode_vaa_payload(vaa);\n    let nullifier = compute_vaa_nullifier(vaa);\n    (envelope, payload, nullifier)\n}\n\n/// Parse the VAA envelope (starts at byte 72 for 1 signature)\n///\n/// Envelope structure (51 bytes):\n///   Bytes 0-3:   timestamp (u32, big-endian)\n///   Bytes 4-7:   nonce (u32, big-endian)\n///   Bytes 8-9:   emitter_chain_id (u16, big-endian)\n///   Bytes 10-41: emitter_address (32 bytes)\n///   Bytes 42-49: sequence (u64, big-endian)\n///   Byte 50:     consistency_level (u8)\npub fn decode_vaa_envelope(vaa: [u8; VAA_MAX_LENGTH]) -> DecodedVAAEnvelope {\n    let offset = VAA_ENVELOPE_START;\n\n    // timestamp (4 bytes, big-endian)\n    let mut timestamp_bytes: [u8; 4] = [0; 4];\n    for i in 0..4 {\n        timestamp_bytes[i] = vaa[offset + i];\n    }\n    let timestamp = Field::from_be_bytes(timestamp_bytes) as u32;\n\n    // nonce (4 bytes, big-endian)\n    let mut nonce_bytes: [u8; 4] = [0; 4];\n    for i in 0..4 {\n        nonce_bytes[i] = vaa[offset + 4 + i];\n    }\n    let nonce = Field::from_be_bytes(nonce_bytes) as u32;\n\n    // emitter_chain_id (2 bytes, big-endian)\n    let mut chain_id_bytes: [u8; 2] = [0; 2];\n    for i in 0..2 {\n        chain_id_bytes[i] = vaa[offset + 8 + i];\n    }\n    let emitter_chain_id = Field::from_be_bytes(chain_id_bytes) as u16;\n\n    // emitter_address (32 bytes)\n    let mut emitter_address: [u8; 32] = [0; 32];\n    for i in 0..32 {\n        emitter_address[i] = vaa[offset + 10 + i];\n    }\n\n    // sequence (8 bytes, big-endian)\n    let mut sequence_bytes: [u8; 8] = [0; 8];\n    for i in 0..8 {\n        sequence_bytes[i] = vaa[offset + 42 + i];\n    }\n    let sequence = Field::from_be_bytes(sequence_bytes) as u64;\n\n    // consistency_level (1 byte)\n    let consistency_level = vaa[offset + 50];\n\n    DecodedVAAEnvelope {\n        timestamp,\n        nonce,\n        emitter_chain_id,\n        emitter_address,\n        sequence,\n        consistency_level,\n    }\n}\n\n/// Parse the VAA payload (starts at byte 123 for 1 signature)\n///\n/// Payload structure (18 bytes):\n///   Bytes 0-1:   destination_chain_id (u16, big-endian)\n///   Bytes 2-17:  value (u128, big-endian)\npub fn decode_vaa_payload(vaa: [u8; VAA_MAX_LENGTH]) -> DecodedVAAPayload {\n    let offset = VAA_PAYLOAD_START;\n\n    // destination_chain_id (2 bytes, big-endian)\n    let destination_chain_id = (\n        (vaa[offset] as Field) * 256\n        + (vaa[offset + 1] as Field)\n    ) as u16;\n\n    // value (16 bytes, big-endian) - parse as u128 via Field multiplication\n    let mut value_bytes: [u8; 16] = [0; 16];\n    for i in 0..16 {\n        value_bytes[i] = vaa[offset + 2 + i];\n    }\n    let value = Field::from_be_bytes(value_bytes) as u128;\n\n    DecodedVAAPayload {\n        destination_chain_id,\n        value,\n    }\n}\n\n/// Compute nullifier from VAA bytes (for replay protection)\nfn compute_vaa_nullifier(vaa: [u8; VAA_MAX_LENGTH]) -> Field {\n    // Pack the relevant bytes (envelope + payload) for hashing\n    let mut nullifier_bytes = [0; MESSAGE_NULLIFIER_LENGTH];\n    for i in 0..MESSAGE_NULLIFIER_LENGTH {\n        nullifier_bytes[i] = vaa[VAA_ENVELOPE_START + i];\n    }\n\n    let packed = pack_bytes(nullifier_bytes);\n    Poseidon2::hash(packed, MESSAGE_NULLIFIER_PACKED_LENGTH)\n}\n\n/// Encode a message payload for sending via Wormhole (Aztec -> EVM)\n///\n/// Payload structure (18 bytes):\n///   Bytes 0-1:   destination_chain_id (u16, big-endian)\n///   Bytes 2-17:  value (u128, big-endian)\n///\n/// Returns 8 chunks of 31 bytes for Aztec Field compatibility\npub fn encode_message_payload(\n    value: u128,\n    destination_chain_id: u16,\n) -> [[u8; 31]; 8] {\n    let mut wormhole_payload: [[u8; 31]; 8] = [[0; 31]; 8];\n\n    let destination_chain_bytes = u16_to_u8(destination_chain_id);\n    let value_bytes: [u8; 16] = Field::to_be_bytes(value as Field);\n\n    // Chunk 0: destination_chain_id (2 bytes) + value (16 bytes) = 18 bytes total\n    wormhole_payload[0][0] = destination_chain_bytes[0];\n    wormhole_payload[0][1] = destination_chain_bytes[1];\n    for i in 0..16 {\n        wormhole_payload[0][2 + i] = value_bytes[i];\n    }\n\n    wormhole_payload\n}\n\n// Keccak hash of VAA body (for signature verification)\npub fn compute_vaa_hash(body_bytes: [u8; 1860], body_length: u32) -> [u8; 32] {\n    let mut actual_body = [0; 1860];\n    for i in 0..body_length {\n        actual_body[i] = body_bytes[i];\n    }\n\n    // Double hash as per Wormhole spec\n    let hash: [u8; 32] = keccak256(actual_body, body_length);\n    let double_hash: [u8; 32] = keccak256(hash, 32);\n\n    double_hash\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0, \"cannot pop from an empty vector\");\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            let _ = vec.get(0);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_beyond_length() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            let _ = vec.get(3);\n        }\n\n        #[test]\n        fn get_works_within_bounds() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(2), 3);\n            assert_eq(vec.get(4), 5);\n        }\n\n        #[test]\n        fn get_unchecked_works() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(0), 1);\n            assert_eq(vec.get_unchecked(2), 3);\n        }\n\n        #[test]\n        fn get_unchecked_works_past_len() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(4), 0);\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_setting_beyond_length() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            vec.set(3, 4);\n        }\n\n        #[test]\n        fn set_unchecked_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(0, 10);\n            assert_eq(vec.get(0), 10);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn set_unchecked_operations_past_len() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(3, 40);\n            assert_eq(vec.get(3), 40);\n        }\n\n        #[test]\n        fn set_preserves_other_elements() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            vec.set(2, 30);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 30);\n            assert_eq(vec.get(3), 4);\n            assert_eq(vec.get(4), 5);\n        }\n    }\n\n    mod any {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn returns_false_if_predicate_not_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, false, false]);\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn returns_true_if_predicate_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, true, true]);\n            let result = vec.any(|value| value);\n\n            assert(result);\n        }\n\n        #[test]\n        fn returns_false_on_empty_boundedvec() {\n            let vec: BoundedVec<bool, 0> = BoundedVec::new();\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn any_with_complex_predicates() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            assert(vec.any(|x| x > 3));\n            assert(!vec.any(|x| x > 10));\n            assert(vec.any(|x| x % 2 == 0)); // has a even number\n            assert(vec.any(|x| x == 3)); // has a specific value\n        }\n\n        #[test]\n        fn any_with_partial_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            assert(vec.any(|x| x == 1));\n            assert(vec.any(|x| x == 2));\n            assert(!vec.any(|x| x == 3));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn map_with_conditional_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.map(|x| if x % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([1, 4, 3, 8]);\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn map_preserves_length() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|x| x * 2);\n\n            assert_eq(result.len(), vec.len());\n            assert_eq(result.max_len(), vec.max_len());\n        }\n\n        #[test]\n        fn map_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let result = vec.map(|x| x * 2);\n            assert_eq(result, vec);\n            assert_eq(result.len(), 0);\n            assert_eq(result.max_len(), 5);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn mapi_with_index_branching_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.mapi(|i, x| if i % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([2, 2, 6, 4]);\n            assert_eq(result, expected);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_each_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_each(|_| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_each_with_side_effects() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let mut seen = BoundedVec::<u32, 3>::new();\n            let seen_ref = &mut seen;\n            vec.for_each(|x| seen_ref.push(x));\n            assert_eq(seen, vec);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_eachi_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_eachi(|_, _| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_eachi_with_index_tracking() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([10, 20, 30]);\n            let mut indices = BoundedVec::<u32, 3>::new();\n            let indices_ref = &mut indices;\n            vec.for_eachi(|i, _| indices_ref.push(i));\n\n            let expected = BoundedVec::from_array([0, 1, 2]);\n            assert_eq(indices, expected);\n        }\n\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n\n        #[test]\n        fn from_array_preserves_order() {\n            let array = [5, 3, 1, 4, 2];\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array(array);\n            for i in 0..array.len() {\n                assert_eq(vec.get(i), array[i]);\n            }\n        }\n\n        #[test]\n        fn from_array_with_different_types() {\n            let bool_array = [true, false, true];\n            let bool_vec: BoundedVec<bool, 3> = BoundedVec::from_array(bool_array);\n            assert_eq(bool_vec.len(), 3);\n            assert_eq(bool_vec.get(0), true);\n            assert_eq(bool_vec.get(1), false);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n\n    mod push_pop {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn push_and_pop_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            assert_eq(vec.len(), 0);\n\n            vec.push(1);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 1);\n\n            vec.push(2);\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.get(1), 2);\n\n            let popped = vec.pop();\n            assert_eq(popped, 2);\n            assert_eq(vec.len(), 1);\n\n            let popped2 = vec.pop();\n            assert_eq(popped2, 1);\n            assert_eq(vec.len(), 0);\n        }\n\n        #[test(should_fail_with = \"push out of bounds\")]\n        fn push_to_full_vector() {\n            let mut vec: BoundedVec<u32, 2> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n            vec.push(3); // should panic\n        }\n\n        #[test(should_fail_with = \"cannot pop from an empty vector\")]\n        fn pop_from_empty_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let _ = vec.pop(); // should panic\n        }\n\n        #[test]\n        fn push_pop_cycle() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n\n            // push to full\n            vec.push(1);\n            vec.push(2);\n            vec.push(3);\n            assert_eq(vec.len(), 3);\n\n            // pop all\n            assert_eq(vec.pop(), 3);\n            assert_eq(vec.pop(), 2);\n            assert_eq(vec.pop(), 1);\n            assert_eq(vec.len(), 0);\n\n            // push again\n            vec.push(4);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 4);\n        }\n    }\n\n    mod extend {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn extend_from_array() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_slice() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_bounded_vec() {\n            let mut vec1: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut vec2: BoundedVec<u32, 3> = BoundedVec::new();\n\n            vec1.push(1);\n            vec2.push(2);\n            vec2.push(3);\n\n            vec1.extend_from_bounded_vec(vec2);\n\n            assert_eq(vec1.len(), 3);\n            assert_eq(vec1.get(0), 1);\n            assert_eq(vec1.get(1), 2);\n            assert_eq(vec1.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"extend_from_array out of bounds\")]\n        fn extend_array_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3, 4]); // should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_slice out of bounds\")]\n        fn extend_slice_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3, 4]); // S]should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_bounded_vec out of bounds\")]\n        fn extend_bounded_vec_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            let other: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            vec.extend_from_bounded_vec(other); // should panic\n        }\n\n        #[test]\n        fn extend_with_empty_collections() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let original_len = vec.len();\n\n            vec.extend_from_array([]);\n            assert_eq(vec.len(), original_len);\n\n            vec.extend_from_slice(&[]);\n            assert_eq(vec.len(), original_len);\n\n            let empty: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.extend_from_bounded_vec(empty);\n            assert_eq(vec.len(), original_len);\n        }\n    }\n\n    mod storage {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn storage_consistency() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            // test initial storage state\n            assert_eq(vec.storage(), [0, 0, 0, 0, 0]);\n\n            vec.push(1);\n            vec.push(2);\n\n            // test storage after modifications\n            assert_eq(vec.storage(), [1, 2, 0, 0, 0]);\n\n            // storage doesn't change length\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.max_len(), 5);\n        }\n\n        #[test]\n        fn storage_after_pop() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n\n            let _ = vec.pop();\n            // after pop, the last element should be zeroed\n            assert_eq(vec.storage(), [1, 2, 0]);\n            assert_eq(vec.len(), 2);\n        }\n\n        #[test]\n        fn vector_immutable() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let storage = vec.storage();\n\n            assert_eq(storage, [1, 2, 3]);\n\n            // Verify that the original vector is unchanged\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n    }\n}\n"
    },
    "64": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push(self, value: T)\n    where\n        T: Serialize,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get(self, index: u32) -> T\n    where\n        T: Deserialize,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n\n    global SLOT: Field = 1230;\n\n    #[test]\n    unconstrained fn empty_array() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            let _: Field = array.get(0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            assert_eq(array.len(), 1);\n            assert_eq(array.get(0), 5);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            let _ = array.get(1);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(5);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            assert_eq(array.len(), 3);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 8);\n            assert_eq(array.get(2), 9);\n\n            array.remove(1);\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 9);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            array.remove(1);\n            array.remove(1);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n            // we do not care about the order in which each tuple was passed to the closure.\n            let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n            array.for_each(|index, value| { called_with.push((index, value)); });\n\n            assert_eq(called_with.len(), 3);\n            assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n            assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n            assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| {\n                if index == 1 {\n                    array.remove(index);\n                }\n            });\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 4);\n            assert_eq(array.get(1), 6);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all_no_copy() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We test that the utilityCopyCapsule was never called, which is the expensive operation we want to avoid.\n            let mock = std::test::OracleMock::mock(\"utilityCopyCapsule\");\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(mock.times_called(), 0);\n        });\n    }\n}\n"
    },
    "65": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PrivateCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    /// Makes the call to this private function.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// This enables contracts to interact with each other while maintaining\n    /// privacy. This \"composability\" of private contract functions is a key\n    /// feature of the Aztec network.\n    ///\n    /// If a user's transaction includes multiple private function calls, then\n    /// by the design of Aztec, the following information will remain private[1]:\n    /// - The function selectors and contract addresses of all private function\n    ///   calls will remain private, so an observer of the public mempool will\n    ///   not be able to look at a tx and deduce which private functions have\n    ///   been executed.\n    /// - The arguments and return values of all private function calls will\n    ///   remain private.\n    /// - The person who initiated the tx will remain private.\n    /// - The notes and nullifiers and private logs that are emitted by all\n    ///   private function calls will (if designed well) not leak any user\n    ///   secrets, nor leak which functions have been executed.\n    ///\n    /// [1] Caveats: Some of these privacy guarantees depend on how app\n    /// developers design their smart contracts. Some actions _can_ leak\n    /// information, such as:\n    /// - Calling an internal public function.\n    /// - Calling a public function and not setting msg_sender to Option::none\n    ///   (see https://github.com/AztecProtocol/aztec-packages/pull/16433)\n    /// - Calling any public function will always leak details about the nature\n    ///   of the transaction, so devs should be careful in their contract\n    ///   designs. If it can be done in a private function, then that will give\n    ///   the best privacy.\n    /// - Not padding the side-effects of a tx to some standardised, uniform\n    ///   size. The kernel circuits can take hints to pad side-effects, so a\n    ///   wallet should be able to request for a particular amount of padding.\n    ///   Wallets should ideally agree on some standard.\n    ///   - Padding should include:\n    ///     - Padding the lengths of note & nullifier arrays\n    ///     - Padding private logs with random fields, up to some standardised\n    ///       size.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Advanced\n    /// * The call is added to the private call stack and executed by kernel\n    ///   circuits after this function completes\n    /// * The called function can modify its own contract's private state\n    /// * Side effects from the called function are included in this transaction\n    /// * The call inherits the current transaction's context and gas limits\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub fn call(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n\n        // If T is () (i.e. if the function does not return anything) then `get_preimage` will constrain that the\n        // returns hash is empty as per the protocol rules.\n        returns_hash.get_preimage()\n    }\n\n    /// Makes a _read-only_ call to this private function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// See `call` for more general info on private function calls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub fn view(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        // If T is () (i.e. if the function does not return anything) then `get_preimage` will constrain that the\n        // returns hash is empty as per the protocol rules.\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PrivateCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PrivateStaticCallInterface<M, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    /// Makes a read-only call to this private function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn view(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PrivateStaticCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PublicCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    /// Makes the call to this public function.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[external(\"public\")] function as `context`, through the\n    ///               #[external(\"public\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn call(self, context: &mut PublicContext) -> T {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        // If T is () (i.e. if the function does not return anything) then `as_array` will constrain that `returns` has\n        // a length of 0 (since that is ()'s deserialization length).\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Makes a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[external(\"public\")] function as `context`, through the\n    ///               #[external(\"public\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn view(self, context: &mut PublicContext) -> T {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        // If T is () (i.e. if the function does not return anything) then `as_array` will constrain that `returns` has\n        // a length of 0 (since that is ()'s deserialization length).\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Enqueues a call to this public function, to be executed later.\n    ///\n    /// Unlike private functions which execute immediately on the user's device,\n    /// public function calls are \"enqueued\" and executed some time later by a\n    /// block proposer.\n    ///\n    /// This means a public function cannot return any values back to a private\n    /// function, because by the time the public function is being executed,\n    /// the private function which called it has already completed execution.\n    /// (In fact, the private function has been executed and proven, along with\n    /// all other private function calls of the user's tx. A single proof of the\n    /// tx has been submitted to the Aztec network, and some time later a\n    /// proposer has picked the tx up from the mempool and begun executing all\n    /// of the enqueued public functions).\n    ///\n    /// # Privacy warning\n    /// Enqueueing a public function call is an inherently leaky action.\n    /// Many interesting applications will require some interaction with public\n    /// state, but smart contract developers should try to use public function\n    /// calls sparingly, and carefully.\n    /// _Internal_ public function calls are especially leaky, because they\n    /// completely leak which private contract made the call.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        self.enqueue_impl(context, false, false)\n    }\n\n    /// Enqueues a call to this public function, to be executed later.\n    ///\n    /// As per `enqueue`, but hides this calling contract's address from the\n    /// target public function.\n    /// This means the origin of the call (msg_sender) will not be publicly\n    /// visible to any blockchain observers, nor to the target public function.\n    /// When the target public function reads `context.msg_sender()` it will\n    /// receive an `Option<AztecAddress>::none`.\n    ///\n    /// NOTES:\n    /// - Not all public functions will accept a msg_sender of \"none\". Many\n    ///   public functions will require that msg_sender is \"some\" and will\n    ///   revert otherwise. Therefore, if using `enqueue_incognito`, you must\n    ///   understand whether the function you're calling will accept a\n    ///   msg_sender of \"none\".\n    ///   Lots of public bookkeeping patterns rely on knowing which address made\n    ///   the call, so as to ascribe state against the caller's address.\n    ///   (There are patterns whereby bookkeeping could instead be done in\n    ///   private-land).\n    /// - If you are enqueueing a call to an _internal_ public function (i.e.\n    ///   a public function that will only accept calls from other functions\n    ///   of its own contract), then by definition a call to it cannot possibly\n    ///   be \"incognito\": the msg_sender must be its own address, and indeed the\n    ///   called public function will assert this. Tl;dr this is not usable for\n    ///   enqueued internal public calls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    /// Advanced:\n    /// - The kernel circuits will permit _any_ private function to set the\n    ///   msg_sender field of any enqueued public function call to\n    ///   NULL_MSG_SENDER_CONTRACT_ADDRESS.\n    /// - When the called public function calls `PublicContext::msg_sender()`,\n    ///   aztec-nr will translate NULL_MSG_SENDER_CONTRACT_ADDRESS into\n    ///   `Option<AztecAddress>::none` for familiarity to devs.\n    ///\n    pub fn enqueue_incognito(self, context: &mut PrivateContext) {\n        self.enqueue_impl(context, false, true)\n    }\n\n    /// Enqueues a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        self.enqueue_impl(context, true, false)\n    }\n\n    /// Enqueues a read-only call to this public function.\n    ///\n    /// As per `enqueue_view`, but hides this calling contract's address from\n    /// the target public function.\n    ///\n    /// See `enqueue_incognito` for more details relating to hiding msg_sender.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn enqueue_view_incognito(self, context: &mut PrivateContext) {\n        self.enqueue_impl(context, true, true)\n    }\n\n    fn enqueue_impl(\n        self,\n        context: &mut PrivateContext,\n        is_static_call: bool,\n        hide_msg_sender: bool,\n    ) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            is_static_call,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a call to this public function, and designates it to be the\n    /// teardown function for this tx. Only one teardown function call can be\n    /// made by a tx.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase ensures the fee payer\n    /// has sufficient balance to pay the proposer their fees.\n    /// The teardown phase is primarily intended to: calculate exactly\n    /// how much the user owes, based on gas consumption, and refund the user\n    /// any change.\n    ///\n    /// Note: in some cases, the cost of refunding the user (i.e. DA costs of\n    /// tx side-effects) might exceed the refund amount. For app logic with\n    /// fairly stable and predictable gas consumption, a material refund amount\n    /// is unlikely. For app logic with unpredictable gas consumption, a\n    /// refund might be important to the user (e.g. if a hefty function reverts\n    /// very early). Wallet/FPC/Paymaster developers should be mindful of this.\n    ///\n    /// See `enqueue` for more information about enqueuing public function calls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        self.set_as_teardown_impl(context, false);\n    }\n\n    /// Enqueues a call to this public function, and designates it to be the teardown\n    /// function for this tx. Only one teardown function call can be made by a\n    /// tx.\n    ///\n    /// As per `set_as_teardown`, but hides this calling contract's address from\n    /// the target public function.\n    ///\n    /// See `enqueue_incognito` for more details relating to hiding msg_sender.\n    ///\n    pub fn set_as_teardown_incognito(self, context: &mut PrivateContext) {\n        self.set_as_teardown_impl(context, true);\n    }\n\n    fn set_as_teardown_impl(self, context: &mut PrivateContext, hide_msg_sender: bool) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PublicCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let M: u32, T> PublicStaticCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    /// Makes the read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[external(\"public\")] function as `context`, through the\n    ///               #[external(\"public\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn view(self, context: &mut PublicContext) -> T {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Enqueues a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n            false,\n        )\n    }\n\n    pub fn enqueue_view_incognito(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n            true,\n        )\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PublicStaticCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// UtilityCallInterface\n\npub struct UtilityCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n}\n\nimpl<let M: u32, T> CallInterface<M> for UtilityCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        false\n    }\n}\n\nimpl<let M: u32, T> UtilityCallInterface<M, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n\n    pub fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    pub fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    pub fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    pub fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n}\n"
    },
    "72": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        logs::notify_created_contract_class_log,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        block_header::BlockHeader,\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log_hash::LogHash,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::{PrivateLog, PrivateLogData},\n        public_call_request::PublicCallRequest,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, MAX_CONTRACT_CLASS_LOGS_PER_CALL,\n        MAX_ENQUEUED_CALLS_PER_CALL, MAX_INCLUDE_BY_TIMESTAMP_DURATION,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        NULL_MSG_SENDER_CONTRACT_ADDRESS, PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    hash::poseidon2_hash,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    side_effect::Counted,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::{ClaimedLengthArray, trimmed_array_length_hint},\n};\n\n/// # PrivateContext\n///\n/// The **main interface** between an #[external(\"private\")] function and the Aztec blockchain.\n///\n/// An instance of the PrivateContext is initialized automatically at the outset\n/// of every private function, within the #[external(\"private\")] macro, so you'll never\n/// need to consciously instantiate this yourself.\n///\n/// The instance is always named `context`, and it is always be available within\n/// the body of every #[external(\"private\")] function in your smart contract.\n///\n/// > For those used to \"vanilla\" Noir, it might be jarring to have access to\n/// > `context` without seeing a declaration `let context = PrivateContext::new(...)`\n/// > within the body of your function. This is just a consequence of using\n/// > macros to tidy-up verbose boilerplate. You can use `nargo expand` to\n/// > expand all macros, if you dare.\n///\n/// Typical usage for a smart contract developer will be to call getter\n/// methods of the PrivateContext.\n///\n/// _Pushing_ data and requests to the context is mostly handled within\n/// aztec-nr's own functions, so typically a smart contract developer won't\n/// need to call any setter methods directly.\n///\n/// > Advanced users might occasionally wish to push data to the context\n/// > directly for lower-level control. If you find yourself doing this, please\n/// > open an issue on GitHub to describe your use case: it might be that\n/// > new functionality should be added to aztec-nr.\n///\n/// ## Responsibilities\n/// - Exposes contextual data to a private function:\n///   - Data relating to how this private function was called.\n///     - msg_sender\n///     - this_address - (the contract address of the private function being\n///                      executed)\n///     - See `CallContext` for more data.\n///   - Data relating to the transaction in which this private function is\n///     being executed.\n///     - chain_id\n///     - version\n///     - gas_settings\n/// - Provides state access:\n///   - Access to the \"Anchor block\" header.\n///     Recall, a private function cannot read from the \"current\" block header,\n///     but must read from some historical block header, because as soon as\n///     private function execution begins (asynchronously, on a user's device),\n///     the public state of the chain (the \"current state\") will have progressed\n///     forward. We call this reference the \"Anchor block\".\n///     See `BlockHeader`.\n///   - Enables consumption of L1->L2 messages.\n/// - Enables calls to functions of other smart contracts:\n///   - Private function calls\n///   - Enqueueing of public function call requests\n///     (Since public functions are executed at a later time, by a block\n///     proposer, we say they are \"enqueued\").\n/// - Writes data to the blockchain:\n///   - New notes\n///   - New nullifiers\n///   - Private logs (for sending encrypted note contents or encrypted events)\n///   - New L2->L1 messages.\n/// - Provides args to the private function (handled by the #[external(\"private\")] macro).\n/// - Returns the return values of this private function (handled by the\n///   #[external(\"private\")] macro).\n/// - Makes Key Validation Requests.\n///   - Private functions are not allowed to see master secret keys, because we\n///     do not trust them. They are instead given \"app-siloed\" secret keys with\n///     a claim that they relate to a master public key. They can then request\n///     validation of this claim, by making a \"key validation request\" to the\n///     protocol's kernel circuits (which _are_ allowed to see certain master\n///     secret keys).\n///\n/// ## Advanced Responsibilities\n///\n/// - Ultimately, the PrivateContext is responsible for constructing the\n///   PrivateCircuitPublicInputs of the private function being executed.\n///   All private functions on Aztec must have public inputs which adhere\n///   to the rigid layout of the PrivateCircuitPublicInputs, in order to be\n///   compatible with the protocol's kernel circuits.\n///   A well-known misnomer:\n///   - \"public inputs\" contain both inputs and outputs of this function.\n///     - By \"outputs\" we mean a lot more side-effects than just the\n///       \"return values\" of the function.\n///   - Most of the so-called \"public inputs\" are kept _private_, and never leak\n///     to the outside world, because they are 'swallowed' by the protocol's\n///     kernel circuits before the tx is sent to the network. Only the\n///     following are exposed to the outside world:\n///     - New note_hashes\n///     - New nullifiers\n///     - New private logs\n///     - New L2->L1 messages\n///     - New enqueued public function call requests\n///     All the above-listed arrays of side-effects can be padded by the\n///     user's wallet (through instructions to the kernel circuits, via the\n///     PXE) to obscure their true lengths.\n///\n/// ## Syntax Justification\n///\n/// Both user-defined functions _and_ most functions in aztec-nr need access to\n/// the PrivateContext instance to read/write data. This is why you'll see the\n/// arguably-ugly pervasiveness of the \"context\" throughout your smart contract\n/// and the aztec-nr library.\n/// For example, `&mut context` is prevalent. In some languages, you can access\n/// and mutate a global variable (such as a PrivateContext instance) from a\n/// function without polluting the function's parameters. With Noir, a function\n/// must explicitly pass control of a mutable variable to another function, by\n/// reference. Since many functions in aztec-nr need to be able to push new data\n/// to the PrivateContext, they need to be handed a mutable reference _to_ the\n/// context as a parameter.\n/// For example, `Context` is prevalent as a generic parameter, to give better\n/// type safety at compile time. Many `aztec-nr` functions don't make sense if\n/// they're called in a particular runtime (private, public or utility), and so\n/// are intentionally only implemented over certain\n/// [Private|Public|Utility]Context structs. This gives smart contract\n/// developers a much faster feedback loop if they're making a mistake, as an\n/// error will be thrown by the LSP or when they compile their contract.\n///\n#[derive(Eq)]\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub include_by_timestamp: u64,\n\n    pub note_hash_read_requests: BoundedVec<Counted<Field>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<Counted<Field>, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<Counted<NoteHash>, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Counted<Nullifier>, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<Counted<L2ToL1Message>, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub anchor_block_header: BlockHeader,\n\n    pub private_logs: BoundedVec<Counted<PrivateLogData>, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<Counted<LogHash>, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        let max_allowed_include_by_timestamp = inputs.anchor_block_header.global_variables.timestamp\n            + MAX_INCLUDE_BY_TIMESTAMP_DURATION;\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            include_by_timestamp: max_allowed_include_by_timestamp,\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            anchor_block_header: inputs.anchor_block_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: Since Aztec doesn't have a concept of an EoA (\n    /// Externally-owned Account), the msg_sender is \"null\" for the first\n    /// function call of every transaction.\n    /// The first function call of a tx is likely to be a call to the user's\n    /// account contract, so this quirk will most often be handled by account\n    /// contract developers.\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called\n    ///   this function (be it an app contract or a user's account contract).\n    ///   Returns `Option<AztecAddress>::none` for the first function call of\n    ///   the tx. No other _private_ function calls in the tx will have a `none`\n    ///   msg_sender, but _public_ function calls might (see the PublicContext).\n    ///\n    pub fn msg_sender(self) -> Option<AztecAddress> {\n        let maybe_msg_sender = self.inputs.call_context.msg_sender;\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// \"Unsafe\" versus calling `context.msg_sender()`, because it doesn't\n    /// translate `NULL_MSG_SENDER_CONTRACT_ADDRESS` as\n    /// `Option<AztecAddress>::none`.\n    /// Used by some internal aztecnr functions.\n    pub fn msg_sender_unsafe(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    /// Returns the contract address of the current function being executed.\n    ///\n    /// This is equivalent to `address(this)` in Solidity (hence the name).\n    /// Use this to identify the current contract's address, commonly needed for\n    /// access control or when interacting with other contracts.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The contract address of the current function being\n    ///                    executed.\n    ///\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    /// Returns the chain ID of the current network.\n    ///\n    /// This is similar to `block.chainid` in Solidity. Returns the unique\n    /// identifier for the blockchain network this transaction is executing on.\n    ///\n    /// Helps prevent cross-chain replay attacks. Useful if implementing\n    /// multi-chain contract logic.\n    ///\n    /// # Returns\n    /// * `Field` - The chain ID as a field element\n    ///\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    /// Returns the Aztec protocol version that this transaction is executing\n    /// under. Different versions may have different rules, opcodes, or\n    /// cryptographic primitives.\n    ///\n    /// This is similar to how Ethereum has different EVM versions.\n    ///\n    /// Useful for forward/backward compatibility checks\n    ///\n    /// Not to be confused with contract versions; this is the protocol version.\n    ///\n    /// # Returns\n    /// * `Field` - The protocol version as a field element\n    ///\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    /// Returns the gas settings for the current transaction.\n    ///\n    /// This provides information about gas limits and pricing for the\n    /// transaction, similar to `tx.gasprice` and gas limits in Ethereum.\n    /// However, Aztec has a more sophisticated gas model with separate\n    /// accounting for L2 computation and data availability (DA) costs.\n    ///\n    /// # Returns\n    /// * `GasSettings` - Struct containing gas limits and fee information\n    ///\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    /// Returns the function selector of the currently executing function.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to access this.\n    ///\n    /// This is similar to `msg.sig` in Solidity, which returns the first 4\n    /// bytes of the function signature. In Aztec, the selector uniquely\n    /// identifies which function within the contract is being called.\n    ///\n    /// # Returns\n    /// * `FunctionSelector` - The 4-byte function identifier\n    ///\n    /// # Advanced\n    /// Only #[external(\"private\")] functions have a function selector as a protocol-\n    /// enshrined concept. The function selectors of private functions are\n    /// baked into the preimage of the contract address, and are used by the\n    /// protocol's kernel circuits to identify each private function and ensure\n    /// the correct one is being executed.\n    ///\n    /// Used internally for function dispatch and call verification.\n    ///\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    ///\n    /// Very low-level function: You shouldn't need to call this. The #[external(\"private\")]\n    /// macro calls this, and it makes the arguments neatly available to the\n    /// body of your private function.\n    ///\n    /// # Returns\n    /// * `Field` - Hash of the function arguments\n    ///\n    /// # Advanced\n    /// * Arguments are hashed to reduce proof size and verification time\n    /// * Enables efficient argument passing in recursive function calls\n    /// * The hash can be used to retrieve the original arguments from the PXE.\n    ///\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    /// Pushes a new note_hash to the Aztec blockchain's global Note Hash Tree\n    /// (a state tree).\n    ///\n    /// A note_hash is a commitment to a piece of private state.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new note hashes.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The new note_hash.\n    ///\n    /// # Advanced\n    /// From here, the protocol's kernel circuits will take over and insert the\n    /// note_hash into the protocol's \"note hash tree\" (in the Base Rollup\n    /// circuit).\n    /// Before insertion, the protocol will:\n    /// - \"Silo\" the `note_hash` with the contract address of this function,\n    ///   to yield a `siloed_note_hash`. This prevents state collisions\n    ///   between different smart contracts.\n    /// - Ensure uniqueness of the `siloed_note_hash`, to prevent Faerie-Gold\n    ///   attacks, by hashing the `siloed_note_hash` with a unique value, to\n    ///   yield a `unique_siloed_note_hash` (see the protocol spec for more).\n    ///\n    /// In addition to calling this function, aztec-nr provides the contents\n    /// of the newly-created note to the PXE, via the `notify_created_note`\n    /// oracle.\n    ///\n    /// > Advanced users might occasionally wish to push data to the context\n    /// > directly for lower-level control. If you find yourself doing this,\n    /// > please open an issue on GitHub to describe your use case: it might be\n    /// > that new functionality should be added to aztec-nr.\n    ///\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(Counted::new(note_hash, self.next_counter()));\n    }\n\n    /// Pushes a new nullifier to the Aztec blockchain's global Nullifier Tree\n    /// (a state tree).\n    ///\n    /// See also: `push_nullifier_for_note_hash`.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifiers.\n    ///\n    /// A nullifier can only be emitted once. Duplicate nullifier insertions are\n    /// rejected by the protocol.\n    ///\n    /// Generally, a nullifier is emitted to prevent an action from happening\n    /// more than once, in such a way that the action cannot be linked (by an\n    /// observer of the blockchain) to any earlier transactions.\n    ///\n    /// I.e. a nullifier is a random-looking, but deterministic record of a\n    /// private, one-time action, which does not leak what action has been\n    /// taken, and which preserves the property of \"tx unlinkability\".\n    ///\n    /// Usually, a nullifier will be emitted to \"spend\" a note (a piece of\n    /// private state), without revealing which specific note is being spent.\n    ///\n    /// (Important: in such cases, use the below `push_nullifier_for_note_hash`).\n    ///\n    /// Sometimes, a nullifier might be emitted completely unrelated to any\n    /// notes. Examples include initialization of a new contract; initialization\n    /// of a PrivateMutable, or signalling in Semaphore-like applications.\n    /// This `push_nullifier` function serves such use cases.\n    ///\n    /// # Arguments\n    /// * `nullifier`\n    ///\n    /// # Advanced\n    /// From here, the protocol's kernel circuits will take over and insert the\n    /// nullifier into the protocol's \"nullifier tree\" (in the Base Rollup\n    /// circuit).\n    /// Before insertion, the protocol will:\n    /// - \"Silo\" the `nullifier` with the contract address of this function,\n    ///   to yield a `siloed_nullifier`. This prevents state collisions\n    ///   between different smart contracts.\n    /// - Ensure the `siloed_nullifier` is unique (the nullifier tree is an\n    ///   indexed merkle tree which supports efficient non-membership proofs).\n    ///\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: 0 }.count(self.next_counter()));\n    }\n\n    /// Pushes a nullifier that corresponds to a specific note hash.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifiers.\n    ///\n    /// This is a specialized version of `push_nullifier` that links a nullifier\n    /// to the specific note hash it's nullifying. This is the most common\n    /// usage pattern for nullifiers.\n    /// See `push_nullifier` for more explanation on nullifiers.\n    ///\n    /// # Arguments\n    /// * `nullifier`\n    /// * `nullified_note_hash` - The note hash of the note being nullified\n    ///\n    /// # Advanced\n    /// Important: usage of this function doesn't mean that the world will _see_\n    /// that this nullifier relates to the given nullified_note_hash (as that\n    /// would violate \"tx unlinkability\"); it simply informs the user's PXE\n    /// about the relationship (via `notify_nullified_note`). The PXE can then\n    /// use this information to feed hints to the kernel circuits for\n    /// \"squashing\" purposes: If a note is nullified during the same tx which\n    /// created it, we can \"squash\" (delete) the note and nullifier (and any\n    /// private logs associated with the note), to save on data emission costs.\n    ///\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash }.count(\n            nullifier_counter,\n        ));\n    }\n\n    /// Returns the anchor block header - the historical block header that this\n    /// private function is reading from.\n    ///\n    /// A private function CANNOT read from the \"current\" block header,\n    /// but must read from some older block header, because as soon as\n    /// private function execution begins (asynchronously, on a user's device),\n    /// the public state of the chain (the \"current state\") will have progressed\n    /// forward.\n    ///\n    /// # Returns\n    /// * `BlockHeader` - The anchor block header.\n    ///\n    /// # Advanced\n    /// * All private functions of a tx read from the same anchor block header.\n    /// * The protocol asserts that the `include_by_timestamp` of every tx\n    ///   is at most 24 hours beyond the timestamp of the tx's chosen anchor\n    ///   block header. This enables the network's nodes to safely prune old txs\n    ///   from the mempool. Therefore, the chosen block header _must_ be one\n    ///   from within the last 24 hours.\n    ///\n    pub fn get_anchor_block_header(self) -> BlockHeader {\n        self.anchor_block_header\n    }\n\n    /// Returns the header of any historical block at or before the anchor\n    /// block.\n    ///\n    /// This enables private contracts to access information from even older\n    /// blocks than the anchor block header.\n    ///\n    /// Useful for time-based contract logic that needs to compare against\n    /// multiple historical points.\n    ///\n    /// # Arguments\n    /// * `block_number` - The block number to retrieve (must be <= anchor\n    ///                    block number)\n    ///\n    /// # Returns\n    /// * `BlockHeader` - The header of the requested historical block\n    ///\n    /// # Advanced\n    /// This function uses an oracle to fetch block header data from the user's\n    /// PXE. Depending on how much blockchain data the user's PXE has been set\n    /// up to store, this might require a query from the PXE to another Aztec\n    /// node to get the data.\n    /// > This is generally true of all oracle getters (see `../oracle`).\n    ///\n    /// Each block header gets hashed and stored as a leaf in the protocol's\n    /// Archive Tree. In fact, the i-th block header gets stored at the i-th\n    /// leaf index of the Archive Tree. Behind the scenes, this\n    /// `get_block_header_at` function will add Archive Tree merkle-membership\n    /// constraints (~3k) to your smart contract function's circuit, to prove\n    /// existence of the block header in the Archive Tree.\n    ///\n    /// Note: we don't do any caching, so avoid making duplicate calls for the\n    /// same block header, because each call will add duplicate constraints.\n    ///\n    /// Calling this function is more expensive (constraint-wise) than getting\n    /// the anchor block header (via `get_block_header`). This is because the\n    /// anchor block's merkle membership proof is handled by Aztec's protocol\n    /// circuits, and is only performed once for the entire tx because all\n    /// private functions of a tx share a common anchor block header. Therefore,\n    /// the cost (constraint-wise) of calling `get_block_header` is effectively\n    /// free.\n    ///\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    /// Sets the hash of the return values for this private function.\n    ///\n    /// Very low-level function: this is called by the #[external(\"private\")] macro.\n    ///\n    /// # Arguments\n    /// * `serialized_return_values` - The serialized return values as a field array\n    ///\n    pub fn set_return_hash<let N: u32>(&mut self, serialized_return_values: [Field; N]) {\n        let return_hash = hash_args_array(serialized_return_values);\n        self.return_hash = return_hash;\n        execution_cache::store(serialized_return_values, return_hash);\n    }\n\n    /// Builds the PrivateCircuitPublicInputs for this private function, to\n    /// ensure compatibility with the protocol's kernel circuits.\n    ///\n    /// Very low-level function: This function is automatically called by the\n    /// #[external(\"private\")] macro.\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            include_by_timestamp: self.include_by_timestamp,\n            note_hash_read_requests: ClaimedLengthArray::from_bounded_vec(\n                self.note_hash_read_requests,\n            ),\n            nullifier_read_requests: ClaimedLengthArray::from_bounded_vec(\n                self.nullifier_read_requests,\n            ),\n            key_validation_requests_and_generators: ClaimedLengthArray::from_bounded_vec(\n                self.key_validation_requests_and_generators,\n            ),\n            note_hashes: ClaimedLengthArray::from_bounded_vec(self.note_hashes),\n            nullifiers: ClaimedLengthArray::from_bounded_vec(self.nullifiers),\n            private_call_requests: ClaimedLengthArray::from_bounded_vec(self.private_call_requests),\n            public_call_requests: ClaimedLengthArray::from_bounded_vec(self.public_call_requests),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: ClaimedLengthArray::from_bounded_vec(self.l2_to_l1_msgs),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: ClaimedLengthArray::from_bounded_vec(self.private_logs),\n            contract_class_logs_hashes: ClaimedLengthArray::from_bounded_vec(\n                self.contract_class_logs_hashes,\n            ),\n            anchor_block_header: self.anchor_block_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    /// Designates this contract as the fee payer for the transaction.\n    ///\n    /// Unlike Ethereum, where the transaction sender always pays fees, Aztec\n    /// allows any contract to voluntarily pay transaction fees. This enables\n    /// patterns like sponsored transactions or fee abstraction where users\n    /// don't need to hold fee-juice themselves. (Fee juice is a fee-paying\n    /// asset for Aztec).\n    ///\n    /// Only one contract per transaction can declare itself as the fee payer,\n    /// and it must have sufficient fee-juice balance (>= the gas limits\n    /// specified in the TxContext) by the time we reach the public setup phase\n    /// of the tx.\n    ///\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    /// Declares the end of the \"setup phase\" of this tx.\n    ///\n    /// Only one function per tx can declare the end of the setup phase.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase enables such a payment to\n    /// be made, because the setup phase _cannot revert_: a reverting function\n    /// within the setup phase would result in an invalid block which cannot\n    /// be proven. Any side-effects generated during that phase are guaranteed\n    /// to be inserted into Aztec's state trees (except for squashed notes &\n    /// nullifiers, of course).\n    ///\n    /// Even though the end of the setup phase is declared within a private\n    /// function, you might have noticed that _public_ functions can also\n    /// execute within the setup phase. This is because any public function\n    /// calls which were enqueued _within the setup phase_ by a private\n    /// function are considered part of the setup phase.\n    ///\n    /// # Advanced\n    /// * Sets the minimum revertible side effect counter of this tx to be the\n    /// PrivateContext's _current_ side effect counter.\n    ///\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    /// Sets a deadline (an \"include-by timestamp\") for when this transaction\n    /// must be included in a block.\n    ///\n    /// Other functions in this tx might call this setter with differing\n    /// values for the include-by timestamp. To ensure that all functions'\n    /// deadlines are met, the _minimum_ of all these include-by timestamps will\n    /// be exposed when this tx is submitted to the network.\n    ///\n    /// If the transaction is not included in a block by its include-by\n    /// timestamp, it becomes invalid and it will never be included.\n    ///\n    /// This expiry timestamp is publicly visible. See the \"Advanced\" section\n    /// for privacy concerns.\n    ///\n    /// # Arguments\n    /// * `include_by_timestamp` - Unix timestamp (seconds) deadline for inclusion.\n    ///                            The include-by timestamp of this tx will be\n    ///                            _at most_ the timestamp specified.\n    ///\n    /// # Advanced\n    /// * If multiple functions set differing `include_by_timestamp`s, the\n    ///   kernel circuits will set it to be the _minimum_ of the two. This\n    ///   ensures the tx expiry requirements of all functions in the tx are met.\n    /// * Rollup circuits will reject expired txs.\n    /// * The protocol enforces that all transactions must be included within\n    ///   24 hours of their chosen anchor block's timestamp, to enable safe\n    ///   mempool pruning.\n    /// * The DelayedPublicMutable design makes heavy use of this functionality,\n    ///   to enable private functions to read public state.\n    /// * A sophisticated Wallet should cleverly set an include-by timestamp\n    ///   to improve the privacy of the user and the network as a whole.\n    ///   For example, if a contract interaction sets include-by to some\n    ///   publicly-known value (e.g. the time when a contract upgrades), then\n    ///   the wallet might wish to set an even lower one to avoid revealing that\n    ///   this tx is interacting with said contract.\n    ///   Ideally, all wallets should standardise on an approach in order to\n    ///   provide users with a large anonymity set -- although the exact apprach\n    ///   will need to be discussed. Wallets that deviate from a standard might\n    ///   accidentally reveal which wallet each transaction originates from.\n    ///\n    // docs:start:include-by-timestamp\n    pub fn set_include_by_timestamp(&mut self, include_by_timestamp: u64) {\n        // docs:end:include-by-timestamp\n        self.include_by_timestamp = std::cmp::min(self.include_by_timestamp, include_by_timestamp);\n    }\n\n    /// Makes a request to the protocol's kernel circuit to ensure a note_hash\n    /// actually exists.\n    ///\n    /// \"Read requests\" are used to prove that a note hash exists without\n    /// revealing which specific note was read.\n    ///\n    /// This can be used to prove existence of both settled notes (created in\n    /// prior transactions) and transient notes (created in the current\n    /// transaction).\n    /// If you need to prove existence of a settled note _at a specific block\n    /// number_, use `note_inclusion::prove_note_inclusion`.\n    ///\n    /// Low-level function. Ordinarily, smart contract developers will not need\n    /// to call this directly. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new note_hash read\n    /// requests.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The note hash to read and verify\n    ///\n    /// # Advanced\n    /// In \"traditional\" circuits for non-Aztec privacy applications, the merkle\n    /// membership proofs to check existence of a note are performed _within_\n    /// the application circuit.\n    ///\n    /// All Aztec private functions have access to the following constraint\n    /// optimisation:\n    /// In cases where the note being read was created earlier in the same tx,\n    /// the note wouldn't yet exist in the Note Hash Tree, so a hard-coded\n    /// merkle membership check which then gets ignored would be a waste of\n    /// constraints.\n    /// Instead, we can send read requests for all notes to the protocol's\n    /// kernel circuits, where we can conditionally assess which notes actually\n    /// need merkle membership proofs, and select an appropriately-sized\n    /// kernel circuit.\n    ///\n    /// For \"settled notes\" (which already existed in the Note Hash Tree of the\n    /// anchor block (i.e. before the tx began)), the kernel does a merkle\n    /// membership check.\n    ///\n    /// For \"pending notes\" (which were created earlier in _this_ tx), the\n    /// kernel will check that the note existed _before_ this read request was\n    /// made, by checking the side-effect counters of the note_hash and this\n    /// read request.\n    ///\n    /// This approach improves latency between writes and reads:\n    /// a function can read a note which was created earlier in the tx (rather\n    /// than performing the read in a later tx, after waiting for the earlier tx\n    /// to be included, to ensure the note is included in the tree).\n    ///\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = Counted::new(note_hash, self.next_counter());\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    /// Requests to read a specific nullifier from the nullifier tree.\n    ///\n    /// Nullifier read requests are used to prove that a nullifier exists without\n    /// revealing which specific nullifier preimage was read.\n    ///\n    /// This can be used to prove existence of both settled nullifiers (created in\n    /// prior transactions) and transient nullifiers (created in the current\n    /// transaction).\n    /// If you need to prove existence of a settled nullifier _at a specific block\n    /// number_, use `nullifier_inclusion::prove_nullifier_inclusion`.\n    ///\n    /// Low-level function. Ordinarily, smart contract developers will not need\n    /// to call this directly. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifier read\n    /// requests.\n    ///\n    /// # Arguments\n    /// * `nullifier` - The nullifier to read and verify\n    ///\n    /// # Advanced\n    /// This approach improves latency between writes and reads:\n    /// a function can read a nullifier which was created earlier in the tx\n    /// (rather than performing the read in a later tx, after waiting for the\n    /// earlier tx to be included, to ensure the note is included in the tree).\n    ///\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = Counted::new(nullifier, self.next_counter());\n        self.nullifier_read_requests.push(request);\n    }\n\n    /// Requests the app-siloed nullifier secret key (nsk_app) for the given\n    /// (hashed) master nullifier public key (npk_m), from the user's PXE.\n    ///\n    /// Advanced function: Only needed if you're designing your own notes and/or\n    /// nullifiers.\n    ///\n    /// Contracts are not allowed to compute nullifiers for other contracts, as\n    /// that would let them read parts of their private state. Because of this,\n    /// a contract is only given an \"app-siloed secret key\", which is\n    /// constructed by hashing the user's master nullifier secret key with the\n    /// contract's address.\n    /// However, because contracts cannot be trusted with a user's master\n    /// nullifier secret key (because we don't know which contracts are honest\n    /// or malicious), the PXE refuses to provide any master secret keys to\n    /// any app smart contract function. This means app functions are unable to\n    /// prove that the derivation of an app-siloed nullifier secret key has been\n    /// computed correctly. Instead, an app function can request to the kernel\n    /// (via `request_nsk_app`) that it validates the siloed derivation, since\n    /// the kernel has been vetted to not leak any master secret keys.\n    ///\n    /// A common nullification scheme is to inject a nullifier secret key into\n    /// the preimage of a nullifier, to make the nullifier deterministic but\n    /// random-looking. This function enables that flow.\n    ///\n    /// # Arguments\n    /// * `npk_m_hash` - A hash of the master nullifier public key of the user\n    ///                  whose PXE is executing this function.\n    ///\n    /// # Returns\n    /// * The app-siloed nullifier secret key that corresponds to the given\n    ///   `npk_m_hash`.\n    ///\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    /// Requests the app-siloed nullifier secret key (nsk_app) for the given\n    /// (hashed) master nullifier public key (npk_m), from the user's PXE.\n    ///\n    /// See `request_nsk_app` and `request_sk_app` for more info.\n    ///\n    /// The intention of the \"outgoing\" keypair is to provide a second secret\n    /// key for all of a user's outgoing activity (i.e. for notes that a user\n    /// creates, as opposed to notes that a user receives from others). The\n    /// separation of incoming and outgoing data was a distinction made by\n    /// zcash, with the intention of enabling a user to optionally share with a\n    /// 3rd party a controlled view of only incoming or outgoing notes.\n    /// Similar functionality of sharing select data can be achieved with\n    /// offchain zero-knowledge proofs. It is up to an app developer whether\n    /// they choose to make use of a user's outgoing keypair within their\n    /// application logic, or instead simply use the same keypair (the address\n    /// keypair (which is effectively the same as the \"incooming\" keypair)) for\n    /// all incoming & outgoing messages to a user.\n    ///\n    /// Currently, all of the exposed encryption functions in aztec-nr ignore\n    /// the outgoing viewing keys, and instead encrypt all note logs and event\n    /// logs to a user's address public key.\n    ///\n    /// # Arguments\n    /// * `ovpk_m_hash` - Hash of the outgoing viewing public key master\n    ///\n    /// # Returns\n    /// * The application-specific outgoing viewing secret key\n    ///\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    /// Pushes a Key Validation Request to the kernel.\n    ///\n    /// Private functions are not allowed to see a user's master secret keys,\n    /// because we do not trust them. They are instead given \"app-siloed\" secret\n    /// keys with a claim that they relate to a master public key.\n    /// They can then request validation of this claim, by making a \"key\n    /// validation request\" to the protocol's kernel circuits (which _are_\n    /// allowed to see certain master secret keys).\n    ///\n    /// When a Key Validation Request tuple of (sk_app, Pk_m, app_address) is\n    /// submitted to the kernel, it will perform the following derivations\n    /// to validate the relationship between the claimed sk_app and the user's\n    /// Pk_m:\n    ///\n    ///       (sk_m) ----> * G ----> Pk_m\n    ///         |                     |\n    ///         v                       We use the kernel to prove this\n    ///  h(sk_m, app_address)         | sk_app-Pk_m relationship, because app\n    ///         |                       circuits must not be trusted to see sk_m.\n    ///         v                     |\n    ///      sk_app - -  - - - - - - -\n    ///\n    /// The function is named \"request_\" instead of \"get_\" to remind the user\n    /// that a Key Validation Request will be emitted to the kernel.\n    ///\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    /// Sends an \"L2 -> L1 message\" from this function (Aztec, L2) to a smart\n    /// contract on Ethereum (L1). L1 contracts which are designed to\n    /// send/receive messages to/from Aztec are called \"Portal Contracts\".\n    ///\n    /// Common use cases include withdrawals, cross-chain asset transfers, and\n    /// triggering L1 actions based on L2 state changes.\n    ///\n    /// The message will be inserted into an Aztec \"Outbox\" contract on L1,\n    /// when this transaction's block is proposed to L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target portal contract. The message will need to be manually\n    /// consumed from the Outbox through a separate Ethereum transaction: a user\n    /// will need to call a function of the portal contract -- a function\n    /// specifically designed to make a call to the Outbox to consume the\n    /// message.\n    /// The message will only be available for consumption once the _epoch_\n    /// proof has been submitted. Given that there are multiple Aztec blocks\n    /// within an epoch, it might take some time for this epoch proof to be\n    /// submitted -- especially if the block was near the start of an epoch.\n    ///\n    /// # Arguments\n    /// * `recipient` - Ethereum address that will receive the message\n    /// * `content` - Message content (32 bytes as a Field element).\n    ///               This content has a very specific layout.\n    /// docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        let message = L2ToL1Message { recipient, content };\n        self.l2_to_l1_msgs.push(message.count(self.next_counter()));\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2).\n    ///\n    /// Common use cases include token bridging, cross-chain governance, and\n    /// triggering L2 actions based on L1 events.\n    ///\n    /// Use this function if you only want the message to ever be \"referred to\"\n    /// once. Once consumed using this method, the message cannot be consumed\n    /// again, because a nullifier is emitted.\n    /// If your use case wants for the message to be read unlimited times, then\n    /// you can always read any historic message from the L1-to-L2 messages tree;\n    /// messages never technically get deleted from that tree.\n    ///\n    /// The message will first be inserted into an Aztec \"Inbox\" smart contract\n    /// on L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target L2 contract. The message will need to be manually\n    /// consumed by the target contract through a separate Aztec transaction.\n    /// The message will not be available for consumption immediately. Messages\n    /// get copied over from the L1 Inbox to L2 by the next Proposer in batches.\n    /// So you will need to wait until the messages are copied before you can\n    /// consume them.\n    ///\n    /// # Arguments\n    /// * `content` - The message content that was sent from L1\n    /// * `secret` - Secret value used for message privacy (if needed)\n    /// * `sender` - Ethereum address that sent the message\n    /// * `leaf_index` - Index of the message in the L1-to-L2 message tree\n    ///\n    /// # Advanced\n    /// Validates message existence in the L1-to-L2 message tree and nullifies\n    /// the message to prevent double-consumption.\n    ///\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let nullifier = process_l1_to_l2_message(\n            self.anchor_block_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n\n    /// Emits a private log (an array of Fields) that will be published to an\n    /// Ethereum blob.\n    ///\n    /// Private logs are intended for the broadcasting of ciphertexts: that is,\n    /// encrypted events or encrypted note contents.\n    /// Since the data in the logs is meant to be _encrypted_, private_logs are\n    /// broadcast to publicly-visible Ethereum blobs.\n    /// The intended recipients of such encrypted messages can then discover and\n    /// decrypt these encrypted logs using their viewing secret key.\n    /// (See `../messages/discovery` for more details).\n    ///\n    /// Important note: This function DOES NOT _do_ any encryption of the input\n    /// `log` fields. This function blindly publishes whatever input `log` data\n    /// is fed into it, so the caller of this function should have already\n    /// performed the encryption, and the `log` should be the result of that\n    /// encryption.\n    ///\n    /// The protocol does not dictate what encryption scheme should be used:\n    /// a smart contract developer can choose whatever encryption scheme they\n    /// like.\n    /// Aztec-nr includes some off-the-shelf encryption libraries that\n    /// developers might wish to use, for convenience. These libraries not only\n    /// encrypt a plaintext (to produce a ciphertext); they also prepend the\n    /// ciphertext with a `tag` and `ephemeral public key` for easier message\n    /// discovery. This is a very dense topic, and we will be writing more\n    /// libraries and docs soon.\n    ///\n    /// > Currently, AES128 CBC encryption is the main scheme included in\n    /// > aztec.nr.\n    /// > We are currently making significant changes to the interfaces of the\n    /// > encryption library.\n    ///\n    /// In some niche use cases, an app might be tempted to publish\n    /// _un-encrypted_ data via a private log, because _public logs_ are not\n    /// available to private functions. Be warned that emitting public data via\n    /// private logs is strongly discouraged, and is considered a \"privacy\n    /// anti-pattern\", because it reveals identifiable information about _which_\n    /// function has been executed. A tx which leaks such information does not\n    /// contribute to the privacy set of the network.\n    ///\n    /// * Unlike `emit_raw_note_log`, this log is not tied to any specific note\n    ///\n    /// # Arguments\n    /// * `log` - The log data that will be publicly broadcast (so make sure\n    ///           it's already been encrypted before you call this function).\n    ///   Private logs are bounded in size (PRIVATE_LOG_SIZE_IN_FIELDS), to\n    ///   encourage all logs from all smart contracts look identical.\n    /// * `length` - The actual length of the `log` (measured in number of\n    ///              Fields). Although the input log has a max size of\n    ///   PRIVATE_LOG_SIZE_IN_FIELDS, the latter values of the array might all\n    ///   be 0's for small logs. This `length` should reflect the trimmed length\n    ///   of the array. The protocol's kernel circuits can then append random\n    ///   fields as \"padding\" after the `length`, so that the logs of this\n    ///   smart contract look indistinguishable from (the same length as) the\n    ///   logs of all other applications. It's up to wallets how much padding\n    ///   to apply, so ideally all wallets should agree on standards for this.\n    ///\n    /// # Advanced\n    ///\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS], length: u32) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter: 0 }\n            .count(counter);\n        self.private_logs.push(private_log);\n    }\n\n    // TODO: rename.\n    /// Emits a private log that is explicitly tied to a newly-emitted note_hash,\n    /// to convey to the kernel: \"this log relates to this note\".\n    ///\n    /// This linkage is important in case the note gets squashed (due to being\n    /// read later in this same tx), since we can then squash the log as well.\n    ///\n    /// See `emit_private_log` for more info about private log emission.\n    ///\n    /// # Arguments\n    /// * `log` - The log data as an array of Field elements\n    /// * `length` - The actual length of the `log` (measured in number of\n    ///              Fields).\n    /// * `note_hash_counter` - The side-effect counter that was assigned to the\n    ///                         new note_hash when it was pushed to this\n    //                          `PrivateContext`.\n    ///\n    /// Important: If your application logic requires the log to always be\n    /// emitted regardless of note squashing, consider using `emit_private_log`\n    /// instead, or emitting additional events.\n    ///\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        length: u32,\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter };\n        self.private_logs.push(private_log.count(counter));\n    }\n\n    pub fn emit_contract_class_log<let N: u32>(&mut self, log: [Field; N]) {\n        let contract_address = self.this_address();\n        let counter = self.next_counter();\n\n        let log_to_emit: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS] =\n            log.concat([0; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS - N]);\n        // Note: the length is not always N, it is the number of fields we want to broadcast, omitting trailing zeros to save blob space.\n        // Safety: The below length is constrained in the base rollup, which will make sure that all the fields beyond length are zero.\n        // However, it won't be able to check that we didn't add extra padding (trailing zeroes)\n        let length = unsafe { trimmed_array_length_hint(log_to_emit) };\n        // We hash the entire padded log to ensure a user cannot pass a shorter length and so emit incorrect shorter bytecode.\n        let log_hash = poseidon2_hash(log_to_emit);\n        // Safety: the below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\n        unsafe {\n            notify_created_contract_class_log(contract_address, log_to_emit, length, counter);\n        }\n\n        self.contract_class_logs_hashes.push(LogHash { value: log_hash, length: length }.count(\n            counter,\n        ));\n    }\n\n    /// Calls a private function on another contract (or the same contract).\n    ///\n    /// Very low-level function.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the called function\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    /// This enables contracts to interact with each other while maintaining\n    /// privacy. This \"composability\" of private contract functions is a key\n    /// feature of the Aztec network.\n    ///\n    /// If a user's transaction includes multiple private function calls, then\n    /// by the design of Aztec, the following information will remain private[1]:\n    /// - The function selectors and contract addresses of all private function\n    ///   calls will remain private, so an observer of the public mempool will\n    ///   not be able to look at a tx and deduce which private functions have\n    ///   been executed.\n    /// - The arguments and return values of all private function calls will\n    ///   remain private.\n    /// - The person who initiated the tx will remain private.\n    /// - The notes and nullifiers and private logs that are emitted by all\n    ///   private function calls will (if designed well) not leak any user\n    ///   secrets, nor leak which functions have been executed.\n    ///\n    /// [1] Caveats: Some of these privacy guarantees depend on how app\n    /// developers design their smart contracts. Some actions _can_ leak\n    /// information, such as:\n    /// - Calling an internal public function.\n    /// - Calling a public function and not setting msg_sender to Option::none\n    ///   (feature not built yet - see github).\n    /// - Calling any public function will always leak details about the nature\n    ///   of the transaction, so devs should be careful in their contract\n    ///   designs. If it can be done in a private function, then that will give\n    ///   the best privacy.\n    /// - Not padding the side-effects of a tx to some standardised, uniform\n    ///   size. The kernel circuits can take hints to pad side-effects, so a\n    ///   wallet should be able to request for a particular amount of padding.\n    ///   Wallets should ideally agree on some standard.\n    ///   - Padding should include:\n    ///     - Padding the lengths of note & nullifier arrays\n    ///     - Padding private logs with random fields, up to some standardised\n    ///       size.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Advanced\n    /// * The call is added to the private call stack and executed by kernel\n    ///   circuits after this function completes\n    /// * The called function can modify its own contract's private state\n    /// * Side effects from the called function are included in this transaction\n    /// * The call inherits the current transaction's context and gas limits\n    ///\n    pub fn call_private_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    /// Makes a read-only call to a private function on another contract.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L2 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// See `call_private_function` for more general info on private function\n    /// calls.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the called function\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn static_call_private_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    /// Calls a private function that takes no arguments.\n    ///\n    /// This is a convenience function for calling private functions that don't\n    /// require any input parameters. It's equivalent to `call_private_function`\n    /// but slightly more efficient to use when no arguments are needed.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    /// Makes a read-only call to a private function which takes no arguments.\n    ///\n    /// This combines the optimisation of `call_private_function_no_args` with\n    /// the safety of `static_call_private_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    /// Low-level private function call.\n    ///\n    /// This is the underlying implementation used by all other private function\n    /// call methods. Instead of taking raw arguments, it accepts a\n    /// hash of the arguments.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args_hash` - Pre-computed hash of the function arguments\n    /// * `is_static_call` - Whether this should be a read-only call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values\n    ///\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1; // TODO: call `next_counter` instead, for consistency\n        ReturnsHash::new(returns_hash)\n    }\n\n    /// Enqueues a call to a public function to be executed later.\n    ///\n    /// Unlike private functions which execute immediately on the user's device,\n    /// public function calls are \"enqueued\" and executed some time later by a\n    /// block proposer.\n    ///\n    /// This means a public function cannot return any values back to a private\n    /// function, because by the time the public function is being executed,\n    /// the private function which called it has already completed execution.\n    /// (In fact, the private function has been executed and proven, along with\n    /// all other private function calls of the user's tx. A single proof of the\n    /// tx has been submitted to the Aztec network, and some time later a\n    /// proposer has picked the tx up from the mempool and begun executing all\n    /// of the enqueued public functions).\n    ///\n    /// # Privacy warning\n    /// Enqueueing a public function call is an inherently leaky action.\n    /// Many interesting applications will require some interaction with public\n    /// state, but smart contract developers should try to use public function\n    /// calls sparingly, and carefully.\n    /// _Internal_ public function calls are especially leaky, because they\n    /// completely leak which private contract made the call.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the public function\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn call_public_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n        hide_msg_sender: bool,\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a read-only call to a public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// See also `call_public_function` for more important information about\n    /// making private -> public function calls.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the public function\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn static_call_public_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n        hide_msg_sender: bool,\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            true,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a call to a public function that takes no arguments.\n    ///\n    /// This is an optimisation for calling public functions that don't\n    /// take any input parameters. It's otherwise equivalent to\n    /// `call_public_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        hide_msg_sender: bool,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a read-only call to a public function with no arguments.\n    ///\n    /// This combines the optimisation of `call_public_function_no_args` with\n    /// the safety of `static_call_public_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        hide_msg_sender: bool,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            true,\n            hide_msg_sender,\n        )\n    }\n\n    /// Low-level public function call.\n    ///\n    /// This is the underlying implementation used by all other public function\n    /// call methods. Instead of taking raw arguments, it accepts a\n    /// hash of the arguments.\n    ///\n    /// Advanced function: Most developers should use `call_public_function`\n    /// or `static_call_public_function` instead. This function is exposed for\n    /// performance optimization and advanced use cases.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `calldata_hash` - Hash of the function calldata\n    /// * `is_static_call` - Whether this should be a read-only call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n        hide_msg_sender: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let msg_sender = if hide_msg_sender {\n            NULL_MSG_SENDER_CONTRACT_ADDRESS\n        } else {\n            self.this_address()\n        };\n\n        let call_request =\n            PublicCallRequest { msg_sender, contract_address, is_static_call, calldata_hash };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    /// Enqueues a public function call, and designates it to be the teardown\n    /// function for this tx. Only one teardown function call can be made by a\n    /// tx.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase ensures the fee payer\n    /// has sufficient balance to pay the proposer their fees.\n    /// The teardown phase is primarily intended to: calculate exactly\n    /// how much the user owes, based on gas consumption, and refund the user\n    /// any change.\n    ///\n    /// Note: in some cases, the cost of refunding the user (i.e. DA costs of\n    /// tx side-effects) might exceed the refund amount. For app logic with\n    /// fairly stable and predictable gas consumption, a material refund amount\n    /// is unlikely. For app logic with unpredictable gas consumption, a\n    /// refund might be important to the user (e.g. if a hefty function reverts\n    /// very early). Wallet/FPC/Paymaster developers should be mindful of this.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the teardown\n    ///                        function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - An array of fields to pass to the function.\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    pub fn set_public_teardown_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n        hide_msg_sender: bool,\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n\n    /// Low-level function to set the public teardown function.\n    ///\n    /// This is the underlying implementation for setting the teardown function\n    /// call that will execute at the end of the transaction. Instead of taking\n    /// raw arguments, it accepts a hash of the arguments.\n    ///\n    /// Advanced function: Most developers should use\n    /// `set_public_teardown_function` instead.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the teardown\n    ///                        function\n    /// * `calldata_hash` - Hash of the function calldata\n    /// * `is_static_call` - Whether this should be a read-only call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n        hide_msg_sender: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let msg_sender = if hide_msg_sender {\n            NULL_MSG_SENDER_CONTRACT_ADDRESS\n        } else {\n            self.this_address()\n        };\n\n        self.public_teardown_call_request =\n            PublicCallRequest { msg_sender, contract_address, is_static_call, calldata_hash };\n    }\n\n    /// Increments the side-effect counter.\n    ///\n    /// Very low-level function.\n    ///\n    /// # Advanced\n    ///\n    /// Every side-effect of a private function is given a \"side-effect counter\",\n    /// based on when it is created. This PrivateContext is in charge of\n    /// assigning the counters.\n    ///\n    /// The reason we have side-effect counters is complicated. Consider this\n    /// illustrative pseudocode of inter-contract function calls:\n    /// ```\n    /// contract A {\n    ///    let x = 5; // pseudocode for storage var x.\n    ///    fn a1 {\n    ///        read x; // value: 5, counter: 1.\n    ///        x = x + 1;\n    ///        write x; // value: 6, counter: 2.\n    ///\n    ///        B.b(); // start_counter: 2, end_counter: 4\n    ///\n    ///        read x; // value: 36, counter: 5.\n    ///        x = x + 1;\n    ///        write x; // value: 37, counter: 6.\n    ///    }\n    ///\n    ///    fn a2 {\n    ///        read x; // value: 6, counter: 3.\n    ///        x = x * x;\n    ///        write x; // value: 36, counter: 4.\n    ///    }\n    /// }\n    ///\n    /// contract B {\n    ///     fn b() {\n    ///         A.a2();\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// Suppose a1 is the first function called. The comments show the execution\n    /// counter of each side-effect, and what the new value of `x` is.\n    ///\n    /// These (private) functions are processed by Aztec's kernel circuits in an\n    /// order that is different from execution order:\n    /// All of A.a1 is proven before B.b is proven, before A.a2 is proven.\n    /// So when we're in the 2nd execution frame of A.a1 (after the call to\n    /// B.b), the circuit needs to justify why x went from being `6` to `36`.\n    /// But the circuit doesn't know why, and given the order of proving, the\n    /// kernel hasn't _seen_ a value of 36 get written yet.\n    /// The kernel needs to track big arrays of all side-effects of all\n    /// private functions in a tx. Then, as it recurses and processes B.b(), it\n    /// will eventually see a value of 36 get written.\n    ///\n    /// Suppose side-effect counters weren't exposed:\n    /// The kernel would only see this ordering (in order of proof verification):\n    /// [ A.a1.read, A.a1.write, A.a1.read, A.a1.write, A.a2.read, A.a2.write ]\n    /// [         5,          6,        36,         37,         6,         36 ]\n    /// The kernel wouldn't know _when_ B.b() was called within A.a1(), because\n    /// it can't see what's going on within an app circuit. So the kernel\n    /// wouldn't know that the ordering of reads and writes should actually be:\n    /// [ A.a1.read, A.a1.write, A.a2.read, A.a2.write, A.a1.read, A.a1.write ]\n    /// [         5,          6,        6,         36,         36,         37 ]\n    ///\n    /// And so, we introduced side-effect counters: every private function must\n    /// assign side-effect counters alongside every side-effect that it emits,\n    /// and also expose to the kernel the counters that it started and ended\n    /// with.\n    /// This gives the kernel enough information to arrange all side-effects in\n    /// the correct order.\n    /// It can then catch (for example) if a function tries to read state\n    /// before it has been written (e.g. if A.a2() maliciously tried to read\n    /// a value of x=37) (e.g. if A.a1() maliciously tried to read x=6).\n    ///\n    /// If a malicious app contract _lies_ and does not count correctly:\n    /// - It cannot lie about its start and end counters because the kernel\n    ///   will catch this.\n    /// - It _could_ lie about its intermediate counters:\n    ///   - 1. It could not increment its side-effects correctly\n    ///   - 2. It could label its side-effects with counters outside of its\n    ///        start and end counters' range.\n    ///   The kernel will catch 2.\n    ///   The kernel will not catch 1., but this would only cause corruption\n    ///   to the private state of the malicious contract, and not any other\n    ///   contracts (because a contract can only modify its own state). If\n    ///   a \"good\" contract is given _read access_ to a maliciously-counting\n    ///   contract (via an external getter function, or by reading historic\n    ///   state from the archive tree directly), and they then make state\n    ///   changes to their _own_ state accordingly, that could be dangerous.\n    ///   Developers should be mindful not to trust the claimed innards of\n    ///   external contracts unless they have audited/vetted the contracts\n    ///   including vetting the side-effect counter incrementation.\n    ///   This is a similar paradigm to Ethereum smart contract development:\n    ///   you must vet external contracts that your contract relies upon, and\n    ///   you must not make any presumptions about their claimed behaviour.\n    ///   (Hopefully if a contract imports a version of aztec-nr, we will get\n    ///   contract verification tooling that can validate the authenticity\n    ///   of the imported aztec-nr package, and hence infer that the side-\n    ///   effect counting will be correct, without having to re-audit such logic\n    ///   for every contract).\n    ///\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            include_by_timestamp: 0,\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            anchor_block_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "73": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::{MAX_U32_VALUE, NULL_MSG_SENDER_CONTRACT_ADDRESS};\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\n/// # PublicContext\n///\n/// The **main interface** between an #[external(\"public\")] function and the Aztec blockchain.\n///\n/// An instance of the PublicContext is initialized automatically at the outset\n/// of every public function, within the #[external(\"public\")] macro, so you'll never\n/// need to consciously instantiate this yourself.\n///\n/// The instance is always named `context`, and it will always be available\n/// within the body of every #[external(\"public\")] function in your smart contract.\n///\n/// Typical usage for a smart contract developer will be to call getter\n/// methods of the PublicContext.\n///\n/// _Pushing_ data and requests to the context is mostly handled within\n/// aztec-nr's own functions, so typically a smart contract developer won't\n/// need to call any setter methods directly.\n///\n/// ## Responsibilities\n/// - Exposes contextual data to a public function:\n///   - Data relating to how this public function was called:\n///     - msg_sender, this_address\n///   - Data relating to the current blockchain state:\n///     - timestamp, block_number, chain_id, version\n///   - Gas and fee information\n/// - Provides state access:\n///   - Read/write public storage (key-value mapping)\n///   - Check existence of notes and nullifiers\n///     (Some patterns use notes & nullifiers to store public (not private)\n///     information)\n///   - Enables consumption of L1->L2 messages.\n/// - Enables calls to other public smart contract functions:\n/// - Writes data to the blockchain:\n///   - Updates to public state variables\n///   - New public logs (for events)\n///   - New L2->L1 messages\n///   - New notes & nullifiers\n///     (E.g. pushing public info to notes/nullifiers, or for completing\n///     \"partial notes\")\n///\n/// ## Key Differences from Private Execution\n///\n/// Unlike private functions -- which are executed on the user's device and which\n/// can only reference historic state -- public functions are executed by a block\n/// proposer and are executed \"live\" on the _current_ tip of the chain.\n/// This means public functions can:\n/// - Read and write _current_ public state\n/// - Immediately see the effects of earlier transactions in the same block\n///\n/// Also, public functions are executed within a zkVM (the \"AVM\"), so that they\n/// can _revert_ whilst still ensuring payment to the proposer and prover.\n/// (Private functions cannot revert: they either succeed, or they cannot be\n/// included).\n///\n/// ## Optimising Public Functions\n///\n/// Using the AVM to execute public functions means they compile down to \"AVM\n/// bytecode\" instead of the ACIR that private functions (standalone circuits)\n/// compile to. Therefore the approach to optimising a public function is\n/// fundamentally different from optimising a public function.\n///\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl Eq for PublicContext {\n    fn eq(self, other: Self) -> bool {\n        (self.args_hash == other.args_hash)\n        // Can't compare the function compute_args_hash\n    }\n}\n\nimpl PublicContext {\n    /// Creates a new PublicContext instance.\n    ///\n    /// Low-level function: This is called automatically by the #[external(\"public\")]\n    /// macro, so you shouldn't need to be called directly by smart contract\n    /// developers.\n    ///\n    /// # Arguments\n    /// * `compute_args_hash` - Function to compute the args_hash\n    ///\n    /// # Returns\n    /// * A new PublicContext instance\n    ///\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    /// Emits a _public_ log that will be visible onchain to everyone.\n    ///\n    /// # Arguments\n    /// * `log` - The data to log, must implement Serialize trait\n    ///\n    pub fn emit_public_log<T>(_self: &mut Self, log: T)\n    where\n        T: Serialize,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    /// Checks if a given note hash exists in the note hash tree at a particular\n    /// leaf_index.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The note hash to check for existence\n    /// * `leaf_index` - The index where the note hash should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the note hash exists at the specified index\n    ///\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: u64) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    /// Checks if a specific L1-to-L2 message exists in the L1-to-L2 message\n    /// tree at a particular leaf index.\n    ///\n    /// Common use cases include token bridging, cross-chain governance, and\n    /// triggering L2 actions based on L1 events.\n    ///\n    /// This function should be called before attempting to consume an L1-to-L2\n    /// message.\n    ///\n    /// # Arguments\n    /// * `msg_hash` - Hash of the L1-to-L2 message to check\n    /// * `msg_leaf_index` - The index where the message should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the message exists at the specified index\n    ///\n    /// # Advanced\n    /// * Uses the AVM l1_to_l2_msg_exists opcode for tree lookup\n    /// * Messages are copied from L1 Inbox to L2 by block proposers\n    ///\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        // TODO(alvaro): Make l1l2msg leaf index a u64 upstream\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index as u64) } == 1\n    }\n\n    /// Checks if a specific nullifier has been emitted by a given contract.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. An example is to check\n    /// whether a contract has been published: we emit a nullifier that is\n    /// deterministic, but whose preimage is _not_ private. This is more\n    /// efficient than using mutable storage, and can be done directly\n    /// from a private function.\n    ///\n    /// Nullifiers can be tested for non-existence in public, which is not the\n    /// case in private. Because private functions do not have access to\n    /// the tip of the blockchain (but only the anchor block they are built\n    /// at) they can only prove nullifier non-existence in the past. But between\n    /// an anchor block and the block in which a tx is included, the nullifier\n    /// might have been inserted into the nullifier tree by some other\n    /// transaction.\n    /// Public functions _do_ have access to the tip of the state, and so\n    /// this pattern is safe.\n    ///\n    /// # Arguments\n    /// * `unsiloed_nullifier` - The raw nullifier value (before siloing with\n    ///                          the contract address that emitted it).\n    /// * `address` - The claimed contract address that emitted the nullifier\n    ///\n    /// # Returns\n    /// * `bool` - True if the nullifier has been emitted by the specified contract\n    ///\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2) -- effectively\n    /// marking it as \"read\".\n    ///\n    /// Use this function if you only want the message to ever be \"referred to\"\n    /// once. Once consumed using this method, the message cannot be consumed\n    /// again, because a nullifier is emitted.\n    /// If your use case wants for the message to be read unlimited times, then\n    /// you can always read any historic message from the L1-to-L2 messages tree,\n    /// using the `l1_to_l2_msg_exists` method. Messages never technically get\n    /// deleted from that tree.\n    ///\n    /// The message will first be inserted into an Aztec \"Inbox\" smart contract\n    /// on L1. It will not be available for consumption immediately. Messages\n    /// get copied-over from the L1 Inbox to L2 by the next Proposer in batches.\n    /// So you will need to wait until the messages are copied before you can\n    /// consume them.\n    ///\n    /// # Arguments\n    /// * `content` - The message content that was sent from L1\n    /// * `secret` - Secret value used for message privacy (if needed)\n    /// * `sender` - Ethereum address that sent the message\n    /// * `leaf_index` - Index of the message in the L1-to-L2 message tree\n    ///\n    /// # Advanced\n    /// * Validates message existence in the L1-to-L2 message tree\n    /// * Prevents double-consumption by emitting a nullifier\n    /// * Message hash is computed from all parameters + chain context\n    /// * Will revert if message doesn't exist or was already consumed\n    ///\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    /// Sends an \"L2 -> L1 message\" from this function (Aztec, L2) to a smart\n    /// contract on Ethereum (L1). L1 contracts which are designed to\n    /// send/receive messages to/from Aztec are called \"Portal Contracts\".\n    ///\n    /// Common use cases include withdrawals, cross-chain asset transfers, and\n    /// triggering L1 actions based on L2 state changes.\n    ///\n    /// The message will be inserted into an Aztec \"Outbox\" contract on L1,\n    /// when this transaction's block is proposed to L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target portal contract. The message will need to be manually\n    /// consumed from the Outbox through a separate Ethereum transaction: a user\n    /// will need to call a function of the portal contract -- a function\n    /// specifically designed to make a call to the Outbox to consume the\n    /// message.\n    /// The message will only be available for consumption once the _epoch_\n    /// proof has been submitted. Given that there are multiple Aztec blocks\n    /// within an epoch, it might take some time for this epoch proof to be\n    /// submitted -- especially if the block was near the start of an epoch.\n    ///\n    /// # Arguments\n    /// * `recipient` - Ethereum address that will receive the message\n    /// * `content` - Message content (32 bytes as a Field element)\n    ///\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    /// Calls a public function on another contract.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Arguments to pass to the function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Makes a read-only call to a public function on another contract.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Useful for querying data from other contracts safely.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Array of arguments to pass to the called function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Adds a new note hash to the Aztec blockchain's global Note Hash Tree.\n    ///\n    /// Notes are ordinarily constructed and emitted by _private_ functions, to\n    /// ensure that both the content of the note, and the contract that emitted\n    /// the note, stay private.\n    ///\n    /// There are however some useful patterns whereby a note needs to contain\n    /// _public_ data. The ability to push a new note_hash from a _public_\n    /// function means that notes can be injected with public data immediately\n    /// -- as soon as the public value is known. The slower alternative would\n    /// be to submit a follow-up transaction so that a private function can\n    /// inject the data. Both are possible on Aztec.\n    ///\n    /// Search \"Partial Note\" for a very common pattern which enables a note\n    /// to be \"partially\" populated with some data in a _private_ function, and\n    /// then later \"completed\" with some data in a public function.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The hash of the note to add to the tree\n    ///\n    /// # Advanced\n    /// * The note hash will be siloed with the contract address by the protocol\n    ///\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n\n    /// Adds a new nullifier to the Aztec blockchain's global Nullifier Tree.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. Hence why you're seeing this\n    /// function within the PublicContext.\n    /// An example is to check whether a contract has been published: we emit\n    /// a nullifier that is deterministic, but whose preimage is _not_ private.\n    ///\n    /// # Arguments\n    /// * `nullifier` - A unique field element that represents the consumed\n    ///   state\n    ///\n    /// # Advanced\n    /// * Nullifier is immediately added to the global nullifier tree\n    /// * Emitted nullifiers are immediately visible to all\n    ///   subsequent transactions in the same block\n    /// * Automatically siloed with the contract address by the protocol\n    /// * Used for preventing double-spending and ensuring one-time actions\n    ///\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    /// Returns the address of the current contract being executed.\n    ///\n    /// This is equivalent to `address(this)` in Solidity (hence the name).\n    /// Use this to identify the current contract's address, commonly needed for\n    /// access control or when interacting with other contracts.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The contract address of the current function being\n    ///                    executed.\n    ///\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: If the calling function is a _private_ function, then\n    /// it had the option of hiding its address when enqueuing this public\n    /// function call. In such cases, this `context.msg_sender()` method will\n    /// return `Option<AztecAddress>::none`.\n    /// If the calling function is a _public_ function, it will always return\n    /// an `Option<AztecAddress>::some` (i.e. a non-null value).\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called\n    ///   this function (be it an app contract or a user's account contract).\n    ///\n    /// # Advanced\n    /// * Value is provided by the AVM sender opcode\n    /// * In nested calls, this is the immediate caller, not the original\n    ///   transaction sender\n    ///\n    pub fn msg_sender(_self: Self) -> Option<AztecAddress> {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let maybe_msg_sender = unsafe { sender() };\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// \"Unsafe\" versus calling `context.msg_sender()`, because it doesn't\n    /// translate `NULL_MSG_SENDER_CONTRACT_ADDRESS` as\n    /// `Option<AztecAddress>::none`.\n    /// Used by some internal aztecnr functions.\n    pub fn msg_sender_unsafe(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n\n    /// Returns the function selector of the currently-executing function.\n    ///\n    /// This is similar to `msg.sig` in Solidity, returning the first 4\n    /// bytes of the function signature.\n    ///\n    /// # Returns\n    /// * `FunctionSelector` - The 4-byte function identifier\n    ///\n    /// # Advanced\n    /// * Extracted from the first element of calldata\n    /// * Used internally for function dispatch in the AVM\n    ///\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    ///\n    /// Very low-level function: The #[external(\"public\")] macro uses this internally.\n    /// Smart contract developers typically won't need to access this\n    /// directly as arguments are automatically made available.\n    ///\n    /// # Returns\n    /// * `Field` - Hash of the function arguments\n    ///\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n\n    /// Returns the \"transaction fee\" for the current transaction.\n    /// This is the final tx fee that will be deducted from the fee_payer's\n    /// \"fee-juice\" balance (in the protocol's Base Rollup circuit).\n    ///\n    /// # Returns\n    /// * `Field` - The actual, final cost of the transaction, taking into account:\n    ///             the actual gas used during the setup and app-logic phases,\n    ///             and the fixed amount of gas that's been allocated by the user\n    ///             for the teardown phase.\n    ///             I.e. effectiveL2FeePerGas * l2GasUsed + effectiveDAFeePerGas * daGasUsed\n    ///\n    /// This will return `0` during the \"setup\" and \"app-logic\" phases of\n    /// tx execution (because the final tx fee is not known at that time).\n    /// This will only return a nonzero value during the \"teardown\" phase of\n    /// execution, where the final tx fee can actually be computed.\n    ///\n    /// Regardless of _when_ this function is called during the teardown phase,\n    /// it will always return the same final tx fee value. The teardown phase\n    /// does not consume a variable amount of gas: it always consumes a\n    /// pre-allocated amount of gas, as specified by the user when they generate\n    /// their tx.\n    ///\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    /// Returns the chain ID of the current network.\n    ///\n    /// This is similar to `block.chainid` in Solidity. Returns the unique\n    /// identifier for the blockchain network this transaction is executing on.\n    ///\n    /// Helps prevent cross-chain replay attacks. Useful if implementing\n    /// multi-chain contract logic.\n    ///\n    /// # Returns\n    /// * `Field` - The chain ID as a field element\n    ///\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n\n    /// Returns the Aztec protocol version that this transaction is executing\n    /// under. Different versions may have different rules, opcodes, or\n    /// cryptographic primitives.\n    ///\n    /// This is similar to how Ethereum has different EVM versions.\n    ///\n    /// Useful for forward/backward compatibility checks\n    ///\n    /// Not to be confused with contract versions; this is the protocol version.\n    ///\n    /// # Returns\n    /// * `Field` - The protocol version as a field element\n    ///\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    /// Returns the current block number.\n    ///\n    /// This is similar to `block.number` in Solidity.\n    ///\n    /// Note: the current block number is only available within a public function\n    /// (as opposed to a private function).\n    ///\n    /// Note: the time intervals between blocks should not be relied upon as\n    /// being consistent:\n    /// - Timestamps of blocks fall within a range, rather than at exact regular\n    ///   intervals.\n    /// - Slots can be missed.\n    /// - Protocol upgrades can completely change the intervals between blocks\n    ///   (and indeed the current roadmap plans to reduce the time between\n    ///   blocks, eventually).\n    /// Use `context.timestamp()` for more-reliable time-based logic.\n    ///\n    /// # Returns\n    /// * `u32` - The current block number\n    ///\n    pub fn block_number(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n\n    /// Returns the timestamp of the current block.\n    ///\n    /// This is similar to `block.timestamp` in Solidity.\n    ///\n    /// All functions of all transactions in a block share the exact same\n    /// timestamp (even though technically each transaction is executed\n    /// one-after-the-other).\n    ///\n    /// Important note: Timestamps of Aztec blocks are not at reliably-fixed\n    /// intervals. The proposer of the block has some flexibility to choose a\n    /// timestamp which is in a valid _range_: Obviously the timestamp of this\n    /// block must be strictly greater than that of the previous block, and must\n    /// must be less than the timestamp of whichever ethereum block the aztec\n    /// block is proposed to. Furthermore, if the timestamp is not deemed close\n    /// enough to the actual current time, the committee of validators will not\n    /// attest to the block.\n    ///\n    /// # Returns\n    /// * `u64` - Unix timestamp in seconds\n    ///\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n\n    /// Returns the fee per unit of L2 gas for this transaction (aka the \"L2 gas\n    /// price\"), as chosen by the user.\n    ///\n    /// L2 gas covers the cost of executing public functions and handling\n    /// side-effects within the AVM.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of L2 gas\n    ///\n    /// Wallet developers should be mindful that the choice of gas price (which\n    /// is publicly visible) can leak information about the user, e.g.:\n    /// - which wallet software the user is using;\n    /// - the amount of time which has elapsed from the time the user's wallet\n    ///   chose a gas price (at the going rate), to the time of tx submission.\n    ///   This can give clues about the proving time, and hence the nature of\n    ///   the tx.\n    /// - the urgency of the transaction (which is kind of unavoidable, if the\n    ///   tx is indeed urgent).\n    /// - the wealth of the user.\n    /// - the exact user (if the gas price is explicitly chosen by the user to\n    ///   be some unique number like 0.123456789, or their favourite number).\n    /// Wallet devs might wish to consider fuzzing the choice of gas price.\n    ///\n    pub fn base_fee_per_l2_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_l2_gas()\n        }\n    }\n\n    /// Returns the fee per unit of DA (Data Availability) gas (aka the \"DA gas\n    /// price\").\n    ///\n    /// DA gas covers the cost of making transaction data available on L1.\n    ///\n    /// See the warning in `fee_pre_l2_gas` for how gas prices can be leaky.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of DA gas\n    ///\n    pub fn base_fee_per_da_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_da_gas()\n        }\n    }\n\n    /// Returns the remaining L2 gas available for this transaction.\n    ///\n    /// Different AVM opcodes consume different amounts of gas.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining L2 gas units\n    ///\n    pub fn l2_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n\n    /// Returns the remaining DA (Data Availability) gas available for this\n    /// transaction.\n    ///\n    /// DA gas is consumed when emitting data that needs to be made available\n    /// on L1, such as public logs or state updates.\n    /// All of the side-effects from the private part of the tx also consume\n    /// DA gas before execution of any public functions even begins.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining DA gas units\n    ///\n    pub fn da_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n\n    /// Checks if the current execution is within a staticcall context, where\n    /// no state changes or logs are allowed to be emitted (by this function\n    /// or any nested function calls).\n    ///\n    /// # Returns\n    /// * `bool` - True if in staticcall context, false otherwise\n    ///\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    /// Reads raw field values from public storage.\n    /// Reads N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to read from\n    ///\n    /// # Returns\n    /// * `[Field; N]` - Array of N field values from consecutive storage slots\n    ///\n    /// # Generic Parameters\n    /// * `N` - the number of consecutive slots to return, starting from the\n    ///         `storage_slot`.\n    ///\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    /// Reads a typed value from public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to read from\n    ///\n    /// # Returns\n    /// * `T` - The deserialized value from storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type that the caller expects to read from the `storage_slot`.\n    ///\n    pub fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    /// Writes raw field values to public storage.\n    /// Writes to N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// Public storage writes take effect immediately.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to write to\n    /// * `values` - Array of N Fields to write to storage\n    ///\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    /// Writes a typed value to public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to write to\n    /// * `value` - The typed value to write to storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type to write to storage.\n    ///\n    pub fn storage_write<T>(self, storage_slot: Field, value: T)\n    where\n        T: Packable,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> u32 {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn base_fee_per_l2_gas() -> u128 {\n    base_fee_per_l2_gas_opcode()\n}\nunconstrained fn base_fee_per_da_gas() -> u128 {\n    base_fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> u32 {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> u32 {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> u1 {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: u64) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: u64) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\n\nunconstrained fn call(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\nunconstrained fn call_static(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeBaseFeePerL2Gas)]\nunconstrained fn base_fee_per_l2_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeBaseFeePerDaGas)]\nunconstrained fn base_fee_per_da_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> u1 {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "74": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr",
      "source": "use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\n/// A hash that represents a private contract function call's return value. Call `get_preimage` to get the underlying\n/// value.\n///\n/// The kernels don't process the actual return values but instead their hashes, so it is up to contracts to populate\n/// oracles with the preimages of these hashes on return to make them available to their callers.\n///\n/// Public calls don't utilize this mechanism since the AVM does process the full return values.\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    /// Fetches the underlying return value from an oracle, constraining that it corresponds to the return data hash.\n    pub fn get_preimage<T>(self) -> T\n    where\n        T: Deserialize,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it. If `T`\n        // is `()`, then `preimage` must be an array of length 0 (since that is `()`'s deserialization length).\n        // `hash_args_array` handles empty arrays following the protocol rules (i.e. an empty args array is signaled\n        // with a zero hash), correctly constraining `self.hash`.\n        let preimage = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage), \"Preimage mismatch\");\n\n        Deserialize::deserialize(preimage)\n    }\n}\n\nmod test {\n    use crate::{\n        hash::hash_args_array,\n        oracle::execution_cache,\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use super::ReturnsHash;\n    use protocol_types::traits::Serialize;\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn retrieves_preimage() {\n        let env = TestEnvironment::new();\n        env.private_context(|_| {\n            let value = MockStruct::new(4, 7);\n            let serialized = value.serialize();\n\n            let hash = hash_args_array(serialized);\n            execution_cache::store(serialized, hash);\n\n            assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n        });\n    }\n\n    #[test]\n    unconstrained fn retrieves_empty_preimage() {\n        let env = TestEnvironment::new();\n        env.private_context(|_| {\n            let value = ();\n            let serialized = [];\n\n            let hash = hash_args_array(serialized);\n            execution_cache::store(serialized, hash);\n\n            assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n        });\n    }\n\n    #[test(should_fail_with = \"Preimage mismatch\")]\n    unconstrained fn rejects_bad_preimage() {\n        let value = MockStruct::new(4, 7);\n        let serialized = value.serialize();\n\n        let mut bad_serialized = serialized;\n        bad_serialized[0] += 1;\n\n        let hash = hash_args_array(serialized);\n\n        let _ = OracleMock::mock(\"privateLoadFromExecutionCache\").returns(bad_serialized);\n        assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n    }\n\n    // This test passes due to a Noir bug.\n    // #[test(should_fail_with=\"Preimage mismatch\")]\n    // unconstrained fn rejects_bad_empty_preimage() {\n    //     let value = ();\n    //     let serialized = [];\n\n    //     let hash = hash_args_array(serialized);\n\n    //     let _ = OracleMock::mock(\"privateLoadFromExecutionCache\").returns([1]);\n    //     assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n    // }\n}\n"
    },
    "75": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{execution::get_utility_context, storage::storage_read};\nuse protocol_types::{address::AztecAddress, traits::Packable};\n\n// If you'll modify this struct don't forget to update utility_context.ts as well.\npub struct UtilityContext {\n    block_number: u32,\n    timestamp: u64,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        get_utility_context()\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        // We get a context with default contract address, and then we construct the final context with the provided\n        // contract address.\n        let default_context = get_utility_context();\n\n        Self {\n            block_number: default_context.block_number,\n            timestamp: default_context.timestamp,\n            contract_address,\n            version: default_context.version,\n            chain_id: default_context.chain_id,\n        }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        // We get a context with default contract address and block number, and then we construct the final context\n        // with the provided contract address and block number.\n        let default_context = get_utility_context();\n\n        Self {\n            block_number,\n            timestamp: default_context.timestamp,\n            contract_address,\n            version: default_context.version,\n            chain_id: default_context.chain_id,\n        }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn timestamp(self) -> u64 {\n        self.timestamp\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "78": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/event/event_selector.nr",
      "source": "use dep::protocol_types::{\n    hash::poseidon2_hash_bytes,\n    traits::{Deserialize, Empty, FromField, Serialize, ToField},\n};\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "80": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_BYTECODE, GENERATOR_INDEX__PUBLIC_CALLDATA,\n        GENERATOR_INDEX__SECRET_HASH, MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS,\n    },\n    hash::{\n        poseidon2_hash_subarray, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice,\n        sha256_to_field,\n    },\n    point::Point,\n    traits::ToField,\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n}\n\n/**\n * Computes the public bytecode commitment for a contract class.\n * The commitment is `hash([separator, ...bytecode])` where bytecode omits the length prefix present\n * in `packed_bytecode`.\n *\n * @param packed_bytecode - The packed bytecode of the contract class. 0th word is the length in bytes.\n *    packed_bytecode is mutable so that we can avoid copying the array to construct one starting with\n *    separator instead of length.\n * @returns The public bytecode commitment.\n */\npub fn compute_public_bytecode_commitment(\n    mut packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS],\n) -> Field {\n    // First field element contains the length of the bytecode\n    let bytecode_length_in_bytes: u32 = packed_public_bytecode[0] as u32;\n    let bytecode_length_in_fields: u32 =\n        (bytecode_length_in_bytes / 31) + (bytecode_length_in_bytes % 31 != 0) as u32;\n    // Don't allow empty public bytecode.\n    // AVM doesn't handle execution of contracts that exist with empty bytecode.\n    assert(bytecode_length_in_fields != 0);\n    assert(bytecode_length_in_fields < MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS);\n\n    // Packed_bytecode's 0th entry is the length. Replace it with separator before hashing.\n    let separator = GENERATOR_INDEX__PUBLIC_BYTECODE.to_field();\n    packed_public_bytecode[0] = separator;\n\n    // `fields_to_hash` is the number of fields from the start of `packed_public_bytecode` that should be included in\n    // the hash. Fields after this length are ignored.\n    // +1 to account for the separator.\n    let num_fields_to_hash = bytecode_length_in_fields + 1;\n\n    poseidon2_hash_subarray(packed_public_bytecode, num_fields_to_hash)\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = [0; 100];\n    for i in 0..100 {\n        input[i] = i as Field;\n    }\n    let hash = hash_args_array(input);\n    dep::std::println(hash);\n    // Used in yarn-project/stdlib test snapshots:\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_calldata_hash() {\n    let mut input = [0; 100];\n    for i in 0..input.len() {\n        input[i] = i as Field;\n    }\n    let hash = hash_calldata_array(input);\n    dep::std::println(hash);\n    let hash_check = hash_calldata(input.as_slice());\n    assert(hash == hash_check);\n    // Used in cpp vm2 tests:\n    assert(hash == 0x191383c9f8964afd3ea8879a03b7dda65d6724773966d18dcf80e452736fc1f3);\n}\n\n#[test]\nunconstrained fn public_bytecode_commitment() {\n    let mut input = [0; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS];\n    let len = 99;\n    for i in 1..len + 1 {\n        input[i] = i as Field;\n    }\n    input[0] = (len as Field) * 31;\n    let hash = compute_public_bytecode_commitment(input);\n    dep::std::println(hash);\n    // Used in cpp vm2 tests:\n    assert(hash == 0x16d621c3387156ef53754679e7b2c9be8f0bceeb44aa59a74991df3b0b42a0bf);\n}\n"
    },
    "92": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/history/public_storage.nr",
      "source": "use dep::protocol_types::{\n    abis::block_header::BlockHeader, address::AztecAddress,\n    constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX, hash::poseidon2_hash_with_separator,\n    utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\nuse protocol_types::traits::{Hash, ToField};\n\nmod test;\n\npub trait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        // Safety: The witness is only used as a \"magical value\" that makes the proof below pass. Hence it's safe.\n        let witness = unsafe {\n            get_public_data_witness(self.global_variables.block_number, public_data_tree_index)\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert_eq(\n            self.state.partial.public_data_tree.root,\n            root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path),\n            \"Proving public value inclusion failed\",\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(\n                preimage.slot,\n                public_data_tree_index,\n                \"Public data tree index doesn't match witness\",\n            );\n            preimage.value\n        };\n\n        value\n    }\n}\n"
    },
    "97": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n\nmod test {\n    use super::get_public_keys;\n\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use protocol_types::traits::Serialize;\n    use std::test::OracleMock;\n\n    global KEY_ORACLE_RESPONSE_LENGTH: u32 = 13; // 12 fields for the keys, one field for the partial address\n\n    #[test(should_fail_with = \"Invalid public keys hint for address\")]\n    unconstrained fn get_public_keys_fails_with_bad_hint() {\n        let mut env = TestEnvironment::new();\n        let account = env.create_light_account();\n\n        // Instead of querying for some unknown account, which would result in the oracle erroring out, we mock a bad oracle\n        // response to check that the circuit properly checks the address derivation.\n        let mut random_keys_and_partial_address = [0; KEY_ORACLE_RESPONSE_LENGTH];\n        // We use randomly generated points on the curve, and a random partial address to ensure that\n        // this combination does not derive the address and we should see the assertion fail.\n        // npk_m\n        random_keys_and_partial_address[0] =\n            0x292364b852c6c6f01472951e76a39cbcf074591fd0e063a81965e7b51ad868a5;\n        random_keys_and_partial_address[1] =\n            0x0a687b46cdc9238f1c311f126aaaa4acbd7a737bff2efd7aeabdb8d805843a27;\n        random_keys_and_partial_address[2] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // ivpk_m\n        random_keys_and_partial_address[3] =\n            0x173c5229a00c5425255680dd6edc27e278c48883991f348fe6985de43b4ec25f;\n        random_keys_and_partial_address[4] =\n            0x1698608e23b5f6c2f43c49a559108bb64e2247b8fc2da842296a416817f40b7f;\n        random_keys_and_partial_address[5] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // ovpk_m\n        random_keys_and_partial_address[6] =\n            0x1bad2f7d1ad960a1bd0fe4d2c8d17f5ab4a86ef8b103e0a9e7f67ec0d3b4795e;\n        random_keys_and_partial_address[7] =\n            0x206db87110abbecc9fbaef2c865189d94ef2c106202f734ee4eba9257fd28bf1;\n        random_keys_and_partial_address[8] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // tpk_m\n        random_keys_and_partial_address[9] =\n            0x05e3bd9cfe6b47daa139613619cf7d7fd8bb0112b6f2908caa6d9b536ed948ed;\n        random_keys_and_partial_address[10] =\n            0x051066f877c9df47552d02e7dc32127ff4edefc8498e813bca1cbd3f5d1be429;\n        random_keys_and_partial_address[11] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // partial address\n        random_keys_and_partial_address[12] =\n            0x236703e2cb00a182e024e98e9f759231b556d25ff19f98896cebb69e9e678cc9;\n\n        let _ = OracleMock::mock(\"utilityGetPublicKeysAndPartialAddress\").returns(\n            random_keys_and_partial_address.serialize(),\n        );\n        let _ = get_public_keys(account);\n    }\n}\n"
    }
  },
  "functions": [
    {
      "abi": {
        "error_types": {
          "11594563071547591162": {
            "error_kind": "string",
            "string": "Function _validate_emitter_and_update_value can only be called internally"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18173155084464344029": {
            "error_kind": "string",
            "string": "Emitter not registered"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "8228371833434187583": {
            "error_kind": "string",
            "string": "Trying to read from uninitialized PublicImmutable"
          }
        },
        "parameters": [
          {
            "name": "emitter_chain_id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 16
            },
            "visibility": "private"
          },
          {
            "name": "emitter_address",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "value",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "internal",
        "public"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "_validate_emitter_and_update_value"
    },
    {
      "abi": {
        "error_types": {
          "14415304921900233953": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "9967937311635654895": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          }
        },
        "parameters": [
          {
            "name": "wormhole_address",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "chain_id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 16
            },
            "visibility": "private"
          },
          {
            "name": "owner",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "message_fee",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "consistency",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JwACBAEoAAABBIBLJwAABEsnAgYEBScCBwQAHwoABgAHAEYcAEdHAxwASUkGHABKSgItCEYBLQhHAi0ISAMtCEkELQhKBSUAAABgJQAAAJAnAgEESycCAgQAOw4AAgABLAAAQwAwZE5y4TGgKbhQRbaBgVhdKDPoSHm5cJFD4fWT8AAAACcARAQGJwBFBAMmJQAAE/MeAgAHAC0IAQgnAgkEAwAIAQkBJwMIBAEAIggCCTYOAAcACQAnAgkEAQAqCAkLLQsLCicCCwQCACoICw0tCw0MHAoKCAAEKggMDScCCAEBJAIACgAAAPUnAgwEADwGDAEtCAEKJwIMBAMACAEMAScDCgQBACIKAgw2DgAHAAwCACoKCQwtCwwHACoKCw4tCw4MHAoHCgAEKgoMDiQCAAcAAAFBJwIKBAA8BgoBJwIHBAAtCAEKJwIMBAIACAEMAScDCgQBACIKAgwfOgAJAAcADAAqCgkPLQsPDBwKDA8EHAoPCgAtCAEMAAABAgEnAg8AAi0ODwwtCAEPAAABAgEnAhAAAy0OEA8nAhAEBS0IAREnAhIEBgAIARIBJwMRBAEAIhECEh86ABAACQASLQgBEgAAAQIBJwITAAAnAhQALC0IARUnAhYEBwAIARYBJwMVBAEAIhUCFi0KFhctDhQXACIXAhctDhMXACIXAhctDhMXACIXAhctDhMXACIXAhctDhMXACIXAhctDhMXLQ4VEi0KBwYjAAACLwwqBhAUJAIAFAAAE50jAAACQS0LEhEtCAESJwIUBAQACAEUAScDEgQBACISAhQtChQVLQ4TFQAiFQIVLQ4TFQAiFQIVLQ4TFSsCABQAAAAAAAAAAAYAAAAAAAAAAC0IARUnAhYEBQAIARYBJwMVBAEAIhUCFi0KFhctDhMXACIXAhctDhMXACIXAhctDhMXACIXAhctDhQXLQgBFAAAAQIBLQ4SFC0IARIAAAECAS0OFRItCAEVAAABAgEtDgcVLQgBFgAAAQIBJwIXAQAtDhcWLQoHBiMAAAMJDCIGRBgkAgAYAAAR2SMAAAMbLQsWEQoqERcYJAIAGAAAAzUnAhkEADwGGQEtCgcGIwAAAz4MIgZFESQCABEAABFTIwAAA1AtCxQRLQsSGC0LFRktCxgaACIaAhotDhoYLQgBGicCGwQFAAgBGwEnAxoEAQAiGAIbJwIcBAQAIhoCHT8PABsAHS0OERQtDhoSLQ4ZFS0OCBYAKhoJEi0LEhEtCwwSLQsPFC0OEgwtDhQPJwIMAA0tCAEPJwISBAQACAESAScDDwQBACIPAhItChIULQ4MFAAiFAIULQ4KFAAiFAIULQ4RFC0IAQonAgwEBAAIAQwBJwMKBAEAIgoCDC0KDBEtDhMRACIRAhEtDhMRACIRAhEtDhMRKwIADAAAAAAAAAAAAwAAAAAAAAAALQgBEScCEgQFAAgBEgEnAxEEAQAiEQISLQoSFC0OExQAIhQCFC0OExQAIhQCFC0OExQAIhQCFC0ODBQtCAEMAAABAgEtDgoMLQgBCgAAAQIBLQ4RCi0IAREAAAECAS0OBxEtCAESAAABAgEtDhcSLQoHBiMAAASwDCIGRRQkAgAUAAAPjyMAAATCLQsSDwoqDxcUJAIAFAAABNwnAhUEADwGFQEtCgcGIwAABOUMIgZFDyQCAA8AAA8JIwAABPctCwwGLQsKDy0LERQtCw8VACIVAhUtDhUPLQgBFScCFgQFAAgBFgEnAxUEAQAiDwIWJwIYBAQAIhUCGT8PABYAGS0OBgwtDhUKLQ4UES0OCBIAKhUJCi0LCgYKKg4GCiQCAAoAAAVjJQAAFBkKKg0TBh4CAAoBCiIKQwwWCgwOHAoODwAEKg8KDgoqDBcKJAIACgAABZYnAg8EADwGDwEKKg0OChIqBgoMJAIADAAABa0lAAAUKy0IAQYnAgoEBAAIAQoBJwMGBAEAIgYCCi0KCgwtDhMMACIMAgwtDhMMACIMAgwtDhMMKwIACgAAAAAAAAAAAgAAAAAAAAAALQgBDCcCDQQFAAgBDQEnAwwEAQAiDAINLQoNDi0OEw4AIg4CDi0OEw4AIg4CDi0OEw4AIg4CDi0OCg4tCAEKAAABAgEtDgYKLQgBBgAAAQIBLQ4MBi0IAQ0AAAECAS0OBw0tCAEOAAABAgEtDhcOJwIPAAYkAgAXAAAGvCMAAAZ1LQgBEScCEgQEAAgBEgEnAxEEAQAiEQISLQoSFC0ODxQAIhQCFC0OExQAIhQCFC0OExQtDhEKLQ4MBi0OCQ0tDhcOIwAAB0gtCgcMIwAABsUMIgxFESQCABEAAA6DIwAABtctCwoMLQsGES0LDhItCxEUACIUAhQtDhQRLQgBFCcCFQQFAAgBFQEnAxQEAQAiEQIVJwIWBAQAIhQCGD8PABUAGC0CDAMnAAQEBCUAABQ9LQgFEQAqEQkVLQ4PFS0OEQotDhQGLQ4JDS0OEg4jAAAHSC0LCgwtCwYRLQsOEgoqEhcUJAIAFAAAB2onAhUEADwGFQEnAhIAASQCABcAAAesIwAAB3wtAgwDJwAEBAQlAAAUPS0IBRQAKhQLFS0OEhUtDhQKLQ4RBi0OCw0tDhcOIwAACDgtCgcLIwAAB7UMIgtFDCQCAAwAAA39IwAAB8ctCwoLLQsGDC0LDhEtCwwUACIUAhQtDhQMLQgBFCcCFQQFAAgBFQEnAxQEAQAiDAIVJwIWBAQAIhQCGD8PABUAGC0CCwMnAAQEBCUAABQ9LQgFDAAqDAkVLQ4SFS0ODAotDhQGLQ4JDS0OEQ4jAAAIOC0LDgwKKgwXESQCABEAAAhSJwIUBAA8BhQBLQoHCyMAAAhbDCILRQwkAgAMAAANdyMAAAhtLQsKDC0LBhEtCw0ULQsRFQAiFQIVLQ4VES0IARUnAhYEBQAIARYBJwMVBAEAIhECFicCGAQEACIVAhk/DwAWABktDgwKLQ4VBi0OFA0tDggOACoVCQotCwoGNAIABhwKAgYAHAoEAgAcCgUEAC0IAQUnAgoEBQAIAQoBJwMFBAEAIgUCCi0KCgwtDgEMACIMAgwtDgYMACIMAgwtDgIMACIMAgwtDgQMLQsFCgAiCgIKLQ4KBS0IAQonAgwEBAAIAQwBJwMKBAEAIgoCDC0KDA0tDhMNACINAg0tDhMNACINAg0tDhMNKwIADAAAAAAAAAAABAAAAAAAAAAALQgBDScCDgQFAAgBDgEnAw0EAQAiDQIOLQoOES0OExEAIhECES0OExEAIhECES0OExEAIhECES0ODBEtCAEMAAABAgEtDgoMLQgBCgAAAQIBLQ4NCi0IAQ0AAAECAS0OBw0tCAEOAAABAgEtDhcOJwIRBAQtCgcLIwAACeYMKgsRFCQCABQAAAuzIwAACfgtCw4LCioLFxEkAgARAAAKEicCFAQAPAYUAS0KBwUjAAAKGwwiBUULJAIACwAACy0jAAAKLS0LDAstCwoRLQsNFC0LERUAIhUCFS0OFREtCAEVJwIWBAUACAEWAScDFQQBACIRAhYnAhcEBAAiFQIYPw8AFgAYLQ4LDC0OFQotDhQNLQ4IDgAqFQkKLQsKCC0IAQonAgsEBgAIAQsBJwMKBAEAIgoCCy0KCwwtDgEMACIMAgwtDgYMACIMAgwtDgIMACIMAgwtDgQMACIMAgwtDggMLQoHBSMAAArUDCoFEAEkAgABAAALASMAAArmMAoAAwAPJwIBAAgwCgATAAEeAgABADQCAAEmHAoFAQAAKhIBAgAiCgIEACoEBQYtCwYBMAoAAQACACoFCQEtCgEFIwAACtQtCwwLLQsKES0LDRQtCw4VDCoFFBYkAgAWAAALTyMAAAulACIRAhcAKhcFGC0LGBYAIgsCGAAqGAUZLQsZFwAqFhcYLQIRAycABAQFJQAAFD0tCAUWACIWAhcAKhcFGS0OGBktDgsMLQ4WCi0OFA0tDhUOIwAAC6UAKgUJCy0KCwUjAAAKGwAiBQIVACoVCxYtCxYULQsMFS0LChYtCw0YLQsOGQoqGRcaJAIAGgAAC+cnAhsEADwGGwEKIhhFGSQCABkAAAxXIwAAC/kMIhhFGSQCABkAAAwLJQAAFKEtAhUDJwAEBAQlAAAUPS0IBRkAIhkCGgAqGhgbLQ4UGwAqGAkUDioYFBUkAgAVAAAMQiUAABSzLQ4ZDC0OFgotDhQNLQ4XDiMAAAzjLQoHFSMAAAxgDCIVRRYkAgAWAAAM8SMAAAxyLQsMFS0LChYtCw4YLQsWGQAiGQIZLQ4ZFi0IARknAhoEBQAIARoBJwMZBAEAIhYCGicCGwQEACIZAhw/DwAaABwtAhUDJwAEBAQlAAAUPS0IBRYAKhYJGi0OFBotDhYMLQ4ZCi0OCQ0tDhgOIwAADOMAKgsJFC0KFAsjAAAJ5i0LDBYtCwoYLQsNGS0LDhoMKhUZGyQCABsAAA0TIwAADWkAIhgCHAAqHBUdLQsdGwAiFgIdACodFR4tCx4cACobHB0tAhgDJwAEBAUlAAAUPS0IBRsAIhsCHAAqHBUeLQ4dHi0OFgwtDhsKLQ4ZDS0OGg4jAAANaQAqFQkWLQoWFSMAAAxgLQsKDC0LBhEtCw0ULQsOFQwqCxQWJAIAFgAADZkjAAAN7wAiEQIYACoYCxktCxkWACIMAhkAKhkLGi0LGhgAKhYYGS0CEQMnAAQEBSUAABQ9LQgFFgAiFgIYACoYCxotDhkaLQ4MCi0OFgYtDhQNLQ4VDiMAAA3vACoLCQwtCgwLIwAACFstCwoMLQsGES0LDRQtCw4VDCoLFBYkAgAWAAAOHyMAAA51ACIRAhgAKhgLGS0LGRYAIgwCGQAqGQsaLQsaGAAqFhgZLQIRAycABAQFJQAAFD0tCAUWACIWAhgAKhgLGi0OGRotDgwKLQ4WBi0OFA0tDhUOIwAADnUAKgsJDC0KDAsjAAAHtS0LChEtCwYSLQsNFC0LDhUMKgwUFiQCABYAAA6lIwAADvsAIhICGAAqGAwZLQsZFgAiEQIZACoZDBotCxoYACoWGBktAhIDJwAEBAUlAAAUPS0IBRYAIhYCGAAqGAwaLQ4ZGi0OEQotDhYGLQ4UDS0OFQ4jAAAO+wAqDAkRLQoRDCMAAAbFLQsMDy0LChQtCxEVLQsSFgwqBhUYJAIAGAAADysjAAAPgQAiFAIZACoZBhotCxoYACIPAhoAKhoGGy0LGxkAKhgZGi0CFAMnAAQEBSUAABQ9LQgFGAAiGAIZACoZBhstDhobLQ4PDC0OGAotDhURLQ4WEiMAAA+BACoGCQ8tCg8GIwAABOUAIg8CFQAqFQYWLQsWFC0LDBUtCwoWLQsRGC0LEhkKKhkXGiQCABoAAA/DJwIbBAA8BhsBCiIYRRkkAgAZAAAQMyMAAA/VDCIYRRkkAgAZAAAP5yUAABShLQIVAycABAQEJQAAFD0tCAUZACIZAhoAKhoYGy0OFBsAKhgJFA4qGBQVJAIAFQAAEB4lAAAUsy0OGQwtDhYKLQ4UES0OFxIjAAAQvy0KBxUjAAAQPAwiFUUWJAIAFgAAEM0jAAAQTi0LDBUtCwoWLQsSGC0LFhkAIhkCGS0OGRYtCAEZJwIaBAUACAEaAScDGQQBACIWAhonAhsEBAAiGQIcPw8AGgAcLQIVAycABAQEJQAAFD0tCAUWACoWCRotDhQaLQ4WDC0OGQotDgkRLQ4YEiMAABC/ACoGCRQtChQGIwAABLAtCwwWLQsKGC0LERktCxIaDCoVGRskAgAbAAAQ7yMAABFFACIYAhwAKhwVHS0LHRsAIhYCHQAqHRUeLQseHAAqGxwdLQIYAycABAQFJQAAFD0tCAUbACIbAhwAKhwVHi0OHR4tDhYMLQ4bCi0OGREtDhoSIwAAEUUAKhUJFi0KFhUjAAAQPC0LFBEtCxIYLQsVGS0LFhoMKgYZGyQCABsAABF1IwAAEcsAIhgCHAAqHAYdLQsdGwAiEQIdACodBh4tCx4cACobHB0tAhgDJwAEBAUlAAAUPS0IBRsAIhsCHAAqHAYeLQ4dHi0OERQtDhsSLQ4ZFS0OGhYjAAARywAqBgkRLQoRBiMAAAM+ACIRAhkAKhkGGi0LGhgtCxQZLQsSGi0LFRstCxYcCiocFx0kAgAdAAASDScCHgQAPAYeAQoiG0UcJAIAHAAAEn0jAAASHwwiG0UcJAIAHAAAEjElAAAUoS0CGQMnAAQEBCUAABQ9LQgFHAAiHAIdACodGx4tDhgeACobCRgOKhsYGSQCABkAABJoJQAAFLMtDhwULQ4aEi0OGBUtDhcWIwAAEwktCgcZIwAAEoYMIhlFGiQCABoAABMXIwAAEpgtCxQZLQsSGi0LFhstCxocACIcAhwtDhwaLQgBHCcCHQQFAAgBHQEnAxwEAQAiGgIdJwIeBAQAIhwCHz8PAB0AHy0CGQMnAAQEBCUAABQ9LQgFGgAqGgkdLQ4YHS0OGhQtDhwSLQ4JFS0OGxYjAAATCQAqBgkYLQoYBiMAAAMJLQsUGi0LEhstCxUcLQsWHQwqGRweJAIAHgAAEzkjAAATjwAiGwIfACofGSAtCyAeACIaAiAAKiAZIS0LIR8AKh4fIC0CGwMnAAQEBSUAABQ9LQgFHgAiHgIfACofGSEtDiAhLQ4aFC0OHhItDhwVLQ4dFiMAABOPACoZCRotChoZIwAAEoYAKgYJFAAiEQIWACoWBhctCxcVLQsSFgwiFEQXJAIAFwAAE8YlAAAUoS0CFgMnAAQEByUAABQ9LQgFFwAiFwIYACoYFBktDhUZLQ4XEi0KFAYjAAACLygAAAQEeEsMAAAEAyQAAAMAABQYKgEAAQXaxfXWtEoybTwEAgEmKgEAAQWKVTosK2fI7zwEAgEmKgEAAQXIDXNzbs204TwEAgEmLQEDBgoABgIHJAAABwAAFFMjAAAUXC0AAwUjAAAUoC0AAQUAAAEEAQAAAwQJLQADCi0ABQsKAAoJDCQAAAwAABSWLQEKCC0ECAsAAAoCCgAACwILIwAAFHInAQUEAQIABgIGJioBAAEF5AhQRQK1jB88BAIBJioBAAEF0Afr9MvGZ5A8BAIBJg==",
      "custom_attributes": [
        "external",
        "initializer",
        "public"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "constructor"
    },
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "14067204867181196045": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "9921926525851912681": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "wormhole_address",
                "type": {
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                }
              },
              {
                "name": "chain_id",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 16
                }
              },
              {
                "name": "message_fee",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "consistency",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 8
                }
              }
            ],
            "kind": "struct",
            "path": "types::config::Config"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "utility"
      ],
      "debug_symbols": "TL3LkjQ9b6R5L996FskDAEK3Mou26emDyUzWMuvDSjffFXCC7ht9j/96i84gCc/ISFTWf/zzX/7rf/4///0//ev/+G///r/++Zf/9z/++c//81//7d/+9b//p3/79/////vf//rv/+Pvf/2Pf37f/9nzn39Z/88/e/3zL/73n/3Pv5y//xj+4/hP4D8H/8n6j/3wn4H/TPxn4T8YxTCKYRTDKIZRDKM4RnGM4hjFMYpjFMcojlEcozhGcYwSGCUwSmCUwCiBUQKjBEYJjBIYJTDKwSgHoxyMcjDKwSgHoxyMcjDKwSgHoyRGSYySGCUxSmKUxCiJURKjJEZJjDJ+v/vfcf8773/X/e++/7X7X7//jfvfc/97xxt3vHHHG3e8cccbd7xxxxt3vHHHG3e8ccebd7z5N974fTAbVsNu+BtzrA+8IRpOw9+44+8AjvU38Px+ao2G2bAadoM1/I089wfRcBrywv5Gtg9Gw2z45vxdznf+AdbwN/IaH0TDacgLXy0ARsNsWA27wRp6ZOuRrUf+qmN9y/LVB2A0zIbVsBuswRui4TT0yNEjR48cPXL0yNEjR48cPXL0yNEjR498euTTI58e+fTIp0f+Kmp9W/DVFCAaTkNe+GoLMBpmw2rYDT1y9sjZI2ePnHfk+fs1jIbZsBp2gzV4QzSchh559MijRx498uiRR488euTRI48eefTIo0eePfLskWePPHvk2SPPHnn2yLNHnj3y7JFXj7x65NUjrx559cirR1498uqRV4+8euTdI+8eeffIu0fePfLukXePvHvk3SPvHtl65KrB88FsWA27wRq8IRpOQ16oGizokb1H9h75q8E9PrAGb/gbefsHpyEvfDUIGA2zYTXsBmvwhh45euTokc9NpHlGw2xYDbvBGrwhGk7DzbqZPXL2yNkjfzW484PdYA3eEA2nIQHrq0HAaJgNq2E3WIM3/I1svw9OQ174ahAwGmbDatgN1uANPfLokUeP/NWgxQejYTasht1gDd4QDachL6weefXIq0dePfLqkVePvHrk1SOvHnn1yLtH3j3y7pF3j7x75N0j7x5598i7R949svXI1iNbj2w9svXI1iNbj2w9svXI1iN7j+w9svfI3iN7j+w9svfI3iN7j+w9cvTI0SNHjxw9cvTI0SNHjxw9cvTI0SOfHvn0yKdHPj3y6ZFPj3x65NMj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ySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSbUJjjEKjejEIB5iPqwsuTiIk7iIdEu6Jd0qS8YsPMS8OKuLsHEQJ3ERN9GITgziIdJt0G3QbdBt0G3QbdBt0G3QbdBt0G3SbdJt0m3SbdJt0m3SbdJt0m3SbdFt0W3RbdFt0W3RbdFt0W3RbdFt023TbdNt023TbdNt023TbdNt083oZnQzuhndjG5Gt8qSsQuDeIjlFh9WllwcxElcxE00ohODeIh0C7oF3YJuQbegW9At6BZ0C7oF3Q7dDt0O3Q7dDt0O3Q7dDt0O3Q7dkm5Jt6Rb0i3plnRLuiXdkm753MbvRxzESVzETTSiE4N4iHQbdBt0G3QbdBt0G3QbdBt0G3QbdJt0m3SbdJt0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0W3TbdNt023TbdNt023TbdNt023TbdDO6Gd2MbkY3o5vRzehmdDO6MUsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySxazZDFLFrNkMUsWs2QxSxazZDFLFrNkMUsWs2QxSxazZDFLFrNkMUsWs2QxSxazZDFLFrNk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",
      "is_unconstrained": true,
      "name": "get_config"
    },
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "14067204867181196045": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "9921926525851912681": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 128
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "utility"
      ],
      "debug_symbols": "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bdCNWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWVI9gmOMwklcxE00ohODmMTzsLLkIt0O3Q7dKkvGLDSiE4OYxHNxViNh4yBO4iJuohGdGMQk0m3QbdBt0G3QbdBt0G3QbdBt0G3QbdJt0m3SbdJt0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0W3TbdNt023TbdNt023TbdNt023TzehmdDO6VZaMXbiJRiy3KAxiEs/DypKLgziJi7iJRqSb083p5nQLugXdgm5Bt6Bb0C3oFnQLugXdkm5Jt6Rb0i3plnRLuiXdkm5Jt0O3Q7dDt0O3Q7dDt0O3Q7dDt/Pcxu9HHMRJXMRNNKITg5hEug26DboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptum26Gd2MbkY3o5vRzejGLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLFLFnMksUsWcySxSxZzJLFLFnMksUsWcySxSxZzJLFLFnM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",
      "is_unconstrained": true,
      "name": "get_current_value"
    },
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "14067204867181196045": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "9921926525851912681": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "utility"
      ],
      "debug_symbols": "TJ3LjjQ9b6Tv5V/PonQgRfpWZjGYo2HAsIE5rHzz08kQFbHx94T/txVKSYzKymJX/8c//sf//G//75//y7/82//69//zj3/6z//xj//2v//lX//1X/75v/zrv//3//p//+Xf/+3v//sf//h9/2flP/5p/ad/7D/hf/8Z//in+PvPxH8W/rPxH8N/HP85+E/gP1n/sR/+g1EMoxhGMYxiGMUwimEUwyiGURyjOEZxjOIYxTGKYxTHKI5RHKM4RjkY5WCUg1EORjkY5WCUg1EORjkY5WCUwCiBUQKjBEYJjBIYJTBKYJTAKIFREqMkRkmMkhglMUpilMQoiVESoyRGGb/f/e+4/533v+v+d9//2v2v3/+e+9+4/73jjTveuOONO96444073rjjjTveuOONv/HG74O8MH8No+FvzLE+WA27wRr+xh3+wd/As34qGvLC+jWMhtnwN/LcH+wGa/CGb2T7IBrywnf0x3c53+EHzIa/kdf4YDdYgzechmjIC185AEbDbOiRrUe2HvkrjfUty1ccgGjIC1+JAEbDbFgNu8EaemTvkb1H9h759MinRz498umRT498euTTI58e+fTIp0eOHjl65K+c1rcFX0EBdoM1eMNpiIa88JUXYDT0yNkjZ4+cPXL2yNkjZ4+cd+T5+zWMhtmwGnaDNXjDaYiGHnn0yKNHHj3y6JFHjzx65NEjjx559MijR5498uyRZ488e+TZI88eefbIs0eePfLskVePvHrk1SOvHnn1yKtHXj3y6pFXj7x65N0j7x5598i7R9498u6Rd4+8e+SqwfggL1QNFoyG2bAadoM1eMNp6JGtR/Ye+avBPT6YDavhb+TtH1iDN5yGaMgLXw0CRsNsWA098umRT498biLNEw03kWb8GkbDbFgNu8EavKFHjh45euSvBnd+MBpmw2rYDdbgDachGhKwfr+G0TAbVsPfyPb7wBq84TREQ174ahAwGmbDauiRR488euSvBu18EA154atBwGiYDathN1iDN/TIs0eePfLqkVePvHrk1SOvHnn1yKtHXj3y6pFXj7x75N0j7x5598i7R9498u6Rd4+8e+TdI1uPbD2y9cjWI1uPbD2y9cjWI1uPbD2y98jeI3uP7D2y98jeI3uP7D2y98jeI58e+fTIp0c+PfLpkU+PfHrk0yOfHvn0yNEjR48cPXL0yNEjR48c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INJt0G3QbdBt0I1ZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkllSP4BijcBIXcRON6MRDDGI+rCy5SLekW9KtsmTMQiM68RCDmBdnNRI2DuIkLuImGtGJhxhEug26DboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptum26Gd2Mbka3ypKxCzfRiOV2Cg8xiPmwsuTiIE7iIm6iEenmdHO6Od0O3Q7dDt0O3Q7dDt0O3Q7dDt0O3YJuQbegW9At6BZ0C7oF3YJuQbekW9It6ZZ0S7ol3ZJuSbekWz638fsRB3ESF3ETjejEQwwi3QbdBt0G3QbdBt0G3QbdBt0G3QbdJt0m3SbdJt0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0W3TbdNt023TbdNt023TbdNt023TbdjG5GN6Ob0c3oZnRjlgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslilixmyWKWLGbJYpYsZslilixmyWKWLGbJYpYsZslilixm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wSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksQd/r9zd9F/pegZUlFz+3vQoncRE30YhOPMQg5sPKkot0c7ohS07hJhrRiYcYxHyILAEO4iTS7dDt0O3Q7dDt0O3QLegWdAu6Bd2CbkG3oFvQLegWdEu6Jd2Sbkm3pFvSLemWdEu65XND3+vFQZzERdxEIzrxEINIt0G3QbdBt0G3QbdBt8oSm4WHGMTPzb4jh77Xi4NYZ3IXLuImGtGJhxjEfFhZcnEQ6bbotui26Lbotui26Lbotum26bbptum26bbptum26bbptulmdDO6Gd2MbkY3o5vRzehmdDO6Od2cbk43p5vTzenmdHO6Od2cboduh26Hboduh26Hboduh26HboduQbegW9At6BZ0C7oF3YJuQbegW9It6ZZ0S7ol3ZJuSbekW9Itnxv6Xi8O4iQu4iYa0YmHGES6DboNug26IUtG4SYa0YmHGMR8iPsS4CBOIt0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0W3TbdNt023TbdNt023TbdNt023TbdjG5GN6Ob0c3oZnQzuhndjG5GN6eb083p5nRzujndnG5ON6eb0+3Q7dDt0O3Q7dDt0O3Q7dDt0O3QLegWdAu6Bd2CbkG3oFvQLegWdEu6Jd2Sbkm3pFvSLemWdEu65XND3+vFQZzERfzcLAqN6MTPzfFvg5gPK0t8FQ7iJC7iJhrRiYcYxHw46TbpNuk26TbpNuk26TbpNuk26bbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptulmdDO6Gd2MbkY3o5vRzehmdDO6Od2cbk43p5vTzenmdHO6Od2cboduh26Hboduh26Hboduh26HboduQbegW9At6BZ0C7oF3YJuQbegW9It6ZZ0S7ol3ZJuSbekW9Itnxv6Xi8O4iQu4iYa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",
      "is_unconstrained": true,
      "name": "get_owner"
    },
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14067204867181196045": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "9921926525851912681": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [
          {
            "name": "chain_id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 16
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "array",
            "length": 32,
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            }
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "utility"
      ],
      "debug_symbols": "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/Tz289jPYz+P8zzO8zjP4zyP8zzO8zjP4zyP8zxOe1Rz1CV7NB7NR+uRP4pH+Wg/eh72POx52POw52HPw56HPQ97HvY87HmM5zGex3ge43mM5zGex3ge43mM5zGex3we83nM5zGfx3we83nM5zGfx3we83ms57Gex3oe63ms57Gex3oe63ms57Gehz8Pfx7+PPx5+PPw5+HPw5+HPw9/HvE84nnE84jn8ercX537q3N/de6vzv3Vub8691fn/urcX537q3N/de6vzv3Vub8691fn/urcX537q3N/de6vzv3Vub8691fn/urcX537q3N/dV6NV+lF89F65I/iUT7aj86lasC6ZI/Go/loPfJH8Sgf7UfPw56HPQ97HvY87HnY87DnUb8ch1/R2o9OU/2KHMgejUfz0Xrkj+LR8/jqfI+i0/TV+SV7NB7NR+uRP4pH+eh5zOexnsd6Hl+d71U0H61H/ige5aP96DTVb5OC7NHz8Ofhz8Ofhz8Pfx7+PPx5xPOI5xHPI55HPI94HvE84nnE84jnkc8jn0c+j3we+TzyeeTzqF9PrTOsfkMVdJrq91SjyB6NR5/HLlqP/NGfx6mz6avzS/vRn8fJj746v2SP/jxOjfLV+aX1yL/f4vwVBjGJm3gaq9Or0YiDOImL6MQgJrHcrPA8tB+x3FbhIE7iIjoxiEncxPNw/Ih0G3QbdBvl5oVODGISN/E8rN+evWjEQZxEuk26TbpNuk26Tbotui26Lbotui26Lbotui26LbotujndnG5ON6eb083p5nRzujndnG5Bt6Bb0C3oFnQLugXdgm5Bt6Bb0i3plnRLuiXdkm5Jt6Rb0i3ptum26bbptum26bbptum26bbptul26Hboduh26Hboduh26Hboduh2ntv+/YhGHMRJXEQnBjGJm0g3o5vRzehmdDO6Gd2MbkY3o5vRbdBt0A1ZsgsncRGdGMQkbuJ5iCwBGpFuk26TbpNuk26TbpNuk26Lbotui26Lbotui26Lbotui26Lbk43p5vTzenmdHO6Od2cbk43p1vQLegWdAu6Bd2CbkG3oFvQLeiWdEu6Jd2Sbkm3pFvSLemWdEu6bbptum26bbptum26bbptum26bboduh26Hboduh26Hboduh26Hbqd53Z+P6IRB3ESF9GJQUziJtLN6GZ0M7oZ3YxuRjejm9HN6GZ0G3QbdGOWHGbJYZYcZslhlhxmyWGWHGbJYZYcZslhlhxmyWGWHGbJYZYcZslhlhxmyWGWHGbJYZYcZslhlhxmyWGWHGbJYZYcZslhlhxmyWGWHGbJYZYcZslhlhxmyWGWHGbJYZYcZslhlhxmyWGWHGbJYZYcZslhlhxmyWGWHGbJYZYcZslhlhxmyWGWHGbJYZYcZslhlhxmyWGWHGbJYZYcZslhlhxmyWGWVK+g2XfxX92CjUYcxElcRCcGMYmb2G6jGggbjVhuo3ASF9GJQUziJp6HlSUXjUg3o5vRzehmdDO6Gd2MboNug26DboNug26DboNug26DboNuk26TbpNuk26TbpNuk26TbpNuk26Lbotui26Lbotui26Lbotui26Lbk43p5vTzenmdHO6Od2cbk43p1vQrbLEVuEgTmK5ZaETg5jETTwPK0suGnEQJ5FuSbekW9It6ZZ023TbdNt023TbdNt023TbdNt023Q7dDt0O3Q7dDt0O3Q7dDt0O3Q7z81+P6IRB3ESF9GJQUziJtLN6GZ0M7oZ3YxuRjejm9HN6GZ0G3QbdBt0G3QbdBt0G3QbdBt0G3SbdJt0m3SbdJt0m3SbdJt0m3SbdFt0W3RbdFt0W3RbdFt0W3RbdFt0c7o53ZxuTjenm9PN6eZ0c7o53YJuQbegW9CNWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMkuqE9O+N5SOasVsNOIgTuIiOjGISdxEui26LbpVlgwrnMRFdGIQk7iJ52FlyUUj0s3p5nRzujndnG5ON6db0C3oFnQLugXdgm5Bt6Bb0C3olnRLuiXdkm5Jt6Rb0i3plnRLum26bbptum26bbptum26bbptum26Hboduh26Hboduh26Hboduh26nedWDZ2NRhzESVxEJwYxiZtIN6Ob0c3oZnQzuhndjG6VJWMWbuJ5WFkyotCIgziJi+jEICZxE8/DSbdJt0m3SbdJt0m3SbdJt0m3SbdFt0W3RbdFt0W3RbdFt0W3RbdFN6eb083p5nRzujndnG5ON6eb0y3oFnQLugXdgm5Bt6Bb0C3oFnRLuiXdkm5Jt6Rb0i3plnRLuiXdNt023TbdNt023TbdNt023TbdNt0O3Q7dDt0O3Q7dDt0O3Q7dDt3Oc/Pfj2jEQZzERXRiEJO4iXQzuhndjG5GN6Ob0c3oZnQzuhndmCXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXoex2ncBGdGMQkbuJ5iCwBGnEQ6TboNuhWWfL93Y+BvteLm3ge4q/GAI04iJO4iE6k26TbpNuk26Lbotui26LboltlyRyFQUziJp6HlSUXjTiIk7iIdHO6Od2cbk63oFvQLegWdAu6Bd2CbkG3oFvQLemWdEu6Jd2Sbkm3pFvSLemWdNt023TbdNt023TbdNt023TbdNt0O3Q7dDt0O3Q7dDt0O3Q7dDt0O88Nfa8XjTiIk7iITgxiEjeRbkY3o5vRzehmdDO6Gd2MbkY3o9ug26DboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbpNuk26Tbotui26LbotuiG7NkM0s2s2QzSzazZDNLNrNkM0s2s2QzSzazZDNLNrNkM0s2s2QzSzazZDNLNrNkM0s2s2QzSzazZDNLNrNkM0s2s2QzSzazZDNLNrNkM0s2s2QzSzazZDNLNrNkM0s2s2QzSzazZDNLNrNkM0s2s2QzSzazZDNLNrNkM0s2s2QzSzazZDNLNrPkMEsOs+QwSw6z5DBLDrPkMEsOs+QwSw6z5DBLDrPkMEsOs+QwSw6z5DBLDrPkMEsOs+QwSw6z5DBL0Pc6V+EiOjGISdzE8xBZAjTiINJt0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0c3p5nRzujndnG5ON6eb083p5nQLugXdgm5Bt6Bb0C3oFnQLugXdkm5Jt6Rb0i3plnRLuiXdkm5Jt023TbdNt003ZEkUOjGI5bYLN/E8RJYAjTiIk7iITgwi3Q7dTrtN9L1eNOIgTuIiOjGISdxEuhndjG5GN6Ob0c3oZnQzuhndjG6DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui25ON6eb083p5nRzujndnG5ON6db0C3oFnQLugXdgm5Bt6Bb0C3olnRLuiXdkm5Jt6Rb0i3plnRLum26bbptum26bbptum26bbptum26Hboduh26Hboduh26Hboduh26MUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGswR9r9/f9p3oe724iZ/bmh9Wllw04iBO4iI6MYhJ3ES6Jd2QJVk4iJO4iE4MYhI38TxElgDptum26bbptum26bbptum26Xboduh26Hboduh26Hboduh26HaeG/peLxpxECdxEZ0YxCRuIt2MbkY3o5vRzehmdDO6Gd2Mbka3QbdBt0G3QbfKEh+FTgzi5+azcBPPw8qStQqNOIiTuIhODGISN/E8XHRbdFt0W3RbdFt0W3RbdFt0W3RzujndnG5ON6eb083p5nRzujndgm5Bt6Bb0C3oFnQLugXdgm5Bt6Rb0i3plnRLuiXdkm5Jt6Rb0m3TbdNt023TbdNt023TbdNt023T7dDt0O3Q7dDt0O3Q7dDt0O3Q7Tw39L1eNOIgTuIiOjGISdxEuhndjG5GN6Ob0c3oZnQzuhndjG6DbsgSKxzESVxEJwYxiZt4HuK6BEi3SbdJt0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0U3p5vTzenmdHO6Od2cbk43p5vTLegWdAu6Bd2CbkG3oFvQLegWdEu6Jd2Sbkm3pFvSLemWdEu6Jd023TbdNt023TbdNt023TbdNt023Q7dDt0O3Q7dDt0O3Q7dDt0O3c5zQ9/rRSMO4iQuohODmMRNpJvRzehWWeK7cBIX8XML/NsgJvFzi1l4HlaWXDTiIE7iIjoxiEmk26DbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotuim9PN6eZ0c7o53ZxuTjenm9PN6RZ0C7oF3YJuQbegW9At6BZ0C7ol3ZJuSbekW9It6ZZ0S7ol3ZJum26bbptum26bbptum26bbptum26Hboduh26Hboduh26Hboduh27nuaHv9aIRB3ESF9GJQUziJtLN6GZ0M7oZ3YxuRjejm9GNWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLEHf6/fXQib6Xi8O4iQuohODmMRNPA8n3SbdJt0m3SpLMgqdGMRyG4WbeB4iS4BGHMRJXEQnBpFui26Lbk43p5vTzenmdHO6Od2cbk43p1vQLegWdAu6Bd2CbkG3oFvQLeiWdEu6Jd2Sbkm3pFvSLemWdEu6bbptum26bbptum26bbptum26bboduh26Hboduh26Hboduh26Hbqd54a+14tGHMRJXEQnBjGJm0g3o5vRzehmdDO6Gd2MbkY3o5vRbdBt0G3QbdBt0G3QbdBt0G3QbdBt0m3SbdJt0m3SbdJt0o1Zspklm1mymSWbWbKZJZtZspklm1mymSWbWbKZJZtZspklm1mymSWbWbKZJZtZspklm1mCvtc9C8/DypKLn9v3QveJvteLk/i57VPoxCB+budXuInnYWXJRSMO4iQuohODSLekW9Jt062y5EThIE7in9vfc9RCJwYxP6x1+LKk8Tz8smR8r0qc1ffaOIjzw9qLL0sanfi5WU3ny5LGTTyN1ffaaMRBnMRFdGIQk7iJdDO6Gd2MbkY3o5vRzehmdDO6Gd0G3QbdBt0G3QbdBt0G3QbdBt0G3SbdJt0m3SbdJt0m3SbdJt0m3SbdFt0W3RbdFt0W3RbdFt0W3RbdFt2cbk43p5vTzenmdHO6Od2cbk63oFvQLegWdAu6Bd2CbkG3oFvQLemWdEu6Jd2Sbkm3pFvSLemWdNt023TbdNt023TbdNt023TbdNt0O3Q7dDt0O3Q7dDt0Y5YcZslhlpyXJev3smT9Xpas38uS9XtZsn4vS9bvZcn6vSxZv5cl6/eyZP1+dDO6Gd2MbkY3o5vRzehmdDO6Gd0G3QbdBt0G3QbdBt0G3QbdBt0G3SbdJt0m3SbdJt0m3SbdJt0m3SbdFt0W3RbdFt0W3RbdFt0W3RbdFt2cbk43p1tlyffWmFV9r41O/NzGLkziJn5u329Urup7bTTi5zbLrbLk4iJ+bt8T/lV9r41J/Ny+53qr+l4vVpZc/NyWFw7iJH5uXgdUWXIxiJ+bY7BNPA8rS+JXaMRB/Nyi5ltZctGJn1vUmlWWXNzEzy1rvpUlF434uWWtWWXJxUX83LJWvbLkYhI38TRW32ujEQdxEhfRiUFM4ibSzehmdDO6Gd2MbkY3o5vRzehmdBt0G3QbdBt0G3QbdBt0qyz5rqtX9b02noeVJd9fUFrV99o4iJO4iE4MYhI38TxcdFt0W3RbdKss+f4C06q+18Ygfm5nFG7ieVhZcuowK0suDuIkLqITg5jETTwPg25Bty9L5q/m+2VJ4yL6hzXfL0sak7g/3IXn4ZcljfZhbXcO4mwc9Q17F33D2lf91RI5v28Eq1oiGwdxEhfRiUFM4iaeh5Nuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui25ON6eb083p5nRzujndnG5ON6db0C3oFnQLugXdgm5Bt6Bb0C3olnRLuiXd6jQzL1xEJwYxiZtYbnWi7h/RiIP4uY06f7+PrMbP7XvT3KqWyMYkbuJ5+H1kNRrxcxurcBIXsdyiMIhJLLea7zmN1RLZaMRBnMTP7XtFwqqWyMYgJvFz+34TblVL5MXvI6vxc1u/wkGcxM9t1WDfR1ZjEOsovkuCan6cdQlTbY5zRWGNUFOvfLgYxCRu4nlY+VAXNtXm2DiIk/i51TVOtTk2fm5ek6x8uLiJ52Hlw0Ujfm5fh8WqNsfGRXTi5/bd8VrV5tj4uUVNsvIBWPlw0YjlVsaVDxcX0YlBTOLnljWdygdg5cNFI35uWZOsfLi4iOXmhUHMh1XzF2uEOoqq7rqUqybFv1vDhd/MNv7teVjVffGb2a4fq+q+OImL6MQgJnETz8Oq7ot0O3Q7dDt0q+quS6NqUmxM4iaexmpSbDTiIE7iIjrxuVUP4vz+MuWqHsTGQZzERXRiEJO4iefhoFtdCHw3WVf1IDZO4iJ+g9WFWDUTzrrkqmbCxklcRCcG8ZtkXTBVM2HjeVgVe9GIgziJi1huXhjEJG7ieVgVe7HconAQJ3ERyyILk7iJZVFLXWV60YiDyN0M7mZwN4O7GdzN5G4mdzO5m8ndTO5mcjc3d3NzNzd3c3M3N3dzczc3d3NzNzd383A3D3fzcDcPd/NwNw9383A3D3fzcDfP281q+mt8u1lNf42TuIh/Fuv7s6mrOv1WXa5Xp1/jefhVbOP8cBbWCKswiZt4Ho4f0Yjjw5rOmMRFdGIQk7iJ5+Est1FoxEGcxHLLQid+bvVNorr3GjfxPPyKd1n92Fe8jYM4iYvoxM9t1HS+4m3cxPPwK95VV2LVvdc4iJO4iE4MYhLLrabj52H8iEYcxEmscXdhjfCVXnXkNRpxEL8RZq3kV7GNTgxiEjfxPPxKes06U/ckLqITa9xa1J3ETTwPv5JuNOIgTuIi5quWs4mnsbrsGmtc4OoSqX66xiDWfIGbeB5WxU4vfPVW/XSNk0g3oxurO1jdweoOVnewuoPVHYMWda1c+Vvtco2beB5W8daNyOBnbPAzNvgZW41xq+5JVmNc4ybWknznZOAztn5sGXEQ6bbotui2gpjETTwPnW5Oi7roxWE6l8S5JM4lqSrEOgRHCE4yOMnwd8TBJQkuSey3DsFJJieZXJKkW9It6ZZckuSSJJckuSRJN37yBgryFDoxiEncxG9J6ktbNbA1GnEQJ3ERP7dVS/J9xjYmcRPL7VuzamBrNGK5ncJJXMTPza3wc/t+KW5VA9uqb3XVwNZ4HlbxXjTiINa4WRjEJG7ieVhlCqwiq/vk1UfW+FnUN8DqGFv1Va46xhqTuInnYX0WXqz/b823PrMuGnEQJ3ERnRjEJG4i3YJuQbegW9At6FbVUt8Aq1vrr1AKa4Ta7vrMujiJNUJtd31mXQxiEjfxPKzPrKwNqGKor7TVgfW3iIVJ3MRvhPqaWh1YjUYcxElcxHKrI65iuFhudfBVDBdPY/Va/R1AYY2wC4NYI4zCGuEUnod1gl804jdufcOurqrGRfzcthUGMYl0M7oNug261bXnxdl7UV1VjU4MYhLfblb/FLawOqWwhdUphc2qTqnGJO7ei+qUurh+RCMO4iSu3rfqlGqMt1kriW83qyfqbmHVG/bNuZtVb9jCqjcslHN9nesbXN+qN2xWcDeDu1n1hs0K7mZwN4NuQbegW9ItuZtVDLuWpIrhohFrOrU6VQwXF9GJQUziJp7GaiFqLLdTOIiTuIhODOLndmbhJp6HVTgXP7f64lgtRI2T+LnV98JqIWoMYrlF4Saeh1U4F8stC2vcXejEICbxb1yvL5nVLOT1HbKahby+fVWzUOMgTuL6sI74K6fGICax3OrYVlnUfFdZ1HS+GvL60lYdQn9fZgsX0YlBTOImnoff55tbrfpXWY3lVsY+iYvoxCAm8XOrr33VIXTxq7dGI35u1SJQHUKNi/i51T3+6hBqTGK51XZHudUc8kc04iBO4iJ+49b3rOoFajwPd/1/y3ifh1/xen1vqZ6dxkGcxEV04ndsddlcPTte17/Vs9N4Lnr17DQacRBr3F1YI5zCb4Q1PvwKstGI3wjf2z68+nAaF9GJQUzi5/Zdsnr14Vwc5bYKjTiINa4X1ghReB5W6X3PRbx6a2qhvHprGidxEWvcWpIqvYtJ3HcDvHprLq4fkW6Lbotui25VhcCqllWrXtVyMYhVLWVR1XLxPKxquWjEQfzm4LUkVS0XnRjEJG7ieVh14bWFVRcXF9GJQUziJp6H38OFRiPSbdNt023TbdNt023TbdPt0O3Q7dDt0O3Q7dDt0O3Q7dDtPLfqdmk04iBO4iI6MYhJ3ES6Gd2MbkY3o5vRzehmdDO6Gd2MboNug26DboNug26DboNug26DboNuk26TbpNuk26TbpNuk26TbpNuk26Lbotui26Lbotui26Lbotui26Lbk43p5vTzenmdHO6Od2cbk43p1vQLegWdAu6Bd2CbkG3oFvQLeiWdEu6MUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglhiyZhUncDxEgv0IjDuIkLqITg5jETXyhO34/ohEHcRIX0YlBTOIm0s3oZnQzuhndjG5GN6Ob0c3oZnQbdBt0G3QbdBt0G3QbdBt0G3QbdJt0m3SbdJt0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0W3RzujndnG5ON6eb083p5nRzujndgm5Bt6AbLzsGLzsGLzsGLzsGLzsGLzsGLztG0i3plnRLuiXdkm5Jt6Rb0i3ptum26bbptum26bbptum26bbptunGLBnMksEsGcySwSwZzJKBLInCJG5iuX2X+RNZAjRiuWXhJC6iE4OYxM/tu7Xq1cd0sbLkohEHcRIX0YlBTCLdjG6DbpUl301fr1e7NU7iIjoxiOU2CzfxPKws+W6tevU8NQ7iJNa4XlgjfNtSfUyNRqwRalsqHy4uYs33FAYxiZv4uWUdUOXDRSMO4jdu1vJVzX+3x7x6ky5WzV+sc6csUPPASVxEJwYxieVWq1M1D6yav1jzrZWsmr84iYvoxCAmcRPPw6r5i3TbdKuaz9qhqvms075q/mIQk7iJ52HV/EUjDuIk0q1qftdmVc1fTGK51VlSNV9Y3U2Nn9sehYM4iZ/b9+uQXt1NjUFM4iaeh1XzF404iJNIt6r578mgV/tTYxLLbRaeh1XzF8utDrNq/uIkllsdZtX8xSD+ucV3g82rP6rxPPxqPr4eDK+uqcZB/HMLq/l+1w+NTowPy+27fmjcxM/ta5f16ppqNOLnNmrNvnxoXMTP7WtZ8Oqaakzi5zZqSb58uPjlQ+PnNms6Xz40TuLnVjeL6hVsjUH83OqeTTVQNZ6HX5ZE3cmpBqrGQfzcvNy+LGl04udWl+PVVtW4iZ9bhXm1VTUa8XOrz4tqq2pcxM+tgrRewdaYxM8tMdh5+GVJ4+dWqVHdWI2TuIhODGISN/E8PD8i3Q7dDt2+LIldq/NlSWMQP7ddO/RlSeNprG6sqIKsbqzGQfzcqpyqG6vRiZ/bd4feqzGrcRP/3PK7qe7VmNVoxPFhuX1Z0riI/mEWBjGJ+8NdeB6OH/Fzs3L7sqRxEj83q8G+LGkM4udmGGwTz8MvS3LUon5Z0jiIn9uoJfmypNGJu2O7GrN818HX9cPFSVxEJwYxiZv4zfe7Z+7VmNVoxEGcxEV0YhC/1fn6o7wasxrPwyi3Wskw4iDWJ+QsXEQnfm6zNutLgpx1QF8SNBpxECdxEZ0YxCRuIt023TbdNt023TbdNt023TbdNt023Q7dDt0O3Q7dDt0O3Q7dDt0O3c5zq9auRiMO4iQuohODmMRNpJvRzehmdDO6Gd2MbkY3o5vRzeg26DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26Tbptui26Lbotui26Lbotui26LbotujmdHO6Od2cbk43p5vTzenmdHO6Bd2CbkG3oFvQLegWdAu6Bd2YJcEsCWZJMEuCWRLMkmCWBLMkkCWjcBPPQ2QJ0IiDOImL6MRy88IkbmK5fekZyBKgEQdxEhfRiUFM4iY+t/z9iEYstyycxEX83Op6svrPGpP4udX1ZCI16seQD1HoxBrhFCZxE8/DyoeLRvzmW9ee9VK0xkV04ufmNcnKh4ub+Ll5Tb3y4aIRy62mXvlwcRGdWG518JUP9b27mtmyLoXr9WeNgziJ37jfr0l5vf4s6x5Ivf4s675Gvf4s6w5Gvf6s8TysJLhYbjWdSoKLk7iI5VbzrfKv6+rqjMu6V1GdcVkf+dUZl3WlW51xjYM4iYvoxCCWW82hyh+ImgfyjEqeqckzNXmmouaBQUziJp6Hm26bbptum26bblXzWWtWNX8xiZ9b3TKoNruLVfMXjTiIk7iITgxiEul2nlu96CzrW0e96KxxECdxEZ1YblmYxE08D+v64fvFGq+WvMZB/NzqVkS15GV9m6mWvMbPrb7CVEte4+dW9x+qJe9i5cNFIw7iJC6iE4OYRLoNuk26TbpNuk26TbpNuk26TbpNuk26Lbotui26Lbotui26Lbotui26Lbo53ZxuTjenm9PN6eZ0c7o53ZxuQbegW9At6FYB8rWiebX6NQYxifUpAjwPK0suGnEQJ3ERnRjEOooviuvlZfjUq5eX5dfi5vXyskYnBjGJm3geVhKcKqfD9T084sMjrpq/eBqrmzDrZlx1EzYO4iS+3axuwsYgJnET325WN2GjvTlUzV+cxEX0NwfUPDCJdGPNH9b8Yc0f1vxhzR/W/Bnv3DkjiEncxPPmMLmSkyvJmj+s+cOaP6z5w5o/rPnDmj+T+4aaB3IlF1dycd9Q80CuJGv+sOYPa/6w5g9r/rDmD2v+sOaPc9+cK+lcSedKOlcSNf99Fh7UPPDPbdc9pmo3bJzERfQPaw5fzTcmcRPPw6/mG404iOVWk8xFrOuHWsm6UqgqrHbDXXem69VjjUYcRO7Q5g5t7tDmub55riMJgDz7DnfocIcOd+hwhw7PPqbGOTwfDs+H0+dDVMPi/m6qRzUsNk5irU4W1l7swiAmcRPPQ/sRjTiIk9h3k+KHuwfATTwPcfcAaMRBnMRFdCLdBt0G3QbdJt0m3SbdJt0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0W3ZxuTjenm9PN6eZ0c7o53ZxuTregW9At6BZ0C7oF3YJuQbegW9At6ZZ0S7ol3ZJuSbekW9It6ZZ023TbdNt023TbdNt023TbdNt023Q7dDt0O3Q7dDt0O3Q7dDt0O3Q7z81+P6IRB3ESF9GJQUziJtLN6GZ0M7oZ3YxuRjdmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYsySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcyS6rXc39vjonotL44f0YiDOImL6MQgJpFug26TbpNuk26TbpNuk26TbpNu76lnoNcSWL1UF404iJP4uX3tGFG9lo1B/NwM/3YTz8MvS/b3u1FRvZaNgziJi+jEICZxE8/DoFvQLegWdAu6Bd2CbkG3oFvQLelW31C+X/aK6rXc3ytco3otGxfRiUFM4iaeh/W95aIR6ba7WyjQa3nRid0tFOi1vLiJdZbUuVN9VxeNOIiTuIhODGISN/G5odfyYq1ZFtbq4P/7rc7XtBPVP9l4HtY3lIvfCN+vwkX1RO7vl96ieiIbN/E8rJq/aMRvfb8mgqieyMZFdGIQk7iJ52HV/PcivqieyMZBnMRyi0In1vquwiRu4nmImgeWW61vVezXxxTV/XixKvai3ZaxQPfjxUlcRCcGMYmbeB7Gj0i3oFvQLegWdAu6Bd2CbkG3pFvSLemWdEu6Jd2Sbkm3pFvSrSq2PmaqU7JxECdxEZ34nVETgyXx27dZp9FXsRfPj2jEQZzERXRiEJNIt1Nu39lXnZKN3U0Y6JS8OImLWON+Z191P+5Z/1+z2/UX1f3YOInrdv1FdT82BrE6BH+Fm3gejh/RiIM4iYvoxCDSbdCt6vhr6ovqaNyrpl4Vu2qS9Sl9MYn7YdXmd5M6qktxf3emo7oUG4OYxE08D6uOVy11ffJeHMRJXEQnBjGJ5TYLz8P65L1oxHKrPa5P3oufm9ea1SfvxSAmcRPPw/rkvWjEQZxEumX3ewa6FC8msfs9A12KwP0jfudO5S+6FC9O4iI6MYhJ3MTzsLoUL9Lt0K0q1uvkqtr0Wuqqze+BeFTnYaMRB7FGiMIaIQvPw6rNi0YcxEms9T2FTgxiEjfxPKxP3otGLDcvnMRFdOLn9j1+j+ombNy3DTeqLXAH0IlBrB+bhZt4bp9u1LvdGo04iDVurW8VZNTMVjfyRrUFNhqxG3mj2gIbF/E7jaqcqi2wMYmbeB6ibRhoxEGcxEWkW9CtSi/qhKki+369IqoBcEcdfBXZRScG8Rvha0OIaurbWateH4AXF9GJQUzit75Zy1cfgMD6ALxoxEGcxEV0YrnVuVMfgBc38TRWU9/+fukiqqmvsdyycBIX0YlBTOImnodVkBeNSDfrJvCopr5GJ3YTeFRTX+MmfudOxUo19TUacRAncRGdGMQkbiLdJt3qovf7/YuoRr29a6mrNjf+wSaeh19tNn4j7Dqg+rCsi95qvmvcxPOwPiwvGvFb3+91uVHNd42L6MQgJnETz8P6sKxv2NV81ziIk1hutcf1YXmx3L7Kqoa6Xd/fqqGucRIX0YlBTOImnod1IXuRbvUBWElbDXWNi1i/FIB/G8Qk1vlQR1EfgMD6ALxoxEGcxEV0YhCTSLfz3Kp1bn8dKlFNcvt76hnVJLe/HoGoJrnGTTwPqwq/x4xRTXK7rnSrSa4xiZt4HtYH4MW/Iz7fc9OoJrnGSVxEJwYxiZtYbt/Zl/XV86IRB7HcrHARy20WBjGJm3g+rNX5arPRiIM4iYvoxCAmcRPpVp+xVf7VOtc4iPP+gkZU61yjE+tXPOp8qM/Yi5t4HtZn7EUjDuIkLqIT6RZ0y1qz2ous1alTI2t16qRNJwYxH34Ve+q7UzW+nfqWVI1vjU4MYhI38VvfurlVjW+NRhzESVxEJwax3Or0PJt4GqvxrbHcvHAQa9yv9Kpt7dTNompbaxzESVxEJwYxiZt4Hg661SdkAAdxEusXl+oo6hPyYhArEXfhJp6H9Ql50YiDOImL6MQg0m3SrWqz7p9VK9qp+2fVinbqRli1ojUmcT/0GqG2xWuEKHRiEJO4iefhV1mnvnJVe1njIE7iIjoxiEkst1V4Hla9XTRiudUWVhVe/Ny+RvSo9rLGICbxc6t7NtV0drFq86IRB3ESF9GJQUwi3erTtD6l6yV4jUasX0OrPT6TuIjfuVO3jattrTGJm3gaD37pDWjEQZzERXRiEGvNvr2oVrRTt5uqFe3ULaRqRWt0YhBrhG/fqr3srBq3Pk0vLqITg5jEb33rRk21l138arPRiIM4iYvoxJrvLkziJp6H9Wla38mqvayxxvVCJwYxiZt4HnqNW+tbdXyxjqJW0iex3Go6Vd0Xy62Wuqr74udWN1+qkexiVXdd8VcjWePnVl9WqpGs8XOrbyjVSNb4udXNjGokayy3OqCqbmBVd93tqEayxnKrA6rqvlhudUBV3RfLrQ6oqvvi51ZXutVedrGquy5vq72s8XOrOw3VXtZYnww1nfcrrXHer7TGeb/SGuf9Smuc9yutUe1lp+5VVHtZ4yCWG/7tIjoxiEncxHMx6y15jUYcxElcxBo3P6xP6e8TJ6uR7HyfkFmNZI2TuIhOjDeuJXETOd/B+Q7Od3C+g/MdnO9wIt0G3armcUBV3TigyflOzreq+2ISN5HzXZzv4nwX57s438X5Ls53cb6L811cnUU3p1tVNw6o6hgH5Jyvc75Vx8Cq44vczeB8g/MNzjc43+B8g/MNzjc43+R8k6uTdEu6VcXigFCbdUCb892c7+bZt3n2be7m5m7WJ+931ZbV2tVYn4VeeB7ikxdoxG/c70ZYVrvW+e5oJdq1fjVYtVgUol3r4tf08H0RS7RrXZzE+jQ9hU4MYhI38Ty0H9GIgziJdDO6VRV+v2CU1YJ1vntiWS1Y54urrBasxkV0Yo3wbVa1VZ2scevT9OIkLqITg/it767VqXq7eB5WvV004iBO4iKWWxYGMYmbWG7fHldbVWO5rcJBnMRFdGIQk7iJ52HV5kW6VVvVr2ZWbVUXF/FrmPnVBlRb1cUk1plam1VtVcBqq7poxEGcxEV0YhCTSLekW1XsrpOranPX1Ks2d02yavPiJp6H9Ql5qrLqs/DUxtZn4cUkbuJprPanxm99v0e+We1PjZO4iE4MYhI3seb7ncrV/tRoxEEst1W4iOW2C4NYbvixP7e/mPkVfwtshdVLedGIgziJi+jEICZxE+k26fYV/d98RvEQnsJL2IVDOIW38CF/1f8YvrXsawhP4SXswkF2/PssXsIuHMIpvIUxz9qu+Anj39fexRY+5Kx/b3VqpgkP4dq/sqpyvOjE2r/yrHK8uIm1f185VmdSoxEHcRIX0YlBTOIm0u3Q7dRqW+3gqVW1Ou1PrdJ3iyir4ejxeVwtR48xThZjnF2cwlv4kO0nbMK12t8dlayOpMdL2IVDOIW38CEP+EaxCQ/hKQxfK3Zh+K5i+OLfb+FDnj9hEx7CU3gJu3AIi281QGM61QANrAboi98pNmrfqgH64iR+p9h3TyrrBXCNQUziJp6HeIEL0IiDOIl0c7qhlkedUYFVOsW1SrN2MKbwEnbhGud7hp0TtTxrfNTy5Sm8hF04hGu1Z61VbuFD3j9hEx7CU3gJw7fOrh3CKbyF4Vu7f37Cfl83lniH28UkbiLG+CpvobIvm/AQnsJL2IVDOIW3sPia+Jr4mvia+Jr4mvia+Jr4mvia+CIJvhteuZAE3/2qXEiCy1N4CbtwCKfwFj5kJMFl8cVL3rxwEhfx+8ZQV3J4ydvFJH7fT75f50u85A1YHRgXjTiIk7iITgxiEum26OZYPSvGKs1irBL+TQpv4UNGxa86LlT2qp2KEE7hLXzI+FS/jNU+xUN4Ci9hFw7hFN7C8K3NQhJcNuEhXL5eu48kuFy+3328XEiCyym8hQ8ZSXDZhIfwFF7C4lt3r60Oq+5eX9zEar365otXtl00YjUJ7sJJXEQnBjGJm3ge1vfti0akm9ENmfDd+0xH7X/3NtNR+98dzXTU/uUhPIUxTo2JWv7uZaajli+b8BCewku4Vvu7z5mOT/XLKbyFDxnX4JdNeAjDN4uXsAuHMHxH8RaGb60hqvvyFK7xo9YWVX8Zx1VriKq/vIUxfs0B1+yXTXgIT+El7MIhnMJbWHxTfFN8U3xTfFN8U3xTfFN8U3xTfLf4bvHd4ouUqDtxjpS47MIhnMKbjF9NqO26AYD/9xJ2YTnl8cWgbuXFj6d8/Ex4CNf4dZMvcJlw2YVr/LqjF7hMuD+7hVlqYeJr4mvia1N4CbtwCIuviRdioG4xBmLg8hLGsaziEE7hLVzj1629QGxcNuEhDN8oxvhZnMJbGON/+xWIh8smPISn8BJ2YfjWmiAeLm/hQ/afsAkP4SlcY9bdwUDp132+QOlfHsJTeAm7cM25btsFSv/yFj5klP5lEx7CUxi+tUco/cshnMJb+JBR+tg7lP7lITyFsS+zeHPd8OEPxof/ZRPGsdS5dGStUOOXUxjjly++IhQnav8yxt/F3KP8TeEl7MIhnMJb+JDtJ2zC4mvihbqui8fE5f/lQ8YlwGWMeYpxAVjHOFw4hGv8ug+aqPHLh4warzudeS/z62dR45ensPhO8Z3iO1N4C/OCN9dPWHyXeKGu6ytgoq4vb2Ecy3fOJ+r6sgkP4Rq/HtYkLgcuu3AIw7fWH7V/am6o/ctDGOPX+Ybav+zCIZzCW/iQUft1SzdR+5eH8BRewi4cwkmuurZ60FRNZH9ca1u13BzCKbyFD7lq3OrLVvWSPR7CU3gJu3AIpzB8a4/OeVxNZY9NeAhP4fX2bqP2L4dwCmNfvnyr9rO7btV/9ngJuzCOJYq5VtVu9tiEMX75jim8hDH+Lg752RTewuI7xXeK7xzCU3gJu7D4TvFCXU/wEJ7CSxhjnmLcDql1Ro2DUeOXa871aKHehPZ4Ctec67b4dpefDeEUFl8X3xDfMOEhPIWXsPiGeFVdW93grs60x0MYx7KKl7ALh3Dte934rga1x4e8f8LwrXMStV83yjdq/3IIY/w631D7lw8ZtX/ZhIfwFIZv7Ttq/3IIp/AWPo8Pav+yCdeYdUO83pD2x6P4kOuzu9mEh/AUrjnXPeuDGr8cwim8hQ8ZtX/ZhOHrxVN4CbtwCKfwfnt3UPtg1P5lE8a+zOLgus0U3sKHvHAsUSxrtZawC2P88l0pvIUx/neeVBtb/6zLHrnskYuvi6+Lr4dwCsu54XJuhPiGeKGusW74TL+cwlsYY9Y5eR/X1XHhs/vyEq4516OCgxq/nMI157rVfpIPrs7+CZuw+G7x3eKLa/jLIZzCW1h8j3ihrivbD+r6cgjjWOqcR11fPs37h7q+XPv+PYrYP3ymX57CSxi+UYzxs/iQUfuXMf4uHsJTeAm7cAinMHxP8SGj9i+b8BCewkvYhWvM72b2/uGz+2s93T/U8uUl7MIhnMI151VrjhoHo8Yvm/AQnsJL2IXhW3uE2r+8hQ8ZtX/ZhAf3DrV/eQm7MPZlfoy6xrqFCQ/hKYxjqXMpZK1iCx8yPt9X+eLz/fIQxvh1nqTsUcoepexRim+Kb4ovPt8vm7CcG1vOjS2+W7yqo+b7mrir263RiIOI8ep8fI02+/cabfbvNdrsH4r7e4qwDcV92YRrsl/v8DY02wAX0YlBTOImnof2IxpxEOlmtEARf08dtqGIwSjiy5j/Kh7CU3gJ1yZ/9/q34QP8cgpvYfh+J6Ch0L974ttQ6JeXMMbfxSGcwlv4kFHol00Yvqd4Ci9hFw7hFN7Ch4wijlpzfFBHrS0K9/IWPmQU9GUTrjlHrTkK+vISduEQTuEtfMgo9Kg9QqFfHsJTeAm7cHDvUOiXt/Aho7i/50bbUMRYN1y8Xw7hFMax1Ll0ZK1wkX55CmP88sWH+eUQxvh1nhzZo8M9Gr+fsAkP4Sm8hF04hFOYvsPEq6r6u1+80UJ30YlBxHjf+VjNctVxuscw4iDWZL+nBXuguC+7cE32e4qwq2Guf3QTz8NJx0nHScfXJbvH65Ld43XJ7vG6ZHe1yjXSAkWctTAo4stLGPNfxSGcwlu4Nvl7KrAHPq0vm/AQhm8UY/wsTuEtjPFrg1Dol014CE/hJezC8K01QaFf3sKHjEK/bMJDeArXmLv2HZ/Ku9YWhXt5CE/hJezCNedda46CvryFDxnfxi+b8BCewvCtPUKhXw7hFN7C5zFa8LB3E4V+eQhPYezLLN5v3dCOdxkFfdmEcSxRzLVC211zCmP88sWHORgf5pcx/i7mHqHtrnkJi+8Q3yG++DC/fMjzJ2zC4jvFCx/g35OAPfEBXldhEx/gYHyAXzbhITyFl7Df313YEz3wwCRu4nlYPfAXjTiI9bsWtbwo+bq2mij5y1v4kFHyp4ZByV8ewlN4CbtwCNcvpdQO45dSgOdh/ohGHMRJXEQn7nfEKUeDMLhswkNYjmbL0Ww5mi1HgzC4vIUP+fCADg/o8IAOD+jwgA4P6ASRy3fe8i387lgW8mjQk9e8hF2YR4OevOYtzKNBT16zCQ/hd0DLFtGJQUwiD8je+bDGj2jE9Y54yNGMEE7hLSxHM+VophzNlKOZU3gJuzAPaPKAJg9o8oAWD2jxgNYgcvkWl6+SoG4+VH9d43lYSXARhzKL+xdy98IvlwKDiHVaxVv4kG8SeLG9H61fTLs4iXQMOgYdKwMubuJ5WBlwkW5JC1y1f48IN3rumrcw5l+Ld2sfbMJDGPtcC3hrH+zCIfz5jl/Npz7wx6/Or/rAbx7Cs7jOl/rAb3bhEE7hLXweV3/dH89iEx7CU3gJu3AIJ9kwphfjZ6PYhUM4hbfwIQ/MeReb8BCewkvYhUM4heF7ig95/oRNeAhP4fX2Dh15zSGcwjjfvkxCt91dtzWFl7AL15jf47ONrrq7Vv4TNuEa38q3Luqbl3CNb3WeuOyRyx657JGLb4hviG8M4Sks50bIuRHiG+KFl0LUoeOlEMBJXEQcR52P9dE+MMR5WL+FerEm+z2X22iVa57CWKQavH7b7f5oEJNIx03HQ8f6TL84iJO4iHQ7zwJ9c8PAJjyEMf9dvIRdOIRrk79ncRt9c82HbD/h8v3aczf648b3fGmjP645hGv875nMDhT65UNGoV824SE8heE7i104hFN4Cx8yCv2yCWNML8bP1trOQ14/YRMewlMYc641R0FfDuEU3sKHjEK/bMLwrT1CoV9ewi4cwim8uXcodDAK/bIJ43zL4uC6RQpv4UOub+xj1rmUsla5hF24xp/lWx/mzVu4xp91nmzZoy17tGWPtvhu8d3iu0M4heXc2HJuHPE94oV3MdU08S4mYBI3EcfxnY+J1y6NwklcxJpsPYRDY1xzCmORvPi8H8XLm4BGpKPR0eiIlzcBg5jETaTboAWKuB7+oUmuOYQx/128hQ8ZRXy5NrkubdEk1zyFl3D51pUimuFGPUxCM9xlFPrlGr8ewCQK/fIUXsIuHMIpDN/aaBQ6GIV+2YSH8BRewi6MMWvf8alcD8nQDNe8hF04hFMYc641R0GDUdCXTXgIT+El7MLwrT1CoV/ewoeMQr9swoN7h0K/vIRdGOfbF2Zokrvrhiv1y0N4CteY9XwMzXB3rXBFfvk8RjPcqGdoaIZrHsI1fj2/QjNc/6wLh3AKb2HxxYf5ZRMewlNYfE288BLFb6k2XqIINOIg4jhmcdw3Lu7qg2vcxJpsPYRDF1yzCWORvHi+H613DV90Ih0nHScd632mwHqf6UUjDiLdFi1QxPXwDx1xl1HElzH/+vco4stTeAnXJteDN3TENafwFi7f71VIG51vox4mofOteQnX+PUAZqPQL6fwFj5kFPplE4ZvbTQK/fISduEQTuEtfMgo4nogh863UQ/J0PnWvIUPGQV92YQx51pzFPTlJezCIZzCW/g8RufbqAdW6HxrHsJTeAm7cLy9Oyj0y1v4kFHc9TASHXFYN3TENYdwCteY9XwMnW9YK3S+NU/hGr+eoaHzrTmEa/y614zOt/5Z7hE635rFd4rvFF98mF924RBOYfFd4vXeXbyrIa7RiUHEcRS/lxfv815evA9eXgysySZ4CbswFqkWHi8wxv97E8/DoGPQMeiIFxgDF9GJQaRb0AJFXA//0P7WvIQx/zrBUcSXU3gL1ybXgze0vzWb8BAu310nIAq9Hiahza15C9f49QDmoNAvm/AQnsJL2IXhWxuNQr+8hU/zQStcswkP4SmMMf1jfCp/D8kO2tyah/AUXsIujDnv4hTewoeMr96XTXgIT2H4nmIXDuEU3sKHjEL/9u78UOiXh/AUxvmWxZvrhit1MAr6sgnXmN/Ds4M2t7tWuCK/nMI1/ilffJiD8WF+ucb/7ukftLndn3XZI5c9cvF18XXxxYf55UMOOTdCzo0Q3xCvquqsadbf8Lh4Htbf8LiI46jzsd5WnnVI9bbyi0GsyX43+g/625oPGcV9auHrjeX40feXB87v/eWB89t03HTcdHx/eeD88JcHgOch/vIAkG6HFijiUwuDIr68hTH/7wRHy1uzCQ/h2uTv5v4xfFpfduEQ/nzn9wDgVIfbH1uxCQ/hWTyKl7ALh3AKb+FDHvCdxSY8hKfwEnbhEE7yxJhejJ+NYhcO4RTewoe8MOda82XCQ3gKL2EXDuEUhm/t0Tpk/wmb8BCewot75y4cwimM8+0LM7S/3XWLKbyEXbjGtDqXQtYqf8ImXONb+daHefMSrvGtzpOUPUrZo5Q9SvHd4rvFdw/hKSznxpZzY4vvFq/6AJ9W59jBsaziKbyEXTiEU3gLf1nyXfSe6n5rNOIgTuIiOjGIf+PWX8A51enWaEQcTBRP4SXswiGcwlv4kFHwl01YfIf4DvEd4jvEd4jvEN8hvlN8p/jWXzlw4CQuohPhmcXfBnlhfTm/aEQc0C6ewksYB3SKgz+axE2ko9PR6VjX9xcncRGdSDenRX2Mz+8pykFfXPMUrvmPOlmQAJdDOIVrQ74nGAd9cZeRDJdNGL6rGOPXmYsEuJzCGL82CAkARgJcNuEhPIWXMHxrTZAAl1N4Cx/y+Qmb8BDGmLXv9Sk/v6cNB/1vzSY8hKfwEq45VxHjlXXNKbyFDxmf/pdNeAjDdxYvYRcO4RTewuftHXrnmk14CGNfrDjfuqEvrvmQUeiXcSyrWNYKn/6XQxhzLl98+l8+ZHz6fw8CDnrk7s8u2aMle7TEd4nvEl98+l/ewnJuuJwbLr4uXvj7fHW4+Pt8wE08DwPjZfEXF6sOr76cX3QiJruLU3gLY7K18HUpjx+tv0Z0cRDpmHRMOtb1/cUkbuJ5uOm2aYEiXrUwKOLLKVzzX3WCo4jBKOLLJlybvOpExkf95SXswvCtBUeh19zwRrpmE8b4UTyFl7ALh3AKb2H4fhuN7rdmEx7CU3gJu3CQUcTfk42Dt8rN72nDwVvlml04hFN4C9ecvycMBz1uzSY8hKfwEnbhEIbvLN7Ch4xCv2zCQ3hy71Dol104hLEvX5ihye2uGy7hL0/hJYxjWcWyVn7IKOrLmHP54sP88hTGWtV5ErJHIXsUskchviG+Kb74ML88hOXcSDk3UnxTvPABXhcm6Hmb3wOIg5635im8hF04hFP4y5IJPA/xR3OBRhzESVxEJ37j1rUP/gRnIf4E50Uj4lhO8TdEXQNVO1tjEmvxvycpx1HUYBT15Vqo7077wV/nxI/iL2ADF5GORkej4/u72Mff38U+/v4u9vH3d7EP/jrnRVqgwKMOFgV++ZBR4N+vRR00tjUP4SlcG13fZ9DY1hzCKQzf7yTHK+Xm13h70OTWPIUx/i524RBO4S18yPjEvgzf2mgU++UpvIRdOIRTeJNR4HXzDA1ss+4zoYGtOYW38CGjkC/XnLPWHIV8eQovYRcO4RTewvCtPUKxXzbhITyFl7Bz71Dsl1N4k/HhHnV+4kMc64YP8csuHMI4lu9cQt8b1gp9b81DGONn8RJ2YYy/i1N+dgtzj9D31iy+Jr74EL+8hF04hMXXxOuraq9Dr1a3Rox4il04hFN4Cx8yKv9yHUndVsfb4pqncPnumhkq/3IIl+/3iOagS675kOuv3+MAv0BoHMRJXEQnBjGJm3gefvXuFUXVAteIY5nFLhzCKbyFDxkf+ZexhjU+EuHyFIZvncFIisshDN9VvIUP+UsKr1Ctl8s1DuIkLqITg5jETTwPkQO76gU5cHkJ42iqjpADl1MYR1NnHC74wciEehiD98s1D+HyrQctgay47MIhnMJb+DzGe+dmPbDBe+eah/AUXsIu/K1lXe9XF53XpUh10XldpVcXXeMgTuIiOjGI3x7Vd+Dqoms8D7/rgsbPrb4K1h8tbZzERXRiEJO4iechMqIeEaGRrnkJY4VWcQinMHampo2MAOPyv57EoMGueQjDt5YHVw2XXTiEU3gLHzKuGuqJDhrsmofwFF7CLvznuxJ4PvzO4Xof3dpAIw7iJC6iE4OYH9Z5/KVE43mYP+LnlsBBnMRFdGIQk7iJ5+GWM2LLGbHljNhyRmw5I7acEVvOiC1nxJEz4sgZceSMOHJGHDkjjpwRR86II2fEkTPi8IzYP54R+2fCQ3gKL2EXfmdEdd7hjKjGO+xn9d01DuIkLqITg/jOiPozqY3vjKievMZ3RlRPXuMkLqITg5jETXxnxL4ZcYqn8BJ24W9nVj0RrZ68x1v4kL+MWPUBVW15jYM4iYvoxCAmcT+sCFj1MBPtec1TeAm7cAjjcOqE8i18yHUp0QzfOltiCE9h+NbShQuHcPnWAz207a16oIe2vVUP0NC212zCQ3gKL/LGz65iE8bPevEUxs/W2n5hgBuB1bXXmMRNPA+/HGjEyLViVdarHuxUAx5uAVb/XeNprO473FOs5rvGQZzERXQi7E5xCtci17Ma9N1drm8NzTXtuqdevXa4I4VWO6wNWu2aD3n8hGu9604GWvCap/CSf+/CISy+Q3wnxlzFU3gJ15jfL5sctNc1p/AWPuT1E65jqUcdpz7im6fwEi7feqSBl9I1p3D51hURXkq36rIML6VrNuEhPIWXsAuHcArDt04H1DcY9V1n7kF9Xx7CU7h8ccKivi+HcApv4UNGfV82YfjWPqK+L2N/a90SvuAQTuEtfMjIg7oqRhdf8xTGMWaxC4cwvGoN9xYur7pbie6+ZhMuX6/6QlpcXsIuHMIpvIXh+3cefn+p7afCVAwVU8VSgaPeELsD7ROn6/hP3Py4wlQMFVPFUuEqoiP5E6liqzgibvRgosieFkPFVLFUuIpQkSq2iIkVnRBDxVSxVLgKbGhApIqt4ohAMLUwFTWD717vJ6aKpcJV1Ay+e8KfSBVbRc0gsD+IqBamAjNYEJgB9gcxFZgocqpFqEgVW8UR8YXSxBJ+mdS4iE4MYj5ERATOZWREiyPiu4KYWIIvMBoHcRIX0YkYGycMiv+7K/uJ71IQ/+gr/sZF/C4FsU1f5TcmcRNPY7UDNpZfXjFU1OakQSwVrqJmn7W76P1bOSGGim8VDhBjLQhXESpSxVZxeu2qAbDRiIM4iYuYXHKbPy45Ov5WOsRQgfUIiKUCx5AQ300IrOBXro2beB7WjcSLRsTYmBwKLjE5/GUp4Hn4FVvjNwr+bd02vDiJi+jEIJbfvsNtFXXWbywgrgVamIqa/cb5gI/3jVMAn+8tvlXAIeLz/S4fPuBbDBVTBVxwPuBDvkWoSNkm1HCLI2LrDLbOYOsMts5g6wy2zmDrDLbOYOsMts7g6AyOzuDoDI7OANcALfzV19EqOlpFR6sIlwEQeEdeC3xW74AwFUPFV1oOXEQnBjGJm3geViFfNOIg0m3QbdBt0G3QDZ/Ge0McESj7FnWU5wcxVNSS74RYKlxFqEgVW8URgc/pMyFMxVBRMzgGsVS4iprBwRYiNlpsFd+a46C/4Gg04iBO4iJibKwvguDgjEAQHBwdvha0mCqWChzDgQgVqWKrOCK++Jjwr/DwHzauwuOJqWKVGBCuIlRkCSxbhccTpwRWoMLjCVNRd3KAk7iITgxiPjwY+wocA5bt4BiwI8dVhIpUUcdgWIQq/yvQOfiEqRgqvqM4wEV0Yt3LAyZxE89D3DkEGhF+BjFVLBUpYmD2A8JU1J1B4CQuYq2cLYhQkSqwcgFxREx4Y7RpKnAkOKyJI8EqVYr4wJpWivjAkVSKPJEq6tkg8DzEk0hgOeD7EboDfUwIjIMjqSzw4RB1JANHUtfsPjCaYzRM3pcKV/HnExeTuB9WIvjAcVfd+8Rxf3WPa/VqD2ysueIqDe2BPnFIVfMt6pLhCVNRq45LePwl2yeWClcRKlLFVnFEbPhgUTdGw6Ju/DMcDwp4YlGPqRgqpopQgdFqNdH39wRGOxB1cLimR8ue4ysCevaeMBU1gzUgpoqlwsWnrtDf/5IqtoojAuWJ1cEflH1iqJgqZA3Q5teHjVJsoauDgsO5hpY+XxMCx7MgXEWoSBVbxRGxfiqwopj1GiqmCswgIDADHBxKFem3UKoIU3T73XJZKNUrUKotysevWCpcxVdkmHOV6sX9EKXqODdQqrjFU619cTGINVfcpkBnn/sd6YhAqbYwFbVajgVCqbZYKlxFqEgVW8URgVLFHRC09jkyE38f1vE1BC+rc3wNwtvqnlgqXEV8f6EbmMRNPI3VwtdoxEGcxEV0YhCTuIl0M7oZ3YxuRjejm9HN6GZ0M7oZ3QbdBt0G3b56xn2F6ulr3MTz8PtIbTTiIE7iIjqRbpNuk26Tbotui26Lbotui26Lbotui26LbotuTjenm9OtLpQdn4Z4r5yj3tCX57jrhAY8x4csuuL8DoBT/wpcm7ao4rsb8hUFbmxUY1zjIjoxiEncxPPw+8BrNCLdDt3wQYcbRI4POnwDrd64fdGIgziJi+jEICZxE89Do5vRzehmdDO6Gd2Mbka36n914HlY/a8X6xfygIM4iVih+6+xQvhfcN2JL/9ofntiqJgqlgpXESpSxVZxRCydwdIZLJ0BPgZxNwvvi3vCVYSKVLFVHBH4GGxhKoYKnYHrDFxn4DoD1xm4zgBvrSjEWyuARhzESVxEjF2fIHhbnOMWW3XC4dt8dcI1TuLfKOf+WycGMYmbeB7iwxC359Dy5rgjh563J1JFHf89qfGZeQUub1uYiqFiqlgqXEWoSBU6gyMzQAeco1zQAvfEUIEZbIilAjM4EDUDLBXeM+dnQGwVRwQusHF3BX+E9YmaAW6UJC6wcaPk/k1W2OBvMF8O4RTewoeMC2jcScH75vzgsCo5ov9ZqtgqTok6u/DSuSdMxVAxVcAHSzExWp016IAL3DFBC9wTQ8VUsVS4ilCRKrYKzABL7j8VpgIzwGb4VLFUuArMAGvtqWKrqO3BbPAnHC+b8Gd/l+n+CUfwEnbhEE7hOi1wSPjzrWD8+dbLOG6cFTlUTBVLRYrYWEUUyDYVNRruDaFl7omloo7kDhbCKbyFD/n+4WawCQ/hKbyExfeI7xHfI76Hvvv3EzbhITyFl7ALh3AKb2HxNfGtLAnc48KL7J6YKrDWE8JVhIraUzwLr+46iqoZ3KjCX4Z9wlQMFVMFZnAgXEXNAHe68AdiA/ez8BdiA7er8HK8FkihFjUD3MhCP94TU8U3g7seeDH95RBO4S18yEgm3CrDH4cN3CrbyB/cKtvInxZbxRGB/MGtMnTiPTFUTBVLRR0KVuL+wRpw+eP7P9rxYt5/dUTgVTo4MvTq48Dub++AD/n+9g64poubXeike2KqWCpcRahIFZgw1iiPCERNi8EZox/38hLG7+6AQziFYYcTch8R56eiDhi3xvD2vCfqgHFvDe/Pe8JV4HcGwCm8hc9jvEGv2YSH8BRewi4cwim8hcXXxNfE18TXxNfE18TXxNfE18TXxBfJgnuC6P17YqjAak+IpcJV1OmFm3DoAHxiqzgikCy4I4cX8QXuyN1WQQNP4SUM+4QIFaliqzgicEHUwlQMFVPFUqEzWDqDpTPA474f+JDRlHPZhIfwFF7CLoy+QXAKb2EcOHY+fipMxVCBAz8QS4Wr2CIQU7hpiYbAwE1LdAQ+sVS4ihoNdyTR8Re4bYiWvyemiqXCVYSK2hTcakTj3xNHBFKohakYKqaKpQIzwMKfUJEqtgrM4Ft4Qw/gE5jBgRgqpgp85oNdOIRTeAsfMq5rqn3F0OMX/b/USHXzy9Dj98RWcUQgY+qGtqHH74mhYqpYKjCDhAgVqWKrOCKQMS1qBonjwdVLi6liqagZJI4HMdMiVdQMErNGzNRtIkP33xOYQUAMFZgBJoqYaeEqQkWq2CqOCFz3tDAVQ4XOwHUGrjNwnYHrDFxn4DqD0BmEziB0BqEzCJ1B6AxCZxA6g9AZhM4gdQapM0idQeoMUmeQOoPUGaTOIHUGqTPYOoOtM9g6g60z2DoDJFsiFpBsLVLFVvHN4OAMq2BrNuEhPIWXsAuHcD7GSw2j7qMZuhWj7qMZuhWfqMOo7jTDCwyfSBVbxRFRF0xPmAr4DAjZFvQr3kXBGwtbIKJamIralrrnZnhr4RNLhauQEwNdjU9sFXJioN/xCVMxVEyZ242oK1xFqEiZGyKqxRGxdAZLZ7B0BhpRphFlGlGmEWVLTk1bugtLd8F1FxBRd26uu+C6CxpRphFlGlGmEWUaUaYRZRpRphFlN6Iwt9BdCN2F0F0I3QVEVN0gNXRdPoFdqM8G9F0+YSqGCqwBhkZEtXAVoSJVbBVHBCKqBWaAckZEtdAyQyod1DZSqUWq2Cr05MP1Vgvd+qNbf3Trjxbg0QI8uvVHt/7o1h/Z+vH7qTAVQ8VUsVTgSA1iqzgiEFx1m9rQxxnVUmjo43xiqlgqXEWoSBVbxRGBSKvb4Yb3Mj6xVLgK+DhEqtgqjoh71YXDRqS1GCqmiqXCVYSKFIHgckwUwdViqJgqcKQBgStyzBrx1OKIQDwd7DbiqcVQgRXdEEsHcBWhQmfgOgPXGSCeWpiKoWKq0BmEmiJ36jub4dWNT5iKb+isRxOGls0nVgmcypU7T4SKLIGTr3LniSOicid/mFvlzhNDxVSBGWAbt6sIFakCM8BmHfhgs85QMVXABwtyXEWoSBVbxaFAY+cTNYO6K29o7HxiqlgqXEWoSBVbhGHoAYEBJkSoSBVbxRFRF0xP4BAcYqiYKpYKVxEqUsVWgRnUNqLH8wlTMVRMFUuFc4PR4/lEqtgiFnZuQUxZ0bVUuIpQgYOrkw/Nnb2IbiqGCvhgBr5UuAr44Kxy3UbXbXTdxtAZhM4gdAYxVSwVeiKFnkihMwg1zXcH3NAM2ryEv3HH/fchnMJ1WAMLiyi5AlHSog7r/gyipMVUUe44NfCHmi6HcApv4UO+f/sFbMJDeAqL7xHfI75HfI/4Hvqu30/YhIfwFF7CLhzCKbyFsdhVBuhlfcJUYLHxMzZV1DlUT3EMvaxPhIo6h+q5i6GX9YmaQT1sMfSyPlEzqGZlQy/rE1NFHf4Bu3AIp/AWPmSETT3bMXSxZj1RMXSx5sRSIFJabBVHBPJlYpGWqRgqpoqlAjPA3JA8LVLFVnFEIJNa1AwWjgeZ1GKqWCpqBgvHg0xqkSpqBguzRibVnXLD+y6fwAyw6cikFpgBJopMauEqQkWq2CqOiPypMBVDhc4gdQapM0idQeoMUmeQOoOtM9g6g60z2DqDrTPYOoOtM9g6g60z2DqDozM4OoOjMzg6g6MzODqDozM4OoOjMzgyA/wd6SdqBtU1bXjD5hNTxVKBJiJwCKfwFj5k9A9dNuEhPIXrAOuRh+EvS2c9yzD8aekncBgTYqiYKpYKVxEqUgSuh/D1Bq/W7LWbuiiIqBahIlXUtuCLAv6KdAtEVAtTIScGXr75xFLhKkJFqtgq9MRARN2Jup4YrieG64nhugaIqOo9N7yJ8wmsQUJsFUcEIqpFzQAPS/DOziemiqXCVYSKVLFV1AzwnRfv9HxiyNYjlfDoBa/yfMJVhIqUbUzd+tSt37r1W7ceqdRiqtCt11RyTSXXVHJNJddUck0l11RyTSW86TMDhYHsaZEqsLxYN2RPvfbA8BrQJ0zFUDFVLBWuIlSkCFw7VWO54b2fTwwVUwV8EsJVhIpUgc/7CXFE3GunK0zFUDFVLBWuIlRUD0+dYeiMbjbhz6R+n8/QFt28hMuh+uUNTdFPpIpqH4I12ofAFVjNdYB4qIeO6CeminLH0lVcNYdwCm/hQ66kajbhITyFxdfF18XXxdfF18U3xDfEN8Q3xDfEN8Q3xDfEF7mEh554gWgL5FILtCthe2670hVYbWwKQqqFq6iL8fsjKbyFDxl/EeyyCcMBpxOiBo9i0UWdePqKLuoWiJoWpgLnzYaYKpYKVxEqMIMDsVUcivse0Qk24SFcPUEDvIRdOIRTeAsfMnqRLpvwEBZfE1/kER7yoXE68VgOndNPbBVHBPKohakYKqaKpcJV6AxwuYSHLmi4fuKIwIUUHmyg4fqJoQIzcIilwlVsEXidAGzwNoHLU3gJu3AIp/AWxnHUaYpG6ydMxVAxVSwVriJUYCVxmuIyqcURgcukeq+CodX6iaGiziXsEd5kfNmFQziFt3B54+kSuq2fMBXljWchaLd+Yqmoo8dDG/yV8CdSRR09npLgD4W3wNVSC8wApwHiqP+XvwEWTqkvfy4ifQ7WEenTYqiYKpYKV/FNf+M+Ozqtn9gqDgWarTdudaLb+omhYpZwiKXCVWAGAZEqtoojwjCDhMAMDkT54MY2uqufCBWponxw2YHu6o2LAnRXb9xjRnf1xi1idFc/MVUsFZgBJjpCRarYKjADHE+lzMaHFRqqN+6DoqF64xYlGqo3bqGho/qJUJEqtoojoq6LnsAMMLc1VMjJiu7rJ0JFqtgqpCjQfb1x7wzd108MFXXYuFhA9/UTriJUpIqt4oioUHrCVAwVOoPQGQRmgC2JUJEqtoojIn8qMAOsdQ4VU8VSgRlsiFCRKmoGC7OuaNoLZ1VF0xM1A+QO+rufqBngvh46vJ9wFaEiVWwVR8T5qTAVQ4XO4OgMjs7g6AyOzuDoDI7MAJ3eT5iKoWKqWCpcRahIFVuFzsB0BqYzMJ2B6QxMZ2A6A9MZmM7AdAamMxg6g6EzGDqDoTMYOoOhMxg6g6EzGDoDJB+uWND9/YSpGCrwBRi8hF04hFN4Cx8ybmRdNmEcoEMg1q7AYdx/dkQg1lqYiqFiqlgqsFxV32jN7uUKXZTQRUFEtVgqsC0bIlSkiq1CT4zUGaSeGKknRuqJkXpipJ4YiKg7N0RUi61CT4wbUZjbjagrhgqdgUbU0Yg6GlFHI+poRB2NqHP01Dy6C0d34egu3IjC3I7uwtFd0Ig6GlFHImr8JKLGTyJq/CSixk8iavx+PA/G70bUFaEiVfA8GL8bURD2U6EzMJ2B6QwkosZPImr8JKLGTyJq/CSixs+OzG38VJiKoWKqwAwOhKuoGdRt4IHm8Se2iiMCEeWYGyKqxVAxVSwVriJUpArMAIeAK7UrbtcBeL6gGOgQ33WndaBD/IlQkSp0s5dututmu6kYKqaKpUI323WzXTfbdbNdT/jQEz70dAs93UJPN8Rb3b8f6AN/YqvAgmLdEG+OWSPeWgwVU8VS4SpCRarYIvAVcGMXcMO8xVSxVLiKUFE+gZMCIdbiiECI1XOCgX7vJ4aKOtJ6GjDQ8v2EqwgVqWKrOBRoCH/CVAwVU8VS4SpCRarYKnQGpjMwnYHpDExngBCr5wQDr8OtP7b9iVCRKraKIwIh1sJUDBVTxVKhM8D7RzBPvIXr8hauZ5mYPt5KctmE61mmgafwEnbhEE7hLXzIeBfJZRMW3yW+yKx6yjHQGL7rXToDjeG7XgY80Bj+xFAxVdRoiaGRMom1Qcq0MBVDxVSxVNRu1O3kgSbvJ1LFVnFEIH9amIqhAjP4QSwVriJUYAY4U5A/Leq3DrG6eLfuZRMewlMY5hCIkep6HmjPfmKqwG8hg104hFN4C5/HtzH7sgkP4Sm8hF04hFN4C4uvia+Jr4mvia+Jr4mvia+Jr4mvie8Q3yG+Q3yRFPWcYKBr+wlXESpSxVZR52bd1x7o2n6itrpujA90bT8xVSwVriJUpIqt4ojAjakWOgPcmMInIPq5n8DvAoBdOISTjESp29kDHdu77kYPdGxvLAwuaC6HcP3C0w+8hQ8ZKQM3hMzlITyFl7ALh3AKb+FDTvFN8UV+tKiB7kyREnU/e6AluwW+hLUwFVglnI24FjnYI1yLtDgicC3SwlQMFbUoB1uDa5EWriJUpIqt4lCg8foJzGBADBVTxVKBGSREqMAMDsRWcUTgWqSFqRgqpoqlwlWECp3BFy6j3p8xqnG7+QuXx/YxDuwLl8dTeH38A7twCKfwFj7k+RM24SE8hcV3iu9EtUFUNpwfZlrZcOrhxUBr9hNLhavAaBUhaMA+P5wcPlRMFUuFqwgViIgNsVUcEZUST5iKoWKqWCowgwURKlLFVoEZ4EzJn4raGhxBZcS550plxBNHRGXEuadLZcQT394OrPR3MfF4CbswPCDwu6mGCZ8aCQd8pvASrpFwGF82PE7h7+wcKNgvGC5X7/RjEx7CU3gJu3AIp/AWFt+q+VNPngbaoI/d/6V2sjr7B9qgn9gqjoi6QDj1FGmgp/nUU6SBpuYnUsVWcUTUdcATtRvYJ7Q8PzFVLBWuIlSkiq0Cx1O7hWboJ0zFUIEZLIilAjMIiFCRKraKI8J/KkzFUDFVLBU6gy8fxrycwlv4OzsmzoEvGx6b8HdWTpw0XzA8XsIuHMIpvIUPOX/CJiy+Kb6JlcXkkA2oN7Qxn4kzEtnQYqiYKmq0aicZaEk+EycHfnW9hakYKqaKpaJ2484av8DeIlVsFYcCLclPmIqhAjMwiKXCVYQKzCAgtgrMoGq83gr8PbqAcBWhIlVsFUdEfdV4wlQMFVOFzqAuCXDXtVqTH6fwd5otrExdElyuS4Lm7zTDDb16p/DjKbyEXTiEU3gLH/L6CYvvEl8kx8LWIB/6f8H64dCQDy1MxVCB0bCduBbADVx0FbfAtUALUzFUTBXYjQPhKkJFqtgqjghcC7QwFZgBdiuniqXCVdQMcBcdLcZP1Axwqwotxi2QGC1MRc0Ad8TRYvzEUuEqQkWq2CqOCKRMC1OhM6jLkMAm1GVIswt/Zya+cFbj8eMt/J2ZuOdVXcePTXgIT+El7MIhnMJbWHxNfA0r6xBYv4TA+m2IreKIQKa0qNFwLxrNwQd3nANXIS22iiMCVyEtTEXtBu6HoHX4iaXCVYSKVLFVHBG4CqkXLA30Dz8xVEwVmMGCcBXwwVrjugEnAnp/n3AVoSJVbBVHBLKkhakYKnQGdf2Ae8PVBfw4hL/TCSVQXcCPD7muH1C11QL8eAhP4SXswiGcwlv4kLf4bvFFPuC2MLp/D24Lo/v35P1nRwRSoIWpqNFwhxadvAc3WNHJ+8ShQCfvE6ZiqKjdwO1TdPM+4SpCRarYKo4I+6nADCbEUDFVLBWYwYYIFTWDavkdaOx94ohALrSoGeAmIxp7n5gqlgpXESpSxVZxRCBLWugM6pLjbkJdcjQv4e/MxB3wer/y4xT+zkycGvXa5ea65Gg24SE8hZewC4dwCovvEl9chWzsIDIF90vRzntw/xPtvE9sFUcEkgN3ENGce3A/FN25T6SKreKIwLVGi9oN3FtEg+4TU8VS4SpCRarYKjADlAGuNVqYiqECM8CZgixpAR+sNbKkxRGBLGlhKoYK+GB/kDItcKTYBXxvaYEZYKLInxaYQW0WenmfwAwOxFDxnYI/3FyrXl4KL2EQoSJLDIit4pSok696eSmsxIIYKjADh1gqMIOACBWYQUJsFZgBDnv8VGAGOOwxVNQMcLexunwpaga461VdvhR1jXX/1RY+5Pq202zCQxjeWL65VLgKeGNdKn6e2CqOiEqgJ0zFUDFVLBWuQmewdAYOH+yMYzRshmM0rL+7ilCRKrYKPZ7Q4wk9ntDjCT2e0OMJPZ7Q4wk9ntAVDZ1B6gxyymFnyGGnHk/q8eQRsX8qTIUez9bj2Xo8W49n6/FsPZ6tx7P1eI4ez9EVPTqDozM4IYd9Dg+7umv7EKq7lmKomCqWCjme8wsVqWKrkOM59lNhKoaKqWKp0BmYzgC5gsM+SI972EOPZ+jxDFcRKlLFVgGfCqbqlKWoi4jLQ3gKL+HywK3hgyzAnd3qfB14vFpvPH48hb+RcOFQrzt+HMKfA640qk/28SFXODSb8BCewkvYhUNYfF18kQn1CphxUPm4K3xQ+QPTRuW3SBVbRGI0bHJiNOxRuopQkSq2iiMClY+bnweV32KomCqWClcRKlIFZoCTFpV/BSq/hanADHCmoPJbYAZY6+MqQkWq2CrOE/OHtGhhKoaKqWKp+GZQ13iz+lwfp/BnX1dus5pcmysomj/veiw+q8P18RRewi4cwim8hQ+5LkiaxXeIL1KjXg4zf8iGuis8f8iGeiIwf8iGFqZiqMBoB6JGW/DBtcIVyIcWpmKomCpqNxZWEdcKLUJFqtgqjghcRbQwFTieDTFVLBWuAjPAmYLrixaYAVYH1xdX4PpiYQBkycK61fXFwY7U5UXzEnbhEE7hLXzIdV3RbMLim+KLNHKc40ijFqEiVWwVRwTSqIWpGCqmCswAG4Q0ahEqUsVWcUQgPxxnOfKjxVZxKAz50cJUYNYJMUXg+qDuU07D9UGLoaJ+pi7Qp+H6oIWr+Jv1rK9Es5pCH2/h83EdZXWEPjbh8THGrD+u3ryEXTiEU3gLH/L8CZuw+E7xxXeNwAEgJeq+6DSkRN3WnIaUaDFUTBUYDVuDig/sBiq+hakYKqaKpQK7cSBCRarYKo4IVHwLUzFUYAYOsVS4ilBRM0isKK4rWtQMEiuKbxSJn8EVR4uhYqpYKlxFqEgVW8URsXUGu04PVMEewlO4TkuszHbhEK7TEru0t/Ahn5+wCQ/hKbyEXTiExffQdyAf6o7dHLiKqDuZc+A7R10yz4HvHC1SxRaB5Kg3DMyBfKibinMgH1qEilSxVRwRuGNR1+Bz4I5Fi6FiqlgqXEWoSBWYwQ/iiMB1RQtTgRk4xFRRba04ArxfHIy39F42YYyEvUFatFgqXEWoSBVbxRGBhGlhKnQGrjNwnYHrDFxn4DoD1xm4ziB0BqEzCJ0BEmbj/ETCbJxrSJgWoSJVbBVHBBKmhakYKqYKncH9zWNwCKcwfr0HfMj3N/rA1fmIEwC/z3d5Ci9hFw7hFN7Ch4y208vie8QX32Bw0T1wnXHu/1LrV42uc+I6o4WpGCowmkNgtIA4InAF0sJUDBVTRe1G3cmdEwnTIlSkiq3iiEDCtDAVmMGCmCqWCleBGRyIVIGuUIM4Im5f6BWmYqiYKpYKVxEqUoXOANcx2Ctcxlw2YXzVAU/hJYzv/uAQTuEtfMiIo8smPISn8BIWXxdfx8pCBNYPMw2sH87IWCpcRajAaBVK9c7egb+BOOulvRRLhasIFakC3ck/iCNi/1SYiqFiqlgqXAVmgNLZqWKrOCIOZoAz5ZgKzADLe1xFqCgfw8KfrQJHWsuLntMnTAV8AmKqWCpcRahIFVvFEWE/FaZCZ2A6A9MZmM7AdAamMzCdgekMhs5g6AyGzmDoDIbOYOgM0JNed2LnQlN6i63iiED+tDAV9etP2JGbK/d/SBVbhVRMda9+vxMIIRVTPaoUrgJHcCBSxVZRPnU3d1aP6hvATcVQoTNwnYHrDDxUpIqt4ogInUGoKcKl7jRPtKE+kSpq6GoBnuhEbVEXLE+YCvzCwoKYKpYKV4EZYE8ROwOnDmKnhamAD/YUsdNiqXAVoSJVbBWYAZYKsdPCVAwVU8VS4SqCwpE0dRt4OvKk7uJOR560cBWhIlVsFXUIuAnryJMWpmKomCqWClcRKjCDBbFVHBHIkxamYqiY3GBHnrRwFaECO1cRj3bVXlFcqLSYKpYKHJxD6CIiNq5AbLSAD2awhoqpAj4Jodu4dBuXbuPSGSydgesMECgthgo9kVxPJNcZuJriGxAujB3fgFoMFVMFhsapjO85uBb22CrkytoRG7jR7YiNFkNFHQLuYDu+5/QAriJU6AxSZ5A6g/1TYSqGiqlCZ7DVFEmxsIhIihamog4O97bRoPrEUuEq6gxZKAxcurTYKg4F+lTvZyMaUvF7whMdqU+4CvgkRKrYKo4IBEoLUzFUYAYbYqlwFaEiVWwVRwQCpUUNXS3MM3B9gTvggXBocUTg+qKFqRgq6hCqx3IGYqOFqwgVqWKrOCIQKC0wA2wjAqXFVLFUuIpQkbLBCJQWRwQCpQV2bkC4rCguPVqkiq0CB4eTL3QR8SWnxVIBH8wA1yEtUgV8cFaFbmPqNqZuY+oMUmeQOgNch7QIFXoipZ5IqTPYaoqk2Fe4ilCRKjA0TmU85cXNj8BT3hZTBQ7hQLiKUFGHgCchcbYOIPczE3dPWpiKoWKqWCpcRahIFTKDNDVFUuBpRiIpWriKOjg850gkRYut4ohAUuA5R+LSo8VQMVVgBg4Bn4DYKo4IBAoeeiQCpcVQMVUsFa4iVGAGG2KrOCIQKC1MxVAxVSwVNTSegCQuMBILj3BoMVUsFa4iVNQh4HlKIjZaHBH4xtLCVAwVU8VSgRlgGxEoLVLFVnFEIFBamGwwAqXFVLFUYOdwXiMp7oriu0wLUzFU4OBw8m1dRHxjabFVwAczwHVIC1MBH5xVR7fx6DYe3cajMzg6g6MzwHUIxMZ1SAtTMVRMFa4CTwMD4ohAbLQwFRh6Q+CZX0KEilSBQzgQRwRio0UdAp6w3K7UO8CYKpYKncHQGQydAZ7xtJAnr2hMfcJU6AymmiIp8MGCptMnjggkBR4LoOn0iaFiqqgzBI8J0HT6RKhIFZhBncobgYLHJxuB0mKqgA+OB4HSIlSkiq3iiECgtMAMcIYgUFpMFUuFqwgVqWKLQFLgocXGBQZandCB+kSq2CqOCMRGizoEPM5AB+oTU8VS4SpCRarYKjADbCMCpYWpGCqmiqXCZYMRKC1SxaZAo+p9DIR21LuiaEd9wlWEChxcnXxoOr2LiKbTJ4YK+GAGuA5p4SrgkxCpA2wVso1n6AyGzmDoDHAd0mKpcBWhQmcw1PR2mR2IqWKpcBUYekNI/9nR/rOj/WdoUDU8VEKH6hNLxeczfvdnQgdIFVuFzsB1Bq4z8KFiqlgqXIXOwNW0kmLgqVS925ViqqjXTeDBFNpXnwgVqWKXWBBHRF16PGEqMAOcygkfnIkZKlIFfHCO5hGxfypMxVAxVSwVmAHOkB0qUsVWcUScnwpTMVTU0HhkhL5UvCFnoS/1CVMxVEwVS0UdQr3SZKEx9YlUsVUcEfZTYSqGCsxgQSwVriJUpIqt4rwNXmhTfcJUDBXYuQGRb0UX2lafOCLmTwUOziF0EaerCBXwwQzmVnFELPgkhG7j0m1cuo1LZ7B0BktnsFLFVqEnkuuJ5DoDV9P7MBcTRVdJi63iiAgMvSHwxPiKpcJV4BAORKrYKuoQBvYHvSN3gNsPf8VQoTNInUHqDKRTfv2kU379pFN+/aRTft3e1BZqiqQYWEQkRYtUUQc3UDJIiiuQFC1MRZ0hA4WBdw+1WCpcBWaAUxmBUk8RFhpVnzAV8EmIqWKpcBWhIlVsFZhBLRXaXp8wFUPFVLFUuIoQgaSoxx2rmle/9wdCLBWuIlSkiq2iDqEeBi1DbLQwFUPFVLFUuIpQgRksiK3iiECgtDAVQ8WUDUagtHAVoQI7VzmKRtheUR8qpoqlAgfnELqIfkQgNlrABzPAdUiLqQI+OKtCtzF0G0O3MXQGoTNInQGuQ1oMFXoipZ5IqTNINcWlx8RpiUuPuupcdt9JdsVUsVS4ilCRKpBV1/SIOD8VpmKomCqWCleB3wrDLiBQ6gpyDQRKC1MxVNSR1mOihZ7XJ1xFqEgVW8URcX/PLiFMxVAxVSwVriJUpIotAr1qWBB0w/aRIndaLBWuQo906JEOPdKhR4rcaWEqhgo90qlHOvVIpx7p1COdeqTziFi61kvX+v6uLhZk6ZEiXVqkiq1Cj9T1SF2P1PVIXc8q17PK9axyPVLXI3U9UtcjDT3S0CMNPatC1zp0re9v8WJBQo80tH5S6ye1flKPNPVIU4809UhTz6rUsyr1rEo90q1HuvVItx7p1iPdeqRbz6qta711rfEWgrp1tNAH+8RQMVXgSAcE3+uw8I7VJw7FvIk0IUzFUIEVXRBLB3AVoSJVbBU6A7zrpIWpGCqmCp2BqSm+DNXD7oWG2SdMBQ4uIaaKpcJV4HTZEKliqzgibghhbrjEqQejC22xT7iK8qlnhwttsU9sFUcELnFamIqhAjMYEEuFqwgVqWKrOCIQQi0wNE4XxwBYeFzitDgicInTwlQMFTgEbAkucVq4ilCRKraKIwLp0gIzwDYiXVpMFUuFqwgVKRuMdGlxROBKqAXO0YBwWVFc4rRIFVsFhsbJd3QR8c2oxVJRPoEZ4JtRi1RRPoGz6sg23peztjAVQ8VUsVS4ilCRKrYKnYGp6X0r0oJwFaEiVeDg6lReePdRYjS8+6jFVFGHUE+XF/pcnwgVWET44N1HPcARgXcftdAZTJ3B1BngPWotXEWoSBU6g6WmSIq4YqlwFTi4hEgVW8URgaSop8sLLbBPDBVTBWZwIMqnHowuNLo+cUQgUOrZ4cIbWZ8YKqaKpcJVhArMAGcIAqXFEYFAaWEqhoqpYqnA0Dhd8M3o7g/CocVUsVS4ilCBQ8CWIDZaHBG41dLCVAwVU8VSgRlgGxEoLVLFVnEo/L7t+QrjBvt93/MVU8VSgXM0IA5XFC2wT5iKoQJDHwhZRDS6PrFVlM/GDHAd0sJUlE89gF1odO0BxlLhKnQGQ2cwdAa4DrkC1yEtTMVQoTOYanrfuIhZ3zcuQiA2WpgKHNyAqETCJ4bj7c4tUkUdQj1dXmh0bYHYaIFFxP7gvWl3gPuWxiuWCp2B6wxcZ3Df0njFEXHf0niFqdAZhJoiKTYWEUnR4ohAUtQT6YUW2CeGiqmizhBc+6MF9olQkSowA5zKCJSDzUKgtJgqyufgeBAoLUJFqtgqjggESgvMAGcIAqXFVLFUuIpQkSo2BV7JilcwLDS6jnoEvNDo+kSq2CqOCMRGCxxCQgwVU8VS4SpCRarYKjCD2kY0uj5hKoaKqWKpcG5wIFBapIotAhlSD+IXWmB7RfFdpoWrCBUYuk4+NLr2IuIbS4uh4vPB6w0WGl2fcBVRwiB0G5du49JtdJ2B6wxcZ4DrkBZLhZ5IrieS6wxcTe+7obGI993QVywVrgIHh1P5vgEaJ8V9A/QVpmLUz0yIqWKpwCJif/BWxh4gVWwVOoOtM9g6A7yVscVUsVS4Cp3BVtNKivnDIp6hYqrAwd2fcRWhIlXsEiiMuvS4Ai2wT5gKzOBAlA8ejKLR9YlUUT54dlive32iAuUJUzFUTBVLBWYwIEJFqtgqjojxU2EqhgoMvSAwQC08Gl2fMBVDxVSxVOAQEiJUpIqt4ohYPxWmYqjADLCNCJQWriJUpIqt4sgG+0+FqRgqcI4GRMqK4k9LtDgi8MclWmBonHyhi4i/I9EiVJQPHg6j0fWJIwJ/TALPMdDo2gOkbmPqNqbOIHUGqTPIVLFV6Im09UTaOoOtpvJ3J9Z9s2uLreKIODi4KyqR8CAx5e9OrPv+1hZ1COOKVLFVYBFrf+77WzHAfX9ri6FiqlgqXEWoSBVbxRFhOgNTUyQFHnajBfaJVIGDS4gjAknRwlTUGYKny2iBfWKpcBWYwYEoHzwYRaPrE6aifPDsEC9hfWKpcBWhIlVsFZhBnSHoh33CVAwVU8VS4SpCBJICz53R6DrxCBiNrk+4ilCRKrYKHAK2BLHRwlQMFVPFUuEqQgVmgG1EoLQ4IhAoLUzFUDFlgxEoLVxFqMA5WjmKFthe0T1UTBVLBYbGybd1EfcRgdhoUT546IRG1yemivLBAyQ0ur4BdBuPbuPRGRyZAbpenzAVQ8VUsVS4CjE9SAqk/8HTlxZDxVTxf3v7tl0JcuPIf5lnPRSvSfpXFoYhy/JCwEAyxtICC0P/vtWVXWScPlPR2cU86we5Y6SJwyKTQTIzmdSPiwoORdIVo2s9+RN0ACobGk3SRNcBIgLtxKwgI0FBUBFgCyK2IGIL4IWs3J8vZD1BRJAQYAsS/lFVCo0maQrsAAGBfpwoSAgygoLgsBANIGkK7AANQQeggqJxJk10TRpF0ETXAQqC4+9oZEgLsw7QEHQAKignCAgiAm2BWsjzoasnKAgqAkHQEHQAz+eunkCp1Vx0g6F+f010HaAD0A3GCQKCiEA/QYdEZeMEBUFFIAgagg5ABeUE2gIdRhWUEyQEGUFBUBEIDLAKygn6AEUzZQdQG60KyujRoimwAwiChkCp+wHC7MSiia4DZATH36naAt2HnEAQHH/n8KUVTXQ9CeKGICDAFkRsQcQW6D7kBBWBIGgIsAUJ/6huPY6YUdEU2HSEfIqmwA4gCBqCDkAF5QQBwaFVQTteX7E5QUZQEFQEgqAh6AD0Ko7ahN7Eef7O8Fs/Uzvg+VzeEwiChqADUDU5QUAQESQEGQG2oGILKragYgsqtkCwBYItEGyBYAsEW6DPWmxPUBEIgoZAW6CdqG6S7QkSgoxAv1QUVASCQL+0KehAoAklJwgIsAUdW9CxBXosOkFFIAgaAmhB2AIC7cSuoCCoCI6PO6JuRdNkB+gA1IFygmMYjwha0TTZARKCjOBowXFdtAQVnSP4U4KKzhOo6JxA/05REBEkBBlBQVARCAJtgXaVis4T6LHoBAFBRJAQZAQFgVIf5qLJsEm043WvcoKMoCCoCATB8QlNh0T3Kk+ge5UTBAQRQUKQERQERwuaDqPqzgkagg5AdecEAUGEAVbdOUFGUBDoZx8LlqbJnj2qgnKCiCAh0I9T4xPsRN3FnKAD0F1M0xboLuYEEYF2olpVw2FsOIwNh7FhCxq2oGELdBdzgoAADamjIXVsQcc/+nz4++iD+Hz4+wkCgohAP64qqL+cj5KX+Hze+wkaArWDQy01GXaAgEA7sSlIQPB83vsJCgJsQcAWBGxB6ADihiAgiAiwBRH/qCrFEdArmv96AlWKExwfd0Tdiua/DpAQZASHhRwRtKL5rwMIgobgaMFzfFRQng1VQTlBRqB/pyioCARBQ9ABqKCcICDQFqiFqKCcICMoCCoCQdAQdACqFF3NRfchXTtexeEEDUEHoLJxgoDg8Ql50yE5ZGOAjKAgqAgEQUPQARyCkjcdxkNQBogIEoKMoCCoMMAqKCdoCDoA1ZAj2Fg0l/XsUT3vnKAiEAT6cYfxaS7rsxM1l3WAhEA/ISsoCCoC7cSioCEBDKPWiB0AWxCwBQFboPuQExQEFYEgwBZE/KNRx6cq0I8TBQVBRSAIGoIOQF8APsGhVe0JIoKEICMoCCoCQdAAHAklTXd2Ry7rBAlBRqBf2hQcbLrNOzJWBzieAx5ALV47sUQECcHRo0cgpxyFXSdBRSAIsAUFW1CxBTUgiAgSgowAW1Dxjx6CkoN2yCEoA0QEx8cFnTIqKCcoCCqCw1z0nKi5rAN0ACooJ9AW6PxR2dBDpCa2DlAR6N9RO2gNQQfQNwQBQUSQEGgL1EJ6QVARCIKGoE+gKa8DBAQH9eE2LZqxmg//YdGM1RMcsjFAQBARJATHJxzhp6KlXQeoCARBQ9ABxA1BQKAtyAoSgoygIKgIBEGbA6ylXU+g6nKCgEBHLiqo0KP6fvgJGoIOQJ8QPyJbRRNbz07MGUFBoH9HW5AFQUOgf+ewKk1sPQkKDmPBYSzYgoItKNiCUhEIAjSkgoZUsQUV/2hVajXLWhEIgoZAqQ/l01zWAQKCiOChVaLH2COXdYKCoCIQBA1BB3CkmgxwdGLSAVZBOUFBUBEcX5q0Q1RQTtABqKCc4KHK9Wk7h6dkgIQgIygIKgJB0CbQxNZ8hAeLJrYOkBBkBAVBRaDfc8xgzWXNR8yraC5rTvpHVUNOUBAoW1UgCLTfREEHoBpyAv2epiAiSAgygoKgIhAE2oKuoANQDTlBQBARJATHyG1PINBvKignwB5VQTlCfUWrvg4QESQEGcHxpUd4sGjV1wEEQUNwtCBrC1RqThAQaAt0GFVqTpARaAt0TFVqTiAItAVqVSo1WQdYpSbrkFRtgXai6s4JEoLj72jYQTNjB2gIOgDVnaJ9oNuVpynrduUEBUFF0AAcGWpVDylHyusECYEahfbokaE2QEUgCBqCDuBwvQ4QEEQExycUbYHuQ04gCBoC7aqDQAu9DhAQRASPLy16ZjpKwE5QEFQEgqAh6ACOaPIAAcHxd9TLduS/TqBfmhUIgoagA1Cp0dCL5r8OEBEkBBlBQXB8qfrfjvzXCRqCDuCIJg8QEEQECUFGUBDol1YFHYBKzQkCAv1SUZAQZAQFgX7ppkAQNAQdQNkQBAQRQUKgY6pDr4JygoagA1BBOUFAsP8ddWEeGbPnzzx/lvmzzp8yf+5/Vf2ER/7s8+dDWs6fYf6M82eaP/WLuoKj3RqirHrOOUFAcPSPuto1A3aAjKAgqAgEQUPQARz6MkBAgC3o2IKOLejYgo4t6NiCji3o0AJNh80aptWKsANkBAXB0aMaMdVE2QEagg5AD0onCAgigoRAW5AUFAQVgSDQFmQFHYAqzwkCgjiHXgvHDpARFAQVgSBoCMDeNNN2AP07RUFGUBDo39HB0k2OBgw1n3aADkCV5wT6pU1BRJAQZARHCzQuovm0WZ0Tmk87QEPQAegm5wQBQUSQEGQEBQG24KFJGkA6km7Pn338fKiRLlBHuu35M86fD23QbzuU6PmzzJ91/pT5s82fffw8lOj5M8yfcf6cf03mX1NPjEYtNXE26/FIE2fzc3aqA/cECUFGoGw6eHoI0uCMlosdICJICDKCguDo+2fX6m7mBA1Bn0DLxQ4QEEQECYG2QBQUBBWBINAWRAUdgKqNRtK0qmzW1UCryg6QEGQEBUFFIAgagg5A1eYE2IKH2nT9gIfWnD/z/Ln/bd17HUm250+ZP/e/2p9kffx8qMv5M8yfcf5M82eeP8v8WedPmT/nX0vzr6mSqKtX02WzBqw0XTZrMEDLxw7QEHQAqgoaidLc2ayRKM2dHUAQNAQdgO5HTnD0vUaVNHd2gIQgIygIKgJB0BBoC9Sa9ehzgoAgItAWaI/qoegE2gLtUd3BnEAQNAQdgGrKCQKCiODRgqJnJ02xHaAgqAgEQUPQARw6NMBjb6PxqiP3dvxO8DvD7wK/K/zWv3AMrabQFo3zaArtALpHeoKCoCIQBA1BB6BnoxMEBBGB9lhRoD1WFQiChqADiBuCgCAi0C8VBRlBQVARaAuagoagA0gbgoAgIkgItAVdwdECjbJo5dkBBEFD0AEce5cBAoxpxtHOONo5IygIKgJB0BB0AKhFmpA7QEZQEOiXBgWgRR21qD+16AmO71HnuKbdDpARaI8+/52KBIKgIcAWCLZAsAVPLXqChCAjKAiwBYJ/9BCZolEjTcgdICHQj1NTVpE5QUUgCNRc1JRVZJ5AReYEAYG2QG20699RG+0VgSA4/o7GHjTtVkHVtNsBAoKIICHICI4WHC79qtm5AwiChqADCBuCgCAiUOqkQAnyAVRdThAQRAQJQUagn1AVVASCoCHoAFRdThAQRATaAlGQERQEFYEgaAj6GOC6PdXlCQKCiEBttCgQ6FGVjRN0AGVDoB/XFGAnloKgItC/oy0oDUEHcAhKSWpVFYex4jBWHMaKLajYgootqIKgIUBDEjQkwRYI/lFVCtE+EEHQEHQATT9OTbnNE0rdWkZQEByfcIRPqqbUDtAQHJ+QdHzgjFQ3OCPVDc5IdevYgo4t6NgCPSOdQBA0BH0CLVA7QERwjM/h9a6aUjuAINCPqwo6AFWKEwQEh4UccZ6qKbUDZAQFgbagKdC/ow1VQTlBQHD8nSNiUjWldoCMoCCoCARBQ3C04AisVE2pHSAgiAgSgoygIKgAVCmOyEzVlNqSteNVHE5QEFQEgqAh0E/QIVHZOEFAEBEkBBlBQVARaAt0GFVQTtABqKCcICCICBIMsArKCQqCikBt9NBRTak9e1QigoQgI9CPU+MT7ETpAFQ2TqB/R1ug+5ATJATH3ylqVQ2HseEwNhzGhi1o2IKOLdB9yAkiAjSkjobUsQUd/qhWni1HGK1q5dlyhJCqVp4dICHICASAisMRT6qaODuAsukfVQk4oiw16kQ/ghdVK8IOEBFoC0RBRlAQVPg7OtHP/6Yh6AB0op/gOIGdICJICDIC7APdHzw/W/cHT5Cxd7KyacfrrD/CGlXzXssRUqia9zqAIGgIOgCd9ScICI4ePXzEVfNeB8gIjhZUbZvO+qofp7O+6iforK/a10cC29kHRwLbAAHB0W/xCfTvqB3o3K462rpZOEFD0AHoZuEEAUFEoF+qg6UScIKCQFugoyDaAu03FQfR3lFxEO2dI/nkuTE70mMniAgOL0F4/jsVgSDQv/P8dzoAlQDRrlIJOEFEcHyp6GerBJygIDi+VLdFmis7QEPQJ9CKsAMcLTi8q1WzaAdICDKCgqAiEAQNgGrI4XetWt1VT65V8141Tlo173WADkDV5fDVVi31OoC2uihICDICbXVVUBEIgoagA1B1OUFAoC0QBQlBRlAQVASCoEHv6Omj6WDp6eMECUFGoH+nK6gIBEFDcMz6TVugEeETBAQRQUKQERQEFcHRo4c/t2pF2AECgojg+NKuhqR7ihMUBBXBYzaqm7QeFWEn6ACO+koDBAQRQUKQERw92nWwVF1O0AHo1qOrKevW4wQRgX6p2rVuPU6gX6qmrFuPEwgCbYG2TXXnCVR3ThAQRAQJQUagLdBhVN05gSBoCPoEmkU7wNHXOreP8rDhebg7UmqDBmXqUR52AkHQEHQAhx92gIDgGFOVziPZdoKMoCA4WqCHLq0iO0BD0AEcl34GCAgigoQgIzj+ji5gmlKraTZVU2pPoIp0goAgIkgIMgIdU/2jqkgnEAQNwfGlup5qSdkBAoKIICHICAqCikAAHDuhetSCq5p5O0BEkA4QFGQEBUE9QFQgCNoB1CwPrTpB3RBoC9SqakSQEGQEBUFFIAi0BUVBByAbgoAgIkgI1Kq01YJWJWhVglbV0KoaWlVDq2poVQ2tqqFVNbSqhlbV0KoaWlVHq+poVR2tqqNVdbSqjlbV0ar606r++c8//PLr3/70x7//5W9//be///bnP//yL/8z/sF///Iv/+t/fvmvP/7257/+/Zd/+es/fv31D7/8nz/++o/jf/Tf//XHvx7//+9//G3/b3fD+/Nf/2P//zvhf/7l1z8/fv3zD/Pf3q7/1d3N0c5/PTwOs4Nid858IQnXJO2xwhwUe4hlEkj7QhBJK7bHnlUbsTv6LinYh4QjVKkcj+zkyw/J1yRH4upBkaEVUr78++X630+P88vx7+8r2mxADeavSMdDQfoVaV8JL79Crkk00HtwPKJqQBGtFI9n4c8vqQ0+JXzti04oUhl9UWBEg5WghtMw9y3bINh38V/NkthlODKYtDP3+Mo1R2Q98fD1P3tC0iUH68xWRlfsgefLzgzEMvXVAx3TfXs/OVL/ylFWR4R+SJ8MW7v+EMLxyGp9cjxSUgdHzV8pGhvWh2A/h7XESwpiWyLnoDZUrNLNDC2fn9H26X3FEIl1xm3I5u7rmnKTv87SSIyzPRZSbUSX60YkMqQhD/PeO3Oad233xkOux4NZhWyn3jyyMa8oHlPxWvUeO/mn6uVwSSHLY9rWx7Svjmkii8g+Nc/x6Hv8aI5pyvYPCY+gyvNDSrj6kESM86g4r5a1XRJwqeh1GEVIVyOa8rp6M458vBWpu4JYr9fCVOlKFMcUgd6IoX7lYN3RzhHZd9bAUOyGcdRzfW7UpFwaRiLm2XM77bOXDQXjazsyacfuah2zRCIIxgdjIudkfzzVcTkmmW06WxlbrR5g0xlf9otEPo/yAmNg96MbsHw19JzXrSOXVevg31K3OppRS7/+Frb5DDIVEDY7O/jK0Zbto69LIO+Pnuf2seOW6aU/SmALrGxjgRXoj1cOpqQibfRHm9a+O+G+ciQ2Y8ZC/3hk75qDqWkcBrJ7vLdrjsI2sulU08fDb9cclR5ax8z9osjNbiBGKSxtXQpLXzV1PrD97IzHM3WXHVqZkdbUxjKZr42jxvWBrWl5YGl39HFQehTBvG5GceiO6tAdst4ddBM2pv0eHSTNIDb6KAx47sMCLE/fpixrR69p7Aa363YIsdJaRzuqhGsZpKJej1fFtE8fYYNLURfCUuOYtY843jUH28KEbczbADP/Iw6Z26AGu/RvHJUdhccqJ/v/zV6NL34BYqiSxwIlJZZrDqKmac5bULHd2fGVgWlp6HPKwSHylaORremRu6imnrZ7DH1sxEK5/g5mXSmdo/oI91yOakvs7JTHh9R6k0NkHsol3uNo82DftmsOPmdla2PO7q6b65YsH59oOyQMR96+y03XG8LWmaO6lTQc1U22izW/Lx+gqHJMn/2j3PXll/S4rhw9rStHz6vK0cu6cvS6qhyUwaQc3ELbjOZIL9fzrffVmcKs61GdduwYYr4361se0ZT9d78+WoeNbTzSPDuh23sf8heStDrfeDvyCGc8KrRctoN6LGRYeui5XXoswsY2pkfK69NP+kXVX0mEycfwqz0e2QCSYCcpebTkUemIkPR130kI26rFv+nWNkykxnBzbGqaJGxsAjsBbW2MTUAvzjeLpy1pc78eC2lJYdHMPtbtjPb62pJQWdRqaElKTe6RmPuExzmsptZ/1NTSNoOzW7spA2kbQZs9BiTXJCz+FHoc/br/7v1SGVlLQhmn7cRmTmTx0U1mvAJ3Zvv++SsJsVep42tE0Jf7CUmrI1zQKp7JvpGIg6mxGI7R1OgMzrDjDWTysbCDvil3RuYqIQl07RtaIoID/NIjNCRlXMepHI3A2P5Lbk6+NDyHafffXZOk5XA+b0ceO/jd55VIO6iXanpUUkKDbx+QHG9w6shsbSMkzKkrw9nVBQ41r4eJwIJTx+P0Tw7wpib5pB0y2wExkO/toNoqY9Zs6HX71hKWYxCGokX02H+bNTQ8tUdO4fxdy9W8YfEpLTfwFIGSSUsqtZI+rURIx8r6sTWwEJX13BpyXz24hrKtn1wDi1HZjq6cwnR25Ut4Ga6ifR9MFk4WototZCj8BgvWay4KC1Gl6RrZrjMwQqHe/zCSUaJkmLwvi29hmrj1OHYB++90GWGi0qoPlD9PnoHoc/E4ZtX1YxaVkTZSNPdzSbqWERaqqsfLJaeDFVRxCx+QyBjiKoWRMNfVFkZEdYMdZ86vn0P6pE+R38OamZCwMEAdM3j39dZrQWMBq1JG8P9RBnWSfLBZrCNtaN+tkc0ii1gdtV5m6B469qVHhDpZE5havG4Ji1nlGGbyEOYEv+ZtSlwXNRZUMIqaZAdRk+IiakwHUpg71317dK0DLGy1+1jGFks62S+yuJV5O8FCV+btBIs8GbcTLThsJ1pc3k5QCtt2ojrENUMrHuNS18dFPMalrY9LWx4Xuh053q14HgQ6Oel1tt08nkN4LjTQH99ktTvIal+X1e4hq/3/g6zGEXpOX5arV1ntdMM5U18S5nq8TpruIavdQVbjtiyrcXOQ1bgtyyqnMMoqzwEc/q8IzrzXzWbcCt2fQUR/S0JoHCQ+buJhI23dRhyyV2JYTl/hFEYbYYkBxzsezy6Fk97r0SiyMFYaobCUMf70wsCi0DICyI/6t6DOr81girjJPAX0eknCOySMjaZUXCe+dQhzB8hUeGnYkpdrHSyGdRQkfYZcN0LR18+sMW7rZ9bIblBZz6yRxbBsZ1beDqsOMfeXWYdY8MmoQ/QelVWHWPzKqEOUwqRD3FKtaxVzSHywViUPG0nRwUZSWrYRdv3GbCMsfmW0EUphtBEiiG2EJTA9+psgprbuRoipO9gHi12Z7SOHZftgsSuzfbAEMKN9UAqjfbBVt6YZAe/EQjJNtkjzEhC05DuJg7cq5uZhZh7HqrJ+rCoex6qyfqwqDscqpuy1wFYmXe8QWeAqb8MrkrdCNlX0clUe2Rp70Gd+TpcXDmaqfdxJ2neL0Kv9tSFMVtO4w/d4cHlaWX6ZNPR+VR2ZFvvPfulc4WvEyIV7FCq5nr3sipXVKRKrQ8Z1rA4p17Eu51zH6pB0Hety1jWnsC0SVN+PJeS50RRmId3BQljQymwhLGhlthAWtDJaCItZmS2E5qLbLIRS2CyEi9m8h5chs/ebmNFrVtbzLotXGc+74pBBE5vHXrWt71Wbx161re9V2/pelS27mBgc4bLVt2W3eThVm4dTta07VZuHU7WvO1X79rOD+yU0U68Hl4WrypaH/2+DWFOon+wy+7h0GqBPv+0yWbyqjdBbg/Id39SQXpcaGUmlY9TstRUeZtrXzbQ7mGnals2UUxjNlFlHmFeSE7GOxO5bWTUobQ4O1bQtO1TTVj0GV9YHd9mhygsylVGQqdbLElvs3tis/pYxkfhbLSVW1i9t44ZFCgkvJcgHJOgbTpGQsDuKtkp0iUWpbKXoKIWtblliF6SMhcsSMw9j5TJ20raWo7OPipBRsZrHl6qon9hYGPU7UiRXgRK9Y2UsYplomT9rHTT6OccLBk8S+jkso0qGM2X/CQb/krnDSVoc8dSWOyGR9ckb2/LkZRTGyUtzZo2Tl8WnjJOXRafMk9c8KmTyUvPoI3dAOlaHezUPFlsy1pNMrOyfdWzFYWzb+tg6FFRLHkW3EgtPWatupbx8EfCNBo2KRtL6TSFroU8Bkev08JRpNlWeVyPBcfh6FZCL+6yblbqQTVV2kNS8Lql5XVKLg6SWdUktHpKaHSSVm8e4lpG3L9cyXsyjlHXzKHXZPMq6KpfmYB7rhX7ZhSqzeZhH5bZ5zHPytrV72+U8E8vylomNscCUsb54qg52WtfttK7baXWw07pup+Jhp9XBTrl1rHowyjZqoJatXNfATyygVONIkH28k3O97Au99jcSU3BH9rrqsxBMGZfTBO9kl+2lFaQ/ahqFNx5vBs1mtBcTYzGpAFVE4ISbX3uDWGkuw8u2H5jz9baQtmNYB4ZPvrWjOcROU1uOnabmEDs9rsIueh3bcuyUf8qssb0HxiMhYZug43nzp3pAvZsPSeqUoNZvkqRtkOyegWuSTqOn44Sb6z2KPm5S4wXZjyjCBpeOKhleFpPaIwNj5n4p89Y/6dNZKTeVu6Obhq0+KlfdI3H5mjD2MCHkdnPWyNhNRWGzlwamPEhCnR7MKu0mySx1G6Rfi0De4uqsoRS2WUMprLMms8CU1c5on/apRD0SYaUbgDJrIRcsrfayAcjs/tTukz5bIvhayD4TXkhYun8b9SV21YJNdzc/h/ZlRwTvXr3siDI7xrQwMoZbxNtP/ZWEe/1n6Tyo8RbjS63rQBfOOm+Wgq/95UGzTB+e2spYfAPs775xEFutY/dfoUTcPqNfKFgBvzALXSdCwVoxL6VhwYBvFCw81Ya7LnV8AKG+ktACwHOtChVIXu2D3Z9qfRvu2EIoWDn14dERuJL2jYIbWJkGBkP7ahyR5j2Nou5QKba8iEeku9RR9LZgZszriyPMEVvn5boqWKqy2b+kjs6ohXxJsgxJBSv/hEHGqoB1sj9iGIXYsATiRwxTQ0EwPuqHUTdUtus20GV6hG97vLvSj/yiLmV5syDl5i7d9CGcwvQh1rMCo+CuF5mul3bTfWN7Ji7Tx6fyNjNx4ebpN46w7CDMOa46CCmFzUGYc152EOZcVh2EmSbQGx2E9lGReM86ZsniiL6XjzjKyE/a18fLd+tyoZl4o/Bq6bXf5BhFsCgHny2mKHguadnSGYXR0unDU7YXDTMt62d50pC3wjjfynI4Pxf6tu7IFN/dctv1fLOTlJskOUz/MVR9/EZS4/K40G8ZN9b2n3e/Zb6xVvG9pg9J5itHabs7NGlUS64JakV871Vysu/ztNPR0r49okdJrC/xUZIwPEg9tHKTJA5fVseMz89IjCksWei20PiGpiy/ScHbIcO/3+WLvZa7JP0uyXxCXnq5RxL20NwMiW2N0PAhHm7gniGC/KGxzVLUsdS7JMOTtJOQCWhfwS8D4rnR28npd06V34LIdPdvess3s1CSNT+AkxwXIJQEoy/fSdg+YJYGjZLJ16znSuW2nCtFKYw7q76eK5X7cq5U7g65UvZRIWcIbh11KnPLtzjSUS70+TFd7nJsyxxpbq0SLN+fcdT5wEe75qBvUhnPQ5zDdh5q/MWEYWS7i36d46aNpTgWqZTb5diWjdb1r/CcHZl1tCFShoHsy8R1Q+ry4L7hcBjc6blMZOIW+h7VNvI/wtdSLx916qyf0a6trPCUPEtl0kKDUH2+udLl+mxG25FHmlKuiXQHXbNH2kVOmGr9smaXUJb9fiXU5TW7BFldsymFbc0uLAhlXLMLjUGZ1uwSw/qabR8VIaNSlv1+nMPm9yuxLMvYG0s3+exKXLfSuG6lsS/77Aq9HGXxDfFWGOcKuxtlnCusbp/VHcNJjEdKTmI8IXMSo2OIkxgdQ2/6xOYYetMnNsdQoW9PGR1DhYVBbI4h3g6jY+gDkn6XxOYYoiR2x9AbO7H5dD4Q5+utHb0iZXHH8B1VznNXFtJNV0qeb5tk4kopLEhlvd5c6DUp4/Vm/jl9vHJWwhbJ52SPzyk//Dn7zn543EJmnyM/aWklj717Kb2SZrDk/jDOMvBaYnwpBl7q8pPpvBUjgQxPMt9bEdmHjG1mjvjkhJ0ibC3NcoStbPdI+ji277/xJsxHJPO18YC3Aj/p1FGNLHc2tPKjFPupvc8VooXLT+Ek1pERj5GR9ZHhM7fCUaT165kr9EV627OthT48ZZu7tB0zj2qP9FbSDkqSwR+SbpJIm4+441ngG0lzWGbYlSnrMlN4jUbbC6OFXZoKVWYmepVw9Y70OxLTM6WF3powPlNaGn+E0vRMaaFPTxlrYBVazM94G62wmIjtNlphUSbrbbTCivnZbqNxCtNtNG4hxhcoS3d4gZKTGF+gLN3hBcrSHV6gLN3hBcrSl1+gpANsfVqw0ItTxmLtdXMo5ls3hwupdVu+kFo3hwupdVu+kMopbBLQq8e4iMe4tPVxcag9Wdffnarr707xmWt8va7yOy22MtyVF/UzWkhweHyyhuXHJ2sQDwtp6xbS1meuw+t1lQWt7C8C1ehQzL9Gh2L+NS4X86/RoZh/jcvF/DmF0UYcXq+rLGZker2usriV9fW6mmipVNvrdbxDjK/X1USPvbbX6yp7d8r2el1NZX2/W1ldP+t+tyaHav41LVfz5+2w6pDHy1N1/eWp6vHyVF1/eaquvzzFLdW6VrGLVR+sVdnFRpqHjfRlG6G1/aw2wor7GW2EUhhthFV+Nr1eV1nEynxSLQ7OqlocnFW1yLp9NA/76Ov20dftg626xtfrKovzWF+vq+zVKbOZVY9jVfU4VtX1Y1X1OFbV9WNVdThWObxeV4WWf7S9XlfpHSDb63WVhjSMr9dVGrMyvl5XWYk/6+t1fI2wvV5XWZEfs1NEHN6erOLw9mRty29P1ubw9mRty29PcgrbIkH13fh6XWXhKrOFeLw9VT3enqrrb09Vj7en6vrbU3X97ak3YmZ7va725HDeZQ4843m3OzwuVLvHXrWv71W7x161r+9V+/pelS271tfrZHNwqsrm4FSVbdmpKpuDU1W2Zacqp3AYXOPrdcJCVcbX697sMm2v1wkt8Wd6vU7Y3Srb63USPMw0rJtp8DDTsG6mwcFM6WU12+t1wu5WmTUoOjhUJS47VCU6OFQlLjtUOYXtlMo0KMtwhWZJmND4QfpenklzWfJ1+p7wR45s6XvCHo5yyRLfO3PW8BFWDoGSzMF5iOA9kmnwu/e23yRJMmswyvUTZUKdZtbRYadun9EpI85Ua2Cf8yYEMJyApYervMh3JCMbeP8NgbNXElblt+ZZ17FG8jksYTzOWydfkjxe3k4QeiOojxU8buHy+rzk5QvWQqNVMcz6qZIv/TvCQk37LgbqSXdwv73ebuI0Ic/s5n0KyCUNNVlJ45P2+UFMNq/XVxGHt6hk/S0qWX+LShzeopL1t6jE4y0qcXiL6o11mOqrSF6vr/KOY1vmsJXPkEId+HBRo9zrU2OdlzccpjovR4ni628xlQJ5w2G6Q8+/JY8LCWlfca7bkX+6HaZ6M3aOm3POWG9GWKDJWm/mjbHbDMQ8Ye4OjK1WjPCCdbZaMW8aYqoVI8y/a9zKsFCVtVYMbYetVszbjWqFjWq+2qjyd6CMu11GYrvrybepMlyi+89rQ23rtaqlLdeqphTGfVBbr1UtbblWtTSHWtX2UWGaTA8xY80OvV/vHVp3kMK4HqXmJNNptv8M90jCNm/vZXqeYi0paVZoqPcPZXChuPd6+1A28xn2A1ohNOyTUp/9EurNfsnjpb+Yv9SfKfZDs1HhMz8ObVMG2q2ps/sQhsmG69W7bcvn/7Y5FFij7bB2KR3a+VBQRmfVRyYftnn9PWz5th8iFNgVye2ZE+aDf+GrTr/QsAT6EW0GP35+vZLELyWPmNXjUvLVdf7GrkZZbzZTEmPpCXq/ynphnK/iYbre0t3L0cZcgsbiVqWOR8dKhZ3RJ/eaIesl5usX1DiJ8ZG9Fn6axPpSHycxvtTXIr21anmpj1LYXuqjFNaX+lqkZZJML/XxPjW+1EezNMu8ub7b481L52GPas+LPAG9za9lsOjd9Trvrlc4tb62pUX6dkQfHHMNjy8vMb9pxzYjLLD//daOREV+ysD+u19Xf2usRmCYBf72oCsuny8FV+hV/DirrsV8fd2jpbysjPwi/nwnu6BCf0Bx3Hx8tgLehvuIwvIh/H60UeI5iVWd6abVg8Qs8dwvYZT4nJYlnlEYJZ4f1IwSz3xwVonnp3mbxPM7xdZ9EbtiZZw0sThMGkpitfcSf5jEPGkoiXXS0ItWtknDKIyThlGYJw3zwlsnDe1T66Sht3mtSyYNOtkmDb/La1kyOYVpyXxDYfoQntZgnP3ZY+LSO1YeJObZT0mss1+25dkv2/Lsl81h9tM8OuPsp31qnf3Z4Rp+k7o8aWiWh3XSFI8tovQfJjFPGkpinTQ0eGWbNC0uT5oWHSYNc3tZJw3tU/OSSQ+IUBoUfM4vp13m9crzTlFOgg70T+6dWycvvSBlnLzNY/J6uPB6+mES8+SlJNbJy+9ZmSYvozBOXkZhnrzsipR18vb0w5O3j2dKerm+zd9Z4KqEeQ0vbuF68tL7wMbJ27dlVxW/ymudvJTEOO/6Jj9MYp28nMQ4eXtY3q5SCtvkpRTWydvD+naV96l18tKnjvvMTugtXk9fdlMqb8PTnL+8DVA+KcZhnb5h/bRZxWH6ehwUeww/TGKevpTEOn1Z4Mo4fRmFcfoyCvP0ZReurNOX9qnH9E1hdGragzzX05eVBsxt1BbJuxxcT9/mUG65p7i++nrEV5rDkbWn8sMk5ulLSazTN7Xl6csojNOXUZinL80aM05f2qfW6UszttPIgAlJpom8lBfqmT+bNCYvLL212ynKSNfC3NHPKEYyX8FqnJ9QHGXHNXSOJezvUpSbFHUWwb/ZF3X0Rb3bFzI+RO72BVLc7At8rulmX8joC7nbF218SLvbF0hxsy/akIwmd1sxiue2drMVfZvvE27rFHdbMZ6c6URyeCkyY342JzHed+2VPlvd5+JYGAnzpFb5HRF+Lb/BP8aYVE1JrBnrvCXGjPU3lZVM0UdKYYs+9nV3TvfwxXYHX2zn71Y5kJg3lJTEuqEUWd5QMgrjhlLEYUPJCgBaN5S0T40bSl6vynoKY3nZtknDS00ZJw0nsdp7qz9MYp40lMQ6aVpfnjSMwjhpGIV50rBcWeukoX1qPoXRYmLz0jxm274WE+ssUTaFWV494BsNrxzUQuB+JnTrS62LzlJUax4vgZV0j2FcA6yt3WQYBau2yza8Kc0WR2759uXg8IVj3+6wY34ZV5lzzS4k/YrEXK0ubdcVgPeW0LeA55uT+Ez6988p7IQ87t7WANd2vpMwO90NfNxGDGVrLjRYkOiTEs3z9XhWoplXz5veix4ut+9hoxeiTEcAXvnOumoGh1Vz/5r00yzWdfMNi3HhDFtYDv1zDtvSyTmsa+fOsh79f9Ox5tWT3hcdV773Y+uU+9d0V/3uS4nMs1h7vJrDOwW9TjguruLDsa/X6GmpReP2OWxx+SIgL5NoVYIYPeZwbD/NYleC2DyUIIV1JUhhXQlS8FCClB2UIHpcCDQ/ZZuvn7Ldv4cdyNusldIyvKj18tgZfenUPI/T+sWVLa3PY05inoE5/jSLfR7n6DGPc1mfx7msz+NcPOZxbg7zOHtcYAnZY/aU9RsswSMVJ4iH3Zf80yz22VOyx+wpsj57iqzPniIes6duDrOn5B9eBfcT/qhqkUq4XAUpSZ6PF+SvpW1fl1IW2vJhqa0Ml1KTq4ojbzhmzeDao9zkmK6tXq45qMEOF0qPt41+lAvtUtYnDuHgupbG66Uxge/kM5I4n5VKG5MSh8tXnCSENAvs5HazKbtpDzUJrdxlAZ9S6rfbUmbJoAIXQT9lqbO0W+u3v2hKW4rsi9pyBjbnsK4ZzSEHe2f5cbNNQ5VCKnK3U4y6RDmMumQcHMpBt9TGb6Ecxm8xbu2ZxtKTl1Vj+RnQqrHdw1i7i8Z2F43tLhrbXTS2u2hs99DYsK1rLOUwaizlMGts2H7cbK0ayzvFpkucw6ZL1sGh2kbdj0aNpRxGjTW6QQkH91IbNfaNv9yoscHhVhYnMWvsGxajxnIWq8ZyFqvGvmExauybL7JqbHTQ2OigsdFFY+OPm61ZY6ODxkYHjY0OGkuDvUaNpRxGjTUGnZnG0pwAq8by7ASrxiYPY00uGptcNDa5aGxy0djkorHJRWOzg8ZmB43NLhqbf9xszRqbHTQ2O2hsXtZYnopq+hROYfoSa0IsE9jNQ2A3F4EtHpZaXAS2uAhscRHY4iKwxUVgi4vAVgeBrQ4CW10Etv642ZoFtjoIbHUQ2LousLIc7+IUNoGV9WgXvUBl9cTyq1xWgfWIdgWXaFdwiXYFl2hXcIl2BZdoV3CJdgWHaFdwiHYFl2hXaD9utmaBdYh2BYdoV1iPdr25YDrKDpYK2R4fUcwnCPHhgRcKemPX+ODOGxLbg0y8xIdtwaEUtgXHWGiEDSwtAWNdcHgxGuuC08Vh5jIS+4LDWawLDmUxLziUxbzgcBbrgsO/yLjgxG25QhbnMC44lMO84MTtx83WuuDwTrEtOJzDtuBYB4dJW1z+FE5hE9i4/CG8RJ5VYKtH/loMDpZKScwC+4bFKLCcxSqwnMUqsG9YjAL75ousAhsdBDY6CGx0Edj442ZrFtjoILDRQWDXdYmXiLUJbFg+m1gL1dIdbPDYwQYPgU0elppcBDa5CGxyEdjkIrDJRWCTi8BmB4HNDgKbXQQ2/7jZmgU2OwhsdhDYvCywvIC+6VM4helLrGX8mcAWD5908fBJx+JhqcVFYIuLwBYXgS0uAltcBLa4CGx1ENjqILDVRWDrj5utWWCrg8BWB4Gt6wJLnxeyCSylsAms8ZEjKrCbh8BuHgIrHpYqLgIrLgIrLgIrLgIrLgIrLgLbHAS2OQhscxHY9uNmaxbY5iCwzUFg27rAyrKLgFPYBFbWXQTZ4e7Fm+c5rQLrEeSKLkGu6BLkii5BrugS5IouQa7oEuRKDkGu5BDkSi5BrrT9uNlaBTY5BLmSQ5ArrQe53jwabMqq4BSmrAp2uS2FPh7XSVjk8uVdnJDYtYnxsh08SplfZL4sX6fmFLbFxvjKNxvU6JAj/eYleONik+L6AzCcxLzYvGExLjacxbrYcBbrYvOGxbjYvPki62IT2/piE9v6YhMdni0KKf242ZoXm9jWF5vY1hebuJzp1djVHqPAUgqbwFIKY7UKj5S1zSNlLWUPS80uAptdBDa7CGx2EdjsIrDZRWCzg8BmB4HNLgJbftxszQKbHQQ2OwhsXhbYwo43tt38GwrLbr7F5ZIZnMIm83G5YEZpDmFHTmKWeY9LW5TELvPV4yoMZzHLfPW4CvOGxSrz1eMqTJL1qzBJ1q/CUA67zMuPm61Z5tddyW84jDK/7kwulRZy7fMlvccrJIOmfkCy/4t9kkCfvJT5TPzGVG8bNOUeSw6Py4RqJjHI5edEjz6JLn2SXfokL/cJrRvQy3w+ssF2oJZPSKbB4rv130noUxzbeDNi/w2rxkc0tgK5nMJUH/cNhaU8bmZP6VhH5g2JbWSyNI+RoTS2keEUppF5Q2EamUJO5buf+py7+0/sjfYJydg47iT1kiTRV83zKG8dc5g78fr1wfmQ2aNaIfe5tYHa8N9J2FuH4yWrljI45/sHHG28QttqYBysNPw2wgQxgKy+PFixk5BubfWU1QZXL3+nIZXFK8Y5a7eRayP5YGzkcmy4kaSxSnx5y/YjjhJH8f+S0rWNsDT60ue5sdd+l2S8SMJIUqqrxprYcyT9yGdVYW1f7ufmD0hiGuocy12SeUrq+BLdZyShzoeoUeA/+5zxLMP+ZfGahDlsusQ+Nr/1esX6gKTfJelzK9+vF703fZJnn5RKOpbKfJtvQMOh/NvEYYUJ8f34S11MLNwnXcZTkh2FMb0KI2P58q5mJioQq8Oaxa5sWdcsxmFds2J3WLPStr5m8Ri7dc0yj42wsWFW0sfDp2E/tV2TsNe4jGvFu5YMd0vc8JD1rSVsNzBGOG90dOiR3vacPG9JDuNhPngf8HcMtlCD3abBtnv9GnfP4CBpZO/KNNrar/yZptKGqUkgVk+DbKZ+pfrawqj50UJLl/rKVy3jsfENie3YyEMv5mPj3rPt53mMT+dwDtvTOW84TE/n0ACMzBhOu1RYJtLmkyN9osm6CrNkJusqzDisqzC7uWJehdkFMusqzDwD9lXYPDZyz0ZsB0dKYT03Mue++dzISUx7gfX9ItukmU+Nm8NRbXM4qXWHg5qZo9/kMB7TuscSQ3vVehL38Ct4uBX6D3+L1VIdfApMlK2WaufoNzlsllpcNkMeXgm+gzA6JVpZdUrQVxWHre87Gnzg8XVryG5mpThWupRwN/QJRxoZAim1660hK1FnC+ix/kh9RtM36NLv/dGp23k+jVoCzP4QXlnYM/I1jo1MxUKILyz8uGrqETIuNY44S4S8jZf+oAxjd1kx3+KVgblEygj2hIJvmb68/Uk5cpwbupguOfYxoW+Lx1bHaTf2fhUAY8kWMo6Yu3MEMjbiZufYu2GDz4H9VHzZcBcWIDHOXM5hm7mFPq1lstNMHzWeFT8FniN+DUyuWjplMFk6rfVitHTKYbX0wnKnzZZOK9pt4wS0/4aWNDtHGZ0aSyEcdLaIjPym0iBz5ftsYe8KWWcL5TDOFnYNyzhb7D0S0mWPFO7w7vOoPfsj3uZo6xzgPvzGQf2p4+Swmyrs6Vq1cxzVMJ4cVW5y9MGR6nbNwXYx8635/We9yTF3HzHJOge8ef/KIWRs6zaiZnXr4ZKj1vWxpRzGseUctrGthe0KK+wKgwNHuckxIkz7T7nHIdNVJyXe42gjmLJHM272h8jQdYFYyn2OdvNbttM+Ugs37aOloYUt3xzbltvk6HfbMeyj1btjK2lwSL8552TuQdjYUk/uNnzbCdbKDzm2yZHXOWK6q0HzskRsN9uRZn+Uvt4OpoXRQdejg65HB10PDroeHHQ9OOh6cND14KDr5AxTtjYiH1uvt/YfJfWzP/afZB9E96djD5MwMh2/nT7YE0rWCFuh3Zq2MbwJb2l8bwpLVy1yskjp4HxoryT0JNTmSQjDffJKwo79M9FlF8dISFiOStjyvHCFd3G+fxDt2zLMPkGFjN/pW8rS5wj1a2Ohx7s6y32EGumBl00gk3/5TUMGxaMhjTREeDLh8NqHDqP8MpGZqzuH00G0/7xuCOMoaUQPCo7wKwd7u6jUKUq11XscM6nqEd295OBDc6RLPYcm59ssYxbvvzvpk2Unc1t2MrPgQQgN7hT17TLDpbAa4z2MKPcetJN7HHFsN3uM7ZaLOY27ePtv2Dp/NLYCSRBSQieTl0WprG4zymF0m9ECgutus689Eu/3a5ss6ebMk+kZ3X/DtvP76HSHEEB3CAH09LOj86VHZLs9OgIs4ZKl91VFowy2YAL7kt2vO7KAWyDavI9MXw2tcI5dFudqIxUc+Z+xyMhl2n/XcJdlKr2gs+YDW2txbklaInM4sDtboeVx/Nx/93aPZj+AjjyxBJm88fUWuJkkxJskZaS+xgLj8xHJ/gmjWN2G56VvJLIePqckexjmtJQSG0rBJyRpJOGUFOWapIa4rNOcw6bTNSzfmn7TIeM8XHIorEPYJeFtpCTWrXTGwtoyXIwVPK6v5743DRnun4oH8w8/Z5YO2f934TbLCP5WTBr7mKUNlp6I2TPvSx6e6JIZCbuvaFtHOYVpIaWfYg3LcxJrXL6yLFprXD6w8c3byKHPX6bOq8BWdvHKqkiUw6hItJSgUZHYBSOZbjGJOPm2D0jq9P9ITNckNdH0DWPyWE3FYfVjJBUu6hfWEHH5nObxObQey9DpgOHo8E3tWbWONB2OIGrSPmhH7WMT2/Dc9tqO5JCfQ0n6LEXWvwQdXiWak4xu7bL12yRpkGBo65Uk01I5ecg0ZrPu3tgXEraD3caSE3e+axKehz4W894w8+GjPmmzYzu4Tr+R0DdDfFi+XDfElJLXXnnzfsk4kMYIZ8DfYUncUzcddfEuy/SzP2pi3GXJ48rSI2eLsbD12FjE680LM3Uc01MjnVvoJsV2+7iu79nq+p6teOzZisuejZZXs2o1Swe3XvyvNNJlvHJY63L9D85hvHJYa1sPiFYW4jJeOays4Jz5yqF9bMjUo0ZivPdfZf2u37GbuhybOjR6/wmbgtfb9pREZu7vbv33SMz3/mlLSpq3dSojYQO89bnx239j1apPaPR+9HP9y5iz8iFNyJMmk3vhtGdSn92Lhbg+6t48Pcz5y7W9VxIaQDCVZuh072erzEA5jIUZalsveFEb9RQYCzPQllh7lY7uyAHYBzrdnDxhS1B9Ejfmn1l9mL0Sgtyeg2HevwlfNf+TbU4ZOyVMW/9spzT8faBL3yn4Vni0Yz+43t5Q53HbY982BY9tOWPhJ6exFe4N8jS+n3m6g3+rr/u3xOGCFeUw+sh4pw4r2fu3XneqbOvhA8qxT+GxctWN2CtnqSMsszuf+l2WVmaMtdxuSx/XceK2hZssZtcFb8vM+grS2BeF4HBI5yzWQzpnsR7ShQa+jIf0N507Uz9aCLe7xSjYb7rFKNj2IWIsMS57miVuDp5micHB00xL/ZWxKZYa8Bq52ElayKOeVYr5JkkZY9zQgfGNROJ6BhdvyKjs3gqmTn5vyHqlAc5hXE7jcqWBQEsf1lHbp+FLIt+Hty272iiFzdVGY5JWVxslsbraJBUHVxst/mR0tQkPfNlcbcLiXkZXG+UwutokO9w9EFbRzuhqExadMbva7GNDXG3USIyuNmEVA6yuNhY8MLvaKInV1Vaqg6uNtsTqaivi4mqjNHZX2xsaq6utVAdXGyWxutpKWXYKlbzuaqMcRlebsJJQRleb0DCR1dVGW2Lt1ergauPmana1cRqzq+0NjdXVRrc5Nlcb3ymZXG2s+of1nMPCXvZzDot7mc85LI8sxXEROO26DXvY/gGJjGS01PGq2jeStr6ih+WcfU5h20zTL7Fupnl3WDfT4pFrmOixHFL2g1wPL0vxC/NtsT3UgAfq+glJBpVON0l2l9jc9sk1yfG/W5/D7BqgeQ7TclF7aHve4JNwPcjMvSzDzbAvO/1e1+b5OfvukXatuHStS8IhOzXVUV0x1lqJ6TOSMlauWCVfk4hLSULxKEkYKk3MmVXAH9fKyqUHxiUInrhLd94JhptN38o9SqdnpznMkslJsHu4C7qDu6Cvuwva5uAuaNu6u6BtLu6C7uAueGMlwwEahR1WOn0WS2alsy63SbZ1EikzY75eG33bmtH9UW52bIKM7H0DeZekTsdyuyZpLBRirbT+hsTmEuKfk8eanjAo870l+cdbMmfgHoZzILk7AffYgQySJqRP2Ma6zvrREqksNQdDMU+e28NzxPae05ioUov0ZViBg35hCw9tSp/Vz4iltJiXvTmNP1lk9ObQlhi9OW92SqnOnVK5jHe12DhLBpZ2i8Wat+GQwdySw3ObLa0/t0k5rPuk5PDcZkvrz2225PHcpn1smEw7ZDA3lqpklkaPDGbxyGAWjwxm8chgFp8MZvFJPRaP1GPxSD2W9dRjcUg9FofU41bW34RrxeNNONoSa696pB6LT+qx+KQei0/q8Ru337wsWUkplUYDX/VIPRgs5RaLcW+RPe47s2fn4xbmW5WJpA2zgvV71OUUFJFI0mQbq2tY6iyeUDGt9CVwZr1sCXdQY/qEREaS7O7m2q5Jjozrn2XZz17btLV2l0Vkprd20i2NXfmSUYBPMNDzEQe8ElnaTY6wxRGOwMKVv8OSqB/UlNrKO7bPOEKPpGNZZdHSRqeUBn6YsAU7yR5nmr2y/0bdz3aaWsOMGcOB9FtbmqxHjXlDxmuTe0M6aUhjplKnIDyKcly/KLbzsF3+fGMtdKyGXb/d8yC2H+eDYBFiPbslvjYlLasks9pSRt/ux8l6i2IGjvef+R6F6UOaOMh9cxHq1n+axS73rXvIPQt8WeWecVjlnt7vNcs9u71mlnvasUa5j6xkjn2zxEJWttkTWXEm6+zhJFa77yzu5cNinj2cxTp7Orv0Ypw9lMM4eyiHefZ0Vr3OOnt4x1pnT9wcFtHO6qMZZw8LANgWUU5hWkTfUNg+pDrIACUxT+Dw4yx2GaAsZhlgyXFWGWAcVhkI3UMGmLWZZYB2rFUGmNvdvIh2FvUyzh4azrDOHkpitnsWrvJhsc8eymKePXSUjbOHcVhnDw3ymGdPcrhMyzvWOnsC3TzOUBG0o7yW/GD3iXIa4bP85V2IEl4Mv3tMYxr6sk1jWgHPOo0piXkC/jyLfRpTFvM0Zo5q6zRmHNZpnIvHNM7NYRrTjvWYxn3cpv3yIMq3acwCTiWMuuMlbuF6GtO3kczTuCx7tmItDtOYkpgnYKk/zWKfxsVlL1sc9rLFYS9bXPay1WMvWzz2sjQE12eaQofiI98nMrPavA0XdQ5Y6fd1IjNts0/kdc9uZLJknsjFxask20+z2CcyZTFPZBb6sk5kxmGdyIzDPpHFoZAs71iPiZzC6NgUeiATWVhmQBuvi+VdGa4nMo3VmicyC3sZJzIbY/NEpiTmKdjyT7PYJzJlMU9kFrqyTmTGYZ3I9P6ZeSL3zWEi0461TmS6rKeRWRMSvKnV5fVzaILB+BoY4FD7BxxlpHJhbumHHCPZr+DTix9x1PFUxJcXY25zlLscoz/q7f6ooz/q7f6YT2fI7f5Ajrv9gY+V3u2P+dKZ3O6PNr6l3e4P5LjbH20oSJPb7ZBTEFu7244+Hi3vt/sDOW63Y1zc7kSDYqEBXls6NyeJI60oRpLOvXsg6MOrfS6ahbIwN+y8//qlRmP94HOMWdiRH2NtKe68JcYU98jStYyhTEphC2XKekZD8/DiNgf/q1Ye/VkW62bzDYtxs7mz1NXNJuewbTY5h3WzubP05c3mm461bjabQz5Q3NJ6IkDzyAfyyIPbv6b8NIt99lAW8+yhVQ2Ns4dxWGcP47DPHlbW0Dx7eN1K61GNVkedd/Ixvzf2+vo97AptGLV2dicO7rZeSaihwF1P6NqX4qY7CXuGchSGqlhc6iOKcZuwwju/H1KcE0e261bQU+cWR1L79uVc8dIMdhMjl3E9OmNxqQWSfknCrWxss1LaNmJlb14LGBWdcmrkczI7Ro+LvDVgbalvJPw24qxQFcrWXGigtve3zqXelvn4eIZ501/NrZqcHD1cb+o3eiXLdjDoHktod1lCa/xpFvsSWqPHElrL+hJay/oSWovHElrX0wjedKx5CaWVTcfN8f0wO+X+NaU2bsLu0I7K7Rmep3idw5vQUlvj8mtEr8nXC7RpSx6baVm+iZg2h6xaTmKewyI/zWJXAhEPJWjbuhK0bV0J2uahBC05KIF43ERkO9g4byImvPMdvu0K2IFW639oU1qe3/OtcHrzmMdt2aUUmkMiAicxz8D+4yz2edyDxzzueX0e97w+j3v2mMddHOZxd7gkE7rH7Anb+iWZzSONx+Ny2P416adZzLOHs1hnT9jWHbKUwzh7KId59oTNwSHLO9ZjFUxphEP2MEq4XAUpSd5m+H/fwl8vpbR2ug9LbWU4lZpcVT15wzEL2NYe5SbHdG71cs1BDXa4UHq8bfSjKmmXsj5xGAfVtTSqnscEvpPPSOLIFtv5mJQ4XOziJOGo6fx0BuV2sykhjNEJoZW7LOBTSv12W8osO1TgsumnLHWWiIOqap9+0ZS2FOkXLedwcw7rmhEdcrhjSD9utmmoUkhF7naKUZcoh1GXjINDdYluqW3fwjls32Ld2ku5efIyauybM6BVY7OHsWYXjc0uGptdNDa7aGx20djsorHZQWOzg8ZmF40tP262Zo3NDhqbHTQ2O2gsdT8aNZZyGDXW6AYlHNxLbdTYN/5yq8ZWD2OtLhpbXTS2umhsddHY6qKx1UVjq4PGVgeNrS4aKz9utmaNrQ4aWx00tjpoLA32GjWWchg11hh0Zhw0J8DqK+DZCVaNbR7G2lw0trlobHPR2Oaisc1FY5uLxjYHjW0OGttcNLb/uNmaNbY5aGxz0NjmoLE0J9WosZTDqLHG3FjG0Tw0tnlobNwcjJWSmDX2DYtRYzmLVWM5i1Vj37AYNfbNFxk1lpbPNGos5TBqLOUwa2wMP262Vo3lnWLTJc5h0yXr4FBti+sxL85h1Ni4HvOil6vMGhs9NNYj5hVdYl7RJeYVXWJe0SXmFV1iXtEl5hUdYl7RIeYVXWJeMf242Zo11iHmFR1iXtEh5sUvn45qhqVCzsdHFPOBQ3z24IWC3uY1Pt3zhsT4uhMvC2Ia2zccprE1lyehY5sc1hxex8a65uTqMHkZiX3N4SzWNSdXjzWHspjXHM5iXXP4F1nXnJLW15yS1tec4lBiK9IbWj5ma15zaKcY1xzKYVxzjINDtU3SusZKWtdYWf4WXmrPqrHFI88iVg9jrS4aW100trpobHXR2OqisdVFY8VBY8VBY8VFY+XHzdasseKgseKgseKgsaWva2zp6xpb1s8otC6xVWN5hWSrxjYPY20uGttcNLa5aGxz0djmorHNRWO7g8Z2B43tLhrbf9xszRrbHTS2O2hsd9DYXNY1Npd1jc3reRbZwz+dPfzTNCPOaqyUxKyxb1iMGstZrBrLWawa+4bFqLFvvsiosSmsayzlMGos5TBrbAo/brZWjeWdYtNYzmHTWOvgUG2jzxgZNZZyGDXW+JwS7Y/soLH83S2rxkYPY40uGhtdNDa6aGx00djoorHRRWOTg8YmB41NLhqbftxszRqbHDQ2OWhsctDY4OArCA6+grDuK4gOdzLevAxq1ViPmFdyiXkll5hXcol5JZeYV3KJeSWXmFdyiHklh5hXcol5pfLjZmvWWIeYV3KIeaX1mNeb94pNeRacwpRnEViFjyNT/KBICYtffnu7srLqRcPc4RnqV53f8vp6s+X19WZbvmfNn4E317LwyJ1OsjlMXPoelHm94SzW9YaymNcbymJebziLdb3hX2Rdb0TW1xuR9fVGHF4/iqn9uNma1xuR9fVGZH29keXcr9DYtR+jxnIOm8ZyDuO3yLrGchKzxnYPY+0uGttdNLa7aGx30djuorHdRWO7g8Z2B43tHhqbtx83W7PGdgeN7Q4a29c1lj/3atnTv6Gw7Ol3YdvWlV62daWX5YoagT1ZYFZ6SmJV+uxxpYuSmJX+DYtR6TmLVek5i1Xp37AYlf7NFxmVPof1WzLZ6Lgsd9thV/r442ZrVfq87lV+w2FT+rzuVQ6Mopbx/Ca8E7C7Wj6gyH1QZEKxrbdiW24Fu6Yay6PyuMrrl7n7+lwtJal91EeuPd0kmQ9Gx76VeyT7CjFeQNoi+ZzKPDhpG06x3a+WbrLY6tW+4TDVq33HYalXy8dGRi38x0OaNwf4C0m+SxInSboemphZalOKvQ3PacgXXfKGI41VL6Um1xz5ZzlyGN+SY7g5vOPNoChYDvyzkRkPdkXpd5UEW3KbpI1t+P7zNsnYSVCSvrzQ9PV1prC6n/0IIjyX7msNecMxKuDvP/sFB/PY2PqCMpj6otE3xMN4CkCgjn+I0c7R4uBoKdzkGOvl/rPe5CizHRC6+YxjHnlbudmOPqyr7JZ2tz/65LgeF/bYUS7z2aUCl47vc7R7HHVslHOF150/4xgPXmchNib8PdY2AnuBPJ6RWf26XIal7h8GHo1aPmmJ7RmPzB7msj3jITQuZ3vFg3JYn9/IbHx9WMyPeHAW6yMe2SGIlR2CWNkliJU9gli8Y42PeLBwi30S05e5jJP4TUuMk7iV1Uncy/ok7h7PMmf2KpcPi30SUxbzJGaPNlkncQ/rk5g+HmWexKzsvnkS0441TmL6DOM2OMoWr3dZjzInhCWOx4xLxD1jeyUhn1Nl9GwV8GC/kPCvqWPPiL6Rb19T6KNcxq8p7NEYj68J493t/ee9XWPZPQgnR4pyj2O+/73/dOCo4SZHG6OLL0R/xiHjRBDb3T4dgYn9Z73JkSZHzmzeLd9YecNh9HsbhZVwdIeL193j3nVhiYtWaaYk5mjcGxZjNI6zWKNxnMUajXvDYozGvfkiYzSusPiVcUdBOYw7Csph3lHsGvrTZmuNxvFOsakS57CpknVwqLI55Ollhzy9vJ6nJw7pw+KRPVySh6kmF4VNLgqbXBQ2uShsclHY5KKw2UFhs4PCZheFzT9utmaFzQ4Kmx0UNi8rbCU7xyQygp3SwP3T6k2Odo+jbee4pBa2mxzDgZRaLjc5cpsc/W47wuCAF20/4xhOm/0naQet0THGZV848j2OtMW5aqW7HNvkyOsc8WY7Yp+rZ2w325Fmf5S+3o56beulrI9tKetj+4bDNLZmjnizHcax5e2wja25HWRsM72/kMdOMRaMh786wGQ9jYVz2FJQiuSf5bClsdA+TWOpfFwvYn3K/KxDlCusUS8UtBl55sHgHuZ3mtEdHKQsjmV0kNKvKXEY6n44vvwazjEck7HU6x7ZfbE0UzEPCSllu8liTMrjHLakvDcclqQ8tle2JdRQBlNCTVpO6knLST2FPZnUy9hl9xYuo5ucY+6ye4uXHIHGWcO2jfyR/TecdT/jMdoo57DZ6BsOi40mdokkjgSjHiHBKKX8AUea6WtFrjn6uo1wDquNiJONiIONiIONyD0b+dcd/PFPf/nt337925/++Pe//O2v/73/e/98UP32lz/++69/fsL//Mdf/wT/7d//73+d/82///aXX3/9y//+t//67W9/+vN//OO3Pz+YHv/dL9vzP/5XqCXIH/b/TPKvf/gl6T/Zt5qPf77t/ySc/6Nw/KP6+EdB/9G+fX/8Z/7Xfz6a+v8A",
      "is_unconstrained": true,
      "name": "get_registered_emitter"
    },
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14067204867181196045": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "9921926525851912681": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [
          {
            "name": "chain_id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 16
            },
            "visibility": "private"
          },
          {
            "name": "emitter_address",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "boolean"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "utility"
      ],
      "debug_symbols": "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zser8/HqfLw6H6/Ox6vz8ep8vDofr87Hq/Px6ny8Oh+vzser8/HqfLw6H6/Ox6vz8ep8vDofr87Hq/Px6ny8Oh+vzser8/HqfLw6H6/Ox6vz8ep8vDq3V+f26txendurc3t1bq/O7dW5vTq3V+f26txendurc3t1bq/O7dW5vTq3V+f26txendurc3t1bq/O7dW5vTq3V+f26txendurc3t1bq/O7dW5vTq3V+f26txendurc3t1bq/O7dW5vTq3V+f26txendurc3t1bq/O7dW5vTq3V+f26txendurc3t1bq/O7dW5vTq3V+f26txendurc3t1bq/O7dW5vTq3V+f26txendurc3t1bq/O7dW5vTq3V+f26txendurc3t1bq/O7dW5vTq3V+f26txendurc3t1bq/O7dW5vTq3V+f26txendurc3t1bq/O7dW5vTq3V+f26txendur8/nqfL46n6/O56vz+ep8vjqfr87nq/P56ny+Op+vzuer8/nqfL46n6/O56vz+ep8vjqfr87nq/P56ny+Op+vzuer8/nqfL46n6/O56vz+ep8vjqfr87nq/P56ny+Op+vzuer8/nqfL46n6/O56vz+ep8vjqfr87nq/P56ny+Op+vzuer8/nqfL46n6/O56vz+ep8vjqfr87nq/P56ny+Op+vzuer8/nqfL46n6/O56vz+ep8vjqfr87nq/P56ny+Op+vzuer8/nqfL46n6/O56vz+ep8vjqfr87nq/P56ny+Op+vzuer8/nqfL46n6/O56vz+ep8vjqfr87nq/P56ny+Op+vzuer8/nqfL46n6/O56vz9ep8vTpfr87Xq/P16ry6lxxN3/4oHv15xK/oNH11fmk8skfz0Xq0H/mjePQ8xvOw52HPw56HPQ97HvY87HnY87DnYc9jPo/5PObzmM9jPo/5PObzmM9jPo/5PNbzWM9jPY/1PNbzWM9jPY/1PNbzWM9jP4/9PPbz2M9jP4/9PPbz2M9jP4/9PPx5+PPw5+HPw5+HPw9/Hv48/Hn484jnEc8jnkc8j3ge8TziecTziOcRzyOfRz6PfB75PPJ55PPI55HPI59HPo/zPM7zOM/jPI/zPM7zOM/jPI/zPE57VHPUpfHIHs1H69F+5I/iUT56Hq/O96vz/eq8OqXCitaj/cgfxaN8dJqqzkHjkT16HvY87HnY87DnYc/Dnsd8HvN5zOcxn8d8HvN5zOcxn8d8HvN5rOexnsd6Hut5rOexnsd6Hut5rOexnsd+Hvt57Oexn8d+Hvt57Oexn8d+Hvt5+PPw5+HPw5+HPw9/Hv48/Hn48/DnEc8jnkc8j3ge8TziecTziOcRzyOeRz6PfB75PPJ55PPI55HPI59HPo98Hud5nOdxnsd5Hud5nOdxnsd5Hud5nPaoBqxL45E9mo/Wo/3IH8WjfPQ8xvMYz2M8j1fn/urcX537q3N/de6vzv3Vub8691fn/urcX537q3N/de6vzv3Vub8691fn/urcX537q3N/de6vzv3Vub8691fn/urcX537q/Pq1IpdZI/mo/VoP/JH8Sgfnaaqc9Dz2M9jP4/9PPbz2M9jP4/9PPbz8Ofhz8Ofhz8Pfx7+POq36UZRPMpHp6l+qw40Htmj+Wg92o+ex1fnWTv+1fml0/TV+aXxyB7NR+vRfuSPnkc+j3we53l8dZ6ryB7NR+vRfuSP4lE+OpeqyevSeGSP5qP1aD/yR/EoHz2P8TzG8xjPYzyP8TzG8xjPYzyP8TzG87DnYc/Dnoc9D3se9jzqt1x3UTzKR5/H9zuT1QJ2aTz6PPArm/PRevTncUaRP4pHfx4nik7TV+eX/jwOfgnUHs1H6/u1z1/hJjoxiEk8D79qbxxEI04i3TbdNt12udWqdhLPQy+32m4fRCNO4iJuohODmMTzMOgWdAu6RbnV+cYibqITg5jE87B+4fbiIBqRbkm3pFvSLemWdEu6Hboduh26Hboduh26Hboduh26nedWDWiNg2jESVzETXRiEJNIt0G3QbdBt0G3QbdBt0G3QbdBt0E3o5vRzehmdDO6Gd2MbkY3o5vRbdJt0m3SbdJt0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0W3TbdNt023TbdNt023TbdNt023TzenmdHO6Od2cbk43p5vTzenmdAu6IUuy0IiTuIib6MQgJvE8RJYA6ZZ0S7ol3ZJuSbekW9It6Xboduh26Hboduh26Hboduh26Hae2/n9iINoxElcxE10YhCTSLdBt0G3QbdBt0G3QbdBt0G3QbdBN6Ob0c3oZnQzuhndjG5GN6Ob0W3SbdJt0m3SbdJt0m3SbdJt0m3SbdFt0W3RbdFt0W3RbdFt0W3RbdFt023TbdNt023TbdNt023TbdNt083p5nRzujndnG5ON6eb083p5nQLujFLDrPkMEsOs+QwSw6z5DBLDrPkMEsOs+QwSw6z5DBLDrPkMEsOs+QwSw6z5DBLDrPkMEsOs+QwSw6z5DBLDrPkMEsOs+S8LLHfyxL7vSyx38sS+70ssd/LEvu9LLHfyxL7vSyx38sS+/3oNug26DboNug26DboNug26DboNuhmdDO6Gd2MbkY3o5vRzehmdDO6TbpNuk26TbpNuk26TbpNulWWDHyDy3lYWXJxEI04iYu4iU4MIt0W3TbdKkuGFRpxEhdxE50YxCSeh5UlF+nmdHO6Od2cbk43p5vTzekWdAu6Bd2CbkG3oFvQLegWdAu6Jd2Sbkm3pFvSLemWdEu6Jd2Sboduh26Hboduh26Hboduh26Hbue5Vc9h4yAacRIXcROdGMQk0q2yZKzCQTRiuUXhIm6iE4OYxPOwsuTiIBqRbkY3o5vRzehmdDO6TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptum26Od2cbk43p5vTzenmdHO6Od2cbkG3oFvQLegWdAu6Bd2CbkG3oFvSLemWdEu6Jd2Sbkm3pFvSLel26Hboduh26Hboduh26Hboduh2npv9fsRBNOIkLuImOjGISaTboNug26Abs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLqxBzfV5patWJerCy5OIhGnMRF3EQnBpFuSbdDt8oSG4VGnMRF3EQnBjGJp7H6MxsH0YiTuIib6MQgJpFug26DboNug26DboNug26DboNug25GN6Ob0c3oZnQzuhndjG5GN6PbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26ab083p5nRzujndnG6VJTYLg5jEcvMPK0suDqIRJ3ERN9GJQUwi3ZJuSbekW9It6ZZ0S7ol3ZJuSbdDt0O3Q7dDt0O3Q7dDt0O3Q7fz3PbvRxxEI07iIm6iE4OYRLoNug26DboNug26DboNug26DboNuhndjG5GN6Ob0c3oZnQzuhndjG6TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptum25ON6eb083p5nRzujndnG5ON2bJZpZsZslmlmxmyWaWbGbJZpZsZslmlmxmyWaWbGbJZpZsZslmlmxmyWaWbGbJZpZsZslmlmxmyWaWbGbJZpZsZslmlmxmyWaWbGaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZgr5XO4WTuIib6MQgJvE8RJYAB5FuQbegW2VJ/aEQ9L1eDGISz0P8oRngIBpxEheRbkm3pFvSLel26Hboduh26FZZMq1wE50YxCSeRvS9XhxEI07iIm6iE4OYRLoNug26DboNug26DboNug26DboNuhndjG5GN6Ob0c3oZnQzuhndjG6TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptum25ON6eb083p5nRzujndnG5ON6db0C3oFnQLugXdgm5Bt6Bb0C3olnRLuiXdkm5Jt6Rb0i3plnRLuh26Hboduh26MUuSWZLMkmSWJLMkmSWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCXoe52rcBIXcROdGMQknofIEuAg0i3plnRLuiXdkm5Jt6Tboduh26Hboduh26Hboduh26HbabeJvteLg2jESVzETXRiEJNIt0G3QbdBt0G3QbdBt0G3QbdBt0E3o5vRzehmdDO6Gd2MbkY3o5vRbdJt0m3SDVnihYu4ieWWhUFM4nmILAEOohEncRE3kW6Lbotui26bbptum26bbptum26bbptum26bbk43p5vTzenmdHO6Od2cbk43p1vQLegWdAu6Bd2CbkG3oFvQLeiWdEu6Jd2Sbkm3pFvSLemWdEu6Hboduh26Hboduh26Hboduh26neeGvteLg2jESVzETXRiEJNIt0G3QbdBt0G3QbdBt0G3QbdBt0E3o5vRzehmdDO6Gd2MbkY3o5vRbdJt0m3SbdJt0m3SjVkymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWTKZJZNZMpklk1kymSXoe60/Boy+14tB/NzWLDwPK0suDqIRJ3ERN9GJQaTboBuyJAoH0YiTuIib6MQgJvE8nHSbdJt0m3SbdJt0m3SbdJt0m3RbdFt0W3RbdFt0W3RbdFt0W3RbdNt023TbdNt023TbdNt023TbdNt0c7o53ZxuTjenm9PN6eZ0c7o53YJuQbegW2XJtsJF3MTPbdclV1lyMYl1TX5vdNH3enEQjTiJi7iJTgxiEul26Hboduh26Hboduh26Hboduh2nhv6Xi8OohEncRE30YlBTCLdBt0G3QbdBt0G3QbdBt0G3QbdBt2MbkY3o5vRzehmdDO6Gd2Mbka3SbdJt0m3SbdJt0m3SbdJt0m3SbdFt0W3RbdFt0W3RbdFt0W3RbdFt023TbdNt023TbdNt023TbdNt003p5vTzenmdHO6Od2cbk43p5vTDVmCvxw/iEacxEXcRCcGMYnnYdIt6ZZ0S7ol3ZJuSbekW9It6Xboduh26Hboduh26Hboduh26HaeG/peLw6iESdxETfRiUFMIt0G3QbdBt0G3QbdBt0G3QbdBt0G3YxuRjejm9HN6GZ0M7oZ3YxuRrdJt0m3SbdJt0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0W3TbdNt023TbdNt023TbdNt023TTenW2XJzkIjTuLn5vi3m+jEz81nYRLPw8qSi4NoxElcxE10It2CbkG3pFvSLemWdEu6Jd2Sbkm3pFvS7dDt0O3Q7dDt0O3Q7dDt0O3Q7Tw39L1eHEQjTuIibqITg5hEug26DboNug26DboNug26DboNug26Gd2MbkY3o5vRzehmdDO6Gd2MbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26bbk43p5vTzenmdHO6Od2YJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMEvS9fn8tZKLv9eIgGnESF3ETnRjEJNIt6ZZ0S7pVloQXLuImlpsVBjGJ5yGyBDiIRpzERdxEuh26Hbqd54a+14uDaMRJXMRNdGIQk0i3QbdBt0G3QbdBt0G3QbdBt0G3QTejm9HN6GZ0M7oZ3YxuRjejm9Ft0m3SbdJt0m3SbdJt0m3SbdJt0m3RbdFt0W3RbdFt0W3RbdFt0W3RbdNt023TbdNt023TbdNt023TbdPN6eZ0c7o53ZxuTjenm9PN6eZ0C7oF3YJuQbegW9At6BZ0C7oF3ZJuSbekW9It6ZZ0Y5YksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLDrPkMEsOs+QwSw6z5DBLDrMEfa85C5N4HlaWfF/oPtH3etGIn1uewkXcxM/t/AqDmMTzsLLk4iAacRIXcRPpZnQzuhndKkuOFw6iEf/c/j5iL1zETfQPax++LGlM4p+bfV+VOKvvtXEQ7cM6iy9LGhfxcxs1nS9LGoOYxPNw/4iDaMRJXES6bbptum26bbo53ZxuTjenm9PN6eZ0c7o53ZxuQbegW9At6BZ0C7oF3YJuQbegW9It6ZZ0S7ol3ZJuSbekW9It6Xboduh26Hboduh26Hboduh26HbabVXfa+MgGnESF3ETnRjEJNJt0G3QbdBt0G3QbdBt0G3QbdBt0M3oZnQzuhndjG5GN6Ob0c3oZnSbdJt0m3SbdJt0m3SbdJt0m3SbdFt0W3RbdFt0W3RbdFt0W3RbdFt023TbdNt023TbdNt023TbdNt023RzujndnG5ON6eb083p5nRzujndgm5Bt6Bb0C3oFnQLugXdgm5Bt6Rb0i3plnRLuiXdkm5Jt6Rb0u3Q7dDt0O3Q7dDt0O3Q7dDt0I1ZMpglg1lSfa/2fWvMqr7XxkX83CwLnRjEz+37jcpVfa8XK0sufm6z3CpLLk7i5/Z9wr+q77XRiZ/b97neqr7XxvOwsmTtwkE04ue2a0GVJRc38XPbGCyISfzc/PdhZcnFQfzcvOZbWXJxET83rz2rLLkYxM8tar6VJcDKkoufW9SeVZZcnMTPLWrXK0suOjGISTwPK0suDqIRJ5Fum26bbptum26bbk43p5vTzenmdHO6Od2cbk43p1vQLegWdAu6Bd2CbpUlWddDZcnFJH5uWYdVWXJxEI04iYu4iU4MYhLpduh26HboVlny/QWmVX2vjZv4uR0rDGISP7fzLbP6XhsH0YiTuIib6MQgJpFug25flszvbyut6nttnMT1oRVuohPjwyxM4nn4Zcn8ncJBtIf1Drv+6XfxzfEr/AYY5fBdZo2DaMRJXMRNdGIQk0i3pFvSLemWdEu6Jd2Sbkm3pFvS7dDt0O3Q7dDt0O3Q7dDt0O3Q7Ty3aolsHEQjTuIibqITg5hEug26DboNug26DboNug26DboNug26Gd2MbnWZjV04iYu4iU4MYrmdwvNw/oiD+Ll9X8a4qiWy8XP7vmluVUtkoxODmMTz8HvJavzcbBUacRLLzQs30YnlVvNdSTwP9484iEb83L6vSFjVEtm4iU783GbN7HvJajwPv5esvwUWDqIRP7dVg30vWY2bWKuIwm/cuoWpNse/ZRfWCDX1yoeLm+jEICbxG7dubKrNsXEQjfi51T1OtTk2fm67Jln5cDGISTwPKx8ufm5eF0Hlw8VJXMTPzasCKh8ufm5ek6x8uHgaq82xsdyi0IiTuIib6MTPLUZhEs/DyoeLn9v3h0lXtTk2TmK57cJN9IdV8xdrhFpFVXfdylWT4t/hFX4zS/zbJJ6HVd1ZP1bVfdGIk7iIm+jEICbxPFx0W3RbdFt0q+quW6NqUmx0YhCTeB5WdV8cRCNOIt023ap4v79MuaoHsXEQjTiJi7iJTgxiEulWNwLfQ9ZVPYiNRpzEb7C6Eatmwlm3XNVM2GjESVzETfwmWTdM1UzYmMTzsCr24iAacRLLrS65qtiLTgxiEk9jNRPO7+HtqmbCRiNOYllEoRODWBZZeB5WmV4cxHea1SvY6MQgJvGdZvUK4rCqV7DRiJP4TrOa/nAs1fTXaMRJXMRNfKdZTX+NSXynWU1/jYNoxEl8p1lNf41ODGISeZqbp7l5mpunuXmaX0Gu78+mrur0W3W7Xp1+jUk8D7/aXN/D/FXde+tXU3cnBjGJ5+FXhY3jw5pOGHESF3ETnRjEJJZbHVb+iINoxHKr6zcX8XOrdxLVvdcYxCR+bqN+7CvexkE04iQu4udmNZ2veBuDmMTPre7EqnuvcRCNOImLuIlOLLcoTOJ5OH7EQTRijZuFNcIpPA/tRxzEb4T5K5zERdxEJwYxiZ/b970eqzryGgexxp2FNcJ3IVY/3f3/rvq3u9CIk1gj1J6tTXRijVv7sJIW5+H+EWvc2oe9iJvoxG/cuqetzrnG8/B7NW0cRCNO4iJuYnZ1Oyq2EBULHMQadxS+JPBwYhBrvnUAVZvAqs2LNd8aF7VZP4baBC4i3ZJuSbdM4sud6oZrHES6HVqc93rheN0EnsbA6yawpr4K3+tF/DbRiXWEuzCJ52EVWb3riPFenaqtrXES6TboNuhWL6EXk3ge2o9IN6NF3fRimXwJra61Rm5J1Rv2gS+hwZfQ4Eto9afdFU9uyeSWzPP2YXGSi5Nc3JJFt0W3RbfFLVncksUtWdySTbdNiyrIFYVODGISz8MqyF27UwV50YiTuIib+Lnt2pJ6Yb2YxPOwynTXnlWZXjRiudXM6oX14iaW2yn83OpBerWfrXoHWO1nF6t4Lw6iESfxG7feXFWjWWMSz8Mq04ujsbrAVj2Vry6wxrI4hZ9FvRmsfq/GJJ6HVWQXx8N6dap3i9WX1WjESVzETXRiEJN4Hk66TbpNuk26TbpNulW11NvU6rX6u4oLawQvnMRFrBGi0IlBTOJ5WK9ZF2vcOoAqhnoUX/1TfyssTOJ5WMWQtdVVDBeNOImLuImfW9aKqxgullstvooBWMVwscaty6gu8HonXD1RjTXCr7BGqGXWBX5xEI1Y49Y+1KvTxU0st9qduuwvJpFuh26Hboduded4cb2zODzNw9M8PM3D0zzvNKv7CUdYfU44wupzwmFVn1NjEk+fRfU5NQ6iESdxEXefW/U5NUYfVvU5Nb7TrI4mHGH1LuHcqnepMfoIq3cJG1W9SxfnjziI1odVvUuNi7j7sKp3qTGIdJt0W3RbdFvvNKsBaNXrZjUANRrxm86p3aliuLiJTgxiEs/DKoaLg1huNZ0qkYuLuIlODOKf2673hdUAdPErnMZBtA/rMvoKp3ER94c1s69wGoNYbnU95Hl4fsRBLLe6YE6NW1fJcWIQk1jj/p38rlaf/X3AtKvVZ3/v9Xa1+jRO4iJ+bl+r2q5Wn8YgJvFzG/PDURa7sCy8sCxqOl8Nbasf+2qo0YlBTOJ5+L2+NX5u39vJXf09jZ+blbEt4iY6MYhJ/Nxm7cNXb42DaMTPbdZ0vnpr3MTPbdbMvnprTGK5rQ9XudUc1iAacRIXcRNr3DrudR7uH/H7/64y/oq38XNbdYRf8TZO4iJuohO/ta1axVe8e9VF4Odh/IiDaMRJrHFrQVWQ323ori6av2dDhYNoxBqhllkFeXETnRjEJH5uu86tCvJiudVGVUFenMRv3F37UKX3fdaxqzOmsVachdYbVZ0xjYu4iTXuLgxiEk8fQHXGNA4i3QbdBt0G3aoKgVUt3830rg6WxiBWtZRFVQuwquXiIBpxEr857NqSqpaLTgxiEs/DqpaLdRancBE30YlBTOJ5WNVycRCNSLdNt023TbdNt023TTenm9PN6eZ0c7o53ZxuTjenm9Mt6BZ0C7oF3YJuQbegW9At6BZ0S7ol3ZJuSbekW9It6ZZ0S7ol3Q7dDt0O3Q7dDt0O3Q7dDt0O3c5zs9+POIhGnMRF3EQnBjGJdBt0G3QbdBt0G3QbdBt0G3QbdBt0M7oZ3YxuRjejm9HN6GZ0M7oZ3SbdJt0m3SbdJt0m3SbdJt0m3SbdFt0W3RbdmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYsyS+o62/X2yves72hrPQwRIFhpxEhdxE50YxCS+0LX4EekWdAu6Bd2CbkG3oFvQLeiWdEu6Jd2Sbkm3pFvSLemWdEu6Hboduh26Hboduh26Hboduh26nec2fz/iIBpxEhdxE50YxCTSbdBt0G3QbdBt0G3QbdBt0G3QbdDN6GZ0M7oZ3YxuRjejm9HN6GZ0m3SbdJt0m3TjbcfkbcfkbcfkbcfkbcfkbcfkbcdcdFt0W3RbdFt0W3RbdFt0W3TbdNt023TbdNt023TbdNt023TbdHO6MUsms2QySyazZDJLJrOkvpht+ypM4nlYWeJeOIhG/Ny+J6e7OpYaN9GJQUxiuX3pWR1LjYNoxElcxE10YhCTSLdDt0O3yhKv3aksubiIm+jEIH5u35PeXR1LwOpYavzcvkeruzqWGidxEb9xv2evu7qQ9vfsdVcXUqMRawQvXMRN/Ob7PZfb9WVrjUk8Dysfvgd3uzqWGo04iTXuKfxG+B6P7epNahzE2t+yqJq/uIib6MQgJrHcaneq5i8O4ueWtZNV8xcXcROdGMQknodV8xcHkW6bblXzWSdUNf89Xdz1BWqNQUzieVg1f3EQjTiJi0i3qvmsw6qav5jEcqurpGr+4iB+bqeOsGr+4iJ+bqcGq5q/GMQknodV8xcH0YiTuIh0q5o/dfVVzV9M4p+b/6r0vppvHET7sJb51XzjIu4Pa5lfzTcG8c/N6wFb9TwBq+ep8XMbq9CIk/i5fc25u9qfGp34uX19urvanxrPwy8f/GuQ2NX+1GjEz+1rm9jVFNW4iZ/b13uwqymqMYmfWz3GqqaoxkH83FZN58uHxkX83OphUX2BWmMQP7d6ZlNfoHbxy5LGz62e5FQvVeMkfm5ebl+WNDrxc6vb8eqlajwPvyzxCvPqpWo04udWrxfVS9W4iZ9bBWn1UjUm8XOr9KxeqsZB/NwqNaqXqnERN9GJQUziefhlSeMg0s3p5nT7ssRP7c6XJY1B/NxOndCXJRe/LGn83KogqwWrcRL/3KLKqVqwGp0YH9YZf1nSeB5+WRL1UL1asBqNOD8st1zETfzc6ul4tWA1JvFzq2fm1YLVOIifWz1JrxasxkX83KwG+7KkMYifm2Gw01gtWI2fWz2Zrhasxkn83L4mo10tWI1OPB3b1Va1v0+Ydn0pWuMibqITg5jE8/DLh6hn5tWC1WjESVzETXRiEL/d+X45cFcL1sX5I5bbLjTiJNbaRuEmOrHcvsOqdq2ox/LVrtVoxElcxE10YhCTeB5uum26bbptum26bbptum26bbptujndnG5ON6eb083p5nRzujndnG5Bt6Bb0C3oFnQLugXdgm5Bt6Bb0i3plnRLuiXdkm5Jt6Rb0i3pduh26Hboduh26Hboduh26Hbodp5bdYQ1DqIRJ3ERN9GJQUwi3QbdBt0G3QbdBt0G3QbdBt0G3QbdjG5GN6Ob0c3oZnQzuhndjG5Gt0m3SbdJt0m3SbdJt0m3SbdJt0k3ZkkwS4JZEsySYJYEsySYJcEsqfayqLurai+7WFlycRCNOImLuIlO/Nzq46rqP2s8DytLvhbNXf1njUacxEXcRCcGMYnnYdAt6BZ0qyypDyqr/6xxEz+3up+s/rPGJH5udT9ZnWb3xyof6vO36jRrrBGiMInnYeXDxUE04jffuvesrzRr3EQnfm5ek6x8uHga6yvN4vvdqF3NbI1GLLdVuIib6MRy24Xl9s23mtmiboXry8saJ3ERv3HjV/iNW89A6svLop5r1JeXRT3BqC8vu1hJcHEQP7eo6VQSXFzETSy3mm+Vf91XV2dc1LOK6oyLesmvzrioO93qjGucxEXcRCcG8XOr9931jWUXq+YX0IiTuIib6MQgJvE8RM0D6bbptum26bbpVjWftWdV8xeTWAuqnayavziIRpzERdxEJwYxiXQLulXN17uO+pqyxklcxE104ud2asVV8xfPw7p/uFhuXmjESSy3mlnlQ72bqZa8xj+3rLcw1ZLXeD6s6Xz50DiIRpzERdxEJwYxic+tvqascRCNOImLuIlODGIS6TboNug26DboNug26DboNug26DboZnQzuhndjG5GN6Ob0c3oZnQzuk26TbpNuk26TbrNcrNCJwYxiadfkqrVr3EQjTiJi7iJTnyvevWFZFlvoOurx/CqV189ll+L266vHmt0YhCTeB76j1j7sAu5v84VO1fs52H8iLW/XmjESVxEnmbQLXiawdMMnmbyNJOnmfbmkJO4iDzN9DcH1DwwiXRjzR/W/GHNH9b8Yc0f1vw5vHYOd/JwJ0/vpP9Q8144iEZsN/+9mvffq3n/vZr336t5/72a99+ref+N3zNGzQONOInrzQE1D3Qi3QbdBt1ezfvv1bz/Xs37z7g249psvzmYE4OYRO4kaj4KB7HcsnASF3ETP7dRc6iav5jE8/Cr+cZBNOIkfm6jJvnVfGPdP9ROrnOr0KvdML8n015fHNZoxEnkCW2e0OYJ7SAm8Tx0Xn3OE3KekPOEnCfkvPqcV5/zenBeD87rofLhe6ju1bDYuIi1O7UPlQ+jZlb5cDGJ52Hlw8VBNOIkLmI/TfIfnh4Az0M8PQAOohEncRE30Yl0O3Q7z238fsRBNOIkLuImOjGISaTboNug26DboNug26DboNug26DboJvRzehmdDO6Gd2MbkY3o5vRzeg26TbpNuk26TbpNuk26TbpNuk26bbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptunmdHO6Od2cbk43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",
      "is_unconstrained": true,
      "name": "is_emitter_registered"
    },
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "14067204867181196045": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "9921926525851912681": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [
          {
            "name": "message_ciphertext",
            "type": {
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 17,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec"
            },
            "visibility": "private"
          },
          {
            "name": "message_context",
            "type": {
              "fields": [
                {
                  "name": "tx_hash",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "unique_note_hashes_in_tx",
                  "type": {
                    "fields": [
                      {
                        "name": "storage",
                        "type": {
                          "kind": "array",
                          "length": 64,
                          "type": {
                            "kind": "field"
                          }
                        }
                      },
                      {
                        "name": "len",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "std::collections::bounded_vec::BoundedVec"
                  }
                },
                {
                  "name": "first_nullifier_in_tx",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "recipient",
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::messages::processing::message_context::MessageContext"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "utility"
      ],
      "debug_symbols": "TJ3LsjS7bpzf5Yw9aIIEQOpVPHD4qlCEQorwZaSX9yokwcyJ95fW+ZmoYiG7uhrd6z/+8T/+53/7f//8X/7l3/7Xv/+ff/zTf/6Pf/y3//0v//qv//LP/+Vf//2//9f/+y///m9//7//8Y/f9//sv/93/qd/7PGPf4q//9g//mn9/WfiPwv/8X/80/77T+A/if9s/OfUf84P/xn4j+E/E/9Z+A9WOVjlYJWDVQ5WGb/f/e+4/7X733n/u+5//f437n/z/nff/971xl1v3PXGXW/c9cZdb9z1xl1v3PXGXW/c9eyuZ3c9u+vZXc/uenbXs7ue3fXsrmd3vXnXm3e9edebd71515t3vXnXm3e9edebd71111t3vXXXW3e9dddbd71111t3vXXXW3c9v+v5Xc/ven7X87ue3/X8rud3Pb/r+V0v7npx14u/9cbvg9mwGrzhb80xP8iG3XAu5N+6Iz74W9i+f5XWMBtWgzdEw9/Ktj7YDefC1x6Ab2X/wBpmw1fzdzhfowCi4W/lOT7YDefC1zKA0WANs2E1eEM09MqnVz53Zfu6aM4PRoM1zIbV4A3RkA274VwYvfLolUevPHrl0SuPXnn0yqNXHr3y6JWtV7Ze2Xpl65WtV7Ze+euv6R9kw244F74eA4wGa5gNq8EbeuXZK89eefbKq1devfLqlVevvHrl1SuvXnn1yqtXXr2y98reK3uv7L2y98reK3uv7L2y98reK0evHL1y9MrRK0evHL1y9MrRK0evHL1y9srZK2evnL1y9srZK2evnL1y9srZK+9eeffKu1fevfLulXevvHvl3SvvXnn3yqdXPr1y9eD+YDasBm+IhmzYDQcwqwcLRoM1zIbV8LfyGh9EQzb8rbzig3Ph60HAaLCG2bAavCEasqFXHr2y9cp2E2maNcyG1eAN0ZANu+Em0py/hl559sqzV/56cJ0PvCEasmE3nAtfDwJGgzXMhl559cqrV1698teD/vvgXPh6EDAarGE2rAZviIZs6JW9V45e+etBzw+sYTasBm+IhmzYDefC14OAXjl75eyVs1fOXjl75eyVs1fOXnn3yrtX3r3y7pV3r7x75d0r715598q7Vz698umVT698euXTK59e+fTKp1c+vfK5K6/fr2E0WMNsWA3eEA3ZsBt65dErj1559MqjVx698uiVR688euXRK49e2Xpl65WtV7Ze2Xpl65WtV7Ze2Xpl65Vnrzx75dkrz1559sqzV5698uyVZ688e+XVK69eefXKq1devfLqlVevvHrl1SuvXtl7Ze+VvVf2Xtl7Ze+VvVf2Xtl7Ze+Vo1fuHlzdg6t7cHUPru7B1T24ugdX9+DqHlzdg6t7cHUPru7B1T24ugdX9+DqHlzdg6t7cHUPru7B1T24ugdX9+DqHlzdg6t7cHUPru7B1T24ugdX9+DqHlzdg6t7cHUPru7B1T24uge9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwez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qmEjr3dUNWzk9Taqho0ag/itUG8qatio8TysPr44iLVuHVD1Zr3zqQEir3dUNUB0sXrz4iAacRIX0YlBLLc64urNi+dh9Wa93akBokYjTuLnVu9maoCoMYifW72FqQGixvOw+rje7tQAUaMRJ3ERnVhudVKrjy9uYrnVqa4+vjiIRnRirVDbEudhdWy9YaqhoEYjfvV6nZ3q44tODGISN/E8rD6+OIhGpNum26bbptum26bbptuh26Hboduh26Hboduh26HboVv18fd20msoqHEQy20WTuIilpsXBrHcduEmnofV3RcHsdxO4SR+bt/7Qq+hII+qrHr+e2PjNRTUuImfW6wPq+cvDuLn9t3bew0FNS6iE4OYDysJvsfOXoM+HnUU1fNRpVfPXwxiEr96sw6oeh5YPX9xEI34uWUdZvV81lmvns8qp3o+y6J6HljdvetMVh/vWqw6dtdi1bEXN/GrbNd2V8deHEQjTuIiOrHc6vTVK+/F/bBaGpVVS180YlnUqa6WvujEz+Lgf5vETfwO6FQ51dIXP7dTR1wtfXESP7dT10619MUgJnETz8Nq6YuDaMRJpNuh26Hboduh23luNZvTOIhGnMRFdGIQk1huXngeVktfLLcsNOIkltsudGIQk1hup/DPLb43Cl6zOfG9O/CazWk04vxwFi6iE4OYxE08D+ePOIhGpNuk26TbLLdRmMRNPA/XjziIRpzEcquzvpwYxHKLwk08D/1HLLfaITfiJAaxVqht+UIhRm3LFwqNRpzEb4VRO/S9jMeos5M/4iAacRIX8TviUYeZQUziJp6H+0ccRCOWW53fvYhODGK51enbm1hudf2eH3EQPzerU/L1fOMiOjGI2VjTMvHdunvNxcT3YYjXXEx89+teczGNQUziV+93F+81F3Nx/IiDaMTPbVYNXx83OjGISdzEz+278fb6PbjGQTRiuZVx9fFFJ5ZbFn5uqyyqjy9+bqtOVPXxxc9t1TmrPr44iYvoxCAmcRPPw+rji3RbdFt0W3RbdFt0W3RbdFt0c7o53ZxuTjenm9PN6eZ0c7o53YJuQbegW9At6BZ0C7oF3YJuQbekW9It6Vb5sOqqrny46MQglltdO5UPF8/DyoeLg2jESVxEJwaRbptum26Hboduh26Hboduh26n1v1ypwaa/j65KDRirbALF9GJQUziJp6HlQTf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",
      "is_unconstrained": true,
      "name": "process_message"
    },
    {
      "abi": {
        "error_types": {
          "11594563071547591162": {
            "error_kind": "string",
            "string": "Function _validate_emitter_and_update_value can only be called internally"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14415304921900233953": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15546539856497705002": {
            "error_kind": "string",
            "string": "u16 to u8 conversion failed"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16810041750452690220": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 27
          },
          "17765343328382640478": {
            "error_kind": "string",
            "string": "Source chain IDs and emitter addresses length mismatch"
          },
          "18173155084464344029": {
            "error_kind": "string",
            "string": "Emitter not registered"
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "6788092787179896647": {
            "error_kind": "string",
            "string": "Caller is not owner"
          },
          "8228371833434187583": {
            "error_kind": "string",
            "string": "Trying to read from uninitialized PublicImmutable"
          },
          "9967937311635654895": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          }
        },
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JwACBAEoAAABBIBTJwAABFMnAgIEAScCAwQAHwoAAgADAFItCFIBJQAAAEElAAAAwScCAQRTJwICBAA7DgACAAEsAABDADBkTnLhMaApuFBFtoGBWF0oM+hIeblwkUPh9ZPwAAAAJwBEBAYpAABFBP////8nAEYEAycARwEAJwBIBAAnAEkAACcASgEBJwBLBAEnAEwAAScATQQCJwBOBAUnAE8EICcAUAQiKwAAUQAAAAAAAAAAAQAAAAAAAAAAJiUAACgFKQIAAgAR18oYCioBAgMnAgQEACcCBgQDACoEBgUtCAECAAgBBQEnAwIEAQAiAgIFLQ4EBQAiBQIFLQ4EBScCBQQDACoCBQQnAgQABicCBQQEJwIGAAgkAgADAAABKSMAAAj3LQgBBycCCAQGAAgBCAEnAwcEAQAiBwIIHzAATgBLAAgtCAEIAAABAgEtDgcILQgBBwAAAQIBLQxIBycCCgQLLQgACy0KCAwtCgcNAAgACgAlAAAoKy0CAAAtCgwJACIJSwstCwsKJwILBAwtCAAMLQoIDS0KBw4ACAALACUAACgrLQIAAC0KDQkAIglLDC0LDAscCgsMAxwKDAkAJwIMBA0tCAANLQoIDi0KBw8ACAAMACUAACgrLQIAAC0KDgsAIgtLDS0LDQwnAg0EDi0IAA4tCggPLQoHEAAIAA0AJQAAKCstAgAALQoPCwAiC0sOLQsODRwKDQ4GHAoOCwAnAg4EDy0IAA8tCggQLQoHEQAIAA4AJQAAKCstAgAALQoQDQAiDUsILQsIBxwKBw0CHAoNCAAeAgAHAC0IAQ0nAg4EAwAIAQ4BJwMNBAEAIg0CDjYOAAcADgAAIg1LDy0LDw4AIg1NEC0LEA8cCg4NAAQqDQ8QJAIADgAAAq4nAg0EADwGDQEtCAENJwIOBAMACAEOAScDDQQBACINAg42DgAHAA4CACINSw4tCw4HACINTQ8tCw8OHAoHDQAEKg0ODyQCAAcAAAL6JwINBAA8Bg0BLQgBBycCDQQCAAgBDQEnAwcEAQAiBwINHzAASwBIAA0AIgdLDi0LDg0cCg0OBBwKDgcALQgBDQAAAQIBJwIOAOMtDg4NLQgBDgAAAQIBJwIRAOQtDhEOLQgBEScCEgQGAAgBEgEnAxEEAQAiEQISHzAATgBLABItCAESAAABAgEnAhMALC0IARQnAhUEBwAIARUBJwMUBAEAIhQCFS0KFRYtDhMWACIWAhYtDEkWACIWAhYtDEkWACIWAhYtDEkWACIWAhYtDEkWACIWAhYtDEkWLQ4UEi0ISAMjAAAD2QwiA04TJAIAEwAAJ68jAAAD6y0LEhEtCAESJwITBAQACAETAScDEgQBACISAhMtChMULQxJFAAiFAIULQxJFAAiFAIULQxJFCsCABMAAAAAAAAAAAYAAAAAAAAAAC0IARQnAhUEBQAIARUBJwMUBAEAIhQCFS0KFRYtDEkWACIWAhYtDEkWACIWAhYtDEkWACIWAhYtDhMWLQgBEwAAAQIBLQ4SEy0IARIAAAECAS0OFBItCAEUAAABAgEtDEgULQgBFQAAAQIBLQxHFS0ISAMjAAAErgwiA0QWJAIAFgAAJ2gjAAAEwCcCFgQXLQgAFy0KExgtChIZLQoUGi0KFRsACAAWACUAACicLQIAAC0KGBEtCw0SLQsOEy0OEg0tDhMOLQgBDScCDgQEAAgBDgEnAw0EAQAiDQIOLQoOEi0MSRIAIhICEi0MSRIAIhICEi0MSRIrAgAOAAAAAAAAAAADAAAAAAAAAAAtCAESJwITBAUACAETAScDEgQBACISAhMtChMULQxJFAAiFAIULQxJFAAiFAIULQxJFAAiFAIULQ4OFC0IAQ4AAAECAS0ODQ4tCAENAAABAgEtDhINLQgBEgAAAQIBLQxIEi0IARMAAAECAS0MRxMnAhQADScCFQQWLQgAFi0KDhctCg0YLQoSGS0KExotChQbAAgAFQAlAAApCC0CAAAnAhQEFS0IABUtCg4WLQoNFy0KEhgtChMZLQoHGgAIABQAJQAAKQgtAgAAJwIHBBQtCAAULQoOFS0KDRYtChIXLQoTGC0KERkACAAHACUAACkILQIAACcCEQQULQgAFC0KDhUtCg0WLQoSFy0KExgACAARACUAACicLQIAAC0KFQcKKg8HDSQCAA0AAAZ0JQAAKgcKIhBJBycCDwQRLQgAEQAIAA8AJQAAKhktAgAALQoSDS0KEw4kAgANAAAGqScCDwQAPAYPAQoqEA4NEioHDQ4kAgAOAAAGwCUAACo/LQgBBycCDQQDAAgBDQEnAwcEAQAiBwINLQoNDi0OBA4AIg4CDi0MTA4nAg4EDy0IAA8tCgcQLQhNES0IRxIACAAOACUAACpRLQIAAC0KEA00AgANLQgBBycCDQQFAAgBDQEnAwcEAQAiBwINLQoNDi0OCg4AIg4CDi0OCQ4AIg4CDi0OCw4AIg4CDi0OCA4tCwcNACINAg0tDg0HLQgBDScCDgQEAAgBDgEnAw0EAQAiDQIOLQoODy0MSQ8AIg8CDy0MSQ8AIg8CDy0MSQ8rAgAOAAAAAAAAAAAEAAAAAAAAAAAtCAEPJwIQBAUACAEQAScDDwQBACIPAhAtChARLQxJEQAiEQIRLQxJEQAiEQIRLQxJEQAiEQIRLQ4OES0IAQ4AAAECAS0ODQ4tCAENAAABAgEtDg8NLQgBDwAAAQIBLQxIDy0IARAAAAECAS0MRxAtCEgDIwAACBsMKgMFESQCABEAACchIwAACC0nAhEEEi0IABItCg4TLQoNFC0KDxUtChAWAAgAEQAlAAAonC0CAAAtChMHLQgBDScCDgQGAAgBDgEnAw0EAQAiDQIOLQoODy0OCg8AIg8CDy0OCQ8AIg8CDy0OCw8AIg8CDy0OCA8AIg8CDy0OBw8tCEgDIwAACKUMIgNOByQCAAcAACb1IwAACLcwCgAMAAQwCABJAAYeAgADADQCAAMtCwIDACIDAgMtDgMCACICAggtCwgHJwIJBAIAKggJAzsOAAcAAyMAAAj3KQIAAwDbK5dbCioBAwcnAgMCAC0IAQgnAgkEIAAIAQkBJwMIBAEAIggCCScCCgQfACoKCQotCgkLDioKCwwkAgAMAAAJSy0OAwsAIgsCCyMAAAkwLQgBCScCCgQhAAgBCgEnAwkEAQAiCQIKJwILBCAAKgsKCy0KCgwOKgsMDSQCAA0AAAmMLQxJDAAiDAIMIwAACXEtCAEKJwILBCEACAELAScDCgQBACIKAgsnAgwEIAAqDAsMLQoLDQ4qDA0OJAIADgAACc0tDgMNACINAg0jAAAJsicCCwQIJwIMAAcnAg0EHyQCAAcAAAnpIwAADqAoAgAOBAEKLQgBDygCABAEAQsACAEQAScDDwQBACIPAhAfMgAOAEsAEC0IARAAAAECAS0ODxAtCAEPAAABAgEtDEgPLQgBEScCEgQKAAgBEgEnAxEEAQAiEQISLQoSEy0MSRMAIhMCEy0MSRMAIhMCEy0MSRMAIhMCEy0MSRMAIhMCEy0MSRMAIhMCEy0MSRMAIhMCEy0MSRMAIhMCEy0MSRMAIhMCEy0MSRMtCAESAAABAgEtDhESJwIRBAktCEgHIwAACq8MKgcREyQCABMAACaAIwAACsEtCxATLQsPFAAqFBEVDioUFRYkAgAWAAAK4CUAACvjLQ4TEC0OFQ8tCxITJwISAwAtCAEUJwIVBAkACAEVAScDFAQBACIUAhUtChUWLQ4SFgAiFgIWLQ4SFgAiFgIWLQ4SFgAiFgIWLQ4SFgAiFgIWLQ4SFgAiFgIWLQ4SFgAiFgIWLQ4SFgAiFgIWLQ4SFi0IARIAAAECAS0OFBItCAEUAAABAgEtDEgUACoTERYtCxYVHAoVFwQcChcWABwKFhUELQhIByMAAAuLDCoHFRYkAgAWAAAl6iMAAAudLQsSES0LFBItCAETKAIAFAQBAgAIARQBJwMTBAEAIhMCFCgCABUEAQEAKhUUFS0KFBYOKhUWFyQCABcAAAvqLQxJFgAiFgIWIwAAC88tCAEUAAABAgEtDhMUKAIAEwQBAS0ISAcjAAAMBwwqBxMVJAIAFQAAJXMjAAAMGS0LEA4tCw8VACoVExYOKhUWFyQCABcAAAw4JQAAK+MtDg4QLQ4WDy0LFA4tCwoPACIPAg8tDg8KLQsKDwAiDwIPLQ4PCi0LCg8AIg8CDy0ODwotCwoPACIPAg8tDg8KLQsKDwAiDwIPLQ4PCi0LCg8AIg8CDy0ODwotCwoPACIPAg8tDg8KLQsKDwAiDwIPLQ4PCi0IAQ8nAhAECQAIARABJwMPBAEAIg8CEC0KEBQtDgoUACIUAhQtDgoUACIUAhQtDgoUACIUAhQtDgoUACIUAhQtDgoUACIUAhQtDgoUACIUAhQtDgoUACIUAhQtDgoULQgBEAAAAQIBLQ4PEC0IAQ8AAAECAS0MSA8AKg4TFS0LFRQcChQWBBwKFhUAHAoVFAQtCwkVACIVAhUtDhUJLQgBFScCFgQhAAgBFgEnAxUEAQAiFQIWJwIXBCAAKhcWFy0KFhgOKhcYGSQCABkAAA2LLQ4DGAAiGAIYIwAADXAtCEgHIwAADZQMKgcUFiQCABYAACP8IwAADaYtCxAOLQsPEB4CAA8AHgIAEwAzKgAPABMAFCQCABQAAA3NJQAAK/UvCgAEAA8nAhUEFi0IABYACAAVACUAACoZLQIAAC0KFxMtChgUJAIAEwAADgMnAhUEADwGFQEKKg8UEyQCABMAAA4VJQAALActCxEPACIPAg8tDg8RLQsODwAiDwIPLQ4PDgoqEhAPJAIADwAADkElAAAsGS0LCA8AIg8CDy0ODwgnAg8EHigCABAAAQAtCEgHIwAADmMMKgcLEyQCABMAACC3IwAADnUtCwIHACIHAgctDgcCACICAg8tCw8OJwIQBAIAKg8QBzsOAA4AByMAAA6gKQIABwCfPRTLCioBBw4oAgAHBAEAJAIADgAADsIjAAAXmy0IAQ8nAhAEBAAIARABJwMPBAEAIg8CEB8wAEYASwAQLQgBEAAAAQIBLQ4PEC0IAQ8AAAECAS0MSA8nAhIEEy0IABMtChAULQoPFQAIABIAJQAALCstAgAALQoUEQAiEUsTLQsTEhwKEhMDHAoTEQAcChESAycCEwQULQgAFC0KEBUtCg8WAAgAEwAlAAAsKy0CAAAtChURACIRSxQtCxQTHAoTFAYcChQRACcCFAQVLQgAFS0KEBYtCg8XAAgAFAAlAAAsKy0CAAAtChYTACITSxAtCxAPHgIAEAAeAgATADMqABAAEwAUJAIAFAAAD7glAAAr9ScCFAQVLQgAFQAIABQAJQAAKhktAgAALQoWEC0KFxMkAgAQAAAP6CcCFAQAPAYUAS0IARAnAhQEAwAIARQBJwMQBAEAIhACFC0KFBUtDgQVACIVAhUtDEwVJwIVBBYtCAAWLQoQFy0ITRgtCEcZAAgAFQAlAAAqUS0CAAAtChcUHgIAEAAzKgAUABAAFSQCABUAABBSJQAALJwtCAEQJwIUBAUACAEUAScDEAQBACIQAhQtChQVLQxJFQAiFQIVLQxJFQAiFQIVLQxJFQAiFQIVLQxJFS0IARQAAAECAS0OEBQtCEgOIwAAEKMMKg4FECQCABAAACBxIwAAELUtCxQQACIQSxUtCxUUACIQRhYtCxYVHAoVFwYcChcWAAAqEAUXLQsXFRwKFRACHAoQBQAtCwgQACIQAhAtDhAILQsIEAAiEAIQLQ4QCC0LCBAAIhACEC0OEAgtCwgQACIQAhAtDhAILQsIEAAiEAIQLQ4QCC0LCBAAIhACEC0OEAgtCwgQACIQAhAtDhAILQgBEAAAAQIBJwIVAwgaKhIVFxwKFxgCHAoYFQMcChUXAhwKEhkCHAoZGAMcChgZAigCABoDAQAEKhUaGwYqGxodCiodFRwkAgAcAAARlyUAACyuACobGBUOKhsVGiQCABoAABGuJQAAK+MKKhUSGCQCABgAABHAJQAALMAnAhUBAC0IARInAhgEEQAIARgBJwMSBAEAIhICGCcCGgQQQwOqABEABwAaABUAGC0IAREnAhUEIAAIARUBJwMRBAEAIhECFS0KFRgtDhcYACIYAhgtDhkYACIYAhgtDgMYACIYAhgtDgMYACIYAhgtDgMYACIYAhgtDgMYACIYAhgtDgMYACIYAhgtDgMYACIYAhgtDgMYACIYAhgtDgMYACIYAhgtDgMYACIYAhgtDgMYACIYAhgtDgMYACIYAhgtDgMYACIYAhgtDgMYACIYAhgtDgMYACIYAhgtDgMYACIYAhgtDgMYACIYAhgtDgMYACIYAhgtDgMYACIYAhgtDgMYACIYAhgtDgMYACIYAhgtDgMYACIYAhgtDgMYACIYAhgtDgMYACIYAhgtDgMYACIYAhgtDgMYACIYAhgtDgMYACIYAhgtDgMYACIYAhgtDgMYACIYAhgtDgMYLQgBFScCFwQJAAgBFwEnAxUEAQAiFQIXLQoXGC0OERgAIhgCGC0OCBgAIhgCGC0OCBgAIhgCGC0OCBgAIhgCGC0OCBgAIhgCGC0OCBgAIhgCGC0OCBgAIhgCGC0OCBgtDhUQJwIIBBAtCEgOIwAAE44MKg4IESQCABEAAB/lIwAAE6AtCxAOLQgBEAAAAQIBLQgBEQAAAQIBLQgBEicCFQT+AAgBFQEnAxIEAQAiEgIVJwIXBP0AKhcVFy0KFRgOKhcYGSQCABkAABP3LQxJGAAiGAIYIwAAE9wtDhIQLQxLES0IARInAhUE+QAIARUBJwMSBAEAIhICFScCFwT4ACoXFRctChUYDioXGBkkAgAZAAAUQC0MSRgAIhgCGCMAABQlLQgBFQAAAQIBLQ4SFS0IARInAhcEIAAIARcBJwMSBAEAIhICFycCGAQfACoYFxgtChcZDioYGRokAgAaAAAUji0MSRkAIhkCGSMAABRzJwIXBPgtCEgIIwAAFJwMKggLGCQCABgAAB6tIwAAFK4tCxULJwIOBP0tCEgIIwAAFMAMKggXEiQCABIAAB48IwAAFNItCxEIACoIFwsOKggLEiQCABIAABTtJQAAK+MtCxAIDCoLDhIkAgASAAAVAyUAACzSLQIIAycABAT+JQAALOQtCAUSACISAhUAKhULFy0OFhcAIgtLCA4qCwgVJAIAFQAAFTolAAAr4wwqCA4LJAIACwAAFUwlAAAs0i0CEgMnAAQE/iUAACzkLQgFCwAiCwIVACoVCBYtDgUWACIISwUOKggFEiQCABIAABWDJQAAK+MMKgUOCCQCAAgAABWVJQAALNItAgsDJwAEBP4lAAAs5C0IBQgAIggCEgAqEgUVLQ4TFQAiBUsLDioFCxIkAgASAAAVzCUAACvjDCoLDgUkAgAFAAAV3iUAACzSLQIIAycABAT+JQAALOQtCAUFACIFAhIAKhILEy0ODxMtDgUQACILSwgOKgsIDyQCAA8AABYZJQAAK+MtDggRJwIPBP0GIg8CCCcCEQQDACoPERAtCAELAAgBEAEnAwsEAQAiCwIQLQ4PEAAiEAIQLQ4PECcCEQQDACoLERAAIgUCES0CEQMtAhAELQIPBSUAAC1ILQsLBQAiBQIFLQ4FCykCAAUAZe/OfgAiDgIPLQIOAy0CCwQnAAUEASUAAC16LQgGEC0IBxEtDgURACIQAg4tCw4LJwIRBAIAKg4RBTkDoABFAEUAFAALAAUgAgAFIQIACy0IAQ8AIg8CEi0LEhEnAhMEAgAqEhMQIjIACwBIABAtCgsRJwITBAMAKhETEgAIARIBJwMPBAEAIg8CEy0OERMAIhMCEy0OERMtChEOBiIOAg4kAgAFAAAXWiMAABcxLQsPBQAiBQIFLQ4FDwAiDwILLQsLCCcCEAQCACoLEAU8DggFIwAAF1oKIg5LBSQCAAUAABdwJwIIBAA8BggBLQsCBQAiBQIFLQ4FAgAiAgILLQsLCCcCDgQCACoLDgU7DgAIAAUjAAAXmykCAAUAyFykmwoqAQUIJAIACAAAF7YjAAAbhi0IAQgnAgsEIwAIAQsBJwMIBAEAIggCCx8wAFAASwALLQgBCwAAAQIBLQ4ICy0IAQgAAAECAS0MSAgnAg8EEC0IABAtCgsRLQoIEgAIAA8AJQAALnstAgAALQoRDgAiDksQLQsQDxwKDxADHAoQDgAtCwkPACIPAg8tDg8JLQgBDwAAAQIBLQ4JDy0ISAUjAAAYSQwiBU8JJAIACQAAHccjAAAYWy0LCwktCwgQACIQTxEOKhAREiQCABIAABh6JQAAK+MtDgkLLQ4RCC0LDwktCAEPAAABAgEtDgkPLQgBCQAAAQIBLQxICS0LChAAIhACEC0OEAonAhEEEi0IABItCg8TLQoJFC0KChUACAARACUAAC7sLQIAAC0KExAnAgoEES0IABEtCgsSLQoIEwAIAAoAJQAALnstAgAALQoSCQAiCUsKLQsKCBwKCAoGHAoKCQAeAgAIAB4CAAoAMyoACAAKAAskAgALAAAZKSUAACv1JwILBBEtCAARAAgACwAlAAAqGS0CAAAtChIILQoTCiQCAAgAABlZJwILBAA8BgsBHgIACAAKKgoICyQCAAsAABlwJQAAL6otCAEIJwIKBAMACAEKAScDCAQBACIIAgotCgoLLQ4MCwAiCwILLQ4OCycCCwQRLQgAES0KCBItCE0TLQhHFAAIAAsAJQAAL7wtAgAALQoSCgoiCkkICiIIRwskAgALAAAZ1yUAADFOLQgBCCcCCwQDAAgBCwEnAwgEAQAiCAILLQoLDC0OBAwAIgwCDC0OCgwnAgsEES0IABEtCggSLQhNEy0IRxQACAALACUAACpRLQIAAC0KEgQeAgAIADMqAAQACAALJAIACwAAGkElAAAsnC8KAAoABAAiCkwILwoACAAKJwILAQAtCAEIJwIMBCAACAEMAScDCAQBACIIAgwnAg4EH0MDqgAEAAcADgALAAwtCAEEJwIHBCEACAEHAScDBAQBACIEAgcnAgsEIAAqCwcLLQoHDA4qCwwOJAIADgAAGsItDgMMACIMAgwjAAAapy0IAQMAAAECAS0OBAMtCEgFIwAAGtgMKgUNBCQCAAQAAB2DIwAAGuocCgoHAhwKBwUAHAoFBwItCwMFLQIFAycABAQhJQAALOQtCAUIACIITwotDgcKLQ4IAy0IAQMAAAECAS0MSgMtCEgEIwAAGzIMIgRPBSQCAAUAAB1HIwAAG0QtCwMEJAIABAAAG1UlAAAxYDAKAAkABi0LAgMAIgMCAy0OAwIAIgICBS0LBQQnAgYEAgAqBQYDOw4ABAADIwAAG4YnAgICVScCAwJuJwIEAmsnAgUCbycCBgJ3JwIHAiAnAggCcycCCQJlJwIKAmwnAgsCYycCDAJ0JwINAnInAg4CeycCDwJ9LQgBECcCEQQcAAgBEQEnAxAEAQAiEAIRLQoREi0OAhIAIhICEi0OAxIAIhICEi0OBBIAIhICEi0OAxIAIhICEi0OBRIAIhICEi0OBhIAIhICEi0OAxIAIhICEi0OBxIAIhICEi0OCBIAIhICEi0OCRIAIhICEi0OChIAIhICEi0OCRIAIhICEi0OCxIAIhICEi0ODBIAIhICEi0OBRIAIhICEi0ODRIAIhICEi0OBxIAIhICEi0ODhIAIhICEi0OCBIAIhICEi0OCRIAIhICEi0OChIAIhICEi0OCRIAIhICEi0OCxIAIhICEi0ODBIAIhICEi0OBRIAIhICEi0ODRIAIhICEi0ODxIKIEdKAiQCAAIAAB1HJwIDBB4tCAEEJwIFBB4ACAEFAS0KBAUqAwAFBelJQ+ibN90sACIFAgUAIhACBicCBwQbLQIGAy0CBQQtAgcFJQAALUgnAgYEGwAqBQYFLQxMBQAiBQIFLQ4BBQAiBQIFPA4DBC0LAwUAIggCCgAqCgQLLQsLBwAiEAILACoLBAwtCwwKCioHCgsEKgULBy0OBwMAIgRLBS0KBQQjAAAbMgAiCAIHACoHBQstCwsELQsDBy0CBwMnAAQEISUAACzkLQgFCwAiCwIMACoMBQ4tDgQOLQ4LAwAiBUsELQoEBSMAABrYLQsLCS0LCBAAKhAFEQ4qEBESJAIAEgAAHeYlAAAr4wwiEVAQJAIAEAAAHfglAAAs0gAiCQISACoSERMtCxMQLQsPCS0CCQMnAAQEISUAACzkLQgFEQAiEQISACoSBRMtDhATLQ4RDwAiBUsJLQoJBSMAABhJLQsREgAqCBIVDioIFRgkAgAYAAAeVyUAACvjACILAhgAKhgIGS0LGRItCxAYDCoVDhkkAgAZAAAeeyUAACzSLQIYAycABAT+JQAALOQtCAUZACIZAhoAKhoVGy0OEhstDhkQACIISxItChIIIwAAFMAAIg4CGgAqGggbLQsbGS0LGRoAIhoCGi0OGhktCxIaACIaAhotDhoSLQgBGgAAAQIBLQ4SGi0ISBgjAAAe6wwqGA0bJAIAGwAAH5wjAAAe/S0LGhkEKggNGi0ISBgjAAAfDwwqGA0bJAIAGwAAHy8jAAAfIQAiCEsYLQoYCCMAABScACoaGBsOKhobHCQCABwAAB9GJQAAK+MAIhkCHQAqHRgeLQseHC0LFR0MKhsXHiQCAB4AAB9qJQAALNItAh0DJwAEBPklAAAs5C0IBR4AIh4CHwAqHxsgLQ4cIC0OHhUAIhhLGy0KGxgjAAAfDwAiGQIcACocGB0tCx0bHAobHAAtCxobLQIbAycABAQgJQAALOQtCAUdACIdAh4AKh4YHy0OHB8tDh0aACIYSxstChsYIwAAHusAKE0OEQAiEgIXACoXDhgtCxgVLQsQFwAiF0sZLQsZGC0LGBkAIhkCGS0OGRgMKhENGSQCABkAACAkJQAALNItAhgDJwAEBCAlAAAs5C0IBRkAIhkCGgAqGhEbLQ4VGy0CFwMnAAQECSUAACzkLQgFEQAiEUsVLQ4ZFS0OERAAIg5LES0KEQ4jAAATjhwKDhAAAChMEBUvCgAVABAtCxQVLQIVAycABAQFJQAALOQtCAUWACIWAhcAKhcOGC0OEBgtDhYUACIOSxAtChAOIwAAEKMtCxETACITAhMtDhMRDCoHEhMkAgATAAAg1iMAACMVLQsRFAAiFAIULQ4UEQAiEQIVACoVBxYtCxYULQsOFQAiFQIVLQ4VDgAiDgIWACoWBxctCxcVLQsVFgAiFgIWLQ4WFRwKFBYALQgBFCcCFwQDAAgBFwEnAxQEAQAiFAIXLQoXGC0ODBgAIhgCGC0OFhgnAhcEGC0IABgtChQZLQhNGi0IRxsACAAXACUAAC+8LQIAAC0KGRYKIhZJFAoiFEcXJAIAFwAAIYUlAAAxTi0IARQnAhcEAwAIARcBJwMUBAEAIhQCFy0KFxgtDgQYACIYAhgtDhYYJwIYBBktCAAZLQoUGi0ITRstCEccAAgAGAAlAAAqUS0CAAAtChoXNAIAFy0LFRQAIhQCFC0OFBUtCwgUACIUAhQtDhQILQgBFAAAAQIBLQ4IFC0ISBMjAAAiCQwqEw0XJAIAFwAAI7gjAAAiGy0LFBctCAEUAAABAgEtDEwULQgBGAAAAQIBLQxJGC0ISBMjAAAiQgwqEw0ZJAIAGQAAI08jAAAiVC0LGBQAIhVPGC0LGBccChcVAC0IARcnAhgEAwAIARgBJwMXBAEAIhcCGC0KGBktDhQZACIZAhktDhUZLQsXGAAiGAIYLQ4YFycCGQQaLQgAGi0KFxstCE0cLQhHHQAIABkAJQAAL7wtAgAALQobGC0IARcnAhkEBAAIARkBJwMXBAEAIhcCGS0KGRotDhQaACIaAhotDhUaACIaAhotDhgaLQhIEyMAACL+DCITRhQkAgAUAAAjIyMAACMQIwAAIxUAIgdLEy0KEwcjAAAOYxwKExQAACoWFBUAIhcCGAAqGBMZLQsZFDAKABQAFQAiE0sULQoUEyMAACL+LQsYGQIqDxMaDioTDxskAgAbAAAjaiUAADFyDCoaDRskAgAbAAAjfCUAACzSACIXAhwAKhwaHS0LHRscChsaAC0LFBsEKhobHAAqGRwaLQ4aGAQqGxAZLQ4ZFAAiE0sZLQoZEyMAACJCACIVAhgAKhgTGS0LGRctCxQYLQIYAycABAQgJQAALOQtCAUZACIZAhoAKhoTGy0OFxstDhkUACITSxctChcTIwAAIgktCwkXACIXAhctDhcJLQgBFwAAAQIBLQ4JFwQiB08YBiIYTxoKKhoHGSQCABkAACQyJQAALK4tCEgWIwAAJDsMIhZPGSQCABkAACUGIwAAJE0tCxcWLQgBFwAAAQIBLQ4WFy0IARYAAAECAS0MSBYtCxUYACIYAhgtDhgVJwIZBBotCAAaLQoXGy0KFhwtChUdAAgAGQAlAAAu7C0CAAAtChsYLQsQFi0LDxcMKhcLGSQCABkAACS5JQAAMYQtAhYDJwAEBAklAAAs5C0IBRkAIhkCGgAqGhcbLQ4YGwAiF0sWDioXFhgkAgAYAAAk8CUAACvjLQ4ZEC0OFg8AIgdLFi0KFgcjAAANlAAqGBYZDioYGRokAgAaAAAlHSUAACvjDCoZExokAgAaAAAlLyUAACzSACIOAhsAKhsZHC0LHBotCxcZLQIZAycABAQhJQAALOQtCAUbACIbAhwAKhwWHS0OGh0tDhsXACIWSxktChkWIwAAJDstCxAVLQsPFgAqFgcXDioWFxgkAgAYAAAlkiUAACvjDCoXDhYkAgAWAAAlpCUAACzSACIVAhgAKhgXGS0LGRYtCxQVLQIVAygAAAQEAQIlAAAs5C0IBRcAIhcCGAAqGAcZLQ4WGS0OFxQAIgdLFS0KFQcjAAAMBwwqBxEWJAIAFgAAJfwlAAAs0gAiEwIXACoXBxgtCxgWHAoWGAMcChgXABwKFxYDLQsSFy0LFBgMKhgLGSQCABkAACYzJQAAMYQtAhcDJwAEBAklAAAs5C0IBRkAIhkCGgAqGhgbLQ4WGwAiGEsWDioYFhckAgAXAAAmaiUAACvjLQ4ZEi0OFhQAIgdLFi0KFgcjAAALiy0LEBMtCw8UACoUBxUOKhQVFiQCABYAACafJQAAK+MMKhUOFCQCABQAACaxJQAALNIAIhMCFgAqFhUXLQsXFC0LEhMtAhMDJwAEBAolAAAs5C0IBRUAIhUCFgAqFgcXLQ4UFy0OFRIAIgdLEy0KEwcjAAAKrxwKAwcAAChMBwgAIg0CCQAqCQMKLQsKBzAKAAcACAAiA0sHLQoHAyMAAAilACIHAhIAKhIDEy0LExEnAhIEEy0IABMtCg4ULQoNFS0KDxYtChAXLQoRGAAIABIAJQAAKQgtAgAAACIDSxEtChEDIwAACBsAIhECFwAqFwMYLQsYFicCFwQYLQgAGC0KExktChIaLQoUGy0KFRwtChYdAAgAFwAlAAApCC0CAAAAIgNLFi0KFgMjAAAErgAiA0sTACIRAhUAKhUDFi0LFhQtCxIVDCITRBYkAgAWAAAn2CUAACzSLQIVAycABAQHJQAALOQtCAUWACIWAhcAKhcTGC0OFBgtDhYSLQoTAyMAAAPZKAAABAR4UwwAAAQDJAAAAwAAKCoqAQABBdrF9da0SjJtPAQCASYlAAAoBS0LAgMtCwEEDCIDTgUkAgAFAAAoSiUAACzSACIEAgYAKgYDBy0LBwUtCAEGJwIHBAIACAEHAScDBgQBACIGAgctCgcILQ4FCAAiA0sFDioDBQckAgAHAAAojyUAACvjLQ4EAS0OBQItCgYBJiUAACgFLQsEBQoiBUcGJAIABgAAKLsnAgcEADwGBwEnAgUEBi0IAAYtCgEHLQoCCC0KAwktCgQKAAgABQAlAAAxli0CAAAtCwEFLQsCBi0LAwctDgUBLQ4GAi0OBwMtDEoEACIGSwItCwIBJiUAACgFLQsEBgoiBkcHJAIABwAAKScnAggEADwGCAEtCwMGCiIGRgckAgAHAAApoyMAACk9LQsBBy0LAggMIgZGCSQCAAkAAClXJQAALNItAgcDJwAEBAQlAAAs5C0IBQkAIgkCCgAqCgYLLQ4FCwAiBksFDioGBQckAgAHAAApjiUAACvjLQ4JAS0OCAItDgUDLQxHBCMAACoGJwIGBActCAAHLQoBCC0KAgktCgMKLQoECwAIAAYAJQAAMZYtAgAALQsBBi0LAgctCwQILQIGAycABAQEJQAALOQtCAUJACIJSwotDgUKLQ4JAS0OBwItDEsDLQ4IBCMAACoGJioBAAEFilU6LCtnyO88BAIBJiUAACgFHgIAAQEKIgFDAhYKAgMcCgMCAAQqAgEELQoEAi0KAwEmKgEAAQXIDXNzbs204TwEAgEmJQAAKAUcCgIFAAQiBVEGLQgBBScCBwQEAAgBBwEnAwUEAQAiBQIHLQoHCC0MSQgAIggCCC0MSQgAIggCCC0MSQgtCAEHJwIIBAUACAEIAScDBwQBACIHAggtCggJLQxJCQAiCQIJLQxJCQAiCQIJLQxJCQAiCQIJLQ4GCS0IAQYAAAECAS0OBQYtCAEFAAABAgEtDgcFLQgBBwAAAQIBLQxIBy0IAQgAAAECAS0MRwgtCEgEIwAAKwoMIgRNCSQCAAkAACuFIwAAKxwkAgADAAArKSMAACtZJwIBBAktCAAJLQoGCi0KBQstCgcMLQoIDS0ITA4ACAABACUAACkILQIAACMAACtZJwICBAktCAAJLQoGCi0KBQstCgcMLQoIDQAIAAIAJQAAKJwtAgAALQoKASYMKgQCCSQCAAkAACuXIwAAK9UAIgECCgAqCgQLLQsLCScCCgQLLQgACy0KBgwtCgUNLQoHDi0KCA8tCgkQAAgACgAlAAApCC0CAAAjAAAr1QAiBEsJLQoJBCMAACsKKgEAAQXQB+v0y8ZnkDwEAgEmKgEAAQUGYTs9C529MzwEAgEmKgEAAQVeNCZs0j+/RzwEAgEmKgEAAQX2iy2h4RphXjwEAgEmJQAAKAUtCwIDLQsBBAwiA0YFJAIABQAALEolAAAs0gAiBAIGACoGAwctCwcFLQgBBicCBwQCAAgBBwEnAwYEAQAiBgIHLQoHCC0OBQgAIgNLBQ4qAwUHJAIABwAALI8lAAAr4y0OBAEtDgUCLQoGASYqAQABBXIxDJYzrKc/PAQCASYqAQABBQUEG5kgr2BMPAQCASYqAQABBdfAZ6Fg/4AqPAQCASYqAQABBeQIUEUCtYwfPAQCASYtAQMGCgAGAgckAAAHAAAs+iMAAC0DLQADBSMAAC1HLQABBQAAAQQBAAADBAktAAMKLQAFCwoACgkMJAAADAAALT0tAQoILQQICwAACgIKAAALAgsjAAAtGScBBQQBAgAGAgYmAAADBQctAAMILQAECQoACAcKJAAACgAALXktAQgGLQQGCQAACAIIAAAJAgkjAAAtVSYtAQQIAAAEAgwEAAMFCQAADAIMLQEMCgAADAILAAAJBQwOAAwKDQoACAIOJAAADQAALbIjAAAuACQAAA4AAC2/IwAALdEtAAQGAAAGAg8tBAwPIwAALfsnABAEAwAAChAPLQABBgAAAQ8BJwEGBAEAAAYCDy0EDA8AAA8CDy0ECg8jAAAuNCcAEAQCBAAMEA8nABEEAwAADxEQLQABBgAAARABJwEGBAEAAAYCEC0EDBAAABACEC0EDxAnAA4EAwAABg4NAAANBQ4CAAkCDwAADg8QAAALDxEMABELDyQAAA8AAC52LQEREi0EEhACABECEQIAEAIQIwAALlItAA0HJiUAACgFLQsCAy0LAQQMIgNQBSQCAAUAAC6aJQAALNIAIgQCBgAqBgMHLQsHBS0IAQYnAgcEAgAIAQcBJwMGBAEAIgYCBy0KBwgtDgUIACIDSwUOKgMFByQCAAcAAC7fJQAAK+MtDgQBLQ4FAi0KBgEmJQAAKAUtCAEFAAABAgEtDgMFLQhIBCMAAC8HDCIETwMkAgADAAAvHiMAAC8ZLQsFASYtCwEDLQsCBgwiBk8HJAIABwAALzglAAAs0gAiAwIIACoIBgktCwkHACIGSwgOKgYICSQCAAkAAC9dJQAAK+MtDgMBLQ4IAhwKBwYCHAoGAwAcCgMGAi0LBQMtAgMDJwAEBCElAAAs5C0IBQcAIgcCCAAqCAQJLQ4GCS0OBwUAIgRLAy0KAwQjAAAvByoBAAEFoOgprtV0yfo8BAIBJiUAACgFHAoCBQAEIgVRBi0IAQUnAgcEBAAIAQcBJwMFBAEAIgUCBy0KBwgtDEkIACIIAggtDEkIACIIAggtDEkILQgBBycCCAQFAAgBCAEnAwcEAQAiBwIILQoICS0MSQkAIgkCCS0MSQkAIgkCCS0MSQkAIgkCCS0OBgktCAEGAAABAgEtDgUGLQgBBQAAAQIBLQ4HBS0IAQcAAAECAS0MSActCAEIAAABAgEtDEcILQhIBCMAADB1DCIETQkkAgAJAAAw8CMAADCHJAIAAwAAMJQjAAAwxCcCAQQJLQgACS0KBgotCgULLQoHDC0KCA0tCEwOAAgAAQAlAAApCC0CAAAjAAAwxCcCAgQJLQgACS0KBgotCgULLQoHDC0KCA0ACAACACUAACicLQIAAC0KCgEmDCoEAgkkAgAJAAAxAiMAADFAACIBAgoAKgoECy0LCwknAgoECy0IAAstCgYMLQoFDS0KBw4tCggPLQoJEAAIAAoAJQAAKQgtAgAAIwAAMUAAIgRLCS0KCQQjAAAwdSoBAAEFursh14IzGGQ8BAIBJioBAAEF/DQEQ4mUy908BAIBJioBAAEFG7xl0D/c6tw8BAIBJioBAAEFszUsOg1YJoA8BAIBJiUAACgFLQhIBSMAADGkDCIFRgYkAgAGAAAyDCMAADG2LQsCBS0LBQYAIgYCBi0OBgUtCAEGJwIHBAUACAEHAScDBgQBACIFAgcnAggEBAAiBgIJPw8ABwAJLQsBBS0LAwctCwQILQ4FAS0OBgItDgcDLQ4IBCYtCwMGDCoFBgckAgAHAAAyIiMAADKELQsCBwAiBwIJACoJBQotCwoILQsBCQAiCQILACoLBQwtCwwKACoICgstCwQILQIHAycABAQFJQAALOQtCAUKACIKAgwAKgwFDS0OCw0tDgkBLQ4KAi0OBgMtDggEIwAAMoQAIgVLBi0KBgUjAAAxpA==",
      "custom_attributes": [
        "external",
        "public"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "public_dispatch"
    },
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "14067204867181196045": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15711892660910782274": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16216212843441549037": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "2014890719615096298": {
            "error_kind": "string",
            "string": "Field failed to decompose into specified 40 limbs"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "3378875131383195299": {
            "error_kind": "string",
            "string": "Invalid destination chain ID"
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "4648451262681811962": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "7555607922535724711": {
            "error_kind": "string",
            "string": "Preimage mismatch"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9589626482238399944": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "9921926525851912681": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "anchor_block_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "sponge_blob_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "vaa",
            "type": {
              "kind": "array",
              "length": 2000,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "length",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "note_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 32,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "log",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "fields",
                                          "type": {
                                            "kind": "array",
                                            "length": 18,
                                            "type": {
                                              "kind": "field"
                                            }
                                          }
                                        },
                                        {
                                          "name": "length",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::log::Log"
                                    }
                                  },
                                  {
                                    "name": "note_hash_counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "anchor_block_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "sponge_blob_hash",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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hS6X0OUWujxCl1fo8gldfqErIHQFha6Q0BUWuiJCV1ToigldcaErIXQlha6U0JUWujJCV1boygldeaGrIHQVha6S0FUWuipCV1XoqglddaGrIXQ1ha6W0NUWujpCV1fo6gldfaFrIHQNha6R0DUWuiZC11Tomgldc6FrIXQtha6V0LUWujZC11bo2glde6HrIHQdha6T0HUWui5C11Xougldd6HrIXQ9ha6X0PUWuj5C11fo+gldf6EbIHQDhW6Q0A0WuiFCN1TohgndcKEbIXQjhW6U0I0WujFCN1boxgndeKGbIHQThW6S0E0WuilCN1XopgnddKGbIXQzhW6W0M0WujlCN1fo5gndfKFbIHQLhW6R0C0WuiVCt1TolgndcqFbIXQrhW6V0K0WujVCt1bo1gndeqHbIHQbhW6T0G0Wui1Ct1XotgnddqHbIXQ7hW6X0O0Wuj1Ct1fo9gndfqE7IHQHhe6Q0B0WuiNCd1TojgndcaE7IXQnhe6U0J0WujNCd1bozgndeaG7IHQXhe6S0F0WuitCd1XorgnddaG7IXQ3he6W0N0WujtCd1fo7gndfaF7IHQPhe6R0D0WuidC91Tongndc6F7IXQvhe6V0L0WujdC91bo3gnde6H7IHQfhe6T0H0Wui9C91Xovgndd6H7IXS+/P/3zkfofAudH6HzK3T+hM6/0AUQuoBCF0joAgtdEKELKnTBhC640IUQupBCF0roQgtdGKELK3ThhC680EUQuohCF0noIgtdFKGLKnTRhC660MUQuphCF0voYgtdHKGLK3TxhC6+0CUQuoRCl0joEgtdEqFLKnTJhC650KUQupRCl0roUgtdGqFLK3TphC690GUQuoxCl0noMgtdFqHLKnTZhC670OUQupxCl0vocgtdHqHLK3T5hC6/0BUQuoJCV0joCgtdEaErKnTFhK640JUQupJCV0roSgtdGaErK3TlhK680FUQuopCV0noKgtdFaGrKnTVhK660NUQuppCV0voagtdHaGrK3T1hK6+0DUQuoZC10joGgtdE6FrKnTNhK650LUQupZC10roWgtdG6FrK3TthK690HUQuo5C10noOgtdF6HrKnTdhK670PUQup5C10voegtdH6HrK3T9hK6/0A0QuoFCN0joBgvdEKEbKnTDhG640I0QupFCN0roRgvdGKEbK3TjhG680E0QuolCN0noJgvdFKGbKnTThG660M0QuplCN0voZgvdHKGbK3TzhG6+0C0QuoVCt0joFgvdEqFbKnTLhG650K0QupVCt0roVgvdGqFbK3TrhG690G0Quo1Ct0noNgvdFqHbKnTbhG670O0Qup1Ct0vodgvdHqHbK3T7hG6/0B0QuoNCd0joDgvdEaE7KnTHhO640J0QupNCd0roTgvdGaE7K3TnhO680F0QuotCd0noLgvdFaG7KnTXhO660N0QuptCd0vobgvdHaG7K3T3hO6+0D0QuodC90joHgvdE6F7KnTPhO650L0QupdC90roXgvdG6F7K3TvhO690H0Quo9C90noPgvdF6H7KnTfhO670P0QOl8B/nvnI3S+hc6P0PkVOn9C51/oAghdQKELJHSBhS6I0AUVumBCF1zoQghdSKELJXShhS6M0IUVunBCF17oIghdRKGLJHSRhS6K0EUVumhCF13oYghdTKGLJXSxhS6O0MUVunhCF1/oEghdQqFLJHSJhS6J0CUVumRCl1zoUghdSqFLJXSphS6N0KUVunRCl17oMghdRqHLJHSZhS6L0GUVumxCl13ocghdTqHLJXS5hS6P0OUVunxCl1/oCghdQaErJHSFha6I0BUVumJCV1zoSghdSaErJXSlha6M0JUVunJCV17oKghdRaGrJHSVha6K0FUVumpCV13oaghdTaGrJXS1ha6O0NUVunpCV1/oGghdQ6FrJHSNha6J0DUVumZC11zoWghdS6FrJXStha6N0LUVunZC117oOghdR6HrJHSdha6L0HUVum5C113oeghdT6HrJXS9ha6P0PUVun5C11/oBgjdQKEbJHSDhW6I0A0VumFCN1zoRgjdSKEbJXSjhW6M0I0VunFCN17oJgjdRKGbJHSThW6K0E0VumlCN13oZgjdTKGbJXSzhW6O0M0VunlCN1/oFgjdQqFbJHSLhW6J0C0VumVCt1zoVgjdSqFbJXSrhW6N0K0VunVCt17oNgjdRqHbJHSbhW6L0G0Vum1Ct13odgjdTqHbJXS7hW6P0O0Vun1Ct1/oDgjdQaE7JHSHhe6I0B0VumNCd1zoTgjdSaE7JXSnhe6M0J0VunNCd17oLgjdRaG7JHSXhe6K0F0VumtCd13obgjdTaG7JXS3he6O0N0VuntCd1/oHgjdQ6F7JHSPhe6J0D0V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79gCuOvemeeub/6hXRz/lsBd93t77vrmH8Zl10P3+7lnaJ1hdLr75rkXVs7hJOElEVy/fya6h1bAXTfXc9e3PUR0cd6xNXDXvTPPXd/8I7k4/m2Au+739tz1zT+yy66H7vdzz0g6I+t0981zL4qco0qiSaK7fv9MdA9tgbturueub3uI4eK8Yzvgrntnnru++cd0cfzbA3fd7+2565t/LJddD93v554xdcbS6e6b515sOcdxcyRxXb9/JrqHDsBdN9dz17c9xHNx3rEjcPd/dqb/h2/+8V0c/07AXfd7e+765p/AZddD9/u5Z3ydCXTGdf37XkI5J5IkliRx/f6Z6B46A3fdXM9d3/aQ1MV5xy7AXffOPHd980/m4vh3Be6639tz1zf/5C67Hrrfzz2T6Uyu0903z70Uck4pSSVJ7fr9M9E9dAPuurmeu77tIY2L847dgbvunXnu+ubv4+L49wDuut/bc9c3/7Quux663889fXSm1enum+deOjmnl2SQZHT9/pnoHnoCd91cz13f9pDJxXnHXsBd9848d33zz+zi+PcG7rrf23PXN/8sLrseut/PPTPrzKLT3TfPvaxyzibJLsnh+v0z0T30Ae66uZ67vu0hp4vzjn2Bu+6dee765p/LxfHvB9x1v7fnrm/+uV12PXS/n3vm0plbp7tvnnt55JxXkk+S3/X7Z6J76A/cdXM9d33bQwEX5x0HAHfdO/Pc9c2/oIvjPxC4635vz13f/Au57Hrofj/3LKizkE533zz3Csu5iKSopJjr989E9zAIuOvmeu76tofiLs47DgbuunfmueubfwkXx38IcNf93p67vvmXdNn10P1+7llCZ0md7r557pWSc2lJGUlZ1++fie5hKHDXzfXc9W0P5VycdxwG3HXvzHPXN//yLo7/cOCu+709d33zr+Cy66H7/dyzvM4KOt1989yrKOdKksqSKq7fPxPdwwjgrpvruevbHqq6OO84Erjr3pnnrq//Sy4ujv8o4K77vT13ff1fYnHZ9dD9fu5ZTWd1ne6+ee7VkHNNSS1Jbdfvn4nuYTRw18313PX1f3DAxXnHMcBd9848d339HyZwcfzHAnfd7+256+v/SIDLrod1XP+adXXW0+num+defTk3kDSUNHL9/pnoHsYBd91cz13f9tDYxXnH8cBd9848d33zb+Li+E8A7rrf23PXN/+mLrseut/PPZvobKrT3TfPvWZybi5pIWnp+v0z0T1MBO66uZ67vu2hlYvzjpOAu+6dee765t/axfGfDNx1v7fnrm/+bVx2PXS/n3u21tlGp7tvnntt5dxO0l7SwfX7Z6J7mALcdXM9d33bQ0cX5x2nAnfdO/Pc9c2/k4vjPw24635vz13f/Du77Hrofj/37KSzs0533zz3usi5q6SbpLvr989E9zAduOvmeu76toceLs47zgDuunfmueubf08Xx38mcNf93p67vvn3ctn10P1+7tlTZy+d7r557vWWcx9JX0k/1++fie5hFnDXzfXc9W0P/V2cd5wN3O3j8rv/ABfHfw5w1/3enru++Q902fXQ/X7uOUDnQJ3uvnnuDZLzYMkQyVDX75+J7mEucNfN9dz1bQ/DXJx3nAfcde/Mc9c3/+Eujv984K77vT13ffMf4bLrofv93HO4zhE63X3z3Bsp51GS0ZIxrt8/E93DAuCum+u569sexro477gQuOvemeeub/7jXBz/RcBd93t77vrmP95l10P3+7nnOJ3jdbr75rk3Qc4TJZMkk12/fya6h8XAXTfXc9e3PUxxcd5xCXDXvTPPXd/8p7o4/kuBu+739tz1zX+ay66H7vdzz6k6p+l0981zb7qcZ0hmSma5fv9MdA/LgLturueub3uY7eK843Lgrntnnru++c9xcfxXAHfd7+2565v/XJddD93v555zdM7V6e6b5948Oc+XLJAsdP3+megeVgJ33VzPXd/2sMjFecdVwF33zjx3ffNf7OL4rwbuut/bc9c3/yUuux663889F+tcotPdN8+9pXJeJlkuWeH6/TPRPawB7rq5nru+7WGli/OOa4G77p157vrmv8rF8V8H3HW/t+eub/6rXXY9dL+fe67SuVqnu2+ee2vkvFayTrLe9ftnontYD9x1cz13fdvDBhfnHTcAd90789z1zX+ji+O/Ebjrfm/PXd/8N7nseuh+P/fcqHOTTnffPPc2y3mLZKtkm+v3z0T3sAm46+Z67vq2h+0uzjtuBu66d+a565v/DhfHfwtw1/3enru++e902fXQ/X7uuUPnTp3uvnnu7ZLzbskeyV7X75+J7mErcNfN9dz1bQ/7XJx33Abcde/Mc9c3//0ujv924O4el9/9D7jseuh+P/fcr/OATnffPPcOyvmQ5LDkiOv3z0T3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mZJZktmSOZK5knmS+ZIFkoWSRZLFkiWSpZJlkuWSFZKVklWS1ZI1krWSdZL1kg2SjZJNks2SLZKtkm2S7ZIdkp2SXZLdkj2SvZJ9kv2SA5KDkkOSw5IjkqOSY5LjkhOSk5JTktOSM5KzknOS85ILkouSS5LLkiuSq5JrkuuSG5KbkluS25I7kruSe5L7kgeSh5JHkseSJ5KnkmeS55IXkpeSV5LXkjeSt5J3kv+PvSuBk6K43j3ssDCwMCAeKKirqCjghYgoKiIIoiAgAkajcgZRBOXwSoy7CN54gbfGxTuJR+77n8SY25j7NPcdcx/mvv6v4rzdb799XdPdU7OMMv37fb+d7ap6r+rVq1evXldXvyT4s+Avgr8K/ib4u+Afgn8K/iX4t+A/gv8KXBA8J+ghaBDkBT0FjYJegt6CgqCPoK+gSdBP0F9QFAwQDBTsIBgk2FGwk2BnwS6CwYJdBbsJhgiGCnYX7CHY071HI9hLsLdgmGAfwb6C/QTDBfsLDhCMEIwUjBIcKDhIcLDgEMGhgtGCwwRjBIcLxgqOEIwTHCk4SjBecLTgGMGxggmC4wQTBccLJgkmC04QTBG479S7b8i777u7b6+776K7b5a774m7b32773C7b2S771e7b0u77z67bzK77yW7bxm77wy7bwC77/O6b+e679q6b86678G6b7W676i6b5y674+6b4O673a6b2q67126b1G670S6bzi67yu6bx+67xK6bwa67/m5b+257+C5b9S578e5b7u57665b6K575W5b4m573y5b3C572O5b1e570q5bz657zG5byW57xi5bwy57/+4b/O47+a4b9q47824b8G477S4b6i475u4b4+474K4b3a472m4b12471C4b0S47ze4byu47x64bxK47wW4s/zdOfvuDHx3Pr07O96d6+7OXHfnobuzyt054u6Mb3f+tjsb251b7c6Uduc9u7OY3TnJ7gxjd76wO/vXncvrzsx159m6s2bdObDujFZ3fqo729SdO+rOBHXndbqzNN05l+4MSnc+pDu70Z2r6M48dOcRurMC3Tl+7ow9d/6dO5vOnRvnznRz5625s9DcOWXuDDF3vpc7e8udi+XOrHLnSbmzntw5TO6MJHd+kTtbyJ37487kcefluLNs3Dkz7gwYdz6LOzvFnWvizhxx54G4szrcORrujAt3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",
      "custom_attributes": [
        "external",
        "private"
      ],
      "debug_symbols": "TL3LzjQ7j5x7L2vsQelAiuxb2QNjex+MBhpuwIdRw/fuNxmiIib9PdH/ehXKlBiVlcXK+o9//t//77/8r//6n//1v/3///4//vmX/+s//vkv//1f/+3f/vW//ud/+/f/5//+n//67//t7//7H//8vv8z9j//Ms3X//5P/4xPr/znX8Z/+mf/8M/APxP/LPyz8Y/hH8c/B/8E/sEohlEMoxhGMYxiGMUwimEUwyiGUQyjOEZxjOIYxTGKYxTHKI5RHKM4RnGMcjDKwSgHoxyMcjDKwSgHoxyMcjDKwSiBUQKjBEYJjBIYJTBKYJTAKIFRAqMkRkmMkhglMUpilMQoiVESoyRGSYwyfr/777j/zvvvuv/u+6/df/3+e+6/cf+944073rjjjTveuOONO964442/8db377n/xv038e/8G8+/f8f9d95/1/33b7z8/v3Gqz/whtMQDXlh/Rq+WZ4PZsNq2A3fyPGBN5yGb+TvKGrHf1B7vuBv5Lk/mA2rYTdYgzechmjIC18dAHpk65GtR/7qYX5n5asIgDechmjIC19tAEbDbFgNPbL3yN4je4/sPbL3yKdHPj3y6ZFPj3x65NMjnx759MinRz498ldD81uCr4oAs2E17AZr8IbTEA15IXvk7JGzR84eOXvk7JGzR84eOXvkvCPP369hNMyG1bAbrMEbTkM09MijRx498uiRR488euTRI48eefTIo0cePfLskWePPHvk2SPPHnn2yLNHnj3y7JFnj7x65NUjrx559cirR1498uqRV4+8euTVI+8eeffIu0fePfLukXeP/NXgGh+chmjIC18NAkbDbFgNu8EaemTrka1H/mpw/VXu/GoQMBq+kfOD1bAbrMEbTkM05IWvBgGjoUc+PfLpkc9NpHm84TREw02kGb+G0TAbVsNu6JGjR44e+avBPT/IC18NAkbDbFgNu8EavOE09Mh5R16/X8No+EZeH6yG3WAN3nAaoiEvfDUIGA098uiRR4/81aD9PvCG0xANeeGrQcBomA2rYTf0yLNHnj3y7JFnj7x65NUjrx559cirR1498uqRV4+8euTVI+8eeffIu0fePfLukXePvHvk3SPvHnn3yNYjW49sPbL1yNYjW49sPbL1yNYjW4/sPbL3yN4je4/sPbL3yN4je4/sPbL3yKdHPj3y6ZFPj3x65NMjnx759MinRz49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V+fj1fl4dT5enY9X5+PV+Xh1Pl6dj1fn49X5eHU+Xp2PV+fj1fl4dT5enY9X5+PV+Xh1Pl6dj1fn49X5eHU+Xp2PV+fj1fl4dT5enY9X5+PV+Xh1Pl6dj1fn49X5eHU+Xp2PV+fj1fl4dT5enY9X5+PV+Xh1Pl6dj1fn49X5eHU+Xp2PV+fj1fl4dT5enY9X5+PV+Xh1Pl6dj1fn49X5eHU+Xp2PV+fj1fl4dT5enY9X5+PV+Xh1Pl6dj1fn49X5eHU+Xp2PV+fj1fl4dT5enY9X5+PV+Xh1Pl6dj1fn49X5fHU+X53PV+fz1fl8dT5fnc9X5/PV+Xx1Pl+dz1fn89X5fHU+X53PV+fz1fl8dT5fnc9X5/PV+Xx1Pl+dz1fn89X5fHU+X53PV+fz1fl8dT5fnc9X5/PV+Xx1Pl+dz1fn89X5fHU+X53PV+fz1fl8dT5fnc9X5/PV+Xx1Pl+dz1fn89X5fHU+X53PV+fz1fl8dT5fnc9X5/PV+Xx1Pl+dz1fn89X5fHU+X53PV+fz1fl8dT5fnc9X5/PV+Xx1Pl+dz1fn89X5fHU+X53PV+fz1fl8dT5fnc9X5/PV+Xx1Pl+dz1fn89X5fHU+X53PV+fz1fl8dT5fnc9X5/PV+Xx1Pl+dz1fn89X5fHU+X53PV+fz1fl6db5ena9X5+vV+Xp1vl6dr1fn69X5enW+Xp2vV+fr1fl6db5ena9X5+vV+Xp1vl6dr1fn69X5enW+Xp2vV+fr1fl6db5ena9X5+vV+Xp1vl6dr1fn69X5enW+Xp2vV+fr1fl6db5ena9X5+vV+Xp1vl6dr1fn69X5enW+Xp1XC5JXS+9X55fi0Z+HV+PwV+eXxqP5aD3aj+yRPzqP4tHz8Ofhz8Ofhz8Pfx7+PPx5+PPw5+HP4zyP8zzO8zjP4zyP8zzO8zjP4zyP8zziecTziOcRzyOeRzyPeB7xPOJ5xPPI55HPI59HPo98Hvk88nnk88jnke1RjUuXxqP5aD3aj+yRPzqP4tHzGM9jPI/xPMbzGM9jPI/xPMbzGM9jPI/5PObzmM9jPo/5PObzmM9jPo/5PObzWM9jPY/1PNbzWM9jPY/1PNbzWM9jPY/9PPbz2M9jP4/9PPbz2M9jP4/9PF6d71fn+9X5fnW+X51Xu5NbkT3yR+dRPMqmqnPQeDQfrUfPw5+HPw9/Hv48/Hmc53Gex3ke53mc53Gex3ke53mc53GeRzyPeB7xPOJ5xPOI5xHPI55HPI94Hvk88nnk88jnkc8jn0c+j3we+TyyPao56tJ4NB+tR/uRPfJH51E8eh7jeYznMZ7HeB7jeYznMZ7HeB7jeYznMZ/HfB7zecznMZ/HfB7zecznMZ/HfB7reaznsZ7Heh7reaznsZ7Heh7reaznsZ/Hfh77eeznsZ/Hfh77eeznsZ/Hfh72POx52POw5/Hq3F6d26tze3Vur87t1bm9OrdX5/bq3F6d26tze3Vur87t1bm9OrdX5/bq3F6d26tze3Vur87t1bm9OrdX5/bq3F6d26tze3Ve7VYeRevRfmSP/NF5FI+yqeocNB49j3we+TzyeeTzyOeRzyPboxqwLo1H89F6tB/ZI3/053F2UTzKpq/OL41H89F6tB/ZI3/0PL46P1aUTV+dXxqP5qP1aD+yR/7oPHoe83ms57Gex1fn5xStR/uRPfJH51E8yqavzi+NR89jP4/9PPbz2M9jP4/9PPbzsOdhz8Oehz0Pex72POx52POw52HPw5+HPw9/Hv48/Hn48/Dn8dX5qR321fmlbPrq/GTReDQf/XnEKNqP7NGfR9Ru+ur8Ujz688jfR1+dXxqP/jyyRvnq/NJ+9OeRq8gfnUfxKJu+Or80Hs1H69F+9DzyeeTz+Oo86zi+Oi+qJq9Ln8cpmo/Wo/3IHvmj8ygeZdNX55eex3ge43l8dZ5RZI/80XkUj7Lpq/NL49F8tB49j/k85vOYz2M+j/k81vNYz2M9j/U81vNYz2M9j/U81vNYz2M/j/089vPYz2M/j/089vPYz2M/j/087HnY87DnYc/Dnoc9D3se9jzsedjz8Ofhz8Ofhz8Pfx7+PPx5+PPw5+HP4zyP8zzO8zjP4zyP8zzO8zjP4zyP8zziecTziOcRzyOeRzyPeB7xPOJ5xPPI55HPI59HPo98Hvk88nnk88jnke1RjWSXxqP5aD3aj+yRPzqP4tHzGM9jPI/6jvtvFC7iJhrRiYcYxHz41XvjINJt0m3SbdJt0m3SbdJt0m3RbdFt0W3RbdFt0W3RbdFt0W3RbdNt023TbdNt023TbdNt023TbdPN6GZ0M7oZ3YxuRjejm9HN6GZ0c7o53ZxuTjenm9PN6eZ0c7o53Q7dDt0O3Q7dDt0O3Q7dDt0O3Q7dgm5Bt6Bb0C3oFnQLugXdgm5Bt6Rb0i3plnRLuiXdkm5Jt6RbPrdqgmscxElcxE00ohMPMYh0G3QbdGOWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJYks+a7GE1kCHMRJXMRNNKITDzGIdEu6Jd2QJVa4iJtoRCceYhDz4vwhS4CDOImLuIlGdOIhBpFug26DboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptum25GN2TJKZzERfzcxq/QiE48xCDmw8qSi4M4iYtIN6eb083p5nRzuh26Hboduh26Hboduh26Hboduh26Bd2CbkG3oFvQLegWdAu6Bd2Cbkm3pFvSLemWdEu6Jd2Sbkm3fG54RtfFQZzERdxEIzrxEINIt0G3QbdBt0G3QbdBt0G3QbdBt0G3SbdJt0m3SbdJt0m3SbdJt0m3SbdFt0W3RbdFt0W3RbdFt0W3RbdFt023TbdNt023TbdNt023TbdNt003o5vRzehmdGOWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJYpYsZslilixmyWKWLGbJYpYsZslilixmyWKWLGbJYpYsZslilixmyWKWLGbJYpYsZMn6EFkCHMRJXMRNNKITDzGIdFt0W3RDluzCRdxEIzrxEIOYD5ElwEGk26bbptum26bbptum26ab0c3oZnQzuhndjG5GN6Ob0c3o5nRzujndnG5ON6eb083p5nRzuh26Hboduh26Hboduh26Hboduh26Bd2CbkG3oFvQLegWdAu6Bd2Cbkm3pFvSLemWdEu6Jd2Sbkm3fG779yMO4iQu4iYa0Ynl5oVBzIfIkiwcxElcxE00ohMPMYj5cNJt0m3SbdJt0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0W3TbdNt023TbdNt023TbdNt023TzehmdDO6Gd2MbkY3o5vRzehmdHO6Od2cbk43p5vTzenmdHO6Od0O3Q7dDt0O3Q7dDt0O3Q7dDt0O3YJuQbegW9At6BZ0C7oF3YJuQbekW9It6ZZ0S7ol3ZJuSbekWz43+/2IgziJi7iJRnTiIQaRbswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZslhlhxmyWGWVCvq32cfhZtoRCceYhDzYWXJxUGcRLoNug26VZZ8P7cxqzG1MYj5sLLk4iBO4iJuohHpNuk26Tbptui26Lbotui26FZZMq3QiYcYxHxYWXJxECdxETeRbptum26bbptuRjejm9HN6GZ0M7oZ3YxuRjejm9PN6eZ0c7o53ZxuTjenm9PN6Xboduh26Hboduh26Hboduh26HboFnQLugXdgm5Bt6Bb0C3oFnQLuiXdkm5Jt6Rb0i3plnRLuiXd8rlVr2vjIE7iIm6iEZ14iEGk26DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26IbsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWYK+13kKN9GITjzEIOZDZAlwECeRbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptum25GN6Ob0c3oZnQzuhndjG5GN6Ob083p5nRzujndnG5ON6eb083pduh26HboduiGLMlCIzrxc6uf90Lf68V8WFlycRAncRE30YhOpFvQLeiWdEu6Jd2Sbkm3pFvSLemWdMt2W+h7vTiIk7iIm2hEJx5iEOk26DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26Tbptui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26WZ0M7oZ3YxuRjejm9HN6GZ0M7o53ZxuTjenm9PN6eZ0c7o53Zxuh26Hboduh26Hboduh26Hboduh25Bt6Bb0C3oFnQLugXdgm5Bt6Bb0i3plnRLuiXdkm5Jt6Rb0o1ZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1mCvtfvJ3UX+l4vBrHc/ENkCXAQJ3ERN9GITjzEINLN6YYs+RVO4iJuohGdeIhBzIfIEiDdDt0O3Q7dDt0O3Q7dDt0O3YJuQbegW9At6BZ0C7oF3YJuQbekW9It6ZZ0S7ol3ZJuSbekWz439L1eHMRJXMRNNKITDzGIdBt0G3QbdBt0qyzZVmhEJ35u2wuDmA+RJadwECdxETfRiE48xCDmw0W3RbdFt0W3RbdFt0W3RbdFt0W3TbdNt023TbdNt023TbdNt023TTejm9HN6GZ0M7oZ3YxuRjejm9HN6eZ0c7o53ZxuTjenm9PN6eZ0O3Q7dDt0O3Q7dDt0O3Q7dDt0O3QLugXdgm5Bt6Bb0C3oFnQLugXdkm5Jt6Rb0i3plnRLuiXdkm753ND3enEQJ3ERN9GITjzEINJt0A33XnfhJC7iJhrRiYcYxHyIe69Auk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptum26Gd2MbkY3o5vRzehmdDO6Gd2Mbk43p5vTzenmdHO6Od2cbk43p9uh26Hboduh26Hboduh26HboduhW9At6BZ0C7oF3YJuQbegW9At6JZ0S7ol3ZJuSbekW9It6ZZ0y+eGvteLg/i52ShcxE383Az/rRMP8XMzL8yHlSUXB3ESF3ETjejEQ6TboNuk26TbpNuk26TbpNuk26TbpNuk26Lbotui26Lbotui26Lbotui26Lbptum26bbptum26bbptum26bbppvRzehmdDO6Gd2MbkY3o5vRzejmdHO6Od2cbk43p5vTzenmdHO6Hboduh26Hboduh26Hboduh26HboF3YJuQbegW9At6BZ0C7oF3YJuSbekW9It6ZZ0S7ol3ZJuSbd8buh7vTiIk7iIm2hEJx5iEOnGLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWbJYZYcZslhlhxmyWGWHGbJYZYcZslhlhxmCfpev5/rWOh7vTiJi7iJRnTiIQYxH066TbpNuk26VZZ4FhrRiXVsVhjEfIgsAQ7iJC7iJhrRiXRbdFt023TbdNt023TbdNt023TbdNt023QzuhndjG5GN6Ob0c3oZnQzuhndnG5ON6eb083p5nRzujndnG5Ot0O3Q7dDt0O3Q7dDt0O3Q7dDt0O3oFvQLegWdAu6Bd2CbkG3oFvQLemWdEu6Jd2Sbkm3pFvSLemWzw19rxcHcRIXcRON6MRDDCLdBt0G3QbdBt0G3QbdBt0G3QbdBt0m3SbdJt0m3SbdJt0m3ZglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglmCvtfjhfmwsuTi5/Y9UX2h7/XiIn5uMQuN6MTPLVZhEPNhZcnFQZzERdxEIzqRbk43p9uhW2VJZOEkLuLnlnUeKksuOvFzyzoPlSUX8+GXJfN7VOKqvtfGSVwf1lp8WdJoRP+wpvNlSWMQ82H+iIM4iYu4iUakW9It6ZbPrfpeGwdxEhdxE43oxEMMIt0G3QbdBt0G3QbdBt0G3QbdBt0G3SbdJt0m3SbdJt0m3SbdJt0m3SbdFt0W3RbdFt0W3RbdFt0W3RbdFt023TbdNt023TbdNt023TbdNt023YxuRjejm9HN6GZ0M7oZ3YxuRjenm9PN6eZ0c7o53ZxuTjenm9Pt0O3Q7dDt0O3Q7dDt0O3Q7dDt0C3oFnQLugXdgm5BN2ZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkluTLkv17WbJ/L0v272XJ/r0s2b+XJfv3smT/Xpbs38uS/XtZsn8/ug26DboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptulWWfE+N2dX32mjEz22OwkMM4uf2faNyV99r4yB+brPcKksubuLn9n3Cv6vvtfEQP7fvc71dfa8XK0sufm4rCidxET+3XQdUWXLRiZ/bxmBBzIeVJbYKB3ESPzev+VaWXDTi5+Z1zipLLgbxc/Oab2XJxUH83LzOWWXJxU383E6d9cqSi4cYxHxYWXJxECdxETeRbkm3pFvSLZ9b9b02DuIkLuImGtGJhxhEug26DboNug26DboNug26VZZ819W7+l4b82FlyfcTRrv6XhsncRE30YhOPMQg5sNFt0W3RbdFt8qS7yeQdvW9NjrxcwsrDGI+rCyJOszKkouTuIibaEQnHmIQ86HRzehWWZI138qSi5v4uWXNt7Lk4iH+ua3vWe27+l4vflnSOD6s5f6ypHE13ieEFp3v//lVf7VEru8dwa6WyMZJXMRNNKITDzGI+XDSbdJt0m3SbdJt0m3SbdJt0m3SbdFt0W3RbdFt0W3RbdFt0W3RbdFt023TbdNt023TbdNt023TbdNt083oZnQzuhndjG5GN6Ob0c3oZnRzujndnG7YZlG4iUZ04iEG8XMbtVG/l6zGQZzEz23U/v1esho/t+9Jc7taIhsPMYj5MH7EQSy3U7iIm1huWejEQ/zc6kqiWiIvfi9ZjYM4iYv4uX2PSNjVEtnoxEMst5pZZmO1RDZ+bmsVTuIifm5f2+uulshGJ9a43yVBNT+uuoSpNse1svAbYc9CIzrxEIOYDysf6sKm2hwbJ3ERy63mUPlw8XOzmmTlw8Ug5sPKh4uD+Ll9HRa72hwbN9GI5WaFh1huNcnKB2Dlw8VB/NzqOqvaHBs30YhOPMTPzWs6lQ/AyoeLg1huNcnKh4ubWMcWhU48D6vmL9YIdRRV3XUpV52Jfx/8FObDKumLgziJ32CnJlklfdGITjzEIJZbzaxK+uIgTmK51XyrpC8a8XOLmlmV9MUgfm5Rm7ZKOqqGqqTrqqM6ExsXcRON6MQa95tk9SA2DuIkLuJ+WFX4/e7jrgbBxs8iZ+FnUVcd1QrYOIiTuIj7YdVFXZZUy16jEZ14iEHMh1UXFwdxEum26bbptum26bbpVhXw3Vnd1Ya3vnuou9rw/s53oRMP8W+Ev1UozIffa2HjIE7iIvqHtQBeI9QCnBqhZnYGcRJrhDrVXzE0GtGJhxjEcqsjjh+x3OrgYxIXscatbRQ1Qp2H/BFrhFX4jTDqML8N3riJRvzGrWvPapdrDOLnVi/u1S7XOIjPrdrlGjfRiE48vRbVLtf4VrPa5RoHcRKtl7Ba4LCE1QKHxaoWuMZBnL0W1QLXuIlGdOIhRq9btcBdXL9erGqBa5xE6yWstjasW7W1Xdy/XsJqa7snavP8bp7fzfO7rRer2toaDzHeYm2upnE1jW5GN6Ob0c24mlUMdVFWvWGNRqzp1NmpYrgYxHxYxXBxECdxETfxc6tLn+oNazzEIObDKpyLn9us+VbhXFzETSy32kZVOBcPsdxqZlU4hdUb1lhup3ASF3ETyy0Ka9wszIdVIhcH8Rv3+yrXri6wvwurwm/cup6sLrBGJx7i5/Z912tXF9jFKqeLg1hudWxVQ3V3rFq/dl17VuvX3+tH4Wex8WdBzIdVQxcHcRIX8XP7vqSzq/WrsdzKeB1iEPNh1dvFQfzc6gZctX41bqIRP7e64KzWr8Ygfm517VmtX42DWG613FVvVnOoertoRCceYjysVz2v5a5XvYvrYb2S1fVkNWM1fm51uVjNWI1OPMQg5sMqXq+jqOKtm4vVjNW4iJtoRCfWuHVAVZB1GVoNVn8vv4WbaMRvhLqpVg1WjUHMxmqwahzEctuFi1huVmhEJ9a433mopqld9+2qaaqxRhiF1ieqmqYaDzGINe53SqppqnEQZy9ANU01biLdJt0m3SbdqgqBVS11MV3NTRerWi5WtZRFVcvFRdxEIzrxm0PUKalquZgPq1ouDuIkLuI3bl3xVxtTYxDzYV0jXhzESVzETTQi3ZxuTjen26Hboduh26Hboduh26Hboduh26Fb0C3oFnQLugXdgm5Bt6Bb0C3olnRLuiXdkm5Jt6Rb0i3plnTL51ZtTI2DOImLuIlGdOIhBpFug26DboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptum25GN6Ob0c3oZnQzujFLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJYEs2YWDOIm7EzEQIEAnHmIQX+hG/IiDOImLSLegW9At6BZ0C7ol3ZJuSbekW9It6ZZ0S7ol3fK55e9HHMRJXMRNNKITDzGIdBt0G3QbdBt0G3QbdBt0G3QbdBt0m3SbdJt0m3SbdJt0m3SbdJt0m3RbdFt0W3RbdFt0W3RbdFt0W3RbdNt023TbdNt023TbdNt042VH8rIjedmRvOxIXnYkLzuSlx1pdDO6Gd2MbkY3o5vTzenmdHO6Od2cbk43p5vTzel26Hboduh26MYsSWZJMkuSWZLMkmSWJLLkFA7iJJZbFm6iEcstCg8xiPkQWQIcxM+tbq1W71LjJhrRiYcYxLxo1bvUOIiTuIibWG6j0ImHGMR8WFlysdx24SQuYrlZoRGdeB5Wanz3Xq36kfZ379WqH6nRiDVCFh5iEP/ma999Oat+pMZBnMT1YR3Qlw+NRnRijVunb9cIq3ARN7HmWxZV8xcPMYj5sGr+4iCWW50dW8RNrPnWmTQnHmIQ86H/iIM4iYu4iXRzunm51Qp5uUVhPjw/4iBO4iJuohGdeIh0+2reRi3WV/ONg1hutUtiETfxcxu1hF/NNx7i5zYxWD78ar7xc5u1S76ab1zEz21WiXw13+jEz23WdDKI2Vg9Rn83jAsHcRI/t+9GmFWPUaMRP7fvo1mrHqPGIH5u38etVj1GjYP4ue1y+2q+cRM/t+/DUqseo8ZD/Ny+b7Fb9Rhd/JKg8XP7PkW06jFqXMTPzeqUTCM68XPzms6XD435sPLh1HQqHy5O4uf23Vux6jFqNOLnduqkftcPjUH83KLcvuuHxkH83L7LZqseo8ZN/NwqdKvHqPEQP7fK9eoxuvhlSeOfm1fgVY9R4yLuD2uwL0sanXg+rK3xZUljPvyypHEQJ3ERN9GITqSb083p9mWJjzo7X5Y0TuLnNmqFvixpNOLnVgVZz9ZrDOLnhnL6sqRxED+3WWv8ZUnjJn5uq07flyWNh/i5rXL7suTilyWNn9uqvf5lSeMifm6r9noa0Ymf2y63L0sas7Gerfd3l7hwECfxc/tuR1s9W6/RiJ/bdwfZqmWsMYif29fIYNVI1jiIu+O1msPs+yTIqjmsMR9WPlwcxElcxE385vvd27ZqDms8xCDmw/UjDuIkfmfna7Gwag5rNGK51ZlchxjEeoX8Nm01hzUO4ufmtVi7xq0D+pKg8RCDmA+/JGgcxElcxE2km9HN6GZ0M7o53ZxuTjenm9PN6eZ0c7o53Zxuh26Hboduh26Hboduh26Hboduh25Bt6Bb0C3oFnQLugXdgm5Bt6Bb0i3plnRLuiXdkm5Jt6Rb0i2fW7WBNQ7iJC7iJhrRiYcYRLoNug26DboNug26DboNug26DboNuk26TbpNuk26TbpNuk26TbpNuk26Lbotui26Lbotui26Lbotui26Lbptum26bbptum26MUsWs2QxSxazZDFLFrNkMUsWs2QhS1bhJhrRiYcYxHyILAEOYrl54SJuYrntQiceYhDzIbIEOIiTuIibSLdDt0M3ZEkU5kNkCfBzq+vJ6j9rXMTPra4nF1Kj/gz5cAoH8Rvh+3DMqqescRON6MRD/OZb157VaQasTrPGQSw3K1zETSw3L3TiIZbbKcyHlQ8XB7HcovBzq/fH1bbmdSlcz7VrDGI+rCTIVfiNW/cqqpnN6/5DNbN53WmoZrZGIzqx3Go6lQQX82ElwcU/t1NX29UZd+q6ujrjTt1TqM64Uy/51Rl36kq3OuMag5gPv/JvHMRJLLeaw95E72209yEG8e3UbT/iIE7iIm6iEelmdDO6Gd2cbl/Nn1Hn7Kv5xkX8Dqje2tcT7BqdeIhBzIdfzTcO4iQuIt0O3U651bqdQwxiPowfcRDLrY44FnETjVhuWXiIQfzc6lZEteSdejdTLXmNn1u9hamWvMbPre4/VEteoxMPMYjZWC15jYM4iYu4iUZ04iEGkW6DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui24VIF/LmFWrX+MkLuLul6Rq9Wt04iEGMR9WllwcxEmso/DC6Fe9eird+VrRrJ5K1ziIk7iIm2jEOg9fOdWT5u55ODziwyOumr9oxDq/WXiIQcyHwdUMugVXM7iawdUMrmZwNavmMYeq+Yv5MLmaqPmaA2oeuIh0Y80ba95Y88aaN9a8s+b99/aO/yZxETfReg7+c+IhBselG2veWfPOmnfWvLPmfbx1c9Q88BCD+NbNUfPAQaQba95Z886ad9a8s+adNe+seV9v3XzxTC6eycUzuXgmq+a/7xFbtRs2fm51j6naDRvzYdX8xc9t1Ryq5i8u4iYa0YmHGMRyq0naj1jXD3UmbXcVVmPhqTvT1VjYeIhB5Ao5V8i5Qj6Ji7iJ3H3OFXKukHOFnCt0uPuYGn64Hw73w+F+qHyom+rVsNiYDysf6nZeNSyeunFXDYuNi7iJRnTiIQYxH+a7m+S4ewDcRCM68RCDmI0Hdw+AgziJi7iJRnTiIQaRboNug26DboNug26DboNug26DboNuk26TbpNuk26TbpNuk26TbpNuk26Lbotui26Lbotui26Lbotui26Lbptum26853g23TbdNt023TbdNt023YxuRjejm9HN6GZ0M7oZ3YxuRjenm9PN6eZ0c7o53ZxuTjenm9Pt0O3Q7dDt0O3Q7dDt0O3Q7dDt0C3oFnQLugXdgm5Bt6Bb0C3oFnRLuiXdmCWHWXKYJYdZcpglh1lymCWHWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJ9Vr+vUQVGtGJhxjEbKxey8ZBnMRF3EQjOvEQg0i3QbdBt0G3QTd+6lm9lo1OPMQg5sN6h1LtGNVr2TiJ5Yb/dhONWMe2Cw8xiPmw3qFcHMRJXMRNNCLdFt0W3RbdNt023TbdNt023TbdNt3qHcr3pSyrXsvzPQXAqtfyYr1DuTiIk7iIm2hEJx4i3ex1C1WvZeMgvm6h6rVs3MTqFqq9U31XFw8xiPmw+q4uDuIkLuIm0u3Qrd63VGNA9U+eauWp/slTTTvVP9loRCd+I1jtvrorYbVCdVfi4iYa0YmH+J3faiKonshCr57IxkGcxEXcRCOW2yw8xCDmw6r5rxvAqyeysToSrHARN9GITiy3+LAq9utj8up+bHTiuS1jXt2PjfmwupsuDuIkLuImGtGJdFt0W3TbdNt023TbdNt023TbdNt023TbdDO6Gd2MbkY3o5vRrSr2e5nx6pRsDGI+rDsNFwfx21Feg9Wdhovfunlto7rTcNGJhxjEfFh3Gi4O4iQuIt3q/qTX7qv7kxe7m9DRKXkxH1an5MUat3ZfVazj/3tu15+j+/FiPqzux+8FxdH9eHESq0Owzll1P140ohMPMYjZiO7Hi4M4iYu4id9Z/5r6vDoaz/c9S6+OxvN9adOro7FxETexRvjKtLoUz3dn2qtLsXESF3ETjfid3++7k15dio1BzIf1yntxECdxEcttFxrRiYdYblmYD+uVN+qc1SvvxUlcxE00ohMPMYj50Ohm3e/p1aXYuIjd7+nVpdjoxOouPYVBzIf1yntxECdxETfRiE6km9OtKjZqc1VtRp3qqs2ovVO1efEQ42HdBYwarF5Now6+Xk0vOvEQg5gP6/OArG1fnwdcnMRF3EQjOvEQy622cr3yFlY3YeMgltsoXMTv/H4NHV5tgSeBgziJ9We7cBOrDfdX6MRDjIdVpt+XDbzaAk/WzGY38nq1BTYeYjfyerUFXkTbMLDahms6aBsGLuImGtGJhxjEfFgvrBfptulWpfd1JHg1AJ7vaxBeDYDxq4P/iqxxECfRPpyF8WGddcuH/iMO4iQu4v6wTp8b0YmHGMR8eH7EQSy32jtnETfRiOVWK3QOsdyiMB/GjziIk7iIm2hEJx4i3aKbwL2a+hoHsZvAvZr6Gjfx2zsVK9XU13iIQczGauprHMRJXMRNNKIT65x9m6sa9eLrf/Bq1ItR/8FXm41GdOI3wtf04NV8F3XRW813jZtoRCce4nd+v+fseTXfXfxqs3EQJ3ERN9GI5bYKDzGI+XCXWxQO4uf2vWHyaqiLWQf/1WZjPqzavDiIk7iIm2hEJ9KtXgAraauh7mK9AF789kPWf1svgBcX8dsPlfbVUNfoxEMMYj6st54XB3ESF5Fuh25VsbNOddXmrJWv2vx6BLya5Bo30Yg1Qi1L1gi1f3MSF3ETjejE7/yuOn1fvTVmYzXJNQ7iJC7iJpbbKXTiIQax3L4Vqia5xnLbhZO4iJv4uX2fpnq1zjUeYhDz4fwRB3ESF3ET6Va3rqv80Tp3MYjfbcKqbrTOXRzE+orHKlzETTSiEw8xiPmwbl1fHES6bbrtOme1FlXH3werXk1y8d3Z82qSa5zERfxGqPdO1fgW9S6pGt8aB3ESF3ETv/O76+zUa+zFQwxiPqzX2IuDOInlVtuzXmMvGtGJ5VZrXBULrIr9bhZ5ta2F1cHXK+TFIObD7xWycRAncRE30Yh0qw+bfsAgZmO1rdWXnLza1honsTIqCzfRiE48xCDmw/oy3cVBnES6DbpVbVpNp6rwu3/m1YoW340wr1a0xkWsswOsEb5lqfayqDcr1V7WOImLuIlGrPNbM6tXyItBzIf1CnlxECdxEcvNCo3oxEP83LyWsKoQWFX4NaJ7tZc1TuIifm51z6aazhqdeIhBzIdVsRcHcRIXkW71oVC9StcPpDYe4rdT61WvfiD14vkRv506az/Uh0IXF3ETjejEQwxiPsSX3oB0C7rVa6zXWlQd1+2makWLuoVUrWiNgziJ3wj19qzay+LUuPVqWljtZY2DOImL+J3fulFT7WWNTjzEIObDejW9OIg13yxcxE00YrntwvOwKrbeLVYjWeMkLuImGrHGPYWHWEcRhfmwqrvu5FQjWePn9nX3ezWSNX5udfOlGskaP7e64q9GssbPrd6sVCPZxarueodSjWSN5WaFi1hudUBV3RfLrQ6oqvtiudUBVXUDq7qjDqiq++LnVpeL9dy6xs+trnSrvazxc6vL22ova/zc6k5DtZddfF9p/cNBnMRF3EQjlludkno9vhjEcqv/tl6PLw7iJC7iJhrRiYcYRLoF3eoKOuv81qt0veJUI1nWK2Q1kjXmw6+6GweR803ONznf5HyT803ONznffPOt9rLGQZzERfQ+oGoZwwFVyxgmWS1jjZO4iJv45lstY42HGETOd3K+k/OdnO/kfOcm0m3SraobB1R1jANanO/ifL86bnTiIXK+i/PdnO/mfDfnuznfzfluzndzvptnZ9Nt0w0VWweE2qwDMs7XOF8L4tt91drVyNX0Ws1RuIj1WuiFRnTieXhq3FlYI6zCb4R6p4Z2rYtO/EZY+LMg5sN6NV01yXo1vTiJi7iJRnTiIQYxHybdkm5Zu2QX1vmtI846v7UsmY3VgtU4iDVCFn4jfF/C8WqrasyHVW8XB3ESv/Nbt4WqrarRiE48xCDmw/kj1nyjcBIXcRPLbRU6sdysMIj5cP2IgziJi7iJRnQi3eq96aqZ1XtTYL03vVirWQtQ700vLmLtnVqsaqu66MRDDGI+rLaqi4M4iYtIN6NbVez3SGSvVqmse2LVKpWjJlm1eXETjfiNUFeZ1f6UdVVc7U+Ni7iJRnTid37rI99qf2rMh19tNg7iJC7iJpZbbeVw4iEGsdxqjet182K51RHnJH5uVbHV/pSVMNX+VI9s8Gp/ajzEIGZj4vEOwEGcxEXcRCM68Tu277HMXu1Pjfmwav7iIE7iIm6iEZ1YbrswiPmwav7iIE5i/bff7qvmpcZBnMRF3MSaWRb6w6/esu7kVOtRoxG//7bu71TrUWMQa4XKourt4iDWCpVb1dvFTawVOoVOPMQg5sO6pr04iJO4iJtIN6fbd/WadROq2omy7htVO1HWDaBqJ2o0ohNrhDriqjccW9XbxU00ohMP8Tu/dZOkmowuVr1dHMRJXMRNNGK51RHX6+bFIObFU61H+fUFnWo9aiw3Kyw3/LebaEQnHmIQ82HV28VBnES6Vesy5lCtyxed+O2d7w7RqZ+SbMyH1br83U069VOSjZO4iJtoRCceYhDz4aLbolvV5tcNcKohKb+7PqcakvLryTnVkHTxe91sHMRvhO9j51NNRuk1btXmxXxoP+IgTuJ3fr3Ojm2iEZ14iEHMh3VNe7Hcau/U6+bFRdzEcqs1dn+IVr86TLT6ARdxE2uELHTiIQYxH9br5sVBnMRF3ES6Bd2CbkG3oFvSLemWdEu6Jd2SblXHXnun6vjUfqg6vpiN1WTUOIiTuIibaEQnHuJ3V/j7MOTgEWvAuit88Vu37zrq4BFrFxfxW7fvy3QHj1i76MRDDGI+rEcoXRzESVxEuk261VXx10B1qiEpv/tcpxqS8tR/UK+mFzfRiDVCHVDV5nfv6lSTUeMibqIRnfid3++O1qkmo8Z8WHV8cRAncRE3sdxqWaqOLx5iEMut1rjq+GK5rcJJXMRNNKITDzGI+bDesV6kW9W81VFUzV/cxGppqklWe+/FQ6zmuyzMh9UseHEQJ3ERN9GITjxEugXdqrqjNlfVcdSprjqO2jtVxxeDmI3VepTfbcJTjyzL797gqUeWNR5iEPNhvcZe/M7vd8fwVG9S4yJuohGdeIhBrPl+W7keb9Y4iJNYbqtwE8ttFwYxH9b179fzdKpjqbGOok5UVezFTaxxy7iufy8eYhDzYb3yXhzESVzETaTbptum26bbppvRzehmdDO6Gd2MbkY3o5vRrao7axtVdV8cxElcxE2sHu9aCxRv/X9RvMBB5Kb9ivfvxai23+GuPdy1h7v2q9O///gr32pqejyEZ3Htu3p9xp/W6/NF1knQMegYdAzWSbJO6vX54iTSLWnxle3ffGoXZz6uxqXHmL8VT+ElvIWt2Itd+AiHMHy/HV+NTX8cxUt4C2P8LHbhIxzCSZ4/4SFcvt+dsVP9UI+3sAm78BEO4SQvjDmL8bd1btcRDuEk75/wEMac65zvJbyFTdiFj3AIJ9ngW2tkQ3gKL+EtbMLOtbMjHMJJdqzLLt48b27CLnyEcSy1l46cqzOFlzDGL99jwi6M8WufHFmjI2sUskYhviG+Ib6xhU1Y9kbI3gjxTfGqqq4LueqeajSiE2u8747Y2bjAjsJBnMSa7HcT8GwU92UTrsl+t/nOxkU2/jSI+XDQcdBx0HEs4iYa0Yl0G7RAEdebqo0ivryFMX8rduEjHMK1yN+nE6d6oh4P4SkM31OM8WtuKPTLIYzxv821UeiXh/AUXsJb2ITLd9VCo9Avh3CSUeiXh/AUXsIYs9bd8bd1blG4l6fwEt7CJow51zlHQV8O4SSfn/AQnsJLGL61Rij0yy58hEM4ySh0rB0K/fIUXsJYl10cPG+RZBT05SGMY6m9lHKu0oWPMMYvX7yYFxtezC9j/CzmGtlvCW9hE3bhIxzCSR4/4SEsvkO8qqodGMR8WJfnF2u8737vqT4r3BGqR341OrEm+91FP4bivpxkFPd3f/hUX9b90zWJi0jHRcdFx3WIQXz3tmz/iHTbtEAR7zpYFPHlEMb8vw1uKOLLQ3gK1yJ/936P4dX6sgm7MHy/DWgo9F2bCIV+eQpj/NpcKPTLJuzCRziEk4xCr3fNhkK/PIWX8BY2YRc+ZBRx3Sg2vCpbnVsU7mUXPsIhnGQUdN3XNRT05Sm8hLewCbvwEYZvrREKvdhR6JeH8BRewvutnaPQL7vwEca6fPvTUcR13hxX6pe3sAnjWE4xz5XjivzyEMb45YsX88tbGONnscvfHuEQFt8lvkt88WJ+eQlvYRMW3yVeVdU4bfXO++IibmKNVzfTHR9T1SHVm2xgvcm+WJOtu+mO4r68hGuydYO62q/6T514iHQ0Ojod6432xUlcxE2km9MCRVzJ7Sjiy1MY87fiLWzCLlyLXDfsHa/Wl5OMV+vL8K0NiEKvm9GOQr/swhi/5o9Cv5xkFPrlITyFl3D5nlpoFPplFz7CIZyPDwr98hDGmLMYf7uKk4xX5ctDeAovYczZik3YhY9wCCcZhX55CMPXi5fwFjZhFz7C8dbuoNDBKPTLQxjrsoud5w1X6pdDOMm4Uq+3VWfLucIV+WUTxvjlixfzyyGM8b99ckzWyGSNTNbIxNfE18QXL+aXj7DsDZO94eLr4lVVXW/6qnGr8RCDWOPVLfzzekbOeT0j57yekXNQ3HW3/qC4Lx/hmmzgv8/3p+gbAQ4iHYOOQccwohMPMYh0S1qgiOtG/0ERX3ZhzL82OIr4cj4OFPHlWuS6wR54tb68hLcwfE8xxo/iJKPQL2P8LJ7CS3gLm7ALH+HyrfuIgUIHo9AvD+EpvIS3sAljzO+cB16V6257oHAvb2ETduEjjDnXOUdBg1HQl4fwFF7CW9iE4VtrhEK/HMJJRqFfHsKTa4dCv7yFTRjr8oVZoIhx3nClfnkKL2EcS+0ll3OFK/LLScaLed2ZD7yYX57CGL/2yZE1OrJGR9boiO8R3yO+eDG/PIRlb4TsjRDfEC90UdfU0EUNHMRJ/MYb9QFANX5V8+Spxq/GIGb9x19oVefX4yE8i2fx6j+t5q9GIzrxEIOYD1/D58nX8HnyNXweNH9dpEUV8agb/dXc1Tx/wpi/FU/hJbyFrdiLXfgIhzB8vw1YPWF/HMVLeAtj/Cx24SMcwkneP+EhXL44J1XozVvYhF34CIdwkg1j1rob/rbOrR3hEE5yFXTzEMac65z7Et7CJuzCRziEk3zgW2t0hvAUXsJb2ISda3eOcAgnObAuu3jzvIUJu/ARxrHUXko5VzmFlzDGL980YRfG+LVPUtYo3xrF7/cTHsJTeAlvYRN24SMc5CFe9QI+vpv6UT1mfzyKTdiFj3AIJxm1f7lisazQzg1cxE00ohMPMR7Wl6O+14r4oeS/a6v4oeQvb2ETxuFgmCMcwklGyV8ewlN43e9BxA/frwAa0YmHGMR8WN+TujiI+x2xydEgDC4f4RCWo3E5GpejcTkahMHlLWzCPCDnATkPyHlAhwd0eEBnEnn6Dk8fvgZVR3zkaFDq4PgJD2E5mpCjCTmakKMJ2RMheyJkTwQPKHlAyQNKHlDygJIHlNwPydOX7/QNfE8qCnk04zeFl/AW5tGMnwsf4RDmnhjjJzyE3wFVC1vjJhrRiTygEcR3+sb8Eb9xv5sPMfDlSaARnYhD2R/je5KjcBAnEefJirewCeM8efHhnwYxH246bjpuOlYGXNxEIzqRbpsWhnU+xUt4C2P+dfJu7YOPcAjXOq86gaj9y0N4CpfvqvngBX/V/sIL/uUQxvi1X/CCf3kIT+ElvIVNGL610HjBvxzCSUYKXB7CU3gJY8xa98Tf1rnFC/7lKbyEt7AJY851zvGCfzmE8/HEC/7lITyFl3D5fh9YxUStX3bhIxzCSUat19pN1PrlKbyEsd+iON55m3jBB+MF//IQrjG/z8diTp6riYv6y0cYcy5fXNSD6xZcc43/fX4Vc3GN5lrCW1h8l/gu8cUr/+Uk75/wEBbfLV54vkEder2yX8yH9cp+Ecexi7+4sBqivlB50YlYWCsO4SSjuHcNXo8zwJ/W4wwuLiIdnY5Ox3pNvxjEfFiv6RfpdmiBIt7gIxzCmH9tcBTx5SE8hWuRrTYyXsovm7ALl6/VBkShW20iFPrlKYzxa3Oh0C+bsAsf4RDOx2iFG9/3HwKtcM1TeAlvYRN24UNGEdemQpvbqPOPNrdmFz7CIZxkFPT3wVigza15Ci/hLWzCLnyEy/f7wCrQ5nYZhX55CE/hJbzf2i0U+mUXPsLYb1+Yof3tnje8Y7+8hU24xvw+Hwu0ud1zZT/hIYw5ly9ezC9v4Rrfa5+YrJHJGpmskYmvi6+LL17MLy9h2Rsue8PF18ULjxWqaeKxQsBF3EQcR+1HPEGoDqmeWACsJxZcxMJa8RRewjhJdeLrSSX3T514iHQMOiYd6xr94iQu4ibSLZ/FRhF/H/7FRhFfnsKYfxZvYRN24VrkurTdeLW+nGS8Wl8u37pS3Cj078Ok2Cj0yy6M8Wv+KPTLSUahXx7CU3gJw3cXm7ALH+EQTjIK/fIQxphejL+tc4vCBeNV+fIQnsJLGHOuc46CvuzCRziEk4xCvzyEyzdqjVDol7ewCbvwEQ6uHQodjEK/PISx36LYed5wpX45hJOMK/WovXTkXOGK/LIJY87lixfzyyFc40ftk5A1ClmjkDUK8Q3xDfHFi/nlIyx7I2RvpPimeOF5gHWq8DxA4CEGEcfx7cdqcauHB0Z1uDVuIhbWil34COMkeXG+P60HFl0cRDoOOg461nvui048xCDSbdICRfx9+BeGIr7swpg//vsQTjKK+HIt8vfBWxherS8v4S1cvt9TfcJQ6N+HSWEodDAK/TLGX8VTeAlvYRN24SMM31poFDoYhX55CE/hJbyFTRhj1rrjVTnr3KJwL29hE3bhI4w51zlHQYNR0JeH8BRewlvYhD/f+as1qkJvDuEkV6E3D+HJtUOhX97CJoz99hUg2t/uecOV+uUpvIR3+dZeSjlXuCK/nI/R5ja/z9ACbW7NU3gVr+Itf2vCLnyEQ1h88WJ+eQhP4SUsvkO83mN4Aw8nuziIk4jjAH9x8X00E/6ewxt4DtlFLGzx+gkPYZwkL17vT/EsXqAR6bjouOiIZ/EW4lm8wEGcRLptWmxszDoxO8n2E8b8s3gKL+Et/C3y/D54i+p5e3yEQ7h8v+cpR3W4/XFtoir05i2M8WtzuQsf4RBOchV68xCGby30WcJb2IRd+AiHcJIDY9a6B/62zm0c4RBOcv6EhzDmXOc8l/AWNmEXPsIhnI/R5jbrwy20uTVP4SW8hU3Y39rVj1s+DuEkD+y3KN7vvKH9rdmFj3CNWR+eoc0N5wptbs1LGHMu32nCLlzj1z19tLn133KN0ObWLL5LfJf4ri1swi58hMV3i1dVdWUunkx20YhOxHF8+/Hgofh1SHgoPnASsbBWvIVNGCepTnw9UPD+aRDzodPR6eh0fA/Rj4OH6AON6ES6OS1QxHWj/6CIL29hzL82OIr48hEO4Vrkurl/8Gp9eQhP4fKtDwAOCr1uBB8U+uUQxvg1fxT65SE8hZfwFjZh+NZCo9Avh3A+Ritc8xCewksYY37rjja3WTdw0ebWPIWX8BY2Ycw5i49wCCd5/oSH8BRewuVbN/HR5tbswkc4hJOMQq+1CxT65Sm8hLHfojh43laSUdCXh3CNWR8AoM3tnqvtwkcYcy5fvJiD8WJ+ucav2zJoc7t/a7JGJmtk4mvia+KLF/PLSXbZGy57w8XXxQsv4HVTH+1vs+7No/3tMl7ALw/hKbyEt7Dd3z6J6n5rPMQg5sP6jeqLgziJdn/MJarTrfEQcTB1kCh4MAr+8hCewkt4C5uwCx9h8U36oj2ueQhP4SW8hU3YhY9w3B/xCfw+JLB+6ObiIMIziu3+dE/Us9AaDxEHlMVJRhpcrgOqTzDwc5D40/pRqoubSMdJx0nH+lGqi/mwfpTq4iDSbdECL+P1KQr64pqTjASoTzzQF9c8hZdwLUh9goG+uGYXPsLw/aogkQB1Vz6RAJeXMMavBUICXHbhIxzCSUYCXIZvnRMkwOUlvIVN2IWPcJCRAPXJBvrfZn3agP635iMcwknGq/zlmnMVceJV/vIS3sIm7MJHOIThW2uEMLg8hKfwEt7CxrVDGFw+wtGc6Jeb36c6ib64Om+JvrhmE3ZhHIt9PN65yh9e/S9PYYxfvnj1v2zCGP8UH/nbEE7yFN8pvlN88ep/eQubsAuL7xQv/NRcHS5+ag64iUbEeFGc9/fusnrgGgcRk83iJbyFa7KnTnz9stz900MMIh2NjkbH+k3Xi4u4iUakm9ECRXzqxKCILy/hmv/3iUei563ZhY9wLfL3CUb+8FIPxkv95SEM3zrhKHTMDYV++Qhj/NpcKHQwCv3yEJ7CS3gLw7cWGoV++QiHcJJR6JeH8BSuMaPWHa/c36cNOVC4l4fwFF7CW7jm/H3CkOhxaz7CIZxkFPrlITyF4buLt7AJu/ARDuF8azdQ6JeH8BTGuszi887bwCX85STjEv4yjsWK5Vzhsv2yC2P88sWL+eUk48X8u7rJsWWNtqzRljXa4rvFd4svXswvh7DsDZO9YeJr4oUX8O/CJNHzNr8PIBI9b81Jxgv45SE8hZfwvr+cmgO//wp04iEGMR/i91+Bg/iNa7XN6ir+ohMPsY4la33rgt1qW+Enm4GLWCc/6+SgqC+7cJ2orA1WPzR5/zQf1g9NXqRj0jHp+H7iOcf7iecc7yeec7yfeE780GQhfl3yYp3w71OYRGNbswlj/lZ8hEM4ySjw7/1MorGteQovYfieYowfxSGcZBTy9ylJosmteQov4S1swi78+a7vE5NE81tzkqvYm4fwFF7CWxhjfuuOBrb1q3O7p/AS3sIm7MKYc53zHcJJtp/wEJ7CS3gLw7fWyFz4CIdwkv0nPLh2KPbLS3gLY11qf3ryvJ2f8BCewjiW2ktHztU5wiGM8cs3fsJDGOPXPglZo5A1ClmjEN8Q3xDfSHL+hGVvpOyNFN8Ur/q1Shx6/VplITrd1veRSKLTrXkKL+EtbMIuXEcyMH4IJ3nAdxUP4SkM31G8hU34u/Xxw39+iEHMh/UU1ouDOImLuIlG/Bt3VxRVC9xFVPv3kUuiA655Ci/hLWzCLoxziPFDOMkbvqd4CE9h+FrxFjZh/w4F//khBjEffinROIiTuIibaEQcTRQnGTlwGUeTxVN4CdfRzNpxdcHfXGdx1u6oC/7mEC7fWTsRWXF5CE/hJbyFTRi+tU+QIZdDOMnIkMtD+DuXdb1fXXS7LkWqi27XVXp10TUGMR9+KdE4iJP4rVG9B64uukYjOrHc6sxmELOx2uwaB3ESF3ETjYgztIuTjIy4jDNkxVN4CWNlvNiEsTKn+AiHMHy/04MGu+YhPIWX8BY2Yfhm8REO4SQjRy4P4e9c/oDfWfu6JrKeNLcH8BCDmA+/pGgcxEn81qiSuVrvGo3oxM/tBwxiPqyMuDiIk7iIm2hE2REmO8JlR7jsCJcd4bIjXHaEy45w2REuO8JlR7jsiCM74siOOLIjjuyIIzviyI44siOO7IgjO+LIjgjZESE7IrgjgjsiuCOCOyK4I4I7IrkjkjsiuSOSOyK5I5I7IrkjkjsiuSPy7Yh6Gl3jIE7iIm6iEesMfZ92Jp43dxkZcXkI18p8n4imISMub2ET/juaVS9Q1ZbXGMR8+OVD4yBO4iJuYi3492Fmoj2vOcmIgMtDeArjcKJ4C5uwC8M3i0M4ybiU2HXqcClxeQqX767lwKXE94Feom1v7Zob3nRcPsIhnGS86biMv7XiI4y/9eIkIwx2ndsvDNaq6XxZ0LiIm2hEJ2LkOmMo611n5tQYZXg20Yg1Rs30K+nGIObDr54bB7HsrE4y3jVcrpNstT/xruGyC9e065569drdPYI3ATg3uYVN2IXrfNedDLTgNedjtODhv0cLXvMUXsJbGGNacZJRvpdrzO/LJon2uuYlvIVN2IXrWLzmjJf4y0nGS/zl8v0+0kg8ga55CZdvXRHhCXSrLsvwBLrmIxzCSUZ9Xx7CU3gJl29dJuEJdM3lW3e+HfV9OYSTjPquO9mO+r48hZfwFjZhFz7C8K11RH2DUd/18Q86+tYBT+ElvIVNGF61l5AHl5OMPKgrXMfFweUpXF51Fxbdfc3lVXcr0d3XfITL9+ubT3T3XcbFweUhPIWX8BaGb+1DXBxcPsIhnGRcHFzG8daeQWxUkvmNDfw3LnyEQ1jqHTcbLg/h+TLYb86At7AJI2dqbsiZyyGcj8/NGfAQnsJLeAvjvO3iEE4yMufyEMZ6neIlvIVN2IWPcPnWTVw8DO8yMufyEC7futGLLsHmLVy+dZMVXYLNRxi+Vgzf7/yjSxDXIOgSbJ7CS3gLm/Df+BMjZtOXK5fGo/loNaHG66YdGvuaTfjvuOrSvtr6LsWjbPrq/NJ4hDFrD1TN7rqZWs+oW/gvsumr10v1Glw0H61H+5E98kdwqRWsCm3O4lq1qtDmIbyLa5zAODWfCOFvvvVfJ0apdc0hPIWX8Ba2PkP5zm6+s5vv7Gaf3WrLu7TeOY26vYdzika8XTds8Ry6Zhz5t1fQoNeMOUfxd8m/itaj/cge+aPTNDFmzafqZNftxsAPJhXZI3/03RWcRfEom77auDQezUdwGcVb2Irx37jwIdcr7q4bmXiK3K4be3iKXPM33xpxO8/RPsIhnGTD6FY8hKfw4hrYFjZh8TXxNfE18XXxdfF18XXxdfF18XXxdfF18XXxPT/hcSsD7XfY6Wi/a97CJuzkwLrVbFCDl0P4q4ry/Grw0ng0H61H+5E98kfnUTxqj+qPuzQezUfrEXZQFpuwC9cR1c3ORI1ernNaN1kTNXp5CE/hJbyFTbh8KzOqa+5xCJdv3ShF21zzEC7funGDx8w1b+EvietIvgq/dB7Fo2z6KvwSxvRizPkUY851LCuEk4xqvlxzrtsMaJVrXsJb2IS/vVArhCrHzFDll5OMKq/XGzTQNU9huNbZQZVfhmsdLar88hGu2xtF2eS/R+PRfLQeYcw6g6jUutuAB8ht/DdnCE/hJVxz3nW8qNXLLnyEQ/i7w1R753ulvTQe1c2sovVoP7JH/ug8ggvGSTJeiy8vYcy2ViSPcN0OK0rQ99NSP2Kdoe8+xyemiqUCJ+lAmAoYB8RRgUNIiDoGgykK/3vh+UTN4Hu9+8RUsVTU52FAIzoRDqsESvnrG/gExsGRoJi/N4SfqCMxHEld1m7D5CdGw+TXT8VQ8efjOI6vuhs3sc6IY4oo4vu/fFV8R/mKuLHm6jhmFLHjkFDFLVzFUVFn3XHkqOUrUMwthoqpYqnYKkwFfHBS8UrsOKl4mXWcVFSp46TihbZFqEgRqNQWGA1nBzXZokY7OLW40j04tfWmcx+cRLzOtjgqagYH5w1FdgWqrMUQH1zz9v+yVGwVpsLl7KA4W4SKpEBn2z0HaG27h43etidMRXCvoY1tn1os9LHtYxBDxVSxVGwVpsJV4Ixi1njFbZEi8Jp7DgRmgINDqR4cAko1cAgoVZTLQKm2cBXlExAo1RZDxVdk8P9KtXET60ii9ga62XYsiK9UcbhVqhcxV5xhlGrc/8VUuIqjos5W4AShVK9AqbYYKqaKpWKrMBXwwVGiVAPnHqUaOPcoyMS5R0FegZfUFkPFl384mu81tXETjejEQwxiPvzKuXEQ6RZ0C7oF3YJuQbegW9At6ZZ0S7ol3ZJuSbekW9Itn1s9oQ0JXX1sjZtoRCceYhDz4VfZjYNIt0G3QbdBt0G3QbdBt0G3SbdJt0m3SbdJt0m3SbdJt0k3XPRm7Vw8S+2JoWKqWCq2ClPhKqoSE6aoxKwKQe/ZzqoQNITZ7wcxVSwVu8SE+A73/rkTDzGI+fCrssZBnMRF3ES6HbrVXaBqGvp+FAzz3hDVAg/cRCM68RCDmA+rA/TiIE4i3ZJuSbekW9It6ZbPrXrFGuv7R8BJXMTPLYFGdCLOUJUnur7s5xBYWRiNrcJUuIqjIlSkiHoZfGKomCp0BlNnMHUGEzPAAc+jIlSkiPVTMVRMFUvFVmEqdAZLZ7B0BktnsHUGW2eA5zYAF3ETjejE89AwNla4Xh5t/CC+UTbQiE78RlnAIObD+ir3xUGcxDozY0LU8Y/7v6SIejV9oo5/YAp14fvEUrFVmApXcVSEihQRPxU6g9AZBGaAooitwlRgBljCOCowA6xGXWDbxGrUBbZNnKq6wH5iqqgZTEynLrCfqBlMVG9dYNvEdOpnEnBy62cSLmYjfob04iBOIsY+EHUMMyDqGFYdA7rDnhgq6hjWgFgqtgpT4SrgUycBXV+2MDckw9oQW4WpcBVHRahIEUiGFkMFZmAQS8VWgRk4hKs4KkIFZoBzjWRoMVR8q3NxETfRvh8xBDrxEIOYD+snzi5+ewHLXL8jfnERcaxXmApXcUT4TwXOXEJsFTUabsmgN+yJo+I7cz9sEfw4Chg/jnJ5CE/hJbyFTdiFj7D4HvEN8Q3xDfEN8Q3xDfEN8Q3xDfEN8U3xTfFN8U3xRXLsK0yFq8C5RqHVW/MnkgK/bGq4MYafNn2i6gS3v/Djpk9sFabCVWAGCREqaga41YWeM8P9MzSdGe6SoevsiaWiZoDbY2g8e8JV1Onf4BBOMn5r6fIQnsJwuKKOBG+b0W1muAGHdrMnhoqpAkeCk4TMaWEqXMVRUYeCCdxfZilG4vgV5Y97b2g8e+JzwasiOsnw4mD3ayrgKbyEa7p4d4MnvT3hKo6KUJEiECgtMGGcI7w5abFUGGd8v40KPsL4AhM4yfg26mXYXTFVLBV1wLgVh8fEPVEHjDtpeFDcE6ECTfnF6DG5PISn8BLewibswkc4hMU3xTfFN8U3xTfFN8U3xTfFN8U36Xt73C4P4SlcZxs3MdHk9oSpwNleEEdFqKjthRuFaId7YqiYKjADg8AMHAJ9N2AXPsKwPxApAm+PWgwVU8VSsVWYCldxVOgMps5g6QxuAyx4Ci/hLWzCLnyEQxiNecVokLs8hHHgAbFUbBWmAgeeEEdFiLChokbD2yh0vhluheJhdk8cFSECYYQ3U2htM9znRG/bE67iqAgVKQLvmHADEx1uT0wVS8VWYSpcxVGBGWBx8I7pCrxjajFUYAY48XjH1AIzwOnFO6YWrgKv+eAQTjLeLl0ewlO4HHBfFq1tllhNXL1kLROa254YKqaKOpLcEFuFqXAVRwVmcCBSBDKmxVAxVSwV3wwcl3PogXvCVRwVUQLHUzHTomLmiVECs66YcVwooBfuCczAIUwFZoCJzqMiVKSI9VMxVEwVS8VWYSp0BktnsHQGS2ewdQZbZ7B1BltnsHUGW2ewdQZbZ7B1BltnYDoD0xmYzsB0BqYzMJ2B6QxMZ2A6A9MZuM7AdQauM3CdgesMXGfgOgPXGThmEBAp4vxUDBXfDBAReKpf8xY2YRc+wiGc5Eq0ZhzgFXUYuD5Gc+ATdRgD1VXx1KLy6YmhYqpYKrYK+FRF4sF899zhyXz3pODRfE8sFVtFLQvusKFz8ImjIlTIxkD34BNDxVSxVGwVpsJlbjeirggVsjHQa9hzQ0S1mCp0BlNnMHUGGlGhERUaUaERFUu2ZixdhaWrsHQVEFF3bktXYekqaESFRlRoRIVGVGhEhUZUaESFRlTciMLctq7C1lXYugpbVwERhTd+aHN8AqtgEEvFVmEqcA7u0EdFqEgRiKgWQ8VUsVRgBglhKrTMkEq4IYtexxZIpRZDhW6+s1To0h9d+qNLf7QAjxbg0aUPXfrQpQ9d+tClD1360O0fuv1DNx+Caw6IoWKqKB/clMbjCH1i1nXV9YSrOCpCRVLgoYRPDBVTBXw2hKs4KkIFfGrzodnyiaFiqsBV14DYKkyFqzgqQkWKwJu7FrhSxkTxFq6FqXAVONK66kq8UcMbhMSdoxZTBVbuQGwVpgJnNCCODhAq5F0JWjKf0BlsnQHes7XYKkyFq9AZbDU1vB1MiKViq6iDwx0odF8+UScRHy3gAYZPpAjkDt6n4hmGT0wVdXpx/x+PMXzCVLgKzADLiBBqkSIQQi0wAywWogY31dGy+YSrgA9OCKKmRYpA1LQYKqaKpaJmgLvyePrhE67iqAgVKQIh1GKowNBYEmQIbkLjZ4AhBp5r+MRQMVUsFTgEgzAVruKoCBUpAunSYqjADBxiqdgqTIWrOCriLfBAx2cLXDC1GCqwchvC3xkdePbhE6EiReBKqPpdB34suE8iAqWFqYAPZoDrnRahAj5ZYusybl3Grcu4dQZbZ7B1BrjeaXFUhArdSKYzMDW1dwd83F8PvnyEv3EHFgo/YwLGbxFdrsMynFhESYulog7L4I0oaeEqyh1n7/7ICTjJ90dOwEN4Ci/hLWzCLiy+R3yP+Ib4hviG+Ib4hviG+Ib4hviG+Ib4pvim+OKCxrBUuKBpsVXgZGO1cEHTovaQoawRRi2SAs9q9PrcZeBhjU/UDOrDloGe1idqBtXPOdDT+oSrqA8sJjiEk4wnul0ewlMYDlfUkdQnKgM9q14tzgM9q08MFVMFjsQhtgpT4SqOCswgIVIEkqfFUDFVLBU1g4PjQSa1cBVHRc3g4HiQSVcgk1rUDA5mjUyqO+UDvbBPYAZYdGRSC8wAE0UmtQgVKQKZ1GKomCqWiq3CVOgMTGdgOgPTGbjOwHUGrjNwnYHrDFxn4DoD1xm4zsB1BkdncHQGR2dwdAZHZ3B0BkdncHQGR2dwdAahMwidQegMQmeAq6RAieMqqYWrOCrQMgROMu6AXx7CU3gJb2ETduE6wPrIY+AnlL0+yxh41OQTOIwFYSpcxVERKlIErpRawGdDyLLg4ZL3pODpkk+kCERUi1qWeqMw8ITJJ5aKrUI2Bp4y+cRRESpkY+BJk08MFVPFkomurcJUuAo9B4io6mgfaBJugYiqj3AGmoSfmCqWippBYmhEVAtXcVSEihSBiGoxVNQMElsMEdXCZOmRSon9hlRqESpSBFLpLqPr0rsuvevSuy49UqmFq9Cl11SamkpTU2lqKk1NpampNDWVpqYSHnXpicJA9lyB7GmB04vzhuxJzBrZ02KrMBWu4qgIFSkC79BawAebD9dOLUyFq4APNh+unVokBR6G+QRe7xfEVLFUbBWmwlUcFaEiRdRlUn3kNdAH3byFq3ULk6zQaj7Cn8Op7viBFugWFVlPVPuQg6fwEt71BwPCVLiKuja+w4ZwkvHjk5eH8BRewlvYhF1YfJf4LvHd4rvFd4vvFt8tvlt8t/hu8d3iu8XXxLdy6dSHngO/M/3EUoF2pfs3pgJnG/ukQuqJUFH+YLzzuzyEp/AS3sJwqEJHz/S5++/gSLA7zlSxVGwV2DcB4SqOilCRIgIzSIihYqr4ZjDheX8iA2zC1YOFY8FDti+HcJLx5PzLQ3gKL+EtbMLim+JbeXTuNqk8OvWx3MAvWD8xVEwVS8VWYSpcxVERKnQGAzPYEEPFVIEZTIitwlRgBgZxVISIOVRUg88Bm7ALH+EQTjKegnN5COM4HGKp2CpMhas4KkJFitg4kwkxVEwVmAHmtrcKU1F7CScfT+m/HMJJvj/GBR7C5V2fLg38EPYTW0V512chA+3WTxwVdfQTW6eCqEUl0RN19HcGPlUsFZgBtgHi6P4v9QQQ/P/rwT0X8cc4j0ifFqbCVRwVoaKmv3BgSJ8WQ8VUUTPArU50Wz9hKmoGd9aVQE+ECswA2yd/KoaKqQIzwCZJzADHU4lzNtYTkdMiKdBd/UT54DYsuqsP7keiu/rgHjO6qw9uEaO7+glXcVRgBgciRSByWgwVmEFClKlhokgZvK9EQ/XBLUo0VB/cQkNH9RMpAldFLYaKqWKpwAwwN1wYtZDNiu7rJ1LE+qkYKqYKmOKwEUotTEUdNi4W0H39RKhIEQilFkPFVLFUbBWmQmewdQYbM8CS7BRhPxVDxVSxVGAGONeIphau4qjADAIiRSCaWtQMDmaNaDrYVYimFjWDg8KoN3JP1AxwXw8d3k+EihSBq6sWQ8VUsVRsFaZCZ3B0BkdncHQGoTMInUHoDEJnEDqD0BmEziB0BqEzCJ1B6gxSZ5A6g9QZpM4gdQapM0idQeoMUmaA1u8nhoqpYqnYKkyFqzgqQoXOYOgMhs4AyYfbwOj+fmKrMBV4Aww+wiGcZNzLujyEp/AS3sI4wHo58BtrV+AwHGKqWCq2ClPhKo4IhBdueqM1u0/X1pOy9aQgolocFViWgEgRiKgWQ4VuDNMZmG4M041hujFMN4bpxkBE3bkholoMFboxbkRhbjeirjAVOgONKNeIco0o14hyjSjXiPKjW/PoKhxdhaOrcCMKczu6CkdXQSPKNaJcI8o1olwjyjWiXCPKQ/fBjagrdBVSVyF1H9yIukJXQSPKNaJcI8o1olwjyjWijkbU0Yg6P9kH57dUbBWmwlVgBgkRKmoGuA2M5vEnhoqpomaAu+xoHn/CVLiKoyJUpAhcqbXADHAIuFJrga4DsDMo0CF+cKcVHeJPpAiEWAtZ7LOmiqViqzAVruKokMVGh3iLrYu9dbH3VLFUbBWmwlXgSCtG0Qf+xFCBE4rzhngLzBrx1sJUuIqjIlSkCMRbi6ECb4CxCgixFq7iqAgVKQIhho8G0O39xFRRR4rPCdDv/YSpqBng0wC0fD8RKlIEQqzFUDFVLBVbhanQGYTOIHQGoTNInUHqDFJnkDqD1BmkziB1BggxfE6AX30/uGWPn32/Au3lTwwVU8VSsVWYCldxVISKbwZ4u3qfTXt5CH/2eHuK1vLmLfx57w124SMcwknGM7guD+EpvIS3sPhO8UVm4VMONIaf+rr8QGP4yYTYKkyFq6gvKOCGPpq8A7el0eT9xFZhKlzFUVHfg8DtZDR5t6j8eWKomCqWiq3CVGAGP4ijIlSkCMcMsAt8qKhvHeLk4NHxl7ewCbswzLE0+NoIPpxBe/YTrgLfQgaHcJLxXbjLQ3gKL+EtbMIuLL4hviG+Kb4pvim+Kb4pvim+Kb4pvim+SV90aDcP4Sm8hLewCeNEJ8RRESpSxPipGCpqb+K+Nrq2n6ilxo1xdG0/4SqOilCRIio0nhgqpoqlQmcwMQODcBX4LgA4hJOM9oLL8MDZXBjpQNSx4PDrgqY5yXU5g8s2dGs3T2E4gLewCbvwEQ7hJCNeLg/hKSy+Jr7Ij/pax0BLduCGOFqyA/ez0ZL9xFKxVeAs4VAPRsManaFiqlgqtgpTUScFn2+h8fqJUJEi8A20FkPFVLFUYAZY0TAVruKowAywUyJFJGaAgsqhYqpYKrYKU+EqjopQkU9MdG4/8TeDWS8jsxq3Hy/h/bGBTdiFz8cLHMJJ/oLl8RCewkt4C5uwC4vvEF+kRn3/YOL5u1HfMph4/m6s+5+5iqMiRCyMhkNdGM0hTIWrOCpCRYq4EREQQ8VUsVRsFabCVRwVmAFWFFlxBcKixVCBGWCnIC9a1NKAkRH1PJuJXusnpor6+41FQEa0+NZ24HR8FxOPj3CQkRwbS4N82Jjwlw9zwu+Lh8dH+BtpwvnLhuYvGh5/u3Ni83zB8HgJb2ETduEjHMJJrqfsN4tvii9qfmP/obLr46GJNuiozv6JNugnhoqpokarT5EmepqjPkWaaGpugeuAFkPFVLFU1GrUx1ATLc9PuIqjIlSkCFwHtBgqcDwJsVRsFaYCM9gQRwVm4BApYv1UDBVTxVKxVZgKV3FU6Azql2aQz9UL/XgIf7sD8VaN0I+3cO1KrHk9g7/5CIdwku0nPISn8BLewuJr4ov3H/Vx4UQbcxiOBtngmDayoYWpcBU1WjXUT7Qkh2Nz4PqhxVZhKlzFUVGrUU/RnWhJboHrhxZDxVSxVGwVpgIzQOng+qFFqEgRuH5w7BRcP7TADHCucS1wcKqQGC2SYiIxWgwVU8VSsVWYCldxVHzbrD6hn9Wa3FyXBM3fNsOrVT1M+PESru3tYBN24SMcwkmeP+EhPIWXsPhO8UVy1AekE53IUbcbJzqRo240T3QiP7FVmAqMhqFxLXBwbnAt0GKp2CpMhavAaiREqEgRuBZoMVRMFUvFVoEZGISrOCpCRc0gsFNwNdGiZlBvpiZajJ9YKraKmkHgjCIxWhwVoSJF4F1Ki6FiqlgqtgqdQV2GILJmXYY0h/C3M1Hf1Xj8eAh/OxNxWV3Hj7ewCbvwEQ7hJNdlSPMQFt8UX7zzCKwgMqVumk80FEfdzJ5oKH5iqlgqarS6Fz3RHBx1x/mvpn4qhoqpYqnYKmo16g7tROvwE0dFqEgRuAppMVRMFTiehNgqTIWrwAw2RIhAltQ9zonW30icKlw3tAgVKQLvK1oMFVPFUrFVmAqdQV0/bEytrh+ak1zXD7hGrS7gx1P42064qK0W4Mcm7MJHOISTjN/JuzyEp7D4uvgiHxJLUymQP+yhSoGsu7oT3b9PLBVbxSmB5QyMBp8YKqaKpWKrMBVeAmcxjopQkSLyp2KomCqWCswA+ztNhas4KjAD7JRMCjT2ZrX8TjT2PjFVLBU1g7rJONHY+4SrOCpCRYoYPxVDxVSxVOgM6pIDV1jV1/v4CFewJzjJdcnRXMF+wFN4CW9hE3bhIxzCSV4/YfFd4rtwZhcEzp9B4PxVUaOd94mhYqrAaDgdG6PhuHeKsJ+KoWKqWCpqNfBOHg26T7iKoyJUpIi61nhiqMAMcHZ8qdgqTAVmgJ3iRwSypG5bTjws+YmpYqnYKkwFfLA+SJkWOFKswkkRyJ+JiSJ/WmAGWCzkTwvMACce+dOiZoB3mejlfaJmsHASkT9XIH9wDw69vE/UDHCnDb28T9QMcDMKz1B+AjPAYSN/WmAGOGzkDwS6fBNvNtDl+wRmEBBLBWaQEKaiZlA9wxNdvk/UDHDXC12+LerdDu5gVJPv4ym8hLewCcN7QhwVoQLedV7Q7PvEUDFVLBVbhalwFUdFqNAZLJ3Bgg9WZmE0LMbCaDj/yKIWKQJZ1GKo0OPZejxbj2fr8Ww9nq3Hs/V4th6P6fGYnlHTGZjOACl1DxtZdA/b9XhcjwdZ1GKp2Cr0eFyPx/V4XI/H9XiOHs/R4zl6PEeP5+gZPTqDozNAFt3DRuLcww49ntDjQeK0cBW6Q0KPJ/R4Uo8n9XhSjyf1eFKPJ/V4Uo8n9YymziBlBuihvYeNTtl72P6T4/HfUREqZMejU/aJoQI+CbFUfAlSXdqzGmUfu/AhIyVwaxiNr4k7u9X5OnEzoZ54/NiFayTMqS5HmpNclyO4xVF9so+n8BLewibswkc4hJO8xXeLLzLBcPiofNwVRnNsGpYSlX8FKr/FUIHRcDpwFWI4blyFtEgRqPwWQ8VUUauBOwZodH3CVLiKoyJUpAhUfgvMAGcHld9iqdgqMAPsFFR+C8xgQYSKFIHrkxZDxVSxVGwVpsJV6Azq7gfuzDh+6BiMnzq+/O0O3Nhw/Nzx5SX87crAmPjR48sufIRDOB8f/Pzx5SE8hZfwFjZhnNk6ALSoJu4Ko0U1cZ2PFtUntgpTgdEqQtBumriPi3bTJ5aKrcJUuIpaDaQNOlGfSBG4VmgxVEwVS8VWgeMJCFdxVIQKzABnFNcXLTADnB1cX7TADDAAsgR3QqsTdcb9r1z4CIdwkuvuSfMQnsJLeAuLr4kv0qiaPCb6Up9IEUijFkPFVLFUbBWmwlVgBlggpFGLFIE0ajFUTBX4G+xy5EeLoWKqWCq2Cswapwr5cQWuD3CfEl2hT5iK+hvcwURX6BOh4ltl3OOrptDHQ/hb5erhnNUR+ngLf6uMO4/VDvr4CIdwkuttSPMQnsJLeAuL7xBfvNfALVc0d+b9X5AS99CQEi1MhavAaLU06PDMekDFRIfnE1uFqXAVRwVWIyFSBCq+xVAxVSwVW4WpwAywWriuaBEqUkSV/a8aNGd1hVJUiwxusVVX6NeJA7FVmApXcVSEihThPxVDxVShM/iqf+FGafWFPnbh8/EEh3CSv7pf93jry87NU3gJb2ETduEjHMJJDvEN8Q2cWWzCwPkLCJw/LHSkiPypGCpqtIHTUZcGP9xUrB5QiqSoLlCKoWKqqNWo1seZaNZqYSpcxVERKlIEWrZaYAY/iKliqdgqMAODcBH4qZXLU3gJb2GMdCBcxVERKlLE+qkYKqaKpWKr0BksncHSGSydwdIZbJ3B1hlsncHWGWydwdYZbMzAITCDhAgVKQIJ02KomCqWiq3CVLgKncH95jE4yfd7x2B8vQc8hZdw9fBjA+CrMJdd+AiHcJLxLZjLQ3gKL2HxPeJbn9r+0JVV/aN/AkVYn8/+qtF1Vv8oxVZhKjAahkZa4H5t9YJSLBVbhalwFbUauJObSJgW+cT6IWFaDBVTxVKxVWAGG8JVHBWhAjPIEkiYFugKHRBTxVKxVZgKV3FUhIoUMX8qdAa4jnHwEt7CeKsDduEjjPf+4CTjXc7lITyFl/AWNmEXPsLiu8QXaVO339cPmbKwNMiUdf+zoyJUpAgkx8KhIh8WNgfyocVRESpSBK5AWqA7+QcxVSwVW4WpcBVHRajADLCi56diqJgqMAPslLNVYAY4vUiMFimiOj1+GyceWdICR4rTiyxpsVXAB9MJV3FUhIoUgauVFkPFVLFUbBU6g9QZpM4gdQYpMxi/n4qhYqpYKrYKU+EqjopQgRnUhh3InxZDxVSxVGwV9fWnACdLYdxcuWKomCowMgaYUjFjHhWhAkdQoTlwXdNiqCifupu7Bq5r7gC4rmlhKnQGS2ewdAZLahZNqk8MFVOFzmCrKcKl7jQvtKG2wAVLixq6PgRb6ER9YqnYKvCFhQ3hKo6KUIEZVJUNxI5h6yB2WmwV8MGaInZaHBWhIkUgdloMFZgBThVip8VWYSpcxVERKlIEksaxXZAnjhOPPGkRKlIE8qTFUFGH4FgS5EmLrcJUuIqjIlQkxUSe1H3QNZEnLaaKpWKrMBXOBZ7IkxahIkUgQurzhIV21XtG0a/6hKs4KnBwtfnQm3pPIppTn1gq4IMZ4I1SC1cBnwMROoAs41w/FTqDpTNYOgMESgtT4SqOCp3BVlMkxcQ5wDugFqbCVWDo2soTsTFx2DZUTBU4hITYKkxF+RysD2KjBwgVKcJ1Bq4zcJ2BLxVbhalwFToDV1MkxcFJRFK02Cpq6IOSQVK0OCpCRfkcFAYuXVoMFVMFZoD1QaAcTBSB0iJUwAd7FIHSYqiYKpaKrcJUYAbYIQiUFqEiKRYCpcVQMVUsFTV0tTCvheuLugO+FsKhxVSxVGwVpqIOoT70WQux0SJUpAhch7QYKqaKpQIz2BCmwlUcFaEiRSBQsMALgdJiqlgqsHITIuSM4tLjCsRGi6ECB2cQehIRGy2OCvhgBrgOuQKB0gI+B0KX0XQZTZfRdAamMzCdAQKlRYpw3UiuG8l1Bq6mSIpxRahIEbj0aIGhsZURGwOrgNho4SpwCAkRKlIEYiOxPjFkgJgqlgqdQegMQmcQR0WoSBH5U6EzSDVFUiROCJKiRaiooetzjrWRFC2GiqmifOpzjrVx6dHCVLgKzKC28kag4O7DRqC0mCrgcyC2ClPhKo6KUJEiECjVDL7QyvrEVLFUbBWmwlUcEZUUo+7Gr3ow7felRghT4SqOilCRIio2xg9LsoeKqWKp2CpMhas4KjADLONOEfZTMVRMFUvFlgVGoLRwFUcFVq72dbW1vjPqS8VWYSpwcNh8rifx/FQMFfDBDM5SsVXAB7vq6DIeXcajy3h0BqEzCJ1BTBVLhW6k0I0UOoNQU3SP3TOK7rEWS8VWgaGxle9nwDhS9IhB3K7UFjiEhJgqloo6hPqEZd2u1B7AVRwVoUJnMHQG6B1pMVUsFVuFzmCoaSXFwAtLNZ1STBV1cNV+vqrplMJUuIraIfXJ1KqmU4oUsX4qMAODgI9DmApXAR8cDwKlRYpAoLQYKqaKpQIzCAhT4SqOilCRIhAoLYaKGnpiu9QFxpg48RUOLeoC44mhYqpYKuoQJpYEsdHCVRwVoSJFIFBaDBWYAZYRgdJiqzAVruKoCFlgBMoVCJQWQwVWbkK4nNE4KkJFikgcHDZf6knMrcJUwAczyKMiVMCndlU90rUH8N9QMVUsFVuFqXAVR0WokI1UjaoUanq7zBLCVRwVoQJD11Z26T9bLv1ny6X/bKFBdeBDJXSoPnFU1CGs+zcpA9z+syuGCp3B0hksncEyFa7iqAgVOoOtpkgKfCrlSIoWrqIOrr48sRxJ0SJFICla1A7Bxz+OS48WS8VWgRkYBHwcIkUgUFrAB3sUgdJiqdgqTIWrOCowA+wQBMoVCJQWQ8VUsVRsFaaihsZHRo4LDHzi4wiHFluFqXAVR0UdwsaSIDauQGy0GCqmiqViqzAVmAGWEYHSIlQkBXpUnxgqJhcYbapPbBWmAitXOXqQFDij1bZKMVUsFTg4g5CTWG2rFCkC1yH4+OfgOqTFVAGfA7F1AFPhKnQGU2cwdQa4DmkxVEwVS4XOYKnp/TAXE0XfWouhYqrA0AGBT4yvOCpCBQ6h0hJNqU8MFXUI+JwJz0ztAW4//BWmQmdgOgPTGUin/DrSKb+OdMqvI53y6/amtlBTJAU+TTpIiiuQFC3q4PAB0kFStFgqtoraIfgA6eDSo8VRESowA2xlBAo+RTgIlBZbBXywpgiUFkdFqEgRCJQWQwVmgFOFQGmxVZgKV3FUhIqkQE/rwMcdaF7F0/YWulefCBUpArHRYqioQ8CHQehhfWKrMBWu4qgIFSkCgYKPiQKB0mKqWCq2ClPhXOBAoLQIFSkCGYLPmQJJcc8o3su0cBVHBQ6uNl9sPYl4x9JiqYAPZoDrkBauAj4HQpdx6zKaLqPpDExnYDoDXIe0MBW6kUw3kukMXE1x6YHPjAKXHrjqjPtMsitcxVERKlIEAqUFsgqm9zs1VywVW4WpcBVHRYhA5ztezQKBgivIQKC02CpMRR3puaMdFaEiRSBQWgwVUwW+l4ZNcb9nd4WpcBVHRajgdycXnpb6xFCxeULQDXuPFN2wTxwVoUKOFN2wTwwVU8VSsVWYCjnSHEdFqNAjnXqkU490ThVLxVZx5IRMPVKkyxW4XGkxVOiRLj3SpUe69EiXqzgqQoUe6dYj3XqkW49065FuPdJtKvRcbz3X91u8OCGmR2pTxVKxVeiRmh6p6ZGaHqnprnLdVa67yvVIXY/U9Uhdj9T1SF2P1HVXuZ7ro+caiYRbR+iDfcJUuAocab0Y4RmreGDDwjNWn5gqcEYXxFZhKnBGN8TRAUJFikidQeoMUmeARGqxVZgKV6EzSJpuNMyiT3ijYfaJrQIHdyBcxVERKrBdosQNoSuGiqkCM8DccIlTH4xutMU+ESrKpz473GiLfWKomCqWiq3CVGAGE+KoCBUpAiHUYqiYKpYKDL1L4KZs4MTjEqfFVLFUbBWmAoeAJcElTotQkSJwidNiqJgqlgrMAMuIdGnhKo6KUJEikC53gZEuLaaKpQJ71CFCziguca7AJU6LoQJDY/MdPYl4Z9TiqCifxAzwzugK3JRtUT6JXRW6jKHLGLqMoTMInUHoDHCJ0yJFpG6k1I2UOoNU0/tUJJyQ+1SkK5ICz2x9Agc3ISqR6oO3jWe2PuEq6hDq0+WNPtcnUgRiI+GDT3nuAPiUp8VSoTMYOoOhM8C1S4tQkSJw7dJCZzDVFEmRVxwVoQIHVyWDFtgnhoqponZIfbq80QL7hKlwFZhBbeX7NNb6YHTfx7G2mCpWiQGxVZgKV3FUhIoUgeey/rBD8GDWFlPFUrFVmApXcUQ4hsZ2cQyAE++mwlUcFaEiRRwcApbkDBVTxVKxVZgKV3FUYAZYRjzp+Qo86rnFUDFVLBVbFvg+7/kKV3FUYI9Wjo77PGec0VwqtgpTgaGx+VJOIhpdnxgqyqc+HN5odH1iqyif+gB2o9H1DXBUhAqdwdAZDJ3BmCqWiq3CVOgMhpreJy5i1veJi1csFVsFDm5CxD/9NMg98XTnK/B05xZ1CPXp8kaj6xNLBU7ihjAdwFUcFTqDpTPYOoP7lMYrpoqlYqvQGWw1RVIMnEQkRYupAgd3ILYKU+EqaofUtf9GC+wTKcJ/KjCDhCificVCoLRwFeUzcTwIlBYpAoHSYqiYKpYKzAA7BIHSwlUcFaEiRdxnx18xVGBobBc8An7ixOMZ8FfgIfAthoqpYqnAIWBJEBstXMVRESqSAo2uTwwVmEFALBVbhalwFUdFcIEXAuUKBEqLoQJ71CGcZxQtsE+EihQxMXRCyElEo+sTpqJ8FmZQ1yFPhIryqQ9gNxpde4A1VEwVOoOlM1g6g+UqjopQIRsJ/bBPqOl9NjRO4n029BVHRajAwdVWXvcJ0NgU9wnQV2wVdQj16fJGo+sTRwVOItYHT4C+A+AJ0C2GCp2B6wxcZ4AnQLdwFUdFqNAZHDVFUiycRCRFC1eBg7t/EypSBJKiRe2QhcLApUeLpWKrwAywlREoGzsRgXIFAqVF+WzsUQRKi6ViqzAVruKowAywQxAoEOiHfWKomCqWiq3CVGDo2i5odMVTezcaXZ/YKkyFqzgqcAgHIkUgNloMFVPFUrFVmArMICCOilCRIhAoLYaKyQXeCJQWW4WpwB6t2kYLbJ9RvJdpMVUsFRg6IfQk4h1LixSB6xDDDHAd0mKqKJ/6HGOj0fUNoMtouoymMzCdgekMcB3SYqjQjeS6kVxn4Goqvzux8WTXJ4aKqQIHd0UlUn2QuLf87sTe93cnrqhDMAjERouhAicR63N/d+L+L1uFqdAZhM4gdAb3dycg7u9OXDFUTBU6g1RTJIXhJCIpIAxJ0QIHdyCmiqViq6gdUp8ub8OlR4ujIlRgBrWV8QBWPI1/4wmsT2wV5VOfHW5DoLQ4KkJFikCgtBgqMIMJsVRsFabCVRwVoSJFICnqc+eNRtfpOPEIhxahIkUgNloMFTgELAlio8VWYSpcxVERKlIEAsWxjAiUFlPFUrFVmAqXBUagtAgVKQIZUh/Eb7TA9hnFe5kWruKowNDYfEdPIt6xtFgqyudgBrgOaeEqyudgVx1dxqPLGLqMoTMInUHoDHAd0sJU6EYK3UihM0g1RVIg/fHc1SdMhavAwdVWdvzOBF4xHL8z0WKqqEOoT5M2Gl2fMBU4iRvi6AChIkUMncHQGQydgfxC1vb7C1lXmApXoTMYaoqkwKdJjqRosVXg4A6EqzgqQkXtEHyAhAe1PjFUTBWYQUKUDz5FwFNZnwgV5YNPhvBg1ieGiqliqdgqTAVmgB1yf+jqilCRIu5vXV0xVEwVSwWGxnbBBQbu+6PR9YmpYqnYKkwFDgFLgthoESpSBG6BtBgqpoqlAjPAMiJQWriKoyJUpAgEyl1gBEqLqWKpwB51iJAzivcyVyA2WgwVGBqbL/Uk4h1Li6OifHCjEI2uV6DR9Ynywb00NLreAdDo+sRWYSpcxVERKlLE+KkYKnQGQ01x6YHPjNACi2cybrTAtsClR4uhYqpYKraKyiq8EcAzXZ84KkJFisDd1hZDxVSB77WBXfgI4zBxAu7P5UHc38u7YqiYKpaKrcJUuIqjQmewdQamMzCdgekMTGdgOgPTGZjOwHQG+AmtdUWKwA2UFkMFZuAQtaDrCldxVOBID0SKQOi0wJEGxJQB8ENZLbYKncHRGRydAd4WtUgR+Dm+FkOFziDUFJcn+EAPbbJPpIgKHTy+cqNN9ompYqnYJVCKFUdPuIqjIkpUjeEpsAsf/uAxsE8sFfAxCFPhKo6KUJEi8Bt8LTADh5gqloqtwlS4iqMiROCH9vDZGpphF2obzbBPHBWhIkWsn4o6BHyyVQ+PpVgqtgpT4SqOilBRM8CHTPXwWIqhYqpYKrYKkwXeruKoCBGGw/5BLDmjtlWYCleBg8Pmcz2JPlRMFTgEzOD/9PZGu7LrRoLlv/j5PoiMYATZv9IoFNxu98CAYRdcrgYGBf/7KMWd1Dq5b0YyU9xTD2XGOfcElRK5RJFLlCmDwqCfxN6qjJfReBmNl9F5BM4jcB6BCwNlwIbkbEjOI3BW+vXh734Ovj78/RUog8Kg/7jelL8+791/9tfnvb+CxKC3A++BMFAG/ST26/P1ee+vBM6gMsARtG1jkBhkBsJAGRQGxgCVdv9V+oJe919HIAyOH9dX3br/OgJj4AyOFtJX0Fr/bOdX0L/beQ8Sg+MI+vXpe8XK14F2oNwDZ9DrKT1oCDpQ7kFikBkIA2XQj8B6YAycQWXQEHSg3IPEIDPoqWsPeoJ+4jsc7kFikBkIA2Vw/IS+stXF1hE4g8qgIehAuQeJQWZwHEFfZGodKPegMDAGzqAyaLjAHSj3IDHIDPrP3nrgOKNeGTQEdWPQf1xvfJUnsRYGxqD/hH4EtTJoCPo4pI/f+h6x9wSNl7HxMjYeQeMRNB5BH4fcg8rgbEil7xE7gsRAGPTrYz3oP857UBk0BH3ocQ8Sg8xAGBysSl9BYWAMnEFl0BD0j3veg8TgqOcY2ZW+y+sIjIEz6L+0HkF/xDmGeaVv6ToCYdBbfD+JHRv3wBgcZ/RYyCl9Y9eRoCHoQsk94BEoj0B5BF0ouQeFgTFwBjyCwko7ULSfkA6Ue1AYHD/ueC21dJd1BJVBQ9CBcjwnlu6yjiAzEAb9CEoPej29jXZs3IOGoGNDezvo2LgHmYEwUAaFgTHoR9BbSKfLPWgIOl3uQWKQGQgDZXCkLr25dGyUfuI7Nu6BMFAGhYExOH5C6ZekY+MetDPoW7uOIDHIDISBMuhHoD0wBs6gMmgIOl3uQTovcN/adQTCQBn0K5d70M4z2vd2HUFikBn0H1d6gJPYxdYRVAa9nn4EfRxyDxKDXo/3AJexi60jKAx4BMIjEB5BH4d8BX0ccg8Sg8yAR6CstD+xHKtupbus96CPUO5BYtBTtx4IA2VQGNxY5Vs/18cLxSOoDBqCvh39PUgMMgNhcJxE6xe4A+UeVAYNQQeK9RPSgXIPMgNhcKNy+Wo7x0zJCIyBM6gMGoJjpmQEicFxRq038j5cuQfGwBlUBg1Bp4v1HtwZYr0DdoZYr7Qz5B5UBj3b0ci75TqCft68B5mBMOi/p/agMDAGzqAyaAg6Q+5BP4LWg8xAGCiDwsAYHFeu395zB0o/b33X1xFkBkc9x1Jf6bu+jqAwMAbO4Pilx/Jg6bu+3oOOmnuQGBxH4P0IOmrugTLoR1B6YAycQT+Cfk07ar6Cjpp70I8g96AfQb/AHTXeL0mfQ/F+Ejt37oExOOqp/Rx07tyDxCAzOOqp/Rz04Upvyt1/HUFl0BD0Eco9OLqz9N9zTL2OwBj0RtHP6GGojaAhOLyTESQGmYEwUAaFwfETaj+CPg75Cvo45B4kBv1U9QR9HHIPlEFhcPzS3K/c4Z2MoDJoCI4JlREkBpmBMFAGRz2pH/UxbTKC/kuP69P91xEkBplB/6WlB8qgMDAGzqAyOH7pMf9WDv/1DBKDzEAYKIPCwBg4g4qgo+bY17T0/WBHIAyUQf+l3gNj4Awqg/5Lj551aLJnkBhkBsJAGRQGxqBf0+PSdxl2BIlBZiAMlMFej38V7Sz6WaxnsY3iDTD34l5rZ9Dhz96Lchb1LJazaGex/6Ie9Oec1n9rf865B8rgOD9bv1ydL/fAGVQGDUHnyz1IDDIDYaAMeATOI3AegfMInEdQeQSVR1B5BJ0vxzJt6TvCjsAZVAbHGT1WTEsXZUeQGGQGwkAZFAbGoB9B72h9kHMP2hl0UXYE/Qi0B5mBMFAG5bz0fePYETiDyqAh6IOce5AYZAbCoNdTeuAMKoNez3Gxuk8rx4Jh6T7tCDIDYdB/ae1BYWAMnMHtCHTrB3oMcrRPTnSfdgSJQWYgDJRBYWAMnEFlwCO4Mcn7dbsR6V7MZ/HGhn7ybiy6F8tZvLGht5aDRF/FehbbKB4k+iqms5jPopxFPYvlLJ61lbM26+fxK+hnqx+d9bPVL7gVBsbAEXjP1i+e92ytB8qgMDAGzqAyOM79sWJXukU7gsQgMxAGyqAwMAb9CHqbrZVBQ9A2Bv0IertomUE/gt4gWj+CfqpaYWAMnEFl0M6gy7YjSAwyA2GgDPYj6Aw4VNt70c/iXncn7SHZfhVvjLkX91r7/ewQb+9FOYt6FstZtLPoZ7GexTaKN9Lci2dt+awt9/PoPehn6+tvjrOV+2/pvLgHiUFmcGQ7VqJKd2f1WIkq3Z29B7oxSAwyA2FwnPtjVal0d3YExsAZVAYNQdkYJAb9CPoVKsJAGRQG/Qh6uyjOoB9BP6OlIejkuAeJQWYgDJRBYXAcQX926ortCCqDhqDT5h4kBpmBMNiPoN9tD/X2XrSz6GexnsU2ip0w/YGry7MqX39jDPro6CuoDBqC/lR0DxKDzEAYKIPCoJ+r3hA6Lfo6Tt9MdgSJQWYgDJRBYdB/qffAGVQGDUHqR1B7kBhkBsJAGRQGxqAfQevBcQR9faXvOXsPjlHLCBKDzEAY6HlNu4o7AmPgDCqDhqBT6B4kBpkBKNRV3BE4g8qg/9KjPxspZKSQfVHoKzjq6dPiXbgdgTPoZ/Tr34CDVjYGiQGPoPAICo/gi0JfgTFwBpUBj8BYacdLXy/qKu4IjEH/cb0pd7zcg4ag4+Ue9ObSm3LHyz0QBsqgH0Fvo30wo72N9sHMV9AHM/fgqKevOnThdgTCQBkUBsbAGRxH0Cfzu5d7D/pg5h4kBpmBMFAGhUFPfVySLtxqX7rpwu0IlEFhYAycQf8J1oOGoNPlHiQGmYEwUAaFQT8C74EzqAwagk6Xe5AY5PMC+xddvgJlUBj0NnqQvO85ez+jHRv3IDMQBv3H1R7wJHZs3IOGoA9r+jJMd25HkBkc9fQVke7cjgS8jMrLqDwC5REoj6AD5R4kBmxIhQ2p8AgKK+2k6I8jbhuDxCAz6D8u9QDPJm7OoDI46ukLJ12mHUFicNTTFwCcT0fOpyPn05Hz6cj5dOR8Ouob0N6DDpR7kBhkBjyCyko7Kfp8d5dp70EnxT3oP653mU6KeyAMlMFRT1/h6TLtCJxBZdCP4Lg+XabVvvLSZdoRKIOjnr5W0mXaETiDyqAh6EC5B4nBcQR9SaXLtCNQBoWBMXAGlUFD0EnRn9O7TKt9ZqHLtCOoDBqCjo17kBj0n2A9EAbKoDAwBs6gMmgIOlD6ck+XaUeQGQgDZVAYGC5wB8o9qAwags6QviTZZdr7Ge1Dj3tgDJxB/3G98RlPYsfGPRAGvZ5+BH0ccg+MwVFPX6TqMu1IwMvovIzOI3AegfMIOlDuQWHAhuRsSM4jqKy0k6IvoPU9Z7UvHvU9Z0dgDBxBx8Y96Nn66e1wuAc9W6+0I6Cvr7Te0fuyResd/R4UBv0IvAfOoDJoZz19L9j73/SOfg8yA2FwewLTvrZwuLBnYAwcQcY56Mbr18/uxusIhEHP9vVv+u/5ytZ/T+tBQ9B7/T1IDDIDYaAMjjPa54C68ToCZ3AcQZ8J6sar9unybrxqnwfvxqv2Z+e+4+v9xx3q2giUwXHeylfQ6+ntoPftPgvdxdgRJAaZgTBQBoVB/6X9AncE3IPKoB9Bvwp9TNH6eTvgUPpkdRdjS7cJ+46vX4OSvuPrCAqD2yzB10NX39f1HhyrOCPo9fSz45mBHEE/VQcCRlAY2BH0n30gYASVQTuC/ksPHowgMcgMhMFxBH1etfuzIzAGzqAyaAgOhowgMej19LNzrBL3h1XrxmtfIbVuvI4gMziO+piltb7J6wj6UZceGANn0I/aetAQpI1BYpAZCANl0I/Ae2AMnEFl0BDkjUHC2cm9ntqDwsAYOINeT+tBQyAbg8Tg6PXSExxrwSNQBoWBMXAGlUFDcIwpyjGTa30v2BEog8Lg+KXHNKj1vWBHUBk0BIclq7mf0ZIYZAbCQBkUBsbAERx0Kcf8jnVLdgSZQf+l/ZqaMigM+i/t7dqcQf+lvSlbQ+Abg34EvVl27twDYaAMCgNj4Az6EfSf3bnzFXTu3IPEIDMQBse5/urBxzxsf7CxQ6a9bZDZg4bgmIcdQWKQGQgDZXBc060fwfG6zwicQWXQj+BoiX3/2BEkBpmBMFAGhYExcASHnSLHPcu6TNsFG+sy7QiEgTIoDIyBM+jX9KuehqAT6R4kBscv3fqBHrtCjkAZFAbGwBlUBg3B4a2M4Pil8hUog8Lg+KXHqy7WndsRVAbHLz1WG6w7tyM4fumxcGDduR2BMOhHoD0oDIyBM6gMGoKyMehHUHqQGQgDZVAYGIN+rntqY6sytipjqzK2KmOrMrYqY6sytipjqzK2KmercrYqZ6tytipnq3K2KmercrYqZ6tytqqKVtUNxH3B6l+//WEv/fcf+v31Nhncb65HyUepjlK7l/oN9Sgdv+Y2jSt5lGSUdJSOOm67U/XGepR8lOr479q91BvobaTdW+dRyqM06tBRR2+RtxFrb45Hqdeh+2+V47f2msr919xK/dccpTRKeZR6TWXPoLcMHSvH2StnfEw5+igdtRwzdUctt1m2jhbL+78z5PH7f3ObD+3/zVFKo5RHSUZJR6mMkt1LX+frdoR+q+mrp/r9vBwlH6U6Sr13+v7vKtrFNtrFNtrFNtrFNtrFNtrFdj+Tt9FcP5NH6Tj+20pHbxdHqYxSr8Pu7UJvx9+O4+hsaPdzcZRklHSU+u9s+7+73Un2U9z/qt7+IH14JtLRRfolEvvX/id//fuf/vjPv/z9b//+z3/8+c+3v7z/wX/+4X/8z//+w3/88R9//ts///A//vZff/3rb3/4v3/8638d/9F//scf/3b87z//+I/9b/dT9Oe//e/9f/eE/+cvf/3zrfSv385/vT3/p/2J8/jX+/OMjwT7TXI2xe3Tj18pbl8ZRIryS4ocpJD7QUgrZwJPswks3c/Bvqg4Ekj6NYE+T5COef4jw+0NgacpSnQebqO8r/Pg8jRFdCprGSei1vb0VHpwQY9d+/oFFTmPYr9p/ZKiXr0a4c9oZ4atPv0ZKchxW0T+ynFbAR45TH9NkaJrertPf13Tkp+mCNqV+/2S7jPG5+8obTpD1fvP2GdVn2cImmb/GHq/ovt4d+TQX3toCppmvS0q9INo/vwgLLikxycn+yVNBV3M6mfXw59fj6hV+HZnzW1h9GmKFhHvNvv2RTxNz1Lk7eo1zenyNc356jW9PRQ/y7B3zfv12KeKz5uHiM7/kOObtl8/pKSnPyRonMdOaL1lbU8TxKhoNhpFkqdX1K+zO8qhx1btRw7NFtwHW3gbyqOL4GzkZL/kkOh01PsV2edZkKHMN4xjL4zeMMTL04YhQfNsxwx+z1E2AuPX45DgOLJvo5d4BjDeuCZ+7+y33XefXhMJ2meqt7F/vyb7useZI/86ypIAn8dLQuPCasE9Mf/a0MUXtI56tXXEv8U2G4dhpT39LRoNPI+vr32BA0OdPfg1R7raPsJWOonA+Hw0PceOjUOmx/Oh0Q3Wt3GDdZyPxxwRSd3rOB/1bO1Sfz0jalGPGTf626cynueIaJpHA5Gct+c5ajSOlTtNc1Z5niOi6bENeL8wvxC5zjeQSRSWdB2FJV9t6vGFbfeTcfsmxdMTWqJGalLHbVKfN45Srl/YYpcvbHg62nhOuu1Z8/ww6oLT0a6fDtuun45wEDa6fa4eHEbQRvf10Ptj320DjeddNjqOZjJGg1twHEErNRvHYZ6eYzCEuh3bPvdzasIR9gOQLchiefRak2zPc0RDmLSNfpvQ89/K4ecwqGKU/i1Hix6Fx13O9/87z2r+dYjsQUN1HTco35fbnucIaCpnvwXF9rmOXzNELD2+xvjV5fAQ+S1HMDQ95tx7U5ftswxtDMRSeZohbF3HBl49habnLdQtenbS8UPMPszhfj6Ue/4sRz0f7Ov2PEfcZ32ro8/uUzdPs9TLj0/hcXga03j7KFeeDwhr0Er3hcVyv7x72bcn9/x6+QEqJEdt520Sx/Dtl5Tr5Kh2nRzVr5Kj1uvkqO0qOcIMU+SIW2it45HFW3ne31q+2lOi1nXbcGqMGLJ+1uvr4Wn331K1PX+0btG4Q85HJ85671f81xx2tbeFR6FjHeP2ZtbTowinK3w089S0Pp2uaNGg9FgC+5oj/YXo28Os3BahY8yp3fbDRZI0n6ToOJLbW8ZBknx93iRtcrW1x2e1jvZhOX12ZUzOHOGViZ59tjquTOL8zWNjDw+kngP1XIIDCXiajg0Q+oVRttWHA0lbi5arBkREqn+WZPaUpHiBY7KdpfyT7Uy2c0F2q58RQLaxVrMv/fjzyxstO6WWx1ndy609Q2J0IKmMZ2wJOk1K0aLo5ucqBcdj+6j51yRBY3UbP8adM7jvJKk2Fgmq8UnsMUm0/jTdzqKVm7l2FndfxTg3BT0vWmzoG7Df1+MsSKLhTW+AxJ0X+PGMlMv37xBFYzVsL/lnPU/GbKHsc3bPG3y+vIQfHoaOQfs+zSXPD0PCialzEkWErb2+kaTp6Lxb3YIk0Tyuj/mt5niOeXx+SNF6VPMycmACVfyd4/DzOLDs8f04Qq766DIbJ9oejyTqMvtCy5jx4yT9ty4Trkjti6V45LbypNOkaEmqv7DxRYCiwZG0sJW0s5U8f8hM0aLU7JNqilalZh9Vk+arz6pJ5frDaoqWpeaeVuMUU4+r8f27jNmhfQAc3DWjVam9hQy8b7hbPboj0aqUnLMhWyDSaDjhn4Z/kl3ReR/uvCVi4tbyGALsZXm6qBSitX+G6+t5MwV8Liuersrlp6sYI1XL+UQizzESrU7ZsW/mfU4VVNzSG0l8XGLzEiWJZqu2NBZRNww3VR9/TnBO2gn5fSVTgyTRzL+NHrxP79pzoEVrVLfNiu4kKRX3rDdGijZMoX2oFowUo0Wq4y3Qc7UeJ/bhjFg4rypoajk4Eo0WZNPpCzUkkcck5TrUonWESaiZL4Ca1TVQixidzpHrPjx6zoFopWqfXBlDLG/BeDFaqpoeTkSrVdPDiWixaXI44bpgOOHl8nAiTDE3nChtxXWpK65Lu3xd6rbgutR0+bqEKeauSzgc0TQm4UsLnvRqNNw8Xiv9utHgfHzDal2A1Xodq3UFVuv/D1jNY7VZfrldPWK1hQPO03YR6h2PnaatwGpbgdV2HattBVbbday2BViNtb8x+5Uxk/dtsNlqOD7DIv4mHqRZgPi8LdBV8nbZV8nbAmElb5eNlTjFZBuJXIBja82vU4onvcdHoxytX8lYAxPlytNDhmjh2cea8W1rKtD58TAiIm5+PgU0e5okPiFpDDTdeJ94PCHRGxD7AHIQ3iuP5PFNjugGvo21eCw9f0+Rrz+zHre1q8+sOXppavaZNUfrV3PPrPFxzHIomv6a5lC08jTJofDVqVkORYtXkxwKU0xxKG6pk/eqHE1IzN+rcl7RRnJZ0EayXW4j0Rs3822kXm8j9XobCYBYx7IEjehvQJR0fRohS17QPqK1q+n2IXq5fURrV9PtI3K+JttHmGKyfUR3XZNz+btFLSQULeR87wdH8i2JLpityrrgsSrrgseqrJcfq7IueKzKevmxKk6xYMhsBUMZeT5CjBaudBuzIrqVYFAVvk+lQ9XYF33On9N+XYXL0cpVbuM1pH20iLPaHg4keqOqf17qa92K0wj60GnCV6psiBZ7sT2dXInvEcOC2y9Het57o7eqZidFclkgWeeywLLO5bJmncsCzzqXy6J1nGLuJhHy/RjZfw00PWgh0aLVdAuJFq2mW0i0aDXdQqJFq8kWEq1ZTbeQUD+fayFhirkWEsPsfPVOofR+g1n4ZtXs8260XjX5vOsLDJrsK8aqfn2s6ivGqn59rOrXx6rRbZdOcMb7Vd9uu75iUrWumFSt1ydV64pJ1Xp9UrXKz17cX5Zm7PnFjZaryqZj/m/DWlOyd0aZbbxnmnBOv40yo/WqOpbeKnbs+EbD8A2pYSSVxlWzh6NoK5ppu95M24pm2q4303a9mYatI51vIUvUOqKXrKYZ1FZMqLbrE6ptwYSqbJcnVOMUc0+p4R5MZezBZPZ0V63odbFzwzelSPxtq54tuulv4/UKScI3EvyNJJwblhwkiV5LnNt8TqJVqrnd58IUc1uVSfRq1OReZRI1j7nNyiR60p7dgW7+qnhwVWabh8qHbSyNLTskB+8BSfh+1eSmlRLu7De59Vn8c4qN18Us/DmRUeVjMmUvosFLeyNJzWM9tepz/UfiF6zmOm9OlztvlGKy84bO7GTnjdanJjtvtDo13Xmnr0rQecPm0YY74I0bwn1rHtH01NwWkhLt9Dd5bUNdbvLaRgtUk9d2yR5qK/bZkmh5an7PwctvAb5g0NjEyGv7EGQ1tRMg/lwPFwltKj3fi8TE4eObgDHcz62ypHkwqNIFSNXrSNXrSNUFSNXrSNUVSNUFSI2bx3gtQ7dfXst4bB51QfNo15vHdSqX61v7Srm8t69EL1TNN4/6083jfE7etvrZcFlPsUw3DdpYtDA1uaW4lAXttFxvp+V6O7UF7dSut1Nb0U7LgnYat46rMxhlG9uelq083/ZeogUly0OQNZXgtm/ha39DTOGI7NtdPz4ffp6P+uE5nduuXaJFqX2B/1wegw76LUe+3mvDRam5XhulmOy14ZLUZK+NlpMme637gl47fVWCXhu2jnMHocxp2LdylDFpePs61dMc8dtPYyuU2zctP8wx3kwNc8S9Ze7RtOrllh6lmGzpNVzhn/qygITvT818WiA+isn+Fq1GTfa3aDXK0li+vX3r7Hl/m09SPkyiw2fZ708pSCJXr0v8W4ZGthc//S3nXufGfZPfTHLuNizbp5dGxv5FJniB43uS6K5fx4xBY0v7NocSJpmdzQmTpDEx3VItHybJY8zfuAzzXpLJeSWN3nuanVfS6BFmcgf38Dh8LPU1/6W9lk+TtE+TDCzuxfJZkrSPl89x6laDCbv4Eo/Vy6Z4rHuzsZ37Q+VinyYZQvieJOiA83fwp0+pGr1C5ef8owczEOHof+qbOhotT80+tMdJjoXrL2kg1yBJNA449+vIrsGvuf7kr+nyk3+YYm5kpQs+PqXXvz6lecGT//xV8eCqhK3DTjJX/SiHHNs8fP2Y5p/m2C7nkHNoJbh9v5fDzi036/Mc4Ueo5p6HXuSYeh6Kf4uejUytXs/xYRuTPG5S+4zr82sbbvtnhm3lg14XHoiX0UD228TzA/EFF9d/+OJ6On9L0HHDFZBtqGDp1/ev3jqp50stNWhl4Y5/U9uFaLQytT8Ijd/S/PmzWXgcOuYO1SQ4HeE9e9ggKlz/fLxnRx/omZz303DLv8l7ttbL92ytl+/Z5fpav5bLa/0aLUxN37Onr0rA07B1zM37xTnm5v202HWMxS19as5Oy/VWWq63Utsuz9lpuC41MzcUH8VkX4mWpSb7SvSq1Ox0TJxk8pEyTjL5hBwnmZwYipNMTgy9OCdzE0MvzsnkxJAv+LKf+vVP+4XHMTsxNJ+kfZpkcmIoSjI/MfSinczN6bwB5+dDu/C9qZnpmHhEpXqOypJ8OJWi54ajGk2l1PgbF1POsUbvPM06x/HPaWPr8ZK2HPycsuLn2A//nJJGkpI0+jn1J1ta0TF2L6UFk3bRcoam8SyT+Wnfh+Nol7/tGx/FMCn4JPP9KCT6IWOYuU+p+dOjCGe5q5x7BNSyfZakjcf2vUw95a0k51e/ElW9d06q47OpwUmtP5pif2pv5x2ipuc/pa64MnXFlakLrkzYcw2PIrU97bllW/AhleOTDdf6bnwcbbxks6/0WnAcYRLFfIh8mMTr+T01Pgt8S9Ku32ZK9BLV7G0m/Dmzn/0o0e5pty9tjkd48/Tsw06vkkx9O6RE++vNfjukxN+pmvt2SEkLXkwtK3b6K9d3+isrdvor13f6K9d3+otbyORnIUq0VjX7WYg4yeRnIUr4JtXkFpsl2udvdovNEu30N7vlSAm36ZvaciS8wLP7/RdZsINakQU7qBVZsINakcs7qBVZsINakcs7qMUp5hAQttTp61JXXJfL+/0XXbDff9HL+/3HKa6jeXZL+aILdk8rumD3tKILdk8r6tdbSF3RQtr1FtKu99zobje5TW8p8Sd/JrfpLWXB/mmlLNg/rZTL+6eVsmD/tFIu758Wp5hsI+FuYXNbypdozWhqS/kSrVvNbilfLNxAfW5L+fiETG4pXyx87J3bUr5EG/3NbSlfwo9TzY53o5eqpse7VheMd61dHu+GxzHLIV/wkcrilz9SWXzBRyqLX/5IZZxijkNhS529V0UvVr1xr/IlbaQtaCPRdn+TbSRacppuI9F2f5NtJEwx2UYCIM5tKV+iFavpJ9W6YrKqrpisqtcnq+qKyap2fbKqXZ+sCu+6k1vKl/CrVJNbypfwu1SzzayteKxqKx6r2vXHqrbisapdf6xqCx6rwvdD5raUt+irVLNbylv4DtDclvIWLmlMbilv4ZrV5JbyFm0vN7ulfHyPmNtS3qJPU81Oiti2YLtfSwv2UbV0eR9VSwv2UbV0eR/VOMVc7w35PrmlvEXLVdMtJPmKFlJXtJDLE6uWF0ysWr48sRqnmGohL2A2t6W85QWfULN8+RNqtuLzWJYXjFUt1+uNbMFY1eTyWDVOMdnIwr1257aUN1kwqWqyYFLV5PKkqomtuLh+/eL6z17cyS3lTcMNkaa2lH8xypzbUt6id5rmtpS36N2quS3lTVc0U73eTHVFM9XrzVQXNNPwZbW5LeWtLPhmiZUFE6pWLk+oWlkwoWrl8oRqnGJunBtu+udjKlRdKDS+oe/pKc3pfo2eJrF4f7k5fc+iPfuWWOL7yTz38PFoO4QwyXlxbhD8LMnZ4Pfe1T5MIqP/7lMSz/cNt3DSbPbqhN+kWnJ1ylhnMkvRz3mxBDAmAUtLz7zIV0mGDbyXsXD2mCRosftZH0zb7PkrCRZ9EUrz+dbJL5LHw4aGFr4R1MYdPG/p6evz5pdfsLZwtSoPgy9n16fzOxYtNe2jmHNpdS+jrdk7aZKedvPeBfxpmrDJuoyf5KJBk/Xr+6uYX99fxfzy/iphirm3YK1e31/F6uX9Vawu2F9l/qp4cFWu769ifn1/lVc5tss55rbPsPDrVHxnvHx2Tif3eXmRY2qfF2vhmujUViAvcky9Qx//Fh0vJMh+x3l+HOWnj2Nqv5n5HB/2ucn9ZixaaJrdb+ZFY59rINMd5tMLM7dXjMcb1s3tFfPiQKb2ivFofnduKOPhl5Am94oJj2Nur5iXA1XDQFWfDFQ9fL1qcrQbJpl71zMepvqYEt2LTxuqp+t7VXu6vFd1mGJuHOTp+l7Vni7vVe1pwV7V81clYnL4EDPu2am1p2MHz9sCFMr1Veo4yTlpthfTZ0nSdr69p+HzVHQkRc4dGuzzhzK8UNyaffxQdvoM+wNaCdJEP0naeV6SfXhe1MdmPPrL/jNl/qF5kvAePw5tJwbqR11nn0MYTTYFd2+5/PzvsmCDtfA4Zk9peGnHPg/7VZYPm3zaztff06Yfz0OkglGRf9xzUt4wuAp6TiTQj9VmzOPr4ytJ8UvJY83q9lLys9f5PXo1avbN5jDJ3HAkfr9q9oXx+C6ezqk3+fTl6EmXwKN1q2IyliUMI6N33muG9ZKxycp7L0f7eCVhn/h6vj7i+tNJ9ie07Wxn9cMkPubg90mW5+fES/jW6uh4ap+laOM9bQ7g30qRNsysWgmShNsk2blNUsMSS3vjnLZzf4SWg3YWWZrlfHO91PrhS+dpH9aeL/IkzjY/bIMVv7tu57vrhqfWx2NxC78d0UaO8x6eHz6P9OI4tnOFBePf78cRQv7EwF5uz3d/82iPwHRu8LcvuvL2+bDhSvgqfj53Xcv6/HUPt3KZjPGL+OfHqwoJ/UYKy0P3sKyfpZj6IeH70bOID5PM0jkctK5IMo34eF5iEvGulxHvehnx8YPaJOKjObhZxMdP85OID98pnh0XRa9YTXaaYgs6TZhktr1X+eEk050mTDLbacIXreY6TZRistNEKaY7TTQLP9tpwnM622nCt3lnb5nhotNcp4nf5Z26ZYYp5m6ZcYqpHxJrDZO931d03PAdqxVJpnt/mGSy99ctXe39YYq53h+mmO39NfToJnt/eE5ne78veA2/bn6504SWx2ynqQuGiDVtP5xkttPESWY7Tbh4NddpklzuNEkWdJpo2muy08TndPqWGT4gYmtQzDnrw3FEt//znSIV5wT6O++dz3be8AWpyc67Yh6wLpjCq1l/OMl05w2TzHbe+D2rqc4bpZjsvFGK6c4bvSI123mz/nDnbeMzJa08f5u/RgtXJZ2v4eUtPe288fvAs51XLk9Vxa/yTnbeOMlsv5P6w0mmO6+sGK7q9eGqXh+u6orhql4frsbndLbzhp86bqed0Gp+3n2jN6V0GzPN+su3Aco7m3HMdl+9/rTZ6oJ774oHxVryDyeZ7r5hktnuGy1cTXbfKMVk941STHff6IWr2e4bntMV3VfSOKmyL/I8777R1oBax94iuuPg+d03LdhuuZpcvvvmBesrcZLZnmf2w0mmu2+YZLb7WrvcfaMUk903SjHdfUNrbLL7hud0svvG2wvJMGCS+NlEHrYXqh5/Nml0Xtx6rc2nKEPXojv6Xooh8xXuxvlOCtvOV0e36ynKhyns3AT/w3Nh41zYp+fCxw/xT88FU3x4Lvi5pg/PhY9z4Z+eizp+SP30XDDFh+eiDmRU//Qoxua5tX54FG07v0+4XU/x6VGMT860ADnxVmSzfnaYZPJ919rCz1a38+ZYoiTRTKr570D42/YbW/zJ2DmpOnxtZtZYD49k1liPd1aaWX2MU0ytPr5IMTegXDAXGyeZHAu2+LtVC5LMDijjJJMDyrbVqwPKMMXcgDJMMTugbNEGgJMDyviczg4oZYGw0yIve7LTyAJhJ04y296T/3CS6U4TJpntNHm73GmiFJOdJkox3WkiV3a204TndPopLNxM7Hxpnrbt42ZiLRJlJZ3bqyd+o+ExR9hC8H4mTuvDXhctUlSPLb76w0eRzzKM1wCt1g8zjA2rtqfH8GJrtjzc8u2XB4dfjyJ8kamMN5nVdEWO9izH9F51sj3f/7dJ+CHg84OT/Eb6tx9j0dPxeO/WEl7Z+ZYjaqJ72x4vIqay1RVZuBXRO5szn9+NDzdnDvfNO+ctWno6cG/hm1BzY39dcbvUFbdL1R9OMn271AXr/U0vr/eHKSZvl7pgvb+V6+v98Tmdvl2GL4iOd7z359ST749+a4vMctFzc/b8rOe2Er49ON5T5XdiH3cPCndWnB0tl8uv/cWbIs52/7JAcG2l/XCS6e5fFrz21+zya39hisnubwte+2t2/bW/+JzOLjlOf7BWn3+wtkUfiUr13BClKj6b9fBFs/BzprO916+/nCJ6vffGSWY73grHPUwy3Xt9wcspzS+/nBKmmOy9vuDllObXX06Jz+ls79UFlk2r119O0RWWjS6wbFotP5xkutPUFbOq9fqsar0+q1pXzKq2BbOqtfzwLW9/bB8bVUhJT295YRI9v0egv+5W+3DfjBarliSxWsYcUfVnW4jEKc49gK1l/yzFOVPVytMUYUMdcyItf9rWx96fzcvl7hKkiEEm40ukWTAb8l6SfH4iSrbnTX1fI7xupsZJUpJzsxytHx7K3qgHRFItn2bBLJG0j4+lnNv/FLzU+W4WO7dpq+3jX3QyTXL0i9JlmzrOMXeniHPM3ir2LD/ebGUgKUnxT0/KFJVe5JjC0vTFidAWDp/nABummAPs5CA+Amz4eDUL2PhBbxaweUVLzUsAm5cANi8BbF4C2LwEsHkJYGUBYGUBYGUJYOXHm+00YGUBYGUBYOU6YMPZxTnAhinmADs5xxmkiGefJwH7Yh58FrC6oqXqEsDqEsDqEsDqEsDqEsDqEsCWBYAtCwBblgC2/HiznQZsWQDYsgCw5Tpgw9XbOcCGKeYAO7mGHAE2XN2fBWzsGcwC1la0VFsCWFsCWFsCWFsCWFsCWFsCWF8AWF8AWF8CWP/xZjsNWF8AWF8AWL8O2NAmnQNsmGIOsJNOawRYWQFYWQLYuqKl1iWArUsAW5cAti4BbF0C2LoEsG0BYNsCwLYlgG0/3mynAdsWALYtAGy7Dtjt+iLXdn2Ra7u8yBW/AzUL2PhtrEnAphWLXGnJIldassiVlixypSWLXGnJIldassiVFixypQWLXGnJIldKP95sZwGbFixypQWLXOn6IteLd0THzoHFYHe8leL8iiC/HfCQInzpdvabOXGSuW8qxbt0TF3aOMXUlZ3dKyS8sNuKG8624oaT64KeGyWZv+HEWWZvOGGW6RtOmGX6hhNnmb3hxL9o9oYj5foNR8r1G44s2OZqz/LjzXb6hhOelMkbTphj8oYzeXEitJXLPyVOMQfYcvmHxLvczVoVbYW2lnRFS9UlgNUlgNUlgNUlgNUlgNUlgC0LAFsWALYsAWz58WY7DdiyALBlAWCvcyne5XUOsHr52WR2r9loBBvuAjw7go33I54FrK1oqbYEsLYEsLYEsLYEsLYEsLYEsL4AsL4AsL4EsP7jzXYasL4AsL4AsH4dsPmyVRGnmANsvmxVxN9ImB3B1iVz0nVFS61LAFuXALYuAWxdAti6BLB1CWDbAsC2BYBtSwDbfrzZTgO2LQBsWwDYdh2w4ReC5gAbppgD7OR3ikLAphWATQsAm7cFLTVMMg3YF1kmARtnmQVsnGUWsC+yTAL2xS+aBGxO1wEb5pgEbJhjGrA5/XiznQVsfFLmABvnmAPs7MWJ0LZdnyLYrk8RbJenCOLvWs4C1le8eJFXLHLlJYtceckiV16yyJWXLHLlJYtceckiV16wyJUXLHLlJYtcWX682U4DdsEiV16wyJWvL3K9+O7vjFXxIsWMVVGiN9sktfF9HOFmlQ+ftkk5em1ifJwO35XUX48i/kT21GWNU0xd1dkPdUcXtSxwpF98zH32ZlPygl4bfoNp+mYTZ5m92YRZpm82YZbpm02cZfZmE/+i2ZtNaddvNqVdv9mUBV8eStl+vNlO32xKu36zKe36zaZcNr08erVnErBhijnAhikmNwJaoKzFSaYB6ytaqi8BrC8BrC8BrC8BrC8BrC8BrC8ArC8ArC8BbP3xZjsNWF8AWF8AWL8M2BI93kyO5uMUM6N5L5d3y4hTzGG+XN4to6QVy45pxbJjXvHSVphkHvNtxaswcZZpzLcVr8K8yDKL+bbiVRjZrr8KI9v1V2HCHNOYl+3Hm+0s5uX6VPKLHHOYl+uTydrCbVvb+TG827fkRhp7I8n+D9uZBOfEHn5N/MZUqxsO5bMseqxd92aSkz/9ObLinMiSc1KWnJNy+ZyE+wa0cn4BsmI4YOWdJGeD5afnvycJP62xje9A7GXcNd5KM7clbpxiakvcFylmtsTV6Js401cmTjJ5Zba25MpEaSavTJhi7srEKWaujLTgqdwk3fvuXuTZqO8kGQPHPYk9TxKNxLOO7ayzpnMkbvpAkejLWEnbObTBHvDfk0SfKxwfpKqimJxvb+So40Oy1VKUI9oDfhvLBDkBqw+fo9iTBPPa1e5YrXj18ncOxKP1ivGctbeR543kjWvjT69N3Ehk3CV++RztWzlKHpv8F5HnbSTS6Es7nxubtU+TjO+NREkk2npgrrGGF6YdHxHuYK2/vJ+rbyQ5lu6+Bpzl0yTnU1Lj9+TeS5Ls/JY0Af/ezxnfX9h/WQ6SRFOvntsY/NrzO9YbSdqnSdo5lG8lSBKeEz3PSbHn5yTGfD0/44yH8m8dJ9qVkJ+Af8pFifwlP76/01M0glEewRgtGv7yaUwNKFB8wT0remVr9p4V5Zi9Z9m24J5l6fo9K15jn71nTV8bj65N1Era+HZp2p/anieJvrQ1ea94dSRjuiVvfMj6diTRaGBcYd3CqxM+0s99ET4+Ek3jY3v44t/3IwnX/be2nQ22fnZec0pjWJJqMHaNpvdnz2v8NaZSR1PzFLT6cJFt6ryGfK1p7PlRU5WnfI3vWpOPjS+SzD02hknmHxv3M9t+Ps/c8+eLHFMPoK9yzDyBpvBTd36u4dTnhG0LnhzDTzLN3oUjmWn2LhzlmL0LR2+uTN+FoxfIZu/C0czA/F14+tr4Z21k7sExTDH73BhN7k8/N8ZJpsYC0QZCcy01y/WnxjDH5KNamGP2SS0veFCbztE+zDH5mJZX3GLCszr7JL5iXmHFtEL+4d8yO6mwYE4h3Hx+sqXO52gf5phrqfEXCmZb6opZiXgEMTcpockuTkpEb47vqx9j3L3x3p/K42EE9/59tvB+pxPhaOidHDIMAZH6dFin0R1mbkEvhw+a52r6hlP6/XzkcNr5/AhqSej9KT1mib4Mb3kMZIwbIT5kiaZq586IRAsteayzZHgbD+cjzDBGl0bf4iFD9CtSGYs9qfDbpQ8f+wxzaD4HdFme5uj/3fOH3VxtPO3m1p6d0XAGbzxi7pMjMDbyNp9jPw0bfg7GU/lhwK0RyWZ7bphjsueGH9Waa6dBz81+7vjp+PDwQ4Z6uaXXqy09+hWzLT3MMd3SI3d6tqXH/vU2noD2Mo6kzuco46TmUp7niHvLoat/nZIKc+V7b4k+KjTbW8Ick70leg1rsrfMn5EkT89I+Fv2p+TzUfs8H/njHPV6DkwffssRzV+k8eSwN1WM6arN58imI4f5hznayLEvezzPEY1izm/K70X7MMc5+sji13Pg2/aPOaLvzNg2Vs1sa+lpjujFmtlrG+aYvLZxjrlrG62YiRlGhWlBjvJhjrHCtBf9sxx+TtV5yZ/lqGMxZV/N+PB8uA+uO9ZSPs9RP/wt2719SE0fto8qg4VVP7y2VeuZo316HKN9VPv02rqMHN4+7HN+jkGiaxu/pTDmtgX3yjdzbGcOvZ4jy6cMOl+WyPXD45DzfJR2/TgiFpYFXC8LuF4WcF0XcF0XcF0XcF0XcF2vcz0SMspWx8rH1uyj8UeRdj8fezEYB4Xj0zGGEa5M529PH9EnlGZX2LSFD+vbuLzCtzS+H0qkqxa/Z/HSMPlQH5OET0L1fBLicp8/Jom63im67HDMQZLwpJTRXgVbW/zOSQmztPPUtudXOXwus3OfjmQ5fFJt7eLE8IsDGSluB1KfH0jZ4kn7Md2eGi7PQw+M5qg13Wd29uLzA4lyFBnT/oVX+DGHW6QNnDSxap/lOG2o27Ls0xzxpVEZL/aZ6sdZRvfby+35OamXZ4fr5dnhGr4UX/EyUNueqikl/H5SGsvT+2qbf5Yjj3Fiy7l+NDcs4yW6vYwx71vX1mEveEkt6LzRC1KT811xjrn5rpL8R+e7fj0j+fPzWs8s8mHP83NKcy9jvPj96uR0/eqEOSavTrROteLq/HJGfPv46jiypKdZorv4HNHCDHOrANEv2Sdkh75bU8Dm/cq0q2sicY4di+fdxg0z8O9l8SEh7WVLn2Y5Se+cZXmjrdV8DkmqBH043DK66nhs3MutfpRlf24cepdAwM0PL29P50j5sxxl+Kq54Nq8k2M//rHB3MZnnG8fvd2uL3mHSfbb0b2RlFxJgXeSyBBnimR/nqTo9eXVOMckovXy8uqLEzKeYYumEp0Qi2bzh0ZoW2lRlmg0P6YFDbOkjw+fLw5kTNkYH6bf/Dnndh/781L6OMtYsDWKXm9nqSNLk6DZRzMmOmaPi4ZJ5OotNE4xdQ8Nf8rsUnqcZHYtvYSv9EyupafozWvdhveuv3SdR8CWaNp1lkhhjkki2eX9KKIpjp1HY7rFM/veNp/Dzokfz/I0x/5bojc1ZnWvEr1tNX3vi151NLxaX6ID8SU/py74OZE6trftMcriAnL6xnqPRhXnFCGQ5vWN47A2Rq+VD2yPxxFa0rMUCNXTc/Ow9ssywSOg4yTjtDbf2sdJZCThYtS3JOGeMjogTf90n4Z9SBJuWjBuOHnPFyQJzfFxK2+VrsJb56SeJ7ZhzvRbkhJNia3J8ssLgpRAHs9KnOVUSXLGw9/vZJF4iu6cocufZjkn2NN+N/w0i46XjG4zV1GWSMGa3HYrPrnHq6Zfz241OrnX97hI5fqIrVwfsZUVI7ayZMQWblM1y+rwHbLJV/VLW/CSYGnXXxIMc0y+JBh/4nhyCbO06y8J2rbiJcH5axN0vbCRTL6pb9Hj0uyb+jUSqG0wei9iUPD4fnyYxE9bd2/9nyWZflM/PJIi5/s1FiV5sQ3g+bpQo0Jg76RJquf9T2mZvJkm6ZlGgze5wzMj7Ty93DrrrdOr59Sy/vKi3WOS0GOe2kyhxhtWTe2lEOaY3ErBolexJrdSsBTOE0xupRAeyexZDa/uWPzfL7R82Hn2GR7sF8mB+XutPp1nJSX/uA+m842Z9Cvz3xnmlDFSomj+3khpzPaBS99TxEPhcRy3fTU+HgqP9zP2YVNaMSyPssRPTmMo3CoEjW/PPJavz27FOeZmt0zSz+aYnLOPT+poJfv5teCkXn83K86xt6Bx57ItaK9xFhuLMvt/2D7NUsu5uFo+PpY2XqDJ25Y+zDI9dREfy6l7Ja/RL4q2Bpx+SI+zzD6kx1lmH9JNF+yN/eLkns5HTenj0zIJ7BenZRLY85coyhJ5PZMzzVa2BTPNFr3TPz3THG7OV8ag2C3xxW+fT1KTjh2oJOuHScq4xpUTGN+SWLmubsUHMvZir4XO5PcD8eu35DDH5O20XH4TPkXbC1Qbu/FUfvvj2wmJjKvJqbYwxdxUW/RTpqfawiSzU21mZcFUW2QEzE61mS3YFdPs+q6YYY7JqTbzBbtiml/fFdN8xa6Y89cmmGoLG8nsVJsv2BRT24KptjDJ7FSbtgVTbeGRzE61hWOB+am2MM38VNuLNLNTbdoWTLWFSWan2qLXyicnhaLuMzvVFuaYnWqLpnJmp9pqWzHVVhec1bZgqi1urtNTbXGa6am2F2lmp9rCYc7cVFs8Upqaatvs+nNO+CGg6eecWFaalWPDGbLx6q7s3MYYtr2RxIeKJo3vqD0mCb9rNHlHT5dl/TjF3GA6/CWzg+n4dEwOpn1bYRrmcFoYrn7y55c3h/Nj54tMTflAbe8kUVBaPkzi9dxvi8PYb2c2rdjTzdOCPd1SuMHTPvA/X93z9PwiR3NjPqYZ9ttO++zU6vlz9tFjeGp9yaldIRxGTT/b2A8xm1nQ9KMkZdy5srk+T+I5rTgr0VaE02fFQjHn3Ld7L6fydAZmySJ4uGGl2vkyMF5p+rZBo+do83w/L7Pr8ydBzwumCzxfny4Ic0xOF7gsmC5wuT5d4LJiumD+2nh0bcJWMiZAswcPK2ESSX7uTdb84yTb9SReTmHegkYfbXH4y/RH+fDECozsfQD5aRI7J5ZrkGTFN7V8wTe1XvwcHfd04aLM9yPRHz+Sswfuy3ALknzaAfe1Ax9JatDso5mPPvv8NZrNIZbqgoYy3Xk+vjyezm4cUSm0ZDfHg36JbjzhobRzv7KopYQb/czN5ngpC2ZzwiOZnM15MVISO0dK5el6l0f7niU0lFuW+lGWWW9jgcHsNvugH90yohM7O06KcsyOk0wXjJOi0zo7TjJbMU6yBZMwtsBgdmvX0WgrDGZbYTDbCoPZVhjMtsZgtjXqsa1Qj22FemzXJVlboB7bAvXYa7p+Bw03UZq+g9Z0/ayuUI9tjXpsa9RjW6Mev5j2O1+WtGAPFQ8XvuwYoo4s5aMss3LqkheEo9WzLZ1fl5RAG462mN9vTHeguOdAk/XwC1l2bp1g1EofDiSaOOTLlngHNcs7SXxIsvs01/Y8iTf/6Sw7grezrdVPs7ifemsLTkuNXvnysfOec6HnrRz4rmOpH+ZIWx7LERu63+9kkXAedEptjU9sO9cRWg5ObPTsVeo4KaViHiZtaT7Jbe0ln2tOfJ388ZtKURqzdK4Z44H027HUrV5eNY4PZHwfcj+QFhxICrcdOIFwe2nh+TfAbmZykOf8Klpq3L/avr3nEbT9fH7CK2OtZ2+Jj4cilykZfe+5lHFu98dJ+yjFuXC8F/WzFFM/ZPrdeg25tgDUNfwa2ZIs07iPs0zjPlr4msV9lGMW9+G3wKZxn8t13Mcndhb38c7Ck4OlGi1ZzfWeHG3NNNt74iTT7T5a91qTZb73hFmme0/00sts7wm/gj3Ze+KPYM/2HvEFvSc8sZO9JydZcRPVy/eeHL2+M3cTjVNM3URfpJj7IW0BBtbc/tR+Oss8BsIs0xiI5NRZDEQ5ZjEQa+qzGIgWvaYxEJ7YWQxE3tT8TbRc7z2RJzHde/KKuYIaPV+syTLfe8Is070nWlyZ7T1RjtneEy7yTPceW/AybXxip2+ikW9h51IRjqM8PhKHH5WQsXymv3wQojx8XDdylea7cbj0NdeNwx3wZrtxmGS6A3r+6Szz3TjMMt2Noze+ZrtxlGO2G0c55rux1wXdODyxK7pxG2/T/vIllG/dOFpwKmnsOl7ylp534+g+Ot+N6+WZrRzeAme78Zr7aLWfzjLfjeuSsWxdMJatC8aydclYtq0Yy9YVY9lwCa6dmkLD5iPfO3K0lZ5uY4paE3f6fezIkYg535GjVZHJjhx5mNMdOUwy2wXbtv10lumOHGeZ7cgtWvqa7MhhjsmOHOaY7shtW7CRbHxiV3RkSePESmrpeUdu4Tb1dXxWTHcyPO/IJgs6coufE6Y6cqQJTXdkW3EvbUl/Ost8Rw6zTHfk6L2v2Y4c5ZjtyOH7Z9MdOdoNZbojJ13QkcPZMhlmTRJ8TKv5488JBYPxa3CBk7U3cpShctEtfTPHkP0Kv7n4Vg4bX4r45XsxH+con+YY58M+Ph82zod9fD7OL2f4x+eDOT49H/xK6afn4/zEmX98Pur4LfXj88Ecn56POghS/ePj8DsQa/30ONr4zHj7+Hwwx8fHMV7cbgGDcgmno+Z07jhJHlrRPhEemNgtEvPS+cGM23soUZbwlWv/HS6L2Bs/Z9LCzvEbRHOKe3wkk4p7jjapmlzKDFPMLWX69cGmr5jF9RWzuK3IT2eZH2yGWaYHm8WuDzajHLODzSjH/GAz3M1wdrAZntjZwaav8IFa9GrWZO+pK3ygumL1oln56SzzvSd+hW+294S7Gk72nijHbO+JX2ea7T0Rq6d7T/za22TvibbKkny+k0+/Nzd7/D3RK7Rp7LWzT+JwtPWYZPZdT5zax81NW/R9exsbQxk3l3orxXib0PCB3zdT3DuOb0+PIkcz42XLQ2rffnmueDiMSM3VMl6PVm4udSFJe5bkRSsbwyyRbQta2YuvBYwdnVRq8HM0eoweL/Ja4t5S35JETZU7VKWy1SVpsLf348mNZ1vOr44r+k17bG5tapKjpaeD+v3XtMsPBm3FLbQtuYX+fJb5W2hboRG0dl0jCHPM3kLbCo2gtQUaQXxip2c7w20Oxpvj+8PsiftHpfb2lYYAkWPndsXnKR778LaFW22Nl18zZ03qQ9+x64Pp/UAuv4mY2wqrti2wavdf4z+dZZYEL7JMkiBv6fKbiHGOORLEOWZJsGe5/ibiixM7+2pK9EZxPt9EFL7z/bgb4f57ogf0eu69UvX8Pd92+Egr+nG6/JJM8gUiQpxkugfm9NNZ5vtxTiv6cdbr/Tjr9X6cdUU/zr6gH+cFL8mktqT3yPUXNNuK3tOW9B6Rn84y33tEVvQeseu9R+x67xFb0XukLeg9Ij98F9yf8Me+GvLLV2re2JxDt3P5f7Mc3EqjFa81WayWMalU/dmuJy9ynBvYWsv+YY5zcquV5znCBjumUFr+uNGPXUn3+bzrHcfLh1yTset5FsydvJckD1tszxehZMGLXXGSlOTcpEfrh4eS0rg6KdXyaRbMKUn7+FjKue1Qwcum72axc4s47Kr27i860SY5/EWXHe44x+w9oyxwuPNmP95sZVApSfFPT8okl8Ick1yavDhhjnBIPflbwhyTv2VyaB8x1lcw1pcw1lc0Vl/CWF/CWF/CWF/CWF/CWF/CWF/AWF/AWF/C2PrjzXaasb6Asb6Asb6AseH04+RvCXNM/pbJadAoRzhLPcnYF/Pls4xtKxprW8LYtoSxbQlj2xLGtiWMbUsY2xYwti1gbFvB2LT9eLOdZmxbwNi2gLHtMmNfLPZO/ZYXOaZ+y/Sic8jYvIKxeQFjw++9zTbWMMk0Y19kmWRsnGWWsXGWWca+yDLJ2Be/aJKxKV1nbJhjkrFhjnnG5h9vtrOMjU/KHGPjHHOMnb04IdtCJ3WSsWGOScZOurHR+agrGFuXMFZWNFZZwlhZwlhZwlhZwlhZwlhZwlhZwFhZwFhZwlj98WY7zVhZwFhZwFhZwNhi1xlb7Dpjy+U1r/jlqlnGxq95zTJ2xZpXWrLmlZaseaUla15pyZpXWrLmlZaseaUFa15pwZpXWrLmlezHm+00YxeseaUFa15pwZpX/PLp2M2wGJyPt1KcHzjkZw8eUoRv805+uudFksmvO8Xbgkzec8Ick/ecye1Jomsb7h4ze8+J97GZvee4Lei8UZL5e06cZfaeE2aZvueEWabvOXGW2XtO/Itm7zlVrt9zqly/59QFW2ztWX682U7fc8KTMnnPCXNM3nMmL07Itk2uM3aT64zdLv+WeKu9WcbqCs8itRWNtS1hbFvC2LaEsW0JY9sSxrYVjM3XtzGMc0wyNq/YxnDP8uPNdpax+TqXXuSYY2y+zqUXG87OMTbOMcfY2Y1vo/MR7ks8y9h4h+RJxua0oLGGSaYZ+yLLJGPjLLOMjbPMMvZFlknGvvhFs4zNCxibFzA2L2Fs/vFmO83YvICxeQFj8wLG+nXPIs4xyVi/7lnIivlpWTE/nWVFY5UljJUljJUljJUljJUljJUljNUFjNUFjNUljNUfb7bTjNUFjNUFjNUFjA0/YzTJ2DDHJGMnP6cUng9fwNj4u1uzjC0rGmtZwtiyhLFlCWPLEsaWJYwtSxhrCxhrCxhrSxhrP95spxlrCxhrCxhrCxirC+YKdMFcgV6fK0gr3slIK97JyCvWvPKSNa+8ZM0rL1nzykvWvPKSNa+8ZM0rL1jzygvWvPKSNa9cf7zZTjN2wZpXXrDmla+veb34XvGUZxGnmPIstmiHj9TuZ0OEm18+fmInR1svjA/n4euX+sh50ev3G9Hr9xu5/J51/Bn42fvNtsKdlu36Z2TiJNP3mxdZJu83cZbZ+02cZfZ+8yLL5P3mxS+avN/IdvnrR3GOyftNmGP6fiPpx5vt7P0mPilz95s4x9z9ZvbihGyLXvuZZWyYY5KxYY7J37JdZ2ycZJqxeUVjzUsYm5cwNi9hbF7C2LyEsXkJY/MCxuYFjM1LGCs/3mynGZsXMDYvYGy+zljbro7pX6SYGdPvYNuuk37brpN+u7yjRooWDKZJHyaZJv2KV7rCJPOk1xVvycRZpkmvK96SeZFllvS64i0Z0etvycjkxGX59DjmSV9+vNlOk/76rPKLHJOkvz6rHL7+bmV8fhPfCdhna95IoW2k0OcpIi1w8ijCFFNHEe3pkUutd7r+0nUfWliYw9rYHdmafJbj/Fp0blv5KIcc21r36bAtP/8tqYRfv97GhNg+pyYfZpnbq/ZFjqm9al/lmNmrNrwyPrbBv31D87Or+0sO/TBHPnPI8+uSJdrBTXKrY8o06ZPz8SKHjNudSPXnOfRnc2gav0Vz+uzajm8FZec24G9dl/GdruztQ4LwOD7NUcfYey9+mmOMHuIcl28u7fq9pUSfvG/H2sPX7TpgR5xj7Hq/F9uTHNEszdy5CDNMnYto7ap4Gtv/O/buTznP56h55KiSPswx7pJ70T7MUc7jwHLNeznOx9xaPjyONlpX2Vvap+ejnTmeXxeLPlVRzk8tFbxo/HmO+lkOG4NjNXzR+b0c4yPX6kEbs/gbrHUs5qXggxkS7VmnZbTU/YdhFsPKO0cy9+kO3S5/S9nDtbi5L3eEOWY/uaGb/nSW6Q93xFlmP9yhCxaudMHClS5ZuNIVC1fxiZ38cEf0NcrpTqzh17gmO/GLI5nsxLHoMNOJa73eicMc090v/XiW+U4cZpnuxNGHmmY7cU7XO3H4wajpThxttT/dicMTO9mJo7t52UaOsuXno6z950RZ8viAcckcM9bHJMHPMR9n1hyz1g9J4l9jY8zIOZHvvyb8ENfsr5H0s78mjW9t78XPRo1lnzy455Dsn+U4v/m9FxfksPRhjjquLr8K/V4OH08EuX56TsdixF60D3PImUM16neX31J5kWNurnsWrEGOuuBl67riXWvVsgDNWhaswL3IMrkCF2eZXYGLs8yuwL3IMrkC9+IXTa7AabRmNTuiKPn6iCLcHG56RFF+vNnOrsDFJ2WSSiVfp9LkxQlzLHDzdIGbp9fdPF+gDPsKY1htRVO1JYS1JYS1JYS1JYS1JYS1JYT1BYT1BYT1JYT1H2+204T1BYT1BYT1y4Qt0frivpx3X1/0iumfah/mqJ/lqNv9ukhN24c5xgSSVC0f5tB65mifHkcaOfAV2/dyjEmbvRgcR7gvx7gu+41DP8shWz7vWvJpju3Moddz5A+PI7fz7pnrh8ch5/ko7fpx2PO2rvX6tdV6/dq+yDF1badz5A+PY/Laxscxd22njyO6tuE7CzpGirlwPfxhAqxs1w2WOMecfVI2/dkccwZLeE5l3Cqz+Bad02jWaEDZcI96SBEehp4SDMcwv3MY7foEaYnWsSYnSMNfU/JoqPsE49NfE+cYE5O52PMzkjSUv4sOhJSyfZhlUsbT6x+Of5VjRsaTaC5/SqgJM0wJNXJZ6pHLUk+JJkZbGaPsVtPT1c04xznKbjU/zZE0RSu+2zb8kb2MZ9338sy20TDHZBuNc8y00XArvjwEo5YhGInoGznk1NeKP80RfYBnto3EOWbbyLaojWwL2si2oI1sl9tI5Fr4AABNp31cNZmgjCex4rhPWp5NkP0cI9NITi6zKWw0r/2cfnIM5/tmNcF/K3U2wWkUts2eJtjvoQEFZbRMcQzz2/aYI/xUxxiDmUc55o4Dy4ePOaL31eR+W2q8nt9PRrn6Q6YuqUFjTu6PBxGJgOn+Q5QLqQ85ooOQ+0E4V3O/H0T0+pKdi+R72dpzjL/Ic7o7e7mVIE90s05pGLj7tDQB6u9kqc2G2cEn47ey1LHUXdHxH3OErWQIXon0mk6Q0qbn/DqnXtMb8JDxK9hU5/vbuMvTXZj+93UAuHKt/9uFiF5uOW9D1DjeSjGe2wwznG+m2EZ3kw9ORNpSOmfReSrqG9gZY/LCs5keEWwatYgxXhL95DByTucEB+8m3777FO4KWMfjgVJQF6ufZrEwS6SC5XquQG3bh8eSWqkDO56eZokaSd1GioqHpu9XOPq2177qMN6h2u/GI0v9liRaffLxTO6OlxC+WaHHrMrzNawx0emcY/idLNEk1BiDaQoWbMqSzzCWJXvylSU72BWf+4hw+TTH9NpeqQuk6tmfE35zIrzIJ6V/fUf1+8+RFZen6vXLM5kjPidR5zknX9PH53VWiC51hcpcJr9NEp/XFa/tH3r95WZfF2jI4V1j3NJvnx0P7hotnL4QOacvVE7Qen4rTRltZS/jTQCffmQWGyKyOIed33+Qxw8345kEs8ppexz3tWj3xX025lxTLmgs309L0OLqftPRMRIWvNk8f1p2GMmpPwj49nhiojkVatFYSikPp9ailaV9og2TbrhA7VuWcOMYfPsT79PlbO9kwWsjirX238lSwinAc+ouPJTovq6qY5CvSpni8THYXrzqVM+emJ4/wMZZvI32X7Fv6HtZfIwlHRf6d3JE2s52ajt89vl+dlNaMJa0aEuPybGkpRWbFVm4pjA7loyzzA5WLNnlm2qYY/qmatFrObM31fgCzY4DbcmmdLbgtSm7/obAi4Y/Nw6Mz+vsONByWTAOtLygyeYlTTavaLLhSZkcB764GZbtXI+XGpBWwi0hxnTI5uehtPyYY8X8gcmK+QOT6/MHtuQzWbbk21TxsUx3Q1nxOGZy/XEszDHfDXXB41h8Uqa7YdSBUj6Hk4LG/70HxcsYci5jtOdJorWuMma+96e2s/tsj+dEw4nNIejnDe8+vJdl/6ej0W6SPj8WZMkfH4ucWUpZcSycwn7zWMZr4nmr24pjqeHZLdEKw1itgaf3PUfkPs8jO7JsZ5EdfTNoHtnFV4wCy/XJ2jDHPCZtwWRtfFKm72PhBZoeptuK6Vqz69O1sznCYXrY8CeH6eF5nR4f2JLxgS0YH9iS8YGvGB/Yz48Pqo+X1Ro2of52a/cYtHfOGmeaHqfgoon9lM+ZmYyXXR5d5PBA6piVrKrRgUQ5hhhUeQ98K0ez87FlS1GSyM5WG1s+KJj0/fYVrYjN3wRrun4TrCteOrVwSWya93XFFltWl0wf1AXTB3XJ9EFdMX1Qy89z6Vy7CbkUJeE7AXzR4luSaHfM5Pm8yPn52zy3cUPQDQ9P4qsb4vnnG95a+ApMPV+BaU8lqD3J7K7FIh8mScMwkeTt0yTnm0U5RUcSvSh1TFd+XePw50S39XZKg03rZ0nydr5+tuXnR+LhDoQzbwa9Og49H8CsBcchP3sc6dxkN1X98KSmgaQrSUZrvZCEt69cg9MaDdrkvGNISx8m0bHmmTQvSVI+TXJasqr6cZKxxqilLfg5nyfx8+fUej1J2T5NUtKZhJsIPyZJV98yfHUco/vtfSi4wNH3cGdZElK+DJZYxLRwy79JyodJpimfL9P1xXFMUj5a6llxHJOUf5UkLUgyR/k4ySzlZVtA+TDJLOXnk5RPk0xS/kWSOcpP/5zPk0xSfjZJSPkwySzl5TJdXxzHJOU1/SzlfXh/mTNJ349DFnS+MMls55tPUj5NMtn5XiSZ63zTP+fzJJOdbzZJ2PnCJLOdL9qabrLzxccx2fmipa7Zzhc9jefh1+03vuDyxusoc0/jHi7pzI7ToiTT47Ryna3xcUyO0yz97HHMjtNeJEkLkkyO08Iks+O08D2p2VtFmGT2VjGfpHyaZPJW8SLJ3K1i+ud8nmTyVjGbJLxVhElmbxV+/VkrPo7JW4VfnxWIKT/5NO4L5lzDJNOUr9fp6ivmXKv87HHMUt4XzLm+SDJJeV8x51pXzLnWFXOudcWca10x51pXzLnWFXOudcWca10x51pXzLm263StK+ZcW/tZyk8+jddoPWu288VJJjvfG0nKp0nmOt+rJFOdb/7nfJ5krvNNJ4k6X5xksvPVaCvCuUb/4jjmOl9Nl2cFYnXB9PxCaXruP9TwjaxZdaFG39OaVRdq9ErWrLpQowWtWXUhTjKpLrxIMqcu1OitrtnJkrpiUauuWNSq1xe16opFrXp9UauuWNSqKxa16opFrbpiUauuWNSqKxa16opFrbpiUauuWNSqKxa16opFrbpiUauuWNSq1xe16opFrXp9UesF5ecmS2q4SDBL+XBz41nK63W6xscxSXn1nz2OWcq/SJIWJJmkvMoCyocfsZqlfJhklvLzScqnSSYp/yLJHOWnf87nSSYpP5skpHyYZJby15e1XhzHJOVNfpbys5Ml8UeFJjtfmGS2880nKZ8mmex8L5LMdb7pn/N5ksnON5sk7Hzxt8EmO59fVgZeHMdk54u2IJw8jvBpfFJdqL7gRYK6YlGrrljUqtcXteqKRa16fVGrrljUqisWteqKRa26YlGrrljUqisWteqKRa26YlGrrljUqisWteqKRa26YlGrrljUqtcXteqKRa16fVHrBeXnnsbbtmDONUwyS/l2/TWtF8cxR/m2lZ89jknKv0qSFiSZo3ycZJLyLS2Yc42TTFL+jSTl0yRzlH+VZIry8z/n8yRzlJ9OElE+TjJJ+Xb9Na0XxzFH+ZbTz1J+8mm85QUvEsRJZjvffJLyaZLJzpcXvEgw/3M+TzLZ+WaThJ0vL3iRoMllZeDFcUx2Prn+IkGoLrDz1WC3uDDJ+Q3mfQ6ifpok1TPJp0fSRhsR7vP2LUm8G2YdR1KgP7y5wbSNXT6yqXyapZ17n7Rgm+pw6+56P5CS5fnW3S1c09q2c5d3bBTy7estYRZpY+euna+AyWaPWcJ9oes4loTvrti3Q4k3uxptltvB1G9nJXjWun1+8CtJy9gV/dt+PU3DHbPsNH/4HUF5hEH4MS21QfuSSpClLNjmLT4Uaed+5pt++oOYJacoS3Ry7dybxqR9mqWeHzyr5eNLJOUcpHiYJWx0Y5fQJtyg/Vuji9/JOfe/z2WLmktdcaWns4RXOswy3QFswXZv8cmV8/FY6vOTO0ttTFt8o3a0s6D6+Bqd1qzPSRktHMjYk0x/+R5nfudAajm/W4hb6vcDCc7q3n3HoZgm2I2e30lTBB9EE3ylz9/5SSWPPbNLxmfVvv0kD+cM5NyEEh//cn0rybnjr8IcfUgSfjF1GJJFYUh+a2zRR7vOzye2jFHGt9Oh0WTOaK85Q6T9niRor7WU8enUwq+M1LeS6GSS6Z9Tg58Tfe14bIje8EXt7ylatOQ29greZ7fq9SSC59o3k5QziXx6JGVscCilBkcSLXVNt5I4yWwrmf05TT5sJeeQeIs6To2+LbuNTxbp5tF5De/l512YEzG6yWOWaKR0qPJf4y08pr+bZXxG9FWW8LSMzdB3Nvrz09Kufz+mtRXfj2ltxfdj4mOZ3ZPz2GD8+ZPP5J6cLVrxmtyTM8wxvSdni9a8pgeP4Um5/mm3ou2eopTy9JE/fjtnDD8dH9l6yCBbOHmR0rh57WV/+hG0PU38ZszYoZffBHn8HPurgzkf1veya3AwwdVZ8UW2UgcjLeF55/vJjaWCjLGjPh2B7mlaOPmwjQdkt/x5mvG8sl+krTxPE32sS5LgVR1/NiuzJ8nXZ2X2LHL9kf9Flsm5nT1Luf6Y/SLL5APynsUvM+6NHxQ88b+60HMzIfvNcrs+E7JnSSsu0XSW8LyEWaYvdNYFFzo8uZMzIa/o4udHOd2x4/w3umS/OpPx8lD8BF3FJPb3QwnS+N7oxj78WSS4G0XvzUzfjV4djY55CN/XPHJwNFF/xMhSsPJp08MOk/GFHRN+fPX2pdJ/28M//ukv//j3v/79T3/851/+/rf/vP3L2weCbgs1tymsvezH+k06yhXldpbzhnJCOaMsKCvKBWVDGfVm1JtRr6BeQb2CegX1CuoV1CuoV1CvoF5BvYp6FfUq6lXUq6hXUa+iXkW9inoV9RbUW1BvQb0F9RbUW1BvQb0F9RbUW1CvoV5DvYZ6DfUa6jXUa6jXUK+hXkO9jnod9TrqddTrqNdRr6NeR72Oeh31VtRbUW9FvRX1VtRbUW9FvRX1VtRbUW9DvQ31NtTbUG9DvQ31NtTbUG9Dve2sd1/yQzmhnFEWlBXlgrKh7ChXlFFvQr0J9SbUm1BvQr0J9SbUC14l8CqBVwm8SuBVAq8SeJXAqwReJfAqgVcJvErgVQKvEniVwKsEXiXwKoFXCbxK4FUCrxJ4lcCrBF4l8CqBVwm8SuBVAq8SeJXAqwReJfAqgVcJvErgVQKvEniVwKsEXiXwKoFXCbxK4FUCrxJ4lcCrBF4l8CqBVwm8SuBVAq8SeJXAqwReJfAqgVcJvErgVQKvEniVwKsEXiXwKoFXCbxK4FUCrxJ4lcCrBF4l8CqBVwm8SuBVAq8SeJXAqwReJfAqgVcZvMrgVQavMniVwasMXmXwKoNXGbzK4FUGrzJ4lcGrDF5l8CqDVxm8yuBVBq8yeJXBqwxeZfAqg1cZvMrgVQavMniVwasMXmXwKoNXGbzK4FUGrzJ4lcGrDF5l8CqDVxm8yuBVBq8yeJXBqwxeZfAqg1cZvMrgVQavMniVwasMXmXwKoNXGbzK4FUGrzJ4lcGrDF5l8CqDVxm8yuBVBq8yeJXBqwxeZfAqg1cZvMrgVQavMniVwasMXmXwKoNXGbzK4FUGrzJ4lcGrDF5l8CqDVxm8yuBVBq8yeJXBqwxeZfAqg1cZvMrgVQavMngl4JWAVwJeCXgl4JWAVwJeCXgl4JWAVwJeCXgl4JWAVwJeCXgl4JWAVwJeCXgl4JWAVwJeCXgl4JWAVwJeCXgl4JWAVwJeCXgl4JWAVwJeCXgl4JWAVwJeCXgl4JWAVwJeCXgl4JWAVwJeCXgl4JWAVwJeCXgl4JWAVwJeCXgl4JWAVwJeCXgl4JWAVwJeCXgl4JWAVwJeCXgl4JWAVwJeCXgl4JWAVwJeCXgl4JWAVwJeCXgl4JWAVwJeCXgl4JWAVwJeCXgl4JWAVwJeCXgl4JWAVwJeCXgl4JWAVwJeCXil4JWCVwpeKXil4JWCVwpeKXil4JWCVwpeKXil4JWCVwpeKXil4JWCVwpeKXil4JWCVwpeKXil4JWCVwpeKXil4JWCVwpeKXil4JWCVwpeKXil4JWCVwpeKXil4JWCVwpeKXil4JWCVwpeKXil4JWCVwpeKXil4JWCVwpeKXil4JWCVwpeKXil4JWCVwpeKXil4JWCVwpeKXil4JWCVwpeKXil4JWCVwpeKXil4JWCVwpeKXil4JWCVwpeKXil4JWCVwpeKXil4JWCVwpeKXil4JWCVwpeKXil4JWCVwpeKXhVwKsCXhXwqoBXBbwq4FUBrwp4VcCrAl4V8KqAVwW8KuBVAa8KeFXAqwJeFfCqgFcFvCrgVQGvCnhVwKsCXhXwqoBXBbwq4FUBrwp4VcCrAl4V8KqAVwW8KuBVAa8KeFXAqwJeFfCqgFcFvCrgVQGvCnhVwKsCXhXwqoBXBbwq4FUBrwp4VcCrAl4V8KqAVwW8KuBVAa8KeFXAqwJeFfCqgFcFvCrgVQGvCnhVwKsCXhXwqoBXBbwq4FUBrwp4VcCrAl4V8KqAVwW8KuBVAa8KeFXAqwJeFfCqgFcFvCrgVQGvCnhVwKsCXhXwqoBXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXFbyq4FUFryp4VcGrCl5V8KqCVxW8quBVBa8qeFXBqwpeVfCqglcVvKrgVQWvKnhVwasKXlXwqoJXFbyq4FUFryp4VcGrCl5V8KqCVxW8quBVBa8qeFXBqwpeVfCqglcVvKrgVQWvKnhVwasKXlXwqoJXFbyq4FUFryp4VcGrCl5V8KqCVxW8quBVBa8qeFXBqwpeVfCqglcVvKrgVQWvKnhVwasKXlXwqoJXFbyq4FUFryp4VcGrCl5V8KqCVxW8quBVBa8qeFXBqwpeVfCqglcVvKrgVQWvKnhVwasKXlXwqoJXFbyq4FUFryp41cCrBl418KqBVw28auBVA68aeNXAqwZeNfCqgVcNvGrgVQOvGnjVwKsGXjXwqoFXDbxq4FUDrxp41cCrBl418KqBVw28auBVA68aeNXAqwZeNfCqgVcNvGrgVQOvGnjVwKsGXjXwqoFXDbxq4FUDrxp41cCrBl418KqBVw28auBVA68aeNXAqwZeNfCqgVcNvGrgVQOvGnjVwKsGXjXwqoFXDbxq4FUDrxp41cCrBl418KqBVw28auBVA68aeNXAqwZeNfCqgVcNvGrgVQOvGnjVwKsGXjXwqoFXDbxq4FUDrxp41cCrBl418KqdvJLt5NVeTihnlAVlRbmgbCg7yhVl1JtQb0K9CfUm1JtQb0K9CfUm1JtQb0K9GfVm1JtRb0a9GfVm1JtRb0a9GfVm1CuoV1CvoF5BvYJ6BfUK6hXUK6hXUK+iXkW9inoV9SrqVdSrqFdRr6JeRb0F9RbUW1BvQb0F9RbUW1BvQb0F9RbUa6jXUK+hXkO9hnoN9RrqNdRrqNdQr6NeR72Oeh31Oup11Ouo11Gvo15HvRX1VtRbUW9FvRX1VtRbUW9FvRX1VtTbUG9DvQ31NtTbUG9DvQ31NtTbUC94Bb9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV++15GveAV/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/Pa9jHrBK/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bfvZdQLXsFvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF376XUS94Bb9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8Jv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qwJeFfCqgFcFvCrgVQGvCnhVwKsCXhXwqoBXBbwq4FUBrwp4VcCrAl4V8KqAVwW8KuBVAa8KeFXAqwJeFfCqgFcFvCrgVQGvCnhVwKsCXhXwqoBXBbwq4FUBrwp4VcCrAl4V8KqAVwW8KuBVAa8KeFXAqwJeFfCqgFcFvCrgVQGvCnhVwKsCXhXwysArA68MvDLwysArA68MvDLwysArA68MvDLwysArA68MvDLwysArA68MvDLwysArA68MvDLwysArA68MvDLwysArA68MvDLwysArA68MvDLwysArA68MvDLwysArA68MvDLwysArA68MvDLwysArA68MvDLwysArA68MvDLwysArA68MvDLwysArA68MvDLwysArA68MvDLwysArA68MvDLwysArA68MvDLwysArA68MvDLwysArA68MvDLwysArA68MvDLwysArA68MvDLwysArA68MvDLwysArA68MvDLwysErB68cvHLwysErB68cvHLwysErB68cvHLwysErB68cvHLwysErB68cvHLwysErB68cvHLwysErB68cvHLwysErB68cvHLwysErB68cvHLwysErB68cvHLwysErB68cvHLwysErB68cvHLwysErB68cvHLwysErB68cvHLwysErB68cvHLwysErB68cvHLwysErB68cvHLwysErB68cvHLwysErB68cvHLwysErB68cvHLwysErB68cvHLwysErB68cvHLwysErB68cvHLwysErB68cvHLwysErB68cvHLwqoJXFbyq4FUFryp4VcGrCl5V8KqCVxW8quBVBa8qeFXBqwpeVfCqglcVvKrgVQWvKnhVwasKXlXwqoJXFbyq4FUFryp4VcGrCl5V8KqCVxW8quBVBa8qeFXBqwpeVfCqglcVvKrgVQWvKnhVwasKXlXwqoJXFbyq4FUFryp4VcGrCl5V8KqCVxW8quBVBa8qeFXBqwpeVfCqglcVvKrgVQWvKnhVwasKXlXwqoJXFbyq4FUFryp4VcGrCl5V8KqCVxW8quBVBa8qeFXBqwpeVfCqglcVvKrgVQWvKnhVwasKXlXwqoJXFbyq4FUFrxp41cCrBl418KqBVw28auBVA68aeNXAqwZeNfCqgVcNvGrgVQOvGnjVwKsGXjXwqoFXDbxq4FUDrxp41cCrBl418KqBVw28auBVA68aeNXAqwZeNfCqgVcNvGrgVQOvGnjVwKsGXjXwqoFXDbxq4FUDrxp41cCrBl418KqBVw28auBVA68aeNXAqwZeNfCqgVcNvGrgVQOvGnjVwKsGXjXwqoFXDbxq4FUDrxp41cCrBl418KqBVw28auBVA68aeNXAqwZeNfCqgVcNvGrgVQOvGnjVwKsGXjXwqoFXDbxq4FUDrxp41cCrBl61k1e2nbyy7eSVbSevbDt5ZdvJK9tOXtl28sq2k1e2nbyybUO9CfUm1JtQb0K9CfUm1JtQb0K9CfUm1JtRb0a9GfVm1JtRb0a9GfVm1JtRb0a9gnoF9QrqFdQrqFdQr6BeQb2CegX1KupV1KuoV1Gvol5FvYp6FfUq6lXUW1BvQb0F9RbUW1BvQb0F9RbUW1BvQb2Geg31Guo11Guo11CvoV5DvYZ6DfU66nXU66jXUa+jXke9jnod9TrqddRbUW9FvRX1VtRbUW9FvRX1VtRbUW9FvQ31NtTbUG9DvQ31NtTbUG9DvQ31glcJvErgVQKvEniVwKsEXiXwKoFXCbxK4FUCrxJ4lcCrBF4l8CqBVwm8SuBVAq8SeJXAqwReJfAqgVcJvErgVQKvEniVwKsEXiXwKoFXCbxK4FUCrxJ4lcCrBF4l8CqBVwm8SuBVAq8SeJXAqwReJfAqgVfw2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8Fv38uoF7yC327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr99L6Ne8Ap+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/Pa9jHrBK/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/Hb/8tstH2VF+ajX7Cgf9Vo9yo7yUa+1o9zOcueVH/k7r/zI2Xnlx7/tvPoqK8oFZUPZUa4ot7PcefVVTigf9dbjGDqvvsqKckHZUHaUK8rtLHdefZUTyr3e4xx2Xn2VFeWCsqHsKFeU21nuvPoqJ5RRb0G9BfXeeLUvBG1H2VB2lCvK7Sgfv+vGq71cjnI6yn6UM8pyK6fj/N94NcoFZUPZUa4ot7PsG8oJ5Ywy6nXU66jXUa+jXke9jnor6q2ot6Leinor6q2ot6Leinor6q2ot6Hehnob6m2ot6Hehnob6m2ot6HedtZ7+O2jnFDOKAvKinJB2VA+6s3lKFeU21lOG8pHvfn4t+moV9JRFpSPekX+9dsf/u8f//GXP/6vv/75P//wP/57D//Pf/3tT//8y9//9hX+8//9j/vf/K9//OWvf/3L//Pv//GPv//pz//7v/7x53//69//dPu7P2y3/3c7hP+Z7Lec/m3/j9PXn+9/kvdmnW7b8P3bb3+Q/if7waXbpnj7n3z9s1Tlt9v/P/4o9f9K8+2/Ur3ly6OKsv1Wyu2P5PZHt4Safivpnqrk34rf/lrPg2q/5SNJGX+U9bfcbn9k449Ef5Pjj/yeV/JvmkfevRK7/XU9/0X7rR9cu/+L/XedP2r8dfq985PiWtL5g3P6Le9/9q9//du//j8=",
      "is_unconstrained": false,
      "name": "receive_value",
      "verification_key": "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"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17765343328382640478": {
            "error_kind": "string",
            "string": "Source chain IDs and emitter addresses length mismatch"
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "6788092787179896647": {
            "error_kind": "string",
            "string": "Caller is not owner"
          }
        },
        "parameters": [
          {
            "name": "source_chain_ids",
            "type": {
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 8,
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 16
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec"
            },
            "visibility": "private"
          },
          {
            "name": "emitter_addresses",
            "type": {
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 8,
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "public"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "register_emitter"
    },
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "14067204867181196045": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "14401109495927734611": {
            "error_kind": "string",
            "string": "Field failed to decompose into specified 16 limbs"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15546539856497705002": {
            "error_kind": "string",
            "string": "u16 to u8 conversion failed"
          },
          "15711892660910782274": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16216212843441549037": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "2014890719615096298": {
            "error_kind": "string",
            "string": "Field failed to decompose into specified 40 limbs"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "4648451262681811962": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "7555607922535724711": {
            "error_kind": "string",
            "string": "Preimage mismatch"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9589626482238399944": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "9921926525851912681": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "anchor_block_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "sponge_blob_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "destination_chain_id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 16
            },
            "visibility": "private"
          },
          {
            "name": "value",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "fee_nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "note_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 32,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "log",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "fields",
                                          "type": {
                                            "kind": "array",
                                            "length": 18,
                                            "type": {
                                              "kind": "field"
                                            }
                                          }
                                        },
                                        {
                                          "name": "length",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::log::Log"
                                    }
                                  },
                                  {
                                    "name": "note_hash_counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "anchor_block_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "sponge_blob_hash",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "private"
      ],
      "debug_symbols": "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6BZ0C7oF3YJuQbegW9It6ZZ0S7ol3ZJuSbekW9Itn1s1wTUO4iQu4iYa0YmHGES6DboNujFLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkkSWfFfjiSwBDuIkLuImGtGJhxhEuiXdkm7IEitcxE00ohMPMYh5cf6QJcBBnMRF3EQjOvEQg0i3QbdBt0G3QbdBt0G3QbdBt0G3QbdJt0m3SbdJt0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0W3TbdNt023TbdNt023TbdNt023TTejG7LkFE7iIn5u41doRCceYhDzYWXJxUGcxEWkm9PN6eZ0c7o53Q7dDt0O3Q7dDt0O3Q7dDt0O3Q7dgm5Bt6Bb0C3oFnQLugXdgm5Bt6Rb0i3plnRLuiXdkm5Jt6RbPjc8o+viIE7iIm6iEZ14iEGk26DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26ab0c3oZnQzujFLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksm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GcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySxB3+v3k7oLfa8Xg1hu/iGyBDiIk7iIm2hEJx5iEOnmdEOW/AoncRE30YhOPMQg5kNkCZBuh26Hboduh26Hboduh26HbkG3oFvQLegWdAu6Bd2CbkG3oFvSLemWdEu6Jd2Sbkm3pFvSLZ8b+l4vDuIkLuImGtGJhxhEug26DboNug26VZZsKzSiEz+37YVBzIfIklM4iJO4iJtoRCceYhDz4aLbotui26Lbotui26Lbotui26Lbptum26bbptum26bbptum26bbppvRzehmdDO6Gd2MbkY3o5vRzejmdHO6Od2cbk43p5vTzenmdHO6Hboduh26Hboduh26Hboduh26HboF3YJuQbegW9At6BZ0C7oF3YJuSbekW9It6ZZ0S7ol3ZJuSbd8buh7vTiIk7iIm2hEJx5iEOk26IZ7r7twEhdxE43oxEMMYj7EvVcg3SbdJt0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0W3TbdNt023TbdNt023TbdNt023TbdjG5GN6Ob0c3oZnQzuhndjG5GN6eb083p5nRzujndnG5ON6eb0+3Q7dDt0O3Q7dDt0O3Q7dDt0O3QLegWdAu6Bd2CbkG3oFvQLegWdEu6Jd2Sbkm3pFvSLemWdEu65XND3+vFQfzcbBQu4iZ+bob/1omH+LmZF+bDypKLgziJi7iJRnTiIdJt0G3SbdJt0m3SbdJt0m3SbdJt0m3SbdFt0W3RbdFt0W3RbdFt0W3RbdFt023TbdNt023TbdNt023TbdNt083oZnQzuhndjG5GN6Ob0c3oZnRzujndnG5ON6eb083p5nRzujndDt0O3Q7dDt0O3Q7dDt0O3Q7dDt2CbkG3oFvQLegWdAu6Bd2CbkG3pFvSLemWdEu6Jd2Sbkm3pFs+N/S9XhzESVzETTSiEw8xiHRjljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPkMEsOs+QwSw6z5DBLDrPkMEsOs+QwSw6zBH2v3891LPS9XpzERdxEIzrxEIOYDyfdJt0m3SbdKks8C43oxDo2KwxiPkSWAAdxEhdxE43oRLotui26bbptum26bbptum26bbptum26bboZ3YxuRjejm9HN6GZ0M7oZ3YxuTjenm9PN6eZ0c7o53ZxuTjen26Hboduh26Hboduh26Hboduh26Fb0C3oFnQLugXdgm5Bt6Bb0C3olnRLuiXdkm5Jt6Rb0i3plnTL54a+14uDOImLuIlGdOIhBpFug26DboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSxB3+vxwnxYWXLxc/ueqL7Q93pxET+3mIVGdOLnFqswiPmwsuTiIE7iIm6iEZ1IN6eb0+3QrbIksnASF/FzyzoPlSUXnfi5ZZ2HypKL+fDLkvk9KnFV32vjJK4Pay2+LGk0on9Y0/mypDGI+TB/xEGcxEXcRCPSLemWdMvnVn2vjYM4iYu4iUZ04iEGkW6DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26bbkY3o5vRzehmdDO6Gd2MbkY3o5vTzenmdHO6Od2cbk43p5vTzel26Hboduh26Hboduh26Hboduh26BZ0C7oF3YJuQbegG7MkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS/Jlyf69LNm/lyX797Jk/16W7N/Lkv17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6z/+/Ne//P34y1CPI9uh5qGNc9zewNDPUty4FMbR7ihFLqVR2lksZi6VUdo7PBKXRh3H5fzYuNTHOW7/mLSN0v7pKXApcimN0o6SMpfKKO26kYhLlUuNS6OOwyaYRx3H29Q5cGnUcTgHcuJS5lLh0qjj2MHnUcfB/blxqZ+lMuo4EomWwKXIpVHH8eh6yVwqXBp1lP3byqxjr7c0LvWzRLOOfbRo1HFEH9Go4zjNUOLSrGPvZxp1HBstIi5VLjUu9bNUNy4FLkUuJS5lLnEdleuoXEflOirX0biOxnU0rqNxHY3raFxH4zoa19G4jsZ1dK6jcx2d6+hcR+c6OtfRuY7OdXSuo3Md+4ZTikGKUYpJilmKRYokxVlXPIpNiqO2gxr2aSzFIMUoxSTFLMUiRZJilWKTotQWpbYotUWpLUptUWqLUluU2qLUFqW2KLUlqS1JbUlqS1JbktqS1JaktiS1JaktSW1ZastSW5bastSWpbYstWWpLUttWWrLUluR2orUVqS2IrUVqa1IbUVqK1JbkdqK1EZSG0ltJLWR1EZSG0ltJLWR1EZSG0ltVWqrUluV2qrUVqW2KrVVqa1KbVVqq1Jbk9qa1Naktia1NamtSW1NamtSW5PamtTWpbYutXWprUttXWrrUluX2rrU1qW2zrXFbZNikGKUYpJilmKRIkmxSrFJUWoTLonCJVG4JAqXROGSKFwShUuicEkULonCJVG4JAqXROGSKFwShUuicEkULonCJVG4JAqXROGSKFwShUuicEkULonCJVG4JAqXROGSKFwShUuicEkULonCJVG4JAqXROGSKFwShUuicEkULonCJVG4JAqXROGSKFwShUuicEkULonCJVG4JAqXROGSKFwShUuicEkULonCJVG4JAqXROGSKFwShUuicEkULonCJVG4JAqXROGSKFwShUuicEkULonCJVG4JAqXROGSKFwShUuicEkULonCJVG4JAqXROGSKFwShUuicEkULonCJUm4JAmXJOGSJFyShEuScEkSLknCJUm4JD245NiPDy6pYzM/uORRjFJMUsyjGI5ikSKNYj6KdRTpKDYpdi7GWduxwY9BiqO244HNNLjkUcxSHLUdBt00uORRHLUdJus0uORR7FwcXFKP2Pg0uORRHLXFozmDS+rhN06DSx7FUdvxJF4aXPIojtqO00caXPIodi4OLhkOxjS45FEctR0PSKTBJY9iluKo7TitpMElj+Ko7Ti5pMElj+Ko7ThDpMElj2KQ4qjtODykwSWP4qjtsHOnwSX1MDOnwSWPYpXiqO14qzkNLpnFwSX1MImlwSWPYpTiqO2wAqbBJY/iqO3YIKfBJY9ileKo7dgrp8Elszi4pB5PR6TBJfWwjaTBJY/iqK2Ns2OW4qjtON2mwSWPYpXiqG3MgMElszi4pB1ewzS45FGMUkyjeDRncMmjWEbxaM7gkkfxqK0dL7SmwSWPYufi4JJ2vB+ZBpc8iqO2obSDSx7FLMUixVHbcTROg0sexVHb0OrBJe1Q5Ty45FEMUhy1HVqdB5c8iqO2cbweXPIokhRHbYdW58Elj+Ko7VDlPLjkUQxSHLWN4/jgkkdx1DaO5oNL2vFwVx5c8iiO2o7zdx5c8iiO2o7Tdh5c8igGKY7ajsmQB5c8iqO2Q5Xz4JJHkaQ4ajusl3lwyaM4ajvsyXlwyaM4ajvsoHlwyaOYpDhqO0wveXDJozhqO7Q6Dy5pbdgvmhQ7FweXtEOr8+CSR3HUdqhyHlzyKGYpjtoOrc6DSx7Fo7Z+qHIeXPIodi4OLumHVufBJY9iHMVhUEmjeLRhcMmjeNTWj7ee8+CSR3HUdhB0HlzyKHYuDi7px2TIg0sexVHbQdB5cMmjmKU4aovDqkNSHLUNrR5c8iiO2o43M/PgkkcxSHHUdhj+8uCSR3HUdrxOnQeX9OOltzy4pB9XgvPgkkdx1DYUfHDJLA4ueRSDFEdtx2XePLjkUcxSnLUdH9RIilWKTYqztqO9fZNikOKobcyWwSWP4qhtTJHBJY/iqO0wT+XBJb0MhCbFfhbL4JJHMUgxSjFJMUuxSJGkWKXYpCi1BaktSG1BagtSW5DaBpf0485NGVzyKFYpNil2Lg4ueRSDFKMUkxSzFKW2KLVFqS1KbVFqS1JbktqS1JaktiS1JaktSW1JaktSW5LastSWpbYstWWpLUttWWrLUluW2rLUlqW2IrUVqa1IbUVqK1JbkdqK1FaktiK1FamNpDaS2khqI6mNpDaS2khqI6mNpDaS2qrUVqW2KrVVqa1KbVVqq1Jbldqq1Faltia1NamtSW1NamtSW5PamtTWpLYmtTWprUttXWrrUluX2rrU1qW2LrV1qa1LbZ1ro22TYpBilGKSYpZikSJJsUqxSVFqC1JbkNqC1BaktiC1CZeQcAkJl5BwCU0uOe5W0eSSWQxSHLUdERw0ueSIwafJJbM4ajte0qLJJbM4ajuur9DkkhEP81+//u3Pv/77b3/6++4GOjxF//zLH0+v0C7+4//+5/mbf//bn3/77c//59/+829//eOf/uOff/vT4UEazqNteJD2//7L7laP4fAwhcfP95/sNqhf9v/G+q/7fnL+ZF9Y9/+m9q+/nH+2G+x+Of47fhTmv9pXzOO/+cCLXMW+oSvl+FE6fnQA7otsCSfUvkCVevw6S6P6L3GAFP7RvguI/fgR8Y9S/iWNH1WM285fp/hLjvzr/d/S8esugP2X2fawnX+yf7d89OP3h0fu/wE=",
      "is_unconstrained": false,
      "name": "send_value_private",
      "verification_key": "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"
    },
    {
      "abi": {
        "error_types": {
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15546539856497705002": {
            "error_kind": "string",
            "string": "u16 to u8 conversion failed"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "8228371833434187583": {
            "error_kind": "string",
            "string": "Trying to read from uninitialized PublicImmutable"
          }
        },
        "parameters": [
          {
            "name": "destination_chain_id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 16
            },
            "visibility": "private"
          },
          {
            "name": "value",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "fee_nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "public"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "send_value_public"
    },
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "14067204867181196045": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "9921926525851912681": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "utility"
      ],
      "debug_symbols": "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4iYa0YmHGES6DboNug26MUuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySahEcYxQO4iQu4iYa0YmHGMR8mHRLuiXdKkvGLNxEIzrxEIOYF2d1EjYO4iQu4iYa0YmHGES6DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26bboZ3YxulSVjFy7iJpbbKXTiIQYxH1aWXBzESVzETaSb083p5nRzuh26Hboduh26Hboduh26Hboduh26Bd2CbkG3oFvQLegWdAu6Bd2Cbkm3pFvSLemWdEu6Jd2Sbkm3fG7j9yMO4iQu4iYa0YmHGES6DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26bboZ3YxuRjejm9GNWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWbKYJYtZspgli1mymCWLWbKYJYtZspgli1mymCWL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26DboNug26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptumW2XJ960xu/peG534uc0oDGI+rCz5fqNyV99r4yR+bqvcKksuGvFz+z7h39X32hjEz+37XG9X32vjIH5u2woXcRM/N6sLqiy5eIifm2GwfFhZcvFz81/hJC7i5+Y138qSi0783LzWrLLkYj6sLDk138qSi5P4uZ1as8qSi0b83E6temXJxSDmw8qSi4M4iYu4iUakW9It6ZbPrfpeGwdxEhdxE43oxEMMIt0G3QbdBt0G3QbdBt0G3QbdKku+++pdfa8XK0sufm7fX1Da1ffauIibaEQnHmIQ82FlyUW6Lbotui26VZZ8f4FpV99r4yF+bjkL82FlycXPLesyK0suLuImGtGJhxjEfFhZcpFuRrcvS9av5vtlSaMR/cOa75cljUHMD796q77XxkGcH9Z2+yLuRnRKRtE37Piqv1oi1/eOYFdLZOMibqIRnXiIQcyH3zFrpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptumm9HN6GZ0M7oZ3YxuRjejm9HN6OZ0c7o53ZxudcyGFRrRiYcYxHx4yq0O6hnESVzEz23W+f1esho/t++b5na1RDYGMR9+L1mNgziJn9vchZtoxHLzwkMMYrnVfPNHHMRJXMRN/Ny+r0jY1RLZeIhB/Ny+34Tb1RLZOIif2/4VLuImfm5f2+uulsjG83DUVZzCb9y6hak2x7W9sEbIQiceYhDzYeXDxW/curGpNsfGRdzEz63ucarNsfFzs5pk5cPFfFj5cHEQJ/Fz+zosdrU5NhrRiZ/b98RrV5tj4+fmNcnKh4uDOInlVsaVDxeN6MRDDOLndmo6lQ8XB3ESP7dTk6x8uGjEcrPCQ4yHVfMXa4S6iqruupWrzsS/J+AfVklfHMRJXMRvsKhJVklfdOIhBjEfVknXPUN1JjZO4iKWW823SvqiE8utZlYlfTEfVklHHdoq6awaqpKuu47qTGzcRCM68TRWD+LfvyocxElcxE20h1WF35+d3NUg2FgW33yrFXDXXUe1AjZO4iJuoj1c9f+t+S4jOvEQg5gP9484iJO4iHTbdNt023TbdNt0sxp3FdYIu7BG8MJDDGKN8G13teE1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",
      "is_unconstrained": true,
      "name": "sync_private_state"
    }
  ],
  "name": "MessageBridge",
  "noir_version": "1.0.0-beta.14+82ec52a8c755d30ce655a2005834186a4acfa0c7-aztec",
  "outputs": {
    "globals": {
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "minters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Wormhole"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "state",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "sequences",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "owner",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "receiver_address",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000009"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "token_address",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000d"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_1",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000011"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_2",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000012"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_3",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000013"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_4",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000014"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_5",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000015"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_6",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000016"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_7",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000017"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_8",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000018"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_9",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000019"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_10",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_11",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001b"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_12",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001c"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_13",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001d"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_14",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001e"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_15",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001f"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_16",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000020"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_17",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000021"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_18",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000022"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_19",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000023"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "current_guardian_set_index",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000024"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "MessageBridge"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "config",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "owner",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "registered_emitters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "current_value",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "emitter_chain_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 16
                    }
                  },
                  {
                    "name": "emitter_address",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "value",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "MessageBridge::_validate_emitter_and_update_value_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::_validate_emitter_and_update_value_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "wormhole_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "chain_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 16
                    }
                  },
                  {
                    "name": "owner",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "message_fee",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "consistency",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  }
                ],
                "kind": "struct",
                "path": "MessageBridge::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "MessageBridge::get_config_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "wormhole_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "chain_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 16
                    }
                  },
                  {
                    "name": "message_fee",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "consistency",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  }
                ],
                "kind": "struct",
                "path": "types::config::Config"
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::get_config_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "MessageBridge::get_current_value_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::get_current_value_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "MessageBridge::get_owner_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::get_owner_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "chain_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 16
                    }
                  }
                ],
                "kind": "struct",
                "path": "MessageBridge::get_registered_emitter_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "array",
                "length": 32,
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 8
                }
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::get_registered_emitter_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "chain_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 16
                    }
                  },
                  {
                    "name": "emitter_address",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "MessageBridge::is_emitter_registered_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "boolean"
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::is_emitter_registered_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "message_ciphertext",
                    "type": {
                      "fields": [
                        {
                          "name": "storage",
                          "type": {
                            "kind": "array",
                            "length": 17,
                            "type": {
                              "kind": "field"
                            }
                          }
                        },
                        {
                          "name": "len",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 32
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "std::collections::bounded_vec::BoundedVec"
                    }
                  },
                  {
                    "name": "message_context",
                    "type": {
                      "fields": [
                        {
                          "name": "tx_hash",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "unique_note_hashes_in_tx",
                          "type": {
                            "fields": [
                              {
                                "name": "storage",
                                "type": {
                                  "kind": "array",
                                  "length": 64,
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              },
                              {
                                "name": "len",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "std::collections::bounded_vec::BoundedVec"
                          }
                        },
                        {
                          "name": "first_nullifier_in_tx",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "recipient",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::messages::processing::message_context::MessageContext"
                    }
                  }
                ],
                "kind": "struct",
                "path": "MessageBridge::process_message_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::process_message_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "vaa",
                    "type": {
                      "kind": "array",
                      "length": 2000,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "length",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "MessageBridge::receive_value_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::receive_value_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "source_chain_ids",
                    "type": {
                      "fields": [
                        {
                          "name": "storage",
                          "type": {
                            "kind": "array",
                            "length": 8,
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 16
                            }
                          }
                        },
                        {
                          "name": "len",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 32
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "std::collections::bounded_vec::BoundedVec"
                    }
                  },
                  {
                    "name": "emitter_addresses",
                    "type": {
                      "fields": [
                        {
                          "name": "storage",
                          "type": {
                            "kind": "array",
                            "length": 8,
                            "type": {
                              "kind": "array",
                              "length": 32,
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 8
                              }
                            }
                          }
                        },
                        {
                          "name": "len",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 32
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "std::collections::bounded_vec::BoundedVec"
                    }
                  }
                ],
                "kind": "struct",
                "path": "MessageBridge::register_emitter_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::register_emitter_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "destination_chain_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 16
                    }
                  },
                  {
                    "name": "value",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "fee_nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "MessageBridge::send_value_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::send_value_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "destination_chain_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 16
                    }
                  },
                  {
                    "name": "value",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "fee_nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "MessageBridge::send_value_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::send_value_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "MessageBridge::sync_private_state_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::sync_private_state_abi"
        }
      ]
    }
  },
  "transpiled": true
}
