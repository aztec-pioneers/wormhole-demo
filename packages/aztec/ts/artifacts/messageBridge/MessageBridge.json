{
  "file_map": {
    "100": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr",
      "source": "use super::utils::compute_fn_selector;\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::utils::get_params_len_quote;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault, panic};\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let seen_selectors =\n        &mut UHashMap::<Field, Quoted, BuildHasherDefault<Poseidon2Hasher>>::default();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n        let fn_name = function.name();\n\n        // Since function selectors are computed as the first 4 bytes of the hash of the function signature,\n        // it's possible to have collisions. With the following check, we ensure it doesn't happen within\n        // the same contract.\n        if seen_selectors.contains_key(selector) {\n            let existing_fn = seen_selectors.get(selector).unwrap();\n            panic(\n                f\"Public function selector collision detected between functions '{fn_name}' and '{existing_fn}'\",\n            );\n        }\n        seen_selectors.insert(selector, fn_name);\n\n        let params_len_quote = get_params_len_quote(parameters);\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $params_len_quote] = dep::aztec::context::public_context::calldata_copy(1, $params_len_quote);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index: &mut u32 = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[external(\"public\")]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "104": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/macros/functions/call_interface_stubs.nr",
      "source": "//! Stubs are auto-generated wrapper functions that provide an ergonomic interface for cross-contract calls.\n//! Instead of manually serializing arguments and creating call interfaces, stubs allow natural syntax, e.g. for\n//! enqueuing calls to public functions:\n//!\n//!   ExternalContract.at(address).some_method(arg1, arg2).enqueue()\n\nuse crate::macros::utils::{AsStrQuote, compute_fn_selector, is_fn_view};\nuse super::stub_registry;\nuse protocol_types::meta::utils::derive_serialization_quotes;\nuse std::meta::unquote;\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\npub comptime fn register_private_fn_stub(f: FunctionDefinition) {\n    let stub = if is_fn_view(f) {\n        create_private_static_stub(f)\n    } else {\n        create_private_stub(f)\n    };\n    stub_registry::register(f.module(), stub);\n}\n\npub comptime fn register_public_fn_stub(f: FunctionDefinition) {\n    let stub = if is_fn_view(f) {\n        create_public_static_stub(f)\n    } else {\n        create_public_stub(f)\n    };\n    stub_registry::register(f.module(), stub);\n}\n\npub comptime fn register_utility_fn_stub(f: FunctionDefinition) {\n    let stub = create_utility_stub(f);\n    stub_registry::register(f.module(), stub);\n}\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, Quoted, u32, Field) {\n    // Dear privacy adventurer,\n    // Chances are, you've command+clicked on the name of an external function\n    // call -- seeking to view that function -- only to end up here.\n    // Here's an explanation:\n    // The external contract that you're calling was likely annotated with the `#[aztec]`\n    // annotation -- as all good aztec contracts are. This triggers a macro which generates\n    // a \"contract interface\" for that contract, which is effectively a pretty interface\n    // that gives natural contract calling semantics:\n    //\n    // `MyImportedContract.at(some_address).my_method(arg1, arg2).enqueue();\n    //\n    // Unfortunately, the usage of macros makes it a bit of a black box.\n    // To actually view the target function, you could instead command+click on\n    // `MyImportedContract`, or you can just manually search it.\n    // If you want to view the noir code that gets generated by this macro, you can\n    // use `nargo expand` on your contract.\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n\n    let (serialized_args_array_construction, _, serialized_args_array_name) =\n        derive_serialization_quotes(fn_parameters, false);\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name,\n        fn_name_str, fn_name_len, fn_selector,\n    )\n}\n\ncomptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, serialized_args_array_name, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            )\n        }\n    }\n}\n\ncomptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, serialized_args_array_name, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, serialized_args_array_name, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            )\n        }\n    }\n}\n\ncomptime fn create_utility_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, serialized_args_array_name, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::UtilityCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::UtilityCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            )\n        }\n    }\n}\n"
    },
    "105": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\n// Used by `create_mark_as_initialized` (you won't find it through searching)\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\n// Used by `create_mark_as_initialized` (you won't find it through searching)\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\n// Used by `create_init_check` (you won't find it through searching)\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\n// Used by `create_init_check` (you won't find it through searching)\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\n// Used by `create_assert_correct_initializer_args` (you won't find it through searching)\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender().unwrap()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n// Used by `create_assert_correct_initializer_args` (you won't find it through searching)\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender().unwrap()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "108": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{\n        auth_registry::AUTHORIZE_ONCE_REGISTRY,\n        call_interface_stubs::{\n            register_private_fn_stub, register_public_fn_stub, register_utility_fn_stub,\n        },\n    },\n    notes::NOTES,\n    utils::{\n        fn_has_authorize_once, fn_has_noinitcheck, is_fn_contract_library_method, is_fn_external,\n        is_fn_initializer, is_fn_internal, is_fn_test, is_fn_view, modify_fn_body,\n        module_has_initializer, module_has_storage,\n    },\n};\nuse dep::protocol_types::meta::utils::derive_serialization_quotes;\nuse std::meta::{ctstring::AsCtString, type_of};\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) {\n    register_private_fn_stub(f);\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    let (args_serialization, _, serialized_args_name) =\n        derive_serialization_quotes(original_params, false);\n\n    let context_creation = quote {\n        $args_serialization\n        let args_hash = dep::aztec::hash::hash_args_array($serialized_args_name);\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, args_hash);\n    };\n\n    let function_name = f.name();\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        let assertion_message = f\"Function {function_name} can only be called internally\";\n        quote { assert(context.msg_sender().unwrap() == context.this_address(), $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        let assertion_message =\n            f\"Function {function_name} can only be called statically\".as_ctstring().as_quoted_str();\n        quote { assert(context.inputs.call_context.is_static_call, $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (\n            quote { aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_private(context); },\n            quote { aztec::macros::functions::initialization_utils::mark_as_initialized_private(&mut context); },\n        )\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        quote { aztec::macros::functions::initialization_utils::assert_is_initialized_private(&mut context); }\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any. Note that the message\n    // discovery call syncs private events as well. We do not sync those here if there are no notes because we don't\n    // have an API that would access events from private functions.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f, true)\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is serialized and hashed before being passed to the context.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n\n        let (return_serialization, _, serialized_return_name) =\n            derive_serialization_quotes([(return_value_var_name, return_value_type)], false);\n\n        body = body_without_return;\n\n        quote {\n            $return_value_assignment\n            $return_serialization\n            context.set_return_hash($serialized_return_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    // A quote to be injected at the beginning of the function body.\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) {\n    register_public_fn_stub(f);\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n\n    let args_len_quote = if original_params.len() == 0 {\n        // If the function has no parameters, we set the args_len to 0.\n        quote { 0 }\n    } else {\n        // The following will give us <type_of_struct_member_1 as Serialize>::N + <type_of_struct_member_2 as Serialize>::N + ...\n        original_params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n            <$param_type as $crate::protocol_types::traits::Serialize>::N\n        }\n            })\n            .join(quote {+})\n    };\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len_quote] = dep::aztec::context::public_context::calldata_copy(1, $args_len_quote);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    let name = f.name();\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        let assertion_message = f\"Function {name} can only be called internally\";\n        quote { assert(context.msg_sender().unwrap() == context.this_address(), $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        let name = f.name();\n        let assertion_message =\n            f\"Function {name} can only be called statically\".as_ctstring().as_quoted_str();\n        quote { assert(context.is_static_call(), $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (\n            quote { aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_public(context); },\n            quote { aztec::macros::functions::initialization_utils::mark_as_initialized_public(&mut context); },\n        )\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        quote { aztec::macros::functions::initialization_utils::assert_is_initialized_public(&mut context); }\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f, false)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    register_utility_fn_stub(f);\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage(f.module()) {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process or they may be used to sync private events from TypeScript\n    // (`sync_private_state` function gets invoked by PXE::getPrivateEvents function).\n    let message_discovery_call = create_message_discovery_call();\n\n    // A quote to be injected at the beginning of the function body.\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Injects an authwit verification check of the form:\n/// ```\n///   if (!from.eq(context.msg_sender().unwrap())) {\n///         assert_current_call_valid_authwit::<N>(&mut context, from);\n///     } else {\n///         assert(authwit_nonce, \"Invalid authwit nonce. When 'from' and 'msg_sender' are the same, authwit_nonce must be zero\");\n///     }\n/// ```\n/// where `from` and `authwit_nonce` are the names of the parameters that are expected to be present in the function definition.\n/// This check is injected by the `#[authorize_once(\"from_arg_name\", \"nonce_arg_name\")]`, which allows the user to define\n/// which parameters to use.\n///\n/// # Arguments\n/// * `f` - The function definition to inject the authwit verification check into. The function must have parameters\n///         matching the names specified in the `#[authorize_once]` attribute.\n/// * `is_private` - Whether the function is a private function (`true`) or a public function (`false`). This determines\n///                  which authwit verification method to use: `assert_current_call_valid_authwit` for private functions\n///                  or `assert_current_call_valid_authwit_public` for public functions.\npub(crate) comptime fn create_authorize_once_check(\n    f: FunctionDefinition,\n    is_private: bool,\n) -> Quoted {\n    let maybe_authorize_once_args = AUTHORIZE_ONCE_REGISTRY.get(f);\n    let authorize_once_args = if maybe_authorize_once_args.is_some() {\n        maybe_authorize_once_args.unwrap()\n    } else {\n        // We need to for authorize_once to have already executed so that we can retrieve its params - this depends on\n        // the order in which the attributes are applied.\n        panic(\n            f\"Functions marked with #[authorize_once] must have the #[external(\\\"private\\\")] or #[external(\\\"public\\\")] attribute placed last\",\n        )\n    };\n\n    let (from_arg_name, nonce_arg_name) = authorize_once_args;\n    let name: Quoted = f.name();\n\n    let from_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{from_arg_name}\".quoted_contents());\n    let (from_arg_name_quoted, from_arg_type) = if from_arg_candidates.len() == 1 {\n        from_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {from_arg_name} parameter. Please specify which one to use in #[authorize_once(\\\"...\\\", \\\"authwit_nonce\\\")]\",\n        )\n    };\n    if from_arg_type\n        != quote { dep::protocol_types::address::aztec_address::AztecAddress }.as_type() {\n        panic(\n            f\"Argument {from_arg_name_quoted} in function {name} must be of type AztecAddress, but is of type {from_arg_type}\",\n        )\n    }\n\n    let nonce_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{nonce_arg_name}\".quoted_contents());\n    let (nonce_arg_name_quoted, nonce_arg_type) = if nonce_arg_candidates.len() == 1 {\n        nonce_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {nonce_arg_name}. Please specify which one to use in #[authorize_once(\\\"from\\\", \\\"...\\\")]\",\n        )\n    };\n    if nonce_arg_type != quote { Field }.as_type() {\n        panic(\n            f\"Argument {nonce_arg_name_quoted} in function {name} must be of type Field, but is of type {nonce_arg_type}\",\n        );\n    }\n\n    let nonce_check_quote = f\"{nonce_arg_name_quoted} == 0\".quoted_contents();\n\n    let fn_call = if is_private {\n        // At this point, the original args of the fn have already been altered by the macro\n        // to include PrivateContextInputs, so we need to adjust the args_len accordingly.\n        let args_len = f.parameters().len() - 1;\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit::<$args_len> }\n    } else {\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit_public }\n    };\n    let invalid_nonce_message = f\"Invalid authwit nonce. When '{from_arg_name}' and 'msg_sender' are the same, '{nonce_arg_name}' must be zero\"\n        .as_ctstring()\n        .as_quoted_str();\n    quote {         \n        if (!$from_arg_name_quoted.eq(context.msg_sender().unwrap())) {\n            $fn_call(&mut context, $from_arg_name_quoted);\n        } else {\n            assert($nonce_check_quote, $invalid_nonce_message);\n        }\n    }\n}\n\n/// Checks if each function in the module is marked with either #[external(...)], #[contract_library_method], or #[test].\n/// Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_external(f) & !is_fn_contract_library_method(f) & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[external(...)], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "110": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/macros/notes.nr",
      "source": "use crate::note::note_getter_options::PropertySelector;\nuse std::{collections::bounded_vec::BoundedVec, meta::{ctstring::AsCtString, type_of}};\n\n/// Maximum number of note types within 1 contract.\ncomptime global MAX_NOTE_TYPES: u32 = 128;\n\n/// A BoundedVec containing all the note types within this contract.\npub comptime mut global NOTES: BoundedVec<Type, MAX_NOTE_TYPES> = BoundedVec::new();\n\ncomptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < MAX_NOTE_TYPES,\n        f\"A contract can contain at most {MAX_NOTE_TYPES} different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_type_impl(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n    let typ = s.as_type();\n    let note_type_name: str<_> = f\"{name}\".as_ctstring().as_quoted_str!();\n    let max_note_packed_len = crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                // This static assertion ensures the note's packed length doesn't exceed the maximum allowed size.\n                // While this check would ideally live in the Packable trait implementation, we place it here since\n                // this function is always generated by our macros and the Packable trait implementation is not.\n                // Note: We set the note type name and max packed length as local variables because injecting them\n                // directly into the error message doesn't work.\n                let note_type_name = $note_type_name;\n                let max_note_packed_len: u32 = $max_note_packed_len; // Casting to u32 to avoid the value to be printed in hex.\n                let note_packed_len = <$typ as Packable>::N;\n                std::static_assert(note_packed_len <= $max_note_packed_len, f\"{note_type_name} has a packed length of {note_packed_len} fields, which exceeds the maximum allowed length of {max_note_packed_len} fields\");\n\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullification: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullification: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::traits::Packable::pack(self).concat( [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::context::PrivateContext,\n                note_hash_for_nullification: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullification, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullification: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullification, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _, _)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates the core note functionality for a struct:\n///\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - NoteHash trait implementation: Handles note hash and nullifier computation\n///\n/// # Requirements\n///\n/// The note struct must:\n/// - Have an `owner` field\n/// - Implement the `Packable` trait\n/// - Not exceed `MAX_NOTE_PACKED_LEN` when packed\n///\n/// # Registration\n///\n/// Registers the note in the global `NOTES` BoundedVec to enable note processing functionality.\n///\n/// # Generated Code\n///\n/// For detailed documentation on the generated implementations, see:\n/// - `generate_note_properties()`\n/// - `generate_note_type_impl()`\n/// - `generate_note_hash_trait_impl()`\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n    assert_has_packable(s);\n\n    // We register the note in the global `NOTES` BoundedVec because we need that information inside the #[aztec] macro\n    // to generate note processing functionality.\n    NOTES.push(s.as_type());\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_type_impl = generate_note_type_impl(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n\n    quote {\n        $note_properties\n        $note_type_impl\n        $note_hash_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n///\n/// # Requirements\n///\n/// The note struct must:\n/// - Implement the `Packable` trait\n/// - Not exceed `MAX_NOTE_PACKED_LEN` when packed\n///\n/// Unlike the `#[note]` macro, there is no requirement for an `owner` field.\n///\n/// # Registration\n///\n/// Registers the note in the global `NOTES` BoundedVec to enable note processing functionality.\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    assert_has_packable(s);\n\n    // We register the note in the global `NOTES` BoundedVec because we need that information inside the #[aztec] macro\n    // to generate note processing functionality.\n    NOTES.push(s.as_type());\n\n    let note_type_id = get_next_note_type_id();\n    let note_properties = generate_note_properties(s);\n    let note_type_impl = generate_note_type_impl(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_type_impl\n    }\n}\n\n/// Asserts that the given note implements the `Packable` trait.\n///\n/// We require that notes have the `Packable` trait implemented because it is used when emitting a note in a log or as\n/// an offchain message.\ncomptime fn assert_has_packable(note: TypeDefinition) {\n    let packable_constraint =\n        quote { crate::protocol_types::traits::Packable }.as_trait_constraint();\n    let note_name = note.name();\n\n    assert(\n        note.as_type().implements(packable_constraint),\n        f\"{note_name} does not implement Packable trait. Either implement it manually or place #[derive(Packable)] on the note struct before #[note] macro invocation.\",\n    );\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    let note_name = note.name();\n\n    assert(\n        has_owner,\n        f\"{note_name} does not have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "111": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/macros/storage.nr",
      "source": "use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract should have this macro (or `storage_no_init`) applied to it, and the\n/// struct has to be called 'Storage'.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    let struct_name = s.name();\n    if struct_name != quote { Storage } {\n        panic(\n            f\"The #[storage] macro can only be applied to a struct with name 'Storage', got '{struct_name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage_no_init\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ, _) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot });\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields = storage_layout_fields.push_back(\n            quote { pub $name: dep::aztec::state_vars::storage::Storable },\n        );\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::state_vars::storage::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract can have this macro (or storage_no_init) applied to it, and the struct\n/// has to be called 'Storage'.\npub comptime fn storage_no_init(s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n\n    // We do need to make sure that the type is called Storage, since we'll do `Storage::init` later on.\n\n    if s.name() != quote { Storage } {\n        let name = s.name();\n        panic(\n            f\"The #[storage_no_init] macro can only be applied to a struct with name 'Storage', got '{name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(typ: Type, slot: Quoted) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    let constructor = if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot });\n\n        quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }\n    } else {\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        quote { $struct_name::new(context, $slot)}\n    };\n\n    (constructor, get_storage_size(typ))\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n"
    },
    "113": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod private_events;\npub mod private_notes;\npub mod process_message;\n\nuse crate::{\n    messages::{\n        discovery::{\n            private_notes::MAX_NOTE_PACKED_LEN, process_message::process_message_ciphertext,\n        },\n        processing::{\n            get_private_logs, pending_tagged_log::PendingTaggedLog,\n            validate_enqueued_notes_and_events,\n        },\n    },\n    utils::array,\n};\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, note nonce, storage slot and note\n/// type ID and attempts to compute its note hash (not hashed by note nonce nor siloed by address) and inner nullifier\n/// (not siloed by address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, note_nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullification = aztec::note::utils::compute_note_hash_for_nullification(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(note_nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullification);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\npub type ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* note nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private logs are downloaded and inspected to find new private\n/// notes, partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Note that the state is synchronized up to the latest block synchronized by PXE. That should be close to the chain\n/// tip as block synchronization is performed before contract function simulation is done.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    // First we process all private logs, which can contain different kinds of messages e.g. private notes, partial\n    // notes, private events, etc.\n    let mut logs = get_private_logs(contract_address);\n    logs.for_each(|i, pending_tagged_log: PendingTaggedLog| {\n        debug_log_format(\n            \"Processing log with tag {0}\",\n            [pending_tagged_log.log.get(0)],\n        );\n\n        // We remove the tag from the pending tagged log and process the message ciphertext contained in it.\n        let message_ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n        process_message_ciphertext(\n            contract_address,\n            compute_note_hash_and_nullifier,\n            message_ciphertext,\n            pending_tagged_log.context,\n        );\n        logs.remove(i);\n    });\n\n    // Then we process all pending partial notes, regardless of whether they were found in the current or previous\n    // executions.\n    partial_notes::fetch_and_process_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    // Finally we validate all notes and events that were found as part of the previous processes, resulting in them\n    // being added to PXE's database and retrievable via oracles (get_notes) and our TS API (PXE::getPrivateEvents).\n    validate_enqueued_notes_and_events(contract_address);\n}\n"
    },
    "114": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub note_nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given note nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    note_nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Found valid nonces for a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullification,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        note_nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullification = compute_note_hash_for_nullification(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(note_nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullification);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        note_nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let note_nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(note_nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash = compute_unique_note_hash(\n            note_nonce,\n            compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash),\n        );\n        let inner_nullifier = note.compute_nullifier_unconstrained(\n            compute_note_hash_for_nullification(retrieved_note, STORAGE_SLOT),\n        );\n\n        NoteAndData { note, note_nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.note_nonce, note_and_data.note_nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == first_note_and_data.note_nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == second_note_and_data.note_nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "115": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::{\n            enqueue_note_for_validation, get_pending_partial_notes_completion_logs,\n            log_retrieval_response::LogRetrievalResponse,\n        },\n    },\n    utils::array,\n};\n\nuse protocol_types::{\n    address::AztecAddress,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for logs that would result in the completion of pending partial notes, ultimately resulting in the notes\n/// being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    // Each of the pending partial notes might get completed by a log containing its public values. For performance\n    // reasons, we fetch all of these logs concurrently and then process them one by one, minimizing the amount of time\n    // waiting for the node roundtrip.\n    let maybe_completion_logs =\n        get_pending_partial_notes_completion_logs(contract_address, pending_partial_notes);\n\n    // Each entry in the maybe completion logs array corresponds to the entry in the pending partial notes array at the\n    // same index. This means we can use the same index as we iterate through the responses to get both the partial note\n    // and the log that might complete it.\n    assert_eq(maybe_completion_logs.len(), pending_partial_notes.len());\n\n    maybe_completion_logs.for_each(|i, maybe_log: Option<LogRetrievalResponse>| {\n        // We clear the completion logs as we read them so that the array is empty by the time we next query it.\n        // TODO(#14943): use volatile arrays to avoid having to manually clear this.\n        maybe_completion_logs.remove(i);\n\n        let pending_partial_note = pending_partial_notes.get(i);\n\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log plaintext to get\n            // the complete packed content.\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                log.log_payload,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            // TODO(#11627): is there anything reasonable we can do if we get a log but it doesn't result in a note\n            // being found?\n            if discovered_notes.len() == 0 {\n                panic(\n                    f\"A partial note's completion log did not result in any notes being found - this should never happen\",\n                );\n            }\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                enqueue_note_for_validation(\n                    contract_address,\n                    pending_partial_note.storage_slot,\n                    discovered_note.note_nonce,\n                    complete_packed_note,\n                    discovered_note.note_hash,\n                    discovered_note.inner_nullifier,\n                    log.tx_hash,\n                    pending_partial_note.recipient,\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
    },
    "116": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/discovery/private_events.nr",
      "source": "use crate::{\n    event::event_selector::EventSelector,\n    messages::{encoding::MAX_MESSAGE_CONTENT_LEN, processing::enqueue_event_for_validation},\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::GENERATOR_INDEX__EVENT_COMMITMENT,\n    hash::poseidon2_hash_with_separator_bounded_vec, traits::FromField,\n};\n\n/// The number of fields in a private event message content that are not the event's serialized representation\n/// (1 field for randomness).\nglobal PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of an event's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, randomness, etc.).\npub global MAX_EVENT_SERIALIZED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN;\n\npub unconstrained fn process_private_event_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n) {\n    // In the case of events, the msg metadata is the event selector.\n    let event_type_id = EventSelector::from_field(msg_metadata as Field);\n\n    assert(\n        msg_content.len() > PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n        f\"Invalid private event message: all private event messages must have at least {PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private event message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN\",\n    );\n\n    let serialized_event_with_randomness = msg_content;\n\n    let event_commitment = poseidon2_hash_with_separator_bounded_vec(\n        serialized_event_with_randomness,\n        GENERATOR_INDEX__EVENT_COMMITMENT,\n    );\n\n    // Randomness was injected into the event payload in `emit_event_in_private` but we have already used it\n    // to compute the event commitment, so we can safely discard it now.\n    let serialized_event = array::subbvec(\n        serialized_event_with_randomness,\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n    );\n\n    enqueue_event_for_validation(\n        contract_address,\n        event_type_id,\n        serialized_event,\n        event_commitment,\n        tx_hash,\n        recipient,\n    );\n}\n"
    },
    "117": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::enqueue_note_for_validation,\n    },\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\n// See the call to `std::static_assert` below to see what's in these fields.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        enqueue_note_for_validation(\n            contract_address,\n            storage_slot,\n            discovered_note.note_nonce,\n            packed_note,\n            discovered_note.note_hash,\n            discovered_note.inner_nullifier,\n            tx_hash,\n            recipient,\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
    },
    "118": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/discovery/process_message.nr",
      "source": "use crate::messages::{\n    discovery::{\n        ComputeNoteHashAndNullifier, partial_notes::process_partial_note_private_msg,\n        private_events::process_private_event_msg, private_notes::process_private_note_msg,\n    },\n    encoding::{decode_message, MESSAGE_CIPHERTEXT_LEN, MESSAGE_PLAINTEXT_LEN},\n    encryption::{aes128::AES128, message_encryption::MessageEncryption},\n    msg_type::{\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n    },\n    processing::message_context::MessageContext,\n};\n\nuse protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\n/// Processes a message that can contain notes, partial notes, or events.\n///\n/// Notes result in nonce discovery being performed prior to delivery, which requires knowledge of the transaction hash\n/// in which the notes would've been created (typically the same transaction in which the log was emitted), along with\n/// the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier` function. Once\n/// discovered, the notes are enqueued for validation.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\n///\n/// Events are processed by computing an event commitment from the serialized event data and its randomness field, then\n/// enqueueing the event data and commitment for validation.\npub unconstrained fn process_message_ciphertext<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_ciphertext: BoundedVec<Field, MESSAGE_CIPHERTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    process_message_plaintext(\n        contract_address,\n        compute_note_hash_and_nullifier,\n        AES128::decrypt(message_ciphertext, message_context.recipient),\n        message_context,\n    );\n}\n\npub unconstrained fn process_message_plaintext<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_plaintext: BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    // The first thing to do after decrypting the message is to determine what type of message we're processing. We\n    // have 3 message types: private notes, partial notes and events.\n\n    // We decode the message to obtain the message type id, metadata and content.\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(message_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            message_context.tx_hash,\n            message_context.unique_note_hashes_in_tx,\n            message_context.first_nullifier_in_tx,\n            message_context.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        process_private_event_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n            message_context.tx_hash,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "119": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::utils::array;\nuse protocol_types::constants::PRIVATE_LOG_CIPHERTEXT_LEN;\n\n// We reassign to the constant here to communicate the distinction between a log and a message. In Aztec.nr, unlike in\n// protocol circuits, we have a concept of a message that can be emitted either as a private log or as an offchain\n// message. Message is a piece of data that is to be eventually delivered to a contract via the `process_message(...)`\n// utility function function that is injected by the #[aztec] macro.\npub global MESSAGE_CIPHERTEXT_LEN: u32 = PRIVATE_LOG_CIPHERTEXT_LEN;\n\n// TODO(#12750): The global variables below should not be here as they are AES128 specific.\n// ciphertext_length (2) + 14 bytes pkcs#7 AES padding.\npub(crate) global HEADER_CIPHERTEXT_SIZE_IN_BYTES: u32 = 16;\n\npub global EPH_PK_X_SIZE_IN_FIELDS: u32 = 1;\npub global EPH_PK_SIGN_BYTE_SIZE_IN_BYTES: u32 = 1;\n\n// (17 - 1) * 31 - 16 - 1 = 479\nglobal MESSAGE_PLAINTEXT_SIZE_IN_BYTES: u32 = (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS)\n    * 31\n    - HEADER_CIPHERTEXT_SIZE_IN_BYTES\n    - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES;\n// Each field of the original note log was serialized to 32 bytes. Below we convert the bytes back to fields.\n// 479 / 32 = 15\npub global MESSAGE_PLAINTEXT_LEN: u32 = MESSAGE_PLAINTEXT_SIZE_IN_BYTES / 32;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MESSAGE_PLAINTEXT_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u16 {\n    fn from(value: u8) -> u16 {\n        value as u16\n    }\n}\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u16> for u32 {\n    fn from(value: u16) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u16> for u64 {\n    fn from(value: u16) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u16> for u128 {\n    fn from(value: u16) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u16> for Field {\n    fn from(value: u16) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i16 {\n    fn from(value: i8) -> i16 {\n        value as i16\n    }\n}\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i16> for i32 {\n    fn from(value: i16) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\n\nimpl From<i16> for i64 {\n    fn from(value: i16) -> i64 {\n        value as i64\n    }\n}\n\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u16 {\n    fn from(value: bool) -> u16 {\n        value as u16\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for u128 {\n    fn from(value: bool) -> u128 {\n        value as u128\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i16 {\n    fn from(value: bool) -> i16 {\n        value as i16\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            let body = if type1 == type2 {\n                quote { self }\n            } else if type1 == quote { bool } {\n                quote { self != 0 }\n            } else {\n                quote { self as $type1 }\n            };\n\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        $body\n                    }\n                }\n            },\n            );\n        }\n    }\n\n    let u_types =\n        [quote { bool }, quote { u8 }, quote { u16 }, quote { u32 }, quote { u64 }, quote { u128 }];\n\n    for type2 in u_types {\n        let body = quote { self as Field };\n\n        impls = impls.push_back(\n            quote {\n                impl AsPrimitive<Field> for $type2 {\n                    fn as_(self) -> Field {\n                        $body\n                    }\n                }\n            },\n        );\n    }\n\n    for type1 in u_types {\n        let body = if type1 == quote { bool } {\n            quote { self != 0 }\n        } else {\n            quote { self as $type1 }\n        };\n\n        impls = impls.push_back(\n            quote {\n                impl AsPrimitive<$type1> for Field {\n                    fn as_(self) -> $type1 {\n                        $body\n                    }\n                }\n            },\n        );\n    }\n\n    impls.join(quote {})\n}\n"
    },
    "120": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encoding::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, MESSAGE_CIPHERTEXT_LEN, MESSAGE_PLAINTEXT_LEN,\n        },\n        encryption::message_encryption::MessageEncryption,\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__message_bytes__from_PT,\n            get_arr_of_size__message_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\n/**\n * Computes N close-to-uniformly-random 256 bits from a given ECDH shared_secret.\n *\n * NEVER re-use the same iv and sym_key.\n * DO NOT call this function more than once with the same shared_secret.\n *\n * This function is only known to be safe if shared_secret is computed by combining a \n * random ephemeral key with an address point. See big comment within the body of the function.\n * See big comment within the body of the function.\n */\nfn extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [[u8; 32]; N] {\n    /*\n     * Unsafe because of https://eprint.iacr.org/2010/264.pdf Page 13, Lemma 2 (and the * two paragraphs below it).\n     *\n     * If you call this function, you need to be careful and aware of how the arg\n     * `shared_secret` has been derived.\n     *\n     * The paper says that the way you derive aes keys and IVs should be fine with poseidon2\n     * (modelled as a RO), as long as you _don't_ use Poseidon2 as a PRG to generate the * two exponents x & y which multiply to the shared secret S:\n     *\n     * S = [x*y]*G.\n     *\n     * (Otherwise, you would have to \"key\" poseidon2, i.e. generate a uniformly string K\n     * which can be public and compute Hash(x) as poseidon(K,x)).\n     * In that lemma, k would be 2*254=508, and m would be the number of points on the * grumpkin curve (which is close to r according to the Hasse bound).\n     *\n     * Our shared secret S is [esk * address_sk] * G, and the question is: * Can we compute hash(S) using poseidon2 instead of sha256?\n     *\n     * Well, esk is random and not generated with poseidon2, so that's good.\n     * What about address_sk?\n     * Well, address_sk = poseidon2(stuff) + ivsk, so there was some\n     * discussion about whether address_sk is independent of poseidon2.\n     * Given that ivsk is random and independent of poseidon2, the address_sk is also\n     * independent of poseidon2.\n     *\n     * Tl;dr: we believe it's safe to hash S = [esk * address_sk] * G using poseidon2,\n     * in order to derive a symmetric key.\n     *\n     * If you're calling this function for a differently-derived `shared_secret`, be\n     * careful.\n     *\n     */\n\n    /* The output of this function needs to be 32 random bytes.\n     * A single field won't give us 32 bytes of entropy.\n     * So we compute two \"random\" fields, by poseidon-hashing with two different\n     * generators.\n     * We then extract the last 16 (big endian) bytes of each \"random\" field.\n     * Note: we use to_be_bytes because it's slightly more efficient. But we have to\n     * be careful not to take bytes from the \"big end\", because the \"big\" byte is\n     * not uniformly random over the byte: it only has < 6 bits of randomness, because\n     * it's the big end of a 254-bit field element.\n     */\n\n    let mut all_bytes: [[u8; 32]; N] = std::mem::zeroed();\n    // We restrict N to be < 2^8, because of how we compute the domain separator\n    // from k below (where k <= N must be 8 bits). In practice, it's extremely\n    // unlikely that an app will want to compute >= 256 ciphertexts.\n    std::static_assert(N < 256, \"N too large\");\n    for k in 0..N {\n        // We augment the domain separator with the loop index, so that we can\n        // generate N lots of randomness.\n        let k_shift = (k as u16 << 8);\n        let separator_1 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY as u16;\n        let separator_2 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY_2 as u16;\n\n        let rand1: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_1);\n        let rand2: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_2);\n\n        let rand1_bytes: [u8; 32] = rand1.to_be_bytes();\n        let rand2_bytes: [u8; 32] = rand2.to_be_bytes();\n\n        let mut bytes: [u8; 32] = [0; 32];\n        for i in 0..16 {\n            // We take bytes from the \"little end\" of the be-bytes arrays:\n            let j = 32 - i - 1;\n            bytes[i] = rand1_bytes[j];\n            bytes[16 + i] = rand2_bytes[j];\n        }\n\n        all_bytes[k] = bytes;\n    }\n\n    all_bytes\n}\n\nfn derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits<let N: u32>(\n    many_random_256_bits: [[u8; 32]; N],\n) -> [([u8; 16], [u8; 16]); N] {\n    // Many (sym_key, iv) pairs:\n    let mut many_pairs: [([u8; 16], [u8; 16]); N] = std::mem::zeroed();\n    for k in 0..N {\n        let random_256_bits = many_random_256_bits[k];\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n        for i in 0..16 {\n            sym_key[i] = random_256_bits[i];\n            iv[i] = random_256_bits[i + 16];\n        }\n        many_pairs[k] = (sym_key, iv);\n    }\n\n    many_pairs\n}\n\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [([u8; 16], [u8; 16]); N] {\n    let many_random_256_bits: [[u8; 32]; N] = extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe(\n        shared_secret,\n    );\n\n    derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits(many_random_256_bits)\n}\n\npub struct AES128 {}\n\nimpl MessageEncryption for AES128 {\n    fn encrypt<let PlaintextLen: u32>(\n        plaintext: [Field; PlaintextLen],\n        recipient: AztecAddress,\n    ) -> [Field; MESSAGE_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the message in `do_process_message`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        // TODO (#17158): Currently we unwrap the Option returned by derive_ecdh_shared_secret_using_aztec_address.\n        // We need to handle the case where the ephemeral public key is invalid to prevent potential DoS vectors.\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient).unwrap();\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        // It is safe to call the `unsafe` function here, because we know the `shared_secret`\n        // was derived using an AztecAddress (the recipient). See the block comment\n        // at the start of this unsafe target function for more info.\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, body_iv, body_sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        std::static_assert(\n            ciphertext_bytes.len() == 16 * (1 + (PlaintextLen * 32) / 16),\n            \"unexpected ciphertext length\",\n        );\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, header_iv, header_sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        std::static_assert(\n            header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES,\n            \"unexpected ciphertext header length\",\n        );\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut message_bytes_padding_to_mult_31 =\n            get_arr_of_size__message_bytes_padding__from_PT::<PlaintextLen * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        message_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut message_bytes = get_arr_of_size__message_bytes__from_PT::<PlaintextLen * 32>();\n\n        std::static_assert(\n            message_bytes.len() % 31 == 0,\n            \"Unexpected error: message_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        message_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            message_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            message_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..message_bytes_padding_to_mult_31.len() {\n            message_bytes[offset + i] = message_bytes_padding_to_mult_31[i];\n        }\n        offset += message_bytes_padding_to_mult_31.len();\n\n        // Ideally we would be able to have a static assert where we check that the offset would be such that we've\n        // written to the entire log_bytes array, but we cannot since Noir does not treat the offset as a comptime\n        // value (despite the values that it goes through being known at each stage). We instead check that the\n        // computation used to obtain the offset computes the expected value (which we _can_ do in a static check), and\n        // then add a cheap runtime check to also validate that the offset matches this.\n        std::static_assert(\n            1\n                + header_ciphertext_bytes.len()\n                + ciphertext_bytes.len()\n                + message_bytes_padding_to_mult_31.len()\n                == message_bytes.len(),\n            \"unexpected message length\",\n        );\n        assert(offset == message_bytes.len(), \"unexpected encrypted message length\");\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make messages produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let message_bytes_as_fields = bytes_to_fields(message_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final message\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; MESSAGE_CIPHERTEXT_LEN] = [0; MESSAGE_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..message_bytes_as_fields.len() {\n            ciphertext[offset + i] = message_bytes_as_fields[i];\n        }\n        offset += message_bytes_as_fields.len();\n\n        for i in offset..MESSAGE_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the message\n            // (all the \"real\" message fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the message to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt(\n        ciphertext: BoundedVec<Field, MESSAGE_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, MESSAGE_PLAINTEXT_LEN> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, MESSAGE_CIPHERTEXT_LEN, MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) != 0;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret\n        // TODO(#17158): handle invalid ephemeral keys when decrypting to prevent DoS vectors\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk.unwrap());\n\n        // Derive symmetric keys:\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with messages with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext =\n            aes128_decrypt_oracle(header_ciphertext_bvec, header_iv, header_sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, body_iv, body_sym_key);\n\n        // Each field of the original note message was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::{\n            encoding::MESSAGE_PLAINTEXT_LEN, encryption::message_encryption::MessageEncryption,\n        },\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{address::AztecAddress, traits::FromField};\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt() {\n        let env = TestEnvironment::new();\n\n        // Message decryption requires oracles that are only available during private execution\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3];\n\n            let recipient = AztecAddress::from_field(\n                0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n            );\n\n            // Mock random values for deterministic test\n            let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(eph_sk).times(1);\n\n            let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(randomness).times(1000000);\n\n            let _ = OracleMock::mock(\"privateGetNextAppTagAsSender\").returns(42);\n\n            // Encrypt the message\n            let encrypted_message = BoundedVec::from_array(AES128::encrypt(plaintext, recipient));\n\n            // Mock shared secret for deterministic test\n            let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n                EmbeddedCurveScalar::from_field(eph_sk),\n                recipient,\n            );\n\n            let _ = OracleMock::mock(\"utilityGetSharedSecret\").returns(shared_secret.unwrap());\n\n            // Decrypt the message\n            let decrypted = AES128::decrypt(encrypted_message, recipient);\n\n            // The decryption function spits out a BoundedVec because it's designed to work with messages with unknown length\n            // at compile time. For this reason we need to convert the original input to a BoundedVec.\n            let plaintext_bvec = BoundedVec::<Field, MESSAGE_PLAINTEXT_LEN>::from_array(plaintext);\n\n            // Verify decryption matches original plaintext\n            assert_eq(\n                decrypted,\n                plaintext_bvec,\n                \"Decrypted bytes should match original plaintext\",\n            );\n\n            // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n            // static methods of the struct).\n            let _ = AES128 {};\n        });\n    }\n}\n"
    },
    "137": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/processing/mod.nr",
      "source": "pub(crate) mod event_validation_request;\npub mod message_context;\npub(crate) mod note_validation_request;\npub(crate) mod log_retrieval_request;\npub(crate) mod log_retrieval_response;\npub(crate) mod pending_tagged_log;\n\nuse crate::{\n    capsules::CapsuleArray,\n    event::event_selector::EventSelector,\n    messages::{\n        discovery::{\n            partial_notes::DeliveredPendingPartialNote, private_events::MAX_EVENT_SERIALIZED_LEN,\n            private_notes::MAX_NOTE_PACKED_LEN,\n        },\n        processing::{\n            log_retrieval_request::LogRetrievalRequest,\n            log_retrieval_response::LogRetrievalResponse,\n            note_validation_request::NoteValidationRequest, pending_tagged_log::PendingTaggedLog,\n        },\n    },\n    oracle,\n};\nuse event_validation_request::EventValidationRequest;\nuse protocol_types::{address::AztecAddress, hash::sha256_to_field};\n\n// Base slot for the pending tagged log array to which the fetch_tagged_logs oracle inserts found private logs.\nglobal PENDING_TAGGED_LOG_ARRAY_BASE_SLOT: Field =\n    sha256_to_field(\"AZTEC_NR::PENDING_TAGGED_LOG_ARRAY_BASE_SLOT\".as_bytes());\n\nglobal NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\n/// Searches for private logs emitted by `contract_address` that might contain messages for one of the local accounts,\n/// and stores them in a `CapsuleArray` which is then returned.\npub(crate) unconstrained fn get_private_logs(\n    contract_address: AztecAddress,\n) -> CapsuleArray<PendingTaggedLog> {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `fetchTaggedLogs`\n    // oracle. This makes PXE synchronize tags, download logs and store the pending tagged logs in a capsule array.\n    oracle::message_processing::fetch_tagged_logs(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    CapsuleArray::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT)\n}\n\n/// Enqueues a note for validation by PXE, so that it becomes aware of a note's existence allowing for later retrieval\n/// via `get_notes` oracle. The note will be scoped to `contract_address`, meaning other contracts will not be able to\n/// access it unless authorized.\n///\n/// In order for the note validation and insertion to occur, `validate_enqueued_notes_and_events` must be later called.\n/// For optimal performance, accumulate as many note validation requests as possible and then validate them all at the\n/// end (which results in PXE minimizing the number of network round-trips).\n///\n/// The `packed_note` is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\npub(crate) unconstrained fn enqueue_note_for_validation(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `NoteValidationRequest`\n    CapsuleArray::at(contract_address, NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        NoteValidationRequest {\n            contract_address,\n            storage_slot,\n            note_nonce,\n            packed_note,\n            note_hash,\n            nullifier,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Enqueues an event for validation by PXE, so that it can be efficiently validated and then inserted into the event\n/// store.\n///\n/// In order for the event validation and insertion to occur, `validate_enqueued_notes_and_events` must be later\n/// called. For optimal performance, accumulate as many event validation requests as possible and then validate them\n/// all at the end (which results in PXE minimizing the number of network round-trips).\npub(crate) unconstrained fn enqueue_event_for_validation(\n    contract_address: AztecAddress,\n    event_type_id: EventSelector,\n    serialized_event: BoundedVec<Field, MAX_EVENT_SERIALIZED_LEN>,\n    event_commitment: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `EventValidationRequest`\n    CapsuleArray::at(contract_address, EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        EventValidationRequest {\n            contract_address,\n            event_type_id,\n            serialized_event,\n            event_commitment,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Validates all note and event validation requests enqueued via `enqueue_note_for_validation` and\n/// `enqueue_event_for_validation`, inserting them into the note database and event store respectively, making them\n/// queryable via `get_notes` oracle and our TS API (PXE::getPrivateEvents).\n///\n/// This automatically clears both validation request queues, so no further work needs to be done by the caller.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(contract_address: AztecAddress) {\n    oracle::message_processing::validate_enqueued_notes_and_events(\n        contract_address,\n        NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n        EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n    );\n}\n\n/// Efficiently queries the node for logs that result in the completion of all `DeliveredPendingPartialNote`s stored in\n/// a `CapsuleArray` by performing all node communication concurrently. Returns a second `CapsuleArray` with Options for\n/// the responses that correspond to the pending partial notes at the same index.\n///\n/// For example, given an array with pending partial notes `[ p1, p2, p3 ]`, where `p1` and `p3` have corresponding\n/// completion logs but `p2` does not, the returned `CapsuleArray` will have contents\n/// `[some(p1_log), none(), some(p3_log)]`.\npub(crate) unconstrained fn get_pending_partial_notes_completion_logs(\n    contract_address: AztecAddress,\n    pending_partial_notes: CapsuleArray<DeliveredPendingPartialNote>,\n) -> CapsuleArray<Option<LogRetrievalResponse>> {\n    let log_retrieval_requests =\n        CapsuleArray::at(contract_address, LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT);\n\n    // We create a LogRetrievalRequest for each PendingPartialNote in the CapsuleArray. Because we need the indices in\n    // the request array to match the indices in the partial note array, we can't use CapsuleArray::for_each, as that\n    // function has arbitrary iteration order. Instead, we manually iterate the array from the beginning and push into\n    // the requests array, which we expect to be empty.\n    let mut i = 0;\n    let pending_partial_notes_count = pending_partial_notes.len();\n    while i < pending_partial_notes_count {\n        let pending_partial_note = pending_partial_notes.get(i);\n        log_retrieval_requests.push(\n            LogRetrievalRequest {\n                contract_address,\n                unsiloed_tag: pending_partial_note.note_completion_log_tag,\n            },\n        );\n        i += 1;\n    }\n\n    oracle::message_processing::bulk_retrieve_logs(\n        contract_address,\n        LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT,\n        LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT,\n    );\n\n    CapsuleArray::at(contract_address, LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT)\n}\n"
    },
    "149": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::{Deserialize, Packable, Serialize};\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, note_nonce: Field },\n//   Settled{ note_nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Deserialize, Eq, Serialize, Packable)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_note_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_note_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_note_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_note_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_note_nonce }\n            }\n        } else if maybe_note_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_note_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_note_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_note_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.note_nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.note_nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    note_nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    note_nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n"
    },
    "152": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().note_nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullification<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullification_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullification`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullification_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let note_nonce = retrieved_note.metadata.to_pending_previous_phase().note_nonce();\n\n        compute_unique_note_hash(note_nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullification =\n        compute_note_hash_for_nullification(retrieved_note, storage_slot);\n    let inner_nullifier =\n        retrieved_note.note.compute_nullifier(context, note_hash_for_nullification);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "156": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(privateCallPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "157": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize,\n{\n    let serialized_option = load_oracle(contract_address, slot, <T as Deserialize>::N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(utilityStoreCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(utilityLoadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(utilityDeleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(utilityCopyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), value);\n        });\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            let new_value = MockStruct::new(7, 8);\n            store(contract_address, SLOT, new_value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n        });\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n            delete(contract_address, SLOT);\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            delete(contract_address, SLOT);\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 5;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 10;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 1;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 2;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n            assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n            assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 2;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 1;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n            assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n            assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n        });\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            copy(contract_address, SLOT, SLOT, 1);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let value = MockStruct::new(5, 6);\n            store(other_contract_address, SLOT, value);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let _: Option<MockStruct> = load(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            delete(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            copy(other_contract_address, SLOT, SLOT, 0);\n        });\n    }\n}\n"
    },
    "158": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(privateNotifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(privateNotifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(privateNotifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "159": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use crate::context::utility_context::UtilityContext;\n\n#[oracle(utilityGetUtilityContext)]\nunconstrained fn get_utility_context_oracle() -> UtilityContext {}\n\n/// Returns a utility context built from the global variables of anchor block and the contract address of the function\n/// being executed.\npub unconstrained fn get_utility_context() -> UtilityContext {\n    get_utility_context_oracle()\n}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars, true)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n    predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        let mut result = if double_predicate {\n            // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n            embedded_curve_add_unsafe(point1, point1)\n        } else {\n            let point1_1 = EmbeddedCurvePoint {\n                x: point1.x + (x_coordinates_match as Field),\n                y: point1.y,\n                is_infinite: false,\n            };\n            let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n            // point1_1 is guaranteed to have a different abscissa than point2:\n            // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n            // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n            // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n            // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n            // therefore we only want to do this if we need the result, otherwise it needs to be eliminated as a dead instruction, lest we want the circuit to fail.\n            embedded_curve_add_unsafe(point1_1, point2_1)\n        };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n    _predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    // Ensure is_infinite is comptime\n    let point1_1 = EmbeddedCurvePoint { x: point1.x, y: point1.y, is_infinite: false };\n    let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n    embedded_curve_add_unsafe(point1_1, point2_1)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2, true)[0]\n}\n"
    },
    "160": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(privateStoreInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(privateLoadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "161": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(utilityGetContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\nstruct GetContractInstanceResult {\n    exists: bool,\n    member: Field,\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n\nunconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_deployer_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_class_id_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_deployer_internal_avm(address)[0] };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_class_id_internal_avm(address)[0] };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address)[0] };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "165": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr",
      "source": "use protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\nuse protocol_types::traits::{Deserialize, Serialize};\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(utilityGetPublicDataWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> PublicDataWitness {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    get_public_data_witness_oracle(block_number, public_data_tree_index)\n}\n"
    },
    "166": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(utilityGetKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "167": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(utilityGetPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] != 0 } },\n        ivpk_m: IvpkM { inner: Point { x: result[3], y: result[4], is_infinite: result[5] != 0 } },\n        ovpk_m: OvpkM { inner: Point { x: result[6], y: result[7], is_infinite: result[8] != 0 } },\n        tpk_m: TpkM { inner: Point { x: result[9], y: result[10], is_infinite: result[11] != 0 } },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "169": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/message_processing.nr",
      "source": "use protocol_types::address::AztecAddress;\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn fetch_tagged_logs(pending_tagged_log_array_base_slot: Field) {\n    fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(utilityFetchTaggedLogs)]\nunconstrained fn fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n// This must be a single oracle and not one for notes and one for events because the entire point is to validate\n// all notes and events in one go, minimizing node round-trips.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {\n    validate_enqueued_notes_and_events_oracle(\n        contract_address,\n        note_validation_requests_array_base_slot,\n        event_validation_requests_array_base_slot,\n    );\n}\n\n#[oracle(utilityValidateEnqueuedNotesAndEvents)]\nunconstrained fn validate_enqueued_notes_and_events_oracle(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {}\n\npub(crate) unconstrained fn bulk_retrieve_logs(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {\n    bulk_retrieve_logs_oracle(\n        contract_address,\n        log_retrieval_requests_array_base_slot,\n        log_retrieval_responses_array_base_slot,\n    );\n}\n\n#[oracle(utilityBulkRetrieveLogs)]\nunconstrained fn bulk_retrieve_logs_oracle(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n\n    #[test]\n    fn check_decompose_edge_cases() {\n        assert_eq(decompose(0), (0, 0));\n        assert_eq(decompose(TWO_POW_128 - 1), (TWO_POW_128 - 1, 0));\n        assert_eq(decompose(TWO_POW_128 + 1), (1, 1));\n        assert_eq(decompose(TWO_POW_128 * 2), (0, 2));\n        assert_eq(decompose(TWO_POW_128 * 2 + 0x1234567890), (0x1234567890, 2));\n    }\n\n    #[test]\n    fn check_decompose_large_values() {\n        let large_field = 0xffffffffffffffff;\n        let (lo, hi) = decompose(large_field);\n        assert_eq(large_field, lo + TWO_POW_128 * hi);\n\n        let large_value = large_field - TWO_POW_128;\n        let (lo2, hi2) = decompose(large_value);\n        assert_eq(large_value, lo2 + TWO_POW_128 * hi2);\n    }\n\n    #[test]\n    fn check_lt_comprehensive() {\n        assert(lt(0, 1));\n        assert(!lt(1, 0));\n        assert(!lt(0, 0));\n        assert(!lt(42, 42));\n\n        assert(lt(TWO_POW_128 - 1, TWO_POW_128));\n        assert(!lt(TWO_POW_128, TWO_POW_128 - 1));\n    }\n}\n"
    },
    "171": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::note::{note_interface::NoteType, retrieved_note::RetrievedNote};\n\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(privateNotifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(privateNotifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(privateNotifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(utilityGetNotes)]\nunconstrained fn get_notes_oracle<Note, let M: u32, let MaxNotes: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; M],\n    _select_by_offsets: [u8; M],\n    _select_by_lengths: [u8; M],\n    _select_values: [Field; M],\n    _select_comparators: [u8; M],\n    _sort_by_indexes: [u8; M],\n    _sort_by_offsets: [u8; M],\n    _sort_by_lengths: [u8; M],\n    _sort_order: [u8; M],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    // This is always set to MAX_NOTES. We need to pass it to TS in order to correctly construct the BoundedVec\n    _max_notes: u32,\n    // This is always set to <RetrievedNote<Note> as Packable>::N. We need to pass it to TS in order to be able to\n    // correctly construct the BoundedVec there.\n    _packed_retrieved_note_length: u32,\n) -> BoundedVec<[Field; <RetrievedNote<Note> as Packable>::N], MaxNotes>\nwhere\n    // TODO(https://github.com/noir-lang/noir/issues/9399): `Note: Packable` should work here.\n    RetrievedNote<Note>: Packable,\n{}\n\npub unconstrained fn get_notes<Note, let M: u32, let MaxNotes: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Option<RetrievedNote<Note>>; MaxNotes]\nwhere\n    Note: NoteType + Packable,\n{\n    let packed_retrieved_notes: BoundedVec<[Field; <RetrievedNote<Note> as Packable>::N], MaxNotes>\n         = get_notes_oracle::<Note, M, MaxNotes>(\n            storage_slot,\n            num_selects,\n            select_by_indexes,\n            select_by_offsets,\n            select_by_lengths,\n            select_values,\n            select_comparators,\n            sort_by_indexes,\n            sort_by_offsets,\n            sort_by_lengths,\n            sort_order,\n            limit,\n            offset,\n            status,\n            MaxNotes,\n            <RetrievedNote<Note> as Packable>::N,\n        );\n\n    let mut notes = BoundedVec::<_, MaxNotes>::new();\n    for i in 0..packed_retrieved_notes.len() {\n        let retrieved_note = RetrievedNote::unpack(packed_retrieved_notes.get(i));\n        notes.push(retrieved_note);\n    }\n\n    // At last we convert the bounded vector to an array of options. We do this because that is what the filter\n    // function needs to have on the output and we've decided to have the same type on the input and output of\n    // the filter and preprocessor functions.\n    //\n    // We have decided to have the same type on the input and output of the filter and preprocessor functions because\n    // it allows us to chain multiple filters and preprocessors together.\n    //\n    // So why do we want the array of options on the output of the filter function?\n    //\n    // Filter returns an array of options rather than a BoundedVec for performance reasons. Using an array of options\n    // allows setting values at known indices in the output array which is much more efficient than pushing to a\n    // BoundedVec where the write position depends on previous iterations. The array can then be efficiently converted\n    // to a BoundedVec using utils/array/collapse.nr::collapse function from Aztec.nr. This avoids expensive dynamic\n    // memory access patterns that would be required when building up a BoundedVec incrementally. For preprocessor\n    // functions we could use BoundedVec return value as there the optimization does not matter since it is applied in\n    // an unconstrained context. We, however, use the same return value type to be able to use the same function as\n    // both a preprocessor and a filter.\n    let mut notes_array = [Option::none(); MaxNotes];\n    for i in 0..notes.len() {\n        if i < notes.len() {\n            notes_array[i] = Option::some(notes.get_unchecked(i));\n        }\n    }\n\n    notes_array\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(utilityCheckNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n// TODO: Oracles below are generic private log oracles and are not specific to notes. Move them somewhere else.\n\n/// Returns the next app tag for a given sender and recipient pair.\n///\n/// This also notifies the simulator that a tag has been used in a note, and to therefore increment the\n/// associated index so that future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub unconstrained fn get_next_app_tag_as_sender(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> Field {\n    get_next_app_tag_as_sender_oracle(sender, recipient)\n}\n\n#[oracle(privateGetNextAppTagAsSender)]\nunconstrained fn get_next_app_tag_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> Field {}\n\n/// Gets the sender for tags.\n///\n/// This unconstrained value is used as the sender when computing an unconstrained shared secret\n/// for a tag in order to emit a log. Constrained tagging should not use this as there is no\n/// guarantee that the recipient knows about the sender, and hence about the shared secret.\n///\n/// The value persists through nested calls, meaning all calls down the stack will use the same\n/// 'senderForTags' value (unless it is replaced).\npub unconstrained fn get_sender_for_tags() -> Option<AztecAddress> {\n    get_sender_for_tags_oracle()\n}\n\n#[oracle(privateGetSenderForTags)]\nunconstrained fn get_sender_for_tags_oracle() -> Option<AztecAddress> {}\n\n/// Sets the sender for tags.\n///\n/// This unconstrained value is used as the sender when computing an unconstrained shared secret\n/// for a tag in order to emit a log. Constrained tagging should not use this as there is no\n/// guarantee that the recipient knows about the sender, and hence about the shared secret.\n///\n/// Account contracts typically set this value before calling other contracts. The value persists\n/// through nested calls, meaning all calls down the stack will use the same 'senderForTags'\n/// value (unless it is replaced by another call to this setter).\npub unconstrained fn set_sender_for_tags(sender_for_tags: AztecAddress) {\n    set_sender_for_tags_oracle(sender_for_tags);\n}\n\n#[oracle(privateSetSenderForTags)]\nunconstrained fn set_sender_for_tags_oracle(_sender_for_tags: AztecAddress) {}\n"
    },
    "174": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(utilityGetSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "175": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(utilityStorageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: u32,\n    length: u32,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(address.to_field(), storage_slot, block_number, N)\n}\n\npub unconstrained fn storage_read<T>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"utilityStorageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"utilityStorageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"
    },
    "176": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/version.nr",
      "source": "/// The ORACLE_VERSION constant is used to check that the oracle interface is in sync between PXE and Aztec.nr. We need\n/// to version the oracle interface to ensure that developers get a reasonable error message if they use incompatible\n/// versions of Aztec.nr and PXE. The TypeScript counterpart is in `oracle_version.ts`.\n///\n/// @dev Whenever a contract function or Noir test is run, the `utilityAssertCompatibleOracleVersion` oracle is called and\n/// if the oracle version is incompatible an error is thrown.\npub global ORACLE_VERSION: Field = 3;\n\n/// Asserts that the version of the oracle is compatible with the version expected by the contract.\npub fn assert_compatible_oracle_version() {\n    // Safety: This oracle call returns nothing: we only call it to check Aztec.nr and Oracle interface versions are\n    // compatible. It is therefore always safe to call.\n    unsafe {\n        assert_compatible_oracle_version_wrapper();\n    }\n}\n\nunconstrained fn assert_compatible_oracle_version_wrapper() {\n    assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n}\n\n#[oracle(utilityAssertCompatibleOracleVersion)]\nunconstrained fn assert_compatible_oracle_version_oracle(version: Field) {}\n\nmod test {\n    use super::{assert_compatible_oracle_version_oracle, ORACLE_VERSION};\n\n    #[test]\n    unconstrained fn compatible_oracle_version() {\n        assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n    }\n\n    #[test(should_fail_with = \"Incompatible oracle version. TXE is using version '3', but got a request for '318183437'.\")]\n    unconstrained fn incompatible_oracle_version() {\n        let arbitrary_incorrect_version = 318183437;\n        assert_compatible_oracle_version_oracle(arbitrary_incorrect_version);\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n"
    },
    "180": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::HasStorageSlot;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\n\n/// Map\n///\n/// A key-value storage container that maps keys to state variables, similar\n/// to Solidity mappings.\n///\n/// `Map` enables you to associate keys (like addresses or other identifiers)\n/// with state variables in your Aztec smart contract. This is conceptually\n/// similar to Solidity's `mapping(K => V)` syntax, where you can store and\n/// retrieve values by their associated keys.\n///\n/// You can declare a state variable contained within a Map in your contract's\n/// #[storage] struct.\n///\n/// For example, you might use\n/// `Map<AztecAddress, PrivateMutable<ValueNote, Context>, Context>` to track\n/// token balances for different users, similar to how you'd use\n/// `mapping(address => uint256)` in Solidity.\n///\n/// > Aside: the verbose `Context` in the declaration is a consequence of\n/// > leveraging Noir's regular syntax for generics to ensure that certain\n/// > state variable methods can only be called in some contexts (private,\n/// > public, utility).\n///\n/// The methods of Map are:\n/// - `at` (access state variable for a given key)\n/// (see the method's own doc comments for more info).\n///\n/// ## Generic Parameters\n/// - `K`: The key type (must implement `ToField` trait for hashing)\n/// - `V`: The value type:\n///   - any Aztec state variable:\n///     - `PublicMutable`\n///     - `PublicImmutable`\n///     - `PrivateMutable`\n///     - `PrivateImmutable`\n///     - `PrivateSet`\n///     - `DelayedPublicMutable`\n///     - `Map`\n/// - `Context`: The execution context (handles private/public function\n///   contexts)\n///\n/// ## Usage\n/// Maps are typically declared in your contract's #[storage] struct and\n/// accessed\n/// using the `at(key)` method to get the state variable for a specific key.\n/// The resulting state variable can then be read from or written to using its\n/// own methods.\n///\n/// ## Advanced\n/// Internally, `Map` uses a single base storage slot to represent the\n/// mapping\n/// itself, similar to Solidity's approach. Individual key-value pairs are\n/// stored at derived storage slots computed by hashing the base storage\n/// slot\n/// with the key using Poseidon2. This ensures:\n/// - No storage slot collisions between different keys\n/// - Uniform distribution of storage slots across the storage space\n/// - Compatibility with Aztec's storage tree structure\n/// - Gas-efficient storage access patterns similar to Solidity mappings\n///\n/// The storage slot derivation uses `derive_storage_slot_in_map(base_slot,\n/// key)` which computes `poseidon2_hash([base_slot, key.to_field()])`,\n/// ensuring cryptographically secure slot separation.\n///\n/// docs:start:map\npub struct Map<K, V, Context> {\n    pub context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n\n// Map reserves a single storage slot regardless of what it stores because\n// nothing is stored at said slot: it is only used to derive the storage slots\n// of nested state variables, which is expected to never result in collisions\n// or slots being close to one another due to these being hashes. This mirrors\n// the strategy adopted by Solidity mappings.\nimpl<K, T, Context> HasStorageSlot<1> for Map<K, T, Context> {\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    /// Initializes a new Map state variable.\n    ///\n    /// This function is usually automatically called within the #[storage]\n    /// macro.\n    /// You typically don't need to call this directly when writing smart contracts.\n    ///\n    /// # Arguments\n    ///\n    /// * `context` - One of `PrivateContext`/`PublicContext`/`UtilityContext`.\n    ///               The Context determines which methods of this struct will\n    ///               be made available to the calling smart contract function.\n    /// * `storage_slot` - A unique identifier for this Map within the contract.\n    ///                    Usually, the #[storage] macro will determine an\n    ///                    appropriate storage_slot automatically. A smart\n    ///                    contract dev shouldn't have to worry about this, as\n    ///                    it's managed behind the scenes.\n    /// * `state_var_constructor` - A function that creates the value type (V)\n    ///                             given a context and storage slot. This is\n    ///                             typically the constructor of the state\n    ///                             variable type being stored in the Map.\n    ///\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n\n    /// Returns the state variable associated with the given key.\n    ///\n    /// This is equivalent to accessing `mapping[key]` in Solidity. It returns\n    /// the state variable instance for the specified key, which can then be\n    /// used to read or write the value at that key.\n    ///\n    /// Unlike Solidity mappings which return the value directly, this returns\n    /// the state variable wrapper (like PrivateMutable, PublicMutable, etc.)\n    /// that you then call methods on to interact with the actual value.\n    ///\n    /// # Arguments\n    ///\n    /// * `key` - The key to look up in the map. Must implement the ToField\n    ///           trait (which most basic Noir & Aztec types do).\n    ///\n    /// # Returns\n    ///\n    /// * `V` - The state variable instance for this key. You can then call\n    ///         methods like `.read()`, `.write()`, `.get_note()`, etc. on this\n    ///         depending on the specific state variable type.\n    ///\n    /// # Example\n    ///\n    /// ```noir\n    /// // Get a user's balance (assuming PrivateMutable<ValueNote>)\n    /// let user_balance = storage.balances.at(user_address);\n    /// let current_note = user_balance.get_note();\n    ///\n    /// // Update the balance\n    /// user_balance.replace(new_note);\n    /// ```\n    ///\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n}\n"
    },
    "188": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr",
      "source": "use crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::storage::HasStorageSlot,\n    utils::with_hash::WithHash,\n};\nuse protocol_types::{\n    constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator,\n    traits::Packable,\n};\n\n/// # PublicImmutable\n///\n/// PublicImmutable is a public state variable type for values that are set once\n/// during initialization and remain permanently unchanged.\n///\n/// You can declare a state variable of type PublicImmutable within your contract's\n/// #[storage] struct:\n///\n/// E.g.:\n/// `your_variable: PublicImmutable<T, Context>`\n///\n/// PublicImmutable stores an immutable value in public state which can be _read_\n/// from public, utility and even _private_ execution contexts.\n///\n/// The methods of PublicImmutable are:\n/// - `initialize`\n/// - `read`\n/// (see the methods' own doc comments for more info).\n///\n/// # Generic Parameters:\n///\n/// * `T` - The type of value stored (must implement Packable).\n/// * `Context` - The execution context (PublicContext, PrivateContext, or UtilityContext).\n///\n/// # Advanced\n///\n/// PublicImmutable leverages `WithHash<T>` to enable efficient private reads of\n/// public storage. The `WithHash` wrapper optimizes reads by hashing values that would\n/// be larger than a single field into a single field, then proving inclusion of only\n/// the hash in public storage.\n///\n/// This optimization is particularly valuable when T packs to multiple fields,\n/// as it maintains \"almost constant\" verification overhead regardless of the\n/// original data size.\n///\n/// ## Optimizing private reads in your contract\n/// Since reading T from public immutable storage in private contexts has \"almost\n/// constant\" constraint costs regardless of T's size, it's recommended to group\n/// multiple values into a single struct when they are to be read together. This is\n/// typically useful for configuration data set during contract initialization. E.g.:\n///\n/// ```noir\n/// use dep::aztec::protocol_types::{address::AztecAddress, traits::Packable};\n/// use std::meta::derive;\n///\n/// #[derive(Eq, Packable)]\n/// pub struct Config \\{\n///     pub address_1: AztecAddress,\n///     pub value_1: u128,\n///     pub value_2: u64,\n///     ...\n/// }\n/// ```\n///\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\n/// `PublicImmutable` stores both the packed value (using M fields) and its hash (1 field), requiring M + 1 total\n/// fields.\nimpl<T, Context, let M: u32> HasStorageSlot<M + 1> for PublicImmutable<T, Context>\nwhere\n    T: Packable<N = M>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    /// Initializes a new PublicImmutable state variable.\n    ///\n    /// This function is usually automatically called within the #[storage] macro.\n    /// You typically don't need to call this directly when writing smart contracts.\n    ///\n    /// # Arguments\n    ///\n    /// * `context` - One of `PublicContext`/`PrivateContext`/`UtilityContext`. The\n    ///               Context determines which methods of this struct will be made\n    ///               available to the calling smart contract function.\n    /// * `storage_slot` - A unique identifier for this state variable within the\n    ///                    contract. Usually, the #[storage] macro will determine an\n    ///                    appropriate storage_slot automatically. A smart contract\n    ///                    dev shouldn't have to worry about this, as it's managed\n    ///                    behind the scenes.\n    ///\n    /// docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n        )\n    }\n}\n\nimpl<T> PublicImmutable<T, &mut PublicContext> {\n    /// Initializes a PublicImmutable state variable instance with a permanent value.\n    ///\n    /// This function sets the immutable value for this state variable. It can only\n    /// be called once per PublicImmutable. Subsequent calls will fail because the\n    /// initialization nullifier will already exist.\n    ///\n    /// # Arguments\n    /// * `value` - The permanent value to store in this PublicImmutable.\n    ///\n    /// # Panics\n    /// Panics if the value is already initialized.\n    ///\n    /// # Advanced\n    ///\n    /// This function performs the following operations:\n    /// - Creates and emits an initialization nullifier to mark this storage slot\n    ///   as initialized. This prevents double-initialization.\n    /// - Wraps the value in `WithHash<T>` for efficient private reads.\n    /// - Stores the wrapped value in Aztec's public data tree.\n    ///\n    /// docs:start:public_immutable_struct_write\n    pub fn initialize(self, value: T)\n    where\n        T: Packable + Eq,\n    {\n        // We emit an initialization nullifier to indicate that the struct is initialized. This also prevents\n        // the value from being initialized again as a nullifier can be included only once.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        self.context.storage_write(self.storage_slot, WithHash::new(value));\n    }\n\n    /// Reads the permanent value stored in this PublicImmutable state variable.\n    ///\n    /// # Returns\n    /// * `T` - The permanent value stored in this PublicImmutable.\n    ///\n    /// # Panics\n    /// Panics if the value is not initialized.\n    ///\n    /// # Advanced\n    ///\n    /// This function performs the following operations:\n    /// - Checks that the state variable has been initialized by verifying the\n    ///   initialization nullifier exists\n    /// - Reads the `WithHash<T>` wrapper from public storage\n    /// - Extracts and returns the original value T\n    ///\n    /// The function will panic if called on an uninitialized PublicImmutable.\n    ///\n    /// docs:start:public_immutable_struct_read\n    pub fn read(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        assert(self.is_initialized(), \"Trying to read from uninitialized PublicImmutable\");\n        WithHash::public_storage_read(*self.context, self.storage_slot)\n    }\n\n    /// Reads the value stored in this PublicImmutable without checking if the value\n    /// is initialized.\n    ///\n    /// This function bypasses the initialization check and directly reads from\n    /// storage.\n    /// If the PublicImmutable has not been initialized, this will return a\n    /// zeroed value.\n    /// However, if the variable is _known_ to be initialized, this is cheaper\n    /// to call than `read`.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The value stored in this PublicImmutable, or empty/default values if\n    ///         uninitialized.\n    ///\n    pub fn read_unsafe(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        WithHash::public_storage_read(*self.context, self.storage_slot)\n    }\n\n    fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.nullifier_exists(nullifier, self.context.this_address())\n    }\n}\n\nimpl<T> PublicImmutable<T, UtilityContext> {\n    /// Reads the permanent value stored in this PublicImmutable state variable.\n    ///\n    /// Notice that this function is executable only within a UtilityContext, which\n    /// is an unconstrained environment on the user's local device.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The permanent value stored in this PublicImmutable.\n    ///\n    pub unconstrained fn read(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        // TODO(#15703): this fn should fail if the variable is not initialized\n        WithHash::utility_public_storage_read(self.context, self.storage_slot)\n    }\n}\n\nimpl<T> PublicImmutable<T, &mut PrivateContext> {\n    /// Reads the permanent value stored in this PublicImmutable from the anchor\n    /// block.\n    ///\n    /// Private functions execute asynchronously and offchain. When a user begins\n    /// private execution, their view of the chain 'branches off' from the current\n    /// public state, since public state continues to advance while they execute\n    /// privately. Therefore, private functions read from a historical snapshot of\n    /// public state rather than the current state.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The permanent value stored in this PublicImmutable at the historical\n    ///         block referenced by the private context.\n    ///\n    /// # Advanced\n    ///\n    /// This function performs a historical read using the block header from the private\n    /// context. The `WithHash` optimization is particularly valuable here because it\n    /// reduces the number of required inclusion proofs by proving membership of\n    /// only the hash instead of the full packed value.\n    ///\n    /// The historical read mechanism:\n    /// - Uses an oracle to obtain the value from the anchor block\n    /// - Proves inclusion of the value's hash in the public data tree\n    /// - Proves that the root of this public data tree is correct, relative to the\n    ///   anchor block header.\n    /// - Verifies that the oracle-provided value matches the stored hash\n    ///\n    pub fn read(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        // TODO(#15703): this fn should fail if the variable is not initialized\n        WithHash::historical_public_storage_read(\n            self.context.get_anchor_block_header(),\n            self.context.this_address(),\n            self.storage_slot,\n        )\n    }\n}\n"
    },
    "19": {
      "path": "std/hash/mod.nr",
      "source": "// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"
    },
    "190": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr",
      "source": "use crate::context::{PublicContext, UtilityContext};\nuse crate::state_vars::storage::HasStorageSlot;\nuse dep::protocol_types::traits::Packable;\n\n/// # PublicMutable\n///\n/// PublicMutable is a public state variable type for values that can be read\n/// and written within #[external(\"public\")] functions of your smart contract.\n///\n/// You can declare a state variable of type PublicMutable within your contract's\n/// #[storage] struct:\n///\n/// E.g.:\n/// `your_variable: PublicMutable<T, Context>`\n/// or:\n/// `your_mapping: Map<Field, PublicMutable<T, Context>>`\n///\n/// The methods of PublicMutable are:\n/// - `read`\n/// - `write`\n/// (see the methods' own doc comments for more info).\n///\n/// ## Example.\n///\n/// A voting contract's proposal count can be represented as a PublicMutable<u64>.\n/// The count can be read by anyone to see how many proposals exist, and incremented\n/// when new proposals are submitted.\n///\n/// # Generic Parameters:\n///\n/// * `T` - The type of value stored (must implement Packable).\n/// * `Context` - The execution context (PublicContext or UtilityContext).\n///\n/// # Advanced\n///\n/// Unlike private state variables which use notes, PublicMutable stores values\n/// directly in Aztec's public data tree. This enables direct read and write\n/// access to the current state during public function execution.\n///\n/// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\nimpl<T, Context, let M: u32> HasStorageSlot<M> for PublicMutable<T, Context>\nwhere\n    T: Packable<N = M>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    /// Initializes a new PublicMutable state variable.\n    ///\n    /// This function is usually automatically called within the #[storage] macro.\n    /// You typically don't need to call this directly when writing smart contracts.\n    ///\n    /// # Arguments\n    ///\n    /// * `context` - One of `PublicContext`/`UtilityContext`. The Context determines\n    ///               which methods of this struct will be made available to the calling\n    ///               smart contract function.\n    /// * `storage_slot` - A unique identifier for this state variable within the\n    ///                    contract. Usually, the #[storage] macro will determine an\n    ///                    appropriate storage_slot automatically. A smart contract\n    ///                    dev shouldn't have to worry about this, as it's managed\n    ///                    behind the scenes.\n    ///\n    /// docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n}\n\nimpl<T> PublicMutable<T, &mut PublicContext> {\n    /// Reads the current value stored in this PublicMutable state variable.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The current value stored in this PublicMutable.\n    ///\n    /// docs:start:public_mutable_struct_read\n    pub fn read(self) -> T\n    where\n        T: Packable,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n\n    /// Writes a new value to this PublicMutable state variable.\n    ///\n    /// # Arguments\n    ///\n    /// * `value` - The new value to store in this PublicMutable.\n    ///\n    /// # Advanced\n    ///\n    /// This function updates the value stored in Aztec's public data tree.\n    /// The new value becomes immediately available to subsequent reads within\n    /// the same transaction.\n    ///\n    /// docs:start:public_mutable_struct_write\n    pub fn write(self, value: T)\n    where\n        T: Packable,\n    {\n        self.context.storage_write(self.storage_slot, value);\n    }\n}\n\nimpl<T> PublicMutable<T, UtilityContext> {\n    /// Reads the current value stored in this PublicMutable state variable.\n    ///\n    /// Notice that this function is executable only within a UtilityContext, which\n    /// is an unconstrained environment on the user's local device.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The current value stored in this PublicMutable.\n    ///\n    pub unconstrained fn read(self) -> T\n    where\n        T: Packable,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"
    },
    "210": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends the elements of the second `BoundedVec` to the end of the first one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let ALen: u32, let BLen: u32, let DstLen: u32>(\n    a: BoundedVec<T, ALen>,\n    b: BoundedVec<T, BLen>,\n) -> BoundedVec<T, DstLen> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "213": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DstLen` elements from a source array, starting at `offset`. `DstLen` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SrcLen: u32, let DstLen: u32>(src: [T; SrcLen], offset: u32) -> [T; DstLen] {\n    assert(offset + DstLen <= SrcLen, \"DstLen too large for offset\");\n\n    let mut dst: [T; DstLen] = std::mem::zeroed();\n    for i in 0..DstLen {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DstLen to be 0, so we always get back an empty array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "214": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DstMaxLen` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DstLen` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DstLen` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SrcMaxLen: u32, let DstMaxLen: u32>(\n    bvec: BoundedVec<T, SrcMaxLen>,\n    offset: u32,\n) -> BoundedVec<T, DstMaxLen> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "216": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "217": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "220": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use protocol_types::{point::Point, utils::field::sqrt};\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\n/// Returns a `Point` in the Grumpkin curve given its x coordinate.\n///\n/// Because not all values in the field are valid x coordinates of points in the curve (i.e. there\n/// is no corresponding y value in the field that satisfies the curve equation), it may not be\n/// possible to reconstruct a `Point`. `Option::none()` is returned in such cases.\npub fn point_from_x_coord(x: Field) -> Option<Point> {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    sqrt(rhs).map(|y| Point { x, y, is_infinite: false })\n}\n\n/// Returns a `Point` in the Grumpkin curve given its x coordinate and sign for the y coordinate.\n///\n/// Because not all values in the field are valid x coordinates of points in the curve (i.e. there\n/// is no corresponding y value in the field that satisfies the curve equation), it may not be\n/// possible to reconstruct a `Point`. `Option::none()` is returned in such cases.\n///\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Option<Point> {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n\n    sqrt(rhs).map(|y| {\n        // If there is a square root, we need to ensure it has the correct \"sign\"\n        let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n        let final_y = if y_is_positive == sign { y } else { -y };\n        Point { x, y: final_y, is_infinite: false }\n    })\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord, point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n    use dep::protocol_types::utils::field::pow;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign).unwrap();\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2).unwrap();\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_valid() {\n        // x = 8 is a known quadratic residue - should give a valid point\n        let result = point_from_x_coord(Field::from(8));\n        assert(result.is_some());\n\n        let point = result.unwrap();\n        assert_eq(point.x, Field::from(8));\n        // Check curve equation y^2 = x^3 - 17\n        assert_eq(pow(point.y, 2), pow(point.x, 3) - 17);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_invalid() {\n        // x = 3 is a non-residue for this curve - should give None\n        let x = Field::from(3);\n        let maybe_point = point_from_x_coord(x);\n        assert(maybe_point.is_none());\n    }\n\n}\n"
    },
    "224": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr",
      "source": "use crate::{\n    context::{PublicContext, UtilityContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    abis::block_header::BlockHeader, address::AztecAddress, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `M` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `M`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let M: u32> {\n    value: T,\n    packed: [Field; M],\n    hash: Field,\n}\n\nimpl<T, let M: u32> WithHash<T, M>\nwhere\n    T: Packable<N = M> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn utility_public_storage_read(\n        context: UtilityContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + M as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\n// Note: I don't derive Packable on `WithHash` because `derive_serialize` function does not support setting \"N = M\"\n// as I do here 3 lines below. This could be worked around by placing the \"where\" clause directly on the `WithHash`\n// struct, but Jake mentioned that the syntax is not expected to be supported at least until Noir 1.0.\n// Relevant discussion on Slack:\n// https://aztecprotocol.slack.com/archives/C04QF64EDNV/p1752593876160699?thread_ts=1752589887.955379&cid=C04QF64EDNV\nimpl<T, let M: u32> Packable for WithHash<T, M>\nwhere\n    T: Packable<N = M>,\n{\n    let N: u32 = M + 1;\n\n    fn pack(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n        for i in 0..M {\n            result[i] = self.packed[i];\n        }\n        result[M] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; Self::N]) -> Self {\n        let mut value_packed = [0; M];\n        for i in 0..M {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[M];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::test::OracleMock;\n\n    global STORAGE_SLOT: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let env = TestEnvironment::new();\n\n        env.private_context(|context| {\n            let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n                context.anchor_block_header,\n                context.this_address(),\n                STORAGE_SLOT,\n            );\n\n            assert_eq(result, std::mem::zeroed());\n        });\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        env.public_context(|context| { context.storage_write(STORAGE_SLOT, value_with_hash); });\n\n        env.private_context(|context| {\n            let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n                context.anchor_block_header,\n                context.this_address(),\n                STORAGE_SLOT,\n            );\n            assert_eq(result, value);\n        });\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn bad_hint_uninitialized_value() {\n        let env = TestEnvironment::new();\n\n        env.private_context(|context| {\n            let block_header = context.anchor_block_header;\n            let address = context.this_address();\n\n            // Mock the oracle to return a non-zero hint/packed value\n            let value_packed = MockStruct { a: 1, b: 1 }.pack();\n            let _ = OracleMock::mock(\"utilityStorageRead\")\n                .with_params((\n                    address.to_field(), STORAGE_SLOT, block_header.global_variables.block_number,\n                    value_packed.len(),\n                ))\n                .returns(value_packed)\n                .times(1);\n\n            // This should fail because the hint value is non-zero and the hash is zero (default value of storage)\n            let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n                block_header,\n                address,\n                STORAGE_SLOT,\n            );\n        });\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn bad_hint_initialized_value() {\n        let env = TestEnvironment::new();\n\n        env.public_context(|context| {\n            // Write the value and hash separately so that the hash is wrong\n            let value = MockStruct { a: 5, b: 3 };\n            context.storage_write(STORAGE_SLOT, value);\n\n            let incorrect_hash = 13;\n            let hash_storage_slot = STORAGE_SLOT + (value.pack().len() as Field);\n            context.storage_write(hash_storage_slot, [incorrect_hash]);\n        });\n\n        env.private_context(|context| {\n            let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n                context.anchor_block_header,\n                context.this_address(),\n                STORAGE_SLOT,\n            );\n        });\n    }\n}\n"
    },
    "231": {
      "path": "/home/jpag/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr",
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "253": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\nuse std::meta::derive;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct FunctionSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    pub inner: u32,\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "294": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\nuse std::meta::derive;\n\n// Aztec address\n#[derive(Deserialize, Eq, Packable, Serialize)]\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    /// Returns an address's `AddressPoint`, which can be used to create shared secrets with the owner\n    /// of the address. If the address is invalid (i.e. it is not a properly derived Aztec address), then this\n    /// returns `Option::none()`, and no shared secrets can be created.\n    pub fn to_address_point(self) -> Option<AddressPoint> {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // An invalid AztecAddress is one for which no y coordinate satisfies the curve equation, which we'll\n        // identify by proving that the square root of y_squared does not exist.\n        let mut y_opt = sqrt(y_squared);\n        if y_opt.is_none() {\n            Option::none()\n        } else {\n            let mut y = y_opt.unwrap();\n\n            // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n            // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n            // note: The field modulus is MAX_FIELD_VALUE + 1\n            if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n                y = (MAX_FIELD_VALUE + 1) - y;\n            }\n\n            Option::some(\n                AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } },\n            )\n        }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    // We use the AZTEC_ADDRESS_LENGTH constant to ensure that there is a match between the derived trait\n    // implementation and the constant.\n    let serialized: [Field; AZTEC_ADDRESS_LENGTH] = address.serialize();\n    let deserialized = AztecAddress::deserialize(serialized);\n    assert_eq(address, deserialized);\n}\n\n#[test]\nfn to_address_point_valid() {\n    // x = 8 where x^3 - 17 = 512 - 17 = 495, which is a residue in this field\n    let address = AztecAddress { inner: 8 };\n    let maybe_point = address.to_address_point();\n    assert(maybe_point.is_some());\n\n    let point = maybe_point.unwrap().inner;\n    // check that x is preserved\n    assert_eq(point.x, Field::from(8));\n\n    // check that the curve equation holds: y^2 == x^3 - 17\n    assert_eq(pow(point.y, 2), pow(point.x, 3) - 17);\n}\n\n#[test]\nunconstrained fn to_address_point_invalid() {\n    // x = 3 where x^3 - 17 = 27 - 17 = 10, which is a non-residue in this field\n    let address = AztecAddress { inner: 3 }; //\n    let maybe_point = address.to_address_point();\n    assert(maybe_point.is_none());\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n"
    },
    "307": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr",
      "source": "use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Deserialize, Empty, Hash, Serialize},\n};\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: Field,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl LeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: Field) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"
    },
    "309": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "// TODO: Expose other wrapped functions than debug (info, warn)\n// ['silent', 'fatal', 'error', 'warn', 'info', 'verbose', 'debug', 'trace']\n\npub global SILENT_LOG_LEVEL: u8 = 0;\npub global FATAL_LOG_LEVEL: u8 = 1;\npub global ERROR_LOG_LEVEL: u8 = 2;\npub global WARN_LOG_LEVEL: u8 = 3;\npub global INFO_LOG_LEVEL: u8 = 4;\npub global VERBOSE_LOG_LEVEL: u8 = 5;\npub global DEBUG_LOG_LEVEL: u8 = 6;\npub global TRACE_LOG_LEVEL: u8 = 7;\n\n/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Same as debug_log, but allows to customize the log level.\n/// Consider changing just to 'log'\npub fn debug_log_with_level<let N: u32>(log_level: u8, msg: str<N>) {\n    debug_log_format_with_level(log_level, msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_array_oracle_wrapper(DEBUG_LOG_LEVEL, msg, args) };\n}\n\n/// Same as debug_log_format, but allows to customize the log level.\n/// Consider changing just to 'log_format'\npub fn debug_log_format_with_level<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field; N],\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_array_oracle_wrapper(log_level, msg, args) };\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` slice.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole slice: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format_slice<let M: u32>(log_level: u8, msg: str<M>, args: [Field]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_slice_oracle_wrapper(log_level, msg, args) };\n}\n\n// We provide two versions of the debug log oracle: one that takes args as a slice and another one that takes args as an array.\n// We do this since conversion from array to slice generates overhead in public functions, since opcodes need to be emitted for the conversion.\n// By exposing the two flavors, we avoid conversions since the AVM is able to handle both arrays an slices in this oracle.\n\nunconstrained fn debug_log_slice_oracle_wrapper<let M: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field],\n) {\n    debug_log_slice_oracle(log_level, msg, args);\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_slice_oracle<let M: u32>(log_level: u8, msg: str<M>, args: [Field]) {}\n\nunconstrained fn debug_log_array_oracle_wrapper<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_array_oracle(log_level, msg, N, args);\n}\n\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_array_oracle<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    length: u32,\n    args: [Field; N],\n) {}\n"
    },
    "319": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "mod poseidon2_chunks;\n\nuse crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_log::{PrivateLog, PrivateLogData},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root_from_sibling_path,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    poseidon2::Poseidon2Sponge,\n    side_effect::{Counted, Scoped},\n    traits::{FromField, Hash, ToField},\n    utils::field::{field_from_bytes, field_from_bytes_32_trunc},\n};\n\npub use poseidon2_chunks::poseidon2_absorb_in_chunks_existing_sponge;\nuse poseidon2_chunks::poseidon2_absorb_in_chunks;\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(note_nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [note_nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_nonce_and_unique_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    let note_nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n    compute_unique_note_hash(note_nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        compute_nonce_and_unique_note_hash(siloed_note_hash, first_nullifier, note_index_in_tx)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: Scoped<Counted<NoteHash>>) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.innermost())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: Scoped<Counted<Nullifier>>) -> Field {\n    let value = nullifier.innermost().value;\n    // Q: shouldn't we be checking whether the _whole_ nullifier is empty?\n    // A: We don't have to. The init and inner circuits add contract address to non-empty nullifiers.\n    // So we know we should silo it if the contract address is not empty.\n    if nullifier.contract_address.is_zero() {\n        value // Return `value` instead of 0 because an already-siloed nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, value)\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<Counted<PrivateLogData>>) -> PrivateLog {\n    let log = private_log.innermost().log;\n    if private_log.contract_address.is_zero() {\n        log\n    } else {\n        let mut fields = log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, log.length)\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn compute_app_secret_key(\n    master_secret_key: EmbeddedCurveScalar,\n    app_address: AztecAddress,\n    app_secret_generator: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [master_secret_key.hi, master_secret_key.lo, app_address.to_field()],\n        app_secret_generator,\n    )\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let contract_address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    let recipient_bytes: [u8; 20] = recipient.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let rollup_version_id_bytes: [u8; 32] = rollup_version_id.to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n\n    let mut bytes: [u8; 148] = std::mem::zeroed();\n    for i in 0..32 {\n        bytes[i] = contract_address_bytes[i];\n        bytes[i + 32] = rollup_version_id_bytes[i];\n        // 64 - 84 are for recipient.\n        bytes[i + 84] = chain_id_bytes[i];\n        bytes[i + 116] = content_bytes[i];\n    }\n\n    for i in 0..20 {\n        bytes[64 + i] = recipient_bytes[i];\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: Scoped<L2ToL1Message>,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.inner.recipient,\n            msg.inner.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n/// Computes sha256 hash of 2 input fields.\n///\n/// @returns A truncated field (i.e., the first byte is always 0).\npub fn accumulate_sha256(v0: Field, v1: Field) -> Field {\n    // Concatenate two fields into 32 x 2 = 64 bytes\n    let v0_as_bytes: [u8; 32] = v0.to_be_bytes();\n    let v1_as_bytes: [u8; 32] = v1.to_be_bytes();\n    let hash_input_flattened = v0_as_bytes.concat(v1_as_bytes);\n\n    sha256_to_field(hash_input_flattened)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = [separator.to_field()].concat(inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n/// Computes a Poseidon2 hash over a dynamic-length subarray of the given input.\n/// Only the first `in_len` fields of `input` are absorbed; any remaining fields are ignored.\n/// The caller is responsible for ensuring that the input is padded with zeros if required.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_in_chunks(input, in_len);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_in_chunks(input, in_len);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n// This function is  unconstrained because it is intended to be used in unconstrained context only as\n// in constrained contexts it would be too inefficient.\npub unconstrained fn poseidon2_hash_with_separator_bounded_vec<let N: u32, T>(\n    inputs: BoundedVec<Field, N>,\n    separator: T,\n) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs.get(i));\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0x3b18c58c739716e76429634a61375c45b3b5cd470c22ab6d3e14cee23dd992);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0xaab2a5828156782b12a1dc6f336e2bc627eb1b9514b02d511f66296990c050);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        L2ToL1Message { recipient: EthAddress::from_field(1), content: 2 }.scope(\n            AztecAddress::from_field(3),\n        ),\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `yarn-project/stdlib/src/hash/hash.test.ts`\n    let hash_from_typescript = 0x0081edf209e087ad31b3fd24263698723d57190bd1d6e9fe056fc0c0a68ee661;\n\n    assert_eq(hash, hash_from_typescript);\n}\n\n#[test]\nunconstrained fn poseidon2_hash_with_separator_bounded_vec_matches_non_bounded_vec_version() {\n    let inputs = BoundedVec::<Field, 4>::from_array([1, 2, 3]);\n    let separator = 42;\n\n    // Hash using bounded vec version\n    let bounded_result = poseidon2_hash_with_separator_bounded_vec(inputs, separator);\n\n    // Hash using regular version\n    let regular_result = poseidon2_hash_with_separator([1, 2, 3], separator);\n\n    // Results should match\n    assert_eq(bounded_result, regular_result);\n}\n"
    },
    "328": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      "source": "use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_tree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n/// These values are precomputed and we run tests to ensure that they are correct.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_tree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_tree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_tree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_tree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_tree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_tree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_tree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_tree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_tree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_tree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_tree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_tree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"
    },
    "332": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use utils::derive_serialization_quotes;\n\npub mod utils;\n\n/// Generates the generic parameter declarations for a struct's trait implementation.\n///\n/// This function takes a struct type definition and generates the generic parameter declarations\n/// that go after the `impl` keyword. For example, given a struct with generics `N: u32` and `T`,\n/// it generates `<let N: u32, T>`.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate generic declarations for\n///\n/// # Returns\n/// A quoted code block containing the generic parameter declarations, or an empty quote if the struct\n/// has no generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// This function generates:\n/// ```\n/// <let N: u32, T>\n/// ```\ncomptime fn get_generics_declarations(s: TypeDefinition) -> Quoted {\n    let generics = s.generics();\n\n    if generics.len() > 0 {\n        let generics_declarations_items = generics\n            .map(|(name, maybe_integer_typ)| {\n                // The second item in the generics tuple is an Option of an integer type that is Some only if\n                // the generic is numeric.\n                if maybe_integer_typ.is_some() {\n                    // The generic is numeric, so we return a quote defined as e.g. \"let N: u32\"\n                    let integer_type = maybe_integer_typ.unwrap();\n                    quote {let $name: $integer_type}\n                } else {\n                    // The generic is not numeric, so we return a quote containing the name of the generic (e.g. \"T\")\n                    quote {$name}\n                }\n            })\n            .join(quote {,});\n        quote {<$generics_declarations_items>}\n    } else {\n        // The struct doesn't have any generics defined, so we just return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates the `where` clause for a trait implementation that constrains non-numeric generic type parameters.\n///\n/// This function takes a struct type definition and a trait name, and generates a `where` clause that\n/// requires all non-numeric generic type parameters to implement the specified trait.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the where clause for\n/// - `trait_name`: The name of the trait that non-numeric generic parameters must implement\n///\n/// # Returns\n/// A quoted code block containing the where clause, or an empty quote if the struct has no non-numeric\n/// generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// And trait name \"Serialize\", this function generates:\n/// ```\n/// where T: Serialize\n/// ```\ncomptime fn get_where_trait_clause(s: TypeDefinition, trait_name: Quoted) -> Quoted {\n    let generics = s.generics();\n\n    // The second item in the generics tuple is an Option of an integer type that is Some only if the generic is\n    // numeric.\n    let non_numeric_generics =\n        generics.filter(|(_, maybe_integer_typ)| maybe_integer_typ.is_none());\n\n    if non_numeric_generics.len() > 0 {\n        let non_numeric_generics_declarations =\n            non_numeric_generics.map(|(name, _)| quote {$name: $trait_name}).join(quote {,});\n        quote {where $non_numeric_generics_declarations}\n    } else {\n        // There are no non-numeric generics, so we return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates a `Serialize` trait implementation for a struct type.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A quoted code block containing the trait implementation\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Log<N> {\n///     fields: [Field; N],\n///     length: u32\n/// }\n/// ```\n///\n/// This function generates code equivalent to:\n/// ```\n/// impl<let N: u32> Serialize for Log<N> {\n///     let N: u32 = <[Field; N] as Serialize>::N + <u32 as Serialize>::N;\n///\n///     #[inline_always]\n///     fn serialize(self) -> [Field; Self::N] {\n///         let mut serialized_params = [0; _];\n///         let mut offset = 0;\n///\n///         let serialized_member = Serialize::serialize(self.fields);\n///         let serialized_member_len = <[Field; N] as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             serialized_params[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         let serialized_member = Serialize::serialize(self.length);\n///         let serialized_member_len = <u32 as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             serialized_params[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         serialized_params\n///     }\n/// }\n/// ```\npub comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n\n    // We care only about the name and type so we drop the last item of the tuple\n    let params = nested_struct.0.fields(nested_struct.1).map(|(name, typ, _)| (name, typ));\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Serialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_serialize_clause = get_where_trait_clause(s, quote {Serialize});\n\n    let (function_body, params_len_quote, serialized_params_name) =\n        derive_serialization_quotes(params, true);\n\n    quote {\n        impl$generics_declarations $crate::traits::Serialize for $typ\n            $where_serialize_clause\n        {\n            let N: u32 = $params_len_quote;\n\n            #[inline_always]\n            fn serialize(self) -> [Field; Self::N] {\n                $function_body\n\n                $serialized_params_name\n            }\n        }\n    }\n}\n\n/// Generates a `Deserialize` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Deserialize` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Deserialize for MyStruct {\n///     let N: u32 = <AztecAddress as Deserialize>::N + <Field as Deserialize>::N;\n///\n///     fn deserialize(serialized: [Field; Self::N]) -> Self {\n///         let mut offset = 0;\n///         let mut member_fields = [0; <AztecAddress as Deserialize>::N];\n///         for i in 0..<AztecAddress as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let x = <AztecAddress as Deserialize>::deserialize(member_fields);\n///         offset += <AztecAddress as Deserialize>::N;\n///\n///         let mut member_fields = [0; <Field as Deserialize>::N];\n///         for i in 0..<Field as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let y = <Field as Deserialize>::deserialize(member_fields);\n///         offset += <Field as Deserialize>::N;\n///\n///         Self { x, y }\n///     }\n/// }\n/// ```\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Deserialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_deserialize_clause = get_where_trait_clause(s, quote {Deserialize});\n\n    // The following will give us <type_of_struct_member_1 as Deserialize>::N + <type_of_struct_member_2 as Deserialize>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Deserialize>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly deserializing the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let function_body = if params.len() > 1 {\n        // This generates deserialization code for each struct member and concatenates them together.\n        let deserialization_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as Deserialize>::N];\n                    for i in 0..<$param_type as Deserialize>::N {\n                        member_fields[i] = serialized[i + offset];\n                    }\n                    let $param_name = <$param_type as Deserialize>::deserialize(member_fields);\n                    offset += <$param_type as Deserialize>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        // This will give us e.g. `a, b, c` for a struct with three fields named `a`, `b`, and `c`.\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n\n            $deserialization_of_struct_members\n\n            Self { $struct_members }\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Deserialize::deserialize(serialized) }\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Deserialize for $typ\n            $where_deserialize_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn deserialize(serialized: [Field; Self::N]) -> Self {\n                $function_body\n            }\n        }\n    }\n}\n\n/// Generates a `Packable` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Packable` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Packable for MyStruct {\n///     let N: u32 = 2;\n///\n///     fn pack(self) -> [Field; 2] {\n///         let mut result: [Field; 2] = [0_Field; 2];\n///         let mut offset: u32 = 0_u32;\n///         let packed_member: [Field; 1] = self.x.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         let packed_member: [Field; 1] = self.y.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         result\n///     }\n///\n///     fn unpack(packed: [Field; 2]) -> Self {\n///         let mut offset: u32 = 0_u32;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<AztecAddress as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let x: AztecAddress = <AztecAddress as Packable>::unpack(member_fields);\n///         offset = offset + <AztecAddress as Packable>::N;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<Field as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let y: Field = <Field as Packable>::unpack(member_fields);\n///         offset = offset + <Field as Packable>::N;\n///         Self { x: x, y: y }\n///     }\n/// }\n/// ```\npub comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Packable` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_packable_clause = get_where_trait_clause(s, quote {Packable});\n\n    // The following will give us <type_of_struct_member_1 as Packable>::N + <type_of_struct_member_2 as Packable>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Packable>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly returning the packed member,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let pack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate packing code that:\n        // 1. Packs each member\n        // 2. Copies the packed fields into the result array at the correct offset\n        // 3. Updates the offset for the next member\n        let packing_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let packed_member = $crate::traits::Packable::pack(self.$param_name);\n                    let packed_member_len = <$param_type as $crate::traits::Packable>::N;\n                    for i in 0..packed_member_len {\n                        result[i + offset] = packed_member[i];\n                    }\n                    offset += packed_member_len;\n                }\n            })\n            .join(quote {});\n\n        quote {\n            let mut result = [0; Self::N];\n            let mut offset = 0;\n\n            $packing_of_struct_members\n\n            result\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            $crate::traits::Packable::pack(self.$param_name)\n        }\n    };\n\n    // For structs containing a single member, we can enhance performance by directly unpacking the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let unpack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate unpacking code that:\n        // 1. Unpacks each member\n        // 2. Copies packed fields into member array at correct offset\n        // 3. Updates offset for next member\n        let unpacking_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as $crate::traits::Packable>::N];\n                    for i in 0..<$param_type as $crate::traits::Packable>::N {\n                        member_fields[i] = packed[i + offset];\n                    }\n                    let $param_name = <$param_type as $crate::traits::Packable>::unpack(member_fields);\n                    offset += <$param_type as $crate::traits::Packable>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n            $unpacking_of_struct_members\n            Self { $struct_members }\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Packable::unpack(packed) }\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Packable for $typ\n            $where_packable_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn pack(self) -> [Field; Self::N] {\n                $pack_function_body\n            }\n\n            #[inline_always]\n            fn unpack(packed: [Field; Self::N]) -> Self {\n                $unpack_function_body\n            }\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Packable, Serialize};\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct Smol {\n        a: Field,\n        b: Field,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct HasArray {\n        a: [Field; 2],\n        b: bool,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct Fancier {\n        a: Smol,\n        b: [Field; 2],\n        c: [u8; 3],\n        d: str<16>,\n    }\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct HasArrayWithGenerics<T, let N: u32> {\n        pub fields: [T; N],\n        pub length: u32,\n    }\n\n    #[test]\n    fn serde_on_smol() {\n        let smol = Smol { a: 1, b: 2 };\n        let serialized = smol.serialize();\n        assert(serialized == [1, 2], serialized);\n        let deserialized = Smol::deserialize(serialized);\n        assert(deserialized == smol);\n\n        // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n        let packed = smol.pack();\n        assert_eq(packed, serialized, \"Packed does not match serialized\");\n    }\n\n    #[test]\n    fn serde_on_has_array() {\n        let has_array = HasArray { a: [1, 2], b: true };\n        let serialized = has_array.serialize();\n        assert(serialized == [1, 2, 1], serialized);\n        let deserialized = HasArray::deserialize(serialized);\n        assert(deserialized == has_array);\n    }\n\n    #[test]\n    fn serde_on_fancier() {\n        let fancier =\n            Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n        let serialized = fancier.serialize();\n        assert(\n            serialized\n                == [\n                    1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                    0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n                ],\n            serialized,\n        );\n        let deserialized = Fancier::deserialize(serialized);\n        assert(deserialized == fancier);\n    }\n\n    #[test]\n    fn serde_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let serialized = struct_with_array_of_generics.serialize();\n        assert(serialized == [1, 2, 3, 3], serialized);\n        let deserialized = HasArrayWithGenerics::deserialize(serialized);\n        assert(deserialized == struct_with_array_of_generics);\n    }\n\n    #[test]\n    fn packable_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let packed = struct_with_array_of_generics.pack();\n        assert(packed == [1, 2, 3, 3], packed);\n\n        let unpacked = HasArrayWithGenerics::unpack(packed);\n        assert(unpacked == struct_with_array_of_generics);\n    }\n\n}\n"
    },
    "333": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/meta/utils.nr",
      "source": "/// Generates serialization code for a list of parameters and the total length of the serialized array\n///\n/// # Parameters\n/// - `params`: A list of (name, type) tuples to serialize\n/// - `use_self_prefix`: If true, parameters are accessed as `self.$param_name` (for struct members).\n///                      If false, parameters are accessed directly as `$param_name` (for function parameters).\n///\n/// # Returns\n/// A tuple containing:\n/// - Quoted code that serializes the parameters into an array named `serialized_params`\n/// - Quoted code that evaluates to the total length of the serialized array\n/// - Quoted code containing the name of the serialized array\npub comptime fn derive_serialization_quotes(\n    params: [(Quoted, Type)],\n    use_self_prefix: bool,\n) -> (Quoted, Quoted, Quoted) {\n    let prefix_quote = if use_self_prefix {\n        quote { self. }\n    } else {\n        quote {}\n    };\n\n    let params_len_quote = get_params_len_quote(params);\n    let serialized_params_name = quote { serialized_params };\n\n    let body = if params.len() == 0 {\n        quote {\n            let $serialized_params_name: [Field; 0] = [];\n        }\n    } else if params.len() == 1 {\n        // When we have only a single parameter on the input, we can enhance performance by directly returning\n        // the serialized member, bypassing the need for loop-based array construction. While this optimization yields\n        // significant benefits in Brillig where the loops are expected to not be optimized, it is not relevant in ACIR\n        // where the loops are expected to be optimized away.\n\n        let param_name = params[0].0;\n        quote {\n            let $serialized_params_name = $crate::traits::Serialize::serialize($prefix_quote$param_name);\n        }\n    } else {\n        // For multiple struct members, generate serialization code that:\n        // 1. Serializes each member\n        // 2. Copies the serialized fields into the serialize array at the correct offset\n        // 3. Updates the offset for the next member\n        let serialization_of_struct_members = params\n            .map(|(param_name, param_type): (Quoted, Type)| {\n                quote {\n                let serialized_member = $crate::traits::Serialize::serialize($prefix_quote$param_name);\n                let serialized_member_len = <$param_type as $crate::traits::Serialize>::N;\n                for i in 0..serialized_member_len {\n                    $serialized_params_name[i + offset] = serialized_member[i];\n                }\n                offset += serialized_member_len;\n            }\n            })\n            .join(quote {});\n\n        quote {\n            let mut $serialized_params_name = [0; $params_len_quote];\n            let mut offset = 0;\n\n            $serialization_of_struct_members\n        }\n    };\n\n    (body, params_len_quote, serialized_params_name)\n}\n\n/// Generates a quoted expression that computes the total serialized length of function parameters.\n///\n/// # Parameters\n/// * `params` - An array of tuples where each tuple contains a quoted parameter name and its Type. The type needs\n///              to implement the Serialize trait.\n///\n/// # Returns\n/// A quoted expression that evaluates to:\n/// * `0` if there are no parameters\n/// * `(<type1 as Serialize>::N + <type2 as Serialize>::N + ...)` for one or more parameters\npub comptime fn get_params_len_quote(params: [(Quoted, Type)]) -> Quoted {\n    if params.len() == 0 {\n        quote { 0 }\n    } else {\n        let params_quote_without_parentheses = params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n                    <$param_type as $crate::traits::Serialize>::N\n                }\n            })\n            .join(quote {+});\n        quote { ($params_quote_without_parentheses) }\n    }\n}\n"
    },
    "334": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl Serialize for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn serialize(self: Self) -> [Field; Self::N] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn deserialize(serialized: [Field; Self::N]) -> Self {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] != 0 }\n    }\n}\n\n// TODO(#11356): use compact representation here.\nimpl Packable for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn pack(self) -> [Field; Self::N] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; Self::N]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "335": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\nuse crate::traits::{Deserialize, Serialize};\nuse std::meta::derive;\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "342": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::{default::Default, meta::derive};\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nmod test {\n    use crate::{\n        point::POINT_LENGTH,\n        public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n        traits::{Deserialize, Serialize},\n    };\n    use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\n    #[test]\n    unconstrained fn compute_public_keys_hash() {\n        let keys = PublicKeys {\n            npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n            ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n            ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n            tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n        };\n\n        let actual = keys.hash();\n        let expected_public_keys_hash =\n            0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n        assert(actual.to_field() == expected_public_keys_hash);\n    }\n\n    #[test]\n    unconstrained fn compute_default_hash() {\n        let keys = PublicKeys::default();\n\n        let actual = keys.hash();\n        let test_data_default_hash =\n            0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n        assert(actual.to_field() == test_data_default_hash);\n    }\n\n    #[test]\n    unconstrained fn serde() {\n        let keys = PublicKeys {\n            npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n            ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n            ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n            tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n        };\n\n        // We use the PUBLIC_KEYS_LENGTH constant to ensure that there is a match between the derived trait\n        let serialized: [Field; POINT_LENGTH * 4] = keys.serialize();\n        let deserialized = PublicKeys::deserialize(serialized);\n\n        assert_eq(keys, deserialized);\n    }\n}\n"
    },
    "347": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "363": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty: Eq {\n    fn empty() -> Self;\n\n    fn is_empty(self) -> bool {\n        self.eq(Self::empty())\n    }\n\n    // Requires this Noir fix: https://github.com/noir-lang/noir/issues/9002\n    // fn assert_not_empty<let U: u32>(self, msg: str<U>) { // This msg version was failing with weird compiler errors.\n    //     // We provide a default impl but it's likely inefficient.\n    //     // The reason we include this function is because there's a lot of\n    //     // opportunity for optimisation on a per-struct basis.\n    //     // You only need to show one element is not empty to know that the whole thing\n    //     // is not empty.\n    //     // If you know an element of your struct which should always be nonempty,\n    //     // you can write an impl that solely checks that that element is nonempty.\n    //     assert(!self.is_empty(), msg);\n    // }\n\n    // This default impl is overwritten by types like arrays, because there's a much\n    // more efficient approach.\n    fn assert_empty<let S: u32>(self, msg: str<S>) {\n        assert(self.is_empty(), msg);\n    }\n}\n\nimpl Empty for Field {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u16 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\n\nimpl<T> Empty for [T]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty()]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\nimpl<A, B> Empty for (A, B)\nwhere\n    A: Empty,\n    B: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        (A::empty(), B::empty())\n    }\n}\n\nimpl<T> Empty for Option<T>\nwhere\n    T: Eq,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\n// pub fn is_empty<T>(item: T) -> bool\n// where\n//     T: Empty,\n// {\n//     item.eq(T::empty())\n// }\n\n// pub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\n// where\n//     T: Empty,\n// {\n//     array.all(|elem| is_empty(elem))\n// }\n\n// pub fn assert_empty<T>(item: T) -> ()\n// where\n//     T: Empty,\n// {\n//     assert(item.eq(T::empty()))\n// }\n\n// pub fn assert_empty_array<T, let N: u32>(array: [T; N]) -> ()\n// where\n//     T: Empty,\n// {\n//     // A cheaper option than `is_empty_array` for if you don't need to gracefully\n//     // handle a bool result.\n//     // Avoids the `&` operator of `is_empty_array`'s `.all()` call.\n//     for i in 0..N {\n//         assert(is_empty(array[i]));\n//     }\n// }\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u16 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value != 0\n    }\n}\nimpl FromField for u1 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u16 {\n    fn from_field(value: Field) -> Self {\n        value as u16\n    }\n}\nimpl FromField for u32 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Associated Constants\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize for str<N> {\n///     let N: u32 = N;\n///\n///     fn serialize(self) -> [Field; Self::N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; Self::N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize {\n    let N: u32;\n\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let M: u32> Serialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; Self::N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n/// Implementation of Deserialize for BoundedVec.\n///\n/// This implementation deserializes a BoundedVec from an array of Fields. The array contains:\n/// 1. The serialized items, each taking up T::N Fields\n/// 2. The length of the BoundedVec as the last Field\n///\n/// # Type Parameters\n/// * `T` - The type of items stored in the BoundedVec, must implement Deserialize\n/// * `M` - The maximum length of the BoundedVec\n///\n/// # Fields Array Layout\n/// [item1_field1, item1_field2, ..., item2_field1, item2_field2, ..., length]\n/// Where:\n/// - itemN_fieldM: The M-th Field of the N-th item (T::N Fields per item)\n/// - length: The number of items in the BoundedVec (1 Field)\n///\n/// Total length N = T::N * M + 1, where:\n/// - T::N is the number of Fields needed to deserialize one item\n/// - M is the maximum length of the BoundedVec\n/// - +1 is for storing the length\n///\n/// # Note\n/// Not deriving this because it's not supported to call derive_deserialize on a \"remote\" struct (and it will never\n/// be supported).\nimpl<T, let M: u32> Deserialize for BoundedVec<T, M>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut new_bounded_vec: BoundedVec<T, M> = BoundedVec::new();\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        let len = fields[<T as Deserialize>::N * M] as u32;\n\n        for i in 0..len {\n            let mut nested_fields = [0; <T as Deserialize>::N];\n            for j in 0..<T as Deserialize>::N {\n                nested_fields[j] = fields[i * <T as Deserialize>::N + j];\n            }\n\n            let item = T::deserialize(nested_fields);\n            new_bounded_vec.push(item);\n        }\n\n        new_bounded_vec\n    }\n}\n\n// This may cause issues if used as program input, because noir disallows empty arrays for program input.\n// I think this is okay because I don't foresee a unit type being used as input. But leaving this comment as a hint\n// if someone does run into this in the future.\nimpl Deserialize for () {\n    let N: u32 = 0;\n\n    fn deserialize(_fields: [Field; Self::N]) -> Self {\n        ()\n    }\n}\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl<T, let M: u32> Serialize for BoundedVec<T, M>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M + 1; // +1 for the length of the BoundedVec\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut fields = [0; Self::N];\n\n        let storage = self.storage();\n\n        for i in 0..M {\n            let serialized_item = storage[i].serialize();\n\n            for j in 0..<T as Serialize>::N {\n                fields[i * <T as Serialize>::N + j] = serialized_item[j];\n            }\n        }\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        fields[<T as Serialize>::N * M] = self.len() as Field;\n\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Associated Constants\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let M: u32> Deserialize for str<M> {\n///     let N: u32 = M;\n///\n///     #[inline_always]\n///     fn deserialize(fields: [Field; Self::N]) -> Self {\n///         str::<Self::N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize {\n    let N: u32;\n\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let M: u32> Deserialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        str::<Self::N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Associated Constants\n/// * `N` - The length of the Field array, known at compile time\n#[derive_via(derive_packable)]\npub trait Packable {\n    let N: u32;\n\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n\n#[test]\nunconstrained fn bounded_vec_serialization() {\n    // Test empty BoundedVec\n    let empty_vec: BoundedVec<Field, 3> = BoundedVec::from_array([]);\n    let serialized = empty_vec.serialize();\n    let deserialized = BoundedVec::<Field, 3>::deserialize(serialized);\n    assert_eq(empty_vec, deserialized);\n    assert_eq(deserialized.len(), 0);\n\n    // Test partially filled BoundedVec\n    let partial_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2]]);\n    let serialized = partial_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(partial_vec, deserialized);\n    assert_eq(deserialized.len(), 1);\n    assert_eq(deserialized.get(0), [1, 2]);\n\n    // Test full BoundedVec\n    let full_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2], [3, 4], [5, 6]]);\n    let serialized = full_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(full_vec, deserialized);\n    assert_eq(deserialized.len(), 3);\n    assert_eq(deserialized.get(0), [1, 2]);\n    assert_eq(deserialized.get(1), [3, 4]);\n    assert_eq(deserialized.get(2), [5, 6]);\n}\n"
    },
    "365": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable for bool {\n    let N: u32 = BOOL_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> bool {\n        (fields[0] as u1) != 0\n    }\n}\n\nimpl Packable for u8 {\n    let N: u32 = U8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable for u16 {\n    let N: u32 = U16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable for u32 {\n    let N: u32 = U32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable for u64 {\n    let N: u32 = U64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable for u128 {\n    let N: u32 = U128_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable for Field {\n    let N: u32 = FIELD_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable for i8 {\n    let N: u32 = I8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Packable for i16 {\n    let N: u32 = I16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Packable for i32 {\n    let N: u32 = I32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Packable for i64 {\n    let N: u32 = I64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Packable for [T; M]\nwhere\n    T: Packable,\n{\n    let N: u32 = M * <T as Packable>::N;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized = self[i].pack();\n            for j in 0..<T as Packable>::N {\n                result[i * <T as Packable>::N + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Packable>::N, M>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "366": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal U1_SERIALIZED_LEN: u32 = 1;\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> bool {\n        fields[0] != 0\n    }\n}\n\nimpl Serialize for u1 {\n    let N: u32 = U1_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u1 {\n    let N: u32 = U1_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u1\n    }\n}\n\nimpl Serialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self]\n    }\n}\n\nimpl Deserialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n}\n\nimpl Deserialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Serialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n}\n\nimpl Deserialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Serialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n}\n\nimpl Deserialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Serialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n}\n\nimpl Deserialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Serialize for [T; M]\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M;\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; _] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized_t = self[i].serialize();\n            let T_N = serialized_t.len();\n            for j in 0..T_N {\n                result[i * T_N + j] = serialized_t[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let M: u32> Deserialize for [T; M]\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Deserialize>::N, M>(Deserialize::deserialize, result)\n    }\n}\n\nimpl<T> Serialize for Option<T>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N + 1;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n\n        result[0] = if self.is_some() { 1 } else { 0 };\n\n        let value_serialized = self.unwrap_unchecked().serialize();\n        for i in 0..<T as Serialize>::N {\n            result[1 + i] = value_serialized[i];\n        }\n\n        result\n    }\n}\n\nimpl<T> Deserialize for Option<T>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        if fields[0] == 1 {\n            let mut value_fields = [0; <T as Deserialize>::N];\n            for i in 0..<T as Deserialize>::N {\n                value_fields[i] = fields[1 + i];\n            }\n\n            Option::some(T::deserialize(value_fields))\n        } else {\n            Option::none()\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Serialize};\n\n    #[test]\n    fn u16_serialization() {\n        let a: u16 = 10;\n        assert_eq(a, u16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i8_serialization() {\n        let a: i8 = -10;\n        assert_eq(a, i8::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i16_serialization() {\n        let a: i16 = -10;\n        assert_eq(a, i16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i32_serialization() {\n        let a: i32 = -10;\n        assert_eq(a, i32::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i64_serialization() {\n        let a: i64 = -10;\n        assert_eq(a, i64::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn option_field_serialization() {\n        let opt_some = Option::some(5);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n\n    #[test]\n    fn array_serialization() {\n        let array = [1, 2, 3, 4];\n\n        let serialized: [Field; 4] = array.serialize();\n        let deserialized: [Field; 4] = Deserialize::deserialize(serialized);\n        assert_eq(deserialized, array);\n    }\n\n    #[test]\n    fn nested_array_serialization() {\n        let nested_array = [[1, 2, 3, 4], [5, 6, 7, 8]];\n\n        let serialized: [Field; 8] = nested_array.serialize();\n        let deserialized: [[Field; 4]; 2] = Deserialize::deserialize(serialized);\n\n        assert_eq(deserialized, nested_array);\n    }\n\n    #[test]\n    fn option_array_serialization() {\n        let opt_some = Option::some([2, 5]);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n}\n"
    },
    "384": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "global KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\npub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO: This currently only exists to aid point compression in compress_to_blob_commitment().\n// Once compression is part of BigCurve it can either be removed or optimized to be used elsewhere.\npub fn byte_to_bits_be(byte: u8) -> [u1; 8] {\n    let mut mut_byte = byte;\n    let mut bits: [u1; 8] = [0; 8];\n    for i in 0..8 {\n        bits[7 - i] = (mut_byte & 1) as u1;\n        mut_byte >>= 1;\n    }\n    bits\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n/// Returns Option::some(sqrt) if there is a square root, and Option::none() if there isn't.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\nunconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n\n#[test]\nunconstrained fn sqrt_valid_test() {\n    let x = 16; // examples: 16, 9, 25, 81\n    let result = sqrt(x);\n    assert(result.is_some());\n    assert_eq(result.unwrap() * result.unwrap(), x);\n}\n\n#[test]\nunconstrained fn sqrt_invalid_test() {\n    let x = KNOWN_NON_RESIDUE; // has no square root in the field\n    let result = sqrt(x);\n    assert(result.is_none());\n}\n"
    },
    "388": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_u64(&mut self) -> u64 {\n        self.read() as u64\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() != 0\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert_eq(self.offset, self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "444": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/uint-note/src/uint_note.nr",
      "source": "use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    history::nullifier_inclusion::ProveNullifierInclusion,\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    messages::logs::note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{\n            GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER,\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT, PRIVATE_LOG_SIZE_IN_FIELDS,\n        },\n        hash::{compute_siloed_nullifier, poseidon2_hash_with_separator},\n        traits::{Deserialize, FromField, Hash, Packable, Serialize, ToField},\n    },\n};\n\n// UintNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the amount).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n/// A private note representing a numeric value associated to an account (e.g. a token balance).\n#[derive(Deserialize, Eq, Serialize, Packable)]\n#[custom_note]\npub struct UintNote {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintPartialNotePrivateContent, and\n    //   b) have the public field at the end\n    // Correct ordering is checked by the tests in this module.\n\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The number stored in the note.\n    value: u128,\n}\n\nimpl NoteHash for UintNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because UintNote has just one variant (where the value is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let private_content =\n            UintPartialNotePrivateContent { owner: self.owner, randomness: self.randomness };\n        let partial_note = PartialUintNote {\n            commitment: private_content.compute_partial_commitment(storage_slot),\n        };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.value)\n    }\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullification: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullification, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(\n        self,\n        note_hash_for_nullification: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullification, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: u128, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness }\n    }\n\n    pub fn get_value(self) -> u128 {\n        self.value\n    }\n\n    pub fn get_owner(self) -> AztecAddress {\n        self.owner\n    }\n\n    /// Creates a partial note that will hide the owner and storage slot but not the value, since the note will be later\n    /// completed in public. This is a powerful technique for scenarios in which the value cannot be known in private\n    /// (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// This function inserts a partial note validity commitment into the nullifier tree to be later on able to verify\n    /// that the partial note and completer are legitimate. See function docs of `compute_validity_commitment` for more\n    /// details.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` so that they can discover the\n    /// note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        completer: AztecAddress,\n    ) -> PartialUintNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = UintPartialNotePrivateContent { owner, randomness }\n            .compute_partial_commitment(storage_slot);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content =\n            UintPartialNotePrivateLogContent { owner, randomness, public_log_tag: commitment };\n\n        let encrypted_log = note::compute_partial_note_private_content_log(\n            private_log_content,\n            storage_slot,\n            recipient,\n        );\n        // Regardless of the original content size, the log is padded with random bytes up to\n        // `PRIVATE_LOG_SIZE_IN_FIELDS` to prevent leaking information about the actual size.\n        let length = encrypted_log.len();\n        context.emit_private_log(encrypted_log, length);\n\n        let partial_note = PartialUintNote { commitment };\n\n        // Now we compute the validity commitment and push it to the nullifier tree. It can be safely pushed to\n        // the nullifier tree since it uses its own separator, making collisions with actual note nullifiers\n        // practically impossible.\n        let validity_commitment = partial_note.compute_validity_commitment(completer);\n        context.push_nullifier(validity_commitment);\n\n        partial_note\n    }\n}\n\n/// The private content of a partial UintNote, i.e. the fields that will remain private. All other note fields will be\n/// made public.\n#[derive(Packable)]\nstruct UintPartialNotePrivateContent {\n    // The ordering of these fields is important given that it must match that of UintNote.\n    // Correct ordering is checked by the tests in this module.\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl UintPartialNotePrivateContent {\n    fn compute_partial_commitment(self, storage_slot: Field) -> Field {\n        // Here we commit to all private values, including the storage slot.\n        poseidon2_hash_with_separator(\n            self.pack().concat([storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\n#[derive(Packable)]\nstruct UintPartialNotePrivateLogContent {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintNote, and\n    //   b) have the public log tag at the beginning\n    // Correct ordering is checked by the tests in this module.\n    public_log_tag: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteType for UintPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        UintNote::get_id()\n    }\n}\n\n/// A partial instance of a UintNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the value field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the value to the public), resulting in a UintNote that can be used like any other one (except\n/// of course that its value is known).\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct PartialUintNote {\n    commitment: Field,\n}\n\nglobal NOTE_COMPLETION_LOG_LENGTH: u32 = 2;\n\nimpl PartialUintNote {\n    /// Completes the partial note, creating a new note that can be used like any other UintNote.\n    pub fn complete(self, context: &mut PublicContext, completer: AztecAddress, value: u128) {\n        // A note with a value of zero is valid, but we cannot currently complete a partial note with such a value\n        // because this will result in the completion log having its last field set to 0. Public logs currently do not\n        // track their length, and so trailing zeros are simply trimmed. This results in the completion log missing its\n        // last field (the value), and note discovery failing.\n        // TODO(#11636): remove this\n        assert(value != 0, \"Cannot complete a PartialUintNote with a value of 0\");\n\n        // We verify that the partial note we're completing is valid (i.e. completer is correct, it uses the correct\n        // state variable's storage slot, and it is internally consistent).\n        let validity_commitment = self.compute_validity_commitment(completer);\n        assert(\n            context.nullifier_exists(validity_commitment, context.this_address()),\n            \"Invalid partial note or completer\",\n        );\n\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the value). The contract will later find it by searching\n        //  for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(value));\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    /// Completes the partial note, creating a new note that can be used like any other UintNote. Same as `complete`\n    /// function but works from private context.\n    pub fn complete_from_private(\n        self,\n        context: &mut PrivateContext,\n        completer: AztecAddress,\n        value: u128,\n    ) {\n        // We verify that the partial note we're completing is valid (i.e. completer is correct, it uses the correct\n        // state variable's storage slot, and it is internally consistent).\n        let validity_commitment = self.compute_validity_commitment(completer);\n        // `prove_nullifier_inclusion` function expects the nullifier to be siloed (hashed with the address of\n        // the contract that emitted the nullifier) as it checks the value directly against the nullifier tree and all\n        // the nullifiers in the tree are siloed by the protocol.\n        let siloed_validity_commitment =\n            compute_siloed_nullifier(context.this_address(), validity_commitment);\n        context.get_anchor_block_header().prove_nullifier_inclusion(siloed_validity_commitment);\n\n        // We need to do two things:\n        //  - emit an unencrypted log containing the public fields (the value) via the private log channel. The\n        //  contract will later find it by searching for the expected tag (which is simply the partial note\n        //  commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_private_log(\n            self.compute_note_completion_log_padded_for_private_log(value),\n            NOTE_COMPLETION_LOG_LENGTH,\n        );\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    /// Computes a validity commitment for this partial note. The commitment cryptographically binds the note's private\n    /// data with the designated completer address. When the note is later completed in public execution, we can load\n    /// this commitment from the nullifier tree and verify that both the partial note (e.g. that the storage slot\n    /// corresponds to the correct owner, and that we're using the correct state variable) and completer are\n    /// legitimate.\n    pub fn compute_validity_commitment(self, completer: AztecAddress) -> Field {\n        poseidon2_hash_with_separator(\n            [self.commitment, completer.to_field()],\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT,\n        )\n    }\n\n    fn compute_note_completion_log(self, value: u128) -> [Field; NOTE_COMPLETION_LOG_LENGTH] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, value.to_field()]\n    }\n\n    fn compute_note_completion_log_padded_for_private_log(\n        self,\n        value: u128,\n    ) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS] {\n        let note_completion_log = self.compute_note_completion_log(value);\n        let padding = [0; PRIVATE_LOG_SIZE_IN_FIELDS - NOTE_COMPLETION_LOG_LENGTH];\n        note_completion_log.concat(padding)\n    }\n\n    fn compute_complete_note_hash(self, value: u128) -> Field {\n        // Here we finalize the note hash by including the (public) value into the partial note commitment. Note that we\n        // use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator(\n            [self.commitment, value.to_field()],\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\nimpl ToField for PartialUintNote {\n    fn to_field(self) -> Field {\n        self.commitment\n    }\n}\n\nimpl FromField for PartialUintNote {\n    fn from_field(field: Field) -> Self {\n        Self { commitment: field }\n    }\n}\n\nmod test {\n    use super::{\n        PartialUintNote, UintNote, UintPartialNotePrivateContent, UintPartialNotePrivateLogContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{address::AztecAddress, traits::{Deserialize, FromField, Packable}},\n        utils::array::subarray,\n    };\n\n    global value: u128 = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a UintNote has the same note hash as a PartialUintNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n\n        let note = UintNote { value, randomness, owner };\n        let note_hash = note.compute_note_hash(storage_slot);\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n\n        let partial_note = PartialUintNote {\n            commitment: partial_note_private_content.compute_partial_commitment(storage_slot),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(value);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular UintNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular UintNote.\n\n        let note = UintNote { value, randomness, owner };\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n        let commitment = partial_note_private_content.compute_partial_commitment(storage_slot);\n\n        let private_log_content =\n            UintPartialNotePrivateLogContent { owner, randomness, public_log_tag: commitment };\n        // The following is a misuse of the `deserialize` function, but this is just a test and it's better than\n        // letting devs manually construct it when they shouldn't be able to.\n        let partial_note = PartialUintNote::deserialize([commitment]);\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(value)[0],\n        );\n\n        // Then we extract all fields except the first of both logs (i.e. the public log tag), and combine them to\n        // produce the note's packed representation. This requires that the members of the intermediate structs are in\n        // the same order as in UintNote.\n        let private_log_without_public_tag: [_; 2] = subarray(private_log_content.pack(), 1);\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(value), 1);\n\n        assert_eq(private_log_without_public_tag.concat(public_log_without_tag), note.pack());\n    }\n}\n"
    },
    "46": {
      "path": "std/slice.nr",
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice with its index, returning a\n    // new slice containing the mapped elements.\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U] {\n        let mut ret = &[];\n        let mut index = 0;\n        for elem in self {\n            ret = ret.push_back(f(index, elem));\n            index += 1;\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for elem in self {\n            f(elem);\n        }\n    }\n\n    // Apply a function to each element of the slice with its index\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        let mut index = 0;\n        for elem in self {\n            f(index, elem);\n            index += 1;\n        }\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq(&[].map(|x| x + 1), &[]);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq(&[].mapi(|i, x| i * x + 1), &[]);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_each(|_x| assert(false));\n        assert(empty_slice == &[]);\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_eachi(|_i, _x| assert(false));\n        assert(empty_slice == &[]);\n    }\n\n    #[test]\n    fn map_example() {\n        let a = &[1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, &[2, 4, 6]);\n        assert_eq(a, &[1, 2, 3]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = &[1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, &[2, 5, 8]);\n        assert_eq(a, &[1, 2, 3]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_each(|a| { *b_ref = b_ref.push_back(a * 2); });\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { *b_ref = b_ref.push_back(i + a * 2); });\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n    #[test]\n    fn len_empty() {\n        let empty: [Field] = &[];\n        assert_eq(empty.len(), 0);\n    }\n\n    #[test]\n    fn len_single() {\n        assert_eq(&[42].len(), 1);\n    }\n\n    #[test]\n    fn len_multiple() {\n        assert_eq(&[1, 2, 3, 4, 5].len(), 5);\n    }\n\n    #[test]\n    fn push_back_empty() {\n        let empty: [Field] = &[];\n        let result = empty.push_back(42);\n        assert_eq(result.len(), 1);\n        assert_eq(result[0], 42);\n    }\n\n    #[test]\n    fn push_back_non_empty() {\n        let slice = &[1, 2, 3];\n        let result = slice.push_back(4);\n        assert_eq(result.len(), 4);\n        assert_eq(result, &[1, 2, 3, 4]);\n    }\n\n    #[test]\n    fn push_front_empty() {\n        let empty = &[];\n        let result = empty.push_front(42);\n        assert_eq(result.len(), 1);\n        assert_eq(result[0], 42);\n    }\n\n    #[test]\n    fn push_front_non_empty() {\n        let slice = &[1, 2, 3];\n        let result = slice.push_front(0);\n        assert_eq(result.len(), 4);\n        assert_eq(result, &[0, 1, 2, 3]);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds\")]\n    fn pop_back_empty() {\n        let slice: [Field] = &[];\n        let (_, _) = slice.pop_back();\n    }\n\n    #[test]\n    fn pop_back_one() {\n        let slice = &[42];\n        let (result, elem) = slice.pop_back();\n        assert_eq(result.len(), 0);\n        assert_eq(elem, 42);\n    }\n\n    #[test]\n    fn pop_back_multiple() {\n        let slice = &[1, 2, 3];\n        let (result, elem) = slice.pop_back();\n        assert_eq(result.len(), 2);\n        assert_eq(result, &[1, 2]);\n        assert_eq(elem, 3);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds\")]\n    fn pop_front_empty() {\n        let slice: [Field] = &[];\n        let (_, _) = slice.pop_front();\n    }\n\n    #[test]\n    fn pop_front_one() {\n        let slice = &[42];\n        let (elem, result) = slice.pop_front();\n        assert_eq(result.len(), 0);\n        assert_eq(elem, 42);\n    }\n\n    #[test]\n    fn pop_front_multiple() {\n        let slice = &[1, 2, 3];\n        let (elem, result) = slice.pop_front();\n        assert_eq(result.len(), 2);\n        assert_eq(result, &[2, 3]);\n        assert_eq(elem, 1);\n    }\n\n    #[test]\n    fn insert_beginning() {\n        let slice = &[1, 2, 3];\n        let result = slice.insert(0, 0);\n        assert_eq(result.len(), 4);\n        assert_eq(result, &[0, 1, 2, 3]);\n    }\n\n    #[test]\n    fn insert_middle() {\n        let slice = &[1, 2, 3];\n        let result = slice.insert(1, 99);\n        assert_eq(result.len(), 4);\n        assert_eq(result, &[1, 99, 2, 3]);\n    }\n\n    #[test]\n    fn insert_end() {\n        let slice = &[1, 2, 3];\n        let result = slice.insert(3, 4);\n        assert_eq(result.len(), 4);\n        assert_eq(result, &[1, 2, 3, 4]);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds\")]\n    fn insert_end_out_of_bounds() {\n        let slice = &[1, 2];\n        let _ = slice.insert(3, 4);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds\")]\n    fn remove_empty() {\n        let slice: [Field] = &[];\n        let (_, _) = slice.remove(0);\n    }\n\n    #[test]\n    fn remove_beginning() {\n        let slice = &[1, 2, 3];\n        let (result, elem) = slice.remove(0);\n        assert_eq(result.len(), 2);\n        assert_eq(result, &[2, 3]);\n        assert_eq(elem, 1);\n    }\n\n    #[test]\n    fn remove_middle() {\n        let slice = &[1, 2, 3];\n        let (result, elem) = slice.remove(1);\n        assert_eq(result.len(), 2);\n        assert_eq(result, &[1, 3]);\n        assert_eq(elem, 2);\n    }\n\n    #[test]\n    fn remove_end() {\n        let slice = &[1, 2, 3];\n        let (result, elem) = slice.remove(2);\n        assert_eq(result.len(), 2);\n        assert_eq(result, &[1, 2]);\n        assert_eq(elem, 3);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds\")]\n    fn remove_end_out_of_bounds() {\n        let slice = &[1, 2];\n        let (_, _) = slice.remove(2);\n    }\n\n    #[test]\n    fn fold_empty() {\n        let empty = &[];\n        let result = empty.fold(10, |acc, x| acc + x);\n        assert_eq(result, 10);\n    }\n\n    #[test]\n    fn fold_single() {\n        let slice = &[5];\n        let result = slice.fold(10, |acc, x| acc + x);\n        assert_eq(result, 15);\n    }\n\n    #[test]\n    fn fold_multiple() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.fold(0, |acc, x| acc + x);\n        assert_eq(result, 10);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds\")]\n    fn reduce_empty() {\n        let empty: [Field] = &[];\n        let _ = empty.reduce(|a, b| a + b);\n    }\n\n    #[test]\n    fn reduce_single() {\n        let slice = &[42];\n        let result = slice.reduce(|a, b| a + b);\n        assert_eq(result, 42);\n    }\n\n    #[test]\n    fn reduce_multiple() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.reduce(|a, b| a + b);\n        assert_eq(result, 10);\n    }\n\n    #[test]\n    fn filter_empty() {\n        let empty = &[];\n        let result = empty.filter(|x| x > 0);\n        assert_eq(result.len(), 0);\n    }\n\n    #[test]\n    fn filter_all_true() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.filter(|x| x > 0);\n        assert_eq(result, slice);\n    }\n\n    #[test]\n    fn filter_all_false() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.filter(|x| x > 10);\n        assert_eq(result.len(), 0);\n    }\n\n    #[test]\n    fn filter_some() {\n        let slice = &[1, 2, 3, 4, 5];\n        let result = slice.filter(|x| x % 2 == 0);\n        assert_eq(result, &[2, 4]);\n    }\n\n    #[test]\n    fn all_empty() {\n        let empty = &[];\n        let result = empty.all(|x| x > 0);\n        assert_eq(result, true);\n    }\n\n    #[test]\n    fn all_true() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.all(|x| x > 0);\n        assert_eq(result, true);\n    }\n\n    #[test]\n    fn all_false() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.all(|x| x > 2);\n        assert_eq(result, false);\n    }\n\n    #[test]\n    fn any_empty() {\n        let empty = &[];\n        let result = empty.any(|x| x > 0);\n        assert_eq(result, false);\n    }\n\n    #[test]\n    fn any_true() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.any(|x| x > 3);\n        assert_eq(result, true);\n    }\n\n    #[test]\n    fn any_false() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.any(|x| x > 10);\n        assert_eq(result, false);\n    }\n\n    // utility method tests\n    #[test]\n    fn append_empty_to_empty() {\n        let empty1: [Field] = &[];\n        let empty2: [Field] = &[];\n        let result = empty1.append(empty2);\n        assert_eq(result.len(), 0);\n    }\n\n    #[test]\n    fn append_empty_to_non_empty() {\n        let slice = &[1, 2, 3];\n        let empty = &[];\n        let result = slice.append(empty);\n        assert_eq(result, slice);\n    }\n\n    #[test]\n    fn append_non_empty_to_empty() {\n        let empty = &[];\n        let slice = &[1, 2, 3];\n        let result = empty.append(slice);\n        assert_eq(result, slice);\n    }\n\n    #[test]\n    fn append_two_non_empty() {\n        let slice1 = &[1, 2];\n        let slice2 = &[3, 4, 5];\n        let result = slice1.append(slice2);\n        assert_eq(result, &[1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    fn as_array_single() {\n        let slice = &[42];\n        let array: [Field; 1] = slice.as_array();\n        assert_eq(array[0], 42);\n    }\n\n    #[test]\n    fn as_array_multiple() {\n        let slice = &[1, 2, 3];\n        let array: [Field; 3] = slice.as_array();\n        assert_eq(array[0], 1);\n        assert_eq(array[1], 2);\n        assert_eq(array[2], 3);\n    }\n\n    // complex scenarios\n    #[test]\n    fn chain_operations() {\n        let slice = &[1, 2, 3, 4, 5];\n        let result = slice.filter(|x| x % 2 == 0).map(|x| x * 2).fold(0, |acc, x| acc + x);\n        assert_eq(result, 12); // (2*2) + (4*2) = 4 + 8 = 12\n    }\n\n    #[test]\n    fn nested_operations() {\n        let slice = &[1, 2, 3, 4];\n        let filtered = slice.filter(|x| x > 1);\n        let mapped = filtered.map(|x| x * x);\n        let sum = mapped.fold(0, |acc, x| acc + x);\n        assert_eq(sum, 29); // 2^2 + 3^2 + 4^2 = 4 + 9 + 16 = 29\n    }\n\n    #[test]\n    fn single_element_operations() {\n        let single = &[42];\n\n        // Test all operations on single element\n        assert_eq(single.len(), 1);\n\n        let pushed_back = single.push_back(99);\n        assert_eq(pushed_back, &[42, 99]);\n\n        let pushed_front = single.push_front(0);\n        assert_eq(pushed_front, &[0, 42]);\n\n        let (popped_back_slice, popped_back_elem) = single.pop_back();\n        assert_eq(popped_back_slice.len(), 0);\n        assert_eq(popped_back_elem, 42);\n\n        let (popped_front_elem, popped_front_slice) = single.pop_front();\n        assert_eq(popped_front_slice.len(), 0);\n        assert_eq(popped_front_elem, 42);\n\n        let inserted = single.insert(0, 0);\n        assert_eq(inserted, &[0, 42]);\n\n        let (removed_slice, removed_elem) = single.remove(0);\n        assert_eq(removed_slice.len(), 0);\n        assert_eq(removed_elem, 42);\n    }\n\n    #[test]\n    fn boundary_conditions() {\n        let slice = &[1, 2, 3];\n\n        // insert at boundaries\n        let at_start = slice.insert(0, 0);\n        assert_eq(at_start, &[0, 1, 2, 3]);\n\n        let at_end = slice.insert(3, 4);\n        assert_eq(at_end, &[1, 2, 3, 4]);\n\n        // remove at boundaries\n        let (removed_start, elem_start) = slice.remove(0);\n        assert_eq(removed_start, &[2, 3]);\n        assert_eq(elem_start, 1);\n\n        let (removed_end, elem_end) = slice.remove(2);\n        assert_eq(removed_end, &[1, 2]);\n        assert_eq(elem_end, 3);\n    }\n\n    #[test]\n    fn complex_predicates() {\n        let slice = &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\n        let even_greater_than_5 = slice.filter(|x| (x % 2 == 0) & (x > 5));\n        assert_eq(even_greater_than_5, &[6, 8, 10]);\n\n        let all_positive_and_less_than_20 = slice.all(|x| (x > 0) & (x < 20));\n        assert_eq(all_positive_and_less_than_20, true);\n\n        let any_divisible_by_7 = slice.any(|x| x % 7 == 0);\n        assert_eq(any_divisible_by_7, true);\n    }\n\n    #[test]\n    fn identity_operations() {\n        let slice = &[1, 2, 3, 4, 5];\n\n        let mapped_identity = slice.map(|x| x);\n        assert_eq(mapped_identity, slice);\n\n        let filtered_all = slice.filter(|_| true);\n        assert_eq(filtered_all, slice);\n\n        let filtered_none = slice.filter(|_| false);\n        assert_eq(filtered_none.len(), 0);\n    }\n\n    #[test(should_fail)]\n    fn as_array_size_mismatch() {\n        let slice = &[1, 2, 3];\n        let _: [Field; 5] = slice.as_array(); // size doesn't match\n    }\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        if result {\n            for i in 0..self.len() {\n                result &= self[i].eq(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let self_len = self.len();\n        let other_len = other.len();\n        let min_len = if self_len < other_len {\n            self_len\n        } else {\n            other_len\n        };\n\n        let mut result = Ordering::equal();\n        for i in 0..min_len {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self_len.cmp(other_len)\n        }\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use super::{Eq, max, min, Ord};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n\n    #[test]\n    fn correctly_handles_unequal_length_slices() {\n        let slice_1 = &[0, 1, 2, 3];\n        let slice_2 = &[0, 1, 2];\n        assert(!slice_1.eq(slice_2));\n    }\n\n    #[test]\n    fn lexicographic_ordering_for_slices() {\n        assert(&[2_u32].cmp(&[1_u32, 1_u32, 1_u32]) == super::Ordering::greater());\n        assert(&[1_u32, 2_u32].cmp(&[1_u32, 2_u32, 3_u32]) == super::Ordering::less());\n    }\n}\n"
    },
    "51": {
      "path": "/home/jpag/Playground/aztec/crosschain/wormhole-demo/packages/aztec/src/message_bridge/src/main.nr",
      "source": "use aztec::macros::aztec;\n\npub mod config;\npub mod utils;\n\n#[aztec]\npub contract MessageBridge {\n    use aztec::{\n        macros::{\n            functions::{initializer, external, internal},\n            storage::storage,\n        },\n        protocol_types::address::AztecAddress,\n        state_vars::{map::Map, public_mutable::PublicMutable, public_immutable::PublicImmutable},\n    };\n    use crate::{\n        config::Config,\n        utils::{\n            vaa::{encode_message_payload, decode_message_payload},\n            address_to_bytes32, DecodedVAAPayload, WORMHOLE_MESSAGE_ID\n        },\n    };\n    use wormhole::Wormhole;\n\n    // ============================================================================\n    // STORAGE\n    // ============================================================================\n\n    #[storage]\n    struct Storage<Context> {\n        // Core configuration (immutable after deployment)\n        config: PublicImmutable<Config, Context>,\n\n        // Owner/admin address\n        owner: PublicMutable<AztecAddress, Context>,\n\n        // Registered emitters\n        // chain id => source chain address => is_registered\n        registered_emitters: Map<u16, Map<Field, PublicImmutable<bool, Context>, Context>, Context>,\n\n        // currently stored value\n        current_value: PublicMutable<u8, Context>,\n    }\n\n    // ============================================================================\n    // INITIALIZATION\n    // ============================================================================\n\n    #[external(\"public\")]\n    #[initializer]\n    fn constructor(\n        wormhole_address: AztecAddress,\n        chain_id: u16,\n        owner: AztecAddress,\n        message_fee: u128,\n    ) {\n        storage.config.initialize(Config::new(\n            wormhole_address,\n            chain_id,\n            message_fee,\n        ));\n        storage.owner.write(owner);\n\n        // Initialize last received values to zero\n        storage.current_value.write(0);\n    }\n\n    #[external(\"public\")]\n    fn register_emitter(source_chain_id: u16, emitter_address: [u8; 32]) {\n        // 1. check caller is admin\n        let owner = storage.owner.read();\n        assert(owner == context.msg_sender().unwrap(), \"Caller is not owner\");\n\n        // 2. pack eth address into a field\n        let  mut emitter_address_truncated = [0; 31];\n        for i in 0..31 {\n            emitter_address_truncated[i] = emitter_address[i];\n        }\n        let emitter_address_field = Field::from_le_bytes(emitter_address_truncated);\n\n        // 3. register emitter\n        storage.registered_emitters\n            .at(source_chain_id)\n            .at(emitter_address_field)\n            .initialize(true);\n    }\n\n    // ============================================================================\n    // SEND MESSAGE (Aztec -> EVM)\n    // ============================================================================\n\n    #[external(\"public\")]\n    fn send_value_public(\n        destination_chain_id: u16,\n        value: u8,\n        fee_nonce: Field,\n    ) {\n        // no auth checks\n        let caller = context.msg_sender().unwrap();\n        let config = storage.config.read();\n\n        // 1. Encode the message payload\n        let wormhole_payload = encode_message_payload(\n            address_to_bytes32(caller),\n            value,\n            config.chain_id,\n            destination_chain_id,\n        );\n\n        // 2. Publish message publicly through Wormhole\n        let _ = Wormhole::at(config.wormhole_address).publish_message_in_public(\n            0, // nonce\n            wormhole_payload,\n            config.message_fee,\n            1, // consistency level (1 = confirmed)\n            caller,\n            fee_nonce,\n        ).call(&mut context);\n    }\n\n    #[external(\"private\")]\n    fn send_value_private(\n        destination_chain_id: u16,\n        value: u8,\n        fee_nonce: Field,\n    ) {\n        // no auth checks\n        let caller = context.msg_sender().unwrap();\n        let config = storage.config.read();\n        // 1. Encode the message payload\n        let wormhole_payload = encode_message_payload(\n            address_to_bytes32(caller),\n            value,\n            config.chain_id,\n            destination_chain_id,\n        );\n\n        // Publish message publicly through Wormhole\n        let _ = Wormhole::at(config.wormhole_address).publish_message_in_private(\n            0, // nonce\n            wormhole_payload,\n            config.message_fee,\n            1, // consistency level (1 = confirmed)\n            caller,\n            fee_nonce,\n        ).call(&mut context);\n    }\n\n    // ============================================================================\n    // RECEIVE MESSAGE (EVM -> Aztec)\n    // ============================================================================\n    \n    #[external(\"private\")]\n    fn receive_value(vaa: [u8; 2000], length: u32) {\n        // 1. verify the VAA through Wormhole\n        let config = storage.config.read();\n        Wormhole::at(config.wormhole_address).verify_vaa(vaa, length).call(&mut context);\n        // 2. extract and decode the paylod\n        let decoded_message = decode_message_payload(vaa);\n        // 3. validate destination chain is this chain\n        assert(\n            decoded_message.destination_chain_id == config.chain_id,\n            \"Invalid destination chain ID\"\n        );\n        // 4. validate emitter for source chain\n        let is_registered_emitter = storage.registered_emitters\n            .at(decoded_message.source_chain_id)\n            .at(decoded_message.sender)\n            .read();\n        assert(is_registered_emitter, \"Emitter not registered\");\n        // 5. emit the nullifier to prevent replays\n        // note: will fail if nullifier has already been emitted\n        context.push_nullifier(decoded_message.nullifier);\n        // 6. update state with received value\n        MessageBridge::at(context.this_address())\n            ._update_value(decoded_message.value)\n            .enqueue(&mut context);\n    }\n\n    #[external(\"public\")]\n    #[internal]\n    fn _update_value(value: u8) {\n        storage.current_value.write(value);\n    }\n\n    // ============================================================================\n    // VIEW FUNCTIONS\n    // ============================================================================\n\n    #[external(\"utility\")]\n    unconstrained fn get_config() -> Config {\n        storage.config.read()\n    }\n\n    #[external(\"utility\")]\n    unconstrained fn get_owner() -> AztecAddress {\n        storage.owner.read()\n    }\n\n    #[external(\"utility\")]\n    unconstrained fn is_emitter_registered(chain_id: u16, emitter_address: [u8; 32]) -> bool {\n        // pack eth address into a field\n        let mut emitter_address_truncated = [0; 31];\n        for i in 0..31 {\n            emitter_address_truncated[i] = emitter_address[i];\n        }\n        let emitter_address_field = Field::from_le_bytes(emitter_address_truncated);\n\n        storage.registered_emitters\n            .at(chain_id)\n            .at(emitter_address_field)\n            .read()\n    }\n\n    #[external(\"utility\")]\n    unconstrained fn get_current_value() -> u8 {\n        storage.current_value.read()\n    }\n}\n"
    },
    "52": {
      "path": "/home/jpag/Playground/aztec/crosschain/wormhole-demo/packages/aztec/src/message_bridge/src/utils/mod.nr",
      "source": "pub mod vaa;\n\nuse aztec::protocol_types::{\n    address::AztecAddress,\n    traits::ToField,\n};\nuse nodash::ArrayExtensions;\n\n/// Wormhole Payload ID for simple value messages\npub global WORMHOLE_MESSAGE_ID: u8 = 99;\npub global VAA_BODY_START: u32 = 6 + 66; // hardcoded as 1 signature\npub global VAA_MAX_LENGTH: u32 = 2000; // max VAA length in Wormhole spec\npub global VAA_BODY_MAX_LENGTH: u32 = 1860; // max body length in Wormhole VAA spec\n// we know the actual payload length we will always observe\npub global MESSAGE_PAYLOAD_LENGTH: u32 = 39; \npub global MESSAGE_NULLIFIER_LENGTH: u32 = VAA_BODY_START + MESSAGE_PAYLOAD_LENGTH;\npub global MESSAGE_NULLIFIER_PACKED_LENGTH: u32 = 4; // ceil(MESSAGE_NULLIFIER_LENGTH / 31)\n\npub struct DecodedVAAPayload {\n    pub value: u8,\n    pub source_chain_id: u16,\n    pub destination_chain_id: u16,\n    pub sender: Field,\n    pub nullifier: Field\n}\n\n\npub fn address_to_bytes32(addr: AztecAddress) -> [u8; 32] {\n    addr.to_field().to_be_bytes()\n}\n\npub fn u16_to_u8(value: u16) -> [u8; 2] {\n    // Safety: constrained below, use unconstrained for bitwise ops\n    let decomposed = unsafe { _u16_to_u8(value) };\n    let asserted = decomposed[0] as u16 * 256 + decomposed[1] as u16;\n    assert(asserted == value, \"u16 to u8 conversion failed\");\n    decomposed\n}\n\nunconstrained pub fn _u16_to_u8(value: u16) -> [u8; 2]{\n    let high = (value >> 8) as u8;\n    let low = (value & 0xFF) as u8;\n    [high, low]\n}\n\n// https://github.com/olehmisar/nodash/blob/main/src/array.nr#L42C1-L50C2\n// cannot import from nodash because of private dependency\npub fn pack_bytes<let N: u32>(bytes: [u8; N]) -> [Field; N / 31 + 1] {\n    let bytes_padded = bytes.pad_end::<(N / 31 + 1) * 31>(0);\n    let mut res = [0 as Field; N / 31 + 1];\n    for i in 0..N / 31 + 1 {\n        let chunk = bytes_padded.slice::<31>(i * 31);\n        res[i] = Field::from_le_bytes(chunk);\n    }\n    res\n}"
    },
    "53": {
      "path": "/home/jpag/Playground/aztec/crosschain/wormhole-demo/packages/aztec/src/message_bridge/src/utils/vaa.nr",
      "source": "use keccak256::keccak256;\nuse poseidon::poseidon2::Poseidon2;\nuse crate::utils::{\n    WORMHOLE_MESSAGE_ID,\n    VAA_MAX_LENGTH,\n    VAA_BODY_START,\n    MESSAGE_PAYLOAD_LENGTH,\n    DecodedVAAPayload,\n    MESSAGE_NULLIFIER_LENGTH,\n    MESSAGE_NULLIFIER_PACKED_LENGTH,\n    pack_bytes,\n    u16_to_u8\n};\n\npub fn decode_message_payload(vaa: [u8; VAA_MAX_LENGTH]) -> DecodedVAAPayload {\n    // 1. parse the actual bytes we care about\n    // note: we could skip this and directly read from vaa with offsets for slight efficiency gain\n    let mut message_bytes = [0; MESSAGE_PAYLOAD_LENGTH];\n    for i in 0..MESSAGE_PAYLOAD_LENGTH {\n        message_bytes[i] = vaa[VAA_BODY_START + i];\n    }\n    // 2. extract the wormhole message id and constrain\n    let message_id = message_bytes[0];\n    assert(message_id == WORMHOLE_MESSAGE_ID, \"Invalid payload ID\");\n    // 3. extract the source chain\n    let source_chain_id = (message_bytes[1] as u16) * 256 + (message_bytes[2] as u16);\n    // 4. extract the destination chain\n    let destination_chain_id = (message_bytes[3] as u16) * 256 + (message_bytes[4] as u16);\n    // 5. extract the sender address\n    // note: we only take first 31 bytes\n    let mut sender_bytes = [0; 31];\n    for i in 0..31 {\n        sender_bytes[i] = message_bytes[5 + i];\n    }\n    let sender = Field::from_le_bytes(sender_bytes);\n    // 6. extract the value\n    let value = message_bytes[38];\n    // 7. compute nullifier\n    let mut nullifier_preimage_bytes = [0; MESSAGE_NULLIFIER_LENGTH];\n    let message_packed = pack_bytes(message_bytes);\n    let nullifier = Poseidon2::hash(message_packed, MESSAGE_NULLIFIER_PACKED_LENGTH);\n    \n    DecodedVAAPayload {\n        value,\n        source_chain_id,\n        destination_chain_id,\n        sender,\n        nullifier,\n    }\n}\n\n/// Encode message payload into Wormhole message format\n///\n/// The Wormhole contract converts each 31-byte chunk to a Field using from_le_bytes(),\n/// which reverses the byte order. When guardians serialize the Field back to 32 bytes\n/// (big-endian), the bytes appear reversed.\n///\n/// To ensure the value ends up at a predictable location in the final EVM payload,\n/// we place it at position 0 of a chunk. After little-endian reversal and 32-byte\n/// Field serialization, it will appear at the last position (byte 31) of that Field.\n///\n/// Payload structure (248 bytes = 8 chunks of 31 bytes):\n/// - Chunk 0 (bytes 0-30):   [value, srcChainHi, srcChainLo, dstChainHi, dstChainLo, payloadId, zeros...]\n/// - Chunk 1 (bytes 31-61):  [sender bytes 0-30]\n/// - Chunk 2 (bytes 62-92):  [sender byte 31, zeros...]\n/// - Chunks 3-7: zeros\n///\n/// After guardian serialization (5 header Fields + 8 payload Fields = 13 Fields x 32 bytes):\n/// The EVM receives a payload where:\n/// - Bytes 0-159: Header (sender, sequence, nonce, consistency, timestamp)\n/// - Bytes 160-191: Field 5 = reversed chunk 0\n/// - Bytes 192-223: Field 6 = reversed chunk 1\n/// etc.\n///\n/// Value will be at: 160 (header) + 31 (last byte of reversed chunk 0) = byte 191\n///\n/// Returns [[u8; 31]; 8] for Wormhole publish_message (248 bytes total)\npub fn encode_message_payload(\n    sender: [u8; 32],\n    value: u8,\n    source_chain_id: u16,\n    destination_chain_id: u16,\n) -> [[u8; 31]; 8] {\n    let mut wormhole_payload: [[u8; 31]; 8] = [[0; 31]; 8];\n\n    // Chunk 0: Control data\n    let source_chain_bytes = u16_to_u8(source_chain_id);\n    let destination_chain_bytes = u16_to_u8(destination_chain_id);\n    wormhole_payload[0][0] = WORMHOLE_MESSAGE_ID;\n    wormhole_payload[0][1] = source_chain_bytes[0];\n    wormhole_payload[0][2] = source_chain_bytes[1];\n    wormhole_payload[0][3] = destination_chain_bytes[0];\n    wormhole_payload[0][4] = destination_chain_bytes[1];\n\n    // Chunk 0: pack the bytes 0-25 of the sender\n    for i in 0..25 {\n        wormhole_payload[0][5 + i] = sender[i];\n    }\n\n    // Chunk 1: pack bytes 26-31 of the sender\n    for i in 0..6 {\n        wormhole_payload[1][i] = sender[26 + i];\n    }\n\n    // Chunk 2: place value at position 6\n    wormhole_payload[2][6] = value;\n\n    wormhole_payload\n}\n\n\n// actual constrained keccak hash of vaa body\npub fn compute_vaa_hash(body_bytes: [u8; 1860], body_length: u32) -> [u8; 32] {\n    // Extract only the actual body content\n    let mut actual_body = [0; 1860];\n    for i in 0..body_length {\n        actual_body[i] = body_bytes[i];\n    }\n\n    // Double hash as per Wormhole spec\n    let hash: [u8; 32] = keccak256(actual_body, body_length);\n    let double_hash: [u8; 32] = keccak256(hash, 32);\n\n    double_hash\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0, \"cannot pop from an empty vector\");\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            let _ = vec.get(0);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_beyond_length() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            let _ = vec.get(3);\n        }\n\n        #[test]\n        fn get_works_within_bounds() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(2), 3);\n            assert_eq(vec.get(4), 5);\n        }\n\n        #[test]\n        fn get_unchecked_works() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(0), 1);\n            assert_eq(vec.get_unchecked(2), 3);\n        }\n\n        #[test]\n        fn get_unchecked_works_past_len() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(4), 0);\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_setting_beyond_length() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            vec.set(3, 4);\n        }\n\n        #[test]\n        fn set_unchecked_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(0, 10);\n            assert_eq(vec.get(0), 10);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn set_unchecked_operations_past_len() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(3, 40);\n            assert_eq(vec.get(3), 40);\n        }\n\n        #[test]\n        fn set_preserves_other_elements() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            vec.set(2, 30);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 30);\n            assert_eq(vec.get(3), 4);\n            assert_eq(vec.get(4), 5);\n        }\n    }\n\n    mod any {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn returns_false_if_predicate_not_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, false, false]);\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn returns_true_if_predicate_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, true, true]);\n            let result = vec.any(|value| value);\n\n            assert(result);\n        }\n\n        #[test]\n        fn returns_false_on_empty_boundedvec() {\n            let vec: BoundedVec<bool, 0> = BoundedVec::new();\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn any_with_complex_predicates() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            assert(vec.any(|x| x > 3));\n            assert(!vec.any(|x| x > 10));\n            assert(vec.any(|x| x % 2 == 0)); // has a even number\n            assert(vec.any(|x| x == 3)); // has a specific value\n        }\n\n        #[test]\n        fn any_with_partial_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            assert(vec.any(|x| x == 1));\n            assert(vec.any(|x| x == 2));\n            assert(!vec.any(|x| x == 3));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn map_with_conditional_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.map(|x| if x % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([1, 4, 3, 8]);\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn map_preserves_length() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|x| x * 2);\n\n            assert_eq(result.len(), vec.len());\n            assert_eq(result.max_len(), vec.max_len());\n        }\n\n        #[test]\n        fn map_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let result = vec.map(|x| x * 2);\n            assert_eq(result, vec);\n            assert_eq(result.len(), 0);\n            assert_eq(result.max_len(), 5);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn mapi_with_index_branching_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.mapi(|i, x| if i % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([2, 2, 6, 4]);\n            assert_eq(result, expected);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_each_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_each(|_| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_each_with_side_effects() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let mut seen = BoundedVec::<u32, 3>::new();\n            let seen_ref = &mut seen;\n            vec.for_each(|x| seen_ref.push(x));\n            assert_eq(seen, vec);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_eachi_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_eachi(|_, _| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_eachi_with_index_tracking() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([10, 20, 30]);\n            let mut indices = BoundedVec::<u32, 3>::new();\n            let indices_ref = &mut indices;\n            vec.for_eachi(|i, _| indices_ref.push(i));\n\n            let expected = BoundedVec::from_array([0, 1, 2]);\n            assert_eq(indices, expected);\n        }\n\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n\n        #[test]\n        fn from_array_preserves_order() {\n            let array = [5, 3, 1, 4, 2];\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array(array);\n            for i in 0..array.len() {\n                assert_eq(vec.get(i), array[i]);\n            }\n        }\n\n        #[test]\n        fn from_array_with_different_types() {\n            let bool_array = [true, false, true];\n            let bool_vec: BoundedVec<bool, 3> = BoundedVec::from_array(bool_array);\n            assert_eq(bool_vec.len(), 3);\n            assert_eq(bool_vec.get(0), true);\n            assert_eq(bool_vec.get(1), false);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n\n    mod push_pop {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn push_and_pop_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            assert_eq(vec.len(), 0);\n\n            vec.push(1);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 1);\n\n            vec.push(2);\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.get(1), 2);\n\n            let popped = vec.pop();\n            assert_eq(popped, 2);\n            assert_eq(vec.len(), 1);\n\n            let popped2 = vec.pop();\n            assert_eq(popped2, 1);\n            assert_eq(vec.len(), 0);\n        }\n\n        #[test(should_fail_with = \"push out of bounds\")]\n        fn push_to_full_vector() {\n            let mut vec: BoundedVec<u32, 2> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n            vec.push(3); // should panic\n        }\n\n        #[test(should_fail_with = \"cannot pop from an empty vector\")]\n        fn pop_from_empty_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let _ = vec.pop(); // should panic\n        }\n\n        #[test]\n        fn push_pop_cycle() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n\n            // push to full\n            vec.push(1);\n            vec.push(2);\n            vec.push(3);\n            assert_eq(vec.len(), 3);\n\n            // pop all\n            assert_eq(vec.pop(), 3);\n            assert_eq(vec.pop(), 2);\n            assert_eq(vec.pop(), 1);\n            assert_eq(vec.len(), 0);\n\n            // push again\n            vec.push(4);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 4);\n        }\n    }\n\n    mod extend {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn extend_from_array() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_slice() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_bounded_vec() {\n            let mut vec1: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut vec2: BoundedVec<u32, 3> = BoundedVec::new();\n\n            vec1.push(1);\n            vec2.push(2);\n            vec2.push(3);\n\n            vec1.extend_from_bounded_vec(vec2);\n\n            assert_eq(vec1.len(), 3);\n            assert_eq(vec1.get(0), 1);\n            assert_eq(vec1.get(1), 2);\n            assert_eq(vec1.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"extend_from_array out of bounds\")]\n        fn extend_array_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3, 4]); // should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_slice out of bounds\")]\n        fn extend_slice_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3, 4]); // S]should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_bounded_vec out of bounds\")]\n        fn extend_bounded_vec_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            let other: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            vec.extend_from_bounded_vec(other); // should panic\n        }\n\n        #[test]\n        fn extend_with_empty_collections() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let original_len = vec.len();\n\n            vec.extend_from_array([]);\n            assert_eq(vec.len(), original_len);\n\n            vec.extend_from_slice(&[]);\n            assert_eq(vec.len(), original_len);\n\n            let empty: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.extend_from_bounded_vec(empty);\n            assert_eq(vec.len(), original_len);\n        }\n    }\n\n    mod storage {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn storage_consistency() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            // test initial storage state\n            assert_eq(vec.storage(), [0, 0, 0, 0, 0]);\n\n            vec.push(1);\n            vec.push(2);\n\n            // test storage after modifications\n            assert_eq(vec.storage(), [1, 2, 0, 0, 0]);\n\n            // storage doesn't change length\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.max_len(), 5);\n        }\n\n        #[test]\n        fn storage_after_pop() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n\n            let _ = vec.pop();\n            // after pop, the last element should be zeroed\n            assert_eq(vec.storage(), [1, 2, 0]);\n            assert_eq(vec.len(), 2);\n        }\n\n        #[test]\n        fn vector_immutable() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let storage = vec.storage();\n\n            assert_eq(storage, [1, 2, 3]);\n\n            // Verify that the original vector is unchanged\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n    }\n}\n"
    },
    "62": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push(self, value: T)\n    where\n        T: Serialize,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get(self, index: u32) -> T\n    where\n        T: Deserialize,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n\n    global SLOT: Field = 1230;\n\n    #[test]\n    unconstrained fn empty_array() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            let _: Field = array.get(0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            assert_eq(array.len(), 1);\n            assert_eq(array.get(0), 5);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            let _ = array.get(1);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(5);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            assert_eq(array.len(), 3);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 8);\n            assert_eq(array.get(2), 9);\n\n            array.remove(1);\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 9);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            array.remove(1);\n            array.remove(1);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n            // we do not care about the order in which each tuple was passed to the closure.\n            let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n            array.for_each(|index, value| { called_with.push((index, value)); });\n\n            assert_eq(called_with.len(), 3);\n            assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n            assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n            assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| {\n                if index == 1 {\n                    array.remove(index);\n                }\n            });\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 4);\n            assert_eq(array.get(1), 6);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all_no_copy() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We test that the utilityCopyCapsule was never called, which is the expensive operation we want to avoid.\n            let mock = std::test::OracleMock::mock(\"utilityCopyCapsule\");\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(mock.times_called(), 0);\n        });\n    }\n}\n"
    },
    "63": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PrivateCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    /// Makes the call to this private function.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// This enables contracts to interact with each other while maintaining\n    /// privacy. This \"composability\" of private contract functions is a key\n    /// feature of the Aztec network.\n    ///\n    /// If a user's transaction includes multiple private function calls, then\n    /// by the design of Aztec, the following information will remain private[1]:\n    /// - The function selectors and contract addresses of all private function\n    ///   calls will remain private, so an observer of the public mempool will\n    ///   not be able to look at a tx and deduce which private functions have\n    ///   been executed.\n    /// - The arguments and return values of all private function calls will\n    ///   remain private.\n    /// - The person who initiated the tx will remain private.\n    /// - The notes and nullifiers and private logs that are emitted by all\n    ///   private function calls will (if designed well) not leak any user\n    ///   secrets, nor leak which functions have been executed.\n    ///\n    /// [1] Caveats: Some of these privacy guarantees depend on how app\n    /// developers design their smart contracts. Some actions _can_ leak\n    /// information, such as:\n    /// - Calling an internal public function.\n    /// - Calling a public function and not setting msg_sender to Option::none\n    ///   (see https://github.com/AztecProtocol/aztec-packages/pull/16433)\n    /// - Calling any public function will always leak details about the nature\n    ///   of the transaction, so devs should be careful in their contract\n    ///   designs. If it can be done in a private function, then that will give\n    ///   the best privacy.\n    /// - Not padding the side-effects of a tx to some standardised, uniform\n    ///   size. The kernel circuits can take hints to pad side-effects, so a\n    ///   wallet should be able to request for a particular amount of padding.\n    ///   Wallets should ideally agree on some standard.\n    ///   - Padding should include:\n    ///     - Padding the lengths of note & nullifier arrays\n    ///     - Padding private logs with random fields, up to some standardised\n    ///       size.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Advanced\n    /// * The call is added to the private call stack and executed by kernel\n    ///   circuits after this function completes\n    /// * The called function can modify its own contract's private state\n    /// * Side effects from the called function are included in this transaction\n    /// * The call inherits the current transaction's context and gas limits\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub fn call(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n\n        // If T is () (i.e. if the function does not return anything) then `get_preimage` will constrain that the\n        // returns hash is empty as per the protocol rules.\n        returns_hash.get_preimage()\n    }\n\n    /// Makes a _read-only_ call to this private function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// See `call` for more general info on private function calls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub fn view(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        // If T is () (i.e. if the function does not return anything) then `get_preimage` will constrain that the\n        // returns hash is empty as per the protocol rules.\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PrivateCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PrivateStaticCallInterface<M, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    /// Makes a read-only call to this private function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn view(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PrivateStaticCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PublicCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    /// Makes the call to this public function.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[external(\"public\")] function as `context`, through the\n    ///               #[external(\"public\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn call(self, context: &mut PublicContext) -> T {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        // If T is () (i.e. if the function does not return anything) then `as_array` will constrain that `returns` has\n        // a length of 0 (since that is ()'s deserialization length).\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Makes a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[external(\"public\")] function as `context`, through the\n    ///               #[external(\"public\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn view(self, context: &mut PublicContext) -> T {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        // If T is () (i.e. if the function does not return anything) then `as_array` will constrain that `returns` has\n        // a length of 0 (since that is ()'s deserialization length).\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Enqueues a call to this public function, to be executed later.\n    ///\n    /// Unlike private functions which execute immediately on the user's device,\n    /// public function calls are \"enqueued\" and executed some time later by a\n    /// block proposer.\n    ///\n    /// This means a public function cannot return any values back to a private\n    /// function, because by the time the public function is being executed,\n    /// the private function which called it has already completed execution.\n    /// (In fact, the private function has been executed and proven, along with\n    /// all other private function calls of the user's tx. A single proof of the\n    /// tx has been submitted to the Aztec network, and some time later a\n    /// proposer has picked the tx up from the mempool and begun executing all\n    /// of the enqueued public functions).\n    ///\n    /// # Privacy warning\n    /// Enqueueing a public function call is an inherently leaky action.\n    /// Many interesting applications will require some interaction with public\n    /// state, but smart contract developers should try to use public function\n    /// calls sparingly, and carefully.\n    /// _Internal_ public function calls are especially leaky, because they\n    /// completely leak which private contract made the call.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        self.enqueue_impl(context, false, false)\n    }\n\n    /// Enqueues a call to this public function, to be executed later.\n    ///\n    /// As per `enqueue`, but hides this calling contract's address from the\n    /// target public function.\n    /// This means the origin of the call (msg_sender) will not be publicly\n    /// visible to any blockchain observers, nor to the target public function.\n    /// When the target public function reads `context.msg_sender()` it will\n    /// receive an `Option<AztecAddress>::none`.\n    ///\n    /// NOTES:\n    /// - Not all public functions will accept a msg_sender of \"none\". Many\n    ///   public functions will require that msg_sender is \"some\" and will\n    ///   revert otherwise. Therefore, if using `enqueue_incognito`, you must\n    ///   understand whether the function you're calling will accept a\n    ///   msg_sender of \"none\".\n    ///   Lots of public bookkeeping patterns rely on knowing which address made\n    ///   the call, so as to ascribe state against the caller's address.\n    ///   (There are patterns whereby bookkeeping could instead be done in\n    ///   private-land).\n    /// - If you are enqueueing a call to an _internal_ public function (i.e.\n    ///   a public function that will only accept calls from other functions\n    ///   of its own contract), then by definition a call to it cannot possibly\n    ///   be \"incognito\": the msg_sender must be its own address, and indeed the\n    ///   called public function will assert this. Tl;dr this is not usable for\n    ///   enqueued internal public calls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    /// Advanced:\n    /// - The kernel circuits will permit _any_ private function to set the\n    ///   msg_sender field of any enqueued public function call to\n    ///   NULL_MSG_SENDER_CONTRACT_ADDRESS.\n    /// - When the called public function calls `PublicContext::msg_sender()`,\n    ///   aztec-nr will translate NULL_MSG_SENDER_CONTRACT_ADDRESS into\n    ///   `Option<AztecAddress>::none` for familiarity to devs.\n    ///\n    pub fn enqueue_incognito(self, context: &mut PrivateContext) {\n        self.enqueue_impl(context, false, true)\n    }\n\n    /// Enqueues a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        self.enqueue_impl(context, true, false)\n    }\n\n    /// Enqueues a read-only call to this public function.\n    ///\n    /// As per `enqueue_view`, but hides this calling contract's address from\n    /// the target public function.\n    ///\n    /// See `enqueue_incognito` for more details relating to hiding msg_sender.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn enqueue_view_incognito(self, context: &mut PrivateContext) {\n        self.enqueue_impl(context, true, true)\n    }\n\n    fn enqueue_impl(\n        self,\n        context: &mut PrivateContext,\n        is_static_call: bool,\n        hide_msg_sender: bool,\n    ) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            is_static_call,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a call to this public function, and designates it to be the\n    /// teardown function for this tx. Only one teardown function call can be\n    /// made by a tx.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase ensures the fee payer\n    /// has sufficient balance to pay the proposer their fees.\n    /// The teardown phase is primarily intended to: calculate exactly\n    /// how much the user owes, based on gas consumption, and refund the user\n    /// any change.\n    ///\n    /// Note: in some cases, the cost of refunding the user (i.e. DA costs of\n    /// tx side-effects) might exceed the refund amount. For app logic with\n    /// fairly stable and predictable gas consumption, a material refund amount\n    /// is unlikely. For app logic with unpredictable gas consumption, a\n    /// refund might be important to the user (e.g. if a hefty function reverts\n    /// very early). Wallet/FPC/Paymaster developers should be mindful of this.\n    ///\n    /// See `enqueue` for more information about enqueuing public function calls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        self.set_as_teardown_impl(context, false);\n    }\n\n    /// Enqueues a call to this public function, and designates it to be the teardown\n    /// function for this tx. Only one teardown function call can be made by a\n    /// tx.\n    ///\n    /// As per `set_as_teardown`, but hides this calling contract's address from\n    /// the target public function.\n    ///\n    /// See `enqueue_incognito` for more details relating to hiding msg_sender.\n    ///\n    pub fn set_as_teardown_incognito(self, context: &mut PrivateContext) {\n        self.set_as_teardown_impl(context, true);\n    }\n\n    fn set_as_teardown_impl(self, context: &mut PrivateContext, hide_msg_sender: bool) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PublicCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let M: u32, T> PublicStaticCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    /// Makes the read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[external(\"public\")] function as `context`, through the\n    ///               #[external(\"public\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn view(self, context: &mut PublicContext) -> T {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Enqueues a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n            false,\n        )\n    }\n\n    pub fn enqueue_view_incognito(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n            true,\n        )\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PublicStaticCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// UtilityCallInterface\n\npub struct UtilityCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n}\n\nimpl<let M: u32, T> CallInterface<M> for UtilityCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        false\n    }\n}\n\nimpl<let M: u32, T> UtilityCallInterface<M, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n\n    pub fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    pub fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    pub fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    pub fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n}\n"
    },
    "70": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        logs::notify_created_contract_class_log,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        block_header::BlockHeader,\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log_hash::LogHash,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::{PrivateLog, PrivateLogData},\n        public_call_request::PublicCallRequest,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, MAX_CONTRACT_CLASS_LOGS_PER_CALL,\n        MAX_ENQUEUED_CALLS_PER_CALL, MAX_INCLUDE_BY_TIMESTAMP_DURATION,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        NULL_MSG_SENDER_CONTRACT_ADDRESS, PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    hash::poseidon2_hash,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    side_effect::Counted,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::{ClaimedLengthArray, trimmed_array_length_hint},\n};\n\n/// # PrivateContext\n///\n/// The **main interface** between an #[external(\"private\")] function and the Aztec blockchain.\n///\n/// An instance of the PrivateContext is initialized automatically at the outset\n/// of every private function, within the #[external(\"private\")] macro, so you'll never\n/// need to consciously instantiate this yourself.\n///\n/// The instance is always named `context`, and it is always be available within\n/// the body of every #[external(\"private\")] function in your smart contract.\n///\n/// > For those used to \"vanilla\" Noir, it might be jarring to have access to\n/// > `context` without seeing a declaration `let context = PrivateContext::new(...)`\n/// > within the body of your function. This is just a consequence of using\n/// > macros to tidy-up verbose boilerplate. You can use `nargo expand` to\n/// > expand all macros, if you dare.\n///\n/// Typical usage for a smart contract developer will be to call getter\n/// methods of the PrivateContext.\n///\n/// _Pushing_ data and requests to the context is mostly handled within\n/// aztec-nr's own functions, so typically a smart contract developer won't\n/// need to call any setter methods directly.\n///\n/// > Advanced users might occasionally wish to push data to the context\n/// > directly for lower-level control. If you find yourself doing this, please\n/// > open an issue on GitHub to describe your use case: it might be that\n/// > new functionality should be added to aztec-nr.\n///\n/// ## Responsibilities\n/// - Exposes contextual data to a private function:\n///   - Data relating to how this private function was called.\n///     - msg_sender\n///     - this_address - (the contract address of the private function being\n///                      executed)\n///     - See `CallContext` for more data.\n///   - Data relating to the transaction in which this private function is\n///     being executed.\n///     - chain_id\n///     - version\n///     - gas_settings\n/// - Provides state access:\n///   - Access to the \"Anchor block\" header.\n///     Recall, a private function cannot read from the \"current\" block header,\n///     but must read from some historical block header, because as soon as\n///     private function execution begins (asynchronously, on a user's device),\n///     the public state of the chain (the \"current state\") will have progressed\n///     forward. We call this reference the \"Anchor block\".\n///     See `BlockHeader`.\n///   - Enables consumption of L1->L2 messages.\n/// - Enables calls to functions of other smart contracts:\n///   - Private function calls\n///   - Enqueueing of public function call requests\n///     (Since public functions are executed at a later time, by a block\n///     proposer, we say they are \"enqueued\").\n/// - Writes data to the blockchain:\n///   - New notes\n///   - New nullifiers\n///   - Private logs (for sending encrypted note contents or encrypted events)\n///   - New L2->L1 messages.\n/// - Provides args to the private function (handled by the #[external(\"private\")] macro).\n/// - Returns the return values of this private function (handled by the\n///   #[external(\"private\")] macro).\n/// - Makes Key Validation Requests.\n///   - Private functions are not allowed to see master secret keys, because we\n///     do not trust them. They are instead given \"app-siloed\" secret keys with\n///     a claim that they relate to a master public key. They can then request\n///     validation of this claim, by making a \"key validation request\" to the\n///     protocol's kernel circuits (which _are_ allowed to see certain master\n///     secret keys).\n///\n/// ## Advanced Responsibilities\n///\n/// - Ultimately, the PrivateContext is responsible for constructing the\n///   PrivateCircuitPublicInputs of the private function being executed.\n///   All private functions on Aztec must have public inputs which adhere\n///   to the rigid layout of the PrivateCircuitPublicInputs, in order to be\n///   compatible with the protocol's kernel circuits.\n///   A well-known misnomer:\n///   - \"public inputs\" contain both inputs and outputs of this function.\n///     - By \"outputs\" we mean a lot more side-effects than just the\n///       \"return values\" of the function.\n///   - Most of the so-called \"public inputs\" are kept _private_, and never leak\n///     to the outside world, because they are 'swallowed' by the protocol's\n///     kernel circuits before the tx is sent to the network. Only the\n///     following are exposed to the outside world:\n///     - New note_hashes\n///     - New nullifiers\n///     - New private logs\n///     - New L2->L1 messages\n///     - New enqueued public function call requests\n///     All the above-listed arrays of side-effects can be padded by the\n///     user's wallet (through instructions to the kernel circuits, via the\n///     PXE) to obscure their true lengths.\n///\n/// ## Syntax Justification\n///\n/// Both user-defined functions _and_ most functions in aztec-nr need access to\n/// the PrivateContext instance to read/write data. This is why you'll see the\n/// arguably-ugly pervasiveness of the \"context\" throughout your smart contract\n/// and the aztec-nr library.\n/// For example, `&mut context` is prevalent. In some languages, you can access\n/// and mutate a global variable (such as a PrivateContext instance) from a\n/// function without polluting the function's parameters. With Noir, a function\n/// must explicitly pass control of a mutable variable to another function, by\n/// reference. Since many functions in aztec-nr need to be able to push new data\n/// to the PrivateContext, they need to be handed a mutable reference _to_ the\n/// context as a parameter.\n/// For example, `Context` is prevalent as a generic parameter, to give better\n/// type safety at compile time. Many `aztec-nr` functions don't make sense if\n/// they're called in a particular runtime (private, public or utility), and so\n/// are intentionally only implemented over certain\n/// [Private|Public|Utility]Context structs. This gives smart contract\n/// developers a much faster feedback loop if they're making a mistake, as an\n/// error will be thrown by the LSP or when they compile their contract.\n///\n#[derive(Eq)]\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub include_by_timestamp: u64,\n\n    pub note_hash_read_requests: BoundedVec<Counted<Field>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<Counted<Field>, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<Counted<NoteHash>, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Counted<Nullifier>, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<Counted<L2ToL1Message>, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub anchor_block_header: BlockHeader,\n\n    pub private_logs: BoundedVec<Counted<PrivateLogData>, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<Counted<LogHash>, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        let max_allowed_include_by_timestamp = inputs.anchor_block_header.global_variables.timestamp\n            + MAX_INCLUDE_BY_TIMESTAMP_DURATION;\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            include_by_timestamp: max_allowed_include_by_timestamp,\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            anchor_block_header: inputs.anchor_block_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: Since Aztec doesn't have a concept of an EoA (\n    /// Externally-owned Account), the msg_sender is \"null\" for the first\n    /// function call of every transaction.\n    /// The first function call of a tx is likely to be a call to the user's\n    /// account contract, so this quirk will most often be handled by account\n    /// contract developers.\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called\n    ///   this function (be it an app contract or a user's account contract).\n    ///   Returns `Option<AztecAddress>::none` for the first function call of\n    ///   the tx. No other _private_ function calls in the tx will have a `none`\n    ///   msg_sender, but _public_ function calls might (see the PublicContext).\n    ///\n    pub fn msg_sender(self) -> Option<AztecAddress> {\n        let maybe_msg_sender = self.inputs.call_context.msg_sender;\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// \"Unsafe\" versus calling `context.msg_sender()`, because it doesn't\n    /// translate `NULL_MSG_SENDER_CONTRACT_ADDRESS` as\n    /// `Option<AztecAddress>::none`.\n    /// Used by some internal aztecnr functions.\n    pub fn msg_sender_unsafe(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    /// Returns the contract address of the current function being executed.\n    ///\n    /// This is equivalent to `address(this)` in Solidity (hence the name).\n    /// Use this to identify the current contract's address, commonly needed for\n    /// access control or when interacting with other contracts.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The contract address of the current function being\n    ///                    executed.\n    ///\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    /// Returns the chain ID of the current network.\n    ///\n    /// This is similar to `block.chainid` in Solidity. Returns the unique\n    /// identifier for the blockchain network this transaction is executing on.\n    ///\n    /// Helps prevent cross-chain replay attacks. Useful if implementing\n    /// multi-chain contract logic.\n    ///\n    /// # Returns\n    /// * `Field` - The chain ID as a field element\n    ///\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    /// Returns the Aztec protocol version that this transaction is executing\n    /// under. Different versions may have different rules, opcodes, or\n    /// cryptographic primitives.\n    ///\n    /// This is similar to how Ethereum has different EVM versions.\n    ///\n    /// Useful for forward/backward compatibility checks\n    ///\n    /// Not to be confused with contract versions; this is the protocol version.\n    ///\n    /// # Returns\n    /// * `Field` - The protocol version as a field element\n    ///\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    /// Returns the gas settings for the current transaction.\n    ///\n    /// This provides information about gas limits and pricing for the\n    /// transaction, similar to `tx.gasprice` and gas limits in Ethereum.\n    /// However, Aztec has a more sophisticated gas model with separate\n    /// accounting for L2 computation and data availability (DA) costs.\n    ///\n    /// # Returns\n    /// * `GasSettings` - Struct containing gas limits and fee information\n    ///\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    /// Returns the function selector of the currently executing function.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to access this.\n    ///\n    /// This is similar to `msg.sig` in Solidity, which returns the first 4\n    /// bytes of the function signature. In Aztec, the selector uniquely\n    /// identifies which function within the contract is being called.\n    ///\n    /// # Returns\n    /// * `FunctionSelector` - The 4-byte function identifier\n    ///\n    /// # Advanced\n    /// Only #[external(\"private\")] functions have a function selector as a protocol-\n    /// enshrined concept. The function selectors of private functions are\n    /// baked into the preimage of the contract address, and are used by the\n    /// protocol's kernel circuits to identify each private function and ensure\n    /// the correct one is being executed.\n    ///\n    /// Used internally for function dispatch and call verification.\n    ///\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    ///\n    /// Very low-level function: You shouldn't need to call this. The #[external(\"private\")]\n    /// macro calls this, and it makes the arguments neatly available to the\n    /// body of your private function.\n    ///\n    /// # Returns\n    /// * `Field` - Hash of the function arguments\n    ///\n    /// # Advanced\n    /// * Arguments are hashed to reduce proof size and verification time\n    /// * Enables efficient argument passing in recursive function calls\n    /// * The hash can be used to retrieve the original arguments from the PXE.\n    ///\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    /// Pushes a new note_hash to the Aztec blockchain's global Note Hash Tree\n    /// (a state tree).\n    ///\n    /// A note_hash is a commitment to a piece of private state.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new note hashes.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The new note_hash.\n    ///\n    /// # Advanced\n    /// From here, the protocol's kernel circuits will take over and insert the\n    /// note_hash into the protocol's \"note hash tree\" (in the Base Rollup\n    /// circuit).\n    /// Before insertion, the protocol will:\n    /// - \"Silo\" the `note_hash` with the contract address of this function,\n    ///   to yield a `siloed_note_hash`. This prevents state collisions\n    ///   between different smart contracts.\n    /// - Ensure uniqueness of the `siloed_note_hash`, to prevent Faerie-Gold\n    ///   attacks, by hashing the `siloed_note_hash` with a unique value, to\n    ///   yield a `unique_siloed_note_hash` (see the protocol spec for more).\n    ///\n    /// In addition to calling this function, aztec-nr provides the contents\n    /// of the newly-created note to the PXE, via the `notify_created_note`\n    /// oracle.\n    ///\n    /// > Advanced users might occasionally wish to push data to the context\n    /// > directly for lower-level control. If you find yourself doing this,\n    /// > please open an issue on GitHub to describe your use case: it might be\n    /// > that new functionality should be added to aztec-nr.\n    ///\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(Counted::new(note_hash, self.next_counter()));\n    }\n\n    /// Pushes a new nullifier to the Aztec blockchain's global Nullifier Tree\n    /// (a state tree).\n    ///\n    /// See also: `push_nullifier_for_note_hash`.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifiers.\n    ///\n    /// A nullifier can only be emitted once. Duplicate nullifier insertions are\n    /// rejected by the protocol.\n    ///\n    /// Generally, a nullifier is emitted to prevent an action from happening\n    /// more than once, in such a way that the action cannot be linked (by an\n    /// observer of the blockchain) to any earlier transactions.\n    ///\n    /// I.e. a nullifier is a random-looking, but deterministic record of a\n    /// private, one-time action, which does not leak what action has been\n    /// taken, and which preserves the property of \"tx unlinkability\".\n    ///\n    /// Usually, a nullifier will be emitted to \"spend\" a note (a piece of\n    /// private state), without revealing which specific note is being spent.\n    ///\n    /// (Important: in such cases, use the below `push_nullifier_for_note_hash`).\n    ///\n    /// Sometimes, a nullifier might be emitted completely unrelated to any\n    /// notes. Examples include initialization of a new contract; initialization\n    /// of a PrivateMutable, or signalling in Semaphore-like applications.\n    /// This `push_nullifier` function serves such use cases.\n    ///\n    /// # Arguments\n    /// * `nullifier`\n    ///\n    /// # Advanced\n    /// From here, the protocol's kernel circuits will take over and insert the\n    /// nullifier into the protocol's \"nullifier tree\" (in the Base Rollup\n    /// circuit).\n    /// Before insertion, the protocol will:\n    /// - \"Silo\" the `nullifier` with the contract address of this function,\n    ///   to yield a `siloed_nullifier`. This prevents state collisions\n    ///   between different smart contracts.\n    /// - Ensure the `siloed_nullifier` is unique (the nullifier tree is an\n    ///   indexed merkle tree which supports efficient non-membership proofs).\n    ///\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: 0 }.count(self.next_counter()));\n    }\n\n    /// Pushes a nullifier that corresponds to a specific note hash.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifiers.\n    ///\n    /// This is a specialized version of `push_nullifier` that links a nullifier\n    /// to the specific note hash it's nullifying. This is the most common\n    /// usage pattern for nullifiers.\n    /// See `push_nullifier` for more explanation on nullifiers.\n    ///\n    /// # Arguments\n    /// * `nullifier`\n    /// * `nullified_note_hash` - The note hash of the note being nullified\n    ///\n    /// # Advanced\n    /// Important: usage of this function doesn't mean that the world will _see_\n    /// that this nullifier relates to the given nullified_note_hash (as that\n    /// would violate \"tx unlinkability\"); it simply informs the user's PXE\n    /// about the relationship (via `notify_nullified_note`). The PXE can then\n    /// use this information to feed hints to the kernel circuits for\n    /// \"squashing\" purposes: If a note is nullified during the same tx which\n    /// created it, we can \"squash\" (delete) the note and nullifier (and any\n    /// private logs associated with the note), to save on data emission costs.\n    ///\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash }.count(\n            nullifier_counter,\n        ));\n    }\n\n    /// Returns the anchor block header - the historical block header that this\n    /// private function is reading from.\n    ///\n    /// A private function CANNOT read from the \"current\" block header,\n    /// but must read from some older block header, because as soon as\n    /// private function execution begins (asynchronously, on a user's device),\n    /// the public state of the chain (the \"current state\") will have progressed\n    /// forward.\n    ///\n    /// # Returns\n    /// * `BlockHeader` - The anchor block header.\n    ///\n    /// # Advanced\n    /// * All private functions of a tx read from the same anchor block header.\n    /// * The protocol asserts that the `include_by_timestamp` of every tx\n    ///   is at most 24 hours beyond the timestamp of the tx's chosen anchor\n    ///   block header. This enables the network's nodes to safely prune old txs\n    ///   from the mempool. Therefore, the chosen block header _must_ be one\n    ///   from within the last 24 hours.\n    ///\n    pub fn get_anchor_block_header(self) -> BlockHeader {\n        self.anchor_block_header\n    }\n\n    /// Returns the header of any historical block at or before the anchor\n    /// block.\n    ///\n    /// This enables private contracts to access information from even older\n    /// blocks than the anchor block header.\n    ///\n    /// Useful for time-based contract logic that needs to compare against\n    /// multiple historical points.\n    ///\n    /// # Arguments\n    /// * `block_number` - The block number to retrieve (must be <= anchor\n    ///                    block number)\n    ///\n    /// # Returns\n    /// * `BlockHeader` - The header of the requested historical block\n    ///\n    /// # Advanced\n    /// This function uses an oracle to fetch block header data from the user's\n    /// PXE. Depending on how much blockchain data the user's PXE has been set\n    /// up to store, this might require a query from the PXE to another Aztec\n    /// node to get the data.\n    /// > This is generally true of all oracle getters (see `../oracle`).\n    ///\n    /// Each block header gets hashed and stored as a leaf in the protocol's\n    /// Archive Tree. In fact, the i-th block header gets stored at the i-th\n    /// leaf index of the Archive Tree. Behind the scenes, this\n    /// `get_block_header_at` function will add Archive Tree merkle-membership\n    /// constraints (~3k) to your smart contract function's circuit, to prove\n    /// existence of the block header in the Archive Tree.\n    ///\n    /// Note: we don't do any caching, so avoid making duplicate calls for the\n    /// same block header, because each call will add duplicate constraints.\n    ///\n    /// Calling this function is more expensive (constraint-wise) than getting\n    /// the anchor block header (via `get_block_header`). This is because the\n    /// anchor block's merkle membership proof is handled by Aztec's protocol\n    /// circuits, and is only performed once for the entire tx because all\n    /// private functions of a tx share a common anchor block header. Therefore,\n    /// the cost (constraint-wise) of calling `get_block_header` is effectively\n    /// free.\n    ///\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    /// Sets the hash of the return values for this private function.\n    ///\n    /// Very low-level function: this is called by the #[external(\"private\")] macro.\n    ///\n    /// # Arguments\n    /// * `serialized_return_values` - The serialized return values as a field array\n    ///\n    pub fn set_return_hash<let N: u32>(&mut self, serialized_return_values: [Field; N]) {\n        let return_hash = hash_args_array(serialized_return_values);\n        self.return_hash = return_hash;\n        execution_cache::store(serialized_return_values, return_hash);\n    }\n\n    /// Builds the PrivateCircuitPublicInputs for this private function, to\n    /// ensure compatibility with the protocol's kernel circuits.\n    ///\n    /// Very low-level function: This function is automatically called by the\n    /// #[external(\"private\")] macro.\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            include_by_timestamp: self.include_by_timestamp,\n            note_hash_read_requests: ClaimedLengthArray::from_bounded_vec(\n                self.note_hash_read_requests,\n            ),\n            nullifier_read_requests: ClaimedLengthArray::from_bounded_vec(\n                self.nullifier_read_requests,\n            ),\n            key_validation_requests_and_generators: ClaimedLengthArray::from_bounded_vec(\n                self.key_validation_requests_and_generators,\n            ),\n            note_hashes: ClaimedLengthArray::from_bounded_vec(self.note_hashes),\n            nullifiers: ClaimedLengthArray::from_bounded_vec(self.nullifiers),\n            private_call_requests: ClaimedLengthArray::from_bounded_vec(self.private_call_requests),\n            public_call_requests: ClaimedLengthArray::from_bounded_vec(self.public_call_requests),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: ClaimedLengthArray::from_bounded_vec(self.l2_to_l1_msgs),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: ClaimedLengthArray::from_bounded_vec(self.private_logs),\n            contract_class_logs_hashes: ClaimedLengthArray::from_bounded_vec(\n                self.contract_class_logs_hashes,\n            ),\n            anchor_block_header: self.anchor_block_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    /// Designates this contract as the fee payer for the transaction.\n    ///\n    /// Unlike Ethereum, where the transaction sender always pays fees, Aztec\n    /// allows any contract to voluntarily pay transaction fees. This enables\n    /// patterns like sponsored transactions or fee abstraction where users\n    /// don't need to hold fee-juice themselves. (Fee juice is a fee-paying\n    /// asset for Aztec).\n    ///\n    /// Only one contract per transaction can declare itself as the fee payer,\n    /// and it must have sufficient fee-juice balance (>= the gas limits\n    /// specified in the TxContext) by the time we reach the public setup phase\n    /// of the tx.\n    ///\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    /// Declares the end of the \"setup phase\" of this tx.\n    ///\n    /// Only one function per tx can declare the end of the setup phase.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase enables such a payment to\n    /// be made, because the setup phase _cannot revert_: a reverting function\n    /// within the setup phase would result in an invalid block which cannot\n    /// be proven. Any side-effects generated during that phase are guaranteed\n    /// to be inserted into Aztec's state trees (except for squashed notes &\n    /// nullifiers, of course).\n    ///\n    /// Even though the end of the setup phase is declared within a private\n    /// function, you might have noticed that _public_ functions can also\n    /// execute within the setup phase. This is because any public function\n    /// calls which were enqueued _within the setup phase_ by a private\n    /// function are considered part of the setup phase.\n    ///\n    /// # Advanced\n    /// * Sets the minimum revertible side effect counter of this tx to be the\n    /// PrivateContext's _current_ side effect counter.\n    ///\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    /// Sets a deadline (an \"include-by timestamp\") for when this transaction\n    /// must be included in a block.\n    ///\n    /// Other functions in this tx might call this setter with differing\n    /// values for the include-by timestamp. To ensure that all functions'\n    /// deadlines are met, the _minimum_ of all these include-by timestamps will\n    /// be exposed when this tx is submitted to the network.\n    ///\n    /// If the transaction is not included in a block by its include-by\n    /// timestamp, it becomes invalid and it will never be included.\n    ///\n    /// This expiry timestamp is publicly visible. See the \"Advanced\" section\n    /// for privacy concerns.\n    ///\n    /// # Arguments\n    /// * `include_by_timestamp` - Unix timestamp (seconds) deadline for inclusion.\n    ///                            The include-by timestamp of this tx will be\n    ///                            _at most_ the timestamp specified.\n    ///\n    /// # Advanced\n    /// * If multiple functions set differing `include_by_timestamp`s, the\n    ///   kernel circuits will set it to be the _minimum_ of the two. This\n    ///   ensures the tx expiry requirements of all functions in the tx are met.\n    /// * Rollup circuits will reject expired txs.\n    /// * The protocol enforces that all transactions must be included within\n    ///   24 hours of their chosen anchor block's timestamp, to enable safe\n    ///   mempool pruning.\n    /// * The DelayedPublicMutable design makes heavy use of this functionality,\n    ///   to enable private functions to read public state.\n    /// * A sophisticated Wallet should cleverly set an include-by timestamp\n    ///   to improve the privacy of the user and the network as a whole.\n    ///   For example, if a contract interaction sets include-by to some\n    ///   publicly-known value (e.g. the time when a contract upgrades), then\n    ///   the wallet might wish to set an even lower one to avoid revealing that\n    ///   this tx is interacting with said contract.\n    ///   Ideally, all wallets should standardise on an approach in order to\n    ///   provide users with a large anonymity set -- although the exact apprach\n    ///   will need to be discussed. Wallets that deviate from a standard might\n    ///   accidentally reveal which wallet each transaction originates from.\n    ///\n    // docs:start:include-by-timestamp\n    pub fn set_include_by_timestamp(&mut self, include_by_timestamp: u64) {\n        // docs:end:include-by-timestamp\n        self.include_by_timestamp = std::cmp::min(self.include_by_timestamp, include_by_timestamp);\n    }\n\n    /// Makes a request to the protocol's kernel circuit to ensure a note_hash\n    /// actually exists.\n    ///\n    /// \"Read requests\" are used to prove that a note hash exists without\n    /// revealing which specific note was read.\n    ///\n    /// This can be used to prove existence of both settled notes (created in\n    /// prior transactions) and transient notes (created in the current\n    /// transaction).\n    /// If you need to prove existence of a settled note _at a specific block\n    /// number_, use `note_inclusion::prove_note_inclusion`.\n    ///\n    /// Low-level function. Ordinarily, smart contract developers will not need\n    /// to call this directly. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new note_hash read\n    /// requests.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The note hash to read and verify\n    ///\n    /// # Advanced\n    /// In \"traditional\" circuits for non-Aztec privacy applications, the merkle\n    /// membership proofs to check existence of a note are performed _within_\n    /// the application circuit.\n    ///\n    /// All Aztec private functions have access to the following constraint\n    /// optimisation:\n    /// In cases where the note being read was created earlier in the same tx,\n    /// the note wouldn't yet exist in the Note Hash Tree, so a hard-coded\n    /// merkle membership check which then gets ignored would be a waste of\n    /// constraints.\n    /// Instead, we can send read requests for all notes to the protocol's\n    /// kernel circuits, where we can conditionally assess which notes actually\n    /// need merkle membership proofs, and select an appropriately-sized\n    /// kernel circuit.\n    ///\n    /// For \"settled notes\" (which already existed in the Note Hash Tree of the\n    /// anchor block (i.e. before the tx began)), the kernel does a merkle\n    /// membership check.\n    ///\n    /// For \"pending notes\" (which were created earlier in _this_ tx), the\n    /// kernel will check that the note existed _before_ this read request was\n    /// made, by checking the side-effect counters of the note_hash and this\n    /// read request.\n    ///\n    /// This approach improves latency between writes and reads:\n    /// a function can read a note which was created earlier in the tx (rather\n    /// than performing the read in a later tx, after waiting for the earlier tx\n    /// to be included, to ensure the note is included in the tree).\n    ///\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = Counted::new(note_hash, self.next_counter());\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    /// Requests to read a specific nullifier from the nullifier tree.\n    ///\n    /// Nullifier read requests are used to prove that a nullifier exists without\n    /// revealing which specific nullifier preimage was read.\n    ///\n    /// This can be used to prove existence of both settled nullifiers (created in\n    /// prior transactions) and transient nullifiers (created in the current\n    /// transaction).\n    /// If you need to prove existence of a settled nullifier _at a specific block\n    /// number_, use `nullifier_inclusion::prove_nullifier_inclusion`.\n    ///\n    /// Low-level function. Ordinarily, smart contract developers will not need\n    /// to call this directly. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifier read\n    /// requests.\n    ///\n    /// # Arguments\n    /// * `nullifier` - The nullifier to read and verify\n    ///\n    /// # Advanced\n    /// This approach improves latency between writes and reads:\n    /// a function can read a nullifier which was created earlier in the tx\n    /// (rather than performing the read in a later tx, after waiting for the\n    /// earlier tx to be included, to ensure the note is included in the tree).\n    ///\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = Counted::new(nullifier, self.next_counter());\n        self.nullifier_read_requests.push(request);\n    }\n\n    /// Requests the app-siloed nullifier secret key (nsk_app) for the given\n    /// (hashed) master nullifier public key (npk_m), from the user's PXE.\n    ///\n    /// Advanced function: Only needed if you're designing your own notes and/or\n    /// nullifiers.\n    ///\n    /// Contracts are not allowed to compute nullifiers for other contracts, as\n    /// that would let them read parts of their private state. Because of this,\n    /// a contract is only given an \"app-siloed secret key\", which is\n    /// constructed by hashing the user's master nullifier secret key with the\n    /// contract's address.\n    /// However, because contracts cannot be trusted with a user's master\n    /// nullifier secret key (because we don't know which contracts are honest\n    /// or malicious), the PXE refuses to provide any master secret keys to\n    /// any app smart contract function. This means app functions are unable to\n    /// prove that the derivation of an app-siloed nullifier secret key has been\n    /// computed correctly. Instead, an app function can request to the kernel\n    /// (via `request_nsk_app`) that it validates the siloed derivation, since\n    /// the kernel has been vetted to not leak any master secret keys.\n    ///\n    /// A common nullification scheme is to inject a nullifier secret key into\n    /// the preimage of a nullifier, to make the nullifier deterministic but\n    /// random-looking. This function enables that flow.\n    ///\n    /// # Arguments\n    /// * `npk_m_hash` - A hash of the master nullifier public key of the user\n    ///                  whose PXE is executing this function.\n    ///\n    /// # Returns\n    /// * The app-siloed nullifier secret key that corresponds to the given\n    ///   `npk_m_hash`.\n    ///\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    /// Requests the app-siloed nullifier secret key (nsk_app) for the given\n    /// (hashed) master nullifier public key (npk_m), from the user's PXE.\n    ///\n    /// See `request_nsk_app` and `request_sk_app` for more info.\n    ///\n    /// The intention of the \"outgoing\" keypair is to provide a second secret\n    /// key for all of a user's outgoing activity (i.e. for notes that a user\n    /// creates, as opposed to notes that a user receives from others). The\n    /// separation of incoming and outgoing data was a distinction made by\n    /// zcash, with the intention of enabling a user to optionally share with a\n    /// 3rd party a controlled view of only incoming or outgoing notes.\n    /// Similar functionality of sharing select data can be achieved with\n    /// offchain zero-knowledge proofs. It is up to an app developer whether\n    /// they choose to make use of a user's outgoing keypair within their\n    /// application logic, or instead simply use the same keypair (the address\n    /// keypair (which is effectively the same as the \"incooming\" keypair)) for\n    /// all incoming & outgoing messages to a user.\n    ///\n    /// Currently, all of the exposed encryption functions in aztec-nr ignore\n    /// the outgoing viewing keys, and instead encrypt all note logs and event\n    /// logs to a user's address public key.\n    ///\n    /// # Arguments\n    /// * `ovpk_m_hash` - Hash of the outgoing viewing public key master\n    ///\n    /// # Returns\n    /// * The application-specific outgoing viewing secret key\n    ///\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    /// Pushes a Key Validation Request to the kernel.\n    ///\n    /// Private functions are not allowed to see a user's master secret keys,\n    /// because we do not trust them. They are instead given \"app-siloed\" secret\n    /// keys with a claim that they relate to a master public key.\n    /// They can then request validation of this claim, by making a \"key\n    /// validation request\" to the protocol's kernel circuits (which _are_\n    /// allowed to see certain master secret keys).\n    ///\n    /// When a Key Validation Request tuple of (sk_app, Pk_m, app_address) is\n    /// submitted to the kernel, it will perform the following derivations\n    /// to validate the relationship between the claimed sk_app and the user's\n    /// Pk_m:\n    ///\n    ///       (sk_m) ----> * G ----> Pk_m\n    ///         |                     |\n    ///         v                       We use the kernel to prove this\n    ///  h(sk_m, app_address)         | sk_app-Pk_m relationship, because app\n    ///         |                       circuits must not be trusted to see sk_m.\n    ///         v                     |\n    ///      sk_app - -  - - - - - - -\n    ///\n    /// The function is named \"request_\" instead of \"get_\" to remind the user\n    /// that a Key Validation Request will be emitted to the kernel.\n    ///\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    /// Sends an \"L2 -> L1 message\" from this function (Aztec, L2) to a smart\n    /// contract on Ethereum (L1). L1 contracts which are designed to\n    /// send/receive messages to/from Aztec are called \"Portal Contracts\".\n    ///\n    /// Common use cases include withdrawals, cross-chain asset transfers, and\n    /// triggering L1 actions based on L2 state changes.\n    ///\n    /// The message will be inserted into an Aztec \"Outbox\" contract on L1,\n    /// when this transaction's block is proposed to L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target portal contract. The message will need to be manually\n    /// consumed from the Outbox through a separate Ethereum transaction: a user\n    /// will need to call a function of the portal contract -- a function\n    /// specifically designed to make a call to the Outbox to consume the\n    /// message.\n    /// The message will only be available for consumption once the _epoch_\n    /// proof has been submitted. Given that there are multiple Aztec blocks\n    /// within an epoch, it might take some time for this epoch proof to be\n    /// submitted -- especially if the block was near the start of an epoch.\n    ///\n    /// # Arguments\n    /// * `recipient` - Ethereum address that will receive the message\n    /// * `content` - Message content (32 bytes as a Field element).\n    ///               This content has a very specific layout.\n    /// docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        let message = L2ToL1Message { recipient, content };\n        self.l2_to_l1_msgs.push(message.count(self.next_counter()));\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2).\n    ///\n    /// Common use cases include token bridging, cross-chain governance, and\n    /// triggering L2 actions based on L1 events.\n    ///\n    /// Use this function if you only want the message to ever be \"referred to\"\n    /// once. Once consumed using this method, the message cannot be consumed\n    /// again, because a nullifier is emitted.\n    /// If your use case wants for the message to be read unlimited times, then\n    /// you can always read any historic message from the L1-to-L2 messages tree;\n    /// messages never technically get deleted from that tree.\n    ///\n    /// The message will first be inserted into an Aztec \"Inbox\" smart contract\n    /// on L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target L2 contract. The message will need to be manually\n    /// consumed by the target contract through a separate Aztec transaction.\n    /// The message will not be available for consumption immediately. Messages\n    /// get copied over from the L1 Inbox to L2 by the next Proposer in batches.\n    /// So you will need to wait until the messages are copied before you can\n    /// consume them.\n    ///\n    /// # Arguments\n    /// * `content` - The message content that was sent from L1\n    /// * `secret` - Secret value used for message privacy (if needed)\n    /// * `sender` - Ethereum address that sent the message\n    /// * `leaf_index` - Index of the message in the L1-to-L2 message tree\n    ///\n    /// # Advanced\n    /// Validates message existence in the L1-to-L2 message tree and nullifies\n    /// the message to prevent double-consumption.\n    ///\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let nullifier = process_l1_to_l2_message(\n            self.anchor_block_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n\n    /// Emits a private log (an array of Fields) that will be published to an\n    /// Ethereum blob.\n    ///\n    /// Private logs are intended for the broadcasting of ciphertexts: that is,\n    /// encrypted events or encrypted note contents.\n    /// Since the data in the logs is meant to be _encrypted_, private_logs are\n    /// broadcast to publicly-visible Ethereum blobs.\n    /// The intended recipients of such encrypted messages can then discover and\n    /// decrypt these encrypted logs using their viewing secret key.\n    /// (See `../messages/discovery` for more details).\n    ///\n    /// Important note: This function DOES NOT _do_ any encryption of the input\n    /// `log` fields. This function blindly publishes whatever input `log` data\n    /// is fed into it, so the caller of this function should have already\n    /// performed the encryption, and the `log` should be the result of that\n    /// encryption.\n    ///\n    /// The protocol does not dictate what encryption scheme should be used:\n    /// a smart contract developer can choose whatever encryption scheme they\n    /// like.\n    /// Aztec-nr includes some off-the-shelf encryption libraries that\n    /// developers might wish to use, for convenience. These libraries not only\n    /// encrypt a plaintext (to produce a ciphertext); they also prepend the\n    /// ciphertext with a `tag` and `ephemeral public key` for easier message\n    /// discovery. This is a very dense topic, and we will be writing more\n    /// libraries and docs soon.\n    ///\n    /// > Currently, AES128 CBC encryption is the main scheme included in\n    /// > aztec.nr.\n    /// > We are currently making significant changes to the interfaces of the\n    /// > encryption library.\n    ///\n    /// In some niche use cases, an app might be tempted to publish\n    /// _un-encrypted_ data via a private log, because _public logs_ are not\n    /// available to private functions. Be warned that emitting public data via\n    /// private logs is strongly discouraged, and is considered a \"privacy\n    /// anti-pattern\", because it reveals identifiable information about _which_\n    /// function has been executed. A tx which leaks such information does not\n    /// contribute to the privacy set of the network.\n    ///\n    /// * Unlike `emit_raw_note_log`, this log is not tied to any specific note\n    ///\n    /// # Arguments\n    /// * `log` - The log data that will be publicly broadcast (so make sure\n    ///           it's already been encrypted before you call this function).\n    ///   Private logs are bounded in size (PRIVATE_LOG_SIZE_IN_FIELDS), to\n    ///   encourage all logs from all smart contracts look identical.\n    /// * `length` - The actual length of the `log` (measured in number of\n    ///              Fields). Although the input log has a max size of\n    ///   PRIVATE_LOG_SIZE_IN_FIELDS, the latter values of the array might all\n    ///   be 0's for small logs. This `length` should reflect the trimmed length\n    ///   of the array. The protocol's kernel circuits can then append random\n    ///   fields as \"padding\" after the `length`, so that the logs of this\n    ///   smart contract look indistinguishable from (the same length as) the\n    ///   logs of all other applications. It's up to wallets how much padding\n    ///   to apply, so ideally all wallets should agree on standards for this.\n    ///\n    /// # Advanced\n    ///\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS], length: u32) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter: 0 }\n            .count(counter);\n        self.private_logs.push(private_log);\n    }\n\n    // TODO: rename.\n    /// Emits a private log that is explicitly tied to a newly-emitted note_hash,\n    /// to convey to the kernel: \"this log relates to this note\".\n    ///\n    /// This linkage is important in case the note gets squashed (due to being\n    /// read later in this same tx), since we can then squash the log as well.\n    ///\n    /// See `emit_private_log` for more info about private log emission.\n    ///\n    /// # Arguments\n    /// * `log` - The log data as an array of Field elements\n    /// * `length` - The actual length of the `log` (measured in number of\n    ///              Fields).\n    /// * `note_hash_counter` - The side-effect counter that was assigned to the\n    ///                         new note_hash when it was pushed to this\n    //                          `PrivateContext`.\n    ///\n    /// Important: If your application logic requires the log to always be\n    /// emitted regardless of note squashing, consider using `emit_private_log`\n    /// instead, or emitting additional events.\n    ///\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        length: u32,\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter };\n        self.private_logs.push(private_log.count(counter));\n    }\n\n    pub fn emit_contract_class_log<let N: u32>(&mut self, log: [Field; N]) {\n        let contract_address = self.this_address();\n        let counter = self.next_counter();\n\n        let log_to_emit: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS] =\n            log.concat([0; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS - N]);\n        // Note: the length is not always N, it is the number of fields we want to broadcast, omitting trailing zeros to save blob space.\n        // Safety: The below length is constrained in the base rollup, which will make sure that all the fields beyond length are zero.\n        // However, it won't be able to check that we didn't add extra padding (trailing zeroes)\n        let length = unsafe { trimmed_array_length_hint(log_to_emit) };\n        // We hash the entire padded log to ensure a user cannot pass a shorter length and so emit incorrect shorter bytecode.\n        let log_hash = poseidon2_hash(log_to_emit);\n        // Safety: the below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\n        unsafe {\n            notify_created_contract_class_log(contract_address, log_to_emit, length, counter);\n        }\n\n        self.contract_class_logs_hashes.push(LogHash { value: log_hash, length: length }.count(\n            counter,\n        ));\n    }\n\n    /// Calls a private function on another contract (or the same contract).\n    ///\n    /// Very low-level function.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the called function\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    /// This enables contracts to interact with each other while maintaining\n    /// privacy. This \"composability\" of private contract functions is a key\n    /// feature of the Aztec network.\n    ///\n    /// If a user's transaction includes multiple private function calls, then\n    /// by the design of Aztec, the following information will remain private[1]:\n    /// - The function selectors and contract addresses of all private function\n    ///   calls will remain private, so an observer of the public mempool will\n    ///   not be able to look at a tx and deduce which private functions have\n    ///   been executed.\n    /// - The arguments and return values of all private function calls will\n    ///   remain private.\n    /// - The person who initiated the tx will remain private.\n    /// - The notes and nullifiers and private logs that are emitted by all\n    ///   private function calls will (if designed well) not leak any user\n    ///   secrets, nor leak which functions have been executed.\n    ///\n    /// [1] Caveats: Some of these privacy guarantees depend on how app\n    /// developers design their smart contracts. Some actions _can_ leak\n    /// information, such as:\n    /// - Calling an internal public function.\n    /// - Calling a public function and not setting msg_sender to Option::none\n    ///   (feature not built yet - see github).\n    /// - Calling any public function will always leak details about the nature\n    ///   of the transaction, so devs should be careful in their contract\n    ///   designs. If it can be done in a private function, then that will give\n    ///   the best privacy.\n    /// - Not padding the side-effects of a tx to some standardised, uniform\n    ///   size. The kernel circuits can take hints to pad side-effects, so a\n    ///   wallet should be able to request for a particular amount of padding.\n    ///   Wallets should ideally agree on some standard.\n    ///   - Padding should include:\n    ///     - Padding the lengths of note & nullifier arrays\n    ///     - Padding private logs with random fields, up to some standardised\n    ///       size.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Advanced\n    /// * The call is added to the private call stack and executed by kernel\n    ///   circuits after this function completes\n    /// * The called function can modify its own contract's private state\n    /// * Side effects from the called function are included in this transaction\n    /// * The call inherits the current transaction's context and gas limits\n    ///\n    pub fn call_private_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    /// Makes a read-only call to a private function on another contract.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L2 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// See `call_private_function` for more general info on private function\n    /// calls.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the called function\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn static_call_private_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    /// Calls a private function that takes no arguments.\n    ///\n    /// This is a convenience function for calling private functions that don't\n    /// require any input parameters. It's equivalent to `call_private_function`\n    /// but slightly more efficient to use when no arguments are needed.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    /// Makes a read-only call to a private function which takes no arguments.\n    ///\n    /// This combines the optimisation of `call_private_function_no_args` with\n    /// the safety of `static_call_private_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    /// Low-level private function call.\n    ///\n    /// This is the underlying implementation used by all other private function\n    /// call methods. Instead of taking raw arguments, it accepts a\n    /// hash of the arguments.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args_hash` - Pre-computed hash of the function arguments\n    /// * `is_static_call` - Whether this should be a read-only call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values\n    ///\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1; // TODO: call `next_counter` instead, for consistency\n        ReturnsHash::new(returns_hash)\n    }\n\n    /// Enqueues a call to a public function to be executed later.\n    ///\n    /// Unlike private functions which execute immediately on the user's device,\n    /// public function calls are \"enqueued\" and executed some time later by a\n    /// block proposer.\n    ///\n    /// This means a public function cannot return any values back to a private\n    /// function, because by the time the public function is being executed,\n    /// the private function which called it has already completed execution.\n    /// (In fact, the private function has been executed and proven, along with\n    /// all other private function calls of the user's tx. A single proof of the\n    /// tx has been submitted to the Aztec network, and some time later a\n    /// proposer has picked the tx up from the mempool and begun executing all\n    /// of the enqueued public functions).\n    ///\n    /// # Privacy warning\n    /// Enqueueing a public function call is an inherently leaky action.\n    /// Many interesting applications will require some interaction with public\n    /// state, but smart contract developers should try to use public function\n    /// calls sparingly, and carefully.\n    /// _Internal_ public function calls are especially leaky, because they\n    /// completely leak which private contract made the call.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the public function\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn call_public_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n        hide_msg_sender: bool,\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a read-only call to a public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// See also `call_public_function` for more important information about\n    /// making private -> public function calls.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the public function\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn static_call_public_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n        hide_msg_sender: bool,\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            true,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a call to a public function that takes no arguments.\n    ///\n    /// This is an optimisation for calling public functions that don't\n    /// take any input parameters. It's otherwise equivalent to\n    /// `call_public_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        hide_msg_sender: bool,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a read-only call to a public function with no arguments.\n    ///\n    /// This combines the optimisation of `call_public_function_no_args` with\n    /// the safety of `static_call_public_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        hide_msg_sender: bool,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            true,\n            hide_msg_sender,\n        )\n    }\n\n    /// Low-level public function call.\n    ///\n    /// This is the underlying implementation used by all other public function\n    /// call methods. Instead of taking raw arguments, it accepts a\n    /// hash of the arguments.\n    ///\n    /// Advanced function: Most developers should use `call_public_function`\n    /// or `static_call_public_function` instead. This function is exposed for\n    /// performance optimization and advanced use cases.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `calldata_hash` - Hash of the function calldata\n    /// * `is_static_call` - Whether this should be a read-only call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n        hide_msg_sender: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let msg_sender = if hide_msg_sender {\n            NULL_MSG_SENDER_CONTRACT_ADDRESS\n        } else {\n            self.this_address()\n        };\n\n        let call_request =\n            PublicCallRequest { msg_sender, contract_address, is_static_call, calldata_hash };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    /// Enqueues a public function call, and designates it to be the teardown\n    /// function for this tx. Only one teardown function call can be made by a\n    /// tx.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase ensures the fee payer\n    /// has sufficient balance to pay the proposer their fees.\n    /// The teardown phase is primarily intended to: calculate exactly\n    /// how much the user owes, based on gas consumption, and refund the user\n    /// any change.\n    ///\n    /// Note: in some cases, the cost of refunding the user (i.e. DA costs of\n    /// tx side-effects) might exceed the refund amount. For app logic with\n    /// fairly stable and predictable gas consumption, a material refund amount\n    /// is unlikely. For app logic with unpredictable gas consumption, a\n    /// refund might be important to the user (e.g. if a hefty function reverts\n    /// very early). Wallet/FPC/Paymaster developers should be mindful of this.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the teardown\n    ///                        function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - An array of fields to pass to the function.\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    pub fn set_public_teardown_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n        hide_msg_sender: bool,\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n\n    /// Low-level function to set the public teardown function.\n    ///\n    /// This is the underlying implementation for setting the teardown function\n    /// call that will execute at the end of the transaction. Instead of taking\n    /// raw arguments, it accepts a hash of the arguments.\n    ///\n    /// Advanced function: Most developers should use\n    /// `set_public_teardown_function` instead.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the teardown\n    ///                        function\n    /// * `calldata_hash` - Hash of the function calldata\n    /// * `is_static_call` - Whether this should be a read-only call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n        hide_msg_sender: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let msg_sender = if hide_msg_sender {\n            NULL_MSG_SENDER_CONTRACT_ADDRESS\n        } else {\n            self.this_address()\n        };\n\n        self.public_teardown_call_request =\n            PublicCallRequest { msg_sender, contract_address, is_static_call, calldata_hash };\n    }\n\n    /// Increments the side-effect counter.\n    ///\n    /// Very low-level function.\n    ///\n    /// # Advanced\n    ///\n    /// Every side-effect of a private function is given a \"side-effect counter\",\n    /// based on when it is created. This PrivateContext is in charge of\n    /// assigning the counters.\n    ///\n    /// The reason we have side-effect counters is complicated. Consider this\n    /// illustrative pseudocode of inter-contract function calls:\n    /// ```\n    /// contract A {\n    ///    let x = 5; // pseudocode for storage var x.\n    ///    fn a1 {\n    ///        read x; // value: 5, counter: 1.\n    ///        x = x + 1;\n    ///        write x; // value: 6, counter: 2.\n    ///\n    ///        B.b(); // start_counter: 2, end_counter: 4\n    ///\n    ///        read x; // value: 36, counter: 5.\n    ///        x = x + 1;\n    ///        write x; // value: 37, counter: 6.\n    ///    }\n    ///\n    ///    fn a2 {\n    ///        read x; // value: 6, counter: 3.\n    ///        x = x * x;\n    ///        write x; // value: 36, counter: 4.\n    ///    }\n    /// }\n    ///\n    /// contract B {\n    ///     fn b() {\n    ///         A.a2();\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// Suppose a1 is the first function called. The comments show the execution\n    /// counter of each side-effect, and what the new value of `x` is.\n    ///\n    /// These (private) functions are processed by Aztec's kernel circuits in an\n    /// order that is different from execution order:\n    /// All of A.a1 is proven before B.b is proven, before A.a2 is proven.\n    /// So when we're in the 2nd execution frame of A.a1 (after the call to\n    /// B.b), the circuit needs to justify why x went from being `6` to `36`.\n    /// But the circuit doesn't know why, and given the order of proving, the\n    /// kernel hasn't _seen_ a value of 36 get written yet.\n    /// The kernel needs to track big arrays of all side-effects of all\n    /// private functions in a tx. Then, as it recurses and processes B.b(), it\n    /// will eventually see a value of 36 get written.\n    ///\n    /// Suppose side-effect counters weren't exposed:\n    /// The kernel would only see this ordering (in order of proof verification):\n    /// [ A.a1.read, A.a1.write, A.a1.read, A.a1.write, A.a2.read, A.a2.write ]\n    /// [         5,          6,        36,         37,         6,         36 ]\n    /// The kernel wouldn't know _when_ B.b() was called within A.a1(), because\n    /// it can't see what's going on within an app circuit. So the kernel\n    /// wouldn't know that the ordering of reads and writes should actually be:\n    /// [ A.a1.read, A.a1.write, A.a2.read, A.a2.write, A.a1.read, A.a1.write ]\n    /// [         5,          6,        6,         36,         36,         37 ]\n    ///\n    /// And so, we introduced side-effect counters: every private function must\n    /// assign side-effect counters alongside every side-effect that it emits,\n    /// and also expose to the kernel the counters that it started and ended\n    /// with.\n    /// This gives the kernel enough information to arrange all side-effects in\n    /// the correct order.\n    /// It can then catch (for example) if a function tries to read state\n    /// before it has been written (e.g. if A.a2() maliciously tried to read\n    /// a value of x=37) (e.g. if A.a1() maliciously tried to read x=6).\n    ///\n    /// If a malicious app contract _lies_ and does not count correctly:\n    /// - It cannot lie about its start and end counters because the kernel\n    ///   will catch this.\n    /// - It _could_ lie about its intermediate counters:\n    ///   - 1. It could not increment its side-effects correctly\n    ///   - 2. It could label its side-effects with counters outside of its\n    ///        start and end counters' range.\n    ///   The kernel will catch 2.\n    ///   The kernel will not catch 1., but this would only cause corruption\n    ///   to the private state of the malicious contract, and not any other\n    ///   contracts (because a contract can only modify its own state). If\n    ///   a \"good\" contract is given _read access_ to a maliciously-counting\n    ///   contract (via an external getter function, or by reading historic\n    ///   state from the archive tree directly), and they then make state\n    ///   changes to their _own_ state accordingly, that could be dangerous.\n    ///   Developers should be mindful not to trust the claimed innards of\n    ///   external contracts unless they have audited/vetted the contracts\n    ///   including vetting the side-effect counter incrementation.\n    ///   This is a similar paradigm to Ethereum smart contract development:\n    ///   you must vet external contracts that your contract relies upon, and\n    ///   you must not make any presumptions about their claimed behaviour.\n    ///   (Hopefully if a contract imports a version of aztec-nr, we will get\n    ///   contract verification tooling that can validate the authenticity\n    ///   of the imported aztec-nr package, and hence infer that the side-\n    ///   effect counting will be correct, without having to re-audit such logic\n    ///   for every contract).\n    ///\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            include_by_timestamp: 0,\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            anchor_block_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "71": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::{MAX_U32_VALUE, NULL_MSG_SENDER_CONTRACT_ADDRESS};\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\n/// # PublicContext\n///\n/// The **main interface** between an #[external(\"public\")] function and the Aztec blockchain.\n///\n/// An instance of the PublicContext is initialized automatically at the outset\n/// of every public function, within the #[external(\"public\")] macro, so you'll never\n/// need to consciously instantiate this yourself.\n///\n/// The instance is always named `context`, and it will always be available\n/// within the body of every #[external(\"public\")] function in your smart contract.\n///\n/// Typical usage for a smart contract developer will be to call getter\n/// methods of the PublicContext.\n///\n/// _Pushing_ data and requests to the context is mostly handled within\n/// aztec-nr's own functions, so typically a smart contract developer won't\n/// need to call any setter methods directly.\n///\n/// ## Responsibilities\n/// - Exposes contextual data to a public function:\n///   - Data relating to how this public function was called:\n///     - msg_sender, this_address\n///   - Data relating to the current blockchain state:\n///     - timestamp, block_number, chain_id, version\n///   - Gas and fee information\n/// - Provides state access:\n///   - Read/write public storage (key-value mapping)\n///   - Check existence of notes and nullifiers\n///     (Some patterns use notes & nullifiers to store public (not private)\n///     information)\n///   - Enables consumption of L1->L2 messages.\n/// - Enables calls to other public smart contract functions:\n/// - Writes data to the blockchain:\n///   - Updates to public state variables\n///   - New public logs (for events)\n///   - New L2->L1 messages\n///   - New notes & nullifiers\n///     (E.g. pushing public info to notes/nullifiers, or for completing\n///     \"partial notes\")\n///\n/// ## Key Differences from Private Execution\n///\n/// Unlike private functions -- which are executed on the user's device and which\n/// can only reference historic state -- public functions are executed by a block\n/// proposer and are executed \"live\" on the _current_ tip of the chain.\n/// This means public functions can:\n/// - Read and write _current_ public state\n/// - Immediately see the effects of earlier transactions in the same block\n///\n/// Also, public functions are executed within a zkVM (the \"AVM\"), so that they\n/// can _revert_ whilst still ensuring payment to the proposer and prover.\n/// (Private functions cannot revert: they either succeed, or they cannot be\n/// included).\n///\n/// ## Optimising Public Functions\n///\n/// Using the AVM to execute public functions means they compile down to \"AVM\n/// bytecode\" instead of the ACIR that private functions (standalone circuits)\n/// compile to. Therefore the approach to optimising a public function is\n/// fundamentally different from optimising a public function.\n///\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl Eq for PublicContext {\n    fn eq(self, other: Self) -> bool {\n        (self.args_hash == other.args_hash)\n        // Can't compare the function compute_args_hash\n    }\n}\n\nimpl PublicContext {\n    /// Creates a new PublicContext instance.\n    ///\n    /// Low-level function: This is called automatically by the #[external(\"public\")]\n    /// macro, so you shouldn't need to be called directly by smart contract\n    /// developers.\n    ///\n    /// # Arguments\n    /// * `compute_args_hash` - Function to compute the args_hash\n    ///\n    /// # Returns\n    /// * A new PublicContext instance\n    ///\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    /// Emits a _public_ log that will be visible onchain to everyone.\n    ///\n    /// # Arguments\n    /// * `log` - The data to log, must implement Serialize trait\n    ///\n    pub fn emit_public_log<T>(_self: &mut Self, log: T)\n    where\n        T: Serialize,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    /// Checks if a given note hash exists in the note hash tree at a particular\n    /// leaf_index.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The note hash to check for existence\n    /// * `leaf_index` - The index where the note hash should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the note hash exists at the specified index\n    ///\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: u64) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    /// Checks if a specific L1-to-L2 message exists in the L1-to-L2 message\n    /// tree at a particular leaf index.\n    ///\n    /// Common use cases include token bridging, cross-chain governance, and\n    /// triggering L2 actions based on L1 events.\n    ///\n    /// This function should be called before attempting to consume an L1-to-L2\n    /// message.\n    ///\n    /// # Arguments\n    /// * `msg_hash` - Hash of the L1-to-L2 message to check\n    /// * `msg_leaf_index` - The index where the message should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the message exists at the specified index\n    ///\n    /// # Advanced\n    /// * Uses the AVM l1_to_l2_msg_exists opcode for tree lookup\n    /// * Messages are copied from L1 Inbox to L2 by block proposers\n    ///\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        // TODO(alvaro): Make l1l2msg leaf index a u64 upstream\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index as u64) } == 1\n    }\n\n    /// Checks if a specific nullifier has been emitted by a given contract.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. An example is to check\n    /// whether a contract has been published: we emit a nullifier that is\n    /// deterministic, but whose preimage is _not_ private. This is more\n    /// efficient than using mutable storage, and can be done directly\n    /// from a private function.\n    ///\n    /// Nullifiers can be tested for non-existence in public, which is not the\n    /// case in private. Because private functions do not have access to\n    /// the tip of the blockchain (but only the anchor block they are built\n    /// at) they can only prove nullifier non-existence in the past. But between\n    /// an anchor block and the block in which a tx is included, the nullifier\n    /// might have been inserted into the nullifier tree by some other\n    /// transaction.\n    /// Public functions _do_ have access to the tip of the state, and so\n    /// this pattern is safe.\n    ///\n    /// # Arguments\n    /// * `unsiloed_nullifier` - The raw nullifier value (before siloing with\n    ///                          the contract address that emitted it).\n    /// * `address` - The claimed contract address that emitted the nullifier\n    ///\n    /// # Returns\n    /// * `bool` - True if the nullifier has been emitted by the specified contract\n    ///\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2) -- effectively\n    /// marking it as \"read\".\n    ///\n    /// Use this function if you only want the message to ever be \"referred to\"\n    /// once. Once consumed using this method, the message cannot be consumed\n    /// again, because a nullifier is emitted.\n    /// If your use case wants for the message to be read unlimited times, then\n    /// you can always read any historic message from the L1-to-L2 messages tree,\n    /// using the `l1_to_l2_msg_exists` method. Messages never technically get\n    /// deleted from that tree.\n    ///\n    /// The message will first be inserted into an Aztec \"Inbox\" smart contract\n    /// on L1. It will not be available for consumption immediately. Messages\n    /// get copied-over from the L1 Inbox to L2 by the next Proposer in batches.\n    /// So you will need to wait until the messages are copied before you can\n    /// consume them.\n    ///\n    /// # Arguments\n    /// * `content` - The message content that was sent from L1\n    /// * `secret` - Secret value used for message privacy (if needed)\n    /// * `sender` - Ethereum address that sent the message\n    /// * `leaf_index` - Index of the message in the L1-to-L2 message tree\n    ///\n    /// # Advanced\n    /// * Validates message existence in the L1-to-L2 message tree\n    /// * Prevents double-consumption by emitting a nullifier\n    /// * Message hash is computed from all parameters + chain context\n    /// * Will revert if message doesn't exist or was already consumed\n    ///\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    /// Sends an \"L2 -> L1 message\" from this function (Aztec, L2) to a smart\n    /// contract on Ethereum (L1). L1 contracts which are designed to\n    /// send/receive messages to/from Aztec are called \"Portal Contracts\".\n    ///\n    /// Common use cases include withdrawals, cross-chain asset transfers, and\n    /// triggering L1 actions based on L2 state changes.\n    ///\n    /// The message will be inserted into an Aztec \"Outbox\" contract on L1,\n    /// when this transaction's block is proposed to L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target portal contract. The message will need to be manually\n    /// consumed from the Outbox through a separate Ethereum transaction: a user\n    /// will need to call a function of the portal contract -- a function\n    /// specifically designed to make a call to the Outbox to consume the\n    /// message.\n    /// The message will only be available for consumption once the _epoch_\n    /// proof has been submitted. Given that there are multiple Aztec blocks\n    /// within an epoch, it might take some time for this epoch proof to be\n    /// submitted -- especially if the block was near the start of an epoch.\n    ///\n    /// # Arguments\n    /// * `recipient` - Ethereum address that will receive the message\n    /// * `content` - Message content (32 bytes as a Field element)\n    ///\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    /// Calls a public function on another contract.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Arguments to pass to the function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Makes a read-only call to a public function on another contract.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Useful for querying data from other contracts safely.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Array of arguments to pass to the called function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Adds a new note hash to the Aztec blockchain's global Note Hash Tree.\n    ///\n    /// Notes are ordinarily constructed and emitted by _private_ functions, to\n    /// ensure that both the content of the note, and the contract that emitted\n    /// the note, stay private.\n    ///\n    /// There are however some useful patterns whereby a note needs to contain\n    /// _public_ data. The ability to push a new note_hash from a _public_\n    /// function means that notes can be injected with public data immediately\n    /// -- as soon as the public value is known. The slower alternative would\n    /// be to submit a follow-up transaction so that a private function can\n    /// inject the data. Both are possible on Aztec.\n    ///\n    /// Search \"Partial Note\" for a very common pattern which enables a note\n    /// to be \"partially\" populated with some data in a _private_ function, and\n    /// then later \"completed\" with some data in a public function.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The hash of the note to add to the tree\n    ///\n    /// # Advanced\n    /// * The note hash will be siloed with the contract address by the protocol\n    ///\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n\n    /// Adds a new nullifier to the Aztec blockchain's global Nullifier Tree.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. Hence why you're seeing this\n    /// function within the PublicContext.\n    /// An example is to check whether a contract has been published: we emit\n    /// a nullifier that is deterministic, but whose preimage is _not_ private.\n    ///\n    /// # Arguments\n    /// * `nullifier` - A unique field element that represents the consumed\n    ///   state\n    ///\n    /// # Advanced\n    /// * Nullifier is immediately added to the global nullifier tree\n    /// * Emitted nullifiers are immediately visible to all\n    ///   subsequent transactions in the same block\n    /// * Automatically siloed with the contract address by the protocol\n    /// * Used for preventing double-spending and ensuring one-time actions\n    ///\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    /// Returns the address of the current contract being executed.\n    ///\n    /// This is equivalent to `address(this)` in Solidity (hence the name).\n    /// Use this to identify the current contract's address, commonly needed for\n    /// access control or when interacting with other contracts.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The contract address of the current function being\n    ///                    executed.\n    ///\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: If the calling function is a _private_ function, then\n    /// it had the option of hiding its address when enqueuing this public\n    /// function call. In such cases, this `context.msg_sender()` method will\n    /// return `Option<AztecAddress>::none`.\n    /// If the calling function is a _public_ function, it will always return\n    /// an `Option<AztecAddress>::some` (i.e. a non-null value).\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called\n    ///   this function (be it an app contract or a user's account contract).\n    ///\n    /// # Advanced\n    /// * Value is provided by the AVM sender opcode\n    /// * In nested calls, this is the immediate caller, not the original\n    ///   transaction sender\n    ///\n    pub fn msg_sender(_self: Self) -> Option<AztecAddress> {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let maybe_msg_sender = unsafe { sender() };\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// \"Unsafe\" versus calling `context.msg_sender()`, because it doesn't\n    /// translate `NULL_MSG_SENDER_CONTRACT_ADDRESS` as\n    /// `Option<AztecAddress>::none`.\n    /// Used by some internal aztecnr functions.\n    pub fn msg_sender_unsafe(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n\n    /// Returns the function selector of the currently-executing function.\n    ///\n    /// This is similar to `msg.sig` in Solidity, returning the first 4\n    /// bytes of the function signature.\n    ///\n    /// # Returns\n    /// * `FunctionSelector` - The 4-byte function identifier\n    ///\n    /// # Advanced\n    /// * Extracted from the first element of calldata\n    /// * Used internally for function dispatch in the AVM\n    ///\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    ///\n    /// Very low-level function: The #[external(\"public\")] macro uses this internally.\n    /// Smart contract developers typically won't need to access this\n    /// directly as arguments are automatically made available.\n    ///\n    /// # Returns\n    /// * `Field` - Hash of the function arguments\n    ///\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n\n    /// Returns the \"transaction fee\" for the current transaction.\n    /// This is the final tx fee that will be deducted from the fee_payer's\n    /// \"fee-juice\" balance (in the protocol's Base Rollup circuit).\n    ///\n    /// # Returns\n    /// * `Field` - The actual, final cost of the transaction, taking into account:\n    ///             the actual gas used during the setup and app-logic phases,\n    ///             and the fixed amount of gas that's been allocated by the user\n    ///             for the teardown phase.\n    ///             I.e. effectiveL2FeePerGas * l2GasUsed + effectiveDAFeePerGas * daGasUsed\n    ///\n    /// This will return `0` during the \"setup\" and \"app-logic\" phases of\n    /// tx execution (because the final tx fee is not known at that time).\n    /// This will only return a nonzero value during the \"teardown\" phase of\n    /// execution, where the final tx fee can actually be computed.\n    ///\n    /// Regardless of _when_ this function is called during the teardown phase,\n    /// it will always return the same final tx fee value. The teardown phase\n    /// does not consume a variable amount of gas: it always consumes a\n    /// pre-allocated amount of gas, as specified by the user when they generate\n    /// their tx.\n    ///\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    /// Returns the chain ID of the current network.\n    ///\n    /// This is similar to `block.chainid` in Solidity. Returns the unique\n    /// identifier for the blockchain network this transaction is executing on.\n    ///\n    /// Helps prevent cross-chain replay attacks. Useful if implementing\n    /// multi-chain contract logic.\n    ///\n    /// # Returns\n    /// * `Field` - The chain ID as a field element\n    ///\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n\n    /// Returns the Aztec protocol version that this transaction is executing\n    /// under. Different versions may have different rules, opcodes, or\n    /// cryptographic primitives.\n    ///\n    /// This is similar to how Ethereum has different EVM versions.\n    ///\n    /// Useful for forward/backward compatibility checks\n    ///\n    /// Not to be confused with contract versions; this is the protocol version.\n    ///\n    /// # Returns\n    /// * `Field` - The protocol version as a field element\n    ///\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    /// Returns the current block number.\n    ///\n    /// This is similar to `block.number` in Solidity.\n    ///\n    /// Note: the current block number is only available within a public function\n    /// (as opposed to a private function).\n    ///\n    /// Note: the time intervals between blocks should not be relied upon as\n    /// being consistent:\n    /// - Timestamps of blocks fall within a range, rather than at exact regular\n    ///   intervals.\n    /// - Slots can be missed.\n    /// - Protocol upgrades can completely change the intervals between blocks\n    ///   (and indeed the current roadmap plans to reduce the time between\n    ///   blocks, eventually).\n    /// Use `context.timestamp()` for more-reliable time-based logic.\n    ///\n    /// # Returns\n    /// * `u32` - The current block number\n    ///\n    pub fn block_number(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n\n    /// Returns the timestamp of the current block.\n    ///\n    /// This is similar to `block.timestamp` in Solidity.\n    ///\n    /// All functions of all transactions in a block share the exact same\n    /// timestamp (even though technically each transaction is executed\n    /// one-after-the-other).\n    ///\n    /// Important note: Timestamps of Aztec blocks are not at reliably-fixed\n    /// intervals. The proposer of the block has some flexibility to choose a\n    /// timestamp which is in a valid _range_: Obviously the timestamp of this\n    /// block must be strictly greater than that of the previous block, and must\n    /// must be less than the timestamp of whichever ethereum block the aztec\n    /// block is proposed to. Furthermore, if the timestamp is not deemed close\n    /// enough to the actual current time, the committee of validators will not\n    /// attest to the block.\n    ///\n    /// # Returns\n    /// * `u64` - Unix timestamp in seconds\n    ///\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n\n    /// Returns the fee per unit of L2 gas for this transaction (aka the \"L2 gas\n    /// price\"), as chosen by the user.\n    ///\n    /// L2 gas covers the cost of executing public functions and handling\n    /// side-effects within the AVM.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of L2 gas\n    ///\n    /// Wallet developers should be mindful that the choice of gas price (which\n    /// is publicly visible) can leak information about the user, e.g.:\n    /// - which wallet software the user is using;\n    /// - the amount of time which has elapsed from the time the user's wallet\n    ///   chose a gas price (at the going rate), to the time of tx submission.\n    ///   This can give clues about the proving time, and hence the nature of\n    ///   the tx.\n    /// - the urgency of the transaction (which is kind of unavoidable, if the\n    ///   tx is indeed urgent).\n    /// - the wealth of the user.\n    /// - the exact user (if the gas price is explicitly chosen by the user to\n    ///   be some unique number like 0.123456789, or their favourite number).\n    /// Wallet devs might wish to consider fuzzing the choice of gas price.\n    ///\n    pub fn base_fee_per_l2_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_l2_gas()\n        }\n    }\n\n    /// Returns the fee per unit of DA (Data Availability) gas (aka the \"DA gas\n    /// price\").\n    ///\n    /// DA gas covers the cost of making transaction data available on L1.\n    ///\n    /// See the warning in `fee_pre_l2_gas` for how gas prices can be leaky.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of DA gas\n    ///\n    pub fn base_fee_per_da_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_da_gas()\n        }\n    }\n\n    /// Returns the remaining L2 gas available for this transaction.\n    ///\n    /// Different AVM opcodes consume different amounts of gas.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining L2 gas units\n    ///\n    pub fn l2_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n\n    /// Returns the remaining DA (Data Availability) gas available for this\n    /// transaction.\n    ///\n    /// DA gas is consumed when emitting data that needs to be made available\n    /// on L1, such as public logs or state updates.\n    /// All of the side-effects from the private part of the tx also consume\n    /// DA gas before execution of any public functions even begins.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining DA gas units\n    ///\n    pub fn da_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n\n    /// Checks if the current execution is within a staticcall context, where\n    /// no state changes or logs are allowed to be emitted (by this function\n    /// or any nested function calls).\n    ///\n    /// # Returns\n    /// * `bool` - True if in staticcall context, false otherwise\n    ///\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    /// Reads raw field values from public storage.\n    /// Reads N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to read from\n    ///\n    /// # Returns\n    /// * `[Field; N]` - Array of N field values from consecutive storage slots\n    ///\n    /// # Generic Parameters\n    /// * `N` - the number of consecutive slots to return, starting from the\n    ///         `storage_slot`.\n    ///\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    /// Reads a typed value from public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to read from\n    ///\n    /// # Returns\n    /// * `T` - The deserialized value from storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type that the caller expects to read from the `storage_slot`.\n    ///\n    pub fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    /// Writes raw field values to public storage.\n    /// Writes to N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// Public storage writes take effect immediately.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to write to\n    /// * `values` - Array of N Fields to write to storage\n    ///\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    /// Writes a typed value to public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to write to\n    /// * `value` - The typed value to write to storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type to write to storage.\n    ///\n    pub fn storage_write<T>(self, storage_slot: Field, value: T)\n    where\n        T: Packable,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> u32 {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn base_fee_per_l2_gas() -> u128 {\n    base_fee_per_l2_gas_opcode()\n}\nunconstrained fn base_fee_per_da_gas() -> u128 {\n    base_fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> u32 {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> u32 {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> u1 {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: u64) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: u64) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\n\nunconstrained fn call(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\nunconstrained fn call_static(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeBaseFeePerL2Gas)]\nunconstrained fn base_fee_per_l2_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeBaseFeePerDaGas)]\nunconstrained fn base_fee_per_da_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> u1 {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "72": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr",
      "source": "use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\n/// A hash that represents a private contract function call's return value. Call `get_preimage` to get the underlying\n/// value.\n///\n/// The kernels don't process the actual return values but instead their hashes, so it is up to contracts to populate\n/// oracles with the preimages of these hashes on return to make them available to their callers.\n///\n/// Public calls don't utilize this mechanism since the AVM does process the full return values.\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    /// Fetches the underlying return value from an oracle, constraining that it corresponds to the return data hash.\n    pub fn get_preimage<T>(self) -> T\n    where\n        T: Deserialize,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it. If `T`\n        // is `()`, then `preimage` must be an array of length 0 (since that is `()`'s deserialization length).\n        // `hash_args_array` handles empty arrays following the protocol rules (i.e. an empty args array is signaled\n        // with a zero hash), correctly constraining `self.hash`.\n        let preimage = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage), \"Preimage mismatch\");\n\n        Deserialize::deserialize(preimage)\n    }\n}\n\nmod test {\n    use crate::{\n        hash::hash_args_array,\n        oracle::execution_cache,\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use super::ReturnsHash;\n    use protocol_types::traits::Serialize;\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn retrieves_preimage() {\n        let env = TestEnvironment::new();\n        env.private_context(|_| {\n            let value = MockStruct::new(4, 7);\n            let serialized = value.serialize();\n\n            let hash = hash_args_array(serialized);\n            execution_cache::store(serialized, hash);\n\n            assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n        });\n    }\n\n    #[test]\n    unconstrained fn retrieves_empty_preimage() {\n        let env = TestEnvironment::new();\n        env.private_context(|_| {\n            let value = ();\n            let serialized = [];\n\n            let hash = hash_args_array(serialized);\n            execution_cache::store(serialized, hash);\n\n            assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n        });\n    }\n\n    #[test(should_fail_with = \"Preimage mismatch\")]\n    unconstrained fn rejects_bad_preimage() {\n        let value = MockStruct::new(4, 7);\n        let serialized = value.serialize();\n\n        let mut bad_serialized = serialized;\n        bad_serialized[0] += 1;\n\n        let hash = hash_args_array(serialized);\n\n        let _ = OracleMock::mock(\"privateLoadFromExecutionCache\").returns(bad_serialized);\n        assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n    }\n\n    // This test passes due to a Noir bug.\n    // #[test(should_fail_with=\"Preimage mismatch\")]\n    // unconstrained fn rejects_bad_empty_preimage() {\n    //     let value = ();\n    //     let serialized = [];\n\n    //     let hash = hash_args_array(serialized);\n\n    //     let _ = OracleMock::mock(\"privateLoadFromExecutionCache\").returns([1]);\n    //     assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n    // }\n}\n"
    },
    "73": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{execution::get_utility_context, storage::storage_read};\nuse protocol_types::{address::AztecAddress, traits::Packable};\n\n// If you'll modify this struct don't forget to update utility_context.ts as well.\npub struct UtilityContext {\n    block_number: u32,\n    timestamp: u64,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        get_utility_context()\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        // We get a context with default contract address, and then we construct the final context with the provided\n        // contract address.\n        let default_context = get_utility_context();\n\n        Self {\n            block_number: default_context.block_number,\n            timestamp: default_context.timestamp,\n            contract_address,\n            version: default_context.version,\n            chain_id: default_context.chain_id,\n        }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        // We get a context with default contract address and block number, and then we construct the final context\n        // with the provided contract address and block number.\n        let default_context = get_utility_context();\n\n        Self {\n            block_number,\n            timestamp: default_context.timestamp,\n            contract_address,\n            version: default_context.version,\n            chain_id: default_context.chain_id,\n        }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn timestamp(self) -> u64 {\n        self.timestamp\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "76": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/event/event_selector.nr",
      "source": "use dep::protocol_types::{\n    hash::poseidon2_hash_bytes,\n    traits::{Deserialize, Empty, FromField, Serialize, ToField},\n};\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "78": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_BYTECODE, GENERATOR_INDEX__PUBLIC_CALLDATA,\n        GENERATOR_INDEX__SECRET_HASH, MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS,\n    },\n    hash::{\n        poseidon2_hash_subarray, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice,\n        sha256_to_field,\n    },\n    point::Point,\n    traits::ToField,\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n}\n\n/**\n * Computes the public bytecode commitment for a contract class.\n * The commitment is `hash([separator, ...bytecode])` where bytecode omits the length prefix present\n * in `packed_bytecode`.\n *\n * @param packed_bytecode - The packed bytecode of the contract class. 0th word is the length in bytes.\n *    packed_bytecode is mutable so that we can avoid copying the array to construct one starting with\n *    separator instead of length.\n * @returns The public bytecode commitment.\n */\npub fn compute_public_bytecode_commitment(\n    mut packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS],\n) -> Field {\n    // First field element contains the length of the bytecode\n    let bytecode_length_in_bytes: u32 = packed_public_bytecode[0] as u32;\n    let bytecode_length_in_fields: u32 =\n        (bytecode_length_in_bytes / 31) + (bytecode_length_in_bytes % 31 != 0) as u32;\n    // Don't allow empty public bytecode.\n    // AVM doesn't handle execution of contracts that exist with empty bytecode.\n    assert(bytecode_length_in_fields != 0);\n    assert(bytecode_length_in_fields < MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS);\n\n    // Packed_bytecode's 0th entry is the length. Replace it with separator before hashing.\n    let separator = GENERATOR_INDEX__PUBLIC_BYTECODE.to_field();\n    packed_public_bytecode[0] = separator;\n\n    // `fields_to_hash` is the number of fields from the start of `packed_public_bytecode` that should be included in\n    // the hash. Fields after this length are ignored.\n    // +1 to account for the separator.\n    let num_fields_to_hash = bytecode_length_in_fields + 1;\n\n    poseidon2_hash_subarray(packed_public_bytecode, num_fields_to_hash)\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = [0; 100];\n    for i in 0..100 {\n        input[i] = i as Field;\n    }\n    let hash = hash_args_array(input);\n    dep::std::println(hash);\n    // Used in yarn-project/stdlib test snapshots:\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_calldata_hash() {\n    let mut input = [0; 100];\n    for i in 0..input.len() {\n        input[i] = i as Field;\n    }\n    let hash = hash_calldata_array(input);\n    dep::std::println(hash);\n    let hash_check = hash_calldata(input.as_slice());\n    assert(hash == hash_check);\n    // Used in cpp vm2 tests:\n    assert(hash == 0x191383c9f8964afd3ea8879a03b7dda65d6724773966d18dcf80e452736fc1f3);\n}\n\n#[test]\nunconstrained fn public_bytecode_commitment() {\n    let mut input = [0; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS];\n    let len = 99;\n    for i in 1..len + 1 {\n        input[i] = i as Field;\n    }\n    input[0] = (len as Field) * 31;\n    let hash = compute_public_bytecode_commitment(input);\n    dep::std::println(hash);\n    // Used in cpp vm2 tests:\n    assert(hash == 0x16d621c3387156ef53754679e7b2c9be8f0bceeb44aa59a74991df3b0b42a0bf);\n}\n"
    },
    "90": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/history/public_storage.nr",
      "source": "use dep::protocol_types::{\n    abis::block_header::BlockHeader, address::AztecAddress,\n    constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX, hash::poseidon2_hash_with_separator,\n    utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\nuse protocol_types::traits::{Hash, ToField};\n\nmod test;\n\npub trait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        // Safety: The witness is only used as a \"magical value\" that makes the proof below pass. Hence it's safe.\n        let witness = unsafe {\n            get_public_data_witness(self.global_variables.block_number, public_data_tree_index)\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert_eq(\n            self.state.partial.public_data_tree.root,\n            root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path),\n            \"Proving public value inclusion failed\",\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(\n                preimage.slot,\n                public_data_tree_index,\n                \"Public data tree index doesn't match witness\",\n            );\n            preimage.value\n        };\n\n        value\n    }\n}\n"
    },
    "95": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n\nmod test {\n    use super::get_public_keys;\n\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use protocol_types::traits::Serialize;\n    use std::test::OracleMock;\n\n    global KEY_ORACLE_RESPONSE_LENGTH: u32 = 13; // 12 fields for the keys, one field for the partial address\n\n    #[test(should_fail_with = \"Invalid public keys hint for address\")]\n    unconstrained fn get_public_keys_fails_with_bad_hint() {\n        let mut env = TestEnvironment::new();\n        let account = env.create_light_account();\n\n        // Instead of querying for some unknown account, which would result in the oracle erroring out, we mock a bad oracle\n        // response to check that the circuit properly checks the address derivation.\n        let mut random_keys_and_partial_address = [0; KEY_ORACLE_RESPONSE_LENGTH];\n        // We use randomly generated points on the curve, and a random partial address to ensure that\n        // this combination does not derive the address and we should see the assertion fail.\n        // npk_m\n        random_keys_and_partial_address[0] =\n            0x292364b852c6c6f01472951e76a39cbcf074591fd0e063a81965e7b51ad868a5;\n        random_keys_and_partial_address[1] =\n            0x0a687b46cdc9238f1c311f126aaaa4acbd7a737bff2efd7aeabdb8d805843a27;\n        random_keys_and_partial_address[2] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // ivpk_m\n        random_keys_and_partial_address[3] =\n            0x173c5229a00c5425255680dd6edc27e278c48883991f348fe6985de43b4ec25f;\n        random_keys_and_partial_address[4] =\n            0x1698608e23b5f6c2f43c49a559108bb64e2247b8fc2da842296a416817f40b7f;\n        random_keys_and_partial_address[5] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // ovpk_m\n        random_keys_and_partial_address[6] =\n            0x1bad2f7d1ad960a1bd0fe4d2c8d17f5ab4a86ef8b103e0a9e7f67ec0d3b4795e;\n        random_keys_and_partial_address[7] =\n            0x206db87110abbecc9fbaef2c865189d94ef2c106202f734ee4eba9257fd28bf1;\n        random_keys_and_partial_address[8] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // tpk_m\n        random_keys_and_partial_address[9] =\n            0x05e3bd9cfe6b47daa139613619cf7d7fd8bb0112b6f2908caa6d9b536ed948ed;\n        random_keys_and_partial_address[10] =\n            0x051066f877c9df47552d02e7dc32127ff4edefc8498e813bca1cbd3f5d1be429;\n        random_keys_and_partial_address[11] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // partial address\n        random_keys_and_partial_address[12] =\n            0x236703e2cb00a182e024e98e9f759231b556d25ff19f98896cebb69e9e678cc9;\n\n        let _ = OracleMock::mock(\"utilityGetPublicKeysAndPartialAddress\").returns(\n            random_keys_and_partial_address.serialize(),\n        );\n        let _ = get_public_keys(account);\n    }\n}\n"
    },
    "99": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::macros::{\n    dispatch::generate_public_dispatch,\n    functions::{stub_registry, utils::check_each_fn_macroified},\n    notes::NOTES,\n    storage::STORAGE_LAYOUT_NAME,\n    utils::{get_trait_impl_method, module_has_storage},\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_private_state` utility function.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[external(...)], #[contract_library_method], or #[test] are not allowed in contracts.\n    check_each_fn_macroified(m);\n\n    // We generate `_compute_note_hash_and_nullifier`, `sync_private_state` and `process_message`\n    // functions only if they are not already implemented. If they are implemented we just insert empty\n    // quotes.\n    let contract_library_method_compute_note_hash_and_nullifier = if !m.functions().any(|f| {\n        f.name() == quote { _compute_note_hash_and_nullifier }\n    }) {\n        generate_contract_library_method_compute_note_hash_and_nullifier()\n    } else {\n        quote {}\n    };\n    let sync_private_state = if !m.functions().any(|f| f.name() == quote { sync_private_state }) {\n        generate_sync_private_state()\n    } else {\n        quote {}\n    };\n    let process_message = if !m.functions().any(|f| f.name() == quote { process_message }) {\n        generate_process_message()\n    } else {\n        quote {}\n    };\n    let public_dispatch = generate_public_dispatch(m);\n\n    quote {\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_private_state\n        $process_message\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    if NOTES.len() > 0 {\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..NOTES.len() {\n            let typ = NOTES.get(i);\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret its raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = <$typ as $crate::protocol_types::traits::Packable>::N;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided note nonce.\n                        let note_hash_for_nullification = aztec::note::utils::compute_note_hash_for_nullification(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(note_nonce).into()\n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullification);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `note_nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_message` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                note_nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_sync_private_state() -> Quoted {\n    // We obtain the `external` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::external(\"utility\")]` in the returned quote because the latter would result in\n    // the function attribute having the full path in the ABI. This is undesirable because we use the information in\n    // the ABI only to determine whether a function is `external(\"private\")`, `external(\"public\")`, or `external(\"utility\")`.\n    let external = crate::macros::functions::external;\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[external(\"utility\")] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[$external(\"utility\")]\n        unconstrained fn sync_private_state() {\n        }\n    }\n}\n\ncomptime fn generate_process_message() -> Quoted {\n    // We obtain the `external` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::external(\"utility\")]` in the returned quote because the latter would result in\n    // the function attribute having the full path in the ABI. This is undesirable because we use the information in\n    // the ABI only to determine whether a function is `external(\"private\")`, `external(\"public\")`, or `external(\"utility\")`.\n    let external = crate::macros::functions::external;\n\n    quote {\n        #[$external(\"utility\")]\n        unconstrained fn process_message(\n            message_ciphertext: BoundedVec<Field, aztec::messages::encoding::MESSAGE_CIPHERTEXT_LEN>,\n            message_context: aztec::messages::processing::message_context::MessageContext,\n        ) {\n            aztec::messages::discovery::process_message::process_message_ciphertext(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n                message_ciphertext,\n                message_context,\n            );\n        }\n    }\n}\n"
    }
  },
  "functions": [
    {
      "abi": {
        "error_types": {
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17398389091582795409": {
            "error_kind": "string",
            "string": "Function _update_value can only be called internally"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "value",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgIEAScCAwQAHwoAAgADAEQcAEREAi0IRAElAAAARiUAAABsJwIBBEUnAgIEADsOAAIAASwAAEMAMGROcuExoCm4UEW2gYFYXSgz6Eh5uXCRQ+H1k/AAAAAmJQAAAPAeAgACAB4CAAMAMyoAAgADAAQnAgIBASQCAAQAAACVJQAAARYeAgACAQoiAkMDFgoDBBwKBAUABCoFAgQnAgIBAAoqAwIFJAIABQAAAMgnAgYEADwGBgEeAgACAAoqBAIDJAIAAwAAAN8lAAABKBwKAQIAJwIBAAcwCgACAAEmKAAABAR4RQwAAAQDJAAAAwAAARUqAQABBdrF9da0SjJtPAQCASYqAQABBQZhOz0Lnb0zPAQCASYqAQABBfFzfrK70t6RPAQCASY=",
      "custom_attributes": [
        "external",
        "internal",
        "public"
      ],
      "debug_symbols": "tVZbjtswDLyLv/MhUi8qV1kEgZM4CwOGE3jjAkXgu5fcSn4UkLBtsz/WSIomHHpI61ldmtP4fmz76+2j2r89q9PQdl37fuxu5/rR3npefVZKHgC62psdj1TtPY/Ic1AMNDAAAS4CYxIIDOSQlRUnIETgdNxyFIGXFRJAEVBaCZCA+w1QcVAIAiwDZAAqAYpAIkQnQFYCAy0rYZp2VRJ4fAxNI/pWijkP93po+ke178eu21U/6m78/NHHve4/x0c98C6rb/oLj0x4bbtG0LRbTqv8UVCoKB5nHGimAEUbEiiQoPGJA51fUdgNBRYoSHlIHKRokeJhw6HzHBqtDZGDsbc5jpIUjSaFoY3JSrEvkOK+WQqSnqWo/FuhPIUnnyh8YMNmgggFIdpZTEK0C/8txOSFFGxOPiQKIoC8yUsWDQizzQNiXkrRo05aQXyxzkCWpByJUUskAbMkBZtqYyOF4aKdGf4tpajyKfUFf7nZXn4JweCXY6A5mUTG5WMILyhXVC+o168m1OQbcYHCAaRic6CXerV/KCkZlChZSwe1SmnYflOkTeazof1MgrqQ0oI/vU+NmLvQTMDt5G/C0HoJw2ZfChYsqsHDrAW8yxYsFvqoth6SxxjbbcEeeFaf22Fz25mEbWjrU9fE6XXsz6vdx8972km3pftwOzeXcWiEaXVl4ucbNwxjD3JvkonbGTpM8te/AA==",
      "is_unconstrained": true,
      "name": "_update_value"
    },
    {
      "abi": {
        "error_types": {
          "14415304921900233953": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "9967937311635654895": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          }
        },
        "parameters": [
          {
            "name": "wormhole_address",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "chain_id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 16
            },
            "visibility": "private"
          },
          {
            "name": "owner",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "message_fee",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "initializer",
        "public"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "constructor"
    },
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "14067204867181196045": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "9921926525851912681": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "wormhole_address",
                "type": {
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                }
              },
              {
                "name": "chain_id",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 16
                }
              },
              {
                "name": "message_fee",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              }
            ],
            "kind": "struct",
            "path": "config::Config"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "utility"
      ],
      "debug_symbols": "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S9b3dSv6Xi8O4iQu4iYa0YlBTCLdjG5GN6Ob0c3oZnQzuhndjG5GN6eb083p5nRzujndnG5ON6eb0y3oFnQLugXdgm5Bt6Bb0C3oFnRLuiXdkm5Jt6Rb0i3plnRLuiXdDt0O3Q7dDt0O3Q7dDt0O3Q7dznND3+vFQZzERdxEIzoxiEmk26DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26LbohuzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMksOs+QwSw6z5DBLDrPkMEsOs+QwSw6z5DBLDrPkMEsOs+QwSw6z5DBLDrMEfa9rFybxPESWAAdxEhdxE43oRLpNuk26Lbotui26Lbotui26Lbotui26Lbptum26bbptum26bbptum26bbptuhndjG5GN6Ob0c3oZnQzuhndjG5ON6eb083p5nRzujndnG5ON6db0C3oFnQLugXdgm5Bt6AbssQLz0NkCbDcsnASF3ETjejEICbxPESWAOl26Hboduh26Hboduh26HbabaHv9eIgTuIibqIRnRjEJNJt0G3QbdBt0G3QbdBt0G3QbdBt0G3SbdJt0m3SbdJt0m3SbdJt0m3SbdFt0W3RbdFt0W3RbdFt0W3RbdFt023TbdNt023TbdNt023TbdNt083oZnQzuhndjG5GN6Ob0c3oZnRzujndnG5ON6eb083p5nRzujndgm5Bt6Bb0C3oFnQLugXdgm5Bt6Rb0i3plnRLuiXdkm5Jt6Rb0u3Q7dDt0O3Q7dDt0O3Q7dDt0I1ZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1ky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bqIRnRjEJJ6HQbegW9At6BZ0C7p91bLrWlgNd7uuZNVwt+szcTXcNW7iN0Jd1KrhrjGISTwPv7porHFrA06NUBtwaoSa2Uniaawmul0fxquJrnESF3ETjfi5rV9hED+3r8tuVxPdxSqGi9+431sNdjXG7bqEVmNcY803CmuE7zCrMa5xECexxrXCTTRiuXlhEJNIt0W3RbdFt7WIu/eiGuManRjEJL7drBY4bGE1u2ELq9ntbtYOYhLP2wvjbhp307ibxt007qbZ2zfjblq8zTLupnE3qwqxhVVv2Dfnbla9YQur3rBQzvUNrm9wfavesFnB3QzuZtUbNiu4m8HdDLoF3ZJuSbd8u1ldYPv71ahdXWCNk/hNp27Vqgus0YhODGISz8MqhouD+LnVbV11gTVuohGdGMRyq/lW4QCrcC4OYrmdwkXcxM/NamZVOBeD+LnZKDwPq3AuDuLn9v22za5+r103kdXv1RjEJNa4385Xv9ffGVRY40bhJC7iJpZbHXGV08UgJvFzq8dy1eS1636ymrx23S5Wk9eu269q8tr1AK6avBqdGMQknod1fbtYbrXqVVkXP7e6w6smr0YjOjGISfzcotah6u3iIE5iudV0qt4uGrHcamZVbxeT+LllbXfVW91PVpNX4yQu4iYa8Rs3a7vrqgesq97F+v9+xtV21fi5fd8D72q7alzETTSiE79jq2db1Xa164602q4uVvFeHMRJXMQadxXWCF+ZVivV/v5w+a5WqsZJrBG8cBON6MQgJrHcvn2rVqrGcquFqoK8uIh/49qv1uErPaunY9Ue1VgjWOF8C1Wld3ETjVjj1pJ8pdeYxPM2oK5kF7mbRjejm9HN6FZVCPyqxepmutqYGoNY529ZoFoKUS3AQZzERdzfYLUkYUQnBjGJ52H+iOvD2sLcRCM6MYhJPA/PjziIk0i3Q7dDt0O3Q7dDt/PcqmGpcRAncRE30YhODGIS6TboNug26DboNug26DboNug26DboNuk26TbpNuk26TbpNuk26TbpNum26Lbotui26Lbotui26Lbotui26Lbptum26bbptum26bbptum26bbpZnQzuhndjG5GN6Ob0c3oZnQzujndnG5ON6eb083p5nRzujndnG5Bt6Bb0C3oFnQLugXdgm5Bt6Bb0i3plnRjliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMksSWZKFSTyNBwFihZO4iJtoRCcGMYkvdM/4Eek26DboNug26DboNug26DboNuk26TbpNuk26TbpNuk26TbpNum26Lbotui26Lbotui26Lbotui26Lbptum26bbptum26bbptum26bbpZnQzuhndjG5GN6Ob0c3oZnQzujndnG5ON6eb083p5nRzujndnG5Bt6Bb0C3oxtuOw9uOw9uOw9uOw9uOw9uOw9uOk3RLuiXdkm5Jt6Rb0i3plnQ7dDt0O3Q7dDt0O3Q7dDt0O3Q77Wa/3484iJO4iJtoRCd+bl9jp1WXUuN5WFkyVuEgTuLn9j05tepSajSiE4OYxHLzDytLLg7iJC7iJhrRiUFMIt0W3RbdKktGrU5lycVNNKITg1huWXgeVpZcLLdTOImLuInfuN+zV6vOI5u1LZUPFyfxG2HWtlQ+XDTiN9/vuZxV51FjEs/DyodZB1T5cHESF7HGreWrmv8ej1l1EzUOYh1xWVTNX9xEIzoxiEn83FatTtX8xUGs+dZKVs1f3EQjOjGISTwPq+YvDiLdDt2q5lftUNX8qtO+av5iEJN4GqubqHEQJ3ERN9GI5WaFQUxiuX1nSXUTNQ5iuUXhIm7i57ZrsKr5i0H83L5vdK26iS5WzV/83L5neFbdRI2L+LlZTadq/qITy62mUzV/8Tysmv8ehFl1EzVO4uf2fQlr1U3UaMTPzWu+VfMXk/i5eblVzV8cxM8tduEibuLnFrVmdf9wMYifW9bG1v0DsPLh4ueWtSSVDxcX8XPLmk7lw0Unfm6nplP5cPE8rHz4nq1YdRM1TuKfm/9qUb/7h0Yj+ofl9t0/NCbxfFg7/2VJ4yD+uXmFbr1Fr3ETP7fK9XqLXmMQP7cKvHqL3sUvSxo/t0q5eote4yJ+blXd9Ra9RicGMYnn4ZcljYM4iYtIt0O3Q7dTbrU6J4mnsd6i9/f0uXAQJ/Fzq4Kst+g1GvFzq3Kqt+g1JvFz+56kW/WGNQ7i5/Y9/LZ6i17jJn5uVm5fljQG8XP7nmJbtYxd/LKk8XP7nm1btYw1LuLn5uX2ZUmjEz+3wGBJPA+/LPGowb4saZzEzy1qUb8saTTi55a1JF+WNObDSo2K12oDs1UHX/lw0YlBTOJ5WPlwcRC/+X7Ptq3awBo30YhODGISz8MvH/xrArVqA2ucxHKrlax8uGjEuh7XSVufLy4msdxqsyoJsg6okuDiJhrRiUFM4nlYSXBxEOmWdEu6Jd2Sbkm3pFvS7dDt0O3Q7dDt0O3Q7dDt0O3Q7Ty3avhqHMRJXMRNNKITg5hEug26DboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptum26Gd2MbkY3o5vRzehmdDO6Gd2Mbk43p5vTzenmdHO6Od2cbk43p1vQLejGLFnMksUsWcySxSxZzJLFLFnMkoUsicJBnMRF3EQjOjGISfzcvq+VrNrLGgex3LJwETfRiE4MYhJP40aWAAdxEhdxEz+37wtFq/6zxiB+bnU/Wf1nFytLLv65Rd1PVqfZ/bHKh+97Mquessbz/dvv4lM9ZY2DOImLuIn2YU39y4fGICax3GqS60ccxM9t1NS/fGjcxM+tnsPUe+0ag5jEz60eqNR77aI+H1fbWtStcL3BrtGITqxxo7DGraP4kiDq+UM1s0U9aahmtsZJXMTPbdZ0viRodGIQP7e6267OuKj76uqMi3qmUJ1xUZf86oyLutOtzrhGIzoxiEk8D7/yj/p8XJ1xjeudRsEzKnimBs/U4JlaNX/xPKyavziIk0i3pFvSLemWdMs6oFqzPA/Pj1gHVCv51XzjIm6iEZ0YxCSexmqzaxzESSy3LNxEIzoxiEn83PZ3xNVm1ziIk/i5fR3lVu+qazTi51aPIqolL+rTTLXkNZbbVwHVktdYbjWdyoeLi7iJRnRiEJN4HlY+XKTbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26ab0c3oZnQzuhndjG5GN6Ob0c3o5nRzujndnG5ON6eb060C5GsZs2r1azwPK0Aujr4kVatf4yJuohGdGMQkvqteNfVFfYCu98/hqlfvn4uvFc3q/XONSTwPKx8uDuIkfuNaldPh+p53xNVN2DiIk/itbz2Mq27CRiM68e1mdRM2vt308SMO4iQu4n5zQM0DnRjEfHOomgdWzV+kG2veWfPOmnfWvLPmnTXv8507PrmSiyu5uJJV85jD4kouriRr3lnzzpp31ryz5p0176x539w31DyQK7m5kpv7VjV/kSvJmnfWvLPmnTXvrHlnzTtr3lnzbtw340oaV9K5ks6V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",
      "is_unconstrained": true,
      "name": "get_config"
    },
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "14067204867181196045": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "9921926525851912681": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 8
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "utility"
      ],
      "debug_symbols": "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bdCNWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWVI9gmOMwklcxE00ohODmMTzsLLkIt0O3Q7dKkvGLDSiE4OYxHNxViNh4yBO4iJuohGdGMQk0m3QbdBt0G3QbdBt0G3QbdBt0G3QbdJt0m3SbdJt0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0W3TbdNt023TbdNt023TbdNt023TzehmdDO6VZaMXbiJRiy3KAxiEs/DypKLgziJi7iJRqSb083p5nQLugXdgm5Bt6Bb0C3oFnQLugXdkm5Jt6Rb0i3plnRLuiXdkm5Jt0O3Q7dDt0O3Q7dDt0O3Q7dDt/Pcxu9HHMRJXMRNNKITg5hEug26DboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptum26Gd2MbkY3o5vRzejGLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLFLFnMksUsWcySxSxZzJLFLFnMksUsWcySxSxZzJLFLFnM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",
      "is_unconstrained": true,
      "name": "get_current_value"
    },
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "14067204867181196045": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "9921926525851912681": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "utility"
      ],
      "debug_symbols": "TJ3JjjTLbqTf5a57kT6QTupVetHoURAgSEAPK718V9CcbrbR+Uz3LzcfgpaRkays//jH//if/+3//fN/+Zd/+1///n/+8U//+T/+8d/+97/867/+yz//l3/99//+X//vv/z7v/39f//jH7/v/6z8xz+t//SP/Sf87z/jH/8Uf/+Z+M/Cfzb+Y/iP4z8H/wn8J+s/9sN/MIphFMMohlEMoxhGMYxiGMUwimMUxyiOURyjOEZxjOIYxTGKYxTHKAejHIxyMMrBKAejHIxyMMrBKAejHIwSGCUwSmCUwCiBUQKjBEYJjBIYJTBKYpTEKIlREqMkRkmMkhglMUpilMQo4/e7/x33v/P+d93/7vtfu//1+99z/xv3v3e8cccbd7xxxxt3vHHHG3e8cccbd7zxN974fZAX5q9hNPyNOdYHq2E3WMPfuMM/+Bt41k9FQ15Yv4bRMBv+Rp77g91gDd7wjWwfRENe+C798S3nu/gBs+Fv5DU+2A3W4A2nIRrywlcOgNEwG3pk65GtR/5KY33b8hUHIBrywlcigNEwG1bDbrCGHtl7ZO+RvUc+PfLpkU+PfHrk0yOfHvn0yKdHPj3y6ZGjR44e+Sun9R3BV1CA3WAN3nAaoiEvfOUFGA09cvbI2SNnj5w9cvbI2SPnHXn+fg2jYTasht1gDd5wGqKhRx498uiRR488euTRI48eefTIo0cePfLokWePPHvk2SPPHnn2yLNHnj3y7JFnjzx75NUjrx559cirR1498uqRV4+8euTVI68eeffIu0fePfLukXePvHvk3SPvHrlqMD7IC1WDBaNhNqyG3WAN3nAaemTrkb1H/mpwjw9mw2r4G3n7B9bgDachGvLCV4OA0TAbVkOPfHrk0yOfm0jzRMNNpBm/htEwG1bDbrAGb+iRo0eOHvmrwZ0fjIbZsBp2gzV4w2mIhgSs369hNMyG1fA3sv0+sAZvOA3RkBe+GgSMhtmwGnrk0SOPHvmrQTsfRENe+GoQMBpmw2rYDdbgDT3y7JFnj7x65NUjrx559cirR1498uqRV4+8euTVI+8eeffIu0fePfLukXePvHvk3SPvHnn3yNYjW49sPbL1yNYjW49sPbL1yNYjW4/sPbL3yN4je4/sPbL3yN4je4/sPbL3yKdHPj3y6ZFPj3x65NMjnx759MinRz49cvTI0SNHjxw9cvTI0SNHjxw9cvTI0SNnj5w9cvbI2SNnj5w9cvbI2SNnj5x35P37NYyG2bAadoM1eMNpiIYeefTIo0cePfLokUePPHrk0SN3De6uwd01uLsGd9fg7hrcXYO7a3B3De6uwd01uLsGd9fg7hrcXYO7a3B3De6uwd01uLsGd9fg7hrcXYO7a3B3De6uwd01uLsGd9fg7hrcXYO7a3B3De6uwd01uLsGd9fg7hrcXYO7a3B3De6uwd01uLsGd9fg7hrcXYO7a3B3De6uwd01uLsGd9fg7hrcXYO7a3B3De6uwd01uLsGd9fg7hrcXYO7a3B3De6uwd01uLsGd9fg7hrcXYO7a3B3De6uwd01uLsGd9fg7hrcXYO7a3B3De6uwd01aF2D1jVoXYPWNWhdg9Y1aF2D1jVoXYPWNWhdg9Y1aF2D1jVoXYPWNWhdg9Y1aF2D1jVoXYPWNWhdg9Y1aF2D1jVoXYPWNWhdg9Y1aF2D1jVoXYPWNWhdg9Y1aF2D1jVoXYPWNWhdg9Y1aF2D1jVoXYPWNWhdg9Y1aF2D1jVoXYPWNWhdg9Y1aF2D1jVoXYPWNWhdg9Y1aF2D1jVoXYPWNWhdg9Y1aF2D1jVoXYPWNWhdg9Y1aF2D1jVoXYPWNWhdg9Y1aF2D1jVoXYPWNWhdg9Y1aF2D1jVoXYPWNWhdg9Y1aF2D1jVoXYPWNWhdg9Y1aF2D1jVoXYPWNehdg9416F2D3jXoXYPeNehdg9416F2D3jXoXYPeNehdg9416F2D3jXoXYPeNehdg9416F2D3jXoXYPeNehdg9416F2D3jXoXYPeNehdg9416F2D3jXoXYPeNehdg9416F2D3jXoXYPeNehdg9416F2D3jXoXYPeNehdg9416F2D3jXoXYPeNehdg9416F2D3jXoXYPeNehdg9416F2D3jXoXYPeNehdg9416F2D3jXoXYPeNehdg9416F2D3jXoXYPeNehdg9416F2D3jXoXYPeNehdg9416F2D3jXoXYPeNehdg9416F2D3jXoXYPeNehdg9416F2D3jV4ugZP1+DpGjxdg6dr8HQNnq7B0zV4ugZP1+DpGjxdg6dr8HQNnq7B0zV4ugZP1+DpGjxdg6dr8HQNnq7B0zV4ugZP1+DpGjxdg6dr8HQNnq7B0zV4ugZP1+DpGjxdg6dr8HQNnq7B0zV4ugZP1+DpGjxdg6dr8HQNnq7B0zV4ugZP1+DpGjxdg6dr8HQNnq7B0zV4ugZP1+DpGjxdg6dr8HQNnq7B0zV4ugZP1+DpGjxdg6dr8HQNnq7B0zV4ugZP1+DpGjxdg6dr8HQNnq7B0zV4ugZP1+DpGjxdg6dr8HQNnq7B0zV4ugZP1+DpGjxdg6dr8HQNnq7B0zV4ugZP1+DpGjxdg9E1GF2D0TUYXYPRNRhdg9E1GF2D0TUYXYPRNRhdg9E1GF2D0TUYXYPRNRhdg9E1GF2D0TUYXYPRNRhdg9E1GF2D0TUYXYPRNRhdg9E1GF2D8dWg/z5YDbvhb2TfH3jDaYiGvFAfyxWMhtmwGnZDj7x75N0j7x5598jWI1uPbD2y9cjWI1uPbD2y9cjWI1uP7D2y98jeI3uP7D2y98jeI3uP7D2y98inRz498umRT498euTTI58e+fTIp0c+PXL0yNEjR48cPXL0yNEjR48cPXL0yNEjZ4+cPXL2yNkjZ4+cPXL2yNkjZ4+cd+T8/RpGw2xYDbvBGrzhNERDjzx65NEjjx559MijRx498uiRR488euTRI88eefbIs0eePfLskWePPHvk2SPPHnn2yKtHXj3y6pFXj7x65K7B7BrMrsHsGsyuwewazK7B7BrMrsHsGsyuwewazK7B7BrMrsHsGsyuwewazK7B7BrMrsHsGsyuwewazK7B7BrMrsHsGsyuwewazK7B7BrMrsHsGsyuwewazK7B7BrMrsHsGsyuwewazK7B7BrMrsHsGsyuwewazK7B7BrMrsHsGsyuwewazK7B7BrMrsHsGsyuwewazK7B7BrMrsHsGsyuwb9P5H+PxqP5aD3aj+yRPzqP4tHzGM9jPI/xPMbzGM9jPI/xPMbzGM9jPI/5PObzmM9jPo/5PObzmM9jPo/5PObzWM9jPY/1PNbzWM9jPY/1PNbzWM9jPY/9PPbz2M9jP4/9PPbz2M9jP4/9PPbzsOdhz8Oehz0Pex72POx52POw52HPw5+HPw9/Hv48/Hn48/Dn4c/Dn4c/j/M8zvM4z+M8j/M8zvM4z+M8j/M8zvOI5xHPI55HPI94HvE84nnE84jnEc8jn0c+j3we+TzyeeTzyOeRzyOfx6vz8ep8vDofr87Hq/Px6ny8Oh+vzser8/HqfLw6H6/Ox6vz8ep8vDofr87Hq/Px6ny8Oh+vzser8/HqfLw6H6/Ox6vz8ep8vDofr87Hq/Px6ny8Oh+vzser8/HqfLw6H6/Ox6vz8ep8vDofr87Hq/Px6ny8Oh+vzser8/HqfLw6H6/Ox6vz8ep8vDofr87Hq/Px6ny8Oh+vzser8/HqfLw6H6/Ox6vz8ep8vDofr87Hq/Px6ny8Oh+vzser8/HqfLw6H6/Ox6vz8ep8vDofr87Hq/Px6ny8Oh+vzser8/HqfLw6H6/Ox6vz8ep8vDofr87Hq/Px6ny8Oh+vzser8/HqfLw6H6/Ox6vz8ep8vDofr87Hq/P56ny+Op+vzuer8/nqfL46n6/O56vz+ep8vjqfr87nq/P56ny+Op+vzuer8/nqfL46n6/O56vz+ep8vjqfr87nq/P56ny+Op+vzuer8/nqfL46n6/O56vz+ep8vjqfr87nq/P56ny+Op+vzuer8/nqfL46n6/O56vz+ep8vjqfr87nq/P56ny+Op+vzuer8/nqfL46n6/O56vz+ep8vjqfr87nq/P56ny+Op+vzuer8/nqfL46n6/O56vz+ep8vjqfr87nq/P56ny+Op+vzuer8/nqfL46n6/O56vz+ep8vjqfr87nq/P56ny+Op+vzuer8/nqfL46n6/O56vz+ep8vjqfr87nq/P56ny+Op+vzuer8/XqfL06X6/O16vz9ep8vTpfr87Xq/P16ny9Ol+vzter8/XqfL06X6/O16vz9ep8vTpfr87Xq/P16ny9Ol+vzter8/XqfL06X6/O16vz9ep8vTpfr87Xq/P16ny9Ol+vzter8/XqfL06X6/O16vz9ep8vTpfr87Xq/P16ny9Ol+vzter82pC8ijKpqpz0J/Hqdbhr84vrUf7kT3yR+dRPMqmr84vPQ9/Hv48/Hn48/Dn4c/Dn4c/j/M8zvM4z+M8j/M8zvM4z+M8j/M8zvOI5xHPI55HPI94HvE84nnE84jnEc8jn0c+j3we+TzyeeTzyOeRzyOfR7ZHNS5dGo/mo/VoP7JH/ug8ikfPYzyP8TzG8xjPYzyP8TzG8xjPYzyP8Tzm85jPYz6P+Tzm85jPYz6P+Tzm85jPYz2P9TzW81jPYz2P9TzW81jPYz2P9Tz289jPYz+P/Tz289jPYz+P/Tz289jPw57Hq/P96ny/Ot+vzver82p4OrPoPIpH2VR1DhqP5qP1aD+yR8/Dn4c/D38e53mc53Gex3ke53mc53Gex3ke53mc5xHPI55HPI94HvE84nnE84jnEc8jnkc+j3we+TzyeeTzyOeRzyOfRz6PbI9qjro0Hs1H69F+ZI/80XkUj57HeB7jeYznMZ7HeB7jeYznMZ7HeB7jecznMZ/HfB7zecznMZ/HfB7zecznMZ/Heh7reaznsZ7Heh7reaznsZ7Heh7reeznsZ/Hfh77eeznsZ/Hfh77eeznsZ+HPQ97HvY87HnY87Dn8ercXp3bq3N7dW6vzu3Vub06t1fn9urcXp3bq3N7dW6vzu3Vub06t1fn9urcXp3bq3N7dW6vzu3Vub06t1fn9urcXp3bq3N7dV4NV8eK7JE/Oo/iUTZVnYPGo/loPXoe+TzyeeTzyOeR7VENWJfGo/loPdqP7JE/Oo/i0Z9HfL9/Va1Yl8aj+Wg92o/skT86j+LR8/jqPGbReDQfrUf7kT3yR+dRPMqm9TzW81jPYz2Pr85jF9kjf3QexaNs+ur80ng0H61Hz2M/j/089vPYz2M/D3se9jzsedjzsOdhz8Oehz0Pex72PPx5+PPw5+HPw5+HPw9/Hv48/HnUr6PWFVa/kQoajz4PL1qP9qPPI4r80Xn055F1NX11Dvrq/NKfR56i+Wg9+vPIGuWr80v+6Hy/vfkrDGI+/Eq9cRAncRE30YhOpFvSLZ9bdXz9PXcvHMRJLLdduIlGdOIhBjEfjh9xECeRboNug26j3KzwEIOYD/Ebs8BBnMRF3EQj0m3SbdJt0m3RbdFt0W3RbdFt0W3RbdFt0W3RbdNt023TbdNt023TbdNt023TbdPN6GZ0M7oZ3YxuRjejm9HN6GZ0c7o53ZxuTjenm9PN6eZ0c7o53Q7dDt0O3Q7dDt0O3Q7dDt0O3Q7dgm5Bt6Bb0C3oFnQLugXdgm5Bt6Rb0i3plnRLuiXdkm5Jt6RbPrf4/YiDOImLuIlGdOIhBpFug26DboNug27Ikig0ohMPMYj5EFkCHMRJXES6TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26bboZ3YxuRjejm9HN6GZ0M7oZ3YxuTjenm9PN6eZ0c7o53ZxuTjen26Hboduh26Hboduh26Hboduh26Fb0C3oFnQLugXdgm5Bt6Bb0C3olnRLuiXdkm5Jt6Rb0i3plnTL55a/H3EQJ3ERN9GITjzEINJt0G3QbdBt0I1ZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkllSP4BijcBIXcRON6MRDDGI+rCy5SLekW9KtsmTMQiM68RCDmBdnNRI2DuIkLuImGtGJhxhEug26DboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptum26Gd2Mbka3ypKxCzfRiOV2Cg8xiPmwsuTiIE7iIm6iEenmdHO6Od0O3Q7dDt0O3Q7dDt0O3Q7dDt0O3YJuQbegW9At6BZ0C7oF3YJuQbekW9It6ZZ0S7ol3ZJuSbekWz638fsRB3ESF3ETjejEQwwi3QbdBt0G3QbdBt0G3QbdBt0G3QbdJt0m3SbdJt0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0W3TbdNt023TbdNt023TbdNt023TbdjG5GN6Ob0c3oZnRjlgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslilixmyWKWLGbJYpYsZslilixmyWKWLGbJYpYsZslilixm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wSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksQd/r9zd9F/pegZUlFz+3vQoncRE30YhOPMQg5sPKkot0c7ohS07hJhrRiYcYxHyILAEO4iTS7dDt0O3Q7dDt0O3QLegWdAu6Bd2CbkG3oFvQLegWdEu6Jd2Sbkm3pFvSLemWdEu65XND3+vFQZzERdxEIzrxEINIt0G3QbdBt0G3QbdBt8oSm4WHGMTPzb5LDn2vFwexrslduIibaEQnHmIQ82FlycVBpNui26Lbotui26Lbotui26bbptum26bbptum26bbptum26ab0c3oZnQzuhndjG5GN6Ob0c3o5nRzujndnG5ON6eb083p5nRzuh26Hboduh26Hboduh26Hboduh26Bd2CbkG3oFvQLegWdAu6Bd2Cbkm3pFvSLemWdEu6Jd2Sbkm3fG7oe704iJO4iJtoRCceYhDpNug26DbohiwZhZtoRCceYhDzIe5LgIM4iXSbdJt0m3SbdJt0m3RbdFt0W3RbdFt0W3RbdFt0W3RbdNt023TbdNt023TbdNt023TbdNt0M7oZ3YxuRjejm9HN6GZ0M7oZ3ZxuTjenm9PN6eZ0c7o53ZxuTrdDt0O3Q7dDt0O3Q7dDt0O3Q7dDt6Bb0C3oFnQLugXdgm5Bt6Bb0C3plnRLuiXdkm5Jt6Rb0i3pls8Nfa8XB3ESF/Fzsyg0ohM/N8e/DWI+rCzxVTiIk7iIm2hEJx5iEPPhpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26ab0c3oZnQzuhndjG5GN6Ob0c3o5nRzujndnG5ON6eb083p5nRzuh26Hboduh26Hboduh26Hboduh26Bd2CbkG3oFvQLegWdAu6Bd2Cbkm3pFvSLemWdEu6Jd2Sbkm3fG7oe704iJO4iJto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",
      "is_unconstrained": true,
      "name": "get_owner"
    },
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14067204867181196045": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "9921926525851912681": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [
          {
            "name": "chain_id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 16
            },
            "visibility": "private"
          },
          {
            "name": "emitter_address",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "boolean"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "utility"
      ],
      "debug_symbols": "TJ3LjjQ9b6Tv5V/PokSJpORbmcVgjoYBwwbmsPLNTydDVMTG3xO/31bokIzKymJX/8c//sf//G//75//y7/82//69//zj3/6z//xj//2v//lX//1X/75v/zrv//3//p//+Xf/+3vf/2Pf/y+/3PiH/80/9M/Tv7jn+LvP/sf/7T//nPqP+P3u/8d9792/zvvf9f9r9//xv1v3v/u+9873rjjjTveuOONO96444073rjjjTveuOONO57d8eyOZ3c8u+PZHc/ueHbHszue3fHsjjfvePOON+94844373jzjjfvePOON+9484637njrjrfueOuOt+5464637njrjrfueOuO53c8v+P5Hc/veH7H8zue3/H8jud3PL/jxR0v7nhxx4s7Xtzx4o4Xd7y448UdL+54ecfLO17e8fKOl3e8/Btv/D6IhmzYDX9jjr8rc+xfw2iwhr9xR3zwN7B9P7W9IRqyYTecC+dvZFsfjAZrmA3fyP6BN0TDN+dvOV/VAA7AvsKZ44PRYA2zYTV4QzRkw244F0aPPHrk0SN/VTTnB6vBG6IhG3bDufAVE2A0WEOPbD2y9cjWI1uPbD2y9cizR5498uyRZ488e+TZI88eefbIs0f+6mv+HYF9BQYYDdYwG1aDN0RDNuyGHtl7ZO+RvUf2Htl7ZO+RvUf2Htl7ZO+Ro0eOHjl65OiRo0eOHjl65OiRo0eOHjl75OyRs0fOHjl75OyRs0fOHjl75OyRd4+8e+TdI+8eeffIu0fePfLukXePvHvk0yOfHvn0yKdHPj3y6ZFPj3x65NMjnzvy/P0aRoM1zIbV8I28P4iGbNgN50LVYMFosIbZsBp65NEjjx75q8E1PjgXvhoE/I284gNrmA2rwRuiIRt2w7nw1SCgR5498uyR502kOb0hGrJhN9xEmuvXMBqsYTb0yKtHXj3yV4PrfLAbzoWvBgGjwRpmw2rwhmjokb1H9h45euSvBv33gTXMhtXgDdGQDbvhXPhqENAjZ4+cPfJXg54feEM0ZMNuOBe+GgSMBmuYDT3y7pF3j7x75N0j7x759MinRz498umRT498euTTI58e+fTI5468fr+G0WANs2E1eEM0ZMNu6JFHjzx65NEjjx559MijRx498uiRR488emTrka1Hth7ZemTrka1Hth7ZemTrka1Hnj3y7JFnjzx75Nkjzx559siz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8/HqfLw6H6/Ox6vz8ep8vDofr87Hq/Px6ny8Oh+vzser8/HqfLw6H6/Ox6vz8ep8vDofr87Hq/Px6ny8Oh+vzser8/HqfLw6H6/Ox6vz8ep8vDq3V+f26txendurc3t1bq/O7dW5vTq3V+f26txendurc3t1bq/O7dW5vTq3V+f26txendurc3t1bq/O7dW5vTq3V+f26txendurc3t1bq/O7dW5vTq3V+f26txendurc3t1bq/O7dW5vTq3V+f26txendurc3t1bq/O7dW5vTq3V+f26txendurc3t1bq/O7dW5vTq3V+f26txendurc3t1bq/O7dW5vTq3V+f26txendurc3t1bq/O7dW5vTq3V+f26txendurc3t1bq/O7dW5vTq3V+f26txendurc3t1bq/O7dW5vTq3V+f26txendurc3t1bq/O7dW5vTq3V+f26txendur8/nqfL46n6/O56vz+ep8vjqfr87nq/P56ny+Op+vzuer8/nqfL46n6/O56vz+ep8vjqfr87nq/P56ny+Op+vzuer8/nqfL46n6/O56vz+ep8vjqfr87nq/P56ny+Op+vzuer8/nqfL46n6/O56vz+ep8vjqfr87nq/P56ny+Op+vzuer8/nqfL46n6/O56vz+ep8vjqfr87nq/P56ny+Op+vzuer8/nqfL46n6/O56vz+ep8vjqfr87nq/P56ny+Op+vzuer8/nqfL46n6/O56vz+ep8vjqfr87nq/P56ny+Op+vzuer8/nqfL46n6/O56vz+ep8vjqfr87nq/P56ny+Op+vzuer8/nqfL46n6/O56vz9ep8vTpfr87Xq/P16ry6lwJN3/EoH/155K/oNH11fmk8skfz0Xrkj+JRPnoe43nY87DnYc/Dnoc9D3se9jzsedjzsOcxn8d8HvN5zOcxn8d8HvN5zOcxn8d8Hut5rOexnsd6Hut5rOexnsd6Hut5rOfhz8Ofhz8Pfx7+PPx5+PPw5+HPw59HPI94HvE84nnE84jnEc8jnkc8j3ge+TzyeeTzyOeRzyOfRz6PfB75PPJ57Oexn8d+Hvt57Oexn8d+Hvt57Oexn8d5Hud5nOdxnsd5Hud5nOdxnsd5Hqc9qjnq0nhkj+aj9cgfxaN8tB89j1fn/urcX51Xp1Ra0Xrkj+JRPtqPTlPVOWg8skfPw56HPQ97HvY8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mCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZMpklk1kymSWTWTKZJeh7rT8GjL7Xi0n83NYsPA8rSy4OohEncRGdGMQk0m3QDVmShYNoxElcRCcGMYmbeB5Ouk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui26Od2cbk43p5vTzenmdHO6Od2cbkG3oFvQLegWdAu6Bd2CbkG3oFvSLemWdKsscStcRCd+bl6XXGXJxU2sa/J7o4u+14uDaMRJXEQnBjGJm0i3Q7dDt0O3Q7dDt0O3Q7dDt0O389zQ93pxEI04iYvoxCAmcRPpNug26DboNug26DboNug26DboNuhmdDO6Gd2MbkY3o5vRzehmdDO6TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26LbotujndnG5ON6eb083p5nRzujndnG5Bt6Bb0C3oFnQLugXdgm5Bt6AbsgR/OX4QjTiJi+jEICZxE8/DTbdNt023TbdNt023TbdNt023TbdDt0O3Q7dDt0O3Q7dDt0O3Q7fz3ND3enEQjTiJi+jEICZxE+k26DboNug26DboNug26DboNug26GZ0M7oZ3YxuRjejm9HN6GZ0M7pNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui26Od2cbk43p5vTzenmdHO6Od2cbkG3yhLfhUacxM8t8G+dGMTPLWbhJp6HlSUXB9GIk7iITgwi3ZJuSbdNt023TbdNt023TbdNt023TbdNt0O3Q7dDt0O3Q7dDt0O3Q7dDt/Pc0Pd6cRCNOImL6MQgJnET6TboNug26DboNug26DboNug26DboZnQzuhndjG5GN6Ob0c3oZnQzuk26TbpNuk26TbpNuk26TbpNuk26Lbotui26Lbotui26Lbotui26Lbo53ZxuTjenm9PN6eZ0c7o5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TbdNtwqQrxUtqtWvcRPPw7p/2MBBNOIkLqITg5jE96pXX421vzfQYcgHYM33FAYxiZt4HlY+XBzEbx++JrmobkLsQ3UTYpnVTXixav7iIH77+z2Mi+ombFxEJ77TrG7Cxk18p2nzRxxEI843B9Q80IlBzDeHqvmL5yFr3ljzxpo31ryx5o01b6x5W+/ascWdXNxJ505WzWMOzp107iRr3ljzxpo31ryx5o01b6x5C54bah7InQzuZPDcquYvcidZ88aaN9a8seaNNW+seWPNG2vekueW3MnkTiZ3cnMnq+a/39SMajdsrJ2chYvoxCDW2moOVfMXz8O6abg4iEacxEUst5rkCWLV/LeT1W6IKqx2w/09mY76nrLGSVzEd0L1PWWNSdzEd61XG2PjIL4TqjbGxkV0YhCTuInvepj2I9YqTuEiOvEb12sfKh+8Zlb5cPE8rHy4OIhGnMRFdGI/TYqJpweFeHoAHEQjTuIiOjGISaTbopvTzenmdHO6Od2cbk43p5vTzekWdAu6Bd2CbkG3oFvQLegWdAu6Jd2Sbkm3pFvSLemWdEu6Jd2Sbptum26bbptum26bbptum26bbptuh26Hboduh26Hboduh26Hbodu57mt3484iEacxEV0YhCTuIl0G3QbdBt0G3QbdBt0G3QbdBt0G3QzuhndjG5GN6Ob0c3oZnQzuhndJt0m3SbdJt0m3SbdJt0m3Zgli1mymCWLWbKYJYtZspgli1mymCWLWbKYJYtZspgli1mymCWLWbKYJYtZspgli1mymCWLWbKYJYtZspgli1mymCWLWbKYJYtZspgli1mymCWLWbKYJYtZspgli1mymCWLWbKYJYtZspgli1mymCWLWbKYJYtZspgli1mymCWLWbKYJYtZspgli1mymCWLWbKYJYtZspgli1nizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWVK9lvv7K+VRvZaNRpzERXRiEJO4ieeh083p5nRzujndnG5ON6eb083p9j71jOq1bDTiJC6iE8ttFSZxE8ut/m29Q7k4iLW2KJzERXRiEJO4iedhvUO5OIh023TbdNt023TbdNt023Q7dDt0O3Sr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",
      "is_unconstrained": true,
      "name": "is_emitter_registered"
    },
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "14067204867181196045": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "9921926525851912681": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [
          {
            "name": "message_ciphertext",
            "type": {
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 17,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec"
            },
            "visibility": "private"
          },
          {
            "name": "message_context",
            "type": {
              "fields": [
                {
                  "name": "tx_hash",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "unique_note_hashes_in_tx",
                  "type": {
                    "fields": [
                      {
                        "name": "storage",
                        "type": {
                          "kind": "array",
                          "length": 64,
                          "type": {
                            "kind": "field"
                          }
                        }
                      },
                      {
                        "name": "len",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "std::collections::bounded_vec::BoundedVec"
                  }
                },
                {
                  "name": "first_nullifier_in_tx",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "recipient",
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::messages::processing::message_context::MessageContext"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "utility"
      ],
      "debug_symbols": "TJ3LsjS7bpzf5Yw9aIIEQOpVPHD4qlCEQorwZaSX9yokwcyJ95fW+ZmoYiG7uhrd6z/+8T/+53/7f//8X/7l3/7Xv/+ff/zTf/6Pf/y3//0v//qv//LP/+Vf//2//9f/+y///m9//7//8Y/f9//sv/93/qd/7PGPf4q//9g//mn9/WfiPwv/8X/80/77T+A/if9s/OfUf84P/xn4j+E/E/9Z+A9WOVjlYJWDVQ5WGb/f/e+4/7X733n/u+5//f437n/z/nff/971xl1v3PXGXW/c9cZdb9z1xl1v3PXGXW/c9eyuZ3c9u+vZXc/uenbXs7ue3fXsrmd3vXnXm3e9edebd71515t3vXnXm3e9edebd71111t3vXXXW3e9dddbd71111t3vXXXW3c9v+v5Xc/ven7X87ue3/X8rud3Pb/r+V0v7npx14u/9cbvg9mwGrzhb80xP8iG3XAu5N+6Iz74W9i+f5XWMBtWgzdEw9/Ktj7YDefC1x6Ab2X/wBpmw1fzdzhfowCi4W/lOT7YDefC1zKA0WANs2E1eEM09MqnVz53Zfu6aM4PRoM1zIbV4A3RkA274VwYvfLolUevPHrl0SuPXnn0yqNXHr3y6JWtV7Ze2Xpl65WtV7Ze+euv6R9kw244F74eA4wGa5gNq8EbeuXZK89eefbKq1devfLqlVevvHrl1SuvXnn1yqtXXr2y98reK3uv7L2y98reK3uv7L2y98reK0evHL1y9MrRK0evHL1y9MrRK0evHL1y9srZK2evnL1y9srZK2evnL1y9srZK+9eeffKu1fevfLulXevvHvl3SvvXnn3yqdXPr1y9eD+YDasBm+IhmzYDQcwqwcLRoM1zIbV8LfyGh9EQzb8rbzig3Ph60HAaLCG2bAavCEasqFXHr2y9cp2E2maNcyG1eAN0ZANu+Em0py/hl559sqzV/56cJ0PvCEasmE3nAtfDwJGgzXMhl559cqrV1698teD/vvgXPh6EDAarGE2rAZviIZs6JW9V45e+etBzw+sYTasBm+IhmzYDefC14OAXjl75eyVs1fOXjl75eyVs1fOXnn3yrtX3r3y7pV3r7x75d0r715598q7Vz698umVT698euXTK59e+fTKp1c+vfK5K6/fr2E0WMNsWA3eEA3ZsBt65dErj1559MqjVx698uiVR688euXRK49e2Xpl65WtV7Ze2Xpl65WtV7Ze2Xpl65Vnrzx75dkrz1559sqzV5698uyVZ688e+XVK69eefXKq1devfLqlVevvHrl1SuvXtl7Ze+VvVf2Xtl7Ze+VvVf2Xtl7Ze+Vo1fuHlzdg6t7cHUPru7B1T24ugdX9+DqHlzdg6t7cHUPru7B1T24ugdX9+DqHlzdg6t7cHUPru7B1T24ugdX9+DqHlzdg6t7cHUPru7B1T24ugdX9+DqHlzdg6t7cHUPru7B1T24uge9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwd39+DuHtzdg7t7cHcP7u7B3T24uwd39+DuHtzdg7t7cHcP7u7B3T24uwd39+DuHtzdg7t7cHcP7u7B3T24uwd39+DuHtzdg7t7cHcP7u7B3T24uwd39+DuHtzdg7t7cHcP7u7B3T24uwd39+DuHtzdg7t7cHcP7u7B3T24uwd39+DuHtzdg7t7cHcP7u7B3T24uwd39+DuHtzdg7t7cHcP7u7B3T24uwd39+DuHtzdg7t7cHcP7u7B3T24uwd39+DuHtzdg7t7cH89GL8PsmE3/K0c38dyXw8CRoM1zIbV4A3RkA27oVc+vfLplU+vfHrl0yufXvn0yqdXPr3yuSuf369hNFjDbFgN3hAN2bAbeuXRK49eefTKo1cevfLolUevPHrl0SuPXtl6ZeuVrVe2Xtl6ZeuVrVe2Xtl6ZeuVZ688e+XZK89eefbKs1eevfLslWevPHvl1SuvXnn1yqtXXr3y6pVXr7x65dUrr17Ze2Xvlb1X9l7Ze2Xvlb1X9l7Ze2XvlaNXjl45euXolaNXjl45euXolaNXjl45e+XslbNXzl45e+XslbNXzl45e+XuwdM9eLoHT/fg6R483YOne/B0D57uwdM9eLoHT/fg6R483YOne/B0D57uwdM9eLoHT/fg6R78+5T992g8skfz0Xrkj+JRPtqPnsd4HuN5jOcxnsd4HuN5jOcxnsd4HuN52POw52HPw56HPQ97HvY87HnY87DnMZ/HfB7zecznMZ/HfB7zecznMZ/HfB7reaznsZ7Heh7reaznsZ7Heh7reazn4c/Dn4c/D38e/jz8efjz8Ofhz8OfRzyPeB7xPOJ5xPOI5xHPI55HPI94Hvk88nnk88jnkc8jn0c+j3we+TzyeeznsZ/Hfh77eeznsZ/Hfh77eeznsZ/HeR7neZzncZ7HeR7neZzncZ7HeR6vz8fr8/H6fLw+H6/Px+vz8fp8vD4fr8/H6/Px+ny8Ph+vz8fr8/H6fLw+H6/Px+vz8fp8vD4fr8/H6/Px+ny8Ph+vz8fr8/H6fLw+H6/Px+vz8fp8vD4fr8/H6/Px+ny8Ph+vz8fr8/H6fLw+H6/Px+vz8fp8vD4fr8/H6/Px+ny8Ph+vz8fr8/H6fLw+H6/Px+vz8fp8vD4fr8/H6/Px+ny8Ph+vz8fr8/H6fLw+H6/Px+vz8fp8vD4fr8/H6/Px+ny8Ph+vz8fr8/H6fLw+H6/Px+vz8fp8vD4fr8/H6/Px+ny8Ph+vz8fr8/H6fLw+H6/Px+vz8fp8vD4fr8/H6/Px+ny8Ph+vz8fr8/H6fLw+H6/P7fW5vT631+f2+txen9vrc3t9bq/P7fW5vT631+f2+txen9vrc3t9bq/P7fW5vT631+f2+txen9vrc3t9bq/P7fW5vT631+f2+txen9vrc3t9bq/P7fW5vT631+f2+txen9vrc3t9bq/P7fW5vT631+f2+txen9vrc3t9bq/P7fW5vT631+f2+txen9vrc3t9bq/P7fW5vT631+f2+txen9vrc3t9bq/P7fW5vT631+f2+txen9vrc3t9bq/P7fW5vT631+f2+txen9vrc3t9bq/P7fW5vT631+f2+txen9vrc3t9bq/P7fW5vT631+f2+txen9vrc3t9bq/P7fW5vT631+f2+ny+Pp+vz+fr8/n6fL4+n6/P5+vz+fp8vj6fr8/n6/P5+ny+Pp+vz+fr8/n6fL4+n6/P5+vz+fp8vj6fr8/n6/P5+ny+Pp+vz+fr8/n6fL4+n6/P5+vz+fp8vj6fr8/n6/P5+ny+Pp+vz+fr8/n6fL4+n6/P5+vz+fp8vj6fr8/n6/P5+ny+Pp+vz+fr8/n6fL4+n6/P5+vz+fp8vj6fr8/n6/P5+ny+Pp+vz+fr8/n6fL4+n6/P5+vz+fp8vj6fr8/n6/P5+ny+Pp+vz+fr8/n6fL4+n6/P5+vz+fp8vj6fr8/n6/P5+ny+Pp+vz+fr8/n6fL4+n6/P5+vz+fq8BpYCc9jz0Xr055G/oniUj/ajc6kGly6NR/ZoPlqP/FE8ykf70fMYz2M8j/E8xvMYz2M8j/E8xvMYz2M8D3se9jzsedjzsOdhz8Oehz0Pex72PObzmM9jPo/5PObzmM9jPo/5PObzmM9jPY/1PNbzWM9jPY/1PNbzWM9jPY/1PPx5+PPw5+HPw5+HPw9/Hv48/Hn484jnEc8jnkc8j3ge8TziecTziOcRzyOfRz6PfB75PPJ55PPI55HPI59HPo/9PPbz2M9jP4/9PPbz2M9jP4/9PPbzOM/jPI/zPM7zOM/j9fl6fb5en6/X5+v1eQ1HpRWNR/ZoPlqP/FE8ykf70Wkaz2M8j/E8xvMYz2M8j/E8xvMYz2M8D3se9jzsedjzsOdhz8Oehz0Pex72PObzmM9jPo/5PObzmM9jPo/5PObzmM9jPY/1PNbzWM9jPY/1PNbzWM9jPY/1PPx5+PPw5+HPw5+HPw9/Hv48/Hn484jnEc8jnkc8j3ge8TziecTziOcRzyOfRz6PfB75PPJ55PPI55HPI59HPo/9PPbz2M9jP4/9PPbz2M9jP4/9PPbzOM/jPI/zPM7zOM/jPI/zPM7zOM/jtEe8Po/X5/H6PF6fx+vzeH0er8/j9Xm8Po/X5/H6PF6fx+vzeH0er8/j9Xm8Po/X5/H6PF6fx+vzeH0er8/j9Xm8Po/X5/H6PF6f13BWetFpqj4HjUf2aD5aj/xRPMpHz2M+j/U81vNYz2M9j/U81vNYz2M9j/U81vPw5+HPw59HfYFuFK1H/ige5aP96DTV1+lA45E9eh5fn+8641+fX4pH+Wg/Ok1fn18aj+zRfPQ88nnk88jn8fX5XkWn6evzS+ORPZqP1iN/FI/y0fPYz+M8j/M8zvM4z+M8j/M8zvM4z+M8j9MeNeR1aTyyR/PReuSP4lE+2o+ex3ge43mM51FfbPWi9cgffR74mmQ+2o8+j+8dSw1+XRqP/jzOKJqP1qM/j5NF8Sgf/XkcrHKavj6/NL5vetb3ML9Gb5zERXRiEJO4iefh1/CNdFt0W3Rb5VZHtZwYxHKr07028Tz0H3EQjTiJi+jEINLN6eZ0i3Kr/Y1BNOIkLqITg5jETTwPk25Jt6Rb0i3plnRLuiXdkm5Jt023TbdNt023TbdNt023TbdNt023Q7dDt0O3Q7dDt0O3Q7dDt0O389xqGq1xEI04iYvoxCAmcRPpNug26DboNug26DboNug26DboNuhmdDO6Gd2MbkY3o5vRzehmdDO6TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26LbotujndnG5ON6eb083p5nRzuiFL8KX18xBZAhxEI07iIjoxiEmkW9At6ZZ0S7ol3ZJuSbekW9It6ZZ023TbdNt023TbdNt023TbdNt023Q7dDt0O3Q7dDt0O3Q7dDt0O3Q7z+38fsRBNOIkLqITg5jETaTboNug26DboNug26DboNug26DboJvRzehmdDO6Gd2MbkY3o5vRzeg26TbpNuk26TbpNuk26TbpNuk26bbotui26Lbotui26Lbotui26Lbo5nRzujndnG5ON6eb083pxiw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsOS9L7PeyxH4vS+z3ssR+L0vs97LEfi9L7PeyxH4vS+z3ssR+P7oNug26DboNug26DboNug26DboNuhndjG5GN6Ob0a2yZNRPq1SWXEziJp6HlSUXB9GIk7iIdJt0m3SrLBlWeB5WllwcRCNO4iI6MYhJpNuim9PN6eZ0c7o53ZxuTjenm9PN6RZ0C7oF3YJuQbegW9At6BZ0C7ol3ZJuSbekW9It6ZZ0S7ol3ZJum26bbptum26bbptum26bbptum26Hboduh26Hboduh26HbpUlYxVu4mmsAcQxsnAQjTiJi+jEICZxE8/DQbdBt0G3QbdBt0G3QbdBt0G3QTejm9HN6GZ0M7oZ3YxuRjejm9Ft0m3SbdJt0m3SbdJt0m3SbdJt0m3RbdFt0W3RbdFt0W3RbdFt0W3RzenmdHO6Od2cbk43p5vTzenmdAu6Bd2CbkG3oFvQLegWdAu6Bd2Sbkm3pFvSLemWdEu6Jd2Sbkm3TbdNt023TbdNt023TbdNt023TbdDt0O3Q7dDt0O3Q7dDt0O3Q7fz3IxZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMktqEnN8v2JqNYrZmMRNPA8rSy4OohEncRHplnRLulWW2Cg8DytLLg6iESdxEZ0YxCTSbdPt0O3Q7dDt0O3Q7dDt0O3Q7dDtPLca1mwcRCNO4iI6MYhJ3ES6DboNug26DboNug26DboNug26DboZ3YxuRjejm9HN6GZ0M7oZ3Yxuk26TbpNuk26TbpNuk26TbpNuk26Lbotui26Lbotui26Lbotui26Lbk43p5vTrbLEZuEiOrHcojCJm3geVpZcHEQjTuIiOpFuQbegW9At6ZZ0S7ol3ZJuSbekW9It6ZZ023TbdNt023TbdNt023TbdNt023Q7dDt0O3Q7dDt0O3Q7dDt0O3Q7z81/P+IgGnESF9GJQUziJtJt0G3QbdBt0G3QbdBt0G3QbdBt0M3oZnQzuhndjG5GN6Ob0c3oZnSbdJt0m3SbdJt0m3SbdJt0m3SbdFt0W3RbdFt0W3RbdFt0W3RbdFt0c7o53ZxuTjenm9ONWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4sySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWYK5VzsfIkuAg2jESVxEJwYxiZtIt6Bb0K2ypP42COZeLy6iE4OYxE08DytLLg4i3ZJuSbekW9It6ZZ0S7ptulWWTCs04iQuohODmMRNPA8rSy7S7dDt0O3Q7dDt0O3Q7dDtPDfMvV4cRCNO4iI6MYhJ3ES6DboNug26DboNug26DboNug26DboZ3YxuRjejm9HN6GZ0M7oZ3Yxuk26TbpNuk26TbpNuk26TbpNuk26Lbotui26Lbotui26Lbotui26Lbk43p5vTzenmdHO6Od2cbk43p1vQLegWdAu6Bd2CbkG3oFvQLeiWdEu6Jd2Sbkm3pFvSLemWdEu6bboxSzazZDNLNrNkM0s2s2QzSzazZDNLNrNkM0s2s2QzSzazZDNLNrNkM0s2s2QzSw6z5DBLDrPkMEsOs+QwSw6z5DBLDrPkMEsOs+QwSw6z5DBLDrPkMEsOs+QwSw6z5DBLDrPkMEsOs+QwSw6z5DBLDrPkMEsOs+QwSw6z5DBLDrPkMEsOs+QwSw6z5DBLDrPkMEsOs+QwSw6z5DBLDrPkMEsOs+QwSw6z5DBLDrPkMEsOs+QwSw6z5DBLDrPkMEsOswRzr/ObecLc68VBNOIkLqITg5jETaRb0i3plnRLuiXdkm5Jt6Rb0i3ptum26bbptum26bbptum26bbptul26Hboduh26Hboduh26Hboduh22m1i7vXiIBpxEhfRiUFM4ibSbdBt0G3QbdBt0G3QbdBt0G3QbdANWRKFg2jEctuFi+jEICZxE89DZAlwEI1It0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0U3p5vTzenmdHO6Od2cbk43p5vTLegWdAu6Bd2CbkG3oFvQLegWdEu6Jd2Sbkm3pFvSLemWdEu6Jd023TbdNt023TbdNt023TbdNt023Q7dDt0O3Q7dDt0O3Q7dDt0O3c5zw9zrxUE04iQuohODmMRNpNug26DboNug26DboNug26DboNugm9HN6GZ0Y5YMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWYJ5l4X/oTuJC7i57ZmYRCTuImnEXOvFwfRiJO4iE4MYh1bFm7ieYgsAQ6iESdxEZ0YRLoNug26Gd2MbkY3o5vRzehmdDO6Gd2MbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui25ON6eb083p5nRzujndnG5ON6dbZYlb4SAa8XPzuuQqSy46sa7JVZjETTwPK0suDqIRJ3ERnUi3pFvSLem26bbptum26bbptum26bbptum26Xboduh26Hboduh26Hboduh26HaeG+ZeLw6iESdxEZ0YxCRuIt0G3QbdBt0G3QbdBt0G3QbdBt0G3YxuRjejm9HN6GZ0M7oZ3YxuRrdJt0m3SbdJt0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0U3p5vTzenmdHO6Od2cbsiSUbiJ5yHuS4CDaMRJXEQnBpFuQbegW9It6ZZ0S7ol3ZJuSbekW9It6bbptum26bbptum26bbptum26bbpduh26Hboduh26Hboduh26Hbodp4b5l4vDqIRJ3ERnRjEJG4i3QbdBt0G3QbdBt0G3QbdBt0G3QbdjG5GN6Ob0c3oZnQzuhndjG5Gt0m3SbdJt0m3SbdJt0m3SbdJt0m3RbdFt0W3RbdFt0W3RbdFt8oS34XnYWXJxc8t6n9bWXJxEj+3mIVODGISN/E8rCy5OIhGnES6Bd2CbkG3oFvQLemWdEu6Jd2Sbkm3pFvSLemWdNt023TbdNt023TbdNt023TbdNt0O3Q7dDt0O3Q7dDt0O3Q7dDt0O88Nc68XB9GIk7iITgxiEjeRboNug26DboNug26DboNug26DboNuRjejm9HN6GZ0M7oZ3YxuRjej26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26LbopvTzenmdHO6MUuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSWYe/3+WsjE3OvFTTwPkSXAQTTiJC6iE+kWdAu6Bd0qSzIKB9GI5WaFi+jEICZxE89DZAlwEI1It023TbdNt023TbdNt0O3Q7dDt0O3Q7dDt0O3Q7dDt/PcMPd6cRCNOImL6MQgJnET6TboNug26DboNug26DboNug26DboZnQzuhndjG5GN6Ob0c3oZnQzuk26TbpNuk26TbpNuk26TbpNuk26Lbotui26Lbotui26Lbotui26Lbo53ZxuTjenm9PN6eZ0c7o53ZxuQbegW9At6BZ0C7oF3YJuQbegW9It6ZZ0Y5ZsZslmlmxmyWaWbGbJZpZsZslmlmxmyWaWbGbJZpZsZslmlmxmyWaWbGbJZpZsZslmlmDudc9CJwbxc/t+0H1i7vXiacTc6z6Fg2jEz+38ChfRiUFM4iaeh5UlFwfRiHQbdBt0G3SrLDlRuInn4Zclf59pFw6iEeeHdR6+LGl04p+bfT+VOGvutXETz4ffXtTca+Mgfm6jyvmypHERnRjEJG7iebh+xEGk26Lbotui26Lbotui26Kb083p5nRzujndnG5ON6eb083pFnQLugXdgm5Bt6Bb0C3oFnQLuiXdkm5Jt6Rb0i3plnRLuiXdkm6bbptum26bbptum26bbptum26bboduh26Hboduh26Hboduh26HbqfdVs29Ng6iESdxEZ0YxCRuIt0G3QbdBt0G3QbdBt0G3QbdBt0G3YxuRjejm9HN6GZ0M7oZ3YxuRrdJt0m3SbdJt0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0U3p5vTzenmdHO6Od2cbk43p5vTLegWdAu6Bd2CbkG3oFvQLegWdEu6Jd2Sbkm3pFvSLemWdEu6Jd023TbdNt023TbdNt023TbdNt0qS75fjVk199o4iJ+b7cJJXMTP7ftG5aq518Ykfm6z3CpLCmvutfFz+z7hXzX32jiJn9v3ud6qudfGIH5uyws38TysLPlGAFbNvTYa8XPzWqyy5KITP7f4FSZxEz+3qHorSy4O4uf2vVVeNffauIifW1a9lSUXk/i5ZZ2zyhJgZcnFzy1PoREncRGdGMQkbuJ5WFlykW6Lbotui26Lbotui26LbotuTjenm9PN6eZ0c7o53ZxuTjenW9At6BZ0qyzZdT1Ullx04ue2a7MqSy5u4nlYWXJxEI04iYvoRLol3ZJuSbfKku8vMK2ae2004ud2rHARnfi5nTrMypKLm3geVpZcHEQjTuIiOpFuh25flsxf1ftlCbDmXhvHh1ZoxElcH+5CJwYxPzyFm3ge1jvs+p9+F98cv8JvgVEO32XWuInn4XeZNQ6iESdxEZ1It6Bb0C3olnRLuiXdkm5Jt6Rb0i3plnRLum26bbptum26bbptum26bbptum26Hboduh26Hboduh26Hboduh26nedWI5GNg2jESVxEJwYxiZtYbl/D1khk4yAacRIXsdxOYRCTuImf2/djjKtGIhs/t++X5laNRDZO4iI6MYhJ/NxsFZ6H80cstyg04iSWW9U7nRjEJG7iefi9ZM3vJxJWjUQ2GnESP7dZlX0vWY1B/NxWnajvJavxPPxesuaqxb6XrEYj1lFk4bdu3cLUmOOfz4eVD6tKr3y4aMRJXEQnfuvWjU2NOTZu4nlY+VD3ODXm2Pi5eRVZ+XBxEZ0YxCR+blEXQeUDsPLh4iB+blEdUPlw8XOLKrLy4WIQk1huZVz5AKx8uDiIRpzEzy2rnMqHi0FM4ueWVWTlQ2GNOTaWmxcacRI3sVb4jqKGFGfdyuHPqhdUXafQiUH86vr+eueqEcXG87B6e5dB9fbFz6vuDWpEsXERP7ddNVRvX0ziJp6H1dsXa91dWCtUvdWv3xO+VWOHjedh9evFr966/aixw8ZJXEQnfm6njqL69eImltt3pdfYYeMgGnESF7Hcaquqiy/mw+rii7VCnZLq14u1Qu1F9evFJFa9dc6qX4HVrxf/6l1131OjhI3zwzoPX782+odV+tev61fn4evXvze4hX9ua2CF8/Dr18bPbVRlX782TuK37iiLXSuUxakVyuLUCnXwp1aoS+PrwVUvPTUIuOp9Zw0CNm7it65969YgYOMgfkdcLxw13LcqZ2u47++CLzwPR62wC2uFU2jESVzE70zOX2EQk7iJ5+HXhY2DaMRadxTWClXkrP/BLPzKqVehmsdrdGIQz8NVK9TZWZNYK9SJWlV6nSiv/22dEp/ERSy3Og8exCTut66f9/8bP+IgGnG+I45FdGIQeWz5ewdUzXCRR1yXPa6HuuzrNbqm3taqU12X/cXzsC77i4NoxEn86l1V2fcy1RjEcqst3OVWpVeL1NOJmnpb9dpfU2/3oq0WuTiJtW6ds2qRi5v4retfZTXf1jiIX73f9yVWzaytug2ombW/vi08D6tF6o6gZtb+9rTQiJO4iN958CgMYhI38TysFrk4iEasdbOwVqgiq0XqIUwNlK26p6iBssYkbuJnXHcaNVDWOIhGnMRFdGIQk7iJdHO6Od2cbk43p5vTzenmdHO6Od2CbkG3oFvQLegWdKt+q9usmhdrHEQjTuIiOjGISdxEum26bbptum26bbptum26bbptum26Hboduh26Hbodup3nVhNcf/9vYblF4edW9401q7XqDrEGqf5enwuNOImfRd0L1iDVqpu9GqRqTOImnoffnVjjIBpxEheRbpNu1UN1Y1iDVI3nYfXQrnqrhy4a8XOr+7MapGp04udWtz41SNW4iZ9b3X7VIFXjIBpxEhfRiUFM4ibSLegWdKtuqfvJGo5adbNXw1Hr+3Plq4ajLlbjXBxEI07iIjoxiEmkW9Jt023TbdNt023TbdOtGqfuMms4qnETz8NqnIuDaMRJXEQn0u3Q7dDte1Hz74+urxqOahzE9eEozA+tcH84C8/D8SMOohEncRGdGMQk0m3Qzehm5bYKjTiJi+jEICZxE8/D+SPSbdJt0m3SbdJt0m2WWxRu4nm4fsRBNGKtm4W1wi78Vqg3FTXE1DiIRpzERXRiEJO4iXQLugXdotzqMopJXEQnBjEfZq1be5y1Qp2+XEQn1gpemMRNPA/3jziIRpzERXQi3TbddrnVtuzz8PyI5XYKjfi51Tu1GkzyesRXg0leb89qMKkxiZ9bvT2rwSRgDSZ53ZnXYJLX7W0NJnm9z6rBpMZFdGIQ82F1d72jqmEjr3dUNWzk9Taqho0ag/itUG8qatio8TysPr44iLVuHVD1Zr3zqQEir3dUNUB0sXrz4iAacRIX0YlBLLc64urNi+dh9Wa93akBokYjTuLnVu9maoCoMYifW72FqQGixvOw+rje7tQAUaMRJ3ERnVhudVKrjy9uYrnVqa4+vjiIRnRirVDbEudhdWy9YaqhoEYjfvV6nZ3q44tODGISN/E8rD6+OIhGpNum26bbptum26bbptuh26Hboduh26Hboduh26HboVv18fd20msoqHEQy20WTuIilpsXBrHcduEmnofV3RcHsdxO4SR+bt/7Qq+hII+qrHr+e2PjNRTUuImfW6wPq+cvDuLn9t3bew0FNS6iE4OYDysJvsfOXoM+HnUU1fNRpVfPXwxiEr96sw6oeh5YPX9xEI34uWUdZvV81lmvns8qp3o+y6J6HljdvetMVh/vWqw6dtdi1bEXN/GrbNd2V8deHEQjTuIiOrHc6vTVK+/F/bBaGpVVS180YlnUqa6WvujEz+Lgf5vETfwO6FQ51dIXP7dTR1wtfXESP7dT10619MUgJnETz8Nq6YuDaMRJpNuh26Hboduh23luNZvTOIhGnMRFdGIQk1huXngeVktfLLcsNOIkltsudGIQk1hup/DPLb43Cl6zOfG9O/CazWk04vxwFi6iE4OYxE08D+ePOIhGpNuk26TbLLdRmMRNPA/XjziIRpzEcquzvpwYxHKLwk08D/1HLLfaITfiJAaxVqht+UIhRm3LFwqNRpzEb4VRO/S9jMeos5M/4iAacRIX8TviUYeZQUziJp6H+0ccRCOWW53fvYhODGK51enbm1hudf2eH3EQPzerU/L1fOMiOjGI2VjTMvHdunvNxcT3YYjXXEx89+teczGNQUziV+93F+81F3Nx/IiDaMTPbVYNXx83OjGISdzEz+278fb6PbjGQTRiuZVx9fFFJ5ZbFn5uqyyqjy9+bqtOVPXxxc9t1TmrPr44iYvoxCAmcRPPw+rji3RbdFt0W3RbdFt0W3RbdFt0c7o53ZxuTjenm9PN6eZ0c7o53YJuQbegW9At6BZ0C7oF3YJuQbekW9It6Vb5sOqqrny46MQglltdO5UPF8/DyoeLg2jESVxEJwaRbptum26Hboduh26Hboduh26n1v1ypwaa/j65KDRirbALF9GJQUziJp6HlQTf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",
      "is_unconstrained": true,
      "name": "process_message"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14415304921900233953": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15546539856497705002": {
            "error_kind": "string",
            "string": "u16 to u8 conversion failed"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16810041750452690220": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 27
          },
          "17398389091582795409": {
            "error_kind": "string",
            "string": "Function _update_value can only be called internally"
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "6788092787179896647": {
            "error_kind": "string",
            "string": "Caller is not owner"
          },
          "8228371833434187583": {
            "error_kind": "string",
            "string": "Trying to read from uninitialized PublicImmutable"
          },
          "9967937311635654895": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          }
        },
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JwACBAEoAAABBIBSJwAABFInAgIEAScCAwQAHwoAAgADAFEtCFEBJQAAAEElAAAAvCcCAQRSJwICBAA7DgACAAEsAABDADBkTnLhMaApuFBFtoGBWF0oM+hIeblwkUPh9ZPwAAAAJwBEAmMnAEUEBikAAEYE/////ycARwQDJwBIAQAnAEkEACcASgAAJwBLAQEnAEwEAScATQABJwBOBAInAE8EBCsAAFAAAAAAAAAAAAEAAAAAAAAAACYlAAAfvikCAAIAlBI/PwoqAQIDJwIEBAAnAgYEAwAqBAYFLQgBAgAIAQUBJwMCBAEAIgICBS0OBAUAIgUCBS0OBAUnAgUEAwAqAgUEJwIEAAYnAgUABScCBgAHJwIHBAUkAgADAAABKSMAAAi4LQgBCCcCCQQFAAgBCQEnAwgEAQAiCAIJHzAATwBMAAktCAEJAAABAgEtDggJLQgBCAAAAQIBLQxJCCcCCwQMLQgADC0KCQ0tCggOAAgACwAlAAAf5C0CAAAtCg0KACIKTAwtCwwLJwIMBA0tCAANLQoJDi0KCA8ACAAMACUAAB/kLQIAAC0KDgoAIgpMDS0LDQwcCgwNAxwKDQoAJwINBA4tCAAOLQoJDy0KCBAACAANACUAAB/kLQIAAC0KDwwAIgxMDi0LDg0nAg4EDy0IAA8tCgkQLQoIEQAIAA4AJQAAH+QtAgAALQoQDAAiDEwJLQsJCBwKCAwGHAoMCQAeAgAIAC0IAQwnAg4EAwAIAQ4BJwMMBAEAIgwCDjYOAAgADgAAIgxMDy0LDw4AIgxOEC0LEA8cCg4MAAQqDA8QJAIADgAAAngnAgwEADwGDAEtCAEMJwIOBAMACAEOAScDDAQBACIMAg42DgAIAA4CACIMTA4tCw4IACIMTg8tCw8OHAoIDAAEKgwODyQCAAgAAALEJwIMBAA8BgwBLQgBCCcCDAQCAAgBDAEnAwgEAQAiCAIMHzAATABJAAwAIghMDi0LDgwcCgwOBBwKDggALQgBDAAAAQIBJwIOAMwtDg4MLQgBDgAAAQIBJwIRAM0tDhEOLQgBEScCEgQFAAgBEgEnAxEEAQAiEQISHzAATwBMABItCAESAAABAgEnAhMALC0IARQnAhUEBgAIARUBJwMUBAEAIhQCFS0KFRYtDhMWACIWAhYtDEoWACIWAhYtDEoWACIWAhYtDEoWACIWAhYtDEoWLQ4UEi0ISQMjAAADmgwiA08TJAIAEwAAH2gjAAADrC0LEhEtCAESJwITBAQACAETAScDEgQBACISAhMtChMULQxKFAAiFAIULQxKFAAiFAIULQxKFCsCABMAAAAAAAAAAAUAAAAAAAAAAC0IARQnAhUEBQAIARUBJwMUBAEAIhQCFS0KFRYtDEoWACIWAhYtDEoWACIWAhYtDEoWACIWAhYtDhMWLQgBEwAAAQIBLQ4SEy0IARIAAAECAS0OFBItCAEUAAABAgEtDEkULQgBFQAAAQIBLQxIFS0ISQMjAAAEbwwqAwcWJAIAFgAAHyEjAAAEgScCFgQXLQgAFy0KExgtChIZLQoUGi0KFRsACAAWACUAACBVLQIAAC0KGBEtCwwSLQsOEy0OEgwtDhMOLQgBDCcCDgQEAAgBDgEnAwwEAQAiDAIOLQoOEi0MShIAIhICEi0MShIAIhICEi0MShIrAgAOAAAAAAAAAAADAAAAAAAAAAAtCAESJwITBAUACAETAScDEgQBACISAhMtChMULQxKFAAiFAIULQxKFAAiFAIULQxKFAAiFAIULQ4OFC0IARMAAAECAS0ODBMtCAEMAAABAgEtDhIMLQgBEgAAAQIBLQxJEi0IARQAAAECAS0MSBQnAhUADScCFgQXLQgAFy0KExgtCgwZLQoSGi0KFBstChUcAAgAFgAlAAAgwS0CAAAnAhUEFi0IABYtChMXLQoMGC0KEhktChQaLQoIGwAIABUAJQAAIMEtAgAAJwIIBBUtCAAVLQoTFi0KDBctChIYLQoUGS0KERoACAAIACUAACDBLQIAACcCEQQVLQgAFS0KExYtCgwXLQoSGC0KFBkACAARACUAACBVLQIAAC0KFggKKg8IDCQCAAwAAAY1JQAAIcAKIhBKCCcCEQQSLQgAEgAIABEAJQAAIdItAgAALQoTDC0KFA8kAgAMAAAGaicCEQQAPAYRAQoqEA8MEioIDA8kAgAPAAAGgSUAACH4LQgBCCcCDAQDAAgBDAEnAwgEAQAiCAIMLQoMDy0OBA8AIg8CDy0MTQ8nAg8EEC0IABAtCggRLQhOEi0ISBMACAAPACUAACIKLQIAAC0KEQw0AgAMLQgBCCcCDAQEAAgBDAEnAwgEAQAiCAIMLQoMDy0MSg8AIg8CDy0MSg8AIg8CDy0MSg8tCAEMJwIPBAUACAEPAScDDAQBACIMAg8tCg8QLQxKEAAiEAIQLQxKEAAiEAIQLQxKEAAiEAIQLQ4OEC0IAQ4AAAECAS0OCA4tCAEIAAABAgEtDgwILQgBDAAAAQIBLQxJDC0IAQ8AAAECAS0MSA8nAhAEES0IABEtCg4SLQoIEy0KDBQtCg8VLQoLFgAIABAAJQAAIMEtAgAAJwIQBBEtCAARLQoOEi0KCBMtCgwULQoPFS0KChYACAAQACUAACDBLQIAACcCEAQRLQgAES0KDhItCggTLQoMFC0KDxUtCgkWAAgAEAAlAAAgwS0CAAAnAhEEEi0IABItCg4TLQoIFC0KDBUtCg8WAAgAEQAlAAAgVS0CAAAtChMQLQgBCCcCDAQFAAgBDAEnAwgEAQAiCAIMLQoMDi0OCw4AIg4CDi0OCg4AIg4CDi0OCQ4AIg4CDi0OEA4tCEkDIwAACGYMIgNPCSQCAAkAAB71IwAACHgwCgANAAUwCABKAAYeAgADADQCAAMtCwIDACIDAgMtDgMCACICAgktCwkIJwIKBAIAKgkKAzsOAAgAAyMAAAi4KQIAAwAVD8uDCioBAwgnAgMEICcCCQIAJwIKBB8kAgAIAAAI4iMAAA24JwILBCEtCAEMJwINBCIACAENAScDDAQBACIMAg0fMgALAEwADS0IAQ0AAAECAS0IAQ4AAAECAQAiDEwQLQsQDy0ODA0tDEwOHAoPEAMcChAMAC0IAQ8nAhAEIQAIARABJwMPBAEAIg8CECcCEQQgACoREBEtChASDioREhMkAgATAAAJdS0MShIAIhICEiMAAAlaLQgBEAAAAQIBLQ4PEC0ISQgjAAAJiwwqCAMPJAIADwAAHoAjAAAJnS0LDQstCw4PACoPAxEOKg8REiQCABIAAAm8JQAAI5wtDgsNLQ4RDi0LEAstCAENAAABAgEtDgsNLQgBCwAAAQIBLQxJCy0IAQ4nAg8EIQAIAQ8BJwMOBAEAIg4CDycCEAQgACoQDxAtCg8RDioQERIkAgASAAAKIy0OCREAIhECESMAAAoILQgBDwAAAQIBLQ4ODy0ISQgjAAAKOQwqCAMOJAIADgAAHfQjAAAKSy0LDwseAgANAB4CAA4AMyoADQAOAA8kAgAPAAAKbiUAACOuLwoABQANJwIPBBAtCAAQAAgADwAlAAAh0i0CAAAtChEFLQoSDiQCAAUAAAqkJwIPBAA8Bg8BCioNDgUkAgAFAAAKtiUAACPALQgBBScCDQQgAAgBDQEnAwUEAQAiBQINJwIOBB8AKg4NDi0KDQ8OKg4PECQCABAAAAr3LQ4JDwAiDwIPIwAACtwtCAENAAABAgEtDgUNLQhJCCMAAAsNDCoICgUkAgAFAAAdsCMAAAsfLQsNCC0IAQsAAAECAS0MTQstCAENAAABAgEtDEoNKAIADgABAC0ISQUjAAALTQwqBQoPJAIADwAAHXAjAAALXy0LDQUtCAEIJwILBAMACAELAScDCAQBACIIAgstCgsNLQ4EDQAiDQINLQ4MDScCDAQNLQgADS0KCA4tCE4PLQhIEAAIAAwAJQAAI9ItAgAALQoOCwoiC0oICiIISAwkAgAMAAALyiUAACVkLQgBCCcCDAQDAAgBDAEnAwgEAQAiCAIMLQoMDS0OCw0AIg0CDS0OBQ0nAgsEDC0IAAwtCggNLQhODi0ISA8ACAALACUAACPSLQIAAC0KDQUKIgVKCAoiCEgLJAIACwAADDElAAAlZC0IAQgnAgsEAwAIAQsBJwMIBAEAIggCCy0KCwwtDgQMACIMAgwtDgUMJwIMBA0tCAANLQoIDi0ITg8tCEgQAAgADAAlAAAiCi0CAAAtCg4LNAIACy0IAQgnAgsEBAAIAQsBJwMIBAEAIggCCy0KCwwtDEoMACIMAgwtDEoMACIMAgwtDEoMLQgBCycCDAQFAAgBDAEnAwsEAQAiCwIMLQoMDS0MSg0AIg0CDS0MSg0AIg0CDS0MSg0AIg0CDS0MUA0tCAEMAAABAgEtDggMLQgBCAAAAQIBLQ4LCC0IAQsAAAECAS0MSQstCAENAAABAgEtDEgNJwIOBA8tCAAPLQoMEC0KCBEtCgsSLQoNEy0ITRQACAAOACUAACDBLQIAACcCDwQQLQgAEC0KDBEtCggSLQoLEy0KDRQACAAPACUAACBVLQIAAC0KEQ4wCABNAAUAIgVNCDAKAA4ACC0LAgUAIgUCBS0OBQIAIgICCy0LCwgnAgwEAgAqCwwFOw4ACAAFIwAADbgpAgAFALCKc9AKKgEFCCQCAAgAAA3TIwAAF8otCAEIJwILBAQACAELAScDCAQBACIIAgsfMABHAEwACy0IAQsAAAECAS0OCAstCAEIAAABAgEtDEkIJwINBA4tCAAOLQoLDy0KCBAACAANACUAACV2LQIAAC0KDwwAIgxMDi0LDg0cCg0OAxwKDgwAHAoMDQMnAg4EDy0IAA8tCgsQLQoIEQAIAA4AJQAAJXYtAgAALQoQDAAiDEwPLQsPDhwKDg8CHAoPDAAcCgwOAicCDwQQLQgAEC0KCxEtCggSAAgADwAlAAAldi0CAAAtChEMACIMTAstCwsIHgIACwAeAgAMADMqAAsADAAPJAIADwAADs4lAAAjricCDwQQLQgAEAAIAA8AJQAAIdItAgAALQoRCy0KEgwkAgALAAAO/icCDwQAPAYPAS0IAQsnAg8EAwAIAQ8BJwMLBAEAIgsCDy0KDxAtDgQQACIQAhAtDE0QJwIPBBAtCAAQLQoLES0IThItCEgTAAgADwAlAAAiCi0CAAAtChEEHgIACwAzKgAEAAsADyQCAA8AAA9oJQAAJectCAEEJwILBAQACAELAScDBAQBACIEAgstCgsPLQxKDwAiDwIPLQxKDwAiDwIPLQxKDy0IAQsAAAECAS0OBAstCEkFIwAAD7AMIgVHBCQCAAQAAB0qIwAAD8ItCwsFACIFTA8tCw8LACIFThAtCxAPHAoPEQMcChEQABwKEA8DACIFRxEtCxEQHAoQEQYcChEFACgCABAEAQAnAhIBAC0IAREnAhMEIQAIARMBJwMRBAEAIhECEycCFAQgQwOqAAwAEAAUABIAEy0IARAnAhIEIAAIARIBJwMQBAEAIhACEicCEwQfACoTEhMtChIUDioTFBUkAgAVAAAQcS0OCRQAIhQCFCMAABBWLQsQEgAiEgISLQ4SEC0LEBIAIhICEi0OEhAtCxASACISAhItDhIQLQsQEgAiEgISLQ4SEC0LEBIAIhICEi0OEhAtCxASACISAhItDhIQLQgBEgAAAQIBJwITAwgaKg8TFBwKFBYCHAoWFQMcChUUAhwKDxcCHAoXFgMcChYXAigCABgDAQAEKhUYGQYqGRgbCiobFRokAgAaAAAREyUAACX5ACoZFhUOKhkVGiQCABoAABEqJQAAI5wKKhUPFiQCABYAABE8JQAAJgsaKg0TDxwKDxUCHAoVEwMcChMPAhwKDRYCHAoWFQMcChUWAgQqExgZBioZGBsKKhsTGiQCABoAABF7JQAAJfkAKhkVEw4qGRMYJAIAGAAAEZIlAAAjnAoqEw0VJAIAFQAAEaQlAAAmCy0IAQ0nAhMEIAAIARMBJwMNBAEAIg0CEy0KExUtDEQVACIVAhUtDhQVACIVAhUtDhcVACIVAhUtDg8VACIVAhUtDhYVACIVAhUtDgkVACIVAhUtDgkVACIVAhUtDgkVACIVAhUtDgkVACIVAhUtDgkVACIVAhUtDgkVACIVAhUtDgkVACIVAhUtDgkVACIVAhUtDgkVACIVAhUtDgkVACIVAhUtDgkVACIVAhUtDgkVACIVAhUtDgkVACIVAhUtDgkVACIVAhUtDgkVACIVAhUtDgkVACIVAhUtDgkVACIVAhUtDgkVACIVAhUtDgkVACIVAhUtDgkVACIVAhUtDgkVACIVAhUtDgkVACIVAhUtDgkVACIVAhUtDgkVACIVAhUtDgkVACIVAhUtDgkVLQgBCScCDwQJAAgBDwEnAwkEAQAiCQIPLQoPEy0ODRMAIhMCEy0OEBMAIhMCEy0OEBMAIhMCEy0OEBMAIhMCEy0OEBMAIhMCEy0OEBMAIhMCEy0OEBMAIhMCEy0OEBMtDgkSJwIJBBktCEkEIwAAE0MMKgQJDSQCAA0AAByeIwAAE1UnAgcEGi0ISQQjAAATYwwiBEUJJAIACQAAHBIjAAATdS0LEgQAIgRHCS0LCQctCwcJACIJAgktDgkHJwIJBActAgcDJwAEBCAlAAAmHS0IBQ0AKg0JDy0ODg8tAgQDJwAEBAklAAAmHS0IBQcAIgdHCS0ODQktDgcSLQgBBAAAAQIBLQgBCQAAAQIBLQgBDScCDgT+AAgBDgEnAw0EAQAiDQIOJwIPBP0AKg8ODy0KDhAOKg8QESQCABEAABQhLQxKEAAiEAIQIwAAFAYtDg0ELQxMCS0IAQ0nAg4E+QAIAQ4BJwMNBAEAIg0CDicCDwT4ACoPDg8tCg4QDioPEBEkAgARAAAUai0MShAAIhACECMAABRPLQgBDgAAAQIBLQ4NDi0IAQ0nAg8EIAAIAQ8BJwMNBAEAIg0CDycCEAQfACoQDxAtCg8RDioQERIkAgASAAAUuC0MShEAIhECESMAABSdJwIPBAgnAhAE+C0ISQMjAAAUywwqAw8RJAIAEQAAGtojAAAU3S0LDgcnAgoE/S0ISQMjAAAU7wwqAxANJAIADQAAGmkjAAAVAS0LCQMAKgMQBw4qAwcNJAIADQAAFRwlAAAjnC0LBAMMKgcKDSQCAA0AABUyJQAAJoEtAgMDJwAEBP4lAAAmHS0IBQ0AIg0CDgAqDgcPLQ4FDwAiB0wDDioHAwUkAgAFAAAVaSUAACOcDCoDCgUkAgAFAAAVeyUAACaBLQINAycABAT+JQAAJh0tCAUFACIFAgcAKgcDDi0MTQ4AIgNMBw4qAwcNJAIADQAAFbIlAAAjnAwqBwoDJAIAAwAAFcQlAAAmgS0CBQMnAAQE/iUAACYdLQgFAwAiAwINACoNBw4tDgwOACIHTAUOKgcFDCQCAAwAABX7JQAAI5wMKgUKByQCAAcAABYNJQAAJoEtAgMDJwAEBP4lAAAmHS0IBQcAIgcCDAAqDAUNLQ4IDS0OBwQAIgVMAw4qBQMEJAIABAAAFkglAAAjnC0OAwknAgUE/QYiBQIDJwIJBAMAKgUJCC0IAQQACAEIAScDBAQBACIEAggtDgUIACIIAggtDgUIJwIJBAMAKgQJCAAiBwIJLQIJAy0CCAQtAgUFJQAAJpMtCwQFACIFAgUtDgUEKQIABQBl785+ACIKAgctAgoDLQIEBCcABQQBJQAAJsUtCAYILQgHCS0OBQkAIggCCS0LCQUnAgoEAgAqCQoEOQOgAEYARgALAAUABCACAAQhAgAFLQgBCAAiCAILLQsLCicCDAQCACoLDAkiMgAFAEkACS0KBQonAgwEAwAqCgwLAAgBCwEnAwgEAQAiCAIMLQ4KDAAiDAIMLQ4KDC0KCgcGIgcCByQCAAQAABeJIwAAF2AtCwgDACIDAgMtDgMIACIIAgUtCwUEJwIJBAIAKgUJAzwOBAMjAAAXiQoiB0wDJAIAAwAAF58nAgQEADwGBAEtCwIDACIDAgMtDgMCACICAgUtCwUEJwIHBAIAKgUHAzsOAAQAAyMAABfKKQIAAwDto9woCioBAwQkAgAEAAAX5SMAABitLQgBAycCBAQCAAgBBAEnAwMEAQAiAwIEHzAATABMAAQAIgNMBS0LBQQcCgQFAhwKBQMAHgIABAAeAgAFADMqAAQABQAHJAIABwAAGDclAAAjrh4CAAQBCiIEQwUWCgUHHAoHCAAEKggEBwoiBUgEJAIABAAAGGUnAggEADwGCAEeAgAEAAoqBwQFJAIABQAAGHwlAAAnxjAKAAMABi0LAgMAIgMCAy0OAwIAIgICBS0LBQQnAgYEAgAqBQYDOw4ABAADIwAAGK0nAgICVScCAwJuJwIEAmsnAgUCbycCBgJ3JwIHAiAnAggCcycCCQJlJwIKAmwnAgsCdCcCDAJyJwINAnsnAg4CfS0IAQ8nAhAEHAAIARABJwMPBAEAIg8CEC0KEBEtDgIRACIRAhEtDgMRACIRAhEtDgQRACIRAhEtDgMRACIRAhEtDgURACIRAhEtDgYRACIRAhEtDgMRACIRAhEtDgcRACIRAhEtDggRACIRAhEtDgkRACIRAhEtDgoRACIRAhEtDgkRACIRAhEtDEQRACIRAhEtDgsRACIRAhEtDgURACIRAhEtDgwRACIRAhEtDgcRACIRAhEtDg0RACIRAhEtDggRACIRAhEtDgkRACIRAhEtDgoRACIRAhEtDgkRACIRAhEtDEQRACIRAhEtDgsRACIRAhEtDgURACIRAhEtDgwRACIRAhEtDg4RCiBISwIkAgACAAAaaScCAwQeLQgBBCcCBQQeAAgBBQEtCgQFKgMABQXpSUPomzfdLAAiBQIFACIPAgYnAgcEGy0CBgMtAgUELQIHBSUAACaTJwIGBBsAKgUGBS0MTQUAIgUCBS0OAQUAIgUCBTwOAwQtCwkNACoDDQ4OKgMODyQCAA8AABqEJQAAI5wAIgcCDwAqDwMRLQsRDS0LBA8MKg4KESQCABEAABqoJQAAJoEtAg8DJwAEBP4lAAAmHS0IBREAIhECEgAqEg4TLQ4NEy0OEQQAIgNMDS0KDQMjAAAU7wAiBwITACoTAxQtCxQSLQsSEwAiEwITLQ4TEi0LDRMAIhMCEy0OEw0tCAETAAABAgEtDg0TLQhJESMAABsYDCoRChQkAgAUAAAbySMAABsqLQsTEgQqAwoTLQhJESMAABs8DCoRChQkAgAUAAAbXCMAABtOACIDTBEtChEDIwAAFMsAKhMRFA4qExQVJAIAFQAAG3MlAAAjnAAiEgIWACoWERctCxcVLQsOFgwqFBAXJAIAFwAAG5clAAAmgS0CFgMnAAQE+SUAACYdLQgFFwAiFwIYACoYFBktDhUZLQ4XDgAiEUwULQoUESMAABs8ACISAhUAKhURFi0LFhQcChQVAC0LExQtAhQDJwAEBCAlAAAmHS0IBRYAIhYCFwAqFxEYLQ4VGC0OFhMAIhFMFC0KFBEjAAAbGAAqBwQJDCoJAw0kAgANAAAcKSUAACaBACIRAg8AKg8JEC0LEA0tCxIJACIJThAtCxAPLQsPEAAiEAIQLQ4QDy0CDwMnAAQEICUAACYdLQgFEAAiEAITACoTBBQtDg0ULQIJAycABAQJJQAAJh0tCAUNACINTg8tDhAPLQ4NEgAiBEwJLQoJBCMAABNjACoHBA0AIhECEAAqEAQTLQsTDy0LEhAAIhBMFC0LFBMtCxMUACIUAhQtDhQTDCoNChQkAgAUAAAc3SUAACaBLQITAycABAQgJQAAJh0tCAUUACIUAhUAKhUNFi0ODxYtAhADJwAEBAklAAAmHS0IBQ0AIg1MDy0OFA8tDg0SACIETA0tCg0EIwAAE0McCgUEAAAoTQQPLwoADwAELQsLDy0CDwMnAAQEBCUAACYdLQgFEAAiEAIRACoRBRItDgQSLQ4QCwAiBUwELQoEBSMAAA+wLQsNDwAiCAIRACoRBRItCxIQHAoQEQAtCwsQBCoREBIAKg8SES0OEQ0EKhAODy0ODwsAIgVMDy0KDwUjAAALTQAiCwIOACoOCA8tCw8FLQsNDi0CDgMnAAQEICUAACYdLQgFDwAiDwIQACoQCBEtDgURLQ4PDQAiCEwFLQoFCCMAAAsNLQsNDi0LCxAMKhADESQCABEAAB4OJQAAJoEAIg4CEgAqEhATLQsTEQAiEEwSDioQEhMkAgATAAAeMyUAACOcLQ4ODS0OEgscChEQAhwKEA4AHAoOEAItCw8OLQIOAycABAQhJQAAJh0tCAURACIRAhIAKhIIEy0OEBMtDhEPACIITA4tCg4IIwAACjktCw0PLQsOEQAqEQgSDioREhMkAgATAAAenyUAACOcDCoSCxEkAgARAAAesSUAACaBACIPAhMAKhMSFC0LFBEtCxAPLQIPAycABAQhJQAAJh0tCAUSACISAhMAKhMIFC0OERQtDhIQACIITA8tCg8IIwAACYscCgMJAAAoTQkKACIIAgsAKgsDDC0LDAkwCgAJAAoAIgNMCS0KCQMjAAAIZgAiEQIXACoXAxgtCxgWJwIXBBgtCAAYLQoTGS0KEhotChQbLQoVHC0KFh0ACAAXACUAACDBLQIAAAAiA0wWLQoWAyMAAARvACIDTBMAIhECFQAqFQMWLQsWFC0LEhUMKhMHFiQCABYAAB+RJQAAJoEtAhUDJwAEBAYlAAAmHS0IBRYAIhYCFwAqFxMYLQ4UGC0OFhItChMDIwAAA5ooAAAEBHhSDAAABAMkAAADAAAf4yoBAAEF2sX11rRKMm08BAIBJiUAAB++LQsCAy0LAQQMIgNPBSQCAAUAACADJQAAJoEAIgQCBgAqBgMHLQsHBS0IAQYnAgcEAgAIAQcBJwMGBAEAIgYCBy0KBwgtDgUIACIDTAUOKgMFByQCAAcAACBIJQAAI5wtDgQBLQ4FAi0KBgEmJQAAH74tCwQFCiIFSAYkAgAGAAAgdCcCBwQAPAYHAScCBQQGLQgABi0KAQctCgIILQoDCS0KBAoACAAFACUAACfYLQIAAC0LAQUtCwIGLQsDBy0OBQEtDgYCLQ4HAy0MSwQAIgZMAi0LAgEmJQAAH74tCwQGCiIGSAckAgAHAAAg4CcCCAQAPAYIAS0LAwYKIgZHByQCAAcAACFcIwAAIPYtCwEHLQsCCAwiBkcJJAIACQAAIRAlAAAmgS0CBwMnAAQEBCUAACYdLQgFCQAiCQIKACoKBgstDgULACIGTAUOKgYFByQCAAcAACFHJQAAI5wtDgkBLQ4IAi0OBQMtDEgEIwAAIb8nAgYEBy0IAActCgEILQoCCS0KAwotCgQLAAgABgAlAAAn2C0CAAAtCwEGLQsCBy0LBAgtAgYDJwAEBAQlAAAmHS0IBQkAIglMCi0OBQotDgkBLQ4HAi0MTAMtDggEIwAAIb8mKgEAAQWKVTosK2fI7zwEAgEmJQAAH74eAgABAQoiAUMCFgoCAxwKAwIABCoCAQQtCgQCLQoDASYqAQABBcgNc3NuzbThPAQCASYlAAAfvhwKAgUABCIFUAYtCAEFJwIHBAQACAEHAScDBQQBACIFAgctCgcILQxKCAAiCAIILQxKCAAiCAIILQxKCC0IAQcnAggEBQAIAQgBJwMHBAEAIgcCCC0KCAktDEoJACIJAgktDEoJACIJAgktDEoJACIJAgktDgYJLQgBBgAAAQIBLQ4FBi0IAQUAAAECAS0OBwUtCAEHAAABAgEtDEkHLQgBCAAAAQIBLQxICC0ISQQjAAAiwwwiBE4JJAIACQAAIz4jAAAi1SQCAAMAACLiIwAAIxInAgEECS0IAAktCgYKLQoFCy0KBwwtCggNLQhNDgAIAAEAJQAAIMEtAgAAIwAAIxInAgIECS0IAAktCgYKLQoFCy0KBwwtCggNAAgAAgAlAAAgVS0CAAAtCgoBJgwqBAIJJAIACQAAI1AjAAAjjgAiAQIKACoKBAstCwsJJwIKBAstCAALLQoGDC0KBQ0tCgcOLQoIDy0KCRAACAAKACUAACDBLQIAACMAACOOACIETAktCgkEIwAAIsMqAQABBdAH6/TLxmeQPAQCASYqAQABBQZhOz0Lnb0zPAQCASYqAQABBV40JmzSP79HPAQCASYlAAAfvhwKAgUABCIFUAYtCAEFJwIHBAQACAEHAScDBQQBACIFAgctCgcILQxKCAAiCAIILQxKCAAiCAIILQxKCC0IAQcnAggEBQAIAQgBJwMHBAEAIgcCCC0KCAktDEoJACIJAgktDEoJACIJAgktDEoJACIJAgktDgYJLQgBBgAAAQIBLQ4FBi0IAQUAAAECAS0OBwUtCAEHAAABAgEtDEkHLQgBCAAAAQIBLQxICC0ISQQjAAAkiwwiBE4JJAIACQAAJQYjAAAknSQCAAMAACSqIwAAJNonAgEECS0IAAktCgYKLQoFCy0KBwwtCggNLQhNDgAIAAEAJQAAIMEtAgAAIwAAJNonAgIECS0IAAktCgYKLQoFCy0KBwwtCggNAAgAAgAlAAAgVS0CAAAtCgoBJgwqBAIJJAIACQAAJRgjAAAlVgAiAQIKACoKBAstCwsJJwIKBAstCAALLQoGDC0KBQ0tCgcOLQoIDy0KCRAACAAKACUAACDBLQIAACMAACVWACIETAktCgkEIwAAJIsqAQABBbq7IdeCMxhkPAQCASYlAAAfvi0LAgMtCwEEDCIDRwUkAgAFAAAllSUAACaBACIEAgYAKgYDBy0LBwUtCAEGJwIHBAIACAEHAScDBgQBACIGAgctCgcILQ4FCAAiA0wFDioDBQckAgAHAAAl2iUAACOcLQ4EAS0OBQItCgYBJioBAAEFcjEMljOspz88BAIBJioBAAEFBQQbmSCvYEw8BAIBJioBAAEF18BnoWD/gCo8BAIBJi0BAwYKAAYCByQAAAcAACYzIwAAJjwtAAMFIwAAJoAtAAEFAAABBAEAAAMECS0AAwotAAULCgAKCQwkAAAMAAAmdi0BCggtBAgLAAAKAgoAAAsCCyMAACZSJwEFBAECAAYCBiYqAQABBeQIUEUCtYwfPAQCASYAAAMFBy0AAwgtAAQJCgAIBwokAAAKAAAmxC0BCAYtBAYJAAAIAggAAAkCCSMAACagJi0BBAgAAAQCDAQAAwUJAAAMAgwtAQwKAAAMAgsAAAkFDA4ADAoNCgAIAg4kAAANAAAm/SMAACdLJAAADgAAJwojAAAnHC0ABAYAAAYCDy0EDA8jAAAnRicAEAQDAAAKEA8tAAEGAAABDwEnAQYEAQAABgIPLQQMDwAADwIPLQQKDyMAACd/JwAQBAIEAAwQDycAEQQDAAAPERAtAAEGAAABEAEnAQYEAQAABgIQLQQMEAAAEAIQLQQPECcADgQDAAAGDg0AAA0FDgIACQIPAAAODxAAAAsPEQwAEQsPJAAADwAAJ8EtARESLQQSEAIAEQIRAgAQAhAjAAAnnS0ADQcmKgEAAQXxc36yu9LekTwEAgEmJQAAH74tCEkFIwAAJ+YMIgVHBiQCAAYAAChOIwAAJ/gtCwIFLQsFBgAiBgIGLQ4GBS0IAQYnAgcEBQAIAQcBJwMGBAEAIgUCBycCCAQEACIGAgk/DwAHAAktCwEFLQsDBy0LBAgtDgUBLQ4GAi0OBwMtDggEJi0LAwYMKgUGByQCAAcAAChkIwAAKMYtCwIHACIHAgkAKgkFCi0LCggtCwEJACIJAgsAKgsFDC0LDAoAKggKCy0LBAgtAgcDJwAEBAUlAAAmHS0IBQoAIgoCDAAqDAUNLQ4LDS0OCQEtDgoCLQ4GAy0OCAQjAAAoxgAiBUwGLQoGBSMAACfm",
      "custom_attributes": [
        "external",
        "public"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "public_dispatch"
    },
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14067204867181196045": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15711892660910782274": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16216212843441549037": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "18173155084464344029": {
            "error_kind": "string",
            "string": "Emitter not registered"
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "2014890719615096298": {
            "error_kind": "string",
            "string": "Field failed to decompose into specified 40 limbs"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "3378875131383195299": {
            "error_kind": "string",
            "string": "Invalid destination chain ID"
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "4648451262681811962": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "5191497793084186475": {
            "error_kind": "string",
            "string": "Invalid payload ID"
          },
          "7555607922535724711": {
            "error_kind": "string",
            "string": "Preimage mismatch"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9589626482238399944": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "9921926525851912681": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "anchor_block_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "sponge_blob_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "vaa",
            "type": {
              "kind": "array",
              "length": 2000,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "length",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "note_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 32,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "log",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "fields",
                                          "type": {
                                            "kind": "array",
                                            "length": 18,
                                            "type": {
                                              "kind": "field"
                                            }
                                          }
                                        },
                                        {
                                          "name": "length",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::log::Log"
                                    }
                                  },
                                  {
                                    "name": "note_hash_counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "anchor_block_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "sponge_blob_hash",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "private"
      ],
      "debug_symbols": "TJ3Ljjy9jtzf5ay9KF1IkX4VLwxfBwMMZgBfVgO/uzsZoiI2p39xvn8rlCkxKiuLnfXv//jv/+O//t9/+s///K//89/+9z/+43/693/81//1z//yL//8T//5X/7tv/2X//PP//avf//vv//j9/3P2P/4j9N8/7//8I/x6f33/47/8I898GPix8KPjR+GH44fBz8CP7J+GEYxjGIYxTCKYRTDKIZRDKMYRjGM4hjFMYpjFMcojlEcozhGcYziGMUxysEoB6McjHIwysEoB6McjHIwysEoB6MERgmMEhglMEpglMAogVECowRGCYySGCUxSmKUxCiJURKjJEZJjJIYJTHK+P3uz3F/zvtz3Z/7/rT70+/Pc3/G/XnHG3e8cccbd7xxxxt3vHHHG3/jre/nuT/j/kz8nH/j+fdz3J/z/lz35994+f38xqtf8IbTEA15Yf0avlmeD2bDatgN38jxgTechm/k7yhWXqg9X/A38twfzIbVsBuswRtOQzTkha8OAD2y9cjWI3/1ML+z8lUEwBtOQzTkha82AKNhNqyGHtl7ZO+RvUf2Htl75NMjnx759MinRz498umRT498euTTI58e+auh+S3BV0WA2bAadoM1eMNpiIa8kD1y9sjZI2ePnD1y9sjZI2ePnD1y3pHn79cwGmbDatgN1uANpyEaeuTRI48eefTIo0cePfLokUePPHrk0SOPHnn2yLNHnj3y7JFnjzx75Nkjzx559sizR1498uqRV4+8euTVI68eefXIq0dePfLqkXePvHvk3SPvHnn3yLtH/mpwjQ9OQzTkha8GAaNhNqyG3WANPbL1yNYjfzW4/ip3fjUIGA3fyPnBatgN1uANpyEa8sJXg4DR0COfHvn0yOcm0jzecBqi4SbSjF/DaJgNq2E39MjRI0eP/NXgnh/kha8GAaNhNqyG3WAN3nAaeuS8I6/fr2E0fCOvD1bDbrAGbzgN0ZAXvhoEjIYeefTIo0f+atB+H3jDaYiGvPDVIGA0zIbVsBt65Nkjzx559sizR1498uqRV4+8euTVI68eefXIq0dePfLqkXePvHvk3SPvHnn3yLtH3j3y7pF3j7x7ZOuRrUe2Htl6ZOuRrUe2Htl6ZOuRrUf2Htl7ZO+RvUf2Htl7ZO+RvUf2Htl75NMjnx759MinRz498umRT498euTTI58eOXrk6JGjR44e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gm5Bt6Rb0i3plnRLuiXdkm5Jt6RbPrdqgmscxElcxE00ohMPMYh0G3QbdGOWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJYks+a7GE1kCHMRJXMRNNKITDzGIdEu6Jd2QJVa4iJtoRCceYhDz4vwhS4CDOImLuIlGdOIhBpFug26DboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptum25GN2TJKZzERfzcxq/QiE48xCDmw8qSi4M4iYtIN6eb083p5nRzuh26Hboduh26Hboduh26Hboduh26Bd2CbkG3oFvQLegWdAu6Bd2Cbkm3pFvSLemWdEu6Jd2Sbkm3fG54RtfFQZzERdxEIzrxEINIt0G3QbdBt0G3QbdBt0G3QbdBt0G3SbdJt0m3SbdJt0m3SbdJt0m3SbdFt0W3RbdFt0W3RbdFt0W3RbdFt023TbdNt023TbdNt023TbdNt003o5vRzehmdGOWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJYpYsZslilixmyWKWLGbJYpYsZslilixmyWKWLGbJYpYsZslilixmyWKWLGbJYpYsZMn6EFkCHMRJXMRNNKITDzGIdFt0W3RDluzCRdxEIzrxEIOYD5ElwEGk26bbptum26bbptum26ab0c3oZnQzuhndjG5GN6Ob0c3o5nRzujndnG5ON6eb083p5nRzuh26Hboduh26Hboduh26Hboduh26Bd2CbkG3oFvQLegWdAu6Bd2Cbkm3pFvSLemWdEu6Jd2Sbkm3fG779yMO4iQu4iYa0Ynl5oVBzIfIkiwcxElcxE00ohMPMYj5cNJt0m3SbdJt0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0W3TbdNt023TbdNt023TbdNt023TzehmdDO6Gd2MbkY3o5vRzehmdHO6Od2cbk43p5vTzenmdHO6Od0O3Q7dDt0O3Q7dDt0O3Q7dDt0O3YJuQbegW9At6BZ0C7oF3YJuQbekW9It6ZZ0S7ol3ZJuSbekWz43+/2IgziJi7iJRnTiIQaRbswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZslhlhxmyWGWVCvq32cfhZtoRCceYhDzYWXJxUGcRLoNug26VZZ8X7cxqzG1MYj5sLLk4iBO4iJuohHpNuk26Tbptui26Lbotui26FZZMq3QiYcYxHxYWXJxECdxETeRbptum26bbptuRjejm9HN6GZ0M7oZ3YxuRjejm9PN6eZ0c7o53ZxuTjenm9PN6Xboduh26Hboduh26Hboduh26HboFnQLugXdgm5Bt6Bb0C3oFnQLuiXdkm5Jt6Rb0i3plnRLuiXd8rlVr2vjIE7iIm6iEZ14iEGk26DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26IbsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWYK+13kKN9GITjzEIOZDZAlwECeRbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptum25GN6Ob0c3oZnQzuhndjG5GN6Ob083p5nRzujndnG5ON6eb083pduh26HboduiGLMlCIzrxc6uv90Lf68V8WFlycRAncRE30YhOpFvQLeiWdEu6Jd2Sbkm3pFvSLemWdMt2W+h7vTiIk7iIm2hEJx5iEOk26DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26Tbptui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26WZ0M7oZ3YxuRjejm9HN6GZ0M7o53ZxuTjenm9PN6eZ0c7o53Zxuh26Hboduh26Hboduh26Hboduh25Bt6Bb0C3oFnQLugXdgm5Bt6Bb0i3plnRLuiXdkm5Jt6Rb0o1ZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1mCvtfvK3UX+l4vBrHc/ENkCXAQJ3ERN9GITjzEINLN6YYs+RVO4iJuohGdeIhBzIfIEiDdDt0O3Q7dDt0O3Q7dDt0O3YJuQbegW9At6BZ0C7oF3YJuQbekW9It6ZZ0S7ol3ZJuSbekWz439L1eHMRJXMRNNKITDzGIdBt0G3QbdBt0qyzZVmhEJ35u2wuDmA+RJadwECdxETfRiE48xCDmw0W3RbdFt0W3RbdFt0W3RbdFt0W3TbdNt023TbdNt023TbdNt023TTejm9HN6GZ0M7oZ3YxuRjejm9HN6eZ0c7o53ZxuTjenm9PN6eZ0O3Q7dDt0O3Q7dDt0O3Q7dDt0O3QLugXdgm5Bt6Bb0C3oFnQLugXdkm5Jt6Rb0i3plnRLuiXdkm753ND3enEQJ3ERN9GITjzEINJt0A33XnfhJC7iJhrRiYcYxHyIe69Auk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptum26Gd2MbkY3o5vRzehmdDO6Gd2Mbk43p5vTzenmdHO6Od2cbk43p9uh26Hboduh26Hboduh26HboduhW9At6BZ0C7oF3YJuQbegW9At6JZ0S7ol3ZJuSbekW9It6ZZ0y+eGvteLg/i52ShcxE383Az/1omH+LmZF+bDypKLgziJi7iJRnTiIdJt0G3SbdJt0m3SbdJt0m3SbdJt0m3SbdFt0W3RbdFt0W3RbdFt0W3RbdFt023TbdNt023TbdNt023TbdNt083oZnQzuhndjG5GN6Ob0c3oZnRzujndnG5ON6eb083p5nRzujndDt0O3Q7dDt0O3Q7dDt0O3Q7dDt2CbkG3oFvQLegWdAu6Bd2CbkG3pFvSLemWdEu6Jd2Sbkm3pFs+N/S9XhzESVzETTSiEw8xiHRjljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPkMEsOs+QwSw6z5DBLDrPkMEsOs+QwSw6zBH2v39d1LPS9XpzERdxEIzrxEIOYDyfdJt0m3SbdKks8C43oxDo2KwxiPkSWAAdxEhdxE43oRLotui26bbptum26bbptum26bbptum26bboZ3YxuRjejm9HN6GZ0M7oZ3YxuTjenm9PN6eZ0c7o53ZxuTjen26Hboduh26Hboduh26Hboduh26Fb0C3oFnQLugXdgm5Bt6Bb0C3olnRLuiXdkm5Jt6Rb0i3plnTL54a+14uDOImLuIlGdOIhBpFug26DboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSxB3+vxwnxYWXLxc/ueqL7Q93pxET+3mIVGdOLnFqswiPmwsuTiIE7iIm6iEZ1IN6eb0+3QrbIksnASF/FzyzoPlSUXnfi5ZZ2HypKL+fDLkvk9KnFV32vjJK4Pay2+LGk0on9Y0/mypDGI+TB/xEGcxEXcRCPSLemWdMvnVn2vjYM4iYu4iUZ04iEGkW6DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26bbkY3o5vRzehmdDO6Gd2MbkY3o5vTzenmdHO6Od2cbk43p5vTzel26Hboduh26Hboduh26Hboduh26BZ0C7oF3YJuQbegG7MkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS/Jlyf69LNm/lyX797Jk/16W7N/Lkv17WbJ/L0v272XJ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c4WcK+STuIibyN3nXCHnCjlXyLlCh7uPqeGH++FwPxzuh8qHuqleDYuN+bDyoW7nVcPiqRt31bDYuIibaEQnHmIQ82G+u0mOuwfATTSiEw8xiNl4cPcAOIiTuIibaEQnHmIQ6TboNug26DboNug26DboNug26DboNuk26TbpNuk26TbpNuk26TbpNum26Lbotui26Lbotui26Lbotui26LbptunGe45n023TbdNt023TbdNt083oZnQzuhndjG5GN6Ob0c3oZnRzujndnG5ON6eb083p5nRzujndDt0O3Q7dDt0O3Q7dDt0O3Q7dDt2CbkG3oFvQLegWdAu6Bd2CbkG3pFvSjVlymCWHWXKYJYdZcpglh1lymCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWVK/l30tUoRGdeIhBzMbqtWwcxElcxE00ohMPMYh0G3QbdBt0G3Tjp57Va9noxEMMYj6sdyjVjlG9lo2TWG74t5toxDq2XXiIQcyH9Q7l4iBO4iJuohHptui26Lbotum26bbptum26bbptulW71C+P8qy6rU831MArHotL9Y7lIuDOImLuIlGdOIh0s1et1D1WjYO4usWql7Lxk2sbqHaO9V3dfEQg5gPq+/q4iBO4iJuIt0O3ep9SzUGVP/kqVae6p881bRT/ZONRnTiN4LV7qu7ElYrVHclLm6iEZ14iN/5rSaC6oks9OqJbBzESVzETTRiuc3CQwxiPqya/7oBvHoiG6sjwQoXcRON6MRyiw+rYr8+Jq/ux0Ynntsy5tX92JgPq7vp4iBO4iJuohGdSLdFt0W3TbdNt023TbdNt023TbdNt023TTejm9HN6GZ0M7oZ3apiv5cZr07JxiDmw7rTcHEQvx3lNVjdabj4rZvXNqo7DRedeIhBzId1p+HiIE7iItKt7k967b66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vBLwSsArAa8EvBLwSsArAa8EvBLwSsArAa8EvBLwSsArAa8EvBLwSsArAa8EvBLwSsArAa8EvBLwSsArAa8EvFLwSsErBa8UvFLwSsErBa8UvFLwSsErBa8UvFLwSsErBa8UvFLwSsErBa8UvFLwSsErBa8UvFLwSsErBa8UvFLwSsErBa8UvFLwSsErBa8UvFLwSsErBa8UvFLwSsErBa8UvFLwSsErBa8UvFLwSsErBa8UvFLwSsErBa8UvFLwSsErBa8UvFLwSsErBa8UvFLwSsErBa8UvFLwSsErBa8UvFLwSsErBa8UvFLwSsErBa8UvFLwSsErBa8UvFLwSsErBa8UvFLwSsErBa8UvFLwSsErBa8UvFLwSsErBa8UvCrgVQGvCnhVwKsCXhXwqoBXBbwq4FUBrwp4VcCrAl4V8KqAVwW8KuBVAa8KeFXAqwJeFfCqgFcFvCrgVQGvCnhVwKsCXhXwqoBXBbwq4FUBrwp4VcCrAl4V8KqAVwW8KuBVAa8KeFXAqwJeFfCqgFcFvCrgVQGvCnhVwKsCXhXwqoBXBbwq4FUBrwp4VcCrAl4V8KqAVwW8KuBVAa8KeFXAqwJeFfCqgFcFvCrgVQGvCnhVwKsCXhXwqoBXBbwq4FUBrwp4VcCrAl4V8KqAVwW8KuBVAa8KeFXAqwJeFfCqgFcFvCrgVQGvCnhVwCsDrwy8MvDKwCsDrwy8MvDKwCsDrwy8MvDKwCsDrwy8MvDKwCsDrwy8MvDKwCsDrwy8MvDKwCsDrwy8MvDKwCsDrwy8MvDKwCsDrwy8MvDKwCsDrwy8MvDKwCsDrwy8MvDKwCsDrwy8MvDKwCsDrwy8MvDKwCsDrwy8MvDKwCsDrwy8MvDKwCsDrwy8MvDKwCsDrwy8MvDKwCsDrwy8MvDKwCsDrwy8MvDKwCsDrwy8MvDKwCsDrwy8MvDKwCsDrwy8MvDKwCsDrwy8MvDKwCsDrwy8MvDKwCsDrwy8MvDKwCsHrxy8cvDKwSsHrxy8cvDKwSsHrxy8cvDKwSsHrxy8cvDKwSsHrxy8cvDKwSsHrxy8cvDKwSsHrxy8cvDKwSsHrxy8cvDKwSsHrxy8cvDKwSsHrxy8cvDKwSsHrxy8cvDKwSsHrxy8cvDKwSsHrxy8cvDKwSsHrxy8cvDKwSsHrxy8cvDKwSsHrxy8cvDKwSsHrxy8cvDKwSsHrxy8cvDKwSsHrxy8cvDKwSsHrxy8cvDKwSsHrxy8cvDKwSsHrxy8cvDKwSsHrxy8cvDKwSsHrxy8cvDKwSsHrxy8cvDKwasKXlXwqoJXFbyq4FUFryp4VcGrCl5V8KqCVxW8quBVBa8qeFXBqwpeVfCqglcVvKrgVQWvKnhVwasKXlXwqoJXFbyq4FUFryp4VcGrCl5V8KqCVxW8quBVBa8qeFXBqwpeVfCqglcVvKrgVQWvKnhVwasKXlXwqoJXFbyq4FUFryp4VcGrCl5V8KqCVxW8quBVBa8qeFXBqwpeVfCqglcVvKrgVQWvKnhVwasKXlXwqoJXFbyq4FUFryp4VcGrCl5V8KqCVxW8quBVBa8qeFXBqwpeVfCqglcVvKrgVQWvKnhVwasKXlXwqoJXFbxq4FUDrxp41cCrBl418KqBVw28auBVA68aeNXAqwZeNfCqgVcNvGrgVQOvGnjVwKsGXjXwqoFXDbxq4FUDrxp41cCrBl418KqBVw28auBVA68aeNXAqwZeNfCqgVcNvGrgVQOvGnjVwKsGXjXwqoFXDbxq4FUDrxp41cCrBl418KqBVw28auBVA68aeNXAqwZeNfCqgVcNvGrgVQOvGnjVwKsGXjXwqoFXDbxq4FUDrxp41cCrBl418KqBVw28auBVA68aeNXAqwZeNfCqgVcNvGrgVQOvGnjVwKsGXjXwqoFXDbxq4FUDrxp41S5eyXHx6mwntDPagraiXdA2tB3tijbqJtRNqJtQN6FuQt2Eugl1E+om1E2om1E3o25G3Yy6GXUz6mbUzaibUTejrqCuoK6grqCuoK6grqCuoK6grqCuoq6irqKuoq6irqKuoq6irqKuom5B3YK6BXUL6hbULahbULegbkHdgrqGuoa6hrqGuoa6hrqGuoa6hrqGuo66jrqOuo66jrqOuo66jrqOuo66FXUr6lbUrahbUbeibkXdiroVdSvqNtRtqNtQt6FuQ92Gug11G+o21AWv4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8Bv/1ijG23UBa/gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gt59t1AWv4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/PazjbrgFfx2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u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txv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gt59t1AWv4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8NvP9uoC17Bb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f4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",
      "is_unconstrained": false,
      "name": "receive_value",
      "verification_key": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANuAAAAAAAAAAAAAAAAAAAAIBWtlgGMluIZk0HPivCBRqkAAAAAAAAAAAAAAAAAAAAAAAXNLWoqRw5Y3La7THC8nQAAAAAAAAAAAAAAAAAAAACLVK9hiDUGVBh9bO2IrmwWAAAAAAAAAAAAAAAAAAAAAAAwVHLYvKHL04nhSxEgjtAAAAAAAAAAAAAAAAAAAACHtvoDDKZIpPTfZnFsCP7Q+gAAAAAAAAAAAAAAAAAAAAAAGJr7hhlQNd4uXFLXlbDkAAAAAAAAAAAAAAAAAAAA6AkfHCwINPTjw2n9K/VESGAAAAAAAAAAAAAAAAAAAAAAAAb8WWRd1fF74Gn53NWbpwAAAAAAAAAAAAAAAAAAAAlurJmFAmbf8M+TMh4PvWeqAAAAAAAAAAAAAAAAAAAAAAAT049aTcJ2pe/Ph0PL6NoAAAAAAAAAAAAAAAAAAAChoGvaDRnxw/xBBt1xN+t1qQAAAAAAAAAAAAAAAAAAAAAABJuhzksQIlMOipeiZSJhAAAAAAAAAAAAAAAAAAAAw/wEqcrwGEK6vAcD7+JcpwgAAAAAAAAAAAAAAAAAAAAAABAa7ezYCmVPRgwLnr1nCgAAAAAAAAAAAAAAAAAAALWS9JarCzr8jI4o/8gZR6jNAAAAAAAAAAAAAAAAAAAAAAAcFd75rXl8tP10A5tSBSoAAAAAAAAAAAAAAAAAAABjHyzD3USJSzB5BxLNQGnIkwAAAAAAAAAAAAAAAAAAAAAAC8JlX5WzJvqFWuZl4wYnAAAAAAAAAAAAAAAAAAAAtek7KdxXtCfSifTtp8PqI08AAAAAAAAAAAAAAAAAAAAAAAJLfEXdjuPxEHJHRMAOTAAAAAAAAAAAAAAAAAAAAN+4x6L5DoFfeZpnc2p+83dRAAAAAAAAAAAAAAAAAAAAAAAc+EzCKRyj8UTz4kS/qLoAAAAAAAAAAAAAAAAAAAB4JMHzixDHl9x7rmu+UpQzjQAAAAAAAAAAAAAAAAAAAAAAEUubA9suiHVD9norX/VMAAAAAAAAAAAAAAAAAAAAtQi6GtLBaVOlbS6XGA9eqnwAAAAAAAAAAAAAAAAAAAAAABfiIWL6/lPx838UMvXv4wAAAAAAAAAAAAAAAAAAADr/3SHoETrf6uZZ1rp+WIZQAAAAAAAAAAAAAAAAAAAAAAAqvpwOG8VS0GsAo7Jkj0UAAAAAAAAAAAAAAAAAAABUJxHlFbLDzcMOKg2f7hCicAAAAAAAAAAAAAAAAAAAAAAAEWBEq9cQJCgbdAYavBP5AAAAAAAAAAAAAAAAAAAAdrkZueUT2Ets4CFAG+vXcr4AAAAAAAAAAAAAAAAAAAAAAB6B5XXXSu46eOAFWZAkrwAAAAAAAAAAAAAAAAAAALkTfCOUy4/vOxcLSCbrCGRsAAAAAAAAAAAAAAAAAAAAAAAkTgVsgENDoUzXtvUU8CAAAAAAAAAAAAAAAAAAAAA/nfo6Uw5CL2IqIFgr+rj7NwAAAAAAAAAAAAAAAAAAAAAABgdQhK48XOs4HZ2W0lDOAAAAAAAAAAAAAAAAAAAAJWFm4EGyUGhysmczBzJmGVsAAAAAAAAAAAAAAAAAAAAAABsTAZ94IIbTVh+oFnLq9wAAAAAAAAAAAAAAAAAAAFUjQ3M3jwr+ZOgHC+tBk6PNAAAAAAAAAAAAAAAAAAAAAAAvB0nhQtdTaVUqerewwjwAAAAAAAAAAAAAAAAAAAAz8iD25gFu+9XWLBf/Cw/JowAAAAAAAAAAAAAAAAAAAAAAFUSotgwoTpxvjMkyT4r6AAAAAAAAAAAAAAAAAAAACSYVs0wGRXNhV7MuyZ9yhXUAAAAAAAAAAAAAAAAAAAAAAA7uOlN3/w9dZSbEN+g1AAAAAAAAAAAAAAAAAAAAAHYvGm0kRgCCaNJgvmxl0NVnAAAAAAAAAAAAAAAAAAAAAAAoYAmmcP4dbFPLRgb9DGkAAAAAAAAAAAAAAAAAAAALrdR5lm0jmKKgoUY8UpM0bAAAAAAAAAAAAAAAAAAAAAAAJUdyKOEdjEt+CesOYaHbAAAAAAAAAAAAAAAAAAAAhA/Xl8k7seEe7QHMHM97Pb8AAAAAAAAAAAAAAAAAAAAAAApz2HKn8SJYycaAn1NTTQAAAAAAAAAAAAAAAAAAACDaRBsx4CyyW5RwdvdX+aQkAAAAAAAAAAAAAAAAAAAAAAAVcMeSuoSvdWPZHwNlAEcAAAAAAAAAAAAAAAAAAAB0oomQy2CRlpd0NkktKW2zagAAAAAAAAAAAAAAAAAAAAAAIfaoFnlOKfhfgn4iOUh2AAAAAAAAAAAAAAAAAAAAMy2Fhihq/pAkvcWKfksluQoAAAAAAAAAAAAAAAAAAAAAACcIvaD1mLk78Cj+B3Tt5gAAAAAAAAAAAAAAAAAAAHPBYvYXGIM5iWZhEvl099zqAAAAAAAAAAAAAAAAAAAAAAAGoXsaNLgEXuWnQofj2oIAAAAAAAAAAAAAAAAAAAA/wZCBBxfwEh+24+cITk0cnwAAAAAAAAAAAAAAAAAAAAAAB124oHUljGR3FCPKq90BAAAAAAAAAAAAAAAAAAAAlh2WdvI0tzNtQ6nZek1IDwgAAAAAAAAAAAAAAAAAAAAAACSH+N6R5efVEkYpHbOoVgAAAAAAAAAAAAAAAAAAAKUKSXzZsDe0eQm5StqyMZW4AAAAAAAAAAAAAAAAAAAAAAAHfv6VIvu+HjCSlqD5K3wAAAAAAAAAAAAAAAAAAADCt1ncBbIHC/ZLfZ3L3MKW0AAAAAAAAAAAAAAAAAAAAAAAL9O/EXK+/xrZ2PunUxn1AAAAAAAAAAAAAAAAAAAAMgN7QNZ4j/SpmFpWasKSZAUAAAAAAAAAAAAAAAAAAAAAACzyrBm0w9dUVcAjLRG8OwAAAAAAAAAAAAAAAAAAAFGQH4o9UYilijhAh1hHgX88AAAAAAAAAAAAAAAAAAAAAAADnD6bPuVrb10/UlZK5B0AAAAAAAAAAAAAAAAAAABVB21S5K5/Yh5n71AzSAWKkgAAAAAAAAAAAAAAAAAAAAAAE7Fa9ctrsGWYTxWR8LkBAAAAAAAAAAAAAAAAAAAA6fu7hpAErLW0VGQp1G0UxOQAAAAAAAAAAAAAAAAAAAAAAB94bXhBsVtFZDhY5AlisgAAAAAAAAAAAAAAAAAAAAcx1LX3N1qn4n/DOAOK50bGAAAAAAAAAAAAAAAAAAAAAAATWnk2ASWH4S4SXOY07mkAAAAAAAAAAAAAAAAAAAAIwOA9ShSowSF9XiGcnMLuBwAAAAAAAAAAAAAAAAAAAAAACwwfzdquUkDq/zEAc5M3AAAAAAAAAAAAAAAAAAAAsoQ5LrrBThe8zjoHw72nC+gAAAAAAAAAAAAAAAAAAAAAAASJquoU+d+6a/7AkccRIQAAAAAAAAAAAAAAAAAAAN4POiHzV4CyrVTBviCPhDhEAAAAAAAAAAAAAAAAAAAAAAAWWkexvRo7pXaaiNkZ5d4AAAAAAAAAAAAAAAAAAADoHSO5a7EuWjAb5Mp0KB1mlAAAAAAAAAAAAAAAAAAAAAAABVQff21neLGTa6WguV2tAAAAAAAAAAAAAAAAAAAANIv0KKqIg2jLCowouHWHcTUAAAAAAAAAAAAAAAAAAAAAACPaPlz14ENl7PFPT2enQQAAAAAAAAAAAAAAAAAAAIRT2bcTdKCuysiBIpdubBbOAAAAAAAAAAAAAAAAAAAAAAAO/nzv1dw10KW7tYMIuvsAAAAAAAAAAAAAAAAAAACMGZ9HbJkAZIVdpe3RTlzKxAAAAAAAAAAAAAAAAAAAAAAABqDA/ck8ubhcBfgMUVzTAAAAAAAAAAAAAAAAAAAAreIM9bMKmUe1NlmZaaAy+xsAAAAAAAAAAAAAAAAAAAAAABNvCP5pFlcX8Ck68OVFBQAAAAAAAAAAAAAAAAAAAFGkxws8pjGFPFrAxEiNiKZvAAAAAAAAAAAAAAAAAAAAAAAaPDkex9QFa+M1+cKv3uYAAAAAAAAAAAAAAAAAAACBxRbxgX6dH/bX8+18EZFW0AAAAAAAAAAAAAAAAAAAAAAAFvOBcJpsuXdvthvuKTZLAAAAAAAAAAAAAAAAAAAAT1jrSA1EinKmegreBOM17oQAAAAAAAAAAAAAAAAAAAAAACpP5938XueYK9lRsqQx8AAAAAAAAAAAAAAAAAAAAD7gDhTe1BwxuEHsc2agJEc/AAAAAAAAAAAAAAAAAAAAAAAhj3icxTsLkBO1+Nwz5bkAAAAAAAAAAAAAAAAAAADUotDXrDmLTxZKvbT011rGRgAAAAAAAAAAAAAAAAAAAAAAAm2Vy0XXc5bPTwYiCnozAAAAAAAAAAAAAAAAAAAA4m//D/oaIEkcbfvcsY8m3yEAAAAAAAAAAAAAAAAAAAAAAAUtiBCqfomCGC6GywfTDQAAAAAAAAAAAAAAAAAAANedPq+IpIRxcYWtqKNbMcFBAAAAAAAAAAAAAAAAAAAAAAAYqcAnwnFfdxcE/rO/iEMAAAAAAAAAAAAAAAAAAADOpZm7rhU1EjBVJa6+CsG3SwAAAAAAAAAAAAAAAAAAAAAADE3UV3HYY4to5MdMoyhzAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACunjrhrbXqwLwqKLtlnEseuQAAAAAAAAAAAAAAAAAAAAAAHpi241O2oUfPxxUdpNTnAAAAAAAAAAAAAAAAAAAA7l5Qo8qKWsdtBgY/7G+HDokAAAAAAAAAAAAAAAAAAAAAABqGG0/fjpw/G2ZZBGYetAAAAAAAAAAAAAAAAAAAAGvMegX/lalrKJQkxfczZw2WAAAAAAAAAAAAAAAAAAAAAAAAxDcm91tv2g3iLODg36sAAAAAAAAAAAAAAAAAAAAdCgnXF47JO614WPluZPC0jQAAAAAAAAAAAAAAAAAAAAAAL5tuC04sAZaN5cMkgqp9AAAAAAAAAAAAAAAAAAAAuYniLEHZIlGoryxOrV7KWK8AAAAAAAAAAAAAAAAAAAAAABZLot4f1KA39toaZFU9FwAAAAAAAAAAAAAAAAAAADM5GCySoL+NorcClECUB1QkAAAAAAAAAAAAAAAAAAAAAAArhIg8uiHvJIH+bTVd9Yc="
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "6788092787179896647": {
            "error_kind": "string",
            "string": "Caller is not owner"
          }
        },
        "parameters": [
          {
            "name": "source_chain_id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 16
            },
            "visibility": "private"
          },
          {
            "name": "emitter_address",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "public"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "register_emitter"
    },
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "14067204867181196045": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15546539856497705002": {
            "error_kind": "string",
            "string": "u16 to u8 conversion failed"
          },
          "15711892660910782274": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "15835548349546956319": {
            "error_kind": "string",
            "string": "Field failed to decompose into specified 32 limbs"
          },
          "16216212843441549037": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "2014890719615096298": {
            "error_kind": "string",
            "string": "Field failed to decompose into specified 40 limbs"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "4648451262681811962": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "7555607922535724711": {
            "error_kind": "string",
            "string": "Preimage mismatch"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9589626482238399944": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "9921926525851912681": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "anchor_block_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "sponge_blob_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "destination_chain_id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 16
            },
            "visibility": "private"
          },
          {
            "name": "value",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          },
          {
            "name": "fee_nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "note_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 32,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "log",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "fields",
                                          "type": {
                                            "kind": "array",
                                            "length": 18,
                                            "type": {
                                              "kind": "field"
                                            }
                                          }
                                        },
                                        {
                                          "name": "length",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::log::Log"
                                    }
                                  },
                                  {
                                    "name": "note_hash_counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "anchor_block_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "sponge_blob_hash",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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P3+e0wucXozg85zMf14eX5DHFwGfl/j5y5xe4fRqBJ+XZP7L8viKPL4K+LzGz1/n9AanNyP4vCbzX5fHN+TxTcDnLX7+Nqf/cHongs9bMv9tefyPPL4D+LzLz9/j9F9O70fweVfmvyeP/5XH9wGfD/j5h5z+x+mjCD4fyPwP5fF/8vgR4PMxP/+E06ecPovg87HM/0QeP5XHzwCfz/n5F5y+5PRVBJ/PZf4X8vilPH4F+HzNz7/h9C2n7yL4fC3zv5HHb+XxO8Dne37+A6cfOf0Uwed7mf+DPP4ojz8BPj/z8184/crptwg+P8v8X+TxV3n8DfARL6QEnKpxyiuk+TCZH8hjNXkU9VW9FD/P51TAqXoEn5TMz5fHAnmsDvgU8vMiTjU41YzgUyjzi+SxhjzWBHyK+XktTrU5lUTwKZb5teSxtjyWAD51+HldTvU41Y/gU0fm15XHevJYH/DZhp9vy6kBp4boJSDT/ZkLDF6qEpiqbrr9mUaF2nwrJNN3MRoYyNRYX6aAmptt5Fw0ksfG8tgQzE0Tft6U03acmhWWt4V90nkr+pw887k0qdvEYNy2t5xLU/nbGtRtaiB/cwP5qXnfXs5zc3ncTh6bgXkP+XkLTi05tZL5YvrzYrBCppV++d3vZsbDtt00dRKYtavwLpluMsW41APGFR4wrvSAYfC+kjXGER4wDveAcZgHjEM9YKz2gLHKA8YhHjAO9oCx0gPGCg8Yyz1gLPOAsdQDxhIPGIs9YCzygLHQA8YCDxjzPWDM84Ax1wPGHA8Ysz1gzLLAYGYY5WBm7UyesbTGmO4BY5oHjKkeMEo9YEzxqI+5drl2uXa5drl2uXbZ0M50rTR4RrVSCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCpldCplZCszamXyPoFIK9aoFWKZ074+fI1/iNu2LQd2KjQwwDN6ZzwgntPkGgHgJvohTPsXRUIDzMlAMXZz5077pUQHUoC2zHSQLnLPy/ODk6dfd8uEOkXaQH75ojX+1eAdigEy/+LGDwZcf2hh+8UPJqdoJBa7BygeuQgNDuVsbfoUCHr2Cw2T6s8awbjqZ2jE/MgVMX6b2zI9M1Zi+TB2YH5kMrD3oyNzIlA5nR6Yv/2ZPXnEn5gdnZ+YHpxPzM5e7MP25PMPTXHZmfnC6MD84XZkfnF2ZH5xuzA9Od+YHZzfmB6cH84OzO/OD05P5wdmD+cHpxfzg7Mn84OzF/OD0Zn5w+jA/OH2ZH5x+zA9Of+YHZwDzgzOQ+cHZm/nBGcT84AxmfnCGMD84+zA/OEOZH5xhzA/OcOYHZwTzgzOS+cEZxfzgjGZ2OEnuwYxhbmRKh7Mv05f/TE/Xo2OZH5xxzA/OeOYHZwLzg7Mf84OzP/ODM5H5wTmA+cGZxPzgHMj84BzE/OBMZn5wpjA/OKXMD85U5gdnGvODM535wZnB/ODMZH5wZjE/OLOZH5w5zA/OXOYHZx7zgzOf+cFZwPzgLGR+cBYxPziLmR+cJcwPzlKmfw2TCc4y5qc/y5kfnBXMD85K5gfnYOYH5xDmB2cV84OzmvnBOZT5wTmM+cE5nPnBOYL5wVnD/OCUMT84a5kfnHXMD8565gdnA/ODs5H5wTmS+cE5ivnBOZr5wTmG+cE5lvnBOY75wTme+cHZxPzgnMD84JzI/OCcxPzgnMz84JzC/OBsZn5wTmV+cE5jfnBOZ35wzmB+cM5kfnDOYn5wzmZ+cM5hfnDOZX5wzmN+cM5nfnAuYH5wLmR+cC5ifnAuZn5wLmF+cC5lfnAuY35wLmd+cK5gfnCuZH5wrmJ+cP6P+cG5mvnBuYb5wbmW+cG5jvnBuZ75wbmB+cG5kfnBuYn5wbmZ+cG5hfnBuZX5wbmN+cG5nfnBuYP5wbmT+cH5G/OD83fmB+cu5gfnH8wPzt3MD84/mR+ce5gfnHuZH5x/MT849zE/OPczPzgPMD84DzI/OA8xPzgPMz84jzA/OI8yPziPMT84jzM/OE8wPzhPMj84TzE/OE8zPzj/Zn5wnmF+cJ5lfnCeY35wnmd+cF5gfnBeZH5wXmJ+cF5mfnBeYX5wXmV+cF5jfnBeZ35w3mB+cN5kfnDeYn5w3mZ+cP7D/OC8w/zgvMv84LzH/OD8l/nBeZ/5wfmA+cH5kPnB+R/zg/MR84PzMfOD8wnzg/Mp84PzGfOD8znzg/MF84PzJfOD8xXzg/M184PzDfOD8y3zg/Md84PzPfOD8wPzg/Mj84PzE/OD8zPzg/ML84PzK/OD8xvzgyMaaNZFDc1wAk841Tzh5HnCSXnCyfeEU+AJp7onnEJPOEWecGp4wqnpCafYE04tTzi1PeGUeMKp4wmnriecep5w6nvC2cYTzraWOEl+96+BI5nS4TQM9OU/z9N3/xppyrT+3BqPwIZJ/sZDY0/z0cRgPnz9wk5TT33fzqDvtr/6YypTMwOZdvA0H9t78ovNPeGEnnBaeMJp6QmnlSecHTzhtPaE08YTTltPOO084bT3hNPBE05HTzg7esLZyRPOzp5wOnnC2cUTTmdPOF084XT1hLOrJ5xunnC6e8LZzRNOD084u3vC6ekJZw9POL084ezpCWcvTzi9PeH08YTT1xNOP084/T3hDPCEM9ATzt6ecAZ5whnsCWeIJ5x9POEM9YQzzBPOcE84IzzhjPSEM8oTzmhPOGM84ezrCWesJ5xxnnDGA5wkv9M+wVN/9vOEs78nnImecA7whDPJE86BnnAO8oQz2RPOFE84pZ5wpnrCmeYJZ7onnBmecGZ6wpnlCWe2J5w5nnDmesKZ5wlnviecBZ5wFnrCWeQJZ7EnnCWecJZ6wlnmCWe5J5wVnnBWesI52BPOIZ5wVnnCWe0J51BPOId5wjncE84RnnDWeMIp84Sz1hPOOk846z3hbPCEs9ETzpGecI7yhHO0J5xjPOEc6wnnOE84x3vC2eQJ5wRPOCd6wjnJE87JnnBO8YSz2RPOqZ5wTvOEc7onnDM84ZzpCecsTzhne8I5xxPOuZ5wzvOEc74nnAs84VzoCeciTzgXe8K5xBPOpZ5wLvOEc7knnCs84VzpCecqTzj/5wnnak8413jCudYTznWecK73hHODJ5wbPeHc5AnnZk84t3jCudUTzm2ecG73hHOHJ5w7PeH8zRPO3z3h3OUJ5x+ecO72hPNPTzj3eMK51xPOvzzh3OcJ535POA94wnnQE85DnnAe9oTziCecRz3hPOYJ53FPOE94wnnSE85TnnCe9oTzb084z3jCedYTznOecJ73hPOCJ5wXPeG85AnnZU84r3jCedUTzmuecF73hPOGJ5w3PeG85QnnbU84//GE844nnHc94bznCee/nnDe94TzgSecDz3h/M8TzkeecD72hPOJJ5xPPeF85gnnc084X3jC+dITzleecL72hPONJ5xvPeF85wnne084P3jC+dETzk+ecH72hPOLJ5xfPeH85glHfJRcsy5qaIYTeMKp5gknzxNOyhNOviecAk841T3hFHrCKfKEU8MTTk1POMWecGp5wqntCafEE04dTzh1PeHU84RT3xPONp5wtvWE08ATTkNPOI084TT2hNPEE05TTzjbecJp5glne084zT3hhJ5wWnjCaekJp5UnnB084bT2hNPGE05bTzjtPOG094TTwRNOR084O3rC2ckTzs6ecDp5wtnFE05nTzhdPOF09YSzqyecbp5wunvC2c0TTg9POLt7wunpCWcPTzi9POHs6QlnL084vT3h9PGE09cTTj9POP094QzwhDPQE87ennAGecIZ7AlniCecfTzhDPWEM8wTznBPOCM84Yz0hDPKE85oTzhjPOHs6wlnrCeccZ5wxnvCmeAJZz9POPt7wpnoCecATziTPOEc6AnnIE84kz3hTPGEU+oJZ6onnGmecKZ7wpnhCWemJ5xZnnBme8KZ4wlnrieceZ5w5nvCWeAJZ6EnnEWecBZ7wlniCWepJ5xlnnCWe8JZ4QlnpSecgz3hHOIJZ5UnnNWecA71hHOYJ5zDPeEc4QlnjSecMk84az3hrPOEs94TzgZPOBs94RzpCecoTzhHe8I5xhPOsZ5wjvOEc7wnnE2ecE7whHOiJ5yTPOGc7AnnFE84mz3h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",
      "custom_attributes": [
        "external",
        "private"
      ],
      "debug_symbols": "TJ3Ljjy9jtzf5ay9KF1IkX4VLwxfBwMMZgBfVgO/uzsZoiI2p39xvn8rlCkxKiuLnfXv//jv/+O//t9/+s///K//89/+9z/+43/693/81//1z//yL//8T//5X/7tv/2X//PP//avf//vv//j9/3P2P/4j9N8/7//8I/x6f33/47/8I898GPix8KPjR+GH44fBz8CP7J+GEYxjGIYxTCKYRTDKIZRDKMYRjGM4hjFMYpjFMcojlEcozhGcYziGMUxysEoB6McjHIwysEoB6McjHIwysEoB6MERgmMEhglMEpglMAogVECowRGCYySGCUxSmKUxCiJURKjJEZJjJIYJTHK+P3uz3F/zvtz3Z/7/rT70+/Pc3/G/XnHG3e8cccbd7xxxxt3vHHHG3/jre/nuT/j/kz8nH/j+fdz3J/z/lz35994+f38xqtf8IbTEA15Yf0avlmeD2bDatgN38jxgTechm/k7yhWXqg9X/A38twfzIbVsBuswRtOQzTkha8OAD2y9cjWI3/1ML+z8lUEwBtOQzTkha82AKNhNqyGHtl7ZO+RvUf2Htl75NMjnx759MinRz498umRT498euTTI58e+auh+S3BV0WA2bAadoM1eMNpiIa8kD1y9sjZI2ePnD1y9sjZI2ePnD1y3pHn79cwGmbDatgN1uANpyEaeuTRI48eefTIo0cePfLokUePPHrk0SOPHnn2yLNHnj3y7JFnjzx75Nkjzx559sizR1498uqRV4+8euTVI68eefXIq0dePfLqkXePvHvk3SPvHnn3yLtH/mpwjQ9OQzTkha8GAaNhNqyG3WANPbL1yNYjfzW4/ip3fjUIGA3fyPnBatgN1uANpyEa8sJXg4DR0COfHvn0yOcm0jzecBqi4SbSjF/DaJgNq2E39MjRI0eP/NXgnh/kha8GAaNhNqyG3WAN3nAaeuS8I6/fr2E0fCOvD1bDbrAGbzgN0ZAXvhoEjIYeefTIo0f+atB+H3jDaYiGvPDVIGA0zIbVsBt65Nkjzx559sizR1498uqRV4+8euTVI68eefXIq0dePfLqkXePvHvk3SPvHnn3yLtH3j3y7pF3j7x7ZOuRrUe2Htl6ZOuRrUe2Htl6ZOuRrUf2Htl7ZO+RvUf2Htl7ZO+RvUf2Htl75NMjnx759MinRz498umRT498euTTI58eOXrk6JGjR44e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gm5Bt6Rb0i3plnRLuiXdkm5Jt6RbPrdqgmscxElcxE00ohMPMYh0G3QbdGOWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJYks+a7GE1kCHMRJXMRNNKITDzGIdEu6Jd2QJVa4iJtoRCceYhDz4vwhS4CDOImLuIlGdOIhBpFug26DboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptum25GN2TJKZzERfzcxq/QiE48xCDmw8qSi4M4iYtIN6eb083p5nRzuh26Hboduh26Hboduh26Hboduh26Bd2CbkG3oFvQLegWdAu6Bd2Cbkm3pFvSLemWdEu6Jd2Sbkm3fG54RtfFQZzERdxEIzrxEINIt0G3QbdBt0G3QbdBt0G3QbdBt0G3SbdJt0m3SbdJt0m3SbdJt0m3SbdFt0W3RbdFt0W3RbdFt0W3RbdFt023TbdNt023TbdNt023TbdNt003o5vRzehmdGOWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJYpYsZslilixmyWKWLGbJYpYsZslilixmyWKWLGbJYpYsZslilixmyWKWLGbJYpYsZMn6EFkCHMRJXMRNNKITDzGIdFt0W3RDluzCRdxEIzrxEIOYD5ElwEGk26bbptum26bbptum26ab0c3oZnQzuhndjG5GN6Ob0c3o5nRzujndnG5ON6eb083p5nRzuh26Hboduh26Hboduh26Hboduh26Bd2CbkG3oFvQLegWdAu6Bd2Cbkm3pFvSLemWdEu6Jd2Sbkm3fG779yMO4iQu4iYa0Ynl5oVBzIfIkiwcxElcxE00ohMPMYj5cNJt0m3SbdJt0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0W3TbdNt023TbdNt023TbdNt023TzehmdDO6Gd2MbkY3o5vRzehmdHO6Od2cbk43p5vTzenmdHO6Od0O3Q7dDt0O3Q7dDt0O3Q7dDt0O3YJuQbegW9At6BZ0C7oF3YJuQbekW9It6ZZ0S7ol3ZJuSbekWz43+/2IgziJi7iJRnTiIQaRbswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZslhlhxmyWGWVCvq32cfhZtoRCceYhDzYWXJxUGcRLoNug26VZZ8X7cxqzG1MYj5sLLk4iBO4iJuohHpNuk26Tbptui26Lbotui26FZZMq3QiYcYxHxYWXJxECdxETeRbptum26bbptuRjejm9HN6GZ0M7oZ3YxuRjejm9PN6eZ0c7o53ZxuTjenm9PN6Xboduh26Hboduh26Hboduh26HboFnQLugXdgm5Bt6Bb0C3oFnQLuiXdkm5Jt6Rb0i3plnRLuiXd8rlVr2vjIE7iIm6iEZ14iEGk26DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26IbsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWYK+13kKN9GITjzEIOZDZAlwECeRbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptum25GN6Ob0c3oZnQzuhndjG5GN6Ob083p5nRzujndnG5ON6eb083pduh26HboduiGLMlCIzrxc6uv90Lf68V8WFlycRAncRE30YhOpFvQLeiWdEu6Jd2Sbkm3pFvSLemWdMt2W+h7vTiIk7iIm2hEJx5iEOk26DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26Tbptui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26WZ0M7oZ3YxuRjejm9HN6GZ0M7o53ZxuTjenm9PN6eZ0c7o53Zxuh26Hboduh26Hboduh26Hboduh25Bt6Bb0C3oFnQLugXdgm5Bt6Bb0i3plnRLuiXdkm5Jt6Rb0o1ZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1mCvtfvK3UX+l4vBrHc/ENkCXAQJ3ERN9GITjzEINLN6YYs+RVO4iJuohGdeIhBzIfIEiDdDt0O3Q7dDt0O3Q7dDt0O3YJuQbegW9At6BZ0C7oF3YJuQbekW9It6ZZ0S7ol3ZJuSbekWz439L1eHMRJXMRNNKITDzGIdBt0G3QbdBt0qyzZVmhEJ35u2wuDmA+RJadwECdxETfRiE48xCDmw0W3RbdFt0W3RbdFt0W3RbdFt0W3TbdNt023TbdNt023TbdNt023TTejm9HN6GZ0M7oZ3YxuRjejm9HN6eZ0c7o53ZxuTjenm9PN6eZ0O3Q7dDt0O3Q7dDt0O3Q7dDt0O3QLugXdgm5Bt6Bb0C3oFnQLugXdkm5Jt6Rb0i3plnRLuiXdkm753ND3enEQJ3ERN9GITjzEINJt0A33XnfhJC7iJhrRiYcYxHyIe69Auk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptum26Gd2MbkY3o5vRzehmdDO6Gd2Mbk43p5vTzenmdHO6Od2cbk43p9uh26Hboduh26Hboduh26HboduhW9At6BZ0C7oF3YJuQbegW9At6JZ0S7ol3ZJuSbekW9It6ZZ0y+eGvteLg/i52ShcxE383Az/1omH+LmZF+bDypKLgziJi7iJRnTiIdJt0G3SbdJt0m3SbdJt0m3SbdJt0m3SbdFt0W3RbdFt0W3RbdFt0W3RbdFt023TbdNt023TbdNt023TbdNt083oZnQzuhndjG5GN6Ob0c3oZnRzujndnG5ON6eb083p5nRzujndDt0O3Q7dDt0O3Q7dDt0O3Q7dDt2CbkG3oFvQLegWdAu6Bd2CbkG3pFvSLemWdEu6Jd2Sbkm3pFs+N/S9XhzESVzETTSiEw8xiHRjljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPkMEsOs+QwSw6z5DBLDrPkMEsOs+QwSw6zBH2v39d1LPS9XpzERdxEIzrxEIOYDyfdJt0m3SbdKks8C43oxDo2KwxiPkSWAAdxEhdxE43oRLotui26bbptum26bbptum26bbptum26bboZ3YxuRjejm9HN6GZ0M7oZ3YxuTjenm9PN6eZ0c7o53ZxuTjen26Hboduh26Hboduh26Hboduh26Fb0C3oFnQLugXdgm5Bt6Bb0C3olnRLuiXdkm5Jt6Rb0i3plnTL54a+14uDOImLuIlGdOIhBpFug26DboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSxB3+vxwnxYWXLxc/ueqL7Q93pxET+3mIVGdOLnFqswiPmwsuTiIE7iIm6iEZ1IN6eb0+3QrbIksnASF/FzyzoPlSUXnfi5ZZ2HypKL+fDLkvk9KnFV32vjJK4Pay2+LGk0on9Y0/mypDGI+TB/xEGcxEXcRCPSLemWdMvnVn2vjYM4iYu4iUZ04iEGkW6DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26bbkY3o5vRzehmdDO6Gd2MbkY3o5vTzenmdHO6Od2cbk43p5vTzel26Hboduh26Hboduh26Hboduh26BZ0C7oF3YJuQbegG7MkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS/Jlyf69LNm/lyX797Jk/16W7N/Lkv17WbJ/L0v272XJ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c4WcK+STuIibyN3nXCHnCjlXyLlCh7uPqeGH++FwPxzuh8qHuqleDYuN+bDyoW7nVcPiqRt31bDYuIibaEQnHmIQ82G+u0mOuwfATTSiEw8xiNl4cPcAOIiTuIibaEQnHmIQ6TboNug26DboNug26DboNug26DboNuk26TbpNuk26TbpNuk26TbpNum26Lbotui26Lbotui26Lbotui26LbptunGe45n023TbdNt023TbdNt083oZnQzuhndjG5GN6Ob0c3oZnRzujndnG5ON6eb083p5nRzujndDt0O3Q7dDt0O3Q7dDt0O3Q7dDt2CbkG3oFvQLegWdAu6Bd2CbkG3pFvSjVlymCWHWXKYJYdZcpglh1lymCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWVK/l30tUoRGdeIhBzMbqtWwcxElcxE00ohMPMYh0G3QbdBt0G3Tjp57Va9noxEMMYj6sdyjVjlG9lo2TWG74t5toxDq2XXiIQcyH9Q7l4iBO4iJuohHptui26Lbotum26bbptum26bbptulW71C+P8qy6rU831MArHotL9Y7lIuDOImLuIlGdOIh0s1et1D1WjYO4usWql7Lxk2sbqHaO9V3dfEQg5gPq+/q4iBO4iJuIt0O3ep9SzUGVP/kqVae6p881bRT/ZONRnTiN4LV7qu7ElYrVHclLm6iEZ14iN/5rSaC6oks9OqJbBzESVzETTRiuc3CQwxiPqya/7oBvHoiG6sjwQoXcRON6MRyiw+rYr8+Jq/ux0Ynntsy5tX92JgPq7vp4iBO4iJuohGdSLdFt0W3TbdNt023TbdNt023TbdNt023TTejm9HN6GZ0M7oZ3apiv5cZr07JxiDmw7rTcHEQvx3lNVjdabj4rZvXNqo7DRedeIhBzId1p+HiIE7iItKt7k967b66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",
      "is_unconstrained": false,
      "name": "send_value_private",
      "verification_key": "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"
    },
    {
      "abi": {
        "error_types": {
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15546539856497705002": {
            "error_kind": "string",
            "string": "u16 to u8 conversion failed"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "8228371833434187583": {
            "error_kind": "string",
            "string": "Trying to read from uninitialized PublicImmutable"
          }
        },
        "parameters": [
          {
            "name": "destination_chain_id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 16
            },
            "visibility": "private"
          },
          {
            "name": "value",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          },
          {
            "name": "fee_nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JwACBAEoAAABBIBLJwAABEsnAgQEAycCBQQAHwoABAAFAEgcAEhIAxwASUkCLQhIAS0ISQItCEoDJQAAAFMlAAAAkScCAQRLJwICBAA7DgACAAEsAABDADBkTnLhMaApuFBFtoGBWF0oM+hIeblwkUPh9ZPwAAAAJwBEAmMpAABFBP////8nAEYEBicARwQDJiUAABEaHgIABAAeAgAFADMqAAQABQAGJwIEAQEkAgAGAAAAuiUAABFAHgIABQEKIgVDBhYKBgccCgcIAAQqCAUHJwIFAQAKKgYFCCQCAAgAAADtJwIJBAA8BgkBJwIGAAAtCAEIJwIJBAQACAEJAScDCAQBACIIAgktCgkKLQ4GCgAiCgIKLQ4GCgAiCgIKLQ4GCisCAAkAAAAAAAAAAAIAAAAAAAAAAC0IAQonAgsEBQAIAQsBJwMKBAEAIgoCCy0KCwwtDgYMACIMAgwtDgYMACIMAgwtDgYMACIMAgwtDgkMLQgBCQAAAQIBLQ4ICS0IAQgAAAECAS0OCggtCAELAAABAgEnAgwEAC0ODAstCAENAAABAgEtDgUNJwIOAAYnAg8EASQCAAUAAAILIwAAAcQtCAEQJwIRBAQACAERAScDEAQBACIQAhEtChESLQ4OEgAiEgISLQ4GEgAiEgISLQ4GEi0OEAktDgoILQ4PCy0OBQ0jAAACly0KDAojAAACFAwiCkcQJAIAEAAAEJQjAAACJi0LCQotCwgQLQsNES0LEBIAIhICEi0OEhAtCAESJwITBAUACAETAScDEgQBACIQAhMnAhQEBAAiEgIVPw8AEwAVLQIKAycABAQEJQAAEVItCAUQACoQDxMtDg4TLQ4QCS0OEggtDg8LLQ4RDSMAAAKXLQsJCi0LCA4tCw0QCioQBREkAgARAAACuScCEgQAPAYSAScCEAABJwIRBAIkAgAFAAADACMAAALQLQIKAycABAQEJQAAEVItCAUSACoSERMtDhATLQ4SCS0ODggtDhELLQ4FDSMAAAOMLQoMCiMAAAMJDCIKRw4kAgAOAAAQDiMAAAMbLQsJCi0LCA4tCw0SLQsOEwAiEwITLQ4TDi0IARMnAhQEBQAIARQBJwMTBAEAIg4CFCcCFQQEACITAhY/DwAUABYtAgoDJwAEBAQlAAARUi0IBQ4AKg4PFC0OEBQtDg4JLQ4TCC0ODwstDhINIwAAA4wtCw0OCioOBRIkAgASAAADpicCEwQAPAYTAS0KDAojAAADrwwiCkcFJAIABQAAD4gjAAADwS0LCQotCwgOLQsLEi0LDhMAIhMCEy0OEw4tCAETJwIUBAUACAEUAScDEwQBACIOAhQnAhUEBAAiEwIWPw8AFAAWLQ4KCS0OEwgtDhILLQ4EDQAqEw8JLQsJCB4CAAkAMyoACAAJAAokAgAKAAAENSUAABG2LQgBCCcCCQQEAAgBCQEnAwgEAQAiCAIJLQoJCi0OBgoAIgoCCi0OBgoAIgoCCi0OBgotCAEJAAABAgEtDggJLQoMBSMAAAR9DCIFRwgkAgAIAAAPQiMAAASPLQsJCAAqCA8KLQsKCQAqCBELLQsLChwKCg0DHAoNCwAcCgsKAwAiCEcNLQsNCxwKCw0GHAoNCAAoAgALBAEAJwIOAQAtCAENJwISBCEACAESAScDDQQBACINAhInAhMEIEMDqgAHAAsAEwAOABInAgsCAC0IAQ4nAhIEIAAIARIBJwMOBAEAIg4CEicCEwQfACoTEhMtChIUDioTFBUkAgAVAAAFQy0OCxQAIhQCFCMAAAUoLQsOEgAiEgISLQ4SDi0LDhIAIhICEi0OEg4tCw4SACISAhItDhIOLQsOEgAiEgISLQ4SDi0LDhIAIhICEi0OEg4tCw4SACISAhItDhIOLQgBEgAAAQIBJwITAwgaKgoTFBwKFBYCHAoWFQMcChUUAhwKChcCHAoXFgMcChYXAigCABgDAQAEKhUYGQYqGRgbCiobFRokAgAaAAAF5SUAABHIACoZFhUOKhkVGiQCABoAAAX8JQAAEdoKKhUKFiQCABYAAAYOJQAAEewaKgETChwKChUCHAoVEwMcChMKAhwKARYCHAoWFQMcChUWAgQqExgZBioZGBsKKhsTGiQCABoAAAZNJQAAEcgAKhkVEw4qGRMYJAIAGAAABmQlAAAR2goqEwEVJAIAFQAABnYlAAAR7C0IAQEnAhMEIAAIARMBJwMBBAEAIgECEy0KExUtDEQVACIVAhUtDhQVACIVAhUtDhcVACIVAhUtDgoVACIVAhUtDhYVACIVAhUtDgsVACIVAhUtDgsVACIVAhUtDgsVACIVAhUtDgsVACIVAhUtDgsVACIVAhUtDgsVACIVAhUtDgsVACIVAhUtDgsVACIVAhUtDgsVACIVAhUtDgsVACIVAhUtDgsVACIVAhUtDgsVACIVAhUtDgsVACIVAhUtDgsVACIVAhUtDgsVACIVAhUtDgsVACIVAhUtDgsVACIVAhUtDgsVACIVAhUtDgsVACIVAhUtDgsVACIVAhUtDgsVACIVAhUtDgsVACIVAhUtDgsVACIVAhUtDgsVACIVAhUtDgsVACIVAhUtDgsVLQgBCicCCwQJAAgBCwEnAwoEAQAiCgILLQoLEy0OARMAIhMCEy0ODhMAIhMCEy0ODhMAIhMCEy0ODhMAIhMCEy0ODhMAIhMCEy0ODhMAIhMCEy0ODhMAIhMCEy0ODhMtDgoSJwIBBBknAgoEBScCCwQfLQoMBSMAAAgfDCoFAQ4kAgAOAAAOtiMAAAgxJwIFBBonAgoEIC0KDAEjAAAIRAwiAUYOJAIADgAADiojAAAIVi0LEgUAIgVHDS0LDQotCwoNACINAg0tDg0KJwINBActAgoDJwAEBCAlAAARUi0IBQ4AKg4NES0OAhEtAgUDJwAEBAklAAARUi0IBQIAIgJHCi0ODgotDgISLQgBBQAAAQIBLQgBCgAAAQIBLQgBDScCDgT+AAgBDgEnAw0EAQAiDQIOJwIRBP0AKhEOES0KDhIOKhESEyQCABMAAAkCLQ4GEgAiEgISIwAACOctDg0FLQ4PCi0IAQ0nAg4E+QAIAQ4BJwMNBAEAIg0CDicCEQT4ACoRDhEtCg4SDioREhMkAgATAAAJSy0OBhIAIhICEiMAAAkwLQgBDgAAAQIBLQ4NDi0IAQ0nAhEEIAAIAREBJwMNBAEAIg0CEScCEgQfACoSERItChETDioSExQkAgAUAAAJmS0OBhMAIhMCEyMAAAl+JwIGBAgnAhEE+C0KDAEjAAAJrAwqAQYSJAIAEgAADPIjAAAJvi0LDgInAgYE/S0KDAEjAAAJ0AwqARELJAIACwAADIEjAAAJ4i0LCgEAKgERAg4qAQILJAIACwAACf0lAAAR2i0LBQEMKgIGCyQCAAsAAAoTJQAAEf4tAgEDJwAEBP4lAAARUi0IBQsAIgsCDQAqDQIOLQ4IDgAqAg8BDioCAQgkAgAIAAAKSiUAABHaDCoBBgIkAgACAAAKXCUAABH+LQILAycABAT+JQAAEVItCAUCACICAggAKggBDS0OEA0AKgEPCA4qAQgLJAIACwAACpMlAAAR2gwqCAYBJAIAAQAACqUlAAAR/i0CAgMnAAQE/iUAABFSLQgFAQAiAQILACoLCA0tDgcNACoIDwIOKggCByQCAAcAAArcJQAAEdoMKgIGByQCAAcAAAruJQAAEf4tAgEDJwAEBP4lAAARUi0IBQQAIgQCBwAqBwIILQ4DCC0OBAUAKgIPAQ4qAgEDJAIAAwAACyklAAAR2i0OAQonAgME/QYiAwIBJwIHBAMAKgMHBS0IAQIACAEFAScDAgQBACICAgUtDgMFACIFAgUtDgMFJwIHBAMAKgIHBQAiBAIHLQIHAy0CBQQtAgMFJQAAEhAtCwIDACIDAgMtDgMCKQIAAwBl785+ACIGAgQtAgYDLQICBCcABQQBJQAAEkItCAYFLQgHBy0OAwcAIgUCBi0LBgMnAgcEAgAqBgcCOQOgAEUARQAJAAMAAiACAAIhAgADLQgBBQAiBQIILQsIBycCCQQCACoICQYiOgADAAwABi0KAwcnAgkEAwAqBwkIAAgBCAEnAwUEAQAiBQIJLQ4HCQAiCQIJLQ4HCS0KBwQGIgQCBCQCAAIAAAxqIwAADEEtCwUBACIBAgEtDgEFACIFAgMtCwMCJwIGBAIAKgMGATwOAgEjAAAMagoqBA8BJAIAAQAADIAnAgIEADwGAgEmLQsKCwAqAQsNDioBDQ4kAgAOAAAMnCUAABHaACICAg4AKg4BEi0LEgstCwUODCoNBhIkAgASAAAMwCUAABH+LQIOAycABAT+JQAAEVItCAUSACISAhMAKhMNFC0OCxQtDhIFACoBDwstCgsBIwAACdAAIgICFAAqFAEVLQsVEy0LExQAIhQCFC0OFBMtCw0UACIUAhQtDhQNLQgBFAAAAQIBLQ4NFC0KDBIjAAANMAwqEgsVJAIAFQAADeEjAAANQi0LFBMEKgELFC0KDBIjAAANVAwqEgsVJAIAFQAADXQjAAANZgAqAQ8SLQoSASMAAAmsACoUEhUOKhQVFiQCABYAAA2LJQAAEdoAIhMCFwAqFxIYLQsYFi0LDhcMKhURGCQCABgAAA2vJQAAEf4tAhcDJwAEBPklAAARUi0IBRgAIhgCGQAqGRUaLQ4WGi0OGA4AKhIPFS0KFRIjAAANVAAiEwIWACoWEhctCxcVHAoVFgAtCxQVLQIVAycABAQgJQAAEVItCAUXACIXAhgAKhgSGS0OFhktDhcUACoSDxUtChUSIwAADTAAKgUBDgwqDgoTJAIAEwAADkElAAAR/gAiDQIUACoUDhUtCxUTLQsSDgAqDhEVLQsVFC0LFBUAIhUCFS0OFRQtAhQDJwAEBCAlAAARUi0IBRUAIhUCFgAqFgEXLQ4TFy0CDgMnAAQECSUAABFSLQgFEwAqExEULQ4VFC0OExIAKgEPDi0KDgEjAAAIRAAqCgUOACINAhQAKhQFFS0LFRMtCxIUACoUDxYtCxYVLQsVFgAiFgIWLQ4WFQwqDgsWJAIAFgAADvUlAAAR/i0CFQMnAAQEICUAABFSLQgFFgAiFgIXACoXDhgtDhMYLQIUAycABAQJJQAAEVItCAUOACoODxMtDhYTLQ4OEgAqBQ8OLQoOBSMAAAgfHAoFCAAAKhAICi8KAAoACC0LCQotAgoDJwAEBAQlAAARUi0IBQsAIgsCDQAqDQUOLQ4IDi0OCwkAKgUPCC0KCAUjAAAEfS0LCQUtCwgOLQsLEi0LDRMMKgoSFCQCABQAAA+qIwAAEAAAIg4CFQAqFQoWLQsWFAAiBQIWACoWChctCxcVACoUFRYtAg4DJwAEBAUlAAARUi0IBRQAIhQCFQAqFQoXLQ4WFy0OBQktDhQILQ4SCy0OEw0jAAAQAAAqCg8FLQoFCiMAAAOvLQsJDi0LCBItCwsTLQsNFAwqChMVJAIAFQAAEDAjAAAQhgAiEgIWACoWChctCxcVACIOAhcAKhcKGC0LGBYAKhUWFy0CEgMnAAQEBSUAABFSLQgFFQAiFQIWACoWChgtDhcYLQ4OCS0OFQgtDhMLLQ4UDSMAABCGACoKDw4tCg4KIwAAAwktCwkQLQsIES0LCxItCw0TDCoKEhQkAgAUAAAQtiMAABEMACIRAhUAKhUKFi0LFhQAIhACFgAqFgoXLQsXFQAqFBUWLQIRAycABAQFJQAAEVItCAUUACIUAhUAKhUKFy0OFhctDhAJLQ4UCC0OEgstDhMNIwAAEQwAKgoPEC0KEAojAAACFCgAAAQEeEsMAAAEAyQAAAMAABE/KgEAAQXaxfXWtEoybTwEAgEmKgEAAQUGYTs9C529MzwEAgEmLQEDBgoABgIHJAAABwAAEWgjAAARcS0AAwUjAAARtS0AAQUAAAEEAQAAAwQJLQADCi0ABQsKAAoJDCQAAAwAABGrLQEKCC0ECAsAAAoCCgAACwILIwAAEYcnAQUEAQIABgIGJioBAAEFcjEMljOspz88BAIBJioBAAEFBQQbmSCvYEw8BAIBJioBAAEF0Afr9MvGZ5A8BAIBJioBAAEF18BnoWD/gCo8BAIBJioBAAEF5AhQRQK1jB88BAIBJgAAAwUHLQADCC0ABAkKAAgHCiQAAAoAABJBLQEIBi0EBgkAAAgCCAAACQIJIwAAEh0mLQEECAAABAIMBAADBQkAAAwCDC0BDAoAAAwCCwAACQUMDgAMCg0KAAgCDiQAAA0AABJ6IwAAEsgkAAAOAAAShyMAABKZLQAEBgAABgIPLQQMDyMAABLDJwAQBAMAAAoQDy0AAQYAAAEPAScBBgQBAAAGAg8tBAwPAAAPAg8tBAoPIwAAEvwnABAEAgQADBAPJwARBAMAAA8REC0AAQYAAAEQAScBBgQBAAAGAhAtBAwQAAAQAhAtBA8QJwAOBAMAAAYODQAADQUOAgAJAg8AAA4PEAAACw8RDAARCw8kAAAPAAATPi0BERItBBIQAgARAhECABACECMAABMaLQANByY=",
      "custom_attributes": [
        "external",
        "public"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "send_value_public"
    },
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "14067204867181196045": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "9921926525851912681": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "utility"
      ],
      "debug_symbols": "TL3LkjS7bqT7LmusQfICENCrnEHb6XNpk5msZdaXkV6+K+AE3Sdan2v/RWeQhGdkJCrrP//5f/+///q//9t/+bf//v//x//851//r//857/+j3/793//t//2X/79P/6f//t//dt//Pe//+9//vP7/s+Kf/51/cs/K//5V/+Xf/bf/y/+/jPwn4n/LPxn4z+G/zj+c/CfwH+y/mMYxTCKYRTDKIZRDKMYRjGMYhjFMIpjFMcojlEcozhGcYziGMUximMUxygHoxyMcjDKwSgHoxyMcjDKwSgHoxyMEhglMEpglMAogVECowRGCYwSGCUwSmKUxCiJURKjJEZJjJIYJTFKYpTEKOP3u/8d97/z/nfd/+77X7v/9fvfc/8b9793vHHHG3e8cccbd7xxxxt3vHHHG3/jjd8H0ZAX5q/hb8yxPpgNq2E3/I07/IO/gWf91GmIhrywfg2j4W/kuT9YDbvBGr6R7YPTEA3fnL/L+c4+YDT8jbzGB6thN1iDN5yGaMgLXz0ARkOPbD2y9chfZaxvWb7aAJyGaMgLX40ARsNsWA27oUf2Htl7ZO+RvUc+PfLpkU+PfHrk0yOfHvn0yKdHPj3y6ZGjR/6qaX1b8NUTYDXsBmvwhtMQDXnhqy9Aj5w9cvbI2SNnj5w9cvbI2SPnHXn+fg2jYTasht1gDd5wGqKhRx498uiRR488euTRI48eefTIo0cePfLokWePPHvk2SPPHnn2yLNHnj3y7JFnjzx75NUjrx559cirR1498uqRV4+8euTVI68eeffIu0fePfLukXePvHvk3SNXDcYH0ZAXqgYLRsNsWA27wRq8oUe2Htl65K8G9/hgNMyGv5G3f7AbrMEbTkM05IWvBgGjYTb0yKdHPj3yuYk0z2mIhptIM34No2E2rIbdYA09cvTI0SN/NbjzD74aBIyG2bAadoM1eMNpiIY78vr9GkbDbPgb2X4f7AZr8IbTEA154atBwGiYDT3y6JFHj/zVoJ0PTkM05IWvBgGjYTasht1gDT3y7JFnjzx75NUjrx559cirR1498uqRV4+8euTVI68eeffIu0fePfLukXePvHvk3SPvHnn3yLtHth7ZemTrka1Hth7ZemTrka1Hth7ZemTvkb1H9h7Ze2Tvkb1H9h7Ze2Tvkb1HPj3y6ZFPj3x65NMjnx759MinRz498umRo0eOHjl65OiRo0eOHjl65OiRo0eOHjl75OyRs0fOHjl75OyRs0fOHjl75Lwj79+vYTTMhtWwG6zBG05DNPTIo0cePfLokUePPHrk0SN3De6uwd01uLsGd9fg7hrcXYO7a3B3De6uwd01uLsGd9fg7hrcXYO7a3B3De6uwd01uLsGd9fg7hrcXYO7a3B3De6uwd01uLsGd9fg7hrcXYO7a3B3De6uwd01uLsGd9fg7hrcXYO7a3B3De6uwd01uLsGd9fg7hrcXYO7a3B3De6uwd01uLsGd9fg7hrcXYO7a3B3De6uwd01uLsGd9fg7hrcXYO7a3B3De6uwd01uLsGd9fg7hrcXYO7a3B3De6uwd01uLsGd9fg7hrcXYO7a3B3De6uwd01uLsGrWvQugata9C6Bq1r0LoGrWvQugata9C6Bq1r0LoGrWvQugata9C6Bq1r0LoGrWvQugata9C6Bq1r0LoGrWvQugata9C6Bq1r0LoGrWvQugata9C6Bq1r0LoGrWvQugata9C6Bq1r0LoGrWvQugata9C6Bq1r0LoGrWvQugata9C6Bq1r0LoGrWvQugata9C6Bq1r0LoGrWvQugata9C6Bq1r0LoGrWvQugata9C6Bq1r0LoGrWvQugata9C6Bq1r0LoGrWvQugata9C6Bq1r0LoGrWvQugata9C6Bq1r0LoGrWvQugata9C6Bq1r0LoGrWvQugata9C6Br1r0LsGvWvQuwa9a9C7Br1r0LsGvWvQuwa9a9C7Br1r0LsGvWvQuwa9a9C7Br1r0LsGvWvQuwa9a9C7Br1r0LsGvWvQuwa9a9C7Br1r0LsGvWvQuwa9a9C7Br1r0LsGvWvQuwa9a9C7Br1r0LsGvWvQuwa9a9C7Br1r0LsGvWvQuwa9a9C7Br1r0LsGvWvQuwa9a9C7Br1r0LsGvWvQuwa9a9C7Br1r0LsGvWvQuwa9a9C7Br1r0LsGvWvQuwa9a9C7Br1r0LsGvWvQuwa9a9C7Br1r0LsGvWvQuwa9a9C7Br1r0LsGvWvQuwa9a9C7Br1r0LsGvWvQuwZP1+DpGjxdg6dr8HQNnq7B0zV4ugZP1+DpGjxdg6dr8HQNnq7B0zV4ugZP1+DpGjxdg6dr8HQNnq7B0zV4ugZP1+DpGjxdg6dr8HQNnq7B0zV4ugZP1+DpGjxdg6dr8HQNnq7B0zV4ugZP1+DpGjxdg6dr8HQNnq7B0zV4ugZP1+DpGjxdg6dr8HQNnq7B0zV4ugZP1+DpGjxdg6dr8HQNnq7B0zV4ugZP1+DpGjxdg6dr8HQNnq7B0zV4ugZP1+DpGjxdg6dr8HQNnq7B0zV4ugZP1+DpGjxdg6dr8HQNnq7B0zV4ugZP1+DpGjxdg6dr8HQNnq7B0zV4ugZP1+DpGjxdg6drMLoGo2swugajazC6BqNrMLoGo2swugajazC6BqNrMLoGo2swugajazC6BqNrMLoGo2swugajazC6BqNrMLoGo2swugajazC6BqNrMLoG46tB/30wG1bD38i+P7AGbzgN0ZAXvhoEjIbZsBp65N0j7x5598i7R949svXI1iNbj2w9svXI1iNbj2w9svXI1iN7j+w9svfI3iN7j+w9svfI3iN7j+w98umRT498euTTI58e+fTIp0c+PfLpkU+PHD1y9MjRI0ePHD1y9MjRI0ePHD1y9MjZI2ePnD1y9sjZI2ePnD1y9sjZI+cdOX+/htEwG1bDbrAGbzgN0dAjjx559MijRx498uiRR488euTRI48eefTIs0eePfLskWePPHvk2SPPHnn2yLNHnj3y6pFXj7x65NUjdw1m12B2DWbXYHYNZtdgdg1m12B2DWbXYHYNZtdgdg1m12B2DWbXYHYNZtdgdg1m12B2DWbXYHYNZtdgdg1m12B2DWbXYHYNZtdgdg1m12B2DWbXYHYNZtdgdg1m12B2DWbXYHYNZtdgdg1m12B2DWbXYHYNZtdgdg1m12B2DWbXYHYNZtdgdg1m12B2DWbXYHYNZtdgdg1m12B2DWbXYHYNZtfg30fyv0fj0Xy0Hu1H9sgfnUfx6HmM5zGex3ge43mM5zGex3ge43mM5zGex3we83nM5zGfx3we83nM5zGfx3we83ms57Gex3oe63ms57Gex3oe63ms57Gex34e+3ns57Gfx34e+3ns57Gfx34e+3nY87DnYc/Dnoc9D3se9jzsedjzsOfhz8Ofhz8Pfx7+PPx5+PPw5+HPw5/HeR7neZzncZ7HeR7neZzncZ7HeR7necTziOcRzyOeRzyPeB7xPOJ5xPOI55HPI59HPo98Hvk88nnk88jnkc/j1fl4dT5enY9X5+PV+Xh1Pl6dj1fn49X5eHU+Xp2PV+fj1fl4dT5enY9X5+PV+Xh1Pl6dj1fn49X5eHU+Xp2PV+fj1fl4dT5enY9X5+PV+Xh1Pl6dj1fn49X5eHU+Xp2PV+fj1fl4dT5enY9X5+PV+Xh1Pl6dj1fn49X5eHU+Xp2PV+fj1fl4dT5enY9X5+PV+Xh1Pl6dj1fn49X5eHU+Xp2PV+fj1fl4dT5enY9X5+PV+Xh1Pl6dj1fn49X5eHU+Xp2PV+fj1fl4dT5enY9X5+PV+Xh1Pl6dj1fn49X5eHU+Xp2PV+fj1fl4dT5enY9X5+PV+Xh1Pl6dj1fn49X5eHU+Xp2PV+fj1fl4dT5enY9X5+PV+Xx1Pl+dz1fn89X5fHU+X53PV+fz1fl8dT5fnc9X5/PV+Xx1Pl+dz1fn89X5fHU+X53PV+fz1fl8dT5fnc9X5/PV+Xx1Pl+dz1fn89X5fHU+X53PV+fz1fl8dT5fnc9X5/PV+Xx1Pl+dz1fn89X5fHU+X53PV+fz1fl8dT5fnc9X5/PV+Xx1Pl+dz1fn89X5fHU+X53PV+fz1fl8dT5fnc9X5/PV+Xx1Pl+dz1fn89X5fHU+X53PV+fz1fl8dT5fnc9X5/PV+Xx1Pl+dz1fn89X5fHU+X53PV+fz1fl8dT5fnc9X5/PV+Xx1Pl+dz1fn89X5fHU+X53PV+fz1fl8dT5fnc9X5/PV+Xx1Pl+dz1fn89X5enW+Xp2vV+fr1fl6db5ena9X5+vV+Xp1vl6dr1fn69X5enW+Xp2vV+fr1fl6db5ena9X5+vV+Xp1vl6dr1fn69X5enW+Xp2vV+fr1fl6db5ena9X5+vV+Xp1vl6dr1fn69X5enW+Xp2vV+fr1fl6db5ena9X5+vV+Xp1vl6dr1fn1YPkURSPsumr81Odw1+dX5qP1qP9yB75o/MoHmWTPw9/Hv48/Hn48/Dn4c/Dn4c/D38e53mc53Gex3ke53mc53Gex3ke53mc5xHPI55HPI94HvE84nnE84jnEc8jnkc+j3we+TzyeeTzyOeRzyOfRz6PbI9qXLo0Hs1H69F+ZI/80XkUj57HeB7jeYznMZ7HeB7jeYznMZ7HeB7jecznMZ/HfB7zecznMZ/HfB7zecznMZ/Heh7reaznsZ7Heh7reaznsZ7Heh7reeznsZ/Hfh77eeznsZ/Hfh77eeznsZ/Hq/P96ny/Ot+vzver8+p3OrPIH51H8Sibqs5B49F8tB7tR8/Dn4c/D38e/jzO8zjP4zyP8zzO8zjP4zyP8zzO8zjPI55HPI94HvE84nnE84jnEc8jnkc8j3we+TzyeeTzyOeRzyOfRz6PfB7ZHtUcdWk8mo/Wo/3IHvmj8ygePY/xPMbzGM9jPI/xPMbzGM9jPI/xPMbzmM9jPo/5PObzmM9jPo/5PObzmM9jPo/1PNbzWM9jPY/1PNbzWM9jPY/1PNbz2M9jP4/9PPbz2M9jP4/9PPbz2M9jPw97HvY87HnY87Dn8ercXp3bq3N7dW6vzu3Vub06t1fn9urcXp3bq3N7dW6vzu3Vub06t1fn9urcXp3bq3N7dW6vzu3Vub06t1fn9urcXp3bq3N7dV79VseK9iN75I/Oo3iUTVXnoPFoPnoe+TzyeeTzyOeRzyPboxqwLo1H89F6tB/ZI390Hv15xCjKpvq9ONB4NB+tR/uRPfJH59Hz+Oo8vhWvpqxL49F8tB7tR/bIH51H8eh5rOexnsd6Hl+dxy7aj+yRPzqP4lE21S+Ogsaj+eh57Oexn8d+Hvt57Oexn4c9D3se9jzsedjzsOdhz8Oehz0Pex7+PPx5+PPw5+HPw5+HPw9/HvXLqHXC6vdRi+pXUkGfhxfNR+vR5xFF9sgf/Xlknaavzi9l01fneYrGo/nozyNrlK/OL9kj/35581d4iEHMh1+tNw7iJC7iJhqRbkm3pFuW23dV1fLVOIjltgsXcRON6MRDDGI+HD/iINJt0G3QbZSbFTrxEIOYD/Ers8BBnMRF3ES6TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptum26Gd2MbkY3o5vRzehmdDO6Gd2Mbk43p5vTzenmdHO6Od2cbk43p9uh26Hboduh26Hboduh26HboduhW9At6BZ0C7oF3YJuQbegW9At6JZ0S7ol3ZJuSbekW9It6ZZ0y+cWvx9xECdxETfRiE48xCDSbdBt0G3QDVkShZtoRCceYhDzIbIEOIiTSLdJt0m3SbdJt0m3SbdFt0W3RbdFt0W3RbdFt0W3RbdFt023TbdNt023TbdNt023TbdNt003o5vRzehmdDO6Gd2MbkY3o5vRzenmdHO6Od2cbk43p5vTzenmdDt0O3Q7dDt0O3Q7dDt0O3Q7dDt0C7oF3YJuQbegW9At6BZ0C7oF3ZJuSbekW9It6ZZ0S7ol3ZJu+dzy9yMO4iQu4iYa0YmHGES6DboNug26MUuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySahEcYxQO4iQu4iYa0YmHGMR8mHRLuiXdKkvGLNxEIzrxEIOYF2d1EjYO4iQu4iYa0YmHGES6DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26bboZ3YxulSVjFy7iJpbbKXTiIQYxH1aWXBzESVzETaSb083p5nRzuh26Hboduh26Hboduh26Hboduh26Bd2CbkG3oFvQLegWdAu6Bd2Cbkm3pFvSLemWdEu6Jd2Sbkm3fG7j9yMO4iQu4iYa0YmHGES6DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26bboZ3YxuRjejm9GNWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWbKYJYtZspgli1mymCWLWbKYJYtZspgli1mymCWL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26DboNug26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptumW2XJ960xu/peG534uc0oDGI+rCz5fqNyV99r4yR+bqvcKksuGvFz+z7h39X32hjEz+37XG9X32vjIH5u2woXcRM/N6sLqiy5eIifm2GwfFhZcvFz81/hJC7i5+Y138qSi0783LzWrLLkYj6sLDk138qSi5P4uZ1as8qSi0b83E6temXJxSDmw8qSi4M4iYu4iUakW9It6ZbPrfpeGwdxEhdxE43oxEMMIt0G3QbdBt0G3QbdBt0G3QbdKku+++pdfa8XK0sufm7fX1Da1ffauIibaEQnHmIQ82FlyUW6Lbotui26VZZ8f4FpV99r4yF+bjkL82FlycXPLesyK0suLuImGtGJhxjEfFhZcpFuRrcvS9av5vtlSaMR/cOa75cljUHMD796q77XxkGcH9Z2+yLuRnRKRtE37Piqv1oi1/eOYFdLZOMibqIRnXiIQcyH3zFrpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptumm9HN6GZ0M7oZ3YxuRjejm9HN6OZ0c7o53ZxudcyGFRrRiYcYxHx4yq0O6hnESVzEz23W+f1esho/t++b5na1RDYGMR9+L1mNgziJn9vchZtoxHLzwkMMYrnVfPNHHMRJXMRN/Ny+r0jY1RLZeIhB/Ny+34Tb1RLZOIif2/4VLuImfm5f2+uulsjG83DUVZzCb9y6hak2x7W9sEbIQiceYhDzYeXDxW/curGpNsfGRdzEz63ucarNsfFzs5pk5cPFfFj5cHEQJ/Fz+zosdrU5NhrRiZ/b98RrV5tj4+fmNcnKh4uDOInlVsaVDxeN6MRDDOLndmo6lQ8XB3ESP7dTk6x8uGjEcrPCQ4yHVfMXa4S6iqruupWrzsS/J+AfVklfHMRJXMRvsKhJVklfdOIhBjEfVknXPUN1JjZO4iKWW823SvqiE8utZlYlfTEfVklHHdoq6awaqpKuu47qTGzcRCM68TRWD+LfvyocxElcxE20h1WF35+d3NUg2FgW33yrFXDXXUe1AjZO4iJuoj1c9f+t+S4jOvEQg5gP9484iJO4iHTbdNt023TbdNt0sxp3FdYIu7BG8MJDDGKN8G13teE1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",
      "is_unconstrained": true,
      "name": "sync_private_state"
    }
  ],
  "name": "MessageBridge",
  "noir_version": "1.0.0-beta.14+82ec52a8c755d30ce655a2005834186a4acfa0c7-aztec",
  "outputs": {
    "globals": {
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "minters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Wormhole"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "state",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "sequences",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "owner",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "receiver_address",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000009"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "token_address",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000d"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_1",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000011"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_2",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000012"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_3",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000013"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_4",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000014"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_5",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000015"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_6",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000016"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_7",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000017"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_8",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000018"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_9",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000019"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_10",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_11",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001b"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_12",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001c"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_13",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001d"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_14",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001e"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_15",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001f"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_16",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000020"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_17",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000021"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_18",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000022"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_19",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000023"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "current_guardian_set_index",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000024"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "MessageBridge"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "config",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "owner",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "registered_emitters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "current_value",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  }
                ],
                "kind": "struct",
                "path": "MessageBridge::_update_value_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::_update_value_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "wormhole_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "chain_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 16
                    }
                  },
                  {
                    "name": "owner",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "message_fee",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "MessageBridge::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "MessageBridge::get_config_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "wormhole_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "chain_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 16
                    }
                  },
                  {
                    "name": "message_fee",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "config::Config"
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::get_config_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "MessageBridge::get_current_value_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::get_current_value_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "MessageBridge::get_owner_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::get_owner_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "chain_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 16
                    }
                  },
                  {
                    "name": "emitter_address",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "MessageBridge::is_emitter_registered_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "boolean"
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::is_emitter_registered_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "message_ciphertext",
                    "type": {
                      "fields": [
                        {
                          "name": "storage",
                          "type": {
                            "kind": "array",
                            "length": 17,
                            "type": {
                              "kind": "field"
                            }
                          }
                        },
                        {
                          "name": "len",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 32
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "std::collections::bounded_vec::BoundedVec"
                    }
                  },
                  {
                    "name": "message_context",
                    "type": {
                      "fields": [
                        {
                          "name": "tx_hash",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "unique_note_hashes_in_tx",
                          "type": {
                            "fields": [
                              {
                                "name": "storage",
                                "type": {
                                  "kind": "array",
                                  "length": 64,
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              },
                              {
                                "name": "len",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "std::collections::bounded_vec::BoundedVec"
                          }
                        },
                        {
                          "name": "first_nullifier_in_tx",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "recipient",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::messages::processing::message_context::MessageContext"
                    }
                  }
                ],
                "kind": "struct",
                "path": "MessageBridge::process_message_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::process_message_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "vaa",
                    "type": {
                      "kind": "array",
                      "length": 2000,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "length",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "MessageBridge::receive_value_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::receive_value_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "source_chain_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 16
                    }
                  },
                  {
                    "name": "emitter_address",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "MessageBridge::register_emitter_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::register_emitter_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "destination_chain_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 16
                    }
                  },
                  {
                    "name": "value",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  },
                  {
                    "name": "fee_nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "MessageBridge::send_value_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::send_value_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "destination_chain_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 16
                    }
                  },
                  {
                    "name": "value",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  },
                  {
                    "name": "fee_nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "MessageBridge::send_value_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::send_value_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "MessageBridge::sync_private_state_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::sync_private_state_abi"
        }
      ]
    }
  },
  "transpiled": true
}
