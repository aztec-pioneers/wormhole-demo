{
  "file_map": {
    "100": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr",
      "source": "use super::utils::compute_fn_selector;\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::utils::get_params_len_quote;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault, panic};\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let seen_selectors =\n        &mut UHashMap::<Field, Quoted, BuildHasherDefault<Poseidon2Hasher>>::default();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n        let fn_name = function.name();\n\n        // Since function selectors are computed as the first 4 bytes of the hash of the function signature,\n        // it's possible to have collisions. With the following check, we ensure it doesn't happen within\n        // the same contract.\n        if seen_selectors.contains_key(selector) {\n            let existing_fn = seen_selectors.get(selector).unwrap();\n            panic(\n                f\"Public function selector collision detected between functions '{fn_name}' and '{existing_fn}'\",\n            );\n        }\n        seen_selectors.insert(selector, fn_name);\n\n        let params_len_quote = get_params_len_quote(parameters);\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $params_len_quote] = dep::aztec::context::public_context::calldata_copy(1, $params_len_quote);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index: &mut u32 = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[external(\"public\")]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "104": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/macros/functions/call_interface_stubs.nr",
      "source": "//! Stubs are auto-generated wrapper functions that provide an ergonomic interface for cross-contract calls.\n//! Instead of manually serializing arguments and creating call interfaces, stubs allow natural syntax, e.g. for\n//! enqueuing calls to public functions:\n//!\n//!   ExternalContract.at(address).some_method(arg1, arg2).enqueue()\n\nuse crate::macros::utils::{AsStrQuote, compute_fn_selector, is_fn_view};\nuse super::stub_registry;\nuse protocol_types::meta::utils::derive_serialization_quotes;\nuse std::meta::unquote;\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\npub comptime fn register_private_fn_stub(f: FunctionDefinition) {\n    let stub = if is_fn_view(f) {\n        create_private_static_stub(f)\n    } else {\n        create_private_stub(f)\n    };\n    stub_registry::register(f.module(), stub);\n}\n\npub comptime fn register_public_fn_stub(f: FunctionDefinition) {\n    let stub = if is_fn_view(f) {\n        create_public_static_stub(f)\n    } else {\n        create_public_stub(f)\n    };\n    stub_registry::register(f.module(), stub);\n}\n\npub comptime fn register_utility_fn_stub(f: FunctionDefinition) {\n    let stub = create_utility_stub(f);\n    stub_registry::register(f.module(), stub);\n}\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, Quoted, u32, Field) {\n    // Dear privacy adventurer,\n    // Chances are, you've command+clicked on the name of an external function\n    // call -- seeking to view that function -- only to end up here.\n    // Here's an explanation:\n    // The external contract that you're calling was likely annotated with the `#[aztec]`\n    // annotation -- as all good aztec contracts are. This triggers a macro which generates\n    // a \"contract interface\" for that contract, which is effectively a pretty interface\n    // that gives natural contract calling semantics:\n    //\n    // `MyImportedContract.at(some_address).my_method(arg1, arg2).enqueue();\n    //\n    // Unfortunately, the usage of macros makes it a bit of a black box.\n    // To actually view the target function, you could instead command+click on\n    // `MyImportedContract`, or you can just manually search it.\n    // If you want to view the noir code that gets generated by this macro, you can\n    // use `nargo expand` on your contract.\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n\n    let (serialized_args_array_construction, _, serialized_args_array_name) =\n        derive_serialization_quotes(fn_parameters, false);\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name,\n        fn_name_str, fn_name_len, fn_selector,\n    )\n}\n\ncomptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, serialized_args_array_name, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            )\n        }\n    }\n}\n\ncomptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, serialized_args_array_name, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, serialized_args_array_name, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            )\n        }\n    }\n}\n\ncomptime fn create_utility_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, serialized_args_array_name, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::UtilityCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::UtilityCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            )\n        }\n    }\n}\n"
    },
    "105": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\n// Used by `create_mark_as_initialized` (you won't find it through searching)\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\n// Used by `create_mark_as_initialized` (you won't find it through searching)\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\n// Used by `create_init_check` (you won't find it through searching)\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\n// Used by `create_init_check` (you won't find it through searching)\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\n// Used by `create_assert_correct_initializer_args` (you won't find it through searching)\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender().unwrap()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n// Used by `create_assert_correct_initializer_args` (you won't find it through searching)\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender().unwrap()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "108": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{\n        auth_registry::AUTHORIZE_ONCE_REGISTRY,\n        call_interface_stubs::{\n            register_private_fn_stub, register_public_fn_stub, register_utility_fn_stub,\n        },\n    },\n    notes::NOTES,\n    utils::{\n        fn_has_authorize_once, fn_has_noinitcheck, is_fn_contract_library_method, is_fn_external,\n        is_fn_initializer, is_fn_internal, is_fn_test, is_fn_view, modify_fn_body,\n        module_has_initializer, module_has_storage,\n    },\n};\nuse dep::protocol_types::meta::utils::derive_serialization_quotes;\nuse std::meta::{ctstring::AsCtString, type_of};\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) {\n    register_private_fn_stub(f);\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    let (args_serialization, _, serialized_args_name) =\n        derive_serialization_quotes(original_params, false);\n\n    let context_creation = quote {\n        $args_serialization\n        let args_hash = dep::aztec::hash::hash_args_array($serialized_args_name);\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, args_hash);\n    };\n\n    let function_name = f.name();\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        let assertion_message = f\"Function {function_name} can only be called internally\";\n        quote { assert(context.msg_sender().unwrap() == context.this_address(), $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        let assertion_message =\n            f\"Function {function_name} can only be called statically\".as_ctstring().as_quoted_str();\n        quote { assert(context.inputs.call_context.is_static_call, $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (\n            quote { aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_private(context); },\n            quote { aztec::macros::functions::initialization_utils::mark_as_initialized_private(&mut context); },\n        )\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        quote { aztec::macros::functions::initialization_utils::assert_is_initialized_private(&mut context); }\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any. Note that the message\n    // discovery call syncs private events as well. We do not sync those here if there are no notes because we don't\n    // have an API that would access events from private functions.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f, true)\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is serialized and hashed before being passed to the context.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n\n        let (return_serialization, _, serialized_return_name) =\n            derive_serialization_quotes([(return_value_var_name, return_value_type)], false);\n\n        body = body_without_return;\n\n        quote {\n            $return_value_assignment\n            $return_serialization\n            context.set_return_hash($serialized_return_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    // A quote to be injected at the beginning of the function body.\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) {\n    register_public_fn_stub(f);\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n\n    let args_len_quote = if original_params.len() == 0 {\n        // If the function has no parameters, we set the args_len to 0.\n        quote { 0 }\n    } else {\n        // The following will give us <type_of_struct_member_1 as Serialize>::N + <type_of_struct_member_2 as Serialize>::N + ...\n        original_params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n            <$param_type as $crate::protocol_types::traits::Serialize>::N\n        }\n            })\n            .join(quote {+})\n    };\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len_quote] = dep::aztec::context::public_context::calldata_copy(1, $args_len_quote);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    let name = f.name();\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        let assertion_message = f\"Function {name} can only be called internally\";\n        quote { assert(context.msg_sender().unwrap() == context.this_address(), $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        let name = f.name();\n        let assertion_message =\n            f\"Function {name} can only be called statically\".as_ctstring().as_quoted_str();\n        quote { assert(context.is_static_call(), $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (\n            quote { aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_public(context); },\n            quote { aztec::macros::functions::initialization_utils::mark_as_initialized_public(&mut context); },\n        )\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        quote { aztec::macros::functions::initialization_utils::assert_is_initialized_public(&mut context); }\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f, false)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    register_utility_fn_stub(f);\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage(f.module()) {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process or they may be used to sync private events from TypeScript\n    // (`sync_private_state` function gets invoked by PXE::getPrivateEvents function).\n    let message_discovery_call = create_message_discovery_call();\n\n    // A quote to be injected at the beginning of the function body.\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Injects an authwit verification check of the form:\n/// ```\n///   if (!from.eq(context.msg_sender().unwrap())) {\n///         assert_current_call_valid_authwit::<N>(&mut context, from);\n///     } else {\n///         assert(authwit_nonce, \"Invalid authwit nonce. When 'from' and 'msg_sender' are the same, authwit_nonce must be zero\");\n///     }\n/// ```\n/// where `from` and `authwit_nonce` are the names of the parameters that are expected to be present in the function definition.\n/// This check is injected by the `#[authorize_once(\"from_arg_name\", \"nonce_arg_name\")]`, which allows the user to define\n/// which parameters to use.\n///\n/// # Arguments\n/// * `f` - The function definition to inject the authwit verification check into. The function must have parameters\n///         matching the names specified in the `#[authorize_once]` attribute.\n/// * `is_private` - Whether the function is a private function (`true`) or a public function (`false`). This determines\n///                  which authwit verification method to use: `assert_current_call_valid_authwit` for private functions\n///                  or `assert_current_call_valid_authwit_public` for public functions.\npub(crate) comptime fn create_authorize_once_check(\n    f: FunctionDefinition,\n    is_private: bool,\n) -> Quoted {\n    let maybe_authorize_once_args = AUTHORIZE_ONCE_REGISTRY.get(f);\n    let authorize_once_args = if maybe_authorize_once_args.is_some() {\n        maybe_authorize_once_args.unwrap()\n    } else {\n        // We need to for authorize_once to have already executed so that we can retrieve its params - this depends on\n        // the order in which the attributes are applied.\n        panic(\n            f\"Functions marked with #[authorize_once] must have the #[external(\\\"private\\\")] or #[external(\\\"public\\\")] attribute placed last\",\n        )\n    };\n\n    let (from_arg_name, nonce_arg_name) = authorize_once_args;\n    let name: Quoted = f.name();\n\n    let from_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{from_arg_name}\".quoted_contents());\n    let (from_arg_name_quoted, from_arg_type) = if from_arg_candidates.len() == 1 {\n        from_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {from_arg_name} parameter. Please specify which one to use in #[authorize_once(\\\"...\\\", \\\"authwit_nonce\\\")]\",\n        )\n    };\n    if from_arg_type\n        != quote { dep::protocol_types::address::aztec_address::AztecAddress }.as_type() {\n        panic(\n            f\"Argument {from_arg_name_quoted} in function {name} must be of type AztecAddress, but is of type {from_arg_type}\",\n        )\n    }\n\n    let nonce_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{nonce_arg_name}\".quoted_contents());\n    let (nonce_arg_name_quoted, nonce_arg_type) = if nonce_arg_candidates.len() == 1 {\n        nonce_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {nonce_arg_name}. Please specify which one to use in #[authorize_once(\\\"from\\\", \\\"...\\\")]\",\n        )\n    };\n    if nonce_arg_type != quote { Field }.as_type() {\n        panic(\n            f\"Argument {nonce_arg_name_quoted} in function {name} must be of type Field, but is of type {nonce_arg_type}\",\n        );\n    }\n\n    let nonce_check_quote = f\"{nonce_arg_name_quoted} == 0\".quoted_contents();\n\n    let fn_call = if is_private {\n        // At this point, the original args of the fn have already been altered by the macro\n        // to include PrivateContextInputs, so we need to adjust the args_len accordingly.\n        let args_len = f.parameters().len() - 1;\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit::<$args_len> }\n    } else {\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit_public }\n    };\n    let invalid_nonce_message = f\"Invalid authwit nonce. When '{from_arg_name}' and 'msg_sender' are the same, '{nonce_arg_name}' must be zero\"\n        .as_ctstring()\n        .as_quoted_str();\n    quote {         \n        if (!$from_arg_name_quoted.eq(context.msg_sender().unwrap())) {\n            $fn_call(&mut context, $from_arg_name_quoted);\n        } else {\n            assert($nonce_check_quote, $invalid_nonce_message);\n        }\n    }\n}\n\n/// Checks if each function in the module is marked with either #[external(...)], #[contract_library_method], or #[test].\n/// Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_external(f) & !is_fn_contract_library_method(f) & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[external(...)], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "110": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/macros/notes.nr",
      "source": "use crate::note::note_getter_options::PropertySelector;\nuse std::{collections::bounded_vec::BoundedVec, meta::{ctstring::AsCtString, type_of}};\n\n/// Maximum number of note types within 1 contract.\ncomptime global MAX_NOTE_TYPES: u32 = 128;\n\n/// A BoundedVec containing all the note types within this contract.\npub comptime mut global NOTES: BoundedVec<Type, MAX_NOTE_TYPES> = BoundedVec::new();\n\ncomptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < MAX_NOTE_TYPES,\n        f\"A contract can contain at most {MAX_NOTE_TYPES} different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_type_impl(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n    let typ = s.as_type();\n    let note_type_name: str<_> = f\"{name}\".as_ctstring().as_quoted_str!();\n    let max_note_packed_len = crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                // This static assertion ensures the note's packed length doesn't exceed the maximum allowed size.\n                // While this check would ideally live in the Packable trait implementation, we place it here since\n                // this function is always generated by our macros and the Packable trait implementation is not.\n                // Note: We set the note type name and max packed length as local variables because injecting them\n                // directly into the error message doesn't work.\n                let note_type_name = $note_type_name;\n                let max_note_packed_len: u32 = $max_note_packed_len; // Casting to u32 to avoid the value to be printed in hex.\n                let note_packed_len = <$typ as Packable>::N;\n                std::static_assert(note_packed_len <= $max_note_packed_len, f\"{note_type_name} has a packed length of {note_packed_len} fields, which exceeds the maximum allowed length of {max_note_packed_len} fields\");\n\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullification: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullification: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::traits::Packable::pack(self).concat( [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::context::PrivateContext,\n                note_hash_for_nullification: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullification, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullification: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullification, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _, _)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates the core note functionality for a struct:\n///\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - NoteHash trait implementation: Handles note hash and nullifier computation\n///\n/// # Requirements\n///\n/// The note struct must:\n/// - Have an `owner` field\n/// - Implement the `Packable` trait\n/// - Not exceed `MAX_NOTE_PACKED_LEN` when packed\n///\n/// # Registration\n///\n/// Registers the note in the global `NOTES` BoundedVec to enable note processing functionality.\n///\n/// # Generated Code\n///\n/// For detailed documentation on the generated implementations, see:\n/// - `generate_note_properties()`\n/// - `generate_note_type_impl()`\n/// - `generate_note_hash_trait_impl()`\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n    assert_has_packable(s);\n\n    // We register the note in the global `NOTES` BoundedVec because we need that information inside the #[aztec] macro\n    // to generate note processing functionality.\n    NOTES.push(s.as_type());\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_type_impl = generate_note_type_impl(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n\n    quote {\n        $note_properties\n        $note_type_impl\n        $note_hash_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n///\n/// # Requirements\n///\n/// The note struct must:\n/// - Implement the `Packable` trait\n/// - Not exceed `MAX_NOTE_PACKED_LEN` when packed\n///\n/// Unlike the `#[note]` macro, there is no requirement for an `owner` field.\n///\n/// # Registration\n///\n/// Registers the note in the global `NOTES` BoundedVec to enable note processing functionality.\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    assert_has_packable(s);\n\n    // We register the note in the global `NOTES` BoundedVec because we need that information inside the #[aztec] macro\n    // to generate note processing functionality.\n    NOTES.push(s.as_type());\n\n    let note_type_id = get_next_note_type_id();\n    let note_properties = generate_note_properties(s);\n    let note_type_impl = generate_note_type_impl(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_type_impl\n    }\n}\n\n/// Asserts that the given note implements the `Packable` trait.\n///\n/// We require that notes have the `Packable` trait implemented because it is used when emitting a note in a log or as\n/// an offchain message.\ncomptime fn assert_has_packable(note: TypeDefinition) {\n    let packable_constraint =\n        quote { crate::protocol_types::traits::Packable }.as_trait_constraint();\n    let note_name = note.name();\n\n    assert(\n        note.as_type().implements(packable_constraint),\n        f\"{note_name} does not implement Packable trait. Either implement it manually or place #[derive(Packable)] on the note struct before #[note] macro invocation.\",\n    );\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    let note_name = note.name();\n\n    assert(\n        has_owner,\n        f\"{note_name} does not have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "111": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/macros/storage.nr",
      "source": "use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract should have this macro (or `storage_no_init`) applied to it, and the\n/// struct has to be called 'Storage'.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    let struct_name = s.name();\n    if struct_name != quote { Storage } {\n        panic(\n            f\"The #[storage] macro can only be applied to a struct with name 'Storage', got '{struct_name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage_no_init\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ, _) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot });\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields = storage_layout_fields.push_back(\n            quote { pub $name: dep::aztec::state_vars::storage::Storable },\n        );\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::state_vars::storage::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract can have this macro (or storage_no_init) applied to it, and the struct\n/// has to be called 'Storage'.\npub comptime fn storage_no_init(s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n\n    // We do need to make sure that the type is called Storage, since we'll do `Storage::init` later on.\n\n    if s.name() != quote { Storage } {\n        let name = s.name();\n        panic(\n            f\"The #[storage_no_init] macro can only be applied to a struct with name 'Storage', got '{name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(typ: Type, slot: Quoted) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    let constructor = if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot });\n\n        quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }\n    } else {\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        quote { $struct_name::new(context, $slot)}\n    };\n\n    (constructor, get_storage_size(typ))\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n"
    },
    "113": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod private_events;\npub mod private_notes;\npub mod process_message;\n\nuse crate::{\n    messages::{\n        discovery::{\n            private_notes::MAX_NOTE_PACKED_LEN, process_message::process_message_ciphertext,\n        },\n        processing::{\n            get_private_logs, pending_tagged_log::PendingTaggedLog,\n            validate_enqueued_notes_and_events,\n        },\n    },\n    utils::array,\n};\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, note nonce, storage slot and note\n/// type ID and attempts to compute its note hash (not hashed by note nonce nor siloed by address) and inner nullifier\n/// (not siloed by address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, note_nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullification = aztec::note::utils::compute_note_hash_for_nullification(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(note_nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullification);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\npub type ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* note nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private logs are downloaded and inspected to find new private\n/// notes, partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Note that the state is synchronized up to the latest block synchronized by PXE. That should be close to the chain\n/// tip as block synchronization is performed before contract function simulation is done.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    // First we process all private logs, which can contain different kinds of messages e.g. private notes, partial\n    // notes, private events, etc.\n    let mut logs = get_private_logs(contract_address);\n    logs.for_each(|i, pending_tagged_log: PendingTaggedLog| {\n        debug_log_format(\n            \"Processing log with tag {0}\",\n            [pending_tagged_log.log.get(0)],\n        );\n\n        // We remove the tag from the pending tagged log and process the message ciphertext contained in it.\n        let message_ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n        process_message_ciphertext(\n            contract_address,\n            compute_note_hash_and_nullifier,\n            message_ciphertext,\n            pending_tagged_log.context,\n        );\n        logs.remove(i);\n    });\n\n    // Then we process all pending partial notes, regardless of whether they were found in the current or previous\n    // executions.\n    partial_notes::fetch_and_process_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    // Finally we validate all notes and events that were found as part of the previous processes, resulting in them\n    // being added to PXE's database and retrievable via oracles (get_notes) and our TS API (PXE::getPrivateEvents).\n    validate_enqueued_notes_and_events(contract_address);\n}\n"
    },
    "114": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub note_nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given note nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    note_nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Found valid nonces for a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullification,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        note_nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullification = compute_note_hash_for_nullification(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(note_nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullification);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        note_nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let note_nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(note_nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash = compute_unique_note_hash(\n            note_nonce,\n            compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash),\n        );\n        let inner_nullifier = note.compute_nullifier_unconstrained(\n            compute_note_hash_for_nullification(retrieved_note, STORAGE_SLOT),\n        );\n\n        NoteAndData { note, note_nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.note_nonce, note_and_data.note_nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == first_note_and_data.note_nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == second_note_and_data.note_nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "115": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::{\n            enqueue_note_for_validation, get_pending_partial_notes_completion_logs,\n            log_retrieval_response::LogRetrievalResponse,\n        },\n    },\n    utils::array,\n};\n\nuse protocol_types::{\n    address::AztecAddress,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for logs that would result in the completion of pending partial notes, ultimately resulting in the notes\n/// being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    // Each of the pending partial notes might get completed by a log containing its public values. For performance\n    // reasons, we fetch all of these logs concurrently and then process them one by one, minimizing the amount of time\n    // waiting for the node roundtrip.\n    let maybe_completion_logs =\n        get_pending_partial_notes_completion_logs(contract_address, pending_partial_notes);\n\n    // Each entry in the maybe completion logs array corresponds to the entry in the pending partial notes array at the\n    // same index. This means we can use the same index as we iterate through the responses to get both the partial note\n    // and the log that might complete it.\n    assert_eq(maybe_completion_logs.len(), pending_partial_notes.len());\n\n    maybe_completion_logs.for_each(|i, maybe_log: Option<LogRetrievalResponse>| {\n        // We clear the completion logs as we read them so that the array is empty by the time we next query it.\n        // TODO(#14943): use volatile arrays to avoid having to manually clear this.\n        maybe_completion_logs.remove(i);\n\n        let pending_partial_note = pending_partial_notes.get(i);\n\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log plaintext to get\n            // the complete packed content.\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                log.log_payload,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            // TODO(#11627): is there anything reasonable we can do if we get a log but it doesn't result in a note\n            // being found?\n            if discovered_notes.len() == 0 {\n                panic(\n                    f\"A partial note's completion log did not result in any notes being found - this should never happen\",\n                );\n            }\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                enqueue_note_for_validation(\n                    contract_address,\n                    pending_partial_note.storage_slot,\n                    discovered_note.note_nonce,\n                    complete_packed_note,\n                    discovered_note.note_hash,\n                    discovered_note.inner_nullifier,\n                    log.tx_hash,\n                    pending_partial_note.recipient,\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
    },
    "116": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/discovery/private_events.nr",
      "source": "use crate::{\n    event::event_selector::EventSelector,\n    messages::{encoding::MAX_MESSAGE_CONTENT_LEN, processing::enqueue_event_for_validation},\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::GENERATOR_INDEX__EVENT_COMMITMENT,\n    hash::poseidon2_hash_with_separator_bounded_vec, traits::FromField,\n};\n\n/// The number of fields in a private event message content that are not the event's serialized representation\n/// (1 field for randomness).\nglobal PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of an event's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, randomness, etc.).\npub global MAX_EVENT_SERIALIZED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN;\n\npub unconstrained fn process_private_event_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n) {\n    // In the case of events, the msg metadata is the event selector.\n    let event_type_id = EventSelector::from_field(msg_metadata as Field);\n\n    assert(\n        msg_content.len() > PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n        f\"Invalid private event message: all private event messages must have at least {PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private event message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN\",\n    );\n\n    let serialized_event_with_randomness = msg_content;\n\n    let event_commitment = poseidon2_hash_with_separator_bounded_vec(\n        serialized_event_with_randomness,\n        GENERATOR_INDEX__EVENT_COMMITMENT,\n    );\n\n    // Randomness was injected into the event payload in `emit_event_in_private` but we have already used it\n    // to compute the event commitment, so we can safely discard it now.\n    let serialized_event = array::subbvec(\n        serialized_event_with_randomness,\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n    );\n\n    enqueue_event_for_validation(\n        contract_address,\n        event_type_id,\n        serialized_event,\n        event_commitment,\n        tx_hash,\n        recipient,\n    );\n}\n"
    },
    "117": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::enqueue_note_for_validation,\n    },\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\n// See the call to `std::static_assert` below to see what's in these fields.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        enqueue_note_for_validation(\n            contract_address,\n            storage_slot,\n            discovered_note.note_nonce,\n            packed_note,\n            discovered_note.note_hash,\n            discovered_note.inner_nullifier,\n            tx_hash,\n            recipient,\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
    },
    "118": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/discovery/process_message.nr",
      "source": "use crate::messages::{\n    discovery::{\n        ComputeNoteHashAndNullifier, partial_notes::process_partial_note_private_msg,\n        private_events::process_private_event_msg, private_notes::process_private_note_msg,\n    },\n    encoding::{decode_message, MESSAGE_CIPHERTEXT_LEN, MESSAGE_PLAINTEXT_LEN},\n    encryption::{aes128::AES128, message_encryption::MessageEncryption},\n    msg_type::{\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n    },\n    processing::message_context::MessageContext,\n};\n\nuse protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\n/// Processes a message that can contain notes, partial notes, or events.\n///\n/// Notes result in nonce discovery being performed prior to delivery, which requires knowledge of the transaction hash\n/// in which the notes would've been created (typically the same transaction in which the log was emitted), along with\n/// the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier` function. Once\n/// discovered, the notes are enqueued for validation.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\n///\n/// Events are processed by computing an event commitment from the serialized event data and its randomness field, then\n/// enqueueing the event data and commitment for validation.\npub unconstrained fn process_message_ciphertext<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_ciphertext: BoundedVec<Field, MESSAGE_CIPHERTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    process_message_plaintext(\n        contract_address,\n        compute_note_hash_and_nullifier,\n        AES128::decrypt(message_ciphertext, message_context.recipient),\n        message_context,\n    );\n}\n\npub unconstrained fn process_message_plaintext<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_plaintext: BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    // The first thing to do after decrypting the message is to determine what type of message we're processing. We\n    // have 3 message types: private notes, partial notes and events.\n\n    // We decode the message to obtain the message type id, metadata and content.\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(message_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            message_context.tx_hash,\n            message_context.unique_note_hashes_in_tx,\n            message_context.first_nullifier_in_tx,\n            message_context.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        process_private_event_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n            message_context.tx_hash,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "119": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::utils::array;\nuse protocol_types::constants::PRIVATE_LOG_CIPHERTEXT_LEN;\n\n// We reassign to the constant here to communicate the distinction between a log and a message. In Aztec.nr, unlike in\n// protocol circuits, we have a concept of a message that can be emitted either as a private log or as an offchain\n// message. Message is a piece of data that is to be eventually delivered to a contract via the `process_message(...)`\n// utility function function that is injected by the #[aztec] macro.\npub global MESSAGE_CIPHERTEXT_LEN: u32 = PRIVATE_LOG_CIPHERTEXT_LEN;\n\n// TODO(#12750): The global variables below should not be here as they are AES128 specific.\n// ciphertext_length (2) + 14 bytes pkcs#7 AES padding.\npub(crate) global HEADER_CIPHERTEXT_SIZE_IN_BYTES: u32 = 16;\n\npub global EPH_PK_X_SIZE_IN_FIELDS: u32 = 1;\npub global EPH_PK_SIGN_BYTE_SIZE_IN_BYTES: u32 = 1;\n\n// (17 - 1) * 31 - 16 - 1 = 479\nglobal MESSAGE_PLAINTEXT_SIZE_IN_BYTES: u32 = (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS)\n    * 31\n    - HEADER_CIPHERTEXT_SIZE_IN_BYTES\n    - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES;\n// Each field of the original note log was serialized to 32 bytes. Below we convert the bytes back to fields.\n// 479 / 32 = 15\npub global MESSAGE_PLAINTEXT_LEN: u32 = MESSAGE_PLAINTEXT_SIZE_IN_BYTES / 32;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MESSAGE_PLAINTEXT_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u16 {\n    fn from(value: u8) -> u16 {\n        value as u16\n    }\n}\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u16> for u32 {\n    fn from(value: u16) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u16> for u64 {\n    fn from(value: u16) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u16> for u128 {\n    fn from(value: u16) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u16> for Field {\n    fn from(value: u16) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i16 {\n    fn from(value: i8) -> i16 {\n        value as i16\n    }\n}\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i16> for i32 {\n    fn from(value: i16) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\n\nimpl From<i16> for i64 {\n    fn from(value: i16) -> i64 {\n        value as i64\n    }\n}\n\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u16 {\n    fn from(value: bool) -> u16 {\n        value as u16\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for u128 {\n    fn from(value: bool) -> u128 {\n        value as u128\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i16 {\n    fn from(value: bool) -> i16 {\n        value as i16\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            let body = if type1 == type2 {\n                quote { self }\n            } else if type1 == quote { bool } {\n                quote { self != 0 }\n            } else {\n                quote { self as $type1 }\n            };\n\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        $body\n                    }\n                }\n            },\n            );\n        }\n    }\n\n    let u_types =\n        [quote { bool }, quote { u8 }, quote { u16 }, quote { u32 }, quote { u64 }, quote { u128 }];\n\n    for type2 in u_types {\n        let body = quote { self as Field };\n\n        impls = impls.push_back(\n            quote {\n                impl AsPrimitive<Field> for $type2 {\n                    fn as_(self) -> Field {\n                        $body\n                    }\n                }\n            },\n        );\n    }\n\n    for type1 in u_types {\n        let body = if type1 == quote { bool } {\n            quote { self != 0 }\n        } else {\n            quote { self as $type1 }\n        };\n\n        impls = impls.push_back(\n            quote {\n                impl AsPrimitive<$type1> for Field {\n                    fn as_(self) -> $type1 {\n                        $body\n                    }\n                }\n            },\n        );\n    }\n\n    impls.join(quote {})\n}\n"
    },
    "120": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encoding::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, MESSAGE_CIPHERTEXT_LEN, MESSAGE_PLAINTEXT_LEN,\n        },\n        encryption::message_encryption::MessageEncryption,\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__message_bytes__from_PT,\n            get_arr_of_size__message_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\n/**\n * Computes N close-to-uniformly-random 256 bits from a given ECDH shared_secret.\n *\n * NEVER re-use the same iv and sym_key.\n * DO NOT call this function more than once with the same shared_secret.\n *\n * This function is only known to be safe if shared_secret is computed by combining a \n * random ephemeral key with an address point. See big comment within the body of the function.\n * See big comment within the body of the function.\n */\nfn extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [[u8; 32]; N] {\n    /*\n     * Unsafe because of https://eprint.iacr.org/2010/264.pdf Page 13, Lemma 2 (and the * two paragraphs below it).\n     *\n     * If you call this function, you need to be careful and aware of how the arg\n     * `shared_secret` has been derived.\n     *\n     * The paper says that the way you derive aes keys and IVs should be fine with poseidon2\n     * (modelled as a RO), as long as you _don't_ use Poseidon2 as a PRG to generate the * two exponents x & y which multiply to the shared secret S:\n     *\n     * S = [x*y]*G.\n     *\n     * (Otherwise, you would have to \"key\" poseidon2, i.e. generate a uniformly string K\n     * which can be public and compute Hash(x) as poseidon(K,x)).\n     * In that lemma, k would be 2*254=508, and m would be the number of points on the * grumpkin curve (which is close to r according to the Hasse bound).\n     *\n     * Our shared secret S is [esk * address_sk] * G, and the question is: * Can we compute hash(S) using poseidon2 instead of sha256?\n     *\n     * Well, esk is random and not generated with poseidon2, so that's good.\n     * What about address_sk?\n     * Well, address_sk = poseidon2(stuff) + ivsk, so there was some\n     * discussion about whether address_sk is independent of poseidon2.\n     * Given that ivsk is random and independent of poseidon2, the address_sk is also\n     * independent of poseidon2.\n     *\n     * Tl;dr: we believe it's safe to hash S = [esk * address_sk] * G using poseidon2,\n     * in order to derive a symmetric key.\n     *\n     * If you're calling this function for a differently-derived `shared_secret`, be\n     * careful.\n     *\n     */\n\n    /* The output of this function needs to be 32 random bytes.\n     * A single field won't give us 32 bytes of entropy.\n     * So we compute two \"random\" fields, by poseidon-hashing with two different\n     * generators.\n     * We then extract the last 16 (big endian) bytes of each \"random\" field.\n     * Note: we use to_be_bytes because it's slightly more efficient. But we have to\n     * be careful not to take bytes from the \"big end\", because the \"big\" byte is\n     * not uniformly random over the byte: it only has < 6 bits of randomness, because\n     * it's the big end of a 254-bit field element.\n     */\n\n    let mut all_bytes: [[u8; 32]; N] = std::mem::zeroed();\n    // We restrict N to be < 2^8, because of how we compute the domain separator\n    // from k below (where k <= N must be 8 bits). In practice, it's extremely\n    // unlikely that an app will want to compute >= 256 ciphertexts.\n    std::static_assert(N < 256, \"N too large\");\n    for k in 0..N {\n        // We augment the domain separator with the loop index, so that we can\n        // generate N lots of randomness.\n        let k_shift = (k as u16 << 8);\n        let separator_1 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY as u16;\n        let separator_2 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY_2 as u16;\n\n        let rand1: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_1);\n        let rand2: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_2);\n\n        let rand1_bytes: [u8; 32] = rand1.to_be_bytes();\n        let rand2_bytes: [u8; 32] = rand2.to_be_bytes();\n\n        let mut bytes: [u8; 32] = [0; 32];\n        for i in 0..16 {\n            // We take bytes from the \"little end\" of the be-bytes arrays:\n            let j = 32 - i - 1;\n            bytes[i] = rand1_bytes[j];\n            bytes[16 + i] = rand2_bytes[j];\n        }\n\n        all_bytes[k] = bytes;\n    }\n\n    all_bytes\n}\n\nfn derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits<let N: u32>(\n    many_random_256_bits: [[u8; 32]; N],\n) -> [([u8; 16], [u8; 16]); N] {\n    // Many (sym_key, iv) pairs:\n    let mut many_pairs: [([u8; 16], [u8; 16]); N] = std::mem::zeroed();\n    for k in 0..N {\n        let random_256_bits = many_random_256_bits[k];\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n        for i in 0..16 {\n            sym_key[i] = random_256_bits[i];\n            iv[i] = random_256_bits[i + 16];\n        }\n        many_pairs[k] = (sym_key, iv);\n    }\n\n    many_pairs\n}\n\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [([u8; 16], [u8; 16]); N] {\n    let many_random_256_bits: [[u8; 32]; N] = extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe(\n        shared_secret,\n    );\n\n    derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits(many_random_256_bits)\n}\n\npub struct AES128 {}\n\nimpl MessageEncryption for AES128 {\n    fn encrypt<let PlaintextLen: u32>(\n        plaintext: [Field; PlaintextLen],\n        recipient: AztecAddress,\n    ) -> [Field; MESSAGE_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the message in `do_process_message`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        // TODO (#17158): Currently we unwrap the Option returned by derive_ecdh_shared_secret_using_aztec_address.\n        // We need to handle the case where the ephemeral public key is invalid to prevent potential DoS vectors.\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient).unwrap();\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        // It is safe to call the `unsafe` function here, because we know the `shared_secret`\n        // was derived using an AztecAddress (the recipient). See the block comment\n        // at the start of this unsafe target function for more info.\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, body_iv, body_sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        std::static_assert(\n            ciphertext_bytes.len() == 16 * (1 + (PlaintextLen * 32) / 16),\n            \"unexpected ciphertext length\",\n        );\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, header_iv, header_sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        std::static_assert(\n            header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES,\n            \"unexpected ciphertext header length\",\n        );\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut message_bytes_padding_to_mult_31 =\n            get_arr_of_size__message_bytes_padding__from_PT::<PlaintextLen * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        message_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut message_bytes = get_arr_of_size__message_bytes__from_PT::<PlaintextLen * 32>();\n\n        std::static_assert(\n            message_bytes.len() % 31 == 0,\n            \"Unexpected error: message_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        message_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            message_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            message_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..message_bytes_padding_to_mult_31.len() {\n            message_bytes[offset + i] = message_bytes_padding_to_mult_31[i];\n        }\n        offset += message_bytes_padding_to_mult_31.len();\n\n        // Ideally we would be able to have a static assert where we check that the offset would be such that we've\n        // written to the entire log_bytes array, but we cannot since Noir does not treat the offset as a comptime\n        // value (despite the values that it goes through being known at each stage). We instead check that the\n        // computation used to obtain the offset computes the expected value (which we _can_ do in a static check), and\n        // then add a cheap runtime check to also validate that the offset matches this.\n        std::static_assert(\n            1\n                + header_ciphertext_bytes.len()\n                + ciphertext_bytes.len()\n                + message_bytes_padding_to_mult_31.len()\n                == message_bytes.len(),\n            \"unexpected message length\",\n        );\n        assert(offset == message_bytes.len(), \"unexpected encrypted message length\");\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make messages produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let message_bytes_as_fields = bytes_to_fields(message_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final message\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; MESSAGE_CIPHERTEXT_LEN] = [0; MESSAGE_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..message_bytes_as_fields.len() {\n            ciphertext[offset + i] = message_bytes_as_fields[i];\n        }\n        offset += message_bytes_as_fields.len();\n\n        for i in offset..MESSAGE_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the message\n            // (all the \"real\" message fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the message to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt(\n        ciphertext: BoundedVec<Field, MESSAGE_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, MESSAGE_PLAINTEXT_LEN> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, MESSAGE_CIPHERTEXT_LEN, MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) != 0;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret\n        // TODO(#17158): handle invalid ephemeral keys when decrypting to prevent DoS vectors\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk.unwrap());\n\n        // Derive symmetric keys:\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with messages with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext =\n            aes128_decrypt_oracle(header_ciphertext_bvec, header_iv, header_sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, body_iv, body_sym_key);\n\n        // Each field of the original note message was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::{\n            encoding::MESSAGE_PLAINTEXT_LEN, encryption::message_encryption::MessageEncryption,\n        },\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{address::AztecAddress, traits::FromField};\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt() {\n        let env = TestEnvironment::new();\n\n        // Message decryption requires oracles that are only available during private execution\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3];\n\n            let recipient = AztecAddress::from_field(\n                0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n            );\n\n            // Mock random values for deterministic test\n            let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(eph_sk).times(1);\n\n            let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(randomness).times(1000000);\n\n            let _ = OracleMock::mock(\"privateGetNextAppTagAsSender\").returns(42);\n\n            // Encrypt the message\n            let encrypted_message = BoundedVec::from_array(AES128::encrypt(plaintext, recipient));\n\n            // Mock shared secret for deterministic test\n            let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n                EmbeddedCurveScalar::from_field(eph_sk),\n                recipient,\n            );\n\n            let _ = OracleMock::mock(\"utilityGetSharedSecret\").returns(shared_secret.unwrap());\n\n            // Decrypt the message\n            let decrypted = AES128::decrypt(encrypted_message, recipient);\n\n            // The decryption function spits out a BoundedVec because it's designed to work with messages with unknown length\n            // at compile time. For this reason we need to convert the original input to a BoundedVec.\n            let plaintext_bvec = BoundedVec::<Field, MESSAGE_PLAINTEXT_LEN>::from_array(plaintext);\n\n            // Verify decryption matches original plaintext\n            assert_eq(\n                decrypted,\n                plaintext_bvec,\n                \"Decrypted bytes should match original plaintext\",\n            );\n\n            // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n            // static methods of the struct).\n            let _ = AES128 {};\n        });\n    }\n}\n"
    },
    "137": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/processing/mod.nr",
      "source": "pub(crate) mod event_validation_request;\npub mod message_context;\npub(crate) mod note_validation_request;\npub(crate) mod log_retrieval_request;\npub(crate) mod log_retrieval_response;\npub(crate) mod pending_tagged_log;\n\nuse crate::{\n    capsules::CapsuleArray,\n    event::event_selector::EventSelector,\n    messages::{\n        discovery::{\n            partial_notes::DeliveredPendingPartialNote, private_events::MAX_EVENT_SERIALIZED_LEN,\n            private_notes::MAX_NOTE_PACKED_LEN,\n        },\n        processing::{\n            log_retrieval_request::LogRetrievalRequest,\n            log_retrieval_response::LogRetrievalResponse,\n            note_validation_request::NoteValidationRequest, pending_tagged_log::PendingTaggedLog,\n        },\n    },\n    oracle,\n};\nuse event_validation_request::EventValidationRequest;\nuse protocol_types::{address::AztecAddress, hash::sha256_to_field};\n\n// Base slot for the pending tagged log array to which the fetch_tagged_logs oracle inserts found private logs.\nglobal PENDING_TAGGED_LOG_ARRAY_BASE_SLOT: Field =\n    sha256_to_field(\"AZTEC_NR::PENDING_TAGGED_LOG_ARRAY_BASE_SLOT\".as_bytes());\n\nglobal NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\n/// Searches for private logs emitted by `contract_address` that might contain messages for one of the local accounts,\n/// and stores them in a `CapsuleArray` which is then returned.\npub(crate) unconstrained fn get_private_logs(\n    contract_address: AztecAddress,\n) -> CapsuleArray<PendingTaggedLog> {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `fetchTaggedLogs`\n    // oracle. This makes PXE synchronize tags, download logs and store the pending tagged logs in a capsule array.\n    oracle::message_processing::fetch_tagged_logs(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    CapsuleArray::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT)\n}\n\n/// Enqueues a note for validation by PXE, so that it becomes aware of a note's existence allowing for later retrieval\n/// via `get_notes` oracle. The note will be scoped to `contract_address`, meaning other contracts will not be able to\n/// access it unless authorized.\n///\n/// In order for the note validation and insertion to occur, `validate_enqueued_notes_and_events` must be later called.\n/// For optimal performance, accumulate as many note validation requests as possible and then validate them all at the\n/// end (which results in PXE minimizing the number of network round-trips).\n///\n/// The `packed_note` is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\npub(crate) unconstrained fn enqueue_note_for_validation(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `NoteValidationRequest`\n    CapsuleArray::at(contract_address, NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        NoteValidationRequest {\n            contract_address,\n            storage_slot,\n            note_nonce,\n            packed_note,\n            note_hash,\n            nullifier,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Enqueues an event for validation by PXE, so that it can be efficiently validated and then inserted into the event\n/// store.\n///\n/// In order for the event validation and insertion to occur, `validate_enqueued_notes_and_events` must be later\n/// called. For optimal performance, accumulate as many event validation requests as possible and then validate them\n/// all at the end (which results in PXE minimizing the number of network round-trips).\npub(crate) unconstrained fn enqueue_event_for_validation(\n    contract_address: AztecAddress,\n    event_type_id: EventSelector,\n    serialized_event: BoundedVec<Field, MAX_EVENT_SERIALIZED_LEN>,\n    event_commitment: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `EventValidationRequest`\n    CapsuleArray::at(contract_address, EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        EventValidationRequest {\n            contract_address,\n            event_type_id,\n            serialized_event,\n            event_commitment,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Validates all note and event validation requests enqueued via `enqueue_note_for_validation` and\n/// `enqueue_event_for_validation`, inserting them into the note database and event store respectively, making them\n/// queryable via `get_notes` oracle and our TS API (PXE::getPrivateEvents).\n///\n/// This automatically clears both validation request queues, so no further work needs to be done by the caller.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(contract_address: AztecAddress) {\n    oracle::message_processing::validate_enqueued_notes_and_events(\n        contract_address,\n        NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n        EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n    );\n}\n\n/// Efficiently queries the node for logs that result in the completion of all `DeliveredPendingPartialNote`s stored in\n/// a `CapsuleArray` by performing all node communication concurrently. Returns a second `CapsuleArray` with Options for\n/// the responses that correspond to the pending partial notes at the same index.\n///\n/// For example, given an array with pending partial notes `[ p1, p2, p3 ]`, where `p1` and `p3` have corresponding\n/// completion logs but `p2` does not, the returned `CapsuleArray` will have contents\n/// `[some(p1_log), none(), some(p3_log)]`.\npub(crate) unconstrained fn get_pending_partial_notes_completion_logs(\n    contract_address: AztecAddress,\n    pending_partial_notes: CapsuleArray<DeliveredPendingPartialNote>,\n) -> CapsuleArray<Option<LogRetrievalResponse>> {\n    let log_retrieval_requests =\n        CapsuleArray::at(contract_address, LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT);\n\n    // We create a LogRetrievalRequest for each PendingPartialNote in the CapsuleArray. Because we need the indices in\n    // the request array to match the indices in the partial note array, we can't use CapsuleArray::for_each, as that\n    // function has arbitrary iteration order. Instead, we manually iterate the array from the beginning and push into\n    // the requests array, which we expect to be empty.\n    let mut i = 0;\n    let pending_partial_notes_count = pending_partial_notes.len();\n    while i < pending_partial_notes_count {\n        let pending_partial_note = pending_partial_notes.get(i);\n        log_retrieval_requests.push(\n            LogRetrievalRequest {\n                contract_address,\n                unsiloed_tag: pending_partial_note.note_completion_log_tag,\n            },\n        );\n        i += 1;\n    }\n\n    oracle::message_processing::bulk_retrieve_logs(\n        contract_address,\n        LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT,\n        LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT,\n    );\n\n    CapsuleArray::at(contract_address, LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT)\n}\n"
    },
    "149": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::{Deserialize, Packable, Serialize};\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, note_nonce: Field },\n//   Settled{ note_nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Deserialize, Eq, Serialize, Packable)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_note_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_note_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_note_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_note_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_note_nonce }\n            }\n        } else if maybe_note_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_note_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_note_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_note_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.note_nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.note_nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    note_nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    note_nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n"
    },
    "152": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().note_nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullification<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullification_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullification`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullification_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let note_nonce = retrieved_note.metadata.to_pending_previous_phase().note_nonce();\n\n        compute_unique_note_hash(note_nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullification =\n        compute_note_hash_for_nullification(retrieved_note, storage_slot);\n    let inner_nullifier =\n        retrieved_note.note.compute_nullifier(context, note_hash_for_nullification);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "156": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(privateCallPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "157": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize,\n{\n    let serialized_option = load_oracle(contract_address, slot, <T as Deserialize>::N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(utilityStoreCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(utilityLoadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(utilityDeleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(utilityCopyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), value);\n        });\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            let new_value = MockStruct::new(7, 8);\n            store(contract_address, SLOT, new_value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n        });\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n            delete(contract_address, SLOT);\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            delete(contract_address, SLOT);\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 5;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 10;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 1;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 2;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n            assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n            assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 2;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 1;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n            assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n            assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n        });\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            copy(contract_address, SLOT, SLOT, 1);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let value = MockStruct::new(5, 6);\n            store(other_contract_address, SLOT, value);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let _: Option<MockStruct> = load(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            delete(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            copy(other_contract_address, SLOT, SLOT, 0);\n        });\n    }\n}\n"
    },
    "158": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(privateNotifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(privateNotifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(privateNotifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "159": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use crate::context::utility_context::UtilityContext;\n\n#[oracle(utilityGetUtilityContext)]\nunconstrained fn get_utility_context_oracle() -> UtilityContext {}\n\n/// Returns a utility context built from the global variables of anchor block and the contract address of the function\n/// being executed.\npub unconstrained fn get_utility_context() -> UtilityContext {\n    get_utility_context_oracle()\n}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars, true)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n    predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        let mut result = if double_predicate {\n            // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n            embedded_curve_add_unsafe(point1, point1)\n        } else {\n            let point1_1 = EmbeddedCurvePoint {\n                x: point1.x + (x_coordinates_match as Field),\n                y: point1.y,\n                is_infinite: false,\n            };\n            let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n            // point1_1 is guaranteed to have a different abscissa than point2:\n            // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n            // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n            // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n            // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n            // therefore we only want to do this if we need the result, otherwise it needs to be eliminated as a dead instruction, lest we want the circuit to fail.\n            embedded_curve_add_unsafe(point1_1, point2_1)\n        };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n    _predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    // Ensure is_infinite is comptime\n    let point1_1 = EmbeddedCurvePoint { x: point1.x, y: point1.y, is_infinite: false };\n    let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n    embedded_curve_add_unsafe(point1_1, point2_1)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2, true)[0]\n}\n"
    },
    "160": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(privateStoreInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(privateLoadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "161": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(utilityGetContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\nstruct GetContractInstanceResult {\n    exists: bool,\n    member: Field,\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n\nunconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_deployer_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_class_id_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_deployer_internal_avm(address)[0] };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_class_id_internal_avm(address)[0] };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address)[0] };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "165": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr",
      "source": "use protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\nuse protocol_types::traits::{Deserialize, Serialize};\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(utilityGetPublicDataWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> PublicDataWitness {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    get_public_data_witness_oracle(block_number, public_data_tree_index)\n}\n"
    },
    "166": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(utilityGetKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "167": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(utilityGetPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] != 0 } },\n        ivpk_m: IvpkM { inner: Point { x: result[3], y: result[4], is_infinite: result[5] != 0 } },\n        ovpk_m: OvpkM { inner: Point { x: result[6], y: result[7], is_infinite: result[8] != 0 } },\n        tpk_m: TpkM { inner: Point { x: result[9], y: result[10], is_infinite: result[11] != 0 } },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "169": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/message_processing.nr",
      "source": "use protocol_types::address::AztecAddress;\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn fetch_tagged_logs(pending_tagged_log_array_base_slot: Field) {\n    fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(utilityFetchTaggedLogs)]\nunconstrained fn fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n// This must be a single oracle and not one for notes and one for events because the entire point is to validate\n// all notes and events in one go, minimizing node round-trips.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {\n    validate_enqueued_notes_and_events_oracle(\n        contract_address,\n        note_validation_requests_array_base_slot,\n        event_validation_requests_array_base_slot,\n    );\n}\n\n#[oracle(utilityValidateEnqueuedNotesAndEvents)]\nunconstrained fn validate_enqueued_notes_and_events_oracle(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {}\n\npub(crate) unconstrained fn bulk_retrieve_logs(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {\n    bulk_retrieve_logs_oracle(\n        contract_address,\n        log_retrieval_requests_array_base_slot,\n        log_retrieval_responses_array_base_slot,\n    );\n}\n\n#[oracle(utilityBulkRetrieveLogs)]\nunconstrained fn bulk_retrieve_logs_oracle(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n\n    #[test]\n    fn check_decompose_edge_cases() {\n        assert_eq(decompose(0), (0, 0));\n        assert_eq(decompose(TWO_POW_128 - 1), (TWO_POW_128 - 1, 0));\n        assert_eq(decompose(TWO_POW_128 + 1), (1, 1));\n        assert_eq(decompose(TWO_POW_128 * 2), (0, 2));\n        assert_eq(decompose(TWO_POW_128 * 2 + 0x1234567890), (0x1234567890, 2));\n    }\n\n    #[test]\n    fn check_decompose_large_values() {\n        let large_field = 0xffffffffffffffff;\n        let (lo, hi) = decompose(large_field);\n        assert_eq(large_field, lo + TWO_POW_128 * hi);\n\n        let large_value = large_field - TWO_POW_128;\n        let (lo2, hi2) = decompose(large_value);\n        assert_eq(large_value, lo2 + TWO_POW_128 * hi2);\n    }\n\n    #[test]\n    fn check_lt_comprehensive() {\n        assert(lt(0, 1));\n        assert(!lt(1, 0));\n        assert(!lt(0, 0));\n        assert(!lt(42, 42));\n\n        assert(lt(TWO_POW_128 - 1, TWO_POW_128));\n        assert(!lt(TWO_POW_128, TWO_POW_128 - 1));\n    }\n}\n"
    },
    "171": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::note::{note_interface::NoteType, retrieved_note::RetrievedNote};\n\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(privateNotifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(privateNotifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(privateNotifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(utilityGetNotes)]\nunconstrained fn get_notes_oracle<Note, let M: u32, let MaxNotes: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; M],\n    _select_by_offsets: [u8; M],\n    _select_by_lengths: [u8; M],\n    _select_values: [Field; M],\n    _select_comparators: [u8; M],\n    _sort_by_indexes: [u8; M],\n    _sort_by_offsets: [u8; M],\n    _sort_by_lengths: [u8; M],\n    _sort_order: [u8; M],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    // This is always set to MAX_NOTES. We need to pass it to TS in order to correctly construct the BoundedVec\n    _max_notes: u32,\n    // This is always set to <RetrievedNote<Note> as Packable>::N. We need to pass it to TS in order to be able to\n    // correctly construct the BoundedVec there.\n    _packed_retrieved_note_length: u32,\n) -> BoundedVec<[Field; <RetrievedNote<Note> as Packable>::N], MaxNotes>\nwhere\n    // TODO(https://github.com/noir-lang/noir/issues/9399): `Note: Packable` should work here.\n    RetrievedNote<Note>: Packable,\n{}\n\npub unconstrained fn get_notes<Note, let M: u32, let MaxNotes: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Option<RetrievedNote<Note>>; MaxNotes]\nwhere\n    Note: NoteType + Packable,\n{\n    let packed_retrieved_notes: BoundedVec<[Field; <RetrievedNote<Note> as Packable>::N], MaxNotes>\n         = get_notes_oracle::<Note, M, MaxNotes>(\n            storage_slot,\n            num_selects,\n            select_by_indexes,\n            select_by_offsets,\n            select_by_lengths,\n            select_values,\n            select_comparators,\n            sort_by_indexes,\n            sort_by_offsets,\n            sort_by_lengths,\n            sort_order,\n            limit,\n            offset,\n            status,\n            MaxNotes,\n            <RetrievedNote<Note> as Packable>::N,\n        );\n\n    let mut notes = BoundedVec::<_, MaxNotes>::new();\n    for i in 0..packed_retrieved_notes.len() {\n        let retrieved_note = RetrievedNote::unpack(packed_retrieved_notes.get(i));\n        notes.push(retrieved_note);\n    }\n\n    // At last we convert the bounded vector to an array of options. We do this because that is what the filter\n    // function needs to have on the output and we've decided to have the same type on the input and output of\n    // the filter and preprocessor functions.\n    //\n    // We have decided to have the same type on the input and output of the filter and preprocessor functions because\n    // it allows us to chain multiple filters and preprocessors together.\n    //\n    // So why do we want the array of options on the output of the filter function?\n    //\n    // Filter returns an array of options rather than a BoundedVec for performance reasons. Using an array of options\n    // allows setting values at known indices in the output array which is much more efficient than pushing to a\n    // BoundedVec where the write position depends on previous iterations. The array can then be efficiently converted\n    // to a BoundedVec using utils/array/collapse.nr::collapse function from Aztec.nr. This avoids expensive dynamic\n    // memory access patterns that would be required when building up a BoundedVec incrementally. For preprocessor\n    // functions we could use BoundedVec return value as there the optimization does not matter since it is applied in\n    // an unconstrained context. We, however, use the same return value type to be able to use the same function as\n    // both a preprocessor and a filter.\n    let mut notes_array = [Option::none(); MaxNotes];\n    for i in 0..notes.len() {\n        if i < notes.len() {\n            notes_array[i] = Option::some(notes.get_unchecked(i));\n        }\n    }\n\n    notes_array\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(utilityCheckNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n// TODO: Oracles below are generic private log oracles and are not specific to notes. Move them somewhere else.\n\n/// Returns the next app tag for a given sender and recipient pair.\n///\n/// This also notifies the simulator that a tag has been used in a note, and to therefore increment the\n/// associated index so that future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub unconstrained fn get_next_app_tag_as_sender(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> Field {\n    get_next_app_tag_as_sender_oracle(sender, recipient)\n}\n\n#[oracle(privateGetNextAppTagAsSender)]\nunconstrained fn get_next_app_tag_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> Field {}\n\n/// Gets the sender for tags.\n///\n/// This unconstrained value is used as the sender when computing an unconstrained shared secret\n/// for a tag in order to emit a log. Constrained tagging should not use this as there is no\n/// guarantee that the recipient knows about the sender, and hence about the shared secret.\n///\n/// The value persists through nested calls, meaning all calls down the stack will use the same\n/// 'senderForTags' value (unless it is replaced).\npub unconstrained fn get_sender_for_tags() -> Option<AztecAddress> {\n    get_sender_for_tags_oracle()\n}\n\n#[oracle(privateGetSenderForTags)]\nunconstrained fn get_sender_for_tags_oracle() -> Option<AztecAddress> {}\n\n/// Sets the sender for tags.\n///\n/// This unconstrained value is used as the sender when computing an unconstrained shared secret\n/// for a tag in order to emit a log. Constrained tagging should not use this as there is no\n/// guarantee that the recipient knows about the sender, and hence about the shared secret.\n///\n/// Account contracts typically set this value before calling other contracts. The value persists\n/// through nested calls, meaning all calls down the stack will use the same 'senderForTags'\n/// value (unless it is replaced by another call to this setter).\npub unconstrained fn set_sender_for_tags(sender_for_tags: AztecAddress) {\n    set_sender_for_tags_oracle(sender_for_tags);\n}\n\n#[oracle(privateSetSenderForTags)]\nunconstrained fn set_sender_for_tags_oracle(_sender_for_tags: AztecAddress) {}\n"
    },
    "174": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(utilityGetSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "175": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(utilityStorageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: u32,\n    length: u32,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(address.to_field(), storage_slot, block_number, N)\n}\n\npub unconstrained fn storage_read<T>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"utilityStorageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"utilityStorageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"
    },
    "176": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/version.nr",
      "source": "/// The ORACLE_VERSION constant is used to check that the oracle interface is in sync between PXE and Aztec.nr. We need\n/// to version the oracle interface to ensure that developers get a reasonable error message if they use incompatible\n/// versions of Aztec.nr and PXE. The TypeScript counterpart is in `oracle_version.ts`.\n///\n/// @dev Whenever a contract function or Noir test is run, the `utilityAssertCompatibleOracleVersion` oracle is called and\n/// if the oracle version is incompatible an error is thrown.\npub global ORACLE_VERSION: Field = 3;\n\n/// Asserts that the version of the oracle is compatible with the version expected by the contract.\npub fn assert_compatible_oracle_version() {\n    // Safety: This oracle call returns nothing: we only call it to check Aztec.nr and Oracle interface versions are\n    // compatible. It is therefore always safe to call.\n    unsafe {\n        assert_compatible_oracle_version_wrapper();\n    }\n}\n\nunconstrained fn assert_compatible_oracle_version_wrapper() {\n    assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n}\n\n#[oracle(utilityAssertCompatibleOracleVersion)]\nunconstrained fn assert_compatible_oracle_version_oracle(version: Field) {}\n\nmod test {\n    use super::{assert_compatible_oracle_version_oracle, ORACLE_VERSION};\n\n    #[test]\n    unconstrained fn compatible_oracle_version() {\n        assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n    }\n\n    #[test(should_fail_with = \"Incompatible oracle version. TXE is using version '3', but got a request for '318183437'.\")]\n    unconstrained fn incompatible_oracle_version() {\n        let arbitrary_incorrect_version = 318183437;\n        assert_compatible_oracle_version_oracle(arbitrary_incorrect_version);\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n"
    },
    "180": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::HasStorageSlot;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\n\n/// Map\n///\n/// A key-value storage container that maps keys to state variables, similar\n/// to Solidity mappings.\n///\n/// `Map` enables you to associate keys (like addresses or other identifiers)\n/// with state variables in your Aztec smart contract. This is conceptually\n/// similar to Solidity's `mapping(K => V)` syntax, where you can store and\n/// retrieve values by their associated keys.\n///\n/// You can declare a state variable contained within a Map in your contract's\n/// #[storage] struct.\n///\n/// For example, you might use\n/// `Map<AztecAddress, PrivateMutable<ValueNote, Context>, Context>` to track\n/// token balances for different users, similar to how you'd use\n/// `mapping(address => uint256)` in Solidity.\n///\n/// > Aside: the verbose `Context` in the declaration is a consequence of\n/// > leveraging Noir's regular syntax for generics to ensure that certain\n/// > state variable methods can only be called in some contexts (private,\n/// > public, utility).\n///\n/// The methods of Map are:\n/// - `at` (access state variable for a given key)\n/// (see the method's own doc comments for more info).\n///\n/// ## Generic Parameters\n/// - `K`: The key type (must implement `ToField` trait for hashing)\n/// - `V`: The value type:\n///   - any Aztec state variable:\n///     - `PublicMutable`\n///     - `PublicImmutable`\n///     - `PrivateMutable`\n///     - `PrivateImmutable`\n///     - `PrivateSet`\n///     - `DelayedPublicMutable`\n///     - `Map`\n/// - `Context`: The execution context (handles private/public function\n///   contexts)\n///\n/// ## Usage\n/// Maps are typically declared in your contract's #[storage] struct and\n/// accessed\n/// using the `at(key)` method to get the state variable for a specific key.\n/// The resulting state variable can then be read from or written to using its\n/// own methods.\n///\n/// ## Advanced\n/// Internally, `Map` uses a single base storage slot to represent the\n/// mapping\n/// itself, similar to Solidity's approach. Individual key-value pairs are\n/// stored at derived storage slots computed by hashing the base storage\n/// slot\n/// with the key using Poseidon2. This ensures:\n/// - No storage slot collisions between different keys\n/// - Uniform distribution of storage slots across the storage space\n/// - Compatibility with Aztec's storage tree structure\n/// - Gas-efficient storage access patterns similar to Solidity mappings\n///\n/// The storage slot derivation uses `derive_storage_slot_in_map(base_slot,\n/// key)` which computes `poseidon2_hash([base_slot, key.to_field()])`,\n/// ensuring cryptographically secure slot separation.\n///\n/// docs:start:map\npub struct Map<K, V, Context> {\n    pub context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n\n// Map reserves a single storage slot regardless of what it stores because\n// nothing is stored at said slot: it is only used to derive the storage slots\n// of nested state variables, which is expected to never result in collisions\n// or slots being close to one another due to these being hashes. This mirrors\n// the strategy adopted by Solidity mappings.\nimpl<K, T, Context> HasStorageSlot<1> for Map<K, T, Context> {\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    /// Initializes a new Map state variable.\n    ///\n    /// This function is usually automatically called within the #[storage]\n    /// macro.\n    /// You typically don't need to call this directly when writing smart contracts.\n    ///\n    /// # Arguments\n    ///\n    /// * `context` - One of `PrivateContext`/`PublicContext`/`UtilityContext`.\n    ///               The Context determines which methods of this struct will\n    ///               be made available to the calling smart contract function.\n    /// * `storage_slot` - A unique identifier for this Map within the contract.\n    ///                    Usually, the #[storage] macro will determine an\n    ///                    appropriate storage_slot automatically. A smart\n    ///                    contract dev shouldn't have to worry about this, as\n    ///                    it's managed behind the scenes.\n    /// * `state_var_constructor` - A function that creates the value type (V)\n    ///                             given a context and storage slot. This is\n    ///                             typically the constructor of the state\n    ///                             variable type being stored in the Map.\n    ///\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n\n    /// Returns the state variable associated with the given key.\n    ///\n    /// This is equivalent to accessing `mapping[key]` in Solidity. It returns\n    /// the state variable instance for the specified key, which can then be\n    /// used to read or write the value at that key.\n    ///\n    /// Unlike Solidity mappings which return the value directly, this returns\n    /// the state variable wrapper (like PrivateMutable, PublicMutable, etc.)\n    /// that you then call methods on to interact with the actual value.\n    ///\n    /// # Arguments\n    ///\n    /// * `key` - The key to look up in the map. Must implement the ToField\n    ///           trait (which most basic Noir & Aztec types do).\n    ///\n    /// # Returns\n    ///\n    /// * `V` - The state variable instance for this key. You can then call\n    ///         methods like `.read()`, `.write()`, `.get_note()`, etc. on this\n    ///         depending on the specific state variable type.\n    ///\n    /// # Example\n    ///\n    /// ```noir\n    /// // Get a user's balance (assuming PrivateMutable<ValueNote>)\n    /// let user_balance = storage.balances.at(user_address);\n    /// let current_note = user_balance.get_note();\n    ///\n    /// // Update the balance\n    /// user_balance.replace(new_note);\n    /// ```\n    ///\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n}\n"
    },
    "188": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr",
      "source": "use crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::storage::HasStorageSlot,\n    utils::with_hash::WithHash,\n};\nuse protocol_types::{\n    constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator,\n    traits::Packable,\n};\n\n/// # PublicImmutable\n///\n/// PublicImmutable is a public state variable type for values that are set once\n/// during initialization and remain permanently unchanged.\n///\n/// You can declare a state variable of type PublicImmutable within your contract's\n/// #[storage] struct:\n///\n/// E.g.:\n/// `your_variable: PublicImmutable<T, Context>`\n///\n/// PublicImmutable stores an immutable value in public state which can be _read_\n/// from public, utility and even _private_ execution contexts.\n///\n/// The methods of PublicImmutable are:\n/// - `initialize`\n/// - `read`\n/// (see the methods' own doc comments for more info).\n///\n/// # Generic Parameters:\n///\n/// * `T` - The type of value stored (must implement Packable).\n/// * `Context` - The execution context (PublicContext, PrivateContext, or UtilityContext).\n///\n/// # Advanced\n///\n/// PublicImmutable leverages `WithHash<T>` to enable efficient private reads of\n/// public storage. The `WithHash` wrapper optimizes reads by hashing values that would\n/// be larger than a single field into a single field, then proving inclusion of only\n/// the hash in public storage.\n///\n/// This optimization is particularly valuable when T packs to multiple fields,\n/// as it maintains \"almost constant\" verification overhead regardless of the\n/// original data size.\n///\n/// ## Optimizing private reads in your contract\n/// Since reading T from public immutable storage in private contexts has \"almost\n/// constant\" constraint costs regardless of T's size, it's recommended to group\n/// multiple values into a single struct when they are to be read together. This is\n/// typically useful for configuration data set during contract initialization. E.g.:\n///\n/// ```noir\n/// use dep::aztec::protocol_types::{address::AztecAddress, traits::Packable};\n/// use std::meta::derive;\n///\n/// #[derive(Eq, Packable)]\n/// pub struct Config \\{\n///     pub address_1: AztecAddress,\n///     pub value_1: u128,\n///     pub value_2: u64,\n///     ...\n/// }\n/// ```\n///\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\n/// `PublicImmutable` stores both the packed value (using M fields) and its hash (1 field), requiring M + 1 total\n/// fields.\nimpl<T, Context, let M: u32> HasStorageSlot<M + 1> for PublicImmutable<T, Context>\nwhere\n    T: Packable<N = M>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    /// Initializes a new PublicImmutable state variable.\n    ///\n    /// This function is usually automatically called within the #[storage] macro.\n    /// You typically don't need to call this directly when writing smart contracts.\n    ///\n    /// # Arguments\n    ///\n    /// * `context` - One of `PublicContext`/`PrivateContext`/`UtilityContext`. The\n    ///               Context determines which methods of this struct will be made\n    ///               available to the calling smart contract function.\n    /// * `storage_slot` - A unique identifier for this state variable within the\n    ///                    contract. Usually, the #[storage] macro will determine an\n    ///                    appropriate storage_slot automatically. A smart contract\n    ///                    dev shouldn't have to worry about this, as it's managed\n    ///                    behind the scenes.\n    ///\n    /// docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n        )\n    }\n}\n\nimpl<T> PublicImmutable<T, &mut PublicContext> {\n    /// Initializes a PublicImmutable state variable instance with a permanent value.\n    ///\n    /// This function sets the immutable value for this state variable. It can only\n    /// be called once per PublicImmutable. Subsequent calls will fail because the\n    /// initialization nullifier will already exist.\n    ///\n    /// # Arguments\n    /// * `value` - The permanent value to store in this PublicImmutable.\n    ///\n    /// # Panics\n    /// Panics if the value is already initialized.\n    ///\n    /// # Advanced\n    ///\n    /// This function performs the following operations:\n    /// - Creates and emits an initialization nullifier to mark this storage slot\n    ///   as initialized. This prevents double-initialization.\n    /// - Wraps the value in `WithHash<T>` for efficient private reads.\n    /// - Stores the wrapped value in Aztec's public data tree.\n    ///\n    /// docs:start:public_immutable_struct_write\n    pub fn initialize(self, value: T)\n    where\n        T: Packable + Eq,\n    {\n        // We emit an initialization nullifier to indicate that the struct is initialized. This also prevents\n        // the value from being initialized again as a nullifier can be included only once.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        self.context.storage_write(self.storage_slot, WithHash::new(value));\n    }\n\n    /// Reads the permanent value stored in this PublicImmutable state variable.\n    ///\n    /// # Returns\n    /// * `T` - The permanent value stored in this PublicImmutable.\n    ///\n    /// # Panics\n    /// Panics if the value is not initialized.\n    ///\n    /// # Advanced\n    ///\n    /// This function performs the following operations:\n    /// - Checks that the state variable has been initialized by verifying the\n    ///   initialization nullifier exists\n    /// - Reads the `WithHash<T>` wrapper from public storage\n    /// - Extracts and returns the original value T\n    ///\n    /// The function will panic if called on an uninitialized PublicImmutable.\n    ///\n    /// docs:start:public_immutable_struct_read\n    pub fn read(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        assert(self.is_initialized(), \"Trying to read from uninitialized PublicImmutable\");\n        WithHash::public_storage_read(*self.context, self.storage_slot)\n    }\n\n    /// Reads the value stored in this PublicImmutable without checking if the value\n    /// is initialized.\n    ///\n    /// This function bypasses the initialization check and directly reads from\n    /// storage.\n    /// If the PublicImmutable has not been initialized, this will return a\n    /// zeroed value.\n    /// However, if the variable is _known_ to be initialized, this is cheaper\n    /// to call than `read`.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The value stored in this PublicImmutable, or empty/default values if\n    ///         uninitialized.\n    ///\n    pub fn read_unsafe(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        WithHash::public_storage_read(*self.context, self.storage_slot)\n    }\n\n    fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.nullifier_exists(nullifier, self.context.this_address())\n    }\n}\n\nimpl<T> PublicImmutable<T, UtilityContext> {\n    /// Reads the permanent value stored in this PublicImmutable state variable.\n    ///\n    /// Notice that this function is executable only within a UtilityContext, which\n    /// is an unconstrained environment on the user's local device.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The permanent value stored in this PublicImmutable.\n    ///\n    pub unconstrained fn read(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        // TODO(#15703): this fn should fail if the variable is not initialized\n        WithHash::utility_public_storage_read(self.context, self.storage_slot)\n    }\n}\n\nimpl<T> PublicImmutable<T, &mut PrivateContext> {\n    /// Reads the permanent value stored in this PublicImmutable from the anchor\n    /// block.\n    ///\n    /// Private functions execute asynchronously and offchain. When a user begins\n    /// private execution, their view of the chain 'branches off' from the current\n    /// public state, since public state continues to advance while they execute\n    /// privately. Therefore, private functions read from a historical snapshot of\n    /// public state rather than the current state.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The permanent value stored in this PublicImmutable at the historical\n    ///         block referenced by the private context.\n    ///\n    /// # Advanced\n    ///\n    /// This function performs a historical read using the block header from the private\n    /// context. The `WithHash` optimization is particularly valuable here because it\n    /// reduces the number of required inclusion proofs by proving membership of\n    /// only the hash instead of the full packed value.\n    ///\n    /// The historical read mechanism:\n    /// - Uses an oracle to obtain the value from the anchor block\n    /// - Proves inclusion of the value's hash in the public data tree\n    /// - Proves that the root of this public data tree is correct, relative to the\n    ///   anchor block header.\n    /// - Verifies that the oracle-provided value matches the stored hash\n    ///\n    pub fn read(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        // TODO(#15703): this fn should fail if the variable is not initialized\n        WithHash::historical_public_storage_read(\n            self.context.get_anchor_block_header(),\n            self.context.this_address(),\n            self.storage_slot,\n        )\n    }\n}\n"
    },
    "19": {
      "path": "std/hash/mod.nr",
      "source": "// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"
    },
    "190": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr",
      "source": "use crate::context::{PublicContext, UtilityContext};\nuse crate::state_vars::storage::HasStorageSlot;\nuse dep::protocol_types::traits::Packable;\n\n/// # PublicMutable\n///\n/// PublicMutable is a public state variable type for values that can be read\n/// and written within #[external(\"public\")] functions of your smart contract.\n///\n/// You can declare a state variable of type PublicMutable within your contract's\n/// #[storage] struct:\n///\n/// E.g.:\n/// `your_variable: PublicMutable<T, Context>`\n/// or:\n/// `your_mapping: Map<Field, PublicMutable<T, Context>>`\n///\n/// The methods of PublicMutable are:\n/// - `read`\n/// - `write`\n/// (see the methods' own doc comments for more info).\n///\n/// ## Example.\n///\n/// A voting contract's proposal count can be represented as a PublicMutable<u64>.\n/// The count can be read by anyone to see how many proposals exist, and incremented\n/// when new proposals are submitted.\n///\n/// # Generic Parameters:\n///\n/// * `T` - The type of value stored (must implement Packable).\n/// * `Context` - The execution context (PublicContext or UtilityContext).\n///\n/// # Advanced\n///\n/// Unlike private state variables which use notes, PublicMutable stores values\n/// directly in Aztec's public data tree. This enables direct read and write\n/// access to the current state during public function execution.\n///\n/// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\nimpl<T, Context, let M: u32> HasStorageSlot<M> for PublicMutable<T, Context>\nwhere\n    T: Packable<N = M>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    /// Initializes a new PublicMutable state variable.\n    ///\n    /// This function is usually automatically called within the #[storage] macro.\n    /// You typically don't need to call this directly when writing smart contracts.\n    ///\n    /// # Arguments\n    ///\n    /// * `context` - One of `PublicContext`/`UtilityContext`. The Context determines\n    ///               which methods of this struct will be made available to the calling\n    ///               smart contract function.\n    /// * `storage_slot` - A unique identifier for this state variable within the\n    ///                    contract. Usually, the #[storage] macro will determine an\n    ///                    appropriate storage_slot automatically. A smart contract\n    ///                    dev shouldn't have to worry about this, as it's managed\n    ///                    behind the scenes.\n    ///\n    /// docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n}\n\nimpl<T> PublicMutable<T, &mut PublicContext> {\n    /// Reads the current value stored in this PublicMutable state variable.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The current value stored in this PublicMutable.\n    ///\n    /// docs:start:public_mutable_struct_read\n    pub fn read(self) -> T\n    where\n        T: Packable,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n\n    /// Writes a new value to this PublicMutable state variable.\n    ///\n    /// # Arguments\n    ///\n    /// * `value` - The new value to store in this PublicMutable.\n    ///\n    /// # Advanced\n    ///\n    /// This function updates the value stored in Aztec's public data tree.\n    /// The new value becomes immediately available to subsequent reads within\n    /// the same transaction.\n    ///\n    /// docs:start:public_mutable_struct_write\n    pub fn write(self, value: T)\n    where\n        T: Packable,\n    {\n        self.context.storage_write(self.storage_slot, value);\n    }\n}\n\nimpl<T> PublicMutable<T, UtilityContext> {\n    /// Reads the current value stored in this PublicMutable state variable.\n    ///\n    /// Notice that this function is executable only within a UtilityContext, which\n    /// is an unconstrained environment on the user's local device.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The current value stored in this PublicMutable.\n    ///\n    pub unconstrained fn read(self) -> T\n    where\n        T: Packable,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"
    },
    "210": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends the elements of the second `BoundedVec` to the end of the first one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let ALen: u32, let BLen: u32, let DstLen: u32>(\n    a: BoundedVec<T, ALen>,\n    b: BoundedVec<T, BLen>,\n) -> BoundedVec<T, DstLen> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "213": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DstLen` elements from a source array, starting at `offset`. `DstLen` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SrcLen: u32, let DstLen: u32>(src: [T; SrcLen], offset: u32) -> [T; DstLen] {\n    assert(offset + DstLen <= SrcLen, \"DstLen too large for offset\");\n\n    let mut dst: [T; DstLen] = std::mem::zeroed();\n    for i in 0..DstLen {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DstLen to be 0, so we always get back an empty array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "214": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DstMaxLen` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DstLen` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DstLen` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SrcMaxLen: u32, let DstMaxLen: u32>(\n    bvec: BoundedVec<T, SrcMaxLen>,\n    offset: u32,\n) -> BoundedVec<T, DstMaxLen> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "216": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "217": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "220": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use protocol_types::{point::Point, utils::field::sqrt};\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\n/// Returns a `Point` in the Grumpkin curve given its x coordinate.\n///\n/// Because not all values in the field are valid x coordinates of points in the curve (i.e. there\n/// is no corresponding y value in the field that satisfies the curve equation), it may not be\n/// possible to reconstruct a `Point`. `Option::none()` is returned in such cases.\npub fn point_from_x_coord(x: Field) -> Option<Point> {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    sqrt(rhs).map(|y| Point { x, y, is_infinite: false })\n}\n\n/// Returns a `Point` in the Grumpkin curve given its x coordinate and sign for the y coordinate.\n///\n/// Because not all values in the field are valid x coordinates of points in the curve (i.e. there\n/// is no corresponding y value in the field that satisfies the curve equation), it may not be\n/// possible to reconstruct a `Point`. `Option::none()` is returned in such cases.\n///\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Option<Point> {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n\n    sqrt(rhs).map(|y| {\n        // If there is a square root, we need to ensure it has the correct \"sign\"\n        let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n        let final_y = if y_is_positive == sign { y } else { -y };\n        Point { x, y: final_y, is_infinite: false }\n    })\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord, point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n    use dep::protocol_types::utils::field::pow;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign).unwrap();\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2).unwrap();\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_valid() {\n        // x = 8 is a known quadratic residue - should give a valid point\n        let result = point_from_x_coord(Field::from(8));\n        assert(result.is_some());\n\n        let point = result.unwrap();\n        assert_eq(point.x, Field::from(8));\n        // Check curve equation y^2 = x^3 - 17\n        assert_eq(pow(point.y, 2), pow(point.x, 3) - 17);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_invalid() {\n        // x = 3 is a non-residue for this curve - should give None\n        let x = Field::from(3);\n        let maybe_point = point_from_x_coord(x);\n        assert(maybe_point.is_none());\n    }\n\n}\n"
    },
    "224": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr",
      "source": "use crate::{\n    context::{PublicContext, UtilityContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    abis::block_header::BlockHeader, address::AztecAddress, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `M` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `M`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let M: u32> {\n    value: T,\n    packed: [Field; M],\n    hash: Field,\n}\n\nimpl<T, let M: u32> WithHash<T, M>\nwhere\n    T: Packable<N = M> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn utility_public_storage_read(\n        context: UtilityContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + M as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\n// Note: I don't derive Packable on `WithHash` because `derive_serialize` function does not support setting \"N = M\"\n// as I do here 3 lines below. This could be worked around by placing the \"where\" clause directly on the `WithHash`\n// struct, but Jake mentioned that the syntax is not expected to be supported at least until Noir 1.0.\n// Relevant discussion on Slack:\n// https://aztecprotocol.slack.com/archives/C04QF64EDNV/p1752593876160699?thread_ts=1752589887.955379&cid=C04QF64EDNV\nimpl<T, let M: u32> Packable for WithHash<T, M>\nwhere\n    T: Packable<N = M>,\n{\n    let N: u32 = M + 1;\n\n    fn pack(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n        for i in 0..M {\n            result[i] = self.packed[i];\n        }\n        result[M] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; Self::N]) -> Self {\n        let mut value_packed = [0; M];\n        for i in 0..M {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[M];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::test::OracleMock;\n\n    global STORAGE_SLOT: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let env = TestEnvironment::new();\n\n        env.private_context(|context| {\n            let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n                context.anchor_block_header,\n                context.this_address(),\n                STORAGE_SLOT,\n            );\n\n            assert_eq(result, std::mem::zeroed());\n        });\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        env.public_context(|context| { context.storage_write(STORAGE_SLOT, value_with_hash); });\n\n        env.private_context(|context| {\n            let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n                context.anchor_block_header,\n                context.this_address(),\n                STORAGE_SLOT,\n            );\n            assert_eq(result, value);\n        });\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn bad_hint_uninitialized_value() {\n        let env = TestEnvironment::new();\n\n        env.private_context(|context| {\n            let block_header = context.anchor_block_header;\n            let address = context.this_address();\n\n            // Mock the oracle to return a non-zero hint/packed value\n            let value_packed = MockStruct { a: 1, b: 1 }.pack();\n            let _ = OracleMock::mock(\"utilityStorageRead\")\n                .with_params((\n                    address.to_field(), STORAGE_SLOT, block_header.global_variables.block_number,\n                    value_packed.len(),\n                ))\n                .returns(value_packed)\n                .times(1);\n\n            // This should fail because the hint value is non-zero and the hash is zero (default value of storage)\n            let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n                block_header,\n                address,\n                STORAGE_SLOT,\n            );\n        });\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn bad_hint_initialized_value() {\n        let env = TestEnvironment::new();\n\n        env.public_context(|context| {\n            // Write the value and hash separately so that the hash is wrong\n            let value = MockStruct { a: 5, b: 3 };\n            context.storage_write(STORAGE_SLOT, value);\n\n            let incorrect_hash = 13;\n            let hash_storage_slot = STORAGE_SLOT + (value.pack().len() as Field);\n            context.storage_write(hash_storage_slot, [incorrect_hash]);\n        });\n\n        env.private_context(|context| {\n            let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n                context.anchor_block_header,\n                context.this_address(),\n                STORAGE_SLOT,\n            );\n        });\n    }\n}\n"
    },
    "231": {
      "path": "/home/jpag/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr",
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "25": {
      "path": "std/meta/expr.nr",
      "source": "//! Contains methods on the built-in `Expr` type for quoted, syntactically valid expressions.\n\nuse crate::meta::op::BinaryOp;\nuse crate::meta::op::UnaryOp;\nuse crate::option::Option;\n\nimpl Expr {\n    /// If this expression is an array literal `[elem1, ..., elemN]`, this returns a slice of each element in the array.\n    #[builtin(expr_as_array)]\n    // docs:start:as_array\n    pub comptime fn as_array(self) -> Option<[Expr]> {}\n    // docs:end:as_array\n\n    /// If this expression is an assert, this returns the assert expression and the optional message.\n    #[builtin(expr_as_assert)]\n    // docs:start:as_assert\n    pub comptime fn as_assert(self) -> Option<(Expr, Option<Expr>)> {}\n    // docs:end:as_assert\n\n    /// If this expression is an assert_eq, this returns the left-hand-side and right-hand-side\n    /// expressions, together with the optional message.\n    #[builtin(expr_as_assert_eq)]\n    // docs:start:as_assert_eq\n    pub comptime fn as_assert_eq(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_assert_eq\n\n    /// If this expression is an assignment, this returns a tuple with the left hand side\n    /// and right hand side in order.\n    #[builtin(expr_as_assign)]\n    // docs:start:as_assign\n    pub comptime fn as_assign(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_assign\n\n    /// If this expression is a binary operator operation `<lhs> <op> <rhs>`,\n    /// return the left-hand side, operator, and the right-hand side of the operation.\n    #[builtin(expr_as_binary_op)]\n    // docs:start:as_binary_op\n    pub comptime fn as_binary_op(self) -> Option<(Expr, BinaryOp, Expr)> {}\n    // docs:end:as_binary_op\n\n    /// If this expression is a block `{ stmt1; stmt2; ...; stmtN }`, return\n    /// a slice containing each statement.\n    #[builtin(expr_as_block)]\n    // docs:start:as_block\n    pub comptime fn as_block(self) -> Option<[Expr]> {}\n    // docs:end:as_block\n\n    /// If this expression is a boolean literal, return that literal.\n    #[builtin(expr_as_bool)]\n    // docs:start:as_bool\n    pub comptime fn as_bool(self) -> Option<bool> {}\n    // docs:end:as_bool\n\n    /// If this expression is a cast expression `expr as type`, returns the casted\n    /// expression and the type to cast to.\n    // docs:start:as_cast\n    #[builtin(expr_as_cast)]\n    pub comptime fn as_cast(self) -> Option<(Expr, UnresolvedType)> {}\n    // docs:end:as_cast\n\n    /// If this expression is a `comptime { stmt1; stmt2; ...; stmtN }` block,\n    /// return each statement in the block.\n    #[builtin(expr_as_comptime)]\n    // docs:start:as_comptime\n    pub comptime fn as_comptime(self) -> Option<[Expr]> {}\n    // docs:end:as_comptime\n\n    /// If this expression is a constructor `Type { field1: expr1, ..., fieldN: exprN }`,\n    /// return the type and the fields.\n    #[builtin(expr_as_constructor)]\n    // docs:start:as_constructor\n    pub comptime fn as_constructor(self) -> Option<(UnresolvedType, [(Quoted, Expr)])> {}\n    // docs:end:as_constructor\n\n    /// If this expression is a for statement over a single expression, return the identifier,\n    /// the expression and the for loop body.\n    #[builtin(expr_as_for)]\n    // docs:start:as_for\n    pub comptime fn as_for(self) -> Option<(Quoted, Expr, Expr)> {}\n    // docs:end:as_for\n\n    /// If this expression is a for statement over a range, return the identifier,\n    /// the range start, the range end and the for loop body.\n    #[builtin(expr_as_for_range)]\n    // docs:start:as_for_range\n    pub comptime fn as_for_range(self) -> Option<(Quoted, Expr, Expr, Expr)> {}\n    // docs:end:as_for_range\n\n    /// If this expression is a function call `foo(arg1, ..., argN)`, return\n    /// the function and a slice of each argument.\n    #[builtin(expr_as_function_call)]\n    // docs:start:as_function_call\n    pub comptime fn as_function_call(self) -> Option<(Expr, [Expr])> {}\n    // docs:end:as_function_call\n\n    /// If this expression is an `if condition { then_branch } else { else_branch }`,\n    /// return the condition, then branch, and else branch. If there is no else branch,\n    /// `None` is returned for that branch instead.\n    #[builtin(expr_as_if)]\n    // docs:start:as_if\n    pub comptime fn as_if(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_if\n\n    /// If this expression is an index into an array `array[index]`, return the\n    /// array and the index.\n    #[builtin(expr_as_index)]\n    // docs:start:as_index\n    pub comptime fn as_index(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_index\n\n    /// If this expression is an integer literal, return the integer as a field\n    /// as well as whether the integer is negative (true) or not (false).\n    #[builtin(expr_as_integer)]\n    // docs:start:as_integer\n    pub comptime fn as_integer(self) -> Option<(Field, bool)> {}\n    // docs:end:as_integer\n\n    /// If this expression is a lambda, returns the parameters, return type and body.\n    #[builtin(expr_as_lambda)]\n    // docs:start:as_lambda\n    pub comptime fn as_lambda(\n        self,\n    ) -> Option<([(Expr, Option<UnresolvedType>)], Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_lambda\n\n    /// If this expression is a let statement, returns the let pattern as an `Expr`,\n    /// the optional type annotation, and the assigned expression.\n    #[builtin(expr_as_let)]\n    // docs:start:as_let\n    pub comptime fn as_let(self) -> Option<(Expr, Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_let\n\n    /// If this expression is a member access `foo.bar`, return the struct/tuple\n    /// expression and the field. The field will be represented as a quoted value.\n    #[builtin(expr_as_member_access)]\n    // docs:start:as_member_access\n    pub comptime fn as_member_access(self) -> Option<(Expr, Quoted)> {}\n    // docs:end:as_member_access\n\n    /// If this expression is a method call `foo.bar::<generic1, ..., genericM>(arg1, ..., argN)`, return\n    /// the receiver, method name, a slice of each generic argument, and a slice of each argument.\n    #[builtin(expr_as_method_call)]\n    // docs:start:as_method_call\n    pub comptime fn as_method_call(self) -> Option<(Expr, Quoted, [UnresolvedType], [Expr])> {}\n    // docs:end:as_method_call\n\n    /// If this expression is a repeated element array `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_array)]\n    // docs:start:as_repeated_element_array\n    pub comptime fn as_repeated_element_array(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_array\n\n    /// If this expression is a repeated element slice `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_slice)]\n    // docs:start:as_repeated_element_slice\n    pub comptime fn as_repeated_element_slice(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_slice\n\n    /// If this expression is a slice literal `&[elem1, ..., elemN]`,\n    /// return each element of the slice.\n    #[builtin(expr_as_slice)]\n    // docs:start:as_slice\n    pub comptime fn as_slice(self) -> Option<[Expr]> {}\n    // docs:end:as_slice\n\n    /// If this expression is a tuple `(field1, ..., fieldN)`,\n    /// return each element of the tuple.\n    #[builtin(expr_as_tuple)]\n    // docs:start:as_tuple\n    pub comptime fn as_tuple(self) -> Option<[Expr]> {}\n    // docs:end:as_tuple\n\n    /// If this expression is a unary operation `<op> <rhs>`,\n    /// return the unary operator as well as the right-hand side expression.\n    #[builtin(expr_as_unary_op)]\n    // docs:start:as_unary_op\n    pub comptime fn as_unary_op(self) -> Option<(UnaryOp, Expr)> {}\n    // docs:end:as_unary_op\n\n    /// If this expression is an `unsafe { stmt1; ...; stmtN }` block,\n    /// return each statement inside in a slice.\n    #[builtin(expr_as_unsafe)]\n    // docs:start:as_unsafe\n    pub comptime fn as_unsafe(self) -> Option<[Expr]> {}\n    // docs:end:as_unsafe\n\n    /// Returns `true` if this expression is trailed by a semicolon.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// comptime {\n    ///     let expr1 = quote { 1 + 2 }.as_expr().unwrap();\n    ///     let expr2 = quote { 1 + 2; }.as_expr().unwrap();\n    ///\n    ///     assert(expr1.as_binary_op().is_some());\n    ///     assert(expr2.as_binary_op().is_some());\n    ///\n    ///     assert(!expr1.has_semicolon());\n    ///     assert(expr2.has_semicolon());\n    /// }\n    /// ```\n    #[builtin(expr_has_semicolon)]\n    // docs:start:has_semicolon\n    pub comptime fn has_semicolon(self) -> bool {}\n    // docs:end:has_semicolon\n\n    /// Returns `true` if this expression is `break`.\n    #[builtin(expr_is_break)]\n    // docs:start:is_break\n    pub comptime fn is_break(self) -> bool {}\n    // docs:end:is_break\n\n    /// Returns `true` if this expression is `continue`.\n    #[builtin(expr_is_continue)]\n    // docs:start:is_continue\n    pub comptime fn is_continue(self) -> bool {}\n    // docs:end:is_continue\n\n    /// Applies a mapping function to this expression and to all of its sub-expressions.\n    /// `f` will be applied to each sub-expression first, then applied to the expression itself.\n    ///\n    /// This happens recursively for every expression within `self`.\n    ///\n    /// For example, calling `modify` on `(&[1], &[2, 3])` with an `f` that returns `Option::some`\n    /// for expressions that are integers, doubling them, would return `(&[2], &[4, 6])`.\n    // docs:start:modify\n    pub comptime fn modify<Env>(self, f: fn[Env](Expr) -> Option<Expr>) -> Expr {\n        // docs:end:modify\n        let result = modify_array(self, f);\n        let result = result.or_else(|| modify_assert(self, f));\n        let result = result.or_else(|| modify_assert_eq(self, f));\n        let result = result.or_else(|| modify_assign(self, f));\n        let result = result.or_else(|| modify_binary_op(self, f));\n        let result = result.or_else(|| modify_block(self, f));\n        let result = result.or_else(|| modify_cast(self, f));\n        let result = result.or_else(|| modify_comptime(self, f));\n        let result = result.or_else(|| modify_constructor(self, f));\n        let result = result.or_else(|| modify_if(self, f));\n        let result = result.or_else(|| modify_index(self, f));\n        let result = result.or_else(|| modify_for(self, f));\n        let result = result.or_else(|| modify_for_range(self, f));\n        let result = result.or_else(|| modify_lambda(self, f));\n        let result = result.or_else(|| modify_let(self, f));\n        let result = result.or_else(|| modify_function_call(self, f));\n        let result = result.or_else(|| modify_member_access(self, f));\n        let result = result.or_else(|| modify_method_call(self, f));\n        let result = result.or_else(|| modify_repeated_element_array(self, f));\n        let result = result.or_else(|| modify_repeated_element_slice(self, f));\n        let result = result.or_else(|| modify_slice(self, f));\n        let result = result.or_else(|| modify_tuple(self, f));\n        let result = result.or_else(|| modify_unary_op(self, f));\n        let result = result.or_else(|| modify_unsafe(self, f));\n        if result.is_some() {\n            let result = result.unwrap_unchecked();\n            let modified = f(result);\n            modified.unwrap_or(result)\n        } else {\n            f(self).unwrap_or(self)\n        }\n    }\n\n    /// Returns this expression as a `Quoted` value. It's the same as `quote { $self }`.\n    // docs:start:quoted\n    pub comptime fn quoted(self) -> Quoted {\n        // docs:end:quoted\n        quote { $self }\n    }\n\n    /// Resolves and type-checks this expression and returns the result as a `TypedExpr`.\n    ///\n    /// The `in_function` argument specifies where the expression is resolved:\n    /// - If it's `none`, the expression is resolved in the function where `resolve` was called\n    /// - If it's `some`, the expression is resolved in the given function\n    ///\n    /// If any names used by this expression are not in scope or if there are any type errors,\n    /// this will give compiler errors as if the expression was written directly into\n    /// the current `comptime` function.\n    #[builtin(expr_resolve)]\n    // docs:start:resolve\n    pub comptime fn resolve(self, in_function: Option<FunctionDefinition>) -> TypedExpr {}\n    // docs:end:resolve\n}\n\ncomptime fn modify_array<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_array().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_array(exprs)\n    })\n}\n\ncomptime fn modify_assert<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert().map(|(predicate, msg)| {\n        let predicate = predicate.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert(predicate, msg)\n    })\n}\n\ncomptime fn modify_assert_eq<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert_eq().map(|(lhs, rhs, msg)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert_eq(lhs, rhs, msg)\n    })\n}\n\ncomptime fn modify_assign<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assign().map(|expr| {\n        let (lhs, rhs) = expr;\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_assign(lhs, rhs)\n    })\n}\n\ncomptime fn modify_binary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_binary_op().map(|(lhs, op, rhs)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_binary_op(lhs, op, rhs)\n    })\n}\n\ncomptime fn modify_block<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_block().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_block(exprs)\n    })\n}\n\ncomptime fn modify_cast<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_cast().map(|(expr, typ)| {\n        let expr = expr.modify(f);\n        new_cast(expr, typ)\n    })\n}\n\ncomptime fn modify_comptime<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_comptime().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_comptime(exprs)\n    })\n}\n\ncomptime fn modify_constructor<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_constructor().map(|(typ, fields)| {\n        let fields = fields.map(|(name, value)| (name, value.modify(f)));\n        new_constructor(typ, fields)\n    })\n}\n\ncomptime fn modify_function_call<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_function_call().map(|(function, arguments)| {\n        let function = function.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_function_call(function, arguments)\n    })\n}\n\ncomptime fn modify_if<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_if().map(|(condition, consequence, alternative)| {\n        let condition = condition.modify(f);\n        let consequence = consequence.modify(f);\n        let alternative = alternative.map(|alternative| alternative.modify(f));\n        new_if(condition, consequence, alternative)\n    })\n}\n\ncomptime fn modify_index<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_index().map(|(object, index)| {\n        let object = object.modify(f);\n        let index = index.modify(f);\n        new_index(object, index)\n    })\n}\n\ncomptime fn modify_for<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for().map(|(identifier, array, body)| {\n        let array = array.modify(f);\n        let body = body.modify(f);\n        new_for(identifier, array, body)\n    })\n}\n\ncomptime fn modify_for_range<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for_range().map(|(identifier, from, to, body)| {\n        let from = from.modify(f);\n        let to = to.modify(f);\n        let body = body.modify(f);\n        new_for_range(identifier, from, to, body)\n    })\n}\n\ncomptime fn modify_lambda<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_lambda().map(|(params, return_type, body)| {\n        let params = params.map(|(name, typ)| (name.modify(f), typ));\n        let body = body.modify(f);\n        new_lambda(params, return_type, body)\n    })\n}\n\ncomptime fn modify_let<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_let().map(|(pattern, typ, expr)| {\n        let pattern = pattern.modify(f);\n        let expr = expr.modify(f);\n        new_let(pattern, typ, expr)\n    })\n}\n\ncomptime fn modify_member_access<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_member_access().map(|(object, name)| {\n        let object = object.modify(f);\n        new_member_access(object, name)\n    })\n}\n\ncomptime fn modify_method_call<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_method_call().map(|(object, name, generics, arguments)| {\n        let object = object.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_method_call(object, name, generics, arguments)\n    })\n}\n\ncomptime fn modify_repeated_element_array<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_array().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_array(expr, length)\n    })\n}\n\ncomptime fn modify_repeated_element_slice<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_slice().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_slice(expr, length)\n    })\n}\n\ncomptime fn modify_slice<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_slice().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_slice(exprs)\n    })\n}\n\ncomptime fn modify_tuple<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_tuple().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_tuple(exprs)\n    })\n}\n\ncomptime fn modify_unary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unary_op().map(|(op, rhs)| {\n        let rhs = rhs.modify(f);\n        new_unary_op(op, rhs)\n    })\n}\n\ncomptime fn modify_unsafe<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unsafe().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_unsafe(exprs)\n    })\n}\n\ncomptime fn modify_expressions<Env>(exprs: [Expr], f: fn[Env](Expr) -> Option<Expr>) -> [Expr] {\n    exprs.map(|expr| expr.modify(f))\n}\n\ncomptime fn new_array(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { [$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_assert(predicate: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert($predicate, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert($predicate) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assert_eq(lhs: Expr, rhs: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert_eq($lhs, $rhs, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert_eq($lhs, $rhs) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assign(lhs: Expr, rhs: Expr) -> Expr {\n    quote { $lhs = $rhs }.as_expr().unwrap()\n}\n\ncomptime fn new_binary_op(lhs: Expr, op: BinaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { ($lhs) $op ($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_block(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_cast(expr: Expr, typ: UnresolvedType) -> Expr {\n    quote { ($expr) as $typ }.as_expr().unwrap()\n}\n\ncomptime fn new_comptime(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { comptime { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_constructor(typ: UnresolvedType, fields: [(Quoted, Expr)]) -> Expr {\n    let fields = fields.map(|(name, value)| quote { $name: $value }).join(quote { , });\n    quote { $typ { $fields }}.as_expr().unwrap()\n}\n\ncomptime fn new_if(condition: Expr, consequence: Expr, alternative: Option<Expr>) -> Expr {\n    if alternative.is_some() {\n        let alternative = alternative.unwrap();\n        quote { if $condition { $consequence } else { $alternative }}.as_expr().unwrap()\n    } else {\n        quote { if $condition { $consequence } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_for(identifier: Quoted, array: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $array { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_for_range(identifier: Quoted, from: Expr, to: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $from .. $to { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_index(object: Expr, index: Expr) -> Expr {\n    quote { $object[$index] }.as_expr().unwrap()\n}\n\ncomptime fn new_lambda(\n    params: [(Expr, Option<UnresolvedType>)],\n    return_type: Option<UnresolvedType>,\n    body: Expr,\n) -> Expr {\n    let params = params\n        .map(|(name, typ)| {\n            if typ.is_some() {\n                let typ = typ.unwrap();\n                quote { $name: $typ }\n            } else {\n                quote { $name }\n            }\n        })\n        .join(quote { , });\n\n    if return_type.is_some() {\n        let return_type = return_type.unwrap();\n        quote { |$params| -> $return_type { $body } }.as_expr().unwrap()\n    } else {\n        quote { |$params| { $body } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_let(pattern: Expr, typ: Option<UnresolvedType>, expr: Expr) -> Expr {\n    if typ.is_some() {\n        let typ = typ.unwrap();\n        quote { let $pattern : $typ = $expr; }.as_expr().unwrap()\n    } else {\n        quote { let $pattern = $expr; }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_member_access(object: Expr, name: Quoted) -> Expr {\n    quote { $object.$name }.as_expr().unwrap()\n}\n\ncomptime fn new_function_call(function: Expr, arguments: [Expr]) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    quote { $function($arguments) }.as_expr().unwrap()\n}\n\ncomptime fn new_method_call(\n    object: Expr,\n    name: Quoted,\n    generics: [UnresolvedType],\n    arguments: [Expr],\n) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    if generics.len() == 0 {\n        quote { $object.$name($arguments) }.as_expr().unwrap()\n    } else {\n        let generics = generics.map(|generic| quote { $generic }).join(quote { , });\n        quote { $object.$name::<$generics>($arguments) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_repeated_element_array(expr: Expr, length: Expr) -> Expr {\n    quote { [$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_repeated_element_slice(expr: Expr, length: Expr) -> Expr {\n    quote { &[$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_slice(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { &[$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_tuple(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { ($exprs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unary_op(op: UnaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { $op($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unsafe(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { \n        // Safety: generated by macro\n        unsafe { $exprs }\n    }\n        .as_expr()\n        .unwrap()\n}\n\ncomptime fn join_expressions(exprs: [Expr], separator: Quoted) -> Quoted {\n    exprs.map(|expr| expr.quoted()).join(separator)\n}\n"
    },
    "253": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\nuse std::meta::derive;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct FunctionSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    pub inner: u32,\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "294": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\nuse std::meta::derive;\n\n// Aztec address\n#[derive(Deserialize, Eq, Packable, Serialize)]\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    /// Returns an address's `AddressPoint`, which can be used to create shared secrets with the owner\n    /// of the address. If the address is invalid (i.e. it is not a properly derived Aztec address), then this\n    /// returns `Option::none()`, and no shared secrets can be created.\n    pub fn to_address_point(self) -> Option<AddressPoint> {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // An invalid AztecAddress is one for which no y coordinate satisfies the curve equation, which we'll\n        // identify by proving that the square root of y_squared does not exist.\n        let mut y_opt = sqrt(y_squared);\n        if y_opt.is_none() {\n            Option::none()\n        } else {\n            let mut y = y_opt.unwrap();\n\n            // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n            // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n            // note: The field modulus is MAX_FIELD_VALUE + 1\n            if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n                y = (MAX_FIELD_VALUE + 1) - y;\n            }\n\n            Option::some(\n                AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } },\n            )\n        }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    // We use the AZTEC_ADDRESS_LENGTH constant to ensure that there is a match between the derived trait\n    // implementation and the constant.\n    let serialized: [Field; AZTEC_ADDRESS_LENGTH] = address.serialize();\n    let deserialized = AztecAddress::deserialize(serialized);\n    assert_eq(address, deserialized);\n}\n\n#[test]\nfn to_address_point_valid() {\n    // x = 8 where x^3 - 17 = 512 - 17 = 495, which is a residue in this field\n    let address = AztecAddress { inner: 8 };\n    let maybe_point = address.to_address_point();\n    assert(maybe_point.is_some());\n\n    let point = maybe_point.unwrap().inner;\n    // check that x is preserved\n    assert_eq(point.x, Field::from(8));\n\n    // check that the curve equation holds: y^2 == x^3 - 17\n    assert_eq(pow(point.y, 2), pow(point.x, 3) - 17);\n}\n\n#[test]\nunconstrained fn to_address_point_invalid() {\n    // x = 3 where x^3 - 17 = 27 - 17 = 10, which is a non-residue in this field\n    let address = AztecAddress { inner: 3 }; //\n    let maybe_point = address.to_address_point();\n    assert(maybe_point.is_none());\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n"
    },
    "307": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr",
      "source": "use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Deserialize, Empty, Hash, Serialize},\n};\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: Field,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl LeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: Field) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"
    },
    "309": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "// TODO: Expose other wrapped functions than debug (info, warn)\n// ['silent', 'fatal', 'error', 'warn', 'info', 'verbose', 'debug', 'trace']\n\npub global SILENT_LOG_LEVEL: u8 = 0;\npub global FATAL_LOG_LEVEL: u8 = 1;\npub global ERROR_LOG_LEVEL: u8 = 2;\npub global WARN_LOG_LEVEL: u8 = 3;\npub global INFO_LOG_LEVEL: u8 = 4;\npub global VERBOSE_LOG_LEVEL: u8 = 5;\npub global DEBUG_LOG_LEVEL: u8 = 6;\npub global TRACE_LOG_LEVEL: u8 = 7;\n\n/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Same as debug_log, but allows to customize the log level.\n/// Consider changing just to 'log'\npub fn debug_log_with_level<let N: u32>(log_level: u8, msg: str<N>) {\n    debug_log_format_with_level(log_level, msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_array_oracle_wrapper(DEBUG_LOG_LEVEL, msg, args) };\n}\n\n/// Same as debug_log_format, but allows to customize the log level.\n/// Consider changing just to 'log_format'\npub fn debug_log_format_with_level<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field; N],\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_array_oracle_wrapper(log_level, msg, args) };\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` slice.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole slice: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format_slice<let M: u32>(log_level: u8, msg: str<M>, args: [Field]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_slice_oracle_wrapper(log_level, msg, args) };\n}\n\n// We provide two versions of the debug log oracle: one that takes args as a slice and another one that takes args as an array.\n// We do this since conversion from array to slice generates overhead in public functions, since opcodes need to be emitted for the conversion.\n// By exposing the two flavors, we avoid conversions since the AVM is able to handle both arrays an slices in this oracle.\n\nunconstrained fn debug_log_slice_oracle_wrapper<let M: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field],\n) {\n    debug_log_slice_oracle(log_level, msg, args);\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_slice_oracle<let M: u32>(log_level: u8, msg: str<M>, args: [Field]) {}\n\nunconstrained fn debug_log_array_oracle_wrapper<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_array_oracle(log_level, msg, N, args);\n}\n\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_array_oracle<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    length: u32,\n    args: [Field; N],\n) {}\n"
    },
    "319": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "mod poseidon2_chunks;\n\nuse crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_log::{PrivateLog, PrivateLogData},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root_from_sibling_path,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    poseidon2::Poseidon2Sponge,\n    side_effect::{Counted, Scoped},\n    traits::{FromField, Hash, ToField},\n    utils::field::{field_from_bytes, field_from_bytes_32_trunc},\n};\n\npub use poseidon2_chunks::poseidon2_absorb_in_chunks_existing_sponge;\nuse poseidon2_chunks::poseidon2_absorb_in_chunks;\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(note_nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [note_nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_nonce_and_unique_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    let note_nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n    compute_unique_note_hash(note_nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        compute_nonce_and_unique_note_hash(siloed_note_hash, first_nullifier, note_index_in_tx)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: Scoped<Counted<NoteHash>>) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.innermost())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: Scoped<Counted<Nullifier>>) -> Field {\n    let value = nullifier.innermost().value;\n    // Q: shouldn't we be checking whether the _whole_ nullifier is empty?\n    // A: We don't have to. The init and inner circuits add contract address to non-empty nullifiers.\n    // So we know we should silo it if the contract address is not empty.\n    if nullifier.contract_address.is_zero() {\n        value // Return `value` instead of 0 because an already-siloed nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, value)\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<Counted<PrivateLogData>>) -> PrivateLog {\n    let log = private_log.innermost().log;\n    if private_log.contract_address.is_zero() {\n        log\n    } else {\n        let mut fields = log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, log.length)\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn compute_app_secret_key(\n    master_secret_key: EmbeddedCurveScalar,\n    app_address: AztecAddress,\n    app_secret_generator: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [master_secret_key.hi, master_secret_key.lo, app_address.to_field()],\n        app_secret_generator,\n    )\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let contract_address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    let recipient_bytes: [u8; 20] = recipient.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let rollup_version_id_bytes: [u8; 32] = rollup_version_id.to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n\n    let mut bytes: [u8; 148] = std::mem::zeroed();\n    for i in 0..32 {\n        bytes[i] = contract_address_bytes[i];\n        bytes[i + 32] = rollup_version_id_bytes[i];\n        // 64 - 84 are for recipient.\n        bytes[i + 84] = chain_id_bytes[i];\n        bytes[i + 116] = content_bytes[i];\n    }\n\n    for i in 0..20 {\n        bytes[64 + i] = recipient_bytes[i];\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: Scoped<L2ToL1Message>,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.inner.recipient,\n            msg.inner.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n/// Computes sha256 hash of 2 input fields.\n///\n/// @returns A truncated field (i.e., the first byte is always 0).\npub fn accumulate_sha256(v0: Field, v1: Field) -> Field {\n    // Concatenate two fields into 32 x 2 = 64 bytes\n    let v0_as_bytes: [u8; 32] = v0.to_be_bytes();\n    let v1_as_bytes: [u8; 32] = v1.to_be_bytes();\n    let hash_input_flattened = v0_as_bytes.concat(v1_as_bytes);\n\n    sha256_to_field(hash_input_flattened)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = [separator.to_field()].concat(inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n/// Computes a Poseidon2 hash over a dynamic-length subarray of the given input.\n/// Only the first `in_len` fields of `input` are absorbed; any remaining fields are ignored.\n/// The caller is responsible for ensuring that the input is padded with zeros if required.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_in_chunks(input, in_len);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_in_chunks(input, in_len);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n// This function is  unconstrained because it is intended to be used in unconstrained context only as\n// in constrained contexts it would be too inefficient.\npub unconstrained fn poseidon2_hash_with_separator_bounded_vec<let N: u32, T>(\n    inputs: BoundedVec<Field, N>,\n    separator: T,\n) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs.get(i));\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0x3b18c58c739716e76429634a61375c45b3b5cd470c22ab6d3e14cee23dd992);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0xaab2a5828156782b12a1dc6f336e2bc627eb1b9514b02d511f66296990c050);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        L2ToL1Message { recipient: EthAddress::from_field(1), content: 2 }.scope(\n            AztecAddress::from_field(3),\n        ),\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `yarn-project/stdlib/src/hash/hash.test.ts`\n    let hash_from_typescript = 0x0081edf209e087ad31b3fd24263698723d57190bd1d6e9fe056fc0c0a68ee661;\n\n    assert_eq(hash, hash_from_typescript);\n}\n\n#[test]\nunconstrained fn poseidon2_hash_with_separator_bounded_vec_matches_non_bounded_vec_version() {\n    let inputs = BoundedVec::<Field, 4>::from_array([1, 2, 3]);\n    let separator = 42;\n\n    // Hash using bounded vec version\n    let bounded_result = poseidon2_hash_with_separator_bounded_vec(inputs, separator);\n\n    // Hash using regular version\n    let regular_result = poseidon2_hash_with_separator([1, 2, 3], separator);\n\n    // Results should match\n    assert_eq(bounded_result, regular_result);\n}\n"
    },
    "328": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      "source": "use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_tree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n/// These values are precomputed and we run tests to ensure that they are correct.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_tree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_tree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_tree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_tree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_tree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_tree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_tree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_tree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_tree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_tree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_tree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_tree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"
    },
    "332": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use utils::derive_serialization_quotes;\n\npub mod utils;\n\n/// Generates the generic parameter declarations for a struct's trait implementation.\n///\n/// This function takes a struct type definition and generates the generic parameter declarations\n/// that go after the `impl` keyword. For example, given a struct with generics `N: u32` and `T`,\n/// it generates `<let N: u32, T>`.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate generic declarations for\n///\n/// # Returns\n/// A quoted code block containing the generic parameter declarations, or an empty quote if the struct\n/// has no generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// This function generates:\n/// ```\n/// <let N: u32, T>\n/// ```\ncomptime fn get_generics_declarations(s: TypeDefinition) -> Quoted {\n    let generics = s.generics();\n\n    if generics.len() > 0 {\n        let generics_declarations_items = generics\n            .map(|(name, maybe_integer_typ)| {\n                // The second item in the generics tuple is an Option of an integer type that is Some only if\n                // the generic is numeric.\n                if maybe_integer_typ.is_some() {\n                    // The generic is numeric, so we return a quote defined as e.g. \"let N: u32\"\n                    let integer_type = maybe_integer_typ.unwrap();\n                    quote {let $name: $integer_type}\n                } else {\n                    // The generic is not numeric, so we return a quote containing the name of the generic (e.g. \"T\")\n                    quote {$name}\n                }\n            })\n            .join(quote {,});\n        quote {<$generics_declarations_items>}\n    } else {\n        // The struct doesn't have any generics defined, so we just return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates the `where` clause for a trait implementation that constrains non-numeric generic type parameters.\n///\n/// This function takes a struct type definition and a trait name, and generates a `where` clause that\n/// requires all non-numeric generic type parameters to implement the specified trait.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the where clause for\n/// - `trait_name`: The name of the trait that non-numeric generic parameters must implement\n///\n/// # Returns\n/// A quoted code block containing the where clause, or an empty quote if the struct has no non-numeric\n/// generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// And trait name \"Serialize\", this function generates:\n/// ```\n/// where T: Serialize\n/// ```\ncomptime fn get_where_trait_clause(s: TypeDefinition, trait_name: Quoted) -> Quoted {\n    let generics = s.generics();\n\n    // The second item in the generics tuple is an Option of an integer type that is Some only if the generic is\n    // numeric.\n    let non_numeric_generics =\n        generics.filter(|(_, maybe_integer_typ)| maybe_integer_typ.is_none());\n\n    if non_numeric_generics.len() > 0 {\n        let non_numeric_generics_declarations =\n            non_numeric_generics.map(|(name, _)| quote {$name: $trait_name}).join(quote {,});\n        quote {where $non_numeric_generics_declarations}\n    } else {\n        // There are no non-numeric generics, so we return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates a `Serialize` trait implementation for a struct type.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A quoted code block containing the trait implementation\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Log<N> {\n///     fields: [Field; N],\n///     length: u32\n/// }\n/// ```\n///\n/// This function generates code equivalent to:\n/// ```\n/// impl<let N: u32> Serialize for Log<N> {\n///     let N: u32 = <[Field; N] as Serialize>::N + <u32 as Serialize>::N;\n///\n///     #[inline_always]\n///     fn serialize(self) -> [Field; Self::N] {\n///         let mut serialized_params = [0; _];\n///         let mut offset = 0;\n///\n///         let serialized_member = Serialize::serialize(self.fields);\n///         let serialized_member_len = <[Field; N] as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             serialized_params[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         let serialized_member = Serialize::serialize(self.length);\n///         let serialized_member_len = <u32 as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             serialized_params[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         serialized_params\n///     }\n/// }\n/// ```\npub comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n\n    // We care only about the name and type so we drop the last item of the tuple\n    let params = nested_struct.0.fields(nested_struct.1).map(|(name, typ, _)| (name, typ));\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Serialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_serialize_clause = get_where_trait_clause(s, quote {Serialize});\n\n    let (function_body, params_len_quote, serialized_params_name) =\n        derive_serialization_quotes(params, true);\n\n    quote {\n        impl$generics_declarations $crate::traits::Serialize for $typ\n            $where_serialize_clause\n        {\n            let N: u32 = $params_len_quote;\n\n            #[inline_always]\n            fn serialize(self) -> [Field; Self::N] {\n                $function_body\n\n                $serialized_params_name\n            }\n        }\n    }\n}\n\n/// Generates a `Deserialize` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Deserialize` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Deserialize for MyStruct {\n///     let N: u32 = <AztecAddress as Deserialize>::N + <Field as Deserialize>::N;\n///\n///     fn deserialize(serialized: [Field; Self::N]) -> Self {\n///         let mut offset = 0;\n///         let mut member_fields = [0; <AztecAddress as Deserialize>::N];\n///         for i in 0..<AztecAddress as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let x = <AztecAddress as Deserialize>::deserialize(member_fields);\n///         offset += <AztecAddress as Deserialize>::N;\n///\n///         let mut member_fields = [0; <Field as Deserialize>::N];\n///         for i in 0..<Field as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let y = <Field as Deserialize>::deserialize(member_fields);\n///         offset += <Field as Deserialize>::N;\n///\n///         Self { x, y }\n///     }\n/// }\n/// ```\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Deserialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_deserialize_clause = get_where_trait_clause(s, quote {Deserialize});\n\n    // The following will give us <type_of_struct_member_1 as Deserialize>::N + <type_of_struct_member_2 as Deserialize>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Deserialize>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly deserializing the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let function_body = if params.len() > 1 {\n        // This generates deserialization code for each struct member and concatenates them together.\n        let deserialization_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as Deserialize>::N];\n                    for i in 0..<$param_type as Deserialize>::N {\n                        member_fields[i] = serialized[i + offset];\n                    }\n                    let $param_name = <$param_type as Deserialize>::deserialize(member_fields);\n                    offset += <$param_type as Deserialize>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        // This will give us e.g. `a, b, c` for a struct with three fields named `a`, `b`, and `c`.\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n\n            $deserialization_of_struct_members\n\n            Self { $struct_members }\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Deserialize::deserialize(serialized) }\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Deserialize for $typ\n            $where_deserialize_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn deserialize(serialized: [Field; Self::N]) -> Self {\n                $function_body\n            }\n        }\n    }\n}\n\n/// Generates a `Packable` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Packable` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Packable for MyStruct {\n///     let N: u32 = 2;\n///\n///     fn pack(self) -> [Field; 2] {\n///         let mut result: [Field; 2] = [0_Field; 2];\n///         let mut offset: u32 = 0_u32;\n///         let packed_member: [Field; 1] = self.x.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         let packed_member: [Field; 1] = self.y.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         result\n///     }\n///\n///     fn unpack(packed: [Field; 2]) -> Self {\n///         let mut offset: u32 = 0_u32;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<AztecAddress as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let x: AztecAddress = <AztecAddress as Packable>::unpack(member_fields);\n///         offset = offset + <AztecAddress as Packable>::N;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<Field as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let y: Field = <Field as Packable>::unpack(member_fields);\n///         offset = offset + <Field as Packable>::N;\n///         Self { x: x, y: y }\n///     }\n/// }\n/// ```\npub comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Packable` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_packable_clause = get_where_trait_clause(s, quote {Packable});\n\n    // The following will give us <type_of_struct_member_1 as Packable>::N + <type_of_struct_member_2 as Packable>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Packable>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly returning the packed member,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let pack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate packing code that:\n        // 1. Packs each member\n        // 2. Copies the packed fields into the result array at the correct offset\n        // 3. Updates the offset for the next member\n        let packing_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let packed_member = $crate::traits::Packable::pack(self.$param_name);\n                    let packed_member_len = <$param_type as $crate::traits::Packable>::N;\n                    for i in 0..packed_member_len {\n                        result[i + offset] = packed_member[i];\n                    }\n                    offset += packed_member_len;\n                }\n            })\n            .join(quote {});\n\n        quote {\n            let mut result = [0; Self::N];\n            let mut offset = 0;\n\n            $packing_of_struct_members\n\n            result\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            $crate::traits::Packable::pack(self.$param_name)\n        }\n    };\n\n    // For structs containing a single member, we can enhance performance by directly unpacking the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let unpack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate unpacking code that:\n        // 1. Unpacks each member\n        // 2. Copies packed fields into member array at correct offset\n        // 3. Updates offset for next member\n        let unpacking_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as $crate::traits::Packable>::N];\n                    for i in 0..<$param_type as $crate::traits::Packable>::N {\n                        member_fields[i] = packed[i + offset];\n                    }\n                    let $param_name = <$param_type as $crate::traits::Packable>::unpack(member_fields);\n                    offset += <$param_type as $crate::traits::Packable>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n            $unpacking_of_struct_members\n            Self { $struct_members }\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Packable::unpack(packed) }\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Packable for $typ\n            $where_packable_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn pack(self) -> [Field; Self::N] {\n                $pack_function_body\n            }\n\n            #[inline_always]\n            fn unpack(packed: [Field; Self::N]) -> Self {\n                $unpack_function_body\n            }\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Packable, Serialize};\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct Smol {\n        a: Field,\n        b: Field,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct HasArray {\n        a: [Field; 2],\n        b: bool,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct Fancier {\n        a: Smol,\n        b: [Field; 2],\n        c: [u8; 3],\n        d: str<16>,\n    }\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct HasArrayWithGenerics<T, let N: u32> {\n        pub fields: [T; N],\n        pub length: u32,\n    }\n\n    #[test]\n    fn serde_on_smol() {\n        let smol = Smol { a: 1, b: 2 };\n        let serialized = smol.serialize();\n        assert(serialized == [1, 2], serialized);\n        let deserialized = Smol::deserialize(serialized);\n        assert(deserialized == smol);\n\n        // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n        let packed = smol.pack();\n        assert_eq(packed, serialized, \"Packed does not match serialized\");\n    }\n\n    #[test]\n    fn serde_on_has_array() {\n        let has_array = HasArray { a: [1, 2], b: true };\n        let serialized = has_array.serialize();\n        assert(serialized == [1, 2, 1], serialized);\n        let deserialized = HasArray::deserialize(serialized);\n        assert(deserialized == has_array);\n    }\n\n    #[test]\n    fn serde_on_fancier() {\n        let fancier =\n            Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n        let serialized = fancier.serialize();\n        assert(\n            serialized\n                == [\n                    1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                    0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n                ],\n            serialized,\n        );\n        let deserialized = Fancier::deserialize(serialized);\n        assert(deserialized == fancier);\n    }\n\n    #[test]\n    fn serde_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let serialized = struct_with_array_of_generics.serialize();\n        assert(serialized == [1, 2, 3, 3], serialized);\n        let deserialized = HasArrayWithGenerics::deserialize(serialized);\n        assert(deserialized == struct_with_array_of_generics);\n    }\n\n    #[test]\n    fn packable_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let packed = struct_with_array_of_generics.pack();\n        assert(packed == [1, 2, 3, 3], packed);\n\n        let unpacked = HasArrayWithGenerics::unpack(packed);\n        assert(unpacked == struct_with_array_of_generics);\n    }\n\n}\n"
    },
    "333": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/meta/utils.nr",
      "source": "/// Generates serialization code for a list of parameters and the total length of the serialized array\n///\n/// # Parameters\n/// - `params`: A list of (name, type) tuples to serialize\n/// - `use_self_prefix`: If true, parameters are accessed as `self.$param_name` (for struct members).\n///                      If false, parameters are accessed directly as `$param_name` (for function parameters).\n///\n/// # Returns\n/// A tuple containing:\n/// - Quoted code that serializes the parameters into an array named `serialized_params`\n/// - Quoted code that evaluates to the total length of the serialized array\n/// - Quoted code containing the name of the serialized array\npub comptime fn derive_serialization_quotes(\n    params: [(Quoted, Type)],\n    use_self_prefix: bool,\n) -> (Quoted, Quoted, Quoted) {\n    let prefix_quote = if use_self_prefix {\n        quote { self. }\n    } else {\n        quote {}\n    };\n\n    let params_len_quote = get_params_len_quote(params);\n    let serialized_params_name = quote { serialized_params };\n\n    let body = if params.len() == 0 {\n        quote {\n            let $serialized_params_name: [Field; 0] = [];\n        }\n    } else if params.len() == 1 {\n        // When we have only a single parameter on the input, we can enhance performance by directly returning\n        // the serialized member, bypassing the need for loop-based array construction. While this optimization yields\n        // significant benefits in Brillig where the loops are expected to not be optimized, it is not relevant in ACIR\n        // where the loops are expected to be optimized away.\n\n        let param_name = params[0].0;\n        quote {\n            let $serialized_params_name = $crate::traits::Serialize::serialize($prefix_quote$param_name);\n        }\n    } else {\n        // For multiple struct members, generate serialization code that:\n        // 1. Serializes each member\n        // 2. Copies the serialized fields into the serialize array at the correct offset\n        // 3. Updates the offset for the next member\n        let serialization_of_struct_members = params\n            .map(|(param_name, param_type): (Quoted, Type)| {\n                quote {\n                let serialized_member = $crate::traits::Serialize::serialize($prefix_quote$param_name);\n                let serialized_member_len = <$param_type as $crate::traits::Serialize>::N;\n                for i in 0..serialized_member_len {\n                    $serialized_params_name[i + offset] = serialized_member[i];\n                }\n                offset += serialized_member_len;\n            }\n            })\n            .join(quote {});\n\n        quote {\n            let mut $serialized_params_name = [0; $params_len_quote];\n            let mut offset = 0;\n\n            $serialization_of_struct_members\n        }\n    };\n\n    (body, params_len_quote, serialized_params_name)\n}\n\n/// Generates a quoted expression that computes the total serialized length of function parameters.\n///\n/// # Parameters\n/// * `params` - An array of tuples where each tuple contains a quoted parameter name and its Type. The type needs\n///              to implement the Serialize trait.\n///\n/// # Returns\n/// A quoted expression that evaluates to:\n/// * `0` if there are no parameters\n/// * `(<type1 as Serialize>::N + <type2 as Serialize>::N + ...)` for one or more parameters\npub comptime fn get_params_len_quote(params: [(Quoted, Type)]) -> Quoted {\n    if params.len() == 0 {\n        quote { 0 }\n    } else {\n        let params_quote_without_parentheses = params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n                    <$param_type as $crate::traits::Serialize>::N\n                }\n            })\n            .join(quote {+});\n        quote { ($params_quote_without_parentheses) }\n    }\n}\n"
    },
    "334": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl Serialize for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn serialize(self: Self) -> [Field; Self::N] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn deserialize(serialized: [Field; Self::N]) -> Self {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] != 0 }\n    }\n}\n\n// TODO(#11356): use compact representation here.\nimpl Packable for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn pack(self) -> [Field; Self::N] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; Self::N]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "335": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\nuse crate::traits::{Deserialize, Serialize};\nuse std::meta::derive;\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "342": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::{default::Default, meta::derive};\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nmod test {\n    use crate::{\n        point::POINT_LENGTH,\n        public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n        traits::{Deserialize, Serialize},\n    };\n    use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\n    #[test]\n    unconstrained fn compute_public_keys_hash() {\n        let keys = PublicKeys {\n            npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n            ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n            ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n            tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n        };\n\n        let actual = keys.hash();\n        let expected_public_keys_hash =\n            0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n        assert(actual.to_field() == expected_public_keys_hash);\n    }\n\n    #[test]\n    unconstrained fn compute_default_hash() {\n        let keys = PublicKeys::default();\n\n        let actual = keys.hash();\n        let test_data_default_hash =\n            0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n        assert(actual.to_field() == test_data_default_hash);\n    }\n\n    #[test]\n    unconstrained fn serde() {\n        let keys = PublicKeys {\n            npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n            ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n            ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n            tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n        };\n\n        // We use the PUBLIC_KEYS_LENGTH constant to ensure that there is a match between the derived trait\n        let serialized: [Field; POINT_LENGTH * 4] = keys.serialize();\n        let deserialized = PublicKeys::deserialize(serialized);\n\n        assert_eq(keys, deserialized);\n    }\n}\n"
    },
    "347": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "363": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty: Eq {\n    fn empty() -> Self;\n\n    fn is_empty(self) -> bool {\n        self.eq(Self::empty())\n    }\n\n    // Requires this Noir fix: https://github.com/noir-lang/noir/issues/9002\n    // fn assert_not_empty<let U: u32>(self, msg: str<U>) { // This msg version was failing with weird compiler errors.\n    //     // We provide a default impl but it's likely inefficient.\n    //     // The reason we include this function is because there's a lot of\n    //     // opportunity for optimisation on a per-struct basis.\n    //     // You only need to show one element is not empty to know that the whole thing\n    //     // is not empty.\n    //     // If you know an element of your struct which should always be nonempty,\n    //     // you can write an impl that solely checks that that element is nonempty.\n    //     assert(!self.is_empty(), msg);\n    // }\n\n    // This default impl is overwritten by types like arrays, because there's a much\n    // more efficient approach.\n    fn assert_empty<let S: u32>(self, msg: str<S>) {\n        assert(self.is_empty(), msg);\n    }\n}\n\nimpl Empty for Field {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u16 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\n\nimpl<T> Empty for [T]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty()]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\nimpl<A, B> Empty for (A, B)\nwhere\n    A: Empty,\n    B: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        (A::empty(), B::empty())\n    }\n}\n\nimpl<T> Empty for Option<T>\nwhere\n    T: Eq,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\n// pub fn is_empty<T>(item: T) -> bool\n// where\n//     T: Empty,\n// {\n//     item.eq(T::empty())\n// }\n\n// pub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\n// where\n//     T: Empty,\n// {\n//     array.all(|elem| is_empty(elem))\n// }\n\n// pub fn assert_empty<T>(item: T) -> ()\n// where\n//     T: Empty,\n// {\n//     assert(item.eq(T::empty()))\n// }\n\n// pub fn assert_empty_array<T, let N: u32>(array: [T; N]) -> ()\n// where\n//     T: Empty,\n// {\n//     // A cheaper option than `is_empty_array` for if you don't need to gracefully\n//     // handle a bool result.\n//     // Avoids the `&` operator of `is_empty_array`'s `.all()` call.\n//     for i in 0..N {\n//         assert(is_empty(array[i]));\n//     }\n// }\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u16 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value != 0\n    }\n}\nimpl FromField for u1 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u16 {\n    fn from_field(value: Field) -> Self {\n        value as u16\n    }\n}\nimpl FromField for u32 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Associated Constants\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize for str<N> {\n///     let N: u32 = N;\n///\n///     fn serialize(self) -> [Field; Self::N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; Self::N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize {\n    let N: u32;\n\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let M: u32> Serialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; Self::N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n/// Implementation of Deserialize for BoundedVec.\n///\n/// This implementation deserializes a BoundedVec from an array of Fields. The array contains:\n/// 1. The serialized items, each taking up T::N Fields\n/// 2. The length of the BoundedVec as the last Field\n///\n/// # Type Parameters\n/// * `T` - The type of items stored in the BoundedVec, must implement Deserialize\n/// * `M` - The maximum length of the BoundedVec\n///\n/// # Fields Array Layout\n/// [item1_field1, item1_field2, ..., item2_field1, item2_field2, ..., length]\n/// Where:\n/// - itemN_fieldM: The M-th Field of the N-th item (T::N Fields per item)\n/// - length: The number of items in the BoundedVec (1 Field)\n///\n/// Total length N = T::N * M + 1, where:\n/// - T::N is the number of Fields needed to deserialize one item\n/// - M is the maximum length of the BoundedVec\n/// - +1 is for storing the length\n///\n/// # Note\n/// Not deriving this because it's not supported to call derive_deserialize on a \"remote\" struct (and it will never\n/// be supported).\nimpl<T, let M: u32> Deserialize for BoundedVec<T, M>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut new_bounded_vec: BoundedVec<T, M> = BoundedVec::new();\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        let len = fields[<T as Deserialize>::N * M] as u32;\n\n        for i in 0..len {\n            let mut nested_fields = [0; <T as Deserialize>::N];\n            for j in 0..<T as Deserialize>::N {\n                nested_fields[j] = fields[i * <T as Deserialize>::N + j];\n            }\n\n            let item = T::deserialize(nested_fields);\n            new_bounded_vec.push(item);\n        }\n\n        new_bounded_vec\n    }\n}\n\n// This may cause issues if used as program input, because noir disallows empty arrays for program input.\n// I think this is okay because I don't foresee a unit type being used as input. But leaving this comment as a hint\n// if someone does run into this in the future.\nimpl Deserialize for () {\n    let N: u32 = 0;\n\n    fn deserialize(_fields: [Field; Self::N]) -> Self {\n        ()\n    }\n}\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl<T, let M: u32> Serialize for BoundedVec<T, M>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M + 1; // +1 for the length of the BoundedVec\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut fields = [0; Self::N];\n\n        let storage = self.storage();\n\n        for i in 0..M {\n            let serialized_item = storage[i].serialize();\n\n            for j in 0..<T as Serialize>::N {\n                fields[i * <T as Serialize>::N + j] = serialized_item[j];\n            }\n        }\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        fields[<T as Serialize>::N * M] = self.len() as Field;\n\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Associated Constants\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let M: u32> Deserialize for str<M> {\n///     let N: u32 = M;\n///\n///     #[inline_always]\n///     fn deserialize(fields: [Field; Self::N]) -> Self {\n///         str::<Self::N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize {\n    let N: u32;\n\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let M: u32> Deserialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        str::<Self::N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Associated Constants\n/// * `N` - The length of the Field array, known at compile time\n#[derive_via(derive_packable)]\npub trait Packable {\n    let N: u32;\n\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n\n#[test]\nunconstrained fn bounded_vec_serialization() {\n    // Test empty BoundedVec\n    let empty_vec: BoundedVec<Field, 3> = BoundedVec::from_array([]);\n    let serialized = empty_vec.serialize();\n    let deserialized = BoundedVec::<Field, 3>::deserialize(serialized);\n    assert_eq(empty_vec, deserialized);\n    assert_eq(deserialized.len(), 0);\n\n    // Test partially filled BoundedVec\n    let partial_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2]]);\n    let serialized = partial_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(partial_vec, deserialized);\n    assert_eq(deserialized.len(), 1);\n    assert_eq(deserialized.get(0), [1, 2]);\n\n    // Test full BoundedVec\n    let full_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2], [3, 4], [5, 6]]);\n    let serialized = full_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(full_vec, deserialized);\n    assert_eq(deserialized.len(), 3);\n    assert_eq(deserialized.get(0), [1, 2]);\n    assert_eq(deserialized.get(1), [3, 4]);\n    assert_eq(deserialized.get(2), [5, 6]);\n}\n"
    },
    "365": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable for bool {\n    let N: u32 = BOOL_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> bool {\n        (fields[0] as u1) != 0\n    }\n}\n\nimpl Packable for u8 {\n    let N: u32 = U8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable for u16 {\n    let N: u32 = U16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable for u32 {\n    let N: u32 = U32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable for u64 {\n    let N: u32 = U64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable for u128 {\n    let N: u32 = U128_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable for Field {\n    let N: u32 = FIELD_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable for i8 {\n    let N: u32 = I8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Packable for i16 {\n    let N: u32 = I16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Packable for i32 {\n    let N: u32 = I32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Packable for i64 {\n    let N: u32 = I64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Packable for [T; M]\nwhere\n    T: Packable,\n{\n    let N: u32 = M * <T as Packable>::N;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized = self[i].pack();\n            for j in 0..<T as Packable>::N {\n                result[i * <T as Packable>::N + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Packable>::N, M>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "366": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal U1_SERIALIZED_LEN: u32 = 1;\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> bool {\n        fields[0] != 0\n    }\n}\n\nimpl Serialize for u1 {\n    let N: u32 = U1_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u1 {\n    let N: u32 = U1_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u1\n    }\n}\n\nimpl Serialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self]\n    }\n}\n\nimpl Deserialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n}\n\nimpl Deserialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Serialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n}\n\nimpl Deserialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Serialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n}\n\nimpl Deserialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Serialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n}\n\nimpl Deserialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Serialize for [T; M]\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M;\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; _] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized_t = self[i].serialize();\n            let T_N = serialized_t.len();\n            for j in 0..T_N {\n                result[i * T_N + j] = serialized_t[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let M: u32> Deserialize for [T; M]\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Deserialize>::N, M>(Deserialize::deserialize, result)\n    }\n}\n\nimpl<T> Serialize for Option<T>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N + 1;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n\n        result[0] = if self.is_some() { 1 } else { 0 };\n\n        let value_serialized = self.unwrap_unchecked().serialize();\n        for i in 0..<T as Serialize>::N {\n            result[1 + i] = value_serialized[i];\n        }\n\n        result\n    }\n}\n\nimpl<T> Deserialize for Option<T>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        if fields[0] == 1 {\n            let mut value_fields = [0; <T as Deserialize>::N];\n            for i in 0..<T as Deserialize>::N {\n                value_fields[i] = fields[1 + i];\n            }\n\n            Option::some(T::deserialize(value_fields))\n        } else {\n            Option::none()\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Serialize};\n\n    #[test]\n    fn u16_serialization() {\n        let a: u16 = 10;\n        assert_eq(a, u16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i8_serialization() {\n        let a: i8 = -10;\n        assert_eq(a, i8::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i16_serialization() {\n        let a: i16 = -10;\n        assert_eq(a, i16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i32_serialization() {\n        let a: i32 = -10;\n        assert_eq(a, i32::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i64_serialization() {\n        let a: i64 = -10;\n        assert_eq(a, i64::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn option_field_serialization() {\n        let opt_some = Option::some(5);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n\n    #[test]\n    fn array_serialization() {\n        let array = [1, 2, 3, 4];\n\n        let serialized: [Field; 4] = array.serialize();\n        let deserialized: [Field; 4] = Deserialize::deserialize(serialized);\n        assert_eq(deserialized, array);\n    }\n\n    #[test]\n    fn nested_array_serialization() {\n        let nested_array = [[1, 2, 3, 4], [5, 6, 7, 8]];\n\n        let serialized: [Field; 8] = nested_array.serialize();\n        let deserialized: [[Field; 4]; 2] = Deserialize::deserialize(serialized);\n\n        assert_eq(deserialized, nested_array);\n    }\n\n    #[test]\n    fn option_array_serialization() {\n        let opt_some = Option::some([2, 5]);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n}\n"
    },
    "384": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "global KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\npub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO: This currently only exists to aid point compression in compress_to_blob_commitment().\n// Once compression is part of BigCurve it can either be removed or optimized to be used elsewhere.\npub fn byte_to_bits_be(byte: u8) -> [u1; 8] {\n    let mut mut_byte = byte;\n    let mut bits: [u1; 8] = [0; 8];\n    for i in 0..8 {\n        bits[7 - i] = (mut_byte & 1) as u1;\n        mut_byte >>= 1;\n    }\n    bits\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n/// Returns Option::some(sqrt) if there is a square root, and Option::none() if there isn't.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\nunconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n\n#[test]\nunconstrained fn sqrt_valid_test() {\n    let x = 16; // examples: 16, 9, 25, 81\n    let result = sqrt(x);\n    assert(result.is_some());\n    assert_eq(result.unwrap() * result.unwrap(), x);\n}\n\n#[test]\nunconstrained fn sqrt_invalid_test() {\n    let x = KNOWN_NON_RESIDUE; // has no square root in the field\n    let result = sqrt(x);\n    assert(result.is_none());\n}\n"
    },
    "388": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_u64(&mut self) -> u64 {\n        self.read() as u64\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() != 0\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert_eq(self.offset, self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "444": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/uint-note/src/uint_note.nr",
      "source": "use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    history::nullifier_inclusion::ProveNullifierInclusion,\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    messages::logs::note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{\n            GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER,\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT, PRIVATE_LOG_SIZE_IN_FIELDS,\n        },\n        hash::{compute_siloed_nullifier, poseidon2_hash_with_separator},\n        traits::{Deserialize, FromField, Hash, Packable, Serialize, ToField},\n    },\n};\n\n// UintNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the amount).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n/// A private note representing a numeric value associated to an account (e.g. a token balance).\n#[derive(Deserialize, Eq, Serialize, Packable)]\n#[custom_note]\npub struct UintNote {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintPartialNotePrivateContent, and\n    //   b) have the public field at the end\n    // Correct ordering is checked by the tests in this module.\n\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The number stored in the note.\n    value: u128,\n}\n\nimpl NoteHash for UintNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because UintNote has just one variant (where the value is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let private_content =\n            UintPartialNotePrivateContent { owner: self.owner, randomness: self.randomness };\n        let partial_note = PartialUintNote {\n            commitment: private_content.compute_partial_commitment(storage_slot),\n        };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.value)\n    }\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullification: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullification, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(\n        self,\n        note_hash_for_nullification: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullification, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: u128, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness }\n    }\n\n    pub fn get_value(self) -> u128 {\n        self.value\n    }\n\n    pub fn get_owner(self) -> AztecAddress {\n        self.owner\n    }\n\n    /// Creates a partial note that will hide the owner and storage slot but not the value, since the note will be later\n    /// completed in public. This is a powerful technique for scenarios in which the value cannot be known in private\n    /// (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// This function inserts a partial note validity commitment into the nullifier tree to be later on able to verify\n    /// that the partial note and completer are legitimate. See function docs of `compute_validity_commitment` for more\n    /// details.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` so that they can discover the\n    /// note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        completer: AztecAddress,\n    ) -> PartialUintNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = UintPartialNotePrivateContent { owner, randomness }\n            .compute_partial_commitment(storage_slot);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content =\n            UintPartialNotePrivateLogContent { owner, randomness, public_log_tag: commitment };\n\n        let encrypted_log = note::compute_partial_note_private_content_log(\n            private_log_content,\n            storage_slot,\n            recipient,\n        );\n        // Regardless of the original content size, the log is padded with random bytes up to\n        // `PRIVATE_LOG_SIZE_IN_FIELDS` to prevent leaking information about the actual size.\n        let length = encrypted_log.len();\n        context.emit_private_log(encrypted_log, length);\n\n        let partial_note = PartialUintNote { commitment };\n\n        // Now we compute the validity commitment and push it to the nullifier tree. It can be safely pushed to\n        // the nullifier tree since it uses its own separator, making collisions with actual note nullifiers\n        // practically impossible.\n        let validity_commitment = partial_note.compute_validity_commitment(completer);\n        context.push_nullifier(validity_commitment);\n\n        partial_note\n    }\n}\n\n/// The private content of a partial UintNote, i.e. the fields that will remain private. All other note fields will be\n/// made public.\n#[derive(Packable)]\nstruct UintPartialNotePrivateContent {\n    // The ordering of these fields is important given that it must match that of UintNote.\n    // Correct ordering is checked by the tests in this module.\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl UintPartialNotePrivateContent {\n    fn compute_partial_commitment(self, storage_slot: Field) -> Field {\n        // Here we commit to all private values, including the storage slot.\n        poseidon2_hash_with_separator(\n            self.pack().concat([storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\n#[derive(Packable)]\nstruct UintPartialNotePrivateLogContent {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintNote, and\n    //   b) have the public log tag at the beginning\n    // Correct ordering is checked by the tests in this module.\n    public_log_tag: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteType for UintPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        UintNote::get_id()\n    }\n}\n\n/// A partial instance of a UintNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the value field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the value to the public), resulting in a UintNote that can be used like any other one (except\n/// of course that its value is known).\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct PartialUintNote {\n    commitment: Field,\n}\n\nglobal NOTE_COMPLETION_LOG_LENGTH: u32 = 2;\n\nimpl PartialUintNote {\n    /// Completes the partial note, creating a new note that can be used like any other UintNote.\n    pub fn complete(self, context: &mut PublicContext, completer: AztecAddress, value: u128) {\n        // A note with a value of zero is valid, but we cannot currently complete a partial note with such a value\n        // because this will result in the completion log having its last field set to 0. Public logs currently do not\n        // track their length, and so trailing zeros are simply trimmed. This results in the completion log missing its\n        // last field (the value), and note discovery failing.\n        // TODO(#11636): remove this\n        assert(value != 0, \"Cannot complete a PartialUintNote with a value of 0\");\n\n        // We verify that the partial note we're completing is valid (i.e. completer is correct, it uses the correct\n        // state variable's storage slot, and it is internally consistent).\n        let validity_commitment = self.compute_validity_commitment(completer);\n        assert(\n            context.nullifier_exists(validity_commitment, context.this_address()),\n            \"Invalid partial note or completer\",\n        );\n\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the value). The contract will later find it by searching\n        //  for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(value));\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    /// Completes the partial note, creating a new note that can be used like any other UintNote. Same as `complete`\n    /// function but works from private context.\n    pub fn complete_from_private(\n        self,\n        context: &mut PrivateContext,\n        completer: AztecAddress,\n        value: u128,\n    ) {\n        // We verify that the partial note we're completing is valid (i.e. completer is correct, it uses the correct\n        // state variable's storage slot, and it is internally consistent).\n        let validity_commitment = self.compute_validity_commitment(completer);\n        // `prove_nullifier_inclusion` function expects the nullifier to be siloed (hashed with the address of\n        // the contract that emitted the nullifier) as it checks the value directly against the nullifier tree and all\n        // the nullifiers in the tree are siloed by the protocol.\n        let siloed_validity_commitment =\n            compute_siloed_nullifier(context.this_address(), validity_commitment);\n        context.get_anchor_block_header().prove_nullifier_inclusion(siloed_validity_commitment);\n\n        // We need to do two things:\n        //  - emit an unencrypted log containing the public fields (the value) via the private log channel. The\n        //  contract will later find it by searching for the expected tag (which is simply the partial note\n        //  commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_private_log(\n            self.compute_note_completion_log_padded_for_private_log(value),\n            NOTE_COMPLETION_LOG_LENGTH,\n        );\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    /// Computes a validity commitment for this partial note. The commitment cryptographically binds the note's private\n    /// data with the designated completer address. When the note is later completed in public execution, we can load\n    /// this commitment from the nullifier tree and verify that both the partial note (e.g. that the storage slot\n    /// corresponds to the correct owner, and that we're using the correct state variable) and completer are\n    /// legitimate.\n    pub fn compute_validity_commitment(self, completer: AztecAddress) -> Field {\n        poseidon2_hash_with_separator(\n            [self.commitment, completer.to_field()],\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT,\n        )\n    }\n\n    fn compute_note_completion_log(self, value: u128) -> [Field; NOTE_COMPLETION_LOG_LENGTH] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, value.to_field()]\n    }\n\n    fn compute_note_completion_log_padded_for_private_log(\n        self,\n        value: u128,\n    ) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS] {\n        let note_completion_log = self.compute_note_completion_log(value);\n        let padding = [0; PRIVATE_LOG_SIZE_IN_FIELDS - NOTE_COMPLETION_LOG_LENGTH];\n        note_completion_log.concat(padding)\n    }\n\n    fn compute_complete_note_hash(self, value: u128) -> Field {\n        // Here we finalize the note hash by including the (public) value into the partial note commitment. Note that we\n        // use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator(\n            [self.commitment, value.to_field()],\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\nimpl ToField for PartialUintNote {\n    fn to_field(self) -> Field {\n        self.commitment\n    }\n}\n\nimpl FromField for PartialUintNote {\n    fn from_field(field: Field) -> Self {\n        Self { commitment: field }\n    }\n}\n\nmod test {\n    use super::{\n        PartialUintNote, UintNote, UintPartialNotePrivateContent, UintPartialNotePrivateLogContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{address::AztecAddress, traits::{Deserialize, FromField, Packable}},\n        utils::array::subarray,\n    };\n\n    global value: u128 = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a UintNote has the same note hash as a PartialUintNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n\n        let note = UintNote { value, randomness, owner };\n        let note_hash = note.compute_note_hash(storage_slot);\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n\n        let partial_note = PartialUintNote {\n            commitment: partial_note_private_content.compute_partial_commitment(storage_slot),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(value);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular UintNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular UintNote.\n\n        let note = UintNote { value, randomness, owner };\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n        let commitment = partial_note_private_content.compute_partial_commitment(storage_slot);\n\n        let private_log_content =\n            UintPartialNotePrivateLogContent { owner, randomness, public_log_tag: commitment };\n        // The following is a misuse of the `deserialize` function, but this is just a test and it's better than\n        // letting devs manually construct it when they shouldn't be able to.\n        let partial_note = PartialUintNote::deserialize([commitment]);\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(value)[0],\n        );\n\n        // Then we extract all fields except the first of both logs (i.e. the public log tag), and combine them to\n        // produce the note's packed representation. This requires that the members of the intermediate structs are in\n        // the same order as in UintNote.\n        let private_log_without_public_tag: [_; 2] = subarray(private_log_content.pack(), 1);\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(value), 1);\n\n        assert_eq(private_log_without_public_tag.concat(public_log_without_tag), note.pack());\n    }\n}\n"
    },
    "46": {
      "path": "std/slice.nr",
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice with its index, returning a\n    // new slice containing the mapped elements.\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U] {\n        let mut ret = &[];\n        let mut index = 0;\n        for elem in self {\n            ret = ret.push_back(f(index, elem));\n            index += 1;\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for elem in self {\n            f(elem);\n        }\n    }\n\n    // Apply a function to each element of the slice with its index\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        let mut index = 0;\n        for elem in self {\n            f(index, elem);\n            index += 1;\n        }\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq(&[].map(|x| x + 1), &[]);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq(&[].mapi(|i, x| i * x + 1), &[]);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_each(|_x| assert(false));\n        assert(empty_slice == &[]);\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_eachi(|_i, _x| assert(false));\n        assert(empty_slice == &[]);\n    }\n\n    #[test]\n    fn map_example() {\n        let a = &[1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, &[2, 4, 6]);\n        assert_eq(a, &[1, 2, 3]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = &[1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, &[2, 5, 8]);\n        assert_eq(a, &[1, 2, 3]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_each(|a| { *b_ref = b_ref.push_back(a * 2); });\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { *b_ref = b_ref.push_back(i + a * 2); });\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n    #[test]\n    fn len_empty() {\n        let empty: [Field] = &[];\n        assert_eq(empty.len(), 0);\n    }\n\n    #[test]\n    fn len_single() {\n        assert_eq(&[42].len(), 1);\n    }\n\n    #[test]\n    fn len_multiple() {\n        assert_eq(&[1, 2, 3, 4, 5].len(), 5);\n    }\n\n    #[test]\n    fn push_back_empty() {\n        let empty: [Field] = &[];\n        let result = empty.push_back(42);\n        assert_eq(result.len(), 1);\n        assert_eq(result[0], 42);\n    }\n\n    #[test]\n    fn push_back_non_empty() {\n        let slice = &[1, 2, 3];\n        let result = slice.push_back(4);\n        assert_eq(result.len(), 4);\n        assert_eq(result, &[1, 2, 3, 4]);\n    }\n\n    #[test]\n    fn push_front_empty() {\n        let empty = &[];\n        let result = empty.push_front(42);\n        assert_eq(result.len(), 1);\n        assert_eq(result[0], 42);\n    }\n\n    #[test]\n    fn push_front_non_empty() {\n        let slice = &[1, 2, 3];\n        let result = slice.push_front(0);\n        assert_eq(result.len(), 4);\n        assert_eq(result, &[0, 1, 2, 3]);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds\")]\n    fn pop_back_empty() {\n        let slice: [Field] = &[];\n        let (_, _) = slice.pop_back();\n    }\n\n    #[test]\n    fn pop_back_one() {\n        let slice = &[42];\n        let (result, elem) = slice.pop_back();\n        assert_eq(result.len(), 0);\n        assert_eq(elem, 42);\n    }\n\n    #[test]\n    fn pop_back_multiple() {\n        let slice = &[1, 2, 3];\n        let (result, elem) = slice.pop_back();\n        assert_eq(result.len(), 2);\n        assert_eq(result, &[1, 2]);\n        assert_eq(elem, 3);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds\")]\n    fn pop_front_empty() {\n        let slice: [Field] = &[];\n        let (_, _) = slice.pop_front();\n    }\n\n    #[test]\n    fn pop_front_one() {\n        let slice = &[42];\n        let (elem, result) = slice.pop_front();\n        assert_eq(result.len(), 0);\n        assert_eq(elem, 42);\n    }\n\n    #[test]\n    fn pop_front_multiple() {\n        let slice = &[1, 2, 3];\n        let (elem, result) = slice.pop_front();\n        assert_eq(result.len(), 2);\n        assert_eq(result, &[2, 3]);\n        assert_eq(elem, 1);\n    }\n\n    #[test]\n    fn insert_beginning() {\n        let slice = &[1, 2, 3];\n        let result = slice.insert(0, 0);\n        assert_eq(result.len(), 4);\n        assert_eq(result, &[0, 1, 2, 3]);\n    }\n\n    #[test]\n    fn insert_middle() {\n        let slice = &[1, 2, 3];\n        let result = slice.insert(1, 99);\n        assert_eq(result.len(), 4);\n        assert_eq(result, &[1, 99, 2, 3]);\n    }\n\n    #[test]\n    fn insert_end() {\n        let slice = &[1, 2, 3];\n        let result = slice.insert(3, 4);\n        assert_eq(result.len(), 4);\n        assert_eq(result, &[1, 2, 3, 4]);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds\")]\n    fn insert_end_out_of_bounds() {\n        let slice = &[1, 2];\n        let _ = slice.insert(3, 4);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds\")]\n    fn remove_empty() {\n        let slice: [Field] = &[];\n        let (_, _) = slice.remove(0);\n    }\n\n    #[test]\n    fn remove_beginning() {\n        let slice = &[1, 2, 3];\n        let (result, elem) = slice.remove(0);\n        assert_eq(result.len(), 2);\n        assert_eq(result, &[2, 3]);\n        assert_eq(elem, 1);\n    }\n\n    #[test]\n    fn remove_middle() {\n        let slice = &[1, 2, 3];\n        let (result, elem) = slice.remove(1);\n        assert_eq(result.len(), 2);\n        assert_eq(result, &[1, 3]);\n        assert_eq(elem, 2);\n    }\n\n    #[test]\n    fn remove_end() {\n        let slice = &[1, 2, 3];\n        let (result, elem) = slice.remove(2);\n        assert_eq(result.len(), 2);\n        assert_eq(result, &[1, 2]);\n        assert_eq(elem, 3);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds\")]\n    fn remove_end_out_of_bounds() {\n        let slice = &[1, 2];\n        let (_, _) = slice.remove(2);\n    }\n\n    #[test]\n    fn fold_empty() {\n        let empty = &[];\n        let result = empty.fold(10, |acc, x| acc + x);\n        assert_eq(result, 10);\n    }\n\n    #[test]\n    fn fold_single() {\n        let slice = &[5];\n        let result = slice.fold(10, |acc, x| acc + x);\n        assert_eq(result, 15);\n    }\n\n    #[test]\n    fn fold_multiple() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.fold(0, |acc, x| acc + x);\n        assert_eq(result, 10);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds\")]\n    fn reduce_empty() {\n        let empty: [Field] = &[];\n        let _ = empty.reduce(|a, b| a + b);\n    }\n\n    #[test]\n    fn reduce_single() {\n        let slice = &[42];\n        let result = slice.reduce(|a, b| a + b);\n        assert_eq(result, 42);\n    }\n\n    #[test]\n    fn reduce_multiple() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.reduce(|a, b| a + b);\n        assert_eq(result, 10);\n    }\n\n    #[test]\n    fn filter_empty() {\n        let empty = &[];\n        let result = empty.filter(|x| x > 0);\n        assert_eq(result.len(), 0);\n    }\n\n    #[test]\n    fn filter_all_true() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.filter(|x| x > 0);\n        assert_eq(result, slice);\n    }\n\n    #[test]\n    fn filter_all_false() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.filter(|x| x > 10);\n        assert_eq(result.len(), 0);\n    }\n\n    #[test]\n    fn filter_some() {\n        let slice = &[1, 2, 3, 4, 5];\n        let result = slice.filter(|x| x % 2 == 0);\n        assert_eq(result, &[2, 4]);\n    }\n\n    #[test]\n    fn all_empty() {\n        let empty = &[];\n        let result = empty.all(|x| x > 0);\n        assert_eq(result, true);\n    }\n\n    #[test]\n    fn all_true() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.all(|x| x > 0);\n        assert_eq(result, true);\n    }\n\n    #[test]\n    fn all_false() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.all(|x| x > 2);\n        assert_eq(result, false);\n    }\n\n    #[test]\n    fn any_empty() {\n        let empty = &[];\n        let result = empty.any(|x| x > 0);\n        assert_eq(result, false);\n    }\n\n    #[test]\n    fn any_true() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.any(|x| x > 3);\n        assert_eq(result, true);\n    }\n\n    #[test]\n    fn any_false() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.any(|x| x > 10);\n        assert_eq(result, false);\n    }\n\n    // utility method tests\n    #[test]\n    fn append_empty_to_empty() {\n        let empty1: [Field] = &[];\n        let empty2: [Field] = &[];\n        let result = empty1.append(empty2);\n        assert_eq(result.len(), 0);\n    }\n\n    #[test]\n    fn append_empty_to_non_empty() {\n        let slice = &[1, 2, 3];\n        let empty = &[];\n        let result = slice.append(empty);\n        assert_eq(result, slice);\n    }\n\n    #[test]\n    fn append_non_empty_to_empty() {\n        let empty = &[];\n        let slice = &[1, 2, 3];\n        let result = empty.append(slice);\n        assert_eq(result, slice);\n    }\n\n    #[test]\n    fn append_two_non_empty() {\n        let slice1 = &[1, 2];\n        let slice2 = &[3, 4, 5];\n        let result = slice1.append(slice2);\n        assert_eq(result, &[1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    fn as_array_single() {\n        let slice = &[42];\n        let array: [Field; 1] = slice.as_array();\n        assert_eq(array[0], 42);\n    }\n\n    #[test]\n    fn as_array_multiple() {\n        let slice = &[1, 2, 3];\n        let array: [Field; 3] = slice.as_array();\n        assert_eq(array[0], 1);\n        assert_eq(array[1], 2);\n        assert_eq(array[2], 3);\n    }\n\n    // complex scenarios\n    #[test]\n    fn chain_operations() {\n        let slice = &[1, 2, 3, 4, 5];\n        let result = slice.filter(|x| x % 2 == 0).map(|x| x * 2).fold(0, |acc, x| acc + x);\n        assert_eq(result, 12); // (2*2) + (4*2) = 4 + 8 = 12\n    }\n\n    #[test]\n    fn nested_operations() {\n        let slice = &[1, 2, 3, 4];\n        let filtered = slice.filter(|x| x > 1);\n        let mapped = filtered.map(|x| x * x);\n        let sum = mapped.fold(0, |acc, x| acc + x);\n        assert_eq(sum, 29); // 2^2 + 3^2 + 4^2 = 4 + 9 + 16 = 29\n    }\n\n    #[test]\n    fn single_element_operations() {\n        let single = &[42];\n\n        // Test all operations on single element\n        assert_eq(single.len(), 1);\n\n        let pushed_back = single.push_back(99);\n        assert_eq(pushed_back, &[42, 99]);\n\n        let pushed_front = single.push_front(0);\n        assert_eq(pushed_front, &[0, 42]);\n\n        let (popped_back_slice, popped_back_elem) = single.pop_back();\n        assert_eq(popped_back_slice.len(), 0);\n        assert_eq(popped_back_elem, 42);\n\n        let (popped_front_elem, popped_front_slice) = single.pop_front();\n        assert_eq(popped_front_slice.len(), 0);\n        assert_eq(popped_front_elem, 42);\n\n        let inserted = single.insert(0, 0);\n        assert_eq(inserted, &[0, 42]);\n\n        let (removed_slice, removed_elem) = single.remove(0);\n        assert_eq(removed_slice.len(), 0);\n        assert_eq(removed_elem, 42);\n    }\n\n    #[test]\n    fn boundary_conditions() {\n        let slice = &[1, 2, 3];\n\n        // insert at boundaries\n        let at_start = slice.insert(0, 0);\n        assert_eq(at_start, &[0, 1, 2, 3]);\n\n        let at_end = slice.insert(3, 4);\n        assert_eq(at_end, &[1, 2, 3, 4]);\n\n        // remove at boundaries\n        let (removed_start, elem_start) = slice.remove(0);\n        assert_eq(removed_start, &[2, 3]);\n        assert_eq(elem_start, 1);\n\n        let (removed_end, elem_end) = slice.remove(2);\n        assert_eq(removed_end, &[1, 2]);\n        assert_eq(elem_end, 3);\n    }\n\n    #[test]\n    fn complex_predicates() {\n        let slice = &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\n        let even_greater_than_5 = slice.filter(|x| (x % 2 == 0) & (x > 5));\n        assert_eq(even_greater_than_5, &[6, 8, 10]);\n\n        let all_positive_and_less_than_20 = slice.all(|x| (x > 0) & (x < 20));\n        assert_eq(all_positive_and_less_than_20, true);\n\n        let any_divisible_by_7 = slice.any(|x| x % 7 == 0);\n        assert_eq(any_divisible_by_7, true);\n    }\n\n    #[test]\n    fn identity_operations() {\n        let slice = &[1, 2, 3, 4, 5];\n\n        let mapped_identity = slice.map(|x| x);\n        assert_eq(mapped_identity, slice);\n\n        let filtered_all = slice.filter(|_| true);\n        assert_eq(filtered_all, slice);\n\n        let filtered_none = slice.filter(|_| false);\n        assert_eq(filtered_none.len(), 0);\n    }\n\n    #[test(should_fail)]\n    fn as_array_size_mismatch() {\n        let slice = &[1, 2, 3];\n        let _: [Field; 5] = slice.as_array(); // size doesn't match\n    }\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        if result {\n            for i in 0..self.len() {\n                result &= self[i].eq(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let self_len = self.len();\n        let other_len = other.len();\n        let min_len = if self_len < other_len {\n            self_len\n        } else {\n            other_len\n        };\n\n        let mut result = Ordering::equal();\n        for i in 0..min_len {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self_len.cmp(other_len)\n        }\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use super::{Eq, max, min, Ord};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n\n    #[test]\n    fn correctly_handles_unequal_length_slices() {\n        let slice_1 = &[0, 1, 2, 3];\n        let slice_2 = &[0, 1, 2];\n        assert(!slice_1.eq(slice_2));\n    }\n\n    #[test]\n    fn lexicographic_ordering_for_slices() {\n        assert(&[2_u32].cmp(&[1_u32, 1_u32, 1_u32]) == super::Ordering::greater());\n        assert(&[1_u32, 2_u32].cmp(&[1_u32, 2_u32, 3_u32]) == super::Ordering::less());\n    }\n}\n"
    },
    "51": {
      "path": "/home/jpag/Playground/aztec/crosschain/wormhole-demo/packages/aztec/src/message_bridge/src/main.nr",
      "source": "use aztec::macros::aztec;\n\npub mod config;\npub mod utils;\n\n#[aztec]\npub contract MessageBridge {\n    use aztec::{\n        macros::{\n            functions::{initializer, external, internal},\n            storage::storage,\n        },\n        protocol_types::address::AztecAddress,\n        state_vars::{map::Map, public_mutable::PublicMutable, public_immutable::PublicImmutable},\n    };\n    use crate::{\n        config::Config,\n        utils::vaa::{encode_message_payload, decode_vaa},\n    };\n    use wormhole::Wormhole;\n\n    // ============================================================================\n    // STORAGE\n    // ============================================================================\n\n    #[storage]\n    struct Storage<Context> {\n        // Core configuration (immutable after deployment)\n        config: PublicImmutable<Config, Context>,\n\n        // Owner/admin address\n        owner: PublicMutable<AztecAddress, Context>,\n\n        // Registered emitters\n        // chain id => emitter address (one emitter per chain)\n        registered_emitters: Map<u16, PublicMutable<[u8; 32], Context>, Context>,\n\n        // currently stored value\n        current_value: PublicMutable<u128, Context>,\n    }\n\n    // ============================================================================\n    // INITIALIZATION\n    // ============================================================================\n\n    #[external(\"public\")]\n    #[initializer]\n    fn constructor(\n        wormhole_address: AztecAddress,\n        chain_id: u16,\n        owner: AztecAddress,\n        message_fee: u128,\n        consistency: u8\n    ) {\n        storage.config.initialize(Config::new(\n            wormhole_address,\n            chain_id,\n            message_fee,\n            consistency\n        ));\n        storage.owner.write(owner);\n\n        // Initialize last received values to zero\n        storage.current_value.write(0);\n    }\n\n    /**\n     * Register up to 8 emitter addresses for source chains\n     *\n     * @param source_chain_id The chain ID of the source chain\n     */\n    #[external(\"public\")]\n    fn register_emitter(\n        source_chain_ids: BoundedVec<u16, 8>,\n        emitter_addresses: BoundedVec<[u8; 32], 8>,\n    ) {\n        // 1. check caller is admin\n        let owner = storage.owner.read();\n        assert(owner == context.msg_sender().unwrap(), \"Caller is not owner\");\n\n        // 2. check lengths match\n        assert(\n            source_chain_ids.len() == emitter_addresses.len(),\n            \"Source chain IDs and emitter addresses length mismatch\"\n        );\n        // 3. register emitters (store full 32-byte addresses)\n        for i in 0..8 {\n            if i < source_chain_ids.len() {\n                let source_chain_id = source_chain_ids.get_unchecked(i);\n                let emitter_address = emitter_addresses.get_unchecked(i);\n                storage.registered_emitters\n                    .at(source_chain_id)\n                    .write(emitter_address);\n            }\n        }\n    }\n\n    // ============================================================================\n    // SEND MESSAGE (Aztec -> EVM)\n    // ============================================================================\n\n    #[external(\"public\")]\n    fn send_value_public(\n        destination_chain_id: u16,\n        value: u128,\n        fee_nonce: Field,\n    ) {\n        // no auth checks\n        let caller = context.msg_sender().unwrap();\n        let config = storage.config.read();\n\n        // 1. Encode the message payload (just destination_chain_id + value)\n        let wormhole_payload = encode_message_payload(value, destination_chain_id);\n\n        // 2. Publish message publicly through Wormhole\n        let _ = Wormhole::at(config.wormhole_address).publish_message_in_public(\n            0, // nonce\n            wormhole_payload,\n            config.message_fee,\n            config.consistency,\n            caller,\n            fee_nonce,\n        ).call(&mut context);\n    }\n\n    #[external(\"private\")]\n    fn send_value_private(\n        destination_chain_id: u16,\n        value: u128,\n        fee_nonce: Field,\n    ) {\n        // no auth checks\n        let caller = context.msg_sender().unwrap();\n        let config = storage.config.read();\n\n        // 1. Encode the message payload (just destination_chain_id + value)\n        let wormhole_payload = encode_message_payload(value, destination_chain_id);\n\n        // 2. Publish message privately through Wormhole\n        let _ = Wormhole::at(config.wormhole_address).publish_message_in_private(\n            0, // nonce\n            wormhole_payload,\n            config.message_fee,\n            config.consistency,\n            caller,\n            fee_nonce,\n        ).call(&mut context);\n    }\n\n    // ============================================================================\n    // RECEIVE MESSAGE (EVM -> Aztec)\n    // ============================================================================\n    \n    #[external(\"private\")]\n    fn receive_value(vaa: [u8; 2000], length: u32) {\n        // 1. verify the VAA through Wormhole\n        let config = storage.config.read();\n        Wormhole::at(config.wormhole_address).verify_vaa(vaa, length).call(&mut context);\n\n        // 2. decode the VAA (envelope + payload) and compute vaa nullifier\n        let (vaa_envelope, vaa_payload, vaa_nullifier) = decode_vaa(vaa);\n\n        // 3. validate destination chain is this chain\n        assert(\n            vaa_payload.destination_chain_id == config.chain_id,\n            \"Invalid destination chain ID\"\n        );\n\n        // 4. emit the nullifier to prevent replays\n        // note: will fail if nullifier has already been emitted\n        context.push_nullifier(vaa_nullifier);\n\n        // 5. validate emitter and update state (done in public to read public storage)\n        MessageBridge::at(context.this_address())\n            ._validate_emitter_and_update_value(\n                vaa_envelope.emitter_chain_id,\n                vaa_envelope.emitter_address,\n                vaa_payload.value,\n            )\n            .enqueue(&mut context);\n    }\n\n    #[external(\"public\")]\n    #[internal]\n    fn _validate_emitter_and_update_value(\n        emitter_chain_id: u16,\n        emitter_address: [u8; 32],\n        value: u128,\n    ) {\n        // Validate emitter from VAA envelope (not sender from payload)\n        let registered_emitter = storage.registered_emitters\n            .at(emitter_chain_id)\n            .read();\n        assert(registered_emitter == emitter_address, \"Emitter not registered\");\n\n        // Update state with received value\n        storage.current_value.write(value);\n    }\n\n    // ============================================================================\n    // VIEW FUNCTIONS\n    // ============================================================================\n\n    #[external(\"utility\")]\n    unconstrained fn get_config() -> Config {\n        storage.config.read()\n    }\n\n    #[external(\"utility\")]\n    unconstrained fn get_owner() -> AztecAddress {\n        storage.owner.read()\n    }\n\n    #[external(\"utility\")]\n    unconstrained fn is_emitter_registered(chain_id: u16, emitter_address: [u8; 32]) -> bool {\n        let registered_emitter = storage.registered_emitters\n            .at(chain_id)\n            .read();\n        registered_emitter == emitter_address\n    }\n\n    #[external(\"utility\")]\n    unconstrained fn get_registered_emitter(chain_id: u16) -> [u8; 32] {\n        storage.registered_emitters\n            .at(chain_id)\n            .read()\n    }\n\n    #[external(\"utility\")]\n    unconstrained fn get_current_value() -> u128 {\n        storage.current_value.read()\n    }\n}\n"
    },
    "52": {
      "path": "/home/jpag/Playground/aztec/crosschain/wormhole-demo/packages/aztec/src/message_bridge/src/utils/mod.nr",
      "source": "pub mod vaa;\n\n// VAA structure offsets (hardcoded for 1 signature)\npub global VAA_HEADER_SIZE: u32 = 6;        // version(1) + guardian_set(4) + num_sigs(1)\npub global VAA_SIGNATURE_SIZE: u32 = 66;    // guardian_index(1) + signature(64) + recovery(1)\npub global VAA_ENVELOPE_START: u32 = VAA_HEADER_SIZE + VAA_SIGNATURE_SIZE; // = 72\npub global VAA_ENVELOPE_SIZE: u32 = 51;     // timestamp(4) + nonce(4) + emitter_chain(2) + emitter_addr(32) + sequence(8) + consistency(1)\npub global VAA_PAYLOAD_START: u32 = VAA_ENVELOPE_START + VAA_ENVELOPE_SIZE; // = 123\n\npub global VAA_MAX_LENGTH: u32 = 2000;      // max VAA length in Wormhole spec\npub global VAA_BODY_MAX_LENGTH: u32 = 1860; // max body length in Wormhole VAA spec\n\n// Message payload structure (18 bytes): destinationChainId (2) + value (16)\npub global MESSAGE_PAYLOAD_LENGTH: u32 = 18;\npub global MESSAGE_NULLIFIER_LENGTH: u32 = VAA_ENVELOPE_SIZE + MESSAGE_PAYLOAD_LENGTH; // 51 + 18 = 69\npub global MESSAGE_NULLIFIER_PACKED_LENGTH: u32 = 3; // ceil(69 / 31) = 3\n\n/// Decoded VAA envelope (excludes header and signatures)\npub struct DecodedVAAEnvelope {\n    pub timestamp: u32,\n    pub nonce: u32,\n    pub emitter_chain_id: u16,\n    pub emitter_address: [u8; 32],\n    pub sequence: u64,\n    pub consistency_level: u8,\n}\n\n\n/// Decoded message payload (18 bytes)\npub struct DecodedVAAPayload {\n    pub destination_chain_id: u16,\n    pub value: u128,\n}\n\n// probably should just use Field::to_le_bytes but meh\npub fn u16_to_u8(value: u16) -> [u8; 2] {\n    // Safety: constrained below, use unconstrained for bitwise ops\n    let decomposed = unsafe { _u16_to_u8(value) };\n    let asserted = decomposed[0] as u16 * 256 + decomposed[1] as u16;\n    assert(asserted == value, \"u16 to u8 conversion failed\");\n    decomposed\n}\n\nunconstrained fn _u16_to_u8(value: u16) -> [u8; 2] {\n    let high = (value >> 8) as u8;\n    let low = (value & 0xFF) as u8;\n    [high, low]\n}"
    },
    "53": {
      "path": "/home/jpag/Playground/aztec/crosschain/wormhole-demo/packages/aztec/src/message_bridge/src/utils/vaa.nr",
      "source": "use keccak256::keccak256;\nuse poseidon::poseidon2::Poseidon2;\nuse crate::utils::{\n    VAA_MAX_LENGTH,\n    VAA_ENVELOPE_START,\n    VAA_PAYLOAD_START,\n    MESSAGE_NULLIFIER_LENGTH,\n    MESSAGE_NULLIFIER_PACKED_LENGTH,\n    DecodedVAAEnvelope,\n    DecodedVAAPayload,\n    u16_to_u8,\n};\nuse nodash::pack_bytes;\n\npub struct DecodedVAA {\n    pub envelope: DecodedVAAEnvelope,\n    pub payload: DecodedVAAPayload,\n}\n\n/// Parse a raw VAA and extract envelope, payload, and compute nullifier\n///\n/// VAA structure (with 1 signature):\n///   Bytes 0-5:     Header (version, guardian set, num sigs) - skipped\n///   Bytes 6-71:    Signature - skipped\n///   Bytes 72-122:  Envelope (timestamp, nonce, emitter chain, emitter addr, sequence, consistency)\n///   Bytes 123+:    Payload\npub fn decode_vaa(vaa: [u8; VAA_MAX_LENGTH]) -> (\n    DecodedVAAEnvelope,\n    DecodedVAAPayload,\n    Field,\n) {\n    let envelope = decode_vaa_envelope(vaa);\n    let payload = decode_vaa_payload(vaa);\n    let nullifier = compute_vaa_nullifier(vaa);\n    (envelope, payload, nullifier)\n}\n\n/// Parse the VAA envelope (starts at byte 72 for 1 signature)\n///\n/// Envelope structure (51 bytes):\n///   Bytes 0-3:   timestamp (u32, big-endian)\n///   Bytes 4-7:   nonce (u32, big-endian)\n///   Bytes 8-9:   emitter_chain_id (u16, big-endian)\n///   Bytes 10-41: emitter_address (32 bytes)\n///   Bytes 42-49: sequence (u64, big-endian)\n///   Byte 50:     consistency_level (u8)\npub fn decode_vaa_envelope(vaa: [u8; VAA_MAX_LENGTH]) -> DecodedVAAEnvelope {\n    let offset = VAA_ENVELOPE_START;\n\n    // timestamp (4 bytes, big-endian)\n    let mut timestamp_bytes: [u8; 4] = [0; 4];\n    for i in 0..4 {\n        timestamp_bytes[i] = vaa[offset + i];\n    }\n    let timestamp = Field::from_be_bytes(timestamp_bytes) as u32;\n\n    // nonce (4 bytes, big-endian)\n    let mut nonce_bytes: [u8; 4] = [0; 4];\n    for i in 0..4 {\n        nonce_bytes[i] = vaa[offset + 4 + i];\n    }\n    let nonce = Field::from_be_bytes(nonce_bytes) as u32;\n\n    // emitter_chain_id (2 bytes, big-endian)\n    let mut chain_id_bytes: [u8; 2] = [0; 2];\n    for i in 0..2 {\n        chain_id_bytes[i] = vaa[offset + 8 + i];\n    }\n    let emitter_chain_id = Field::from_be_bytes(chain_id_bytes) as u16;\n\n    // emitter_address (32 bytes)\n    let mut emitter_address: [u8; 32] = [0; 32];\n    for i in 0..32 {\n        emitter_address[i] = vaa[offset + 10 + i];\n    }\n\n    // sequence (8 bytes, big-endian)\n    let mut sequence_bytes: [u8; 8] = [0; 8];\n    for i in 0..8 {\n        sequence_bytes[i] = vaa[offset + 42 + i];\n    }\n    let sequence = Field::from_be_bytes(sequence_bytes) as u64;\n\n    // consistency_level (1 byte)\n    let consistency_level = vaa[offset + 50];\n\n    DecodedVAAEnvelope {\n        timestamp,\n        nonce,\n        emitter_chain_id,\n        emitter_address,\n        sequence,\n        consistency_level,\n    }\n}\n\n/// Parse the VAA payload (starts at byte 123 for 1 signature)\n///\n/// Payload structure (18 bytes):\n///   Bytes 0-1:   destination_chain_id (u16, big-endian)\n///   Bytes 2-17:  value (u128, big-endian)\npub fn decode_vaa_payload(vaa: [u8; VAA_MAX_LENGTH]) -> DecodedVAAPayload {\n    let offset = VAA_PAYLOAD_START;\n\n    // destination_chain_id (2 bytes, big-endian)\n    let destination_chain_id = (\n        (vaa[offset] as Field) * 256\n        + (vaa[offset + 1] as Field)\n    ) as u16;\n\n    // value (16 bytes, big-endian) - parse as u128 via Field multiplication\n    let mut value_bytes: [u8; 16] = [0; 16];\n    for i in 0..16 {\n        value_bytes[i] = vaa[offset + 2 + i];\n    }\n    let value = Field::from_be_bytes(value_bytes) as u128;\n\n    DecodedVAAPayload {\n        destination_chain_id,\n        value,\n    }\n}\n\n/// Compute nullifier from VAA bytes (for replay protection)\nfn compute_vaa_nullifier(vaa: [u8; VAA_MAX_LENGTH]) -> Field {\n    // Pack the relevant bytes (envelope + payload) for hashing\n    let mut nullifier_bytes = [0; MESSAGE_NULLIFIER_LENGTH];\n    for i in 0..MESSAGE_NULLIFIER_LENGTH {\n        nullifier_bytes[i] = vaa[VAA_ENVELOPE_START + i];\n    }\n\n    let packed = pack_bytes(nullifier_bytes);\n    Poseidon2::hash(packed, MESSAGE_NULLIFIER_PACKED_LENGTH)\n}\n\n/// Encode a message payload for sending via Wormhole (Aztec -> EVM)\n///\n/// Payload structure (18 bytes):\n///   Bytes 0-1:   destination_chain_id (u16, big-endian)\n///   Bytes 2-17:  value (u128, big-endian)\n///\n/// Returns 8 chunks of 31 bytes for Aztec Field compatibility\npub fn encode_message_payload(\n    value: u128,\n    destination_chain_id: u16,\n) -> [[u8; 31]; 8] {\n    let mut wormhole_payload: [[u8; 31]; 8] = [[0; 31]; 8];\n\n    let destination_chain_bytes = u16_to_u8(destination_chain_id);\n    let value_bytes: [u8; 16] = Field::to_be_bytes(value as Field);\n\n    // Chunk 0: destination_chain_id (2 bytes) + value (16 bytes) = 18 bytes total\n    wormhole_payload[0][0] = destination_chain_bytes[0];\n    wormhole_payload[0][1] = destination_chain_bytes[1];\n    for i in 0..16 {\n        wormhole_payload[0][2 + i] = value_bytes[i];\n    }\n\n    wormhole_payload\n}\n\n// Keccak hash of VAA body (for signature verification)\npub fn compute_vaa_hash(body_bytes: [u8; 1860], body_length: u32) -> [u8; 32] {\n    let mut actual_body = [0; 1860];\n    for i in 0..body_length {\n        actual_body[i] = body_bytes[i];\n    }\n\n    // Double hash as per Wormhole spec\n    let hash: [u8; 32] = keccak256(actual_body, body_length);\n    let double_hash: [u8; 32] = keccak256(hash, 32);\n\n    double_hash\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0, \"cannot pop from an empty vector\");\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            let _ = vec.get(0);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_beyond_length() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            let _ = vec.get(3);\n        }\n\n        #[test]\n        fn get_works_within_bounds() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(2), 3);\n            assert_eq(vec.get(4), 5);\n        }\n\n        #[test]\n        fn get_unchecked_works() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(0), 1);\n            assert_eq(vec.get_unchecked(2), 3);\n        }\n\n        #[test]\n        fn get_unchecked_works_past_len() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(4), 0);\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_setting_beyond_length() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            vec.set(3, 4);\n        }\n\n        #[test]\n        fn set_unchecked_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(0, 10);\n            assert_eq(vec.get(0), 10);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn set_unchecked_operations_past_len() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(3, 40);\n            assert_eq(vec.get(3), 40);\n        }\n\n        #[test]\n        fn set_preserves_other_elements() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            vec.set(2, 30);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 30);\n            assert_eq(vec.get(3), 4);\n            assert_eq(vec.get(4), 5);\n        }\n    }\n\n    mod any {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn returns_false_if_predicate_not_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, false, false]);\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn returns_true_if_predicate_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, true, true]);\n            let result = vec.any(|value| value);\n\n            assert(result);\n        }\n\n        #[test]\n        fn returns_false_on_empty_boundedvec() {\n            let vec: BoundedVec<bool, 0> = BoundedVec::new();\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn any_with_complex_predicates() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            assert(vec.any(|x| x > 3));\n            assert(!vec.any(|x| x > 10));\n            assert(vec.any(|x| x % 2 == 0)); // has a even number\n            assert(vec.any(|x| x == 3)); // has a specific value\n        }\n\n        #[test]\n        fn any_with_partial_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            assert(vec.any(|x| x == 1));\n            assert(vec.any(|x| x == 2));\n            assert(!vec.any(|x| x == 3));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn map_with_conditional_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.map(|x| if x % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([1, 4, 3, 8]);\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn map_preserves_length() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|x| x * 2);\n\n            assert_eq(result.len(), vec.len());\n            assert_eq(result.max_len(), vec.max_len());\n        }\n\n        #[test]\n        fn map_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let result = vec.map(|x| x * 2);\n            assert_eq(result, vec);\n            assert_eq(result.len(), 0);\n            assert_eq(result.max_len(), 5);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn mapi_with_index_branching_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.mapi(|i, x| if i % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([2, 2, 6, 4]);\n            assert_eq(result, expected);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_each_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_each(|_| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_each_with_side_effects() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let mut seen = BoundedVec::<u32, 3>::new();\n            let seen_ref = &mut seen;\n            vec.for_each(|x| seen_ref.push(x));\n            assert_eq(seen, vec);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_eachi_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_eachi(|_, _| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_eachi_with_index_tracking() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([10, 20, 30]);\n            let mut indices = BoundedVec::<u32, 3>::new();\n            let indices_ref = &mut indices;\n            vec.for_eachi(|i, _| indices_ref.push(i));\n\n            let expected = BoundedVec::from_array([0, 1, 2]);\n            assert_eq(indices, expected);\n        }\n\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n\n        #[test]\n        fn from_array_preserves_order() {\n            let array = [5, 3, 1, 4, 2];\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array(array);\n            for i in 0..array.len() {\n                assert_eq(vec.get(i), array[i]);\n            }\n        }\n\n        #[test]\n        fn from_array_with_different_types() {\n            let bool_array = [true, false, true];\n            let bool_vec: BoundedVec<bool, 3> = BoundedVec::from_array(bool_array);\n            assert_eq(bool_vec.len(), 3);\n            assert_eq(bool_vec.get(0), true);\n            assert_eq(bool_vec.get(1), false);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n\n    mod push_pop {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn push_and_pop_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            assert_eq(vec.len(), 0);\n\n            vec.push(1);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 1);\n\n            vec.push(2);\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.get(1), 2);\n\n            let popped = vec.pop();\n            assert_eq(popped, 2);\n            assert_eq(vec.len(), 1);\n\n            let popped2 = vec.pop();\n            assert_eq(popped2, 1);\n            assert_eq(vec.len(), 0);\n        }\n\n        #[test(should_fail_with = \"push out of bounds\")]\n        fn push_to_full_vector() {\n            let mut vec: BoundedVec<u32, 2> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n            vec.push(3); // should panic\n        }\n\n        #[test(should_fail_with = \"cannot pop from an empty vector\")]\n        fn pop_from_empty_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let _ = vec.pop(); // should panic\n        }\n\n        #[test]\n        fn push_pop_cycle() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n\n            // push to full\n            vec.push(1);\n            vec.push(2);\n            vec.push(3);\n            assert_eq(vec.len(), 3);\n\n            // pop all\n            assert_eq(vec.pop(), 3);\n            assert_eq(vec.pop(), 2);\n            assert_eq(vec.pop(), 1);\n            assert_eq(vec.len(), 0);\n\n            // push again\n            vec.push(4);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 4);\n        }\n    }\n\n    mod extend {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn extend_from_array() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_slice() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_bounded_vec() {\n            let mut vec1: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut vec2: BoundedVec<u32, 3> = BoundedVec::new();\n\n            vec1.push(1);\n            vec2.push(2);\n            vec2.push(3);\n\n            vec1.extend_from_bounded_vec(vec2);\n\n            assert_eq(vec1.len(), 3);\n            assert_eq(vec1.get(0), 1);\n            assert_eq(vec1.get(1), 2);\n            assert_eq(vec1.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"extend_from_array out of bounds\")]\n        fn extend_array_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3, 4]); // should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_slice out of bounds\")]\n        fn extend_slice_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3, 4]); // S]should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_bounded_vec out of bounds\")]\n        fn extend_bounded_vec_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            let other: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            vec.extend_from_bounded_vec(other); // should panic\n        }\n\n        #[test]\n        fn extend_with_empty_collections() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let original_len = vec.len();\n\n            vec.extend_from_array([]);\n            assert_eq(vec.len(), original_len);\n\n            vec.extend_from_slice(&[]);\n            assert_eq(vec.len(), original_len);\n\n            let empty: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.extend_from_bounded_vec(empty);\n            assert_eq(vec.len(), original_len);\n        }\n    }\n\n    mod storage {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn storage_consistency() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            // test initial storage state\n            assert_eq(vec.storage(), [0, 0, 0, 0, 0]);\n\n            vec.push(1);\n            vec.push(2);\n\n            // test storage after modifications\n            assert_eq(vec.storage(), [1, 2, 0, 0, 0]);\n\n            // storage doesn't change length\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.max_len(), 5);\n        }\n\n        #[test]\n        fn storage_after_pop() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n\n            let _ = vec.pop();\n            // after pop, the last element should be zeroed\n            assert_eq(vec.storage(), [1, 2, 0]);\n            assert_eq(vec.len(), 2);\n        }\n\n        #[test]\n        fn vector_immutable() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let storage = vec.storage();\n\n            assert_eq(storage, [1, 2, 3]);\n\n            // Verify that the original vector is unchanged\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n    }\n}\n"
    },
    "62": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push(self, value: T)\n    where\n        T: Serialize,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get(self, index: u32) -> T\n    where\n        T: Deserialize,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n\n    global SLOT: Field = 1230;\n\n    #[test]\n    unconstrained fn empty_array() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            let _: Field = array.get(0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            assert_eq(array.len(), 1);\n            assert_eq(array.get(0), 5);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            let _ = array.get(1);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(5);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            assert_eq(array.len(), 3);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 8);\n            assert_eq(array.get(2), 9);\n\n            array.remove(1);\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 9);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            array.remove(1);\n            array.remove(1);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n            // we do not care about the order in which each tuple was passed to the closure.\n            let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n            array.for_each(|index, value| { called_with.push((index, value)); });\n\n            assert_eq(called_with.len(), 3);\n            assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n            assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n            assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| {\n                if index == 1 {\n                    array.remove(index);\n                }\n            });\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 4);\n            assert_eq(array.get(1), 6);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all_no_copy() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We test that the utilityCopyCapsule was never called, which is the expensive operation we want to avoid.\n            let mock = std::test::OracleMock::mock(\"utilityCopyCapsule\");\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(mock.times_called(), 0);\n        });\n    }\n}\n"
    },
    "63": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PrivateCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    /// Makes the call to this private function.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// This enables contracts to interact with each other while maintaining\n    /// privacy. This \"composability\" of private contract functions is a key\n    /// feature of the Aztec network.\n    ///\n    /// If a user's transaction includes multiple private function calls, then\n    /// by the design of Aztec, the following information will remain private[1]:\n    /// - The function selectors and contract addresses of all private function\n    ///   calls will remain private, so an observer of the public mempool will\n    ///   not be able to look at a tx and deduce which private functions have\n    ///   been executed.\n    /// - The arguments and return values of all private function calls will\n    ///   remain private.\n    /// - The person who initiated the tx will remain private.\n    /// - The notes and nullifiers and private logs that are emitted by all\n    ///   private function calls will (if designed well) not leak any user\n    ///   secrets, nor leak which functions have been executed.\n    ///\n    /// [1] Caveats: Some of these privacy guarantees depend on how app\n    /// developers design their smart contracts. Some actions _can_ leak\n    /// information, such as:\n    /// - Calling an internal public function.\n    /// - Calling a public function and not setting msg_sender to Option::none\n    ///   (see https://github.com/AztecProtocol/aztec-packages/pull/16433)\n    /// - Calling any public function will always leak details about the nature\n    ///   of the transaction, so devs should be careful in their contract\n    ///   designs. If it can be done in a private function, then that will give\n    ///   the best privacy.\n    /// - Not padding the side-effects of a tx to some standardised, uniform\n    ///   size. The kernel circuits can take hints to pad side-effects, so a\n    ///   wallet should be able to request for a particular amount of padding.\n    ///   Wallets should ideally agree on some standard.\n    ///   - Padding should include:\n    ///     - Padding the lengths of note & nullifier arrays\n    ///     - Padding private logs with random fields, up to some standardised\n    ///       size.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Advanced\n    /// * The call is added to the private call stack and executed by kernel\n    ///   circuits after this function completes\n    /// * The called function can modify its own contract's private state\n    /// * Side effects from the called function are included in this transaction\n    /// * The call inherits the current transaction's context and gas limits\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub fn call(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n\n        // If T is () (i.e. if the function does not return anything) then `get_preimage` will constrain that the\n        // returns hash is empty as per the protocol rules.\n        returns_hash.get_preimage()\n    }\n\n    /// Makes a _read-only_ call to this private function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// See `call` for more general info on private function calls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub fn view(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        // If T is () (i.e. if the function does not return anything) then `get_preimage` will constrain that the\n        // returns hash is empty as per the protocol rules.\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PrivateCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PrivateStaticCallInterface<M, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    /// Makes a read-only call to this private function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn view(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PrivateStaticCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PublicCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    /// Makes the call to this public function.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[external(\"public\")] function as `context`, through the\n    ///               #[external(\"public\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn call(self, context: &mut PublicContext) -> T {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        // If T is () (i.e. if the function does not return anything) then `as_array` will constrain that `returns` has\n        // a length of 0 (since that is ()'s deserialization length).\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Makes a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[external(\"public\")] function as `context`, through the\n    ///               #[external(\"public\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn view(self, context: &mut PublicContext) -> T {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        // If T is () (i.e. if the function does not return anything) then `as_array` will constrain that `returns` has\n        // a length of 0 (since that is ()'s deserialization length).\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Enqueues a call to this public function, to be executed later.\n    ///\n    /// Unlike private functions which execute immediately on the user's device,\n    /// public function calls are \"enqueued\" and executed some time later by a\n    /// block proposer.\n    ///\n    /// This means a public function cannot return any values back to a private\n    /// function, because by the time the public function is being executed,\n    /// the private function which called it has already completed execution.\n    /// (In fact, the private function has been executed and proven, along with\n    /// all other private function calls of the user's tx. A single proof of the\n    /// tx has been submitted to the Aztec network, and some time later a\n    /// proposer has picked the tx up from the mempool and begun executing all\n    /// of the enqueued public functions).\n    ///\n    /// # Privacy warning\n    /// Enqueueing a public function call is an inherently leaky action.\n    /// Many interesting applications will require some interaction with public\n    /// state, but smart contract developers should try to use public function\n    /// calls sparingly, and carefully.\n    /// _Internal_ public function calls are especially leaky, because they\n    /// completely leak which private contract made the call.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        self.enqueue_impl(context, false, false)\n    }\n\n    /// Enqueues a call to this public function, to be executed later.\n    ///\n    /// As per `enqueue`, but hides this calling contract's address from the\n    /// target public function.\n    /// This means the origin of the call (msg_sender) will not be publicly\n    /// visible to any blockchain observers, nor to the target public function.\n    /// When the target public function reads `context.msg_sender()` it will\n    /// receive an `Option<AztecAddress>::none`.\n    ///\n    /// NOTES:\n    /// - Not all public functions will accept a msg_sender of \"none\". Many\n    ///   public functions will require that msg_sender is \"some\" and will\n    ///   revert otherwise. Therefore, if using `enqueue_incognito`, you must\n    ///   understand whether the function you're calling will accept a\n    ///   msg_sender of \"none\".\n    ///   Lots of public bookkeeping patterns rely on knowing which address made\n    ///   the call, so as to ascribe state against the caller's address.\n    ///   (There are patterns whereby bookkeeping could instead be done in\n    ///   private-land).\n    /// - If you are enqueueing a call to an _internal_ public function (i.e.\n    ///   a public function that will only accept calls from other functions\n    ///   of its own contract), then by definition a call to it cannot possibly\n    ///   be \"incognito\": the msg_sender must be its own address, and indeed the\n    ///   called public function will assert this. Tl;dr this is not usable for\n    ///   enqueued internal public calls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    /// Advanced:\n    /// - The kernel circuits will permit _any_ private function to set the\n    ///   msg_sender field of any enqueued public function call to\n    ///   NULL_MSG_SENDER_CONTRACT_ADDRESS.\n    /// - When the called public function calls `PublicContext::msg_sender()`,\n    ///   aztec-nr will translate NULL_MSG_SENDER_CONTRACT_ADDRESS into\n    ///   `Option<AztecAddress>::none` for familiarity to devs.\n    ///\n    pub fn enqueue_incognito(self, context: &mut PrivateContext) {\n        self.enqueue_impl(context, false, true)\n    }\n\n    /// Enqueues a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        self.enqueue_impl(context, true, false)\n    }\n\n    /// Enqueues a read-only call to this public function.\n    ///\n    /// As per `enqueue_view`, but hides this calling contract's address from\n    /// the target public function.\n    ///\n    /// See `enqueue_incognito` for more details relating to hiding msg_sender.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn enqueue_view_incognito(self, context: &mut PrivateContext) {\n        self.enqueue_impl(context, true, true)\n    }\n\n    fn enqueue_impl(\n        self,\n        context: &mut PrivateContext,\n        is_static_call: bool,\n        hide_msg_sender: bool,\n    ) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            is_static_call,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a call to this public function, and designates it to be the\n    /// teardown function for this tx. Only one teardown function call can be\n    /// made by a tx.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase ensures the fee payer\n    /// has sufficient balance to pay the proposer their fees.\n    /// The teardown phase is primarily intended to: calculate exactly\n    /// how much the user owes, based on gas consumption, and refund the user\n    /// any change.\n    ///\n    /// Note: in some cases, the cost of refunding the user (i.e. DA costs of\n    /// tx side-effects) might exceed the refund amount. For app logic with\n    /// fairly stable and predictable gas consumption, a material refund amount\n    /// is unlikely. For app logic with unpredictable gas consumption, a\n    /// refund might be important to the user (e.g. if a hefty function reverts\n    /// very early). Wallet/FPC/Paymaster developers should be mindful of this.\n    ///\n    /// See `enqueue` for more information about enqueuing public function calls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        self.set_as_teardown_impl(context, false);\n    }\n\n    /// Enqueues a call to this public function, and designates it to be the teardown\n    /// function for this tx. Only one teardown function call can be made by a\n    /// tx.\n    ///\n    /// As per `set_as_teardown`, but hides this calling contract's address from\n    /// the target public function.\n    ///\n    /// See `enqueue_incognito` for more details relating to hiding msg_sender.\n    ///\n    pub fn set_as_teardown_incognito(self, context: &mut PrivateContext) {\n        self.set_as_teardown_impl(context, true);\n    }\n\n    fn set_as_teardown_impl(self, context: &mut PrivateContext, hide_msg_sender: bool) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PublicCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let M: u32, T> PublicStaticCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    /// Makes the read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[external(\"public\")] function as `context`, through the\n    ///               #[external(\"public\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn view(self, context: &mut PublicContext) -> T {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Enqueues a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n            false,\n        )\n    }\n\n    pub fn enqueue_view_incognito(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n            true,\n        )\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PublicStaticCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// UtilityCallInterface\n\npub struct UtilityCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n}\n\nimpl<let M: u32, T> CallInterface<M> for UtilityCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        false\n    }\n}\n\nimpl<let M: u32, T> UtilityCallInterface<M, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n\n    pub fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    pub fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    pub fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    pub fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n}\n"
    },
    "70": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        logs::notify_created_contract_class_log,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        block_header::BlockHeader,\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log_hash::LogHash,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::{PrivateLog, PrivateLogData},\n        public_call_request::PublicCallRequest,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, MAX_CONTRACT_CLASS_LOGS_PER_CALL,\n        MAX_ENQUEUED_CALLS_PER_CALL, MAX_INCLUDE_BY_TIMESTAMP_DURATION,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        NULL_MSG_SENDER_CONTRACT_ADDRESS, PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    hash::poseidon2_hash,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    side_effect::Counted,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::{ClaimedLengthArray, trimmed_array_length_hint},\n};\n\n/// # PrivateContext\n///\n/// The **main interface** between an #[external(\"private\")] function and the Aztec blockchain.\n///\n/// An instance of the PrivateContext is initialized automatically at the outset\n/// of every private function, within the #[external(\"private\")] macro, so you'll never\n/// need to consciously instantiate this yourself.\n///\n/// The instance is always named `context`, and it is always be available within\n/// the body of every #[external(\"private\")] function in your smart contract.\n///\n/// > For those used to \"vanilla\" Noir, it might be jarring to have access to\n/// > `context` without seeing a declaration `let context = PrivateContext::new(...)`\n/// > within the body of your function. This is just a consequence of using\n/// > macros to tidy-up verbose boilerplate. You can use `nargo expand` to\n/// > expand all macros, if you dare.\n///\n/// Typical usage for a smart contract developer will be to call getter\n/// methods of the PrivateContext.\n///\n/// _Pushing_ data and requests to the context is mostly handled within\n/// aztec-nr's own functions, so typically a smart contract developer won't\n/// need to call any setter methods directly.\n///\n/// > Advanced users might occasionally wish to push data to the context\n/// > directly for lower-level control. If you find yourself doing this, please\n/// > open an issue on GitHub to describe your use case: it might be that\n/// > new functionality should be added to aztec-nr.\n///\n/// ## Responsibilities\n/// - Exposes contextual data to a private function:\n///   - Data relating to how this private function was called.\n///     - msg_sender\n///     - this_address - (the contract address of the private function being\n///                      executed)\n///     - See `CallContext` for more data.\n///   - Data relating to the transaction in which this private function is\n///     being executed.\n///     - chain_id\n///     - version\n///     - gas_settings\n/// - Provides state access:\n///   - Access to the \"Anchor block\" header.\n///     Recall, a private function cannot read from the \"current\" block header,\n///     but must read from some historical block header, because as soon as\n///     private function execution begins (asynchronously, on a user's device),\n///     the public state of the chain (the \"current state\") will have progressed\n///     forward. We call this reference the \"Anchor block\".\n///     See `BlockHeader`.\n///   - Enables consumption of L1->L2 messages.\n/// - Enables calls to functions of other smart contracts:\n///   - Private function calls\n///   - Enqueueing of public function call requests\n///     (Since public functions are executed at a later time, by a block\n///     proposer, we say they are \"enqueued\").\n/// - Writes data to the blockchain:\n///   - New notes\n///   - New nullifiers\n///   - Private logs (for sending encrypted note contents or encrypted events)\n///   - New L2->L1 messages.\n/// - Provides args to the private function (handled by the #[external(\"private\")] macro).\n/// - Returns the return values of this private function (handled by the\n///   #[external(\"private\")] macro).\n/// - Makes Key Validation Requests.\n///   - Private functions are not allowed to see master secret keys, because we\n///     do not trust them. They are instead given \"app-siloed\" secret keys with\n///     a claim that they relate to a master public key. They can then request\n///     validation of this claim, by making a \"key validation request\" to the\n///     protocol's kernel circuits (which _are_ allowed to see certain master\n///     secret keys).\n///\n/// ## Advanced Responsibilities\n///\n/// - Ultimately, the PrivateContext is responsible for constructing the\n///   PrivateCircuitPublicInputs of the private function being executed.\n///   All private functions on Aztec must have public inputs which adhere\n///   to the rigid layout of the PrivateCircuitPublicInputs, in order to be\n///   compatible with the protocol's kernel circuits.\n///   A well-known misnomer:\n///   - \"public inputs\" contain both inputs and outputs of this function.\n///     - By \"outputs\" we mean a lot more side-effects than just the\n///       \"return values\" of the function.\n///   - Most of the so-called \"public inputs\" are kept _private_, and never leak\n///     to the outside world, because they are 'swallowed' by the protocol's\n///     kernel circuits before the tx is sent to the network. Only the\n///     following are exposed to the outside world:\n///     - New note_hashes\n///     - New nullifiers\n///     - New private logs\n///     - New L2->L1 messages\n///     - New enqueued public function call requests\n///     All the above-listed arrays of side-effects can be padded by the\n///     user's wallet (through instructions to the kernel circuits, via the\n///     PXE) to obscure their true lengths.\n///\n/// ## Syntax Justification\n///\n/// Both user-defined functions _and_ most functions in aztec-nr need access to\n/// the PrivateContext instance to read/write data. This is why you'll see the\n/// arguably-ugly pervasiveness of the \"context\" throughout your smart contract\n/// and the aztec-nr library.\n/// For example, `&mut context` is prevalent. In some languages, you can access\n/// and mutate a global variable (such as a PrivateContext instance) from a\n/// function without polluting the function's parameters. With Noir, a function\n/// must explicitly pass control of a mutable variable to another function, by\n/// reference. Since many functions in aztec-nr need to be able to push new data\n/// to the PrivateContext, they need to be handed a mutable reference _to_ the\n/// context as a parameter.\n/// For example, `Context` is prevalent as a generic parameter, to give better\n/// type safety at compile time. Many `aztec-nr` functions don't make sense if\n/// they're called in a particular runtime (private, public or utility), and so\n/// are intentionally only implemented over certain\n/// [Private|Public|Utility]Context structs. This gives smart contract\n/// developers a much faster feedback loop if they're making a mistake, as an\n/// error will be thrown by the LSP or when they compile their contract.\n///\n#[derive(Eq)]\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub include_by_timestamp: u64,\n\n    pub note_hash_read_requests: BoundedVec<Counted<Field>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<Counted<Field>, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<Counted<NoteHash>, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Counted<Nullifier>, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<Counted<L2ToL1Message>, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub anchor_block_header: BlockHeader,\n\n    pub private_logs: BoundedVec<Counted<PrivateLogData>, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<Counted<LogHash>, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        let max_allowed_include_by_timestamp = inputs.anchor_block_header.global_variables.timestamp\n            + MAX_INCLUDE_BY_TIMESTAMP_DURATION;\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            include_by_timestamp: max_allowed_include_by_timestamp,\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            anchor_block_header: inputs.anchor_block_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: Since Aztec doesn't have a concept of an EoA (\n    /// Externally-owned Account), the msg_sender is \"null\" for the first\n    /// function call of every transaction.\n    /// The first function call of a tx is likely to be a call to the user's\n    /// account contract, so this quirk will most often be handled by account\n    /// contract developers.\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called\n    ///   this function (be it an app contract or a user's account contract).\n    ///   Returns `Option<AztecAddress>::none` for the first function call of\n    ///   the tx. No other _private_ function calls in the tx will have a `none`\n    ///   msg_sender, but _public_ function calls might (see the PublicContext).\n    ///\n    pub fn msg_sender(self) -> Option<AztecAddress> {\n        let maybe_msg_sender = self.inputs.call_context.msg_sender;\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// \"Unsafe\" versus calling `context.msg_sender()`, because it doesn't\n    /// translate `NULL_MSG_SENDER_CONTRACT_ADDRESS` as\n    /// `Option<AztecAddress>::none`.\n    /// Used by some internal aztecnr functions.\n    pub fn msg_sender_unsafe(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    /// Returns the contract address of the current function being executed.\n    ///\n    /// This is equivalent to `address(this)` in Solidity (hence the name).\n    /// Use this to identify the current contract's address, commonly needed for\n    /// access control or when interacting with other contracts.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The contract address of the current function being\n    ///                    executed.\n    ///\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    /// Returns the chain ID of the current network.\n    ///\n    /// This is similar to `block.chainid` in Solidity. Returns the unique\n    /// identifier for the blockchain network this transaction is executing on.\n    ///\n    /// Helps prevent cross-chain replay attacks. Useful if implementing\n    /// multi-chain contract logic.\n    ///\n    /// # Returns\n    /// * `Field` - The chain ID as a field element\n    ///\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    /// Returns the Aztec protocol version that this transaction is executing\n    /// under. Different versions may have different rules, opcodes, or\n    /// cryptographic primitives.\n    ///\n    /// This is similar to how Ethereum has different EVM versions.\n    ///\n    /// Useful for forward/backward compatibility checks\n    ///\n    /// Not to be confused with contract versions; this is the protocol version.\n    ///\n    /// # Returns\n    /// * `Field` - The protocol version as a field element\n    ///\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    /// Returns the gas settings for the current transaction.\n    ///\n    /// This provides information about gas limits and pricing for the\n    /// transaction, similar to `tx.gasprice` and gas limits in Ethereum.\n    /// However, Aztec has a more sophisticated gas model with separate\n    /// accounting for L2 computation and data availability (DA) costs.\n    ///\n    /// # Returns\n    /// * `GasSettings` - Struct containing gas limits and fee information\n    ///\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    /// Returns the function selector of the currently executing function.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to access this.\n    ///\n    /// This is similar to `msg.sig` in Solidity, which returns the first 4\n    /// bytes of the function signature. In Aztec, the selector uniquely\n    /// identifies which function within the contract is being called.\n    ///\n    /// # Returns\n    /// * `FunctionSelector` - The 4-byte function identifier\n    ///\n    /// # Advanced\n    /// Only #[external(\"private\")] functions have a function selector as a protocol-\n    /// enshrined concept. The function selectors of private functions are\n    /// baked into the preimage of the contract address, and are used by the\n    /// protocol's kernel circuits to identify each private function and ensure\n    /// the correct one is being executed.\n    ///\n    /// Used internally for function dispatch and call verification.\n    ///\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    ///\n    /// Very low-level function: You shouldn't need to call this. The #[external(\"private\")]\n    /// macro calls this, and it makes the arguments neatly available to the\n    /// body of your private function.\n    ///\n    /// # Returns\n    /// * `Field` - Hash of the function arguments\n    ///\n    /// # Advanced\n    /// * Arguments are hashed to reduce proof size and verification time\n    /// * Enables efficient argument passing in recursive function calls\n    /// * The hash can be used to retrieve the original arguments from the PXE.\n    ///\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    /// Pushes a new note_hash to the Aztec blockchain's global Note Hash Tree\n    /// (a state tree).\n    ///\n    /// A note_hash is a commitment to a piece of private state.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new note hashes.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The new note_hash.\n    ///\n    /// # Advanced\n    /// From here, the protocol's kernel circuits will take over and insert the\n    /// note_hash into the protocol's \"note hash tree\" (in the Base Rollup\n    /// circuit).\n    /// Before insertion, the protocol will:\n    /// - \"Silo\" the `note_hash` with the contract address of this function,\n    ///   to yield a `siloed_note_hash`. This prevents state collisions\n    ///   between different smart contracts.\n    /// - Ensure uniqueness of the `siloed_note_hash`, to prevent Faerie-Gold\n    ///   attacks, by hashing the `siloed_note_hash` with a unique value, to\n    ///   yield a `unique_siloed_note_hash` (see the protocol spec for more).\n    ///\n    /// In addition to calling this function, aztec-nr provides the contents\n    /// of the newly-created note to the PXE, via the `notify_created_note`\n    /// oracle.\n    ///\n    /// > Advanced users might occasionally wish to push data to the context\n    /// > directly for lower-level control. If you find yourself doing this,\n    /// > please open an issue on GitHub to describe your use case: it might be\n    /// > that new functionality should be added to aztec-nr.\n    ///\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(Counted::new(note_hash, self.next_counter()));\n    }\n\n    /// Pushes a new nullifier to the Aztec blockchain's global Nullifier Tree\n    /// (a state tree).\n    ///\n    /// See also: `push_nullifier_for_note_hash`.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifiers.\n    ///\n    /// A nullifier can only be emitted once. Duplicate nullifier insertions are\n    /// rejected by the protocol.\n    ///\n    /// Generally, a nullifier is emitted to prevent an action from happening\n    /// more than once, in such a way that the action cannot be linked (by an\n    /// observer of the blockchain) to any earlier transactions.\n    ///\n    /// I.e. a nullifier is a random-looking, but deterministic record of a\n    /// private, one-time action, which does not leak what action has been\n    /// taken, and which preserves the property of \"tx unlinkability\".\n    ///\n    /// Usually, a nullifier will be emitted to \"spend\" a note (a piece of\n    /// private state), without revealing which specific note is being spent.\n    ///\n    /// (Important: in such cases, use the below `push_nullifier_for_note_hash`).\n    ///\n    /// Sometimes, a nullifier might be emitted completely unrelated to any\n    /// notes. Examples include initialization of a new contract; initialization\n    /// of a PrivateMutable, or signalling in Semaphore-like applications.\n    /// This `push_nullifier` function serves such use cases.\n    ///\n    /// # Arguments\n    /// * `nullifier`\n    ///\n    /// # Advanced\n    /// From here, the protocol's kernel circuits will take over and insert the\n    /// nullifier into the protocol's \"nullifier tree\" (in the Base Rollup\n    /// circuit).\n    /// Before insertion, the protocol will:\n    /// - \"Silo\" the `nullifier` with the contract address of this function,\n    ///   to yield a `siloed_nullifier`. This prevents state collisions\n    ///   between different smart contracts.\n    /// - Ensure the `siloed_nullifier` is unique (the nullifier tree is an\n    ///   indexed merkle tree which supports efficient non-membership proofs).\n    ///\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: 0 }.count(self.next_counter()));\n    }\n\n    /// Pushes a nullifier that corresponds to a specific note hash.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifiers.\n    ///\n    /// This is a specialized version of `push_nullifier` that links a nullifier\n    /// to the specific note hash it's nullifying. This is the most common\n    /// usage pattern for nullifiers.\n    /// See `push_nullifier` for more explanation on nullifiers.\n    ///\n    /// # Arguments\n    /// * `nullifier`\n    /// * `nullified_note_hash` - The note hash of the note being nullified\n    ///\n    /// # Advanced\n    /// Important: usage of this function doesn't mean that the world will _see_\n    /// that this nullifier relates to the given nullified_note_hash (as that\n    /// would violate \"tx unlinkability\"); it simply informs the user's PXE\n    /// about the relationship (via `notify_nullified_note`). The PXE can then\n    /// use this information to feed hints to the kernel circuits for\n    /// \"squashing\" purposes: If a note is nullified during the same tx which\n    /// created it, we can \"squash\" (delete) the note and nullifier (and any\n    /// private logs associated with the note), to save on data emission costs.\n    ///\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash }.count(\n            nullifier_counter,\n        ));\n    }\n\n    /// Returns the anchor block header - the historical block header that this\n    /// private function is reading from.\n    ///\n    /// A private function CANNOT read from the \"current\" block header,\n    /// but must read from some older block header, because as soon as\n    /// private function execution begins (asynchronously, on a user's device),\n    /// the public state of the chain (the \"current state\") will have progressed\n    /// forward.\n    ///\n    /// # Returns\n    /// * `BlockHeader` - The anchor block header.\n    ///\n    /// # Advanced\n    /// * All private functions of a tx read from the same anchor block header.\n    /// * The protocol asserts that the `include_by_timestamp` of every tx\n    ///   is at most 24 hours beyond the timestamp of the tx's chosen anchor\n    ///   block header. This enables the network's nodes to safely prune old txs\n    ///   from the mempool. Therefore, the chosen block header _must_ be one\n    ///   from within the last 24 hours.\n    ///\n    pub fn get_anchor_block_header(self) -> BlockHeader {\n        self.anchor_block_header\n    }\n\n    /// Returns the header of any historical block at or before the anchor\n    /// block.\n    ///\n    /// This enables private contracts to access information from even older\n    /// blocks than the anchor block header.\n    ///\n    /// Useful for time-based contract logic that needs to compare against\n    /// multiple historical points.\n    ///\n    /// # Arguments\n    /// * `block_number` - The block number to retrieve (must be <= anchor\n    ///                    block number)\n    ///\n    /// # Returns\n    /// * `BlockHeader` - The header of the requested historical block\n    ///\n    /// # Advanced\n    /// This function uses an oracle to fetch block header data from the user's\n    /// PXE. Depending on how much blockchain data the user's PXE has been set\n    /// up to store, this might require a query from the PXE to another Aztec\n    /// node to get the data.\n    /// > This is generally true of all oracle getters (see `../oracle`).\n    ///\n    /// Each block header gets hashed and stored as a leaf in the protocol's\n    /// Archive Tree. In fact, the i-th block header gets stored at the i-th\n    /// leaf index of the Archive Tree. Behind the scenes, this\n    /// `get_block_header_at` function will add Archive Tree merkle-membership\n    /// constraints (~3k) to your smart contract function's circuit, to prove\n    /// existence of the block header in the Archive Tree.\n    ///\n    /// Note: we don't do any caching, so avoid making duplicate calls for the\n    /// same block header, because each call will add duplicate constraints.\n    ///\n    /// Calling this function is more expensive (constraint-wise) than getting\n    /// the anchor block header (via `get_block_header`). This is because the\n    /// anchor block's merkle membership proof is handled by Aztec's protocol\n    /// circuits, and is only performed once for the entire tx because all\n    /// private functions of a tx share a common anchor block header. Therefore,\n    /// the cost (constraint-wise) of calling `get_block_header` is effectively\n    /// free.\n    ///\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    /// Sets the hash of the return values for this private function.\n    ///\n    /// Very low-level function: this is called by the #[external(\"private\")] macro.\n    ///\n    /// # Arguments\n    /// * `serialized_return_values` - The serialized return values as a field array\n    ///\n    pub fn set_return_hash<let N: u32>(&mut self, serialized_return_values: [Field; N]) {\n        let return_hash = hash_args_array(serialized_return_values);\n        self.return_hash = return_hash;\n        execution_cache::store(serialized_return_values, return_hash);\n    }\n\n    /// Builds the PrivateCircuitPublicInputs for this private function, to\n    /// ensure compatibility with the protocol's kernel circuits.\n    ///\n    /// Very low-level function: This function is automatically called by the\n    /// #[external(\"private\")] macro.\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            include_by_timestamp: self.include_by_timestamp,\n            note_hash_read_requests: ClaimedLengthArray::from_bounded_vec(\n                self.note_hash_read_requests,\n            ),\n            nullifier_read_requests: ClaimedLengthArray::from_bounded_vec(\n                self.nullifier_read_requests,\n            ),\n            key_validation_requests_and_generators: ClaimedLengthArray::from_bounded_vec(\n                self.key_validation_requests_and_generators,\n            ),\n            note_hashes: ClaimedLengthArray::from_bounded_vec(self.note_hashes),\n            nullifiers: ClaimedLengthArray::from_bounded_vec(self.nullifiers),\n            private_call_requests: ClaimedLengthArray::from_bounded_vec(self.private_call_requests),\n            public_call_requests: ClaimedLengthArray::from_bounded_vec(self.public_call_requests),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: ClaimedLengthArray::from_bounded_vec(self.l2_to_l1_msgs),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: ClaimedLengthArray::from_bounded_vec(self.private_logs),\n            contract_class_logs_hashes: ClaimedLengthArray::from_bounded_vec(\n                self.contract_class_logs_hashes,\n            ),\n            anchor_block_header: self.anchor_block_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    /// Designates this contract as the fee payer for the transaction.\n    ///\n    /// Unlike Ethereum, where the transaction sender always pays fees, Aztec\n    /// allows any contract to voluntarily pay transaction fees. This enables\n    /// patterns like sponsored transactions or fee abstraction where users\n    /// don't need to hold fee-juice themselves. (Fee juice is a fee-paying\n    /// asset for Aztec).\n    ///\n    /// Only one contract per transaction can declare itself as the fee payer,\n    /// and it must have sufficient fee-juice balance (>= the gas limits\n    /// specified in the TxContext) by the time we reach the public setup phase\n    /// of the tx.\n    ///\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    /// Declares the end of the \"setup phase\" of this tx.\n    ///\n    /// Only one function per tx can declare the end of the setup phase.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase enables such a payment to\n    /// be made, because the setup phase _cannot revert_: a reverting function\n    /// within the setup phase would result in an invalid block which cannot\n    /// be proven. Any side-effects generated during that phase are guaranteed\n    /// to be inserted into Aztec's state trees (except for squashed notes &\n    /// nullifiers, of course).\n    ///\n    /// Even though the end of the setup phase is declared within a private\n    /// function, you might have noticed that _public_ functions can also\n    /// execute within the setup phase. This is because any public function\n    /// calls which were enqueued _within the setup phase_ by a private\n    /// function are considered part of the setup phase.\n    ///\n    /// # Advanced\n    /// * Sets the minimum revertible side effect counter of this tx to be the\n    /// PrivateContext's _current_ side effect counter.\n    ///\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    /// Sets a deadline (an \"include-by timestamp\") for when this transaction\n    /// must be included in a block.\n    ///\n    /// Other functions in this tx might call this setter with differing\n    /// values for the include-by timestamp. To ensure that all functions'\n    /// deadlines are met, the _minimum_ of all these include-by timestamps will\n    /// be exposed when this tx is submitted to the network.\n    ///\n    /// If the transaction is not included in a block by its include-by\n    /// timestamp, it becomes invalid and it will never be included.\n    ///\n    /// This expiry timestamp is publicly visible. See the \"Advanced\" section\n    /// for privacy concerns.\n    ///\n    /// # Arguments\n    /// * `include_by_timestamp` - Unix timestamp (seconds) deadline for inclusion.\n    ///                            The include-by timestamp of this tx will be\n    ///                            _at most_ the timestamp specified.\n    ///\n    /// # Advanced\n    /// * If multiple functions set differing `include_by_timestamp`s, the\n    ///   kernel circuits will set it to be the _minimum_ of the two. This\n    ///   ensures the tx expiry requirements of all functions in the tx are met.\n    /// * Rollup circuits will reject expired txs.\n    /// * The protocol enforces that all transactions must be included within\n    ///   24 hours of their chosen anchor block's timestamp, to enable safe\n    ///   mempool pruning.\n    /// * The DelayedPublicMutable design makes heavy use of this functionality,\n    ///   to enable private functions to read public state.\n    /// * A sophisticated Wallet should cleverly set an include-by timestamp\n    ///   to improve the privacy of the user and the network as a whole.\n    ///   For example, if a contract interaction sets include-by to some\n    ///   publicly-known value (e.g. the time when a contract upgrades), then\n    ///   the wallet might wish to set an even lower one to avoid revealing that\n    ///   this tx is interacting with said contract.\n    ///   Ideally, all wallets should standardise on an approach in order to\n    ///   provide users with a large anonymity set -- although the exact apprach\n    ///   will need to be discussed. Wallets that deviate from a standard might\n    ///   accidentally reveal which wallet each transaction originates from.\n    ///\n    // docs:start:include-by-timestamp\n    pub fn set_include_by_timestamp(&mut self, include_by_timestamp: u64) {\n        // docs:end:include-by-timestamp\n        self.include_by_timestamp = std::cmp::min(self.include_by_timestamp, include_by_timestamp);\n    }\n\n    /// Makes a request to the protocol's kernel circuit to ensure a note_hash\n    /// actually exists.\n    ///\n    /// \"Read requests\" are used to prove that a note hash exists without\n    /// revealing which specific note was read.\n    ///\n    /// This can be used to prove existence of both settled notes (created in\n    /// prior transactions) and transient notes (created in the current\n    /// transaction).\n    /// If you need to prove existence of a settled note _at a specific block\n    /// number_, use `note_inclusion::prove_note_inclusion`.\n    ///\n    /// Low-level function. Ordinarily, smart contract developers will not need\n    /// to call this directly. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new note_hash read\n    /// requests.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The note hash to read and verify\n    ///\n    /// # Advanced\n    /// In \"traditional\" circuits for non-Aztec privacy applications, the merkle\n    /// membership proofs to check existence of a note are performed _within_\n    /// the application circuit.\n    ///\n    /// All Aztec private functions have access to the following constraint\n    /// optimisation:\n    /// In cases where the note being read was created earlier in the same tx,\n    /// the note wouldn't yet exist in the Note Hash Tree, so a hard-coded\n    /// merkle membership check which then gets ignored would be a waste of\n    /// constraints.\n    /// Instead, we can send read requests for all notes to the protocol's\n    /// kernel circuits, where we can conditionally assess which notes actually\n    /// need merkle membership proofs, and select an appropriately-sized\n    /// kernel circuit.\n    ///\n    /// For \"settled notes\" (which already existed in the Note Hash Tree of the\n    /// anchor block (i.e. before the tx began)), the kernel does a merkle\n    /// membership check.\n    ///\n    /// For \"pending notes\" (which were created earlier in _this_ tx), the\n    /// kernel will check that the note existed _before_ this read request was\n    /// made, by checking the side-effect counters of the note_hash and this\n    /// read request.\n    ///\n    /// This approach improves latency between writes and reads:\n    /// a function can read a note which was created earlier in the tx (rather\n    /// than performing the read in a later tx, after waiting for the earlier tx\n    /// to be included, to ensure the note is included in the tree).\n    ///\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = Counted::new(note_hash, self.next_counter());\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    /// Requests to read a specific nullifier from the nullifier tree.\n    ///\n    /// Nullifier read requests are used to prove that a nullifier exists without\n    /// revealing which specific nullifier preimage was read.\n    ///\n    /// This can be used to prove existence of both settled nullifiers (created in\n    /// prior transactions) and transient nullifiers (created in the current\n    /// transaction).\n    /// If you need to prove existence of a settled nullifier _at a specific block\n    /// number_, use `nullifier_inclusion::prove_nullifier_inclusion`.\n    ///\n    /// Low-level function. Ordinarily, smart contract developers will not need\n    /// to call this directly. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifier read\n    /// requests.\n    ///\n    /// # Arguments\n    /// * `nullifier` - The nullifier to read and verify\n    ///\n    /// # Advanced\n    /// This approach improves latency between writes and reads:\n    /// a function can read a nullifier which was created earlier in the tx\n    /// (rather than performing the read in a later tx, after waiting for the\n    /// earlier tx to be included, to ensure the note is included in the tree).\n    ///\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = Counted::new(nullifier, self.next_counter());\n        self.nullifier_read_requests.push(request);\n    }\n\n    /// Requests the app-siloed nullifier secret key (nsk_app) for the given\n    /// (hashed) master nullifier public key (npk_m), from the user's PXE.\n    ///\n    /// Advanced function: Only needed if you're designing your own notes and/or\n    /// nullifiers.\n    ///\n    /// Contracts are not allowed to compute nullifiers for other contracts, as\n    /// that would let them read parts of their private state. Because of this,\n    /// a contract is only given an \"app-siloed secret key\", which is\n    /// constructed by hashing the user's master nullifier secret key with the\n    /// contract's address.\n    /// However, because contracts cannot be trusted with a user's master\n    /// nullifier secret key (because we don't know which contracts are honest\n    /// or malicious), the PXE refuses to provide any master secret keys to\n    /// any app smart contract function. This means app functions are unable to\n    /// prove that the derivation of an app-siloed nullifier secret key has been\n    /// computed correctly. Instead, an app function can request to the kernel\n    /// (via `request_nsk_app`) that it validates the siloed derivation, since\n    /// the kernel has been vetted to not leak any master secret keys.\n    ///\n    /// A common nullification scheme is to inject a nullifier secret key into\n    /// the preimage of a nullifier, to make the nullifier deterministic but\n    /// random-looking. This function enables that flow.\n    ///\n    /// # Arguments\n    /// * `npk_m_hash` - A hash of the master nullifier public key of the user\n    ///                  whose PXE is executing this function.\n    ///\n    /// # Returns\n    /// * The app-siloed nullifier secret key that corresponds to the given\n    ///   `npk_m_hash`.\n    ///\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    /// Requests the app-siloed nullifier secret key (nsk_app) for the given\n    /// (hashed) master nullifier public key (npk_m), from the user's PXE.\n    ///\n    /// See `request_nsk_app` and `request_sk_app` for more info.\n    ///\n    /// The intention of the \"outgoing\" keypair is to provide a second secret\n    /// key for all of a user's outgoing activity (i.e. for notes that a user\n    /// creates, as opposed to notes that a user receives from others). The\n    /// separation of incoming and outgoing data was a distinction made by\n    /// zcash, with the intention of enabling a user to optionally share with a\n    /// 3rd party a controlled view of only incoming or outgoing notes.\n    /// Similar functionality of sharing select data can be achieved with\n    /// offchain zero-knowledge proofs. It is up to an app developer whether\n    /// they choose to make use of a user's outgoing keypair within their\n    /// application logic, or instead simply use the same keypair (the address\n    /// keypair (which is effectively the same as the \"incooming\" keypair)) for\n    /// all incoming & outgoing messages to a user.\n    ///\n    /// Currently, all of the exposed encryption functions in aztec-nr ignore\n    /// the outgoing viewing keys, and instead encrypt all note logs and event\n    /// logs to a user's address public key.\n    ///\n    /// # Arguments\n    /// * `ovpk_m_hash` - Hash of the outgoing viewing public key master\n    ///\n    /// # Returns\n    /// * The application-specific outgoing viewing secret key\n    ///\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    /// Pushes a Key Validation Request to the kernel.\n    ///\n    /// Private functions are not allowed to see a user's master secret keys,\n    /// because we do not trust them. They are instead given \"app-siloed\" secret\n    /// keys with a claim that they relate to a master public key.\n    /// They can then request validation of this claim, by making a \"key\n    /// validation request\" to the protocol's kernel circuits (which _are_\n    /// allowed to see certain master secret keys).\n    ///\n    /// When a Key Validation Request tuple of (sk_app, Pk_m, app_address) is\n    /// submitted to the kernel, it will perform the following derivations\n    /// to validate the relationship between the claimed sk_app and the user's\n    /// Pk_m:\n    ///\n    ///       (sk_m) ----> * G ----> Pk_m\n    ///         |                     |\n    ///         v                       We use the kernel to prove this\n    ///  h(sk_m, app_address)         | sk_app-Pk_m relationship, because app\n    ///         |                       circuits must not be trusted to see sk_m.\n    ///         v                     |\n    ///      sk_app - -  - - - - - - -\n    ///\n    /// The function is named \"request_\" instead of \"get_\" to remind the user\n    /// that a Key Validation Request will be emitted to the kernel.\n    ///\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    /// Sends an \"L2 -> L1 message\" from this function (Aztec, L2) to a smart\n    /// contract on Ethereum (L1). L1 contracts which are designed to\n    /// send/receive messages to/from Aztec are called \"Portal Contracts\".\n    ///\n    /// Common use cases include withdrawals, cross-chain asset transfers, and\n    /// triggering L1 actions based on L2 state changes.\n    ///\n    /// The message will be inserted into an Aztec \"Outbox\" contract on L1,\n    /// when this transaction's block is proposed to L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target portal contract. The message will need to be manually\n    /// consumed from the Outbox through a separate Ethereum transaction: a user\n    /// will need to call a function of the portal contract -- a function\n    /// specifically designed to make a call to the Outbox to consume the\n    /// message.\n    /// The message will only be available for consumption once the _epoch_\n    /// proof has been submitted. Given that there are multiple Aztec blocks\n    /// within an epoch, it might take some time for this epoch proof to be\n    /// submitted -- especially if the block was near the start of an epoch.\n    ///\n    /// # Arguments\n    /// * `recipient` - Ethereum address that will receive the message\n    /// * `content` - Message content (32 bytes as a Field element).\n    ///               This content has a very specific layout.\n    /// docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        let message = L2ToL1Message { recipient, content };\n        self.l2_to_l1_msgs.push(message.count(self.next_counter()));\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2).\n    ///\n    /// Common use cases include token bridging, cross-chain governance, and\n    /// triggering L2 actions based on L1 events.\n    ///\n    /// Use this function if you only want the message to ever be \"referred to\"\n    /// once. Once consumed using this method, the message cannot be consumed\n    /// again, because a nullifier is emitted.\n    /// If your use case wants for the message to be read unlimited times, then\n    /// you can always read any historic message from the L1-to-L2 messages tree;\n    /// messages never technically get deleted from that tree.\n    ///\n    /// The message will first be inserted into an Aztec \"Inbox\" smart contract\n    /// on L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target L2 contract. The message will need to be manually\n    /// consumed by the target contract through a separate Aztec transaction.\n    /// The message will not be available for consumption immediately. Messages\n    /// get copied over from the L1 Inbox to L2 by the next Proposer in batches.\n    /// So you will need to wait until the messages are copied before you can\n    /// consume them.\n    ///\n    /// # Arguments\n    /// * `content` - The message content that was sent from L1\n    /// * `secret` - Secret value used for message privacy (if needed)\n    /// * `sender` - Ethereum address that sent the message\n    /// * `leaf_index` - Index of the message in the L1-to-L2 message tree\n    ///\n    /// # Advanced\n    /// Validates message existence in the L1-to-L2 message tree and nullifies\n    /// the message to prevent double-consumption.\n    ///\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let nullifier = process_l1_to_l2_message(\n            self.anchor_block_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n\n    /// Emits a private log (an array of Fields) that will be published to an\n    /// Ethereum blob.\n    ///\n    /// Private logs are intended for the broadcasting of ciphertexts: that is,\n    /// encrypted events or encrypted note contents.\n    /// Since the data in the logs is meant to be _encrypted_, private_logs are\n    /// broadcast to publicly-visible Ethereum blobs.\n    /// The intended recipients of such encrypted messages can then discover and\n    /// decrypt these encrypted logs using their viewing secret key.\n    /// (See `../messages/discovery` for more details).\n    ///\n    /// Important note: This function DOES NOT _do_ any encryption of the input\n    /// `log` fields. This function blindly publishes whatever input `log` data\n    /// is fed into it, so the caller of this function should have already\n    /// performed the encryption, and the `log` should be the result of that\n    /// encryption.\n    ///\n    /// The protocol does not dictate what encryption scheme should be used:\n    /// a smart contract developer can choose whatever encryption scheme they\n    /// like.\n    /// Aztec-nr includes some off-the-shelf encryption libraries that\n    /// developers might wish to use, for convenience. These libraries not only\n    /// encrypt a plaintext (to produce a ciphertext); they also prepend the\n    /// ciphertext with a `tag` and `ephemeral public key` for easier message\n    /// discovery. This is a very dense topic, and we will be writing more\n    /// libraries and docs soon.\n    ///\n    /// > Currently, AES128 CBC encryption is the main scheme included in\n    /// > aztec.nr.\n    /// > We are currently making significant changes to the interfaces of the\n    /// > encryption library.\n    ///\n    /// In some niche use cases, an app might be tempted to publish\n    /// _un-encrypted_ data via a private log, because _public logs_ are not\n    /// available to private functions. Be warned that emitting public data via\n    /// private logs is strongly discouraged, and is considered a \"privacy\n    /// anti-pattern\", because it reveals identifiable information about _which_\n    /// function has been executed. A tx which leaks such information does not\n    /// contribute to the privacy set of the network.\n    ///\n    /// * Unlike `emit_raw_note_log`, this log is not tied to any specific note\n    ///\n    /// # Arguments\n    /// * `log` - The log data that will be publicly broadcast (so make sure\n    ///           it's already been encrypted before you call this function).\n    ///   Private logs are bounded in size (PRIVATE_LOG_SIZE_IN_FIELDS), to\n    ///   encourage all logs from all smart contracts look identical.\n    /// * `length` - The actual length of the `log` (measured in number of\n    ///              Fields). Although the input log has a max size of\n    ///   PRIVATE_LOG_SIZE_IN_FIELDS, the latter values of the array might all\n    ///   be 0's for small logs. This `length` should reflect the trimmed length\n    ///   of the array. The protocol's kernel circuits can then append random\n    ///   fields as \"padding\" after the `length`, so that the logs of this\n    ///   smart contract look indistinguishable from (the same length as) the\n    ///   logs of all other applications. It's up to wallets how much padding\n    ///   to apply, so ideally all wallets should agree on standards for this.\n    ///\n    /// # Advanced\n    ///\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS], length: u32) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter: 0 }\n            .count(counter);\n        self.private_logs.push(private_log);\n    }\n\n    // TODO: rename.\n    /// Emits a private log that is explicitly tied to a newly-emitted note_hash,\n    /// to convey to the kernel: \"this log relates to this note\".\n    ///\n    /// This linkage is important in case the note gets squashed (due to being\n    /// read later in this same tx), since we can then squash the log as well.\n    ///\n    /// See `emit_private_log` for more info about private log emission.\n    ///\n    /// # Arguments\n    /// * `log` - The log data as an array of Field elements\n    /// * `length` - The actual length of the `log` (measured in number of\n    ///              Fields).\n    /// * `note_hash_counter` - The side-effect counter that was assigned to the\n    ///                         new note_hash when it was pushed to this\n    //                          `PrivateContext`.\n    ///\n    /// Important: If your application logic requires the log to always be\n    /// emitted regardless of note squashing, consider using `emit_private_log`\n    /// instead, or emitting additional events.\n    ///\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        length: u32,\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter };\n        self.private_logs.push(private_log.count(counter));\n    }\n\n    pub fn emit_contract_class_log<let N: u32>(&mut self, log: [Field; N]) {\n        let contract_address = self.this_address();\n        let counter = self.next_counter();\n\n        let log_to_emit: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS] =\n            log.concat([0; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS - N]);\n        // Note: the length is not always N, it is the number of fields we want to broadcast, omitting trailing zeros to save blob space.\n        // Safety: The below length is constrained in the base rollup, which will make sure that all the fields beyond length are zero.\n        // However, it won't be able to check that we didn't add extra padding (trailing zeroes)\n        let length = unsafe { trimmed_array_length_hint(log_to_emit) };\n        // We hash the entire padded log to ensure a user cannot pass a shorter length and so emit incorrect shorter bytecode.\n        let log_hash = poseidon2_hash(log_to_emit);\n        // Safety: the below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\n        unsafe {\n            notify_created_contract_class_log(contract_address, log_to_emit, length, counter);\n        }\n\n        self.contract_class_logs_hashes.push(LogHash { value: log_hash, length: length }.count(\n            counter,\n        ));\n    }\n\n    /// Calls a private function on another contract (or the same contract).\n    ///\n    /// Very low-level function.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the called function\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    /// This enables contracts to interact with each other while maintaining\n    /// privacy. This \"composability\" of private contract functions is a key\n    /// feature of the Aztec network.\n    ///\n    /// If a user's transaction includes multiple private function calls, then\n    /// by the design of Aztec, the following information will remain private[1]:\n    /// - The function selectors and contract addresses of all private function\n    ///   calls will remain private, so an observer of the public mempool will\n    ///   not be able to look at a tx and deduce which private functions have\n    ///   been executed.\n    /// - The arguments and return values of all private function calls will\n    ///   remain private.\n    /// - The person who initiated the tx will remain private.\n    /// - The notes and nullifiers and private logs that are emitted by all\n    ///   private function calls will (if designed well) not leak any user\n    ///   secrets, nor leak which functions have been executed.\n    ///\n    /// [1] Caveats: Some of these privacy guarantees depend on how app\n    /// developers design their smart contracts. Some actions _can_ leak\n    /// information, such as:\n    /// - Calling an internal public function.\n    /// - Calling a public function and not setting msg_sender to Option::none\n    ///   (feature not built yet - see github).\n    /// - Calling any public function will always leak details about the nature\n    ///   of the transaction, so devs should be careful in their contract\n    ///   designs. If it can be done in a private function, then that will give\n    ///   the best privacy.\n    /// - Not padding the side-effects of a tx to some standardised, uniform\n    ///   size. The kernel circuits can take hints to pad side-effects, so a\n    ///   wallet should be able to request for a particular amount of padding.\n    ///   Wallets should ideally agree on some standard.\n    ///   - Padding should include:\n    ///     - Padding the lengths of note & nullifier arrays\n    ///     - Padding private logs with random fields, up to some standardised\n    ///       size.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Advanced\n    /// * The call is added to the private call stack and executed by kernel\n    ///   circuits after this function completes\n    /// * The called function can modify its own contract's private state\n    /// * Side effects from the called function are included in this transaction\n    /// * The call inherits the current transaction's context and gas limits\n    ///\n    pub fn call_private_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    /// Makes a read-only call to a private function on another contract.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L2 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// See `call_private_function` for more general info on private function\n    /// calls.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the called function\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn static_call_private_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    /// Calls a private function that takes no arguments.\n    ///\n    /// This is a convenience function for calling private functions that don't\n    /// require any input parameters. It's equivalent to `call_private_function`\n    /// but slightly more efficient to use when no arguments are needed.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    /// Makes a read-only call to a private function which takes no arguments.\n    ///\n    /// This combines the optimisation of `call_private_function_no_args` with\n    /// the safety of `static_call_private_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    /// Low-level private function call.\n    ///\n    /// This is the underlying implementation used by all other private function\n    /// call methods. Instead of taking raw arguments, it accepts a\n    /// hash of the arguments.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args_hash` - Pre-computed hash of the function arguments\n    /// * `is_static_call` - Whether this should be a read-only call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values\n    ///\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1; // TODO: call `next_counter` instead, for consistency\n        ReturnsHash::new(returns_hash)\n    }\n\n    /// Enqueues a call to a public function to be executed later.\n    ///\n    /// Unlike private functions which execute immediately on the user's device,\n    /// public function calls are \"enqueued\" and executed some time later by a\n    /// block proposer.\n    ///\n    /// This means a public function cannot return any values back to a private\n    /// function, because by the time the public function is being executed,\n    /// the private function which called it has already completed execution.\n    /// (In fact, the private function has been executed and proven, along with\n    /// all other private function calls of the user's tx. A single proof of the\n    /// tx has been submitted to the Aztec network, and some time later a\n    /// proposer has picked the tx up from the mempool and begun executing all\n    /// of the enqueued public functions).\n    ///\n    /// # Privacy warning\n    /// Enqueueing a public function call is an inherently leaky action.\n    /// Many interesting applications will require some interaction with public\n    /// state, but smart contract developers should try to use public function\n    /// calls sparingly, and carefully.\n    /// _Internal_ public function calls are especially leaky, because they\n    /// completely leak which private contract made the call.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the public function\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn call_public_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n        hide_msg_sender: bool,\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a read-only call to a public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// See also `call_public_function` for more important information about\n    /// making private -> public function calls.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the public function\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn static_call_public_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n        hide_msg_sender: bool,\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            true,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a call to a public function that takes no arguments.\n    ///\n    /// This is an optimisation for calling public functions that don't\n    /// take any input parameters. It's otherwise equivalent to\n    /// `call_public_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        hide_msg_sender: bool,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a read-only call to a public function with no arguments.\n    ///\n    /// This combines the optimisation of `call_public_function_no_args` with\n    /// the safety of `static_call_public_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        hide_msg_sender: bool,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            true,\n            hide_msg_sender,\n        )\n    }\n\n    /// Low-level public function call.\n    ///\n    /// This is the underlying implementation used by all other public function\n    /// call methods. Instead of taking raw arguments, it accepts a\n    /// hash of the arguments.\n    ///\n    /// Advanced function: Most developers should use `call_public_function`\n    /// or `static_call_public_function` instead. This function is exposed for\n    /// performance optimization and advanced use cases.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `calldata_hash` - Hash of the function calldata\n    /// * `is_static_call` - Whether this should be a read-only call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n        hide_msg_sender: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let msg_sender = if hide_msg_sender {\n            NULL_MSG_SENDER_CONTRACT_ADDRESS\n        } else {\n            self.this_address()\n        };\n\n        let call_request =\n            PublicCallRequest { msg_sender, contract_address, is_static_call, calldata_hash };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    /// Enqueues a public function call, and designates it to be the teardown\n    /// function for this tx. Only one teardown function call can be made by a\n    /// tx.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase ensures the fee payer\n    /// has sufficient balance to pay the proposer their fees.\n    /// The teardown phase is primarily intended to: calculate exactly\n    /// how much the user owes, based on gas consumption, and refund the user\n    /// any change.\n    ///\n    /// Note: in some cases, the cost of refunding the user (i.e. DA costs of\n    /// tx side-effects) might exceed the refund amount. For app logic with\n    /// fairly stable and predictable gas consumption, a material refund amount\n    /// is unlikely. For app logic with unpredictable gas consumption, a\n    /// refund might be important to the user (e.g. if a hefty function reverts\n    /// very early). Wallet/FPC/Paymaster developers should be mindful of this.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the teardown\n    ///                        function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - An array of fields to pass to the function.\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    pub fn set_public_teardown_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n        hide_msg_sender: bool,\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n\n    /// Low-level function to set the public teardown function.\n    ///\n    /// This is the underlying implementation for setting the teardown function\n    /// call that will execute at the end of the transaction. Instead of taking\n    /// raw arguments, it accepts a hash of the arguments.\n    ///\n    /// Advanced function: Most developers should use\n    /// `set_public_teardown_function` instead.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the teardown\n    ///                        function\n    /// * `calldata_hash` - Hash of the function calldata\n    /// * `is_static_call` - Whether this should be a read-only call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n        hide_msg_sender: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let msg_sender = if hide_msg_sender {\n            NULL_MSG_SENDER_CONTRACT_ADDRESS\n        } else {\n            self.this_address()\n        };\n\n        self.public_teardown_call_request =\n            PublicCallRequest { msg_sender, contract_address, is_static_call, calldata_hash };\n    }\n\n    /// Increments the side-effect counter.\n    ///\n    /// Very low-level function.\n    ///\n    /// # Advanced\n    ///\n    /// Every side-effect of a private function is given a \"side-effect counter\",\n    /// based on when it is created. This PrivateContext is in charge of\n    /// assigning the counters.\n    ///\n    /// The reason we have side-effect counters is complicated. Consider this\n    /// illustrative pseudocode of inter-contract function calls:\n    /// ```\n    /// contract A {\n    ///    let x = 5; // pseudocode for storage var x.\n    ///    fn a1 {\n    ///        read x; // value: 5, counter: 1.\n    ///        x = x + 1;\n    ///        write x; // value: 6, counter: 2.\n    ///\n    ///        B.b(); // start_counter: 2, end_counter: 4\n    ///\n    ///        read x; // value: 36, counter: 5.\n    ///        x = x + 1;\n    ///        write x; // value: 37, counter: 6.\n    ///    }\n    ///\n    ///    fn a2 {\n    ///        read x; // value: 6, counter: 3.\n    ///        x = x * x;\n    ///        write x; // value: 36, counter: 4.\n    ///    }\n    /// }\n    ///\n    /// contract B {\n    ///     fn b() {\n    ///         A.a2();\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// Suppose a1 is the first function called. The comments show the execution\n    /// counter of each side-effect, and what the new value of `x` is.\n    ///\n    /// These (private) functions are processed by Aztec's kernel circuits in an\n    /// order that is different from execution order:\n    /// All of A.a1 is proven before B.b is proven, before A.a2 is proven.\n    /// So when we're in the 2nd execution frame of A.a1 (after the call to\n    /// B.b), the circuit needs to justify why x went from being `6` to `36`.\n    /// But the circuit doesn't know why, and given the order of proving, the\n    /// kernel hasn't _seen_ a value of 36 get written yet.\n    /// The kernel needs to track big arrays of all side-effects of all\n    /// private functions in a tx. Then, as it recurses and processes B.b(), it\n    /// will eventually see a value of 36 get written.\n    ///\n    /// Suppose side-effect counters weren't exposed:\n    /// The kernel would only see this ordering (in order of proof verification):\n    /// [ A.a1.read, A.a1.write, A.a1.read, A.a1.write, A.a2.read, A.a2.write ]\n    /// [         5,          6,        36,         37,         6,         36 ]\n    /// The kernel wouldn't know _when_ B.b() was called within A.a1(), because\n    /// it can't see what's going on within an app circuit. So the kernel\n    /// wouldn't know that the ordering of reads and writes should actually be:\n    /// [ A.a1.read, A.a1.write, A.a2.read, A.a2.write, A.a1.read, A.a1.write ]\n    /// [         5,          6,        6,         36,         36,         37 ]\n    ///\n    /// And so, we introduced side-effect counters: every private function must\n    /// assign side-effect counters alongside every side-effect that it emits,\n    /// and also expose to the kernel the counters that it started and ended\n    /// with.\n    /// This gives the kernel enough information to arrange all side-effects in\n    /// the correct order.\n    /// It can then catch (for example) if a function tries to read state\n    /// before it has been written (e.g. if A.a2() maliciously tried to read\n    /// a value of x=37) (e.g. if A.a1() maliciously tried to read x=6).\n    ///\n    /// If a malicious app contract _lies_ and does not count correctly:\n    /// - It cannot lie about its start and end counters because the kernel\n    ///   will catch this.\n    /// - It _could_ lie about its intermediate counters:\n    ///   - 1. It could not increment its side-effects correctly\n    ///   - 2. It could label its side-effects with counters outside of its\n    ///        start and end counters' range.\n    ///   The kernel will catch 2.\n    ///   The kernel will not catch 1., but this would only cause corruption\n    ///   to the private state of the malicious contract, and not any other\n    ///   contracts (because a contract can only modify its own state). If\n    ///   a \"good\" contract is given _read access_ to a maliciously-counting\n    ///   contract (via an external getter function, or by reading historic\n    ///   state from the archive tree directly), and they then make state\n    ///   changes to their _own_ state accordingly, that could be dangerous.\n    ///   Developers should be mindful not to trust the claimed innards of\n    ///   external contracts unless they have audited/vetted the contracts\n    ///   including vetting the side-effect counter incrementation.\n    ///   This is a similar paradigm to Ethereum smart contract development:\n    ///   you must vet external contracts that your contract relies upon, and\n    ///   you must not make any presumptions about their claimed behaviour.\n    ///   (Hopefully if a contract imports a version of aztec-nr, we will get\n    ///   contract verification tooling that can validate the authenticity\n    ///   of the imported aztec-nr package, and hence infer that the side-\n    ///   effect counting will be correct, without having to re-audit such logic\n    ///   for every contract).\n    ///\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            include_by_timestamp: 0,\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            anchor_block_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "71": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::{MAX_U32_VALUE, NULL_MSG_SENDER_CONTRACT_ADDRESS};\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\n/// # PublicContext\n///\n/// The **main interface** between an #[external(\"public\")] function and the Aztec blockchain.\n///\n/// An instance of the PublicContext is initialized automatically at the outset\n/// of every public function, within the #[external(\"public\")] macro, so you'll never\n/// need to consciously instantiate this yourself.\n///\n/// The instance is always named `context`, and it will always be available\n/// within the body of every #[external(\"public\")] function in your smart contract.\n///\n/// Typical usage for a smart contract developer will be to call getter\n/// methods of the PublicContext.\n///\n/// _Pushing_ data and requests to the context is mostly handled within\n/// aztec-nr's own functions, so typically a smart contract developer won't\n/// need to call any setter methods directly.\n///\n/// ## Responsibilities\n/// - Exposes contextual data to a public function:\n///   - Data relating to how this public function was called:\n///     - msg_sender, this_address\n///   - Data relating to the current blockchain state:\n///     - timestamp, block_number, chain_id, version\n///   - Gas and fee information\n/// - Provides state access:\n///   - Read/write public storage (key-value mapping)\n///   - Check existence of notes and nullifiers\n///     (Some patterns use notes & nullifiers to store public (not private)\n///     information)\n///   - Enables consumption of L1->L2 messages.\n/// - Enables calls to other public smart contract functions:\n/// - Writes data to the blockchain:\n///   - Updates to public state variables\n///   - New public logs (for events)\n///   - New L2->L1 messages\n///   - New notes & nullifiers\n///     (E.g. pushing public info to notes/nullifiers, or for completing\n///     \"partial notes\")\n///\n/// ## Key Differences from Private Execution\n///\n/// Unlike private functions -- which are executed on the user's device and which\n/// can only reference historic state -- public functions are executed by a block\n/// proposer and are executed \"live\" on the _current_ tip of the chain.\n/// This means public functions can:\n/// - Read and write _current_ public state\n/// - Immediately see the effects of earlier transactions in the same block\n///\n/// Also, public functions are executed within a zkVM (the \"AVM\"), so that they\n/// can _revert_ whilst still ensuring payment to the proposer and prover.\n/// (Private functions cannot revert: they either succeed, or they cannot be\n/// included).\n///\n/// ## Optimising Public Functions\n///\n/// Using the AVM to execute public functions means they compile down to \"AVM\n/// bytecode\" instead of the ACIR that private functions (standalone circuits)\n/// compile to. Therefore the approach to optimising a public function is\n/// fundamentally different from optimising a public function.\n///\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl Eq for PublicContext {\n    fn eq(self, other: Self) -> bool {\n        (self.args_hash == other.args_hash)\n        // Can't compare the function compute_args_hash\n    }\n}\n\nimpl PublicContext {\n    /// Creates a new PublicContext instance.\n    ///\n    /// Low-level function: This is called automatically by the #[external(\"public\")]\n    /// macro, so you shouldn't need to be called directly by smart contract\n    /// developers.\n    ///\n    /// # Arguments\n    /// * `compute_args_hash` - Function to compute the args_hash\n    ///\n    /// # Returns\n    /// * A new PublicContext instance\n    ///\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    /// Emits a _public_ log that will be visible onchain to everyone.\n    ///\n    /// # Arguments\n    /// * `log` - The data to log, must implement Serialize trait\n    ///\n    pub fn emit_public_log<T>(_self: &mut Self, log: T)\n    where\n        T: Serialize,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    /// Checks if a given note hash exists in the note hash tree at a particular\n    /// leaf_index.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The note hash to check for existence\n    /// * `leaf_index` - The index where the note hash should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the note hash exists at the specified index\n    ///\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: u64) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    /// Checks if a specific L1-to-L2 message exists in the L1-to-L2 message\n    /// tree at a particular leaf index.\n    ///\n    /// Common use cases include token bridging, cross-chain governance, and\n    /// triggering L2 actions based on L1 events.\n    ///\n    /// This function should be called before attempting to consume an L1-to-L2\n    /// message.\n    ///\n    /// # Arguments\n    /// * `msg_hash` - Hash of the L1-to-L2 message to check\n    /// * `msg_leaf_index` - The index where the message should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the message exists at the specified index\n    ///\n    /// # Advanced\n    /// * Uses the AVM l1_to_l2_msg_exists opcode for tree lookup\n    /// * Messages are copied from L1 Inbox to L2 by block proposers\n    ///\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        // TODO(alvaro): Make l1l2msg leaf index a u64 upstream\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index as u64) } == 1\n    }\n\n    /// Checks if a specific nullifier has been emitted by a given contract.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. An example is to check\n    /// whether a contract has been published: we emit a nullifier that is\n    /// deterministic, but whose preimage is _not_ private. This is more\n    /// efficient than using mutable storage, and can be done directly\n    /// from a private function.\n    ///\n    /// Nullifiers can be tested for non-existence in public, which is not the\n    /// case in private. Because private functions do not have access to\n    /// the tip of the blockchain (but only the anchor block they are built\n    /// at) they can only prove nullifier non-existence in the past. But between\n    /// an anchor block and the block in which a tx is included, the nullifier\n    /// might have been inserted into the nullifier tree by some other\n    /// transaction.\n    /// Public functions _do_ have access to the tip of the state, and so\n    /// this pattern is safe.\n    ///\n    /// # Arguments\n    /// * `unsiloed_nullifier` - The raw nullifier value (before siloing with\n    ///                          the contract address that emitted it).\n    /// * `address` - The claimed contract address that emitted the nullifier\n    ///\n    /// # Returns\n    /// * `bool` - True if the nullifier has been emitted by the specified contract\n    ///\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2) -- effectively\n    /// marking it as \"read\".\n    ///\n    /// Use this function if you only want the message to ever be \"referred to\"\n    /// once. Once consumed using this method, the message cannot be consumed\n    /// again, because a nullifier is emitted.\n    /// If your use case wants for the message to be read unlimited times, then\n    /// you can always read any historic message from the L1-to-L2 messages tree,\n    /// using the `l1_to_l2_msg_exists` method. Messages never technically get\n    /// deleted from that tree.\n    ///\n    /// The message will first be inserted into an Aztec \"Inbox\" smart contract\n    /// on L1. It will not be available for consumption immediately. Messages\n    /// get copied-over from the L1 Inbox to L2 by the next Proposer in batches.\n    /// So you will need to wait until the messages are copied before you can\n    /// consume them.\n    ///\n    /// # Arguments\n    /// * `content` - The message content that was sent from L1\n    /// * `secret` - Secret value used for message privacy (if needed)\n    /// * `sender` - Ethereum address that sent the message\n    /// * `leaf_index` - Index of the message in the L1-to-L2 message tree\n    ///\n    /// # Advanced\n    /// * Validates message existence in the L1-to-L2 message tree\n    /// * Prevents double-consumption by emitting a nullifier\n    /// * Message hash is computed from all parameters + chain context\n    /// * Will revert if message doesn't exist or was already consumed\n    ///\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    /// Sends an \"L2 -> L1 message\" from this function (Aztec, L2) to a smart\n    /// contract on Ethereum (L1). L1 contracts which are designed to\n    /// send/receive messages to/from Aztec are called \"Portal Contracts\".\n    ///\n    /// Common use cases include withdrawals, cross-chain asset transfers, and\n    /// triggering L1 actions based on L2 state changes.\n    ///\n    /// The message will be inserted into an Aztec \"Outbox\" contract on L1,\n    /// when this transaction's block is proposed to L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target portal contract. The message will need to be manually\n    /// consumed from the Outbox through a separate Ethereum transaction: a user\n    /// will need to call a function of the portal contract -- a function\n    /// specifically designed to make a call to the Outbox to consume the\n    /// message.\n    /// The message will only be available for consumption once the _epoch_\n    /// proof has been submitted. Given that there are multiple Aztec blocks\n    /// within an epoch, it might take some time for this epoch proof to be\n    /// submitted -- especially if the block was near the start of an epoch.\n    ///\n    /// # Arguments\n    /// * `recipient` - Ethereum address that will receive the message\n    /// * `content` - Message content (32 bytes as a Field element)\n    ///\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    /// Calls a public function on another contract.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Arguments to pass to the function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Makes a read-only call to a public function on another contract.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Useful for querying data from other contracts safely.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Array of arguments to pass to the called function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Adds a new note hash to the Aztec blockchain's global Note Hash Tree.\n    ///\n    /// Notes are ordinarily constructed and emitted by _private_ functions, to\n    /// ensure that both the content of the note, and the contract that emitted\n    /// the note, stay private.\n    ///\n    /// There are however some useful patterns whereby a note needs to contain\n    /// _public_ data. The ability to push a new note_hash from a _public_\n    /// function means that notes can be injected with public data immediately\n    /// -- as soon as the public value is known. The slower alternative would\n    /// be to submit a follow-up transaction so that a private function can\n    /// inject the data. Both are possible on Aztec.\n    ///\n    /// Search \"Partial Note\" for a very common pattern which enables a note\n    /// to be \"partially\" populated with some data in a _private_ function, and\n    /// then later \"completed\" with some data in a public function.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The hash of the note to add to the tree\n    ///\n    /// # Advanced\n    /// * The note hash will be siloed with the contract address by the protocol\n    ///\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n\n    /// Adds a new nullifier to the Aztec blockchain's global Nullifier Tree.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. Hence why you're seeing this\n    /// function within the PublicContext.\n    /// An example is to check whether a contract has been published: we emit\n    /// a nullifier that is deterministic, but whose preimage is _not_ private.\n    ///\n    /// # Arguments\n    /// * `nullifier` - A unique field element that represents the consumed\n    ///   state\n    ///\n    /// # Advanced\n    /// * Nullifier is immediately added to the global nullifier tree\n    /// * Emitted nullifiers are immediately visible to all\n    ///   subsequent transactions in the same block\n    /// * Automatically siloed with the contract address by the protocol\n    /// * Used for preventing double-spending and ensuring one-time actions\n    ///\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    /// Returns the address of the current contract being executed.\n    ///\n    /// This is equivalent to `address(this)` in Solidity (hence the name).\n    /// Use this to identify the current contract's address, commonly needed for\n    /// access control or when interacting with other contracts.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The contract address of the current function being\n    ///                    executed.\n    ///\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: If the calling function is a _private_ function, then\n    /// it had the option of hiding its address when enqueuing this public\n    /// function call. In such cases, this `context.msg_sender()` method will\n    /// return `Option<AztecAddress>::none`.\n    /// If the calling function is a _public_ function, it will always return\n    /// an `Option<AztecAddress>::some` (i.e. a non-null value).\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called\n    ///   this function (be it an app contract or a user's account contract).\n    ///\n    /// # Advanced\n    /// * Value is provided by the AVM sender opcode\n    /// * In nested calls, this is the immediate caller, not the original\n    ///   transaction sender\n    ///\n    pub fn msg_sender(_self: Self) -> Option<AztecAddress> {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let maybe_msg_sender = unsafe { sender() };\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// \"Unsafe\" versus calling `context.msg_sender()`, because it doesn't\n    /// translate `NULL_MSG_SENDER_CONTRACT_ADDRESS` as\n    /// `Option<AztecAddress>::none`.\n    /// Used by some internal aztecnr functions.\n    pub fn msg_sender_unsafe(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n\n    /// Returns the function selector of the currently-executing function.\n    ///\n    /// This is similar to `msg.sig` in Solidity, returning the first 4\n    /// bytes of the function signature.\n    ///\n    /// # Returns\n    /// * `FunctionSelector` - The 4-byte function identifier\n    ///\n    /// # Advanced\n    /// * Extracted from the first element of calldata\n    /// * Used internally for function dispatch in the AVM\n    ///\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    ///\n    /// Very low-level function: The #[external(\"public\")] macro uses this internally.\n    /// Smart contract developers typically won't need to access this\n    /// directly as arguments are automatically made available.\n    ///\n    /// # Returns\n    /// * `Field` - Hash of the function arguments\n    ///\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n\n    /// Returns the \"transaction fee\" for the current transaction.\n    /// This is the final tx fee that will be deducted from the fee_payer's\n    /// \"fee-juice\" balance (in the protocol's Base Rollup circuit).\n    ///\n    /// # Returns\n    /// * `Field` - The actual, final cost of the transaction, taking into account:\n    ///             the actual gas used during the setup and app-logic phases,\n    ///             and the fixed amount of gas that's been allocated by the user\n    ///             for the teardown phase.\n    ///             I.e. effectiveL2FeePerGas * l2GasUsed + effectiveDAFeePerGas * daGasUsed\n    ///\n    /// This will return `0` during the \"setup\" and \"app-logic\" phases of\n    /// tx execution (because the final tx fee is not known at that time).\n    /// This will only return a nonzero value during the \"teardown\" phase of\n    /// execution, where the final tx fee can actually be computed.\n    ///\n    /// Regardless of _when_ this function is called during the teardown phase,\n    /// it will always return the same final tx fee value. The teardown phase\n    /// does not consume a variable amount of gas: it always consumes a\n    /// pre-allocated amount of gas, as specified by the user when they generate\n    /// their tx.\n    ///\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    /// Returns the chain ID of the current network.\n    ///\n    /// This is similar to `block.chainid` in Solidity. Returns the unique\n    /// identifier for the blockchain network this transaction is executing on.\n    ///\n    /// Helps prevent cross-chain replay attacks. Useful if implementing\n    /// multi-chain contract logic.\n    ///\n    /// # Returns\n    /// * `Field` - The chain ID as a field element\n    ///\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n\n    /// Returns the Aztec protocol version that this transaction is executing\n    /// under. Different versions may have different rules, opcodes, or\n    /// cryptographic primitives.\n    ///\n    /// This is similar to how Ethereum has different EVM versions.\n    ///\n    /// Useful for forward/backward compatibility checks\n    ///\n    /// Not to be confused with contract versions; this is the protocol version.\n    ///\n    /// # Returns\n    /// * `Field` - The protocol version as a field element\n    ///\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    /// Returns the current block number.\n    ///\n    /// This is similar to `block.number` in Solidity.\n    ///\n    /// Note: the current block number is only available within a public function\n    /// (as opposed to a private function).\n    ///\n    /// Note: the time intervals between blocks should not be relied upon as\n    /// being consistent:\n    /// - Timestamps of blocks fall within a range, rather than at exact regular\n    ///   intervals.\n    /// - Slots can be missed.\n    /// - Protocol upgrades can completely change the intervals between blocks\n    ///   (and indeed the current roadmap plans to reduce the time between\n    ///   blocks, eventually).\n    /// Use `context.timestamp()` for more-reliable time-based logic.\n    ///\n    /// # Returns\n    /// * `u32` - The current block number\n    ///\n    pub fn block_number(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n\n    /// Returns the timestamp of the current block.\n    ///\n    /// This is similar to `block.timestamp` in Solidity.\n    ///\n    /// All functions of all transactions in a block share the exact same\n    /// timestamp (even though technically each transaction is executed\n    /// one-after-the-other).\n    ///\n    /// Important note: Timestamps of Aztec blocks are not at reliably-fixed\n    /// intervals. The proposer of the block has some flexibility to choose a\n    /// timestamp which is in a valid _range_: Obviously the timestamp of this\n    /// block must be strictly greater than that of the previous block, and must\n    /// must be less than the timestamp of whichever ethereum block the aztec\n    /// block is proposed to. Furthermore, if the timestamp is not deemed close\n    /// enough to the actual current time, the committee of validators will not\n    /// attest to the block.\n    ///\n    /// # Returns\n    /// * `u64` - Unix timestamp in seconds\n    ///\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n\n    /// Returns the fee per unit of L2 gas for this transaction (aka the \"L2 gas\n    /// price\"), as chosen by the user.\n    ///\n    /// L2 gas covers the cost of executing public functions and handling\n    /// side-effects within the AVM.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of L2 gas\n    ///\n    /// Wallet developers should be mindful that the choice of gas price (which\n    /// is publicly visible) can leak information about the user, e.g.:\n    /// - which wallet software the user is using;\n    /// - the amount of time which has elapsed from the time the user's wallet\n    ///   chose a gas price (at the going rate), to the time of tx submission.\n    ///   This can give clues about the proving time, and hence the nature of\n    ///   the tx.\n    /// - the urgency of the transaction (which is kind of unavoidable, if the\n    ///   tx is indeed urgent).\n    /// - the wealth of the user.\n    /// - the exact user (if the gas price is explicitly chosen by the user to\n    ///   be some unique number like 0.123456789, or their favourite number).\n    /// Wallet devs might wish to consider fuzzing the choice of gas price.\n    ///\n    pub fn base_fee_per_l2_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_l2_gas()\n        }\n    }\n\n    /// Returns the fee per unit of DA (Data Availability) gas (aka the \"DA gas\n    /// price\").\n    ///\n    /// DA gas covers the cost of making transaction data available on L1.\n    ///\n    /// See the warning in `fee_pre_l2_gas` for how gas prices can be leaky.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of DA gas\n    ///\n    pub fn base_fee_per_da_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_da_gas()\n        }\n    }\n\n    /// Returns the remaining L2 gas available for this transaction.\n    ///\n    /// Different AVM opcodes consume different amounts of gas.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining L2 gas units\n    ///\n    pub fn l2_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n\n    /// Returns the remaining DA (Data Availability) gas available for this\n    /// transaction.\n    ///\n    /// DA gas is consumed when emitting data that needs to be made available\n    /// on L1, such as public logs or state updates.\n    /// All of the side-effects from the private part of the tx also consume\n    /// DA gas before execution of any public functions even begins.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining DA gas units\n    ///\n    pub fn da_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n\n    /// Checks if the current execution is within a staticcall context, where\n    /// no state changes or logs are allowed to be emitted (by this function\n    /// or any nested function calls).\n    ///\n    /// # Returns\n    /// * `bool` - True if in staticcall context, false otherwise\n    ///\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    /// Reads raw field values from public storage.\n    /// Reads N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to read from\n    ///\n    /// # Returns\n    /// * `[Field; N]` - Array of N field values from consecutive storage slots\n    ///\n    /// # Generic Parameters\n    /// * `N` - the number of consecutive slots to return, starting from the\n    ///         `storage_slot`.\n    ///\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    /// Reads a typed value from public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to read from\n    ///\n    /// # Returns\n    /// * `T` - The deserialized value from storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type that the caller expects to read from the `storage_slot`.\n    ///\n    pub fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    /// Writes raw field values to public storage.\n    /// Writes to N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// Public storage writes take effect immediately.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to write to\n    /// * `values` - Array of N Fields to write to storage\n    ///\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    /// Writes a typed value to public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to write to\n    /// * `value` - The typed value to write to storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type to write to storage.\n    ///\n    pub fn storage_write<T>(self, storage_slot: Field, value: T)\n    where\n        T: Packable,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> u32 {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn base_fee_per_l2_gas() -> u128 {\n    base_fee_per_l2_gas_opcode()\n}\nunconstrained fn base_fee_per_da_gas() -> u128 {\n    base_fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> u32 {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> u32 {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> u1 {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: u64) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: u64) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\n\nunconstrained fn call(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\nunconstrained fn call_static(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeBaseFeePerL2Gas)]\nunconstrained fn base_fee_per_l2_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeBaseFeePerDaGas)]\nunconstrained fn base_fee_per_da_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> u1 {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "72": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr",
      "source": "use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\n/// A hash that represents a private contract function call's return value. Call `get_preimage` to get the underlying\n/// value.\n///\n/// The kernels don't process the actual return values but instead their hashes, so it is up to contracts to populate\n/// oracles with the preimages of these hashes on return to make them available to their callers.\n///\n/// Public calls don't utilize this mechanism since the AVM does process the full return values.\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    /// Fetches the underlying return value from an oracle, constraining that it corresponds to the return data hash.\n    pub fn get_preimage<T>(self) -> T\n    where\n        T: Deserialize,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it. If `T`\n        // is `()`, then `preimage` must be an array of length 0 (since that is `()`'s deserialization length).\n        // `hash_args_array` handles empty arrays following the protocol rules (i.e. an empty args array is signaled\n        // with a zero hash), correctly constraining `self.hash`.\n        let preimage = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage), \"Preimage mismatch\");\n\n        Deserialize::deserialize(preimage)\n    }\n}\n\nmod test {\n    use crate::{\n        hash::hash_args_array,\n        oracle::execution_cache,\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use super::ReturnsHash;\n    use protocol_types::traits::Serialize;\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn retrieves_preimage() {\n        let env = TestEnvironment::new();\n        env.private_context(|_| {\n            let value = MockStruct::new(4, 7);\n            let serialized = value.serialize();\n\n            let hash = hash_args_array(serialized);\n            execution_cache::store(serialized, hash);\n\n            assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n        });\n    }\n\n    #[test]\n    unconstrained fn retrieves_empty_preimage() {\n        let env = TestEnvironment::new();\n        env.private_context(|_| {\n            let value = ();\n            let serialized = [];\n\n            let hash = hash_args_array(serialized);\n            execution_cache::store(serialized, hash);\n\n            assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n        });\n    }\n\n    #[test(should_fail_with = \"Preimage mismatch\")]\n    unconstrained fn rejects_bad_preimage() {\n        let value = MockStruct::new(4, 7);\n        let serialized = value.serialize();\n\n        let mut bad_serialized = serialized;\n        bad_serialized[0] += 1;\n\n        let hash = hash_args_array(serialized);\n\n        let _ = OracleMock::mock(\"privateLoadFromExecutionCache\").returns(bad_serialized);\n        assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n    }\n\n    // This test passes due to a Noir bug.\n    // #[test(should_fail_with=\"Preimage mismatch\")]\n    // unconstrained fn rejects_bad_empty_preimage() {\n    //     let value = ();\n    //     let serialized = [];\n\n    //     let hash = hash_args_array(serialized);\n\n    //     let _ = OracleMock::mock(\"privateLoadFromExecutionCache\").returns([1]);\n    //     assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n    // }\n}\n"
    },
    "73": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{execution::get_utility_context, storage::storage_read};\nuse protocol_types::{address::AztecAddress, traits::Packable};\n\n// If you'll modify this struct don't forget to update utility_context.ts as well.\npub struct UtilityContext {\n    block_number: u32,\n    timestamp: u64,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        get_utility_context()\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        // We get a context with default contract address, and then we construct the final context with the provided\n        // contract address.\n        let default_context = get_utility_context();\n\n        Self {\n            block_number: default_context.block_number,\n            timestamp: default_context.timestamp,\n            contract_address,\n            version: default_context.version,\n            chain_id: default_context.chain_id,\n        }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        // We get a context with default contract address and block number, and then we construct the final context\n        // with the provided contract address and block number.\n        let default_context = get_utility_context();\n\n        Self {\n            block_number,\n            timestamp: default_context.timestamp,\n            contract_address,\n            version: default_context.version,\n            chain_id: default_context.chain_id,\n        }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn timestamp(self) -> u64 {\n        self.timestamp\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "76": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/event/event_selector.nr",
      "source": "use dep::protocol_types::{\n    hash::poseidon2_hash_bytes,\n    traits::{Deserialize, Empty, FromField, Serialize, ToField},\n};\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "78": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_BYTECODE, GENERATOR_INDEX__PUBLIC_CALLDATA,\n        GENERATOR_INDEX__SECRET_HASH, MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS,\n    },\n    hash::{\n        poseidon2_hash_subarray, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice,\n        sha256_to_field,\n    },\n    point::Point,\n    traits::ToField,\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n}\n\n/**\n * Computes the public bytecode commitment for a contract class.\n * The commitment is `hash([separator, ...bytecode])` where bytecode omits the length prefix present\n * in `packed_bytecode`.\n *\n * @param packed_bytecode - The packed bytecode of the contract class. 0th word is the length in bytes.\n *    packed_bytecode is mutable so that we can avoid copying the array to construct one starting with\n *    separator instead of length.\n * @returns The public bytecode commitment.\n */\npub fn compute_public_bytecode_commitment(\n    mut packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS],\n) -> Field {\n    // First field element contains the length of the bytecode\n    let bytecode_length_in_bytes: u32 = packed_public_bytecode[0] as u32;\n    let bytecode_length_in_fields: u32 =\n        (bytecode_length_in_bytes / 31) + (bytecode_length_in_bytes % 31 != 0) as u32;\n    // Don't allow empty public bytecode.\n    // AVM doesn't handle execution of contracts that exist with empty bytecode.\n    assert(bytecode_length_in_fields != 0);\n    assert(bytecode_length_in_fields < MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS);\n\n    // Packed_bytecode's 0th entry is the length. Replace it with separator before hashing.\n    let separator = GENERATOR_INDEX__PUBLIC_BYTECODE.to_field();\n    packed_public_bytecode[0] = separator;\n\n    // `fields_to_hash` is the number of fields from the start of `packed_public_bytecode` that should be included in\n    // the hash. Fields after this length are ignored.\n    // +1 to account for the separator.\n    let num_fields_to_hash = bytecode_length_in_fields + 1;\n\n    poseidon2_hash_subarray(packed_public_bytecode, num_fields_to_hash)\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = [0; 100];\n    for i in 0..100 {\n        input[i] = i as Field;\n    }\n    let hash = hash_args_array(input);\n    dep::std::println(hash);\n    // Used in yarn-project/stdlib test snapshots:\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_calldata_hash() {\n    let mut input = [0; 100];\n    for i in 0..input.len() {\n        input[i] = i as Field;\n    }\n    let hash = hash_calldata_array(input);\n    dep::std::println(hash);\n    let hash_check = hash_calldata(input.as_slice());\n    assert(hash == hash_check);\n    // Used in cpp vm2 tests:\n    assert(hash == 0x191383c9f8964afd3ea8879a03b7dda65d6724773966d18dcf80e452736fc1f3);\n}\n\n#[test]\nunconstrained fn public_bytecode_commitment() {\n    let mut input = [0; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS];\n    let len = 99;\n    for i in 1..len + 1 {\n        input[i] = i as Field;\n    }\n    input[0] = (len as Field) * 31;\n    let hash = compute_public_bytecode_commitment(input);\n    dep::std::println(hash);\n    // Used in cpp vm2 tests:\n    assert(hash == 0x16d621c3387156ef53754679e7b2c9be8f0bceeb44aa59a74991df3b0b42a0bf);\n}\n"
    },
    "90": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/history/public_storage.nr",
      "source": "use dep::protocol_types::{\n    abis::block_header::BlockHeader, address::AztecAddress,\n    constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX, hash::poseidon2_hash_with_separator,\n    utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\nuse protocol_types::traits::{Hash, ToField};\n\nmod test;\n\npub trait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        // Safety: The witness is only used as a \"magical value\" that makes the proof below pass. Hence it's safe.\n        let witness = unsafe {\n            get_public_data_witness(self.global_variables.block_number, public_data_tree_index)\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert_eq(\n            self.state.partial.public_data_tree.root,\n            root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path),\n            \"Proving public value inclusion failed\",\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(\n                preimage.slot,\n                public_data_tree_index,\n                \"Public data tree index doesn't match witness\",\n            );\n            preimage.value\n        };\n\n        value\n    }\n}\n"
    },
    "95": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n\nmod test {\n    use super::get_public_keys;\n\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use protocol_types::traits::Serialize;\n    use std::test::OracleMock;\n\n    global KEY_ORACLE_RESPONSE_LENGTH: u32 = 13; // 12 fields for the keys, one field for the partial address\n\n    #[test(should_fail_with = \"Invalid public keys hint for address\")]\n    unconstrained fn get_public_keys_fails_with_bad_hint() {\n        let mut env = TestEnvironment::new();\n        let account = env.create_light_account();\n\n        // Instead of querying for some unknown account, which would result in the oracle erroring out, we mock a bad oracle\n        // response to check that the circuit properly checks the address derivation.\n        let mut random_keys_and_partial_address = [0; KEY_ORACLE_RESPONSE_LENGTH];\n        // We use randomly generated points on the curve, and a random partial address to ensure that\n        // this combination does not derive the address and we should see the assertion fail.\n        // npk_m\n        random_keys_and_partial_address[0] =\n            0x292364b852c6c6f01472951e76a39cbcf074591fd0e063a81965e7b51ad868a5;\n        random_keys_and_partial_address[1] =\n            0x0a687b46cdc9238f1c311f126aaaa4acbd7a737bff2efd7aeabdb8d805843a27;\n        random_keys_and_partial_address[2] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // ivpk_m\n        random_keys_and_partial_address[3] =\n            0x173c5229a00c5425255680dd6edc27e278c48883991f348fe6985de43b4ec25f;\n        random_keys_and_partial_address[4] =\n            0x1698608e23b5f6c2f43c49a559108bb64e2247b8fc2da842296a416817f40b7f;\n        random_keys_and_partial_address[5] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // ovpk_m\n        random_keys_and_partial_address[6] =\n            0x1bad2f7d1ad960a1bd0fe4d2c8d17f5ab4a86ef8b103e0a9e7f67ec0d3b4795e;\n        random_keys_and_partial_address[7] =\n            0x206db87110abbecc9fbaef2c865189d94ef2c106202f734ee4eba9257fd28bf1;\n        random_keys_and_partial_address[8] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // tpk_m\n        random_keys_and_partial_address[9] =\n            0x05e3bd9cfe6b47daa139613619cf7d7fd8bb0112b6f2908caa6d9b536ed948ed;\n        random_keys_and_partial_address[10] =\n            0x051066f877c9df47552d02e7dc32127ff4edefc8498e813bca1cbd3f5d1be429;\n        random_keys_and_partial_address[11] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // partial address\n        random_keys_and_partial_address[12] =\n            0x236703e2cb00a182e024e98e9f759231b556d25ff19f98896cebb69e9e678cc9;\n\n        let _ = OracleMock::mock(\"utilityGetPublicKeysAndPartialAddress\").returns(\n            random_keys_and_partial_address.serialize(),\n        );\n        let _ = get_public_keys(account);\n    }\n}\n"
    },
    "99": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::macros::{\n    dispatch::generate_public_dispatch,\n    functions::{stub_registry, utils::check_each_fn_macroified},\n    notes::NOTES,\n    storage::STORAGE_LAYOUT_NAME,\n    utils::{get_trait_impl_method, module_has_storage},\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_private_state` utility function.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[external(...)], #[contract_library_method], or #[test] are not allowed in contracts.\n    check_each_fn_macroified(m);\n\n    // We generate `_compute_note_hash_and_nullifier`, `sync_private_state` and `process_message`\n    // functions only if they are not already implemented. If they are implemented we just insert empty\n    // quotes.\n    let contract_library_method_compute_note_hash_and_nullifier = if !m.functions().any(|f| {\n        f.name() == quote { _compute_note_hash_and_nullifier }\n    }) {\n        generate_contract_library_method_compute_note_hash_and_nullifier()\n    } else {\n        quote {}\n    };\n    let sync_private_state = if !m.functions().any(|f| f.name() == quote { sync_private_state }) {\n        generate_sync_private_state()\n    } else {\n        quote {}\n    };\n    let process_message = if !m.functions().any(|f| f.name() == quote { process_message }) {\n        generate_process_message()\n    } else {\n        quote {}\n    };\n    let public_dispatch = generate_public_dispatch(m);\n\n    quote {\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_private_state\n        $process_message\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    if NOTES.len() > 0 {\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..NOTES.len() {\n            let typ = NOTES.get(i);\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret its raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = <$typ as $crate::protocol_types::traits::Packable>::N;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided note nonce.\n                        let note_hash_for_nullification = aztec::note::utils::compute_note_hash_for_nullification(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(note_nonce).into()\n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullification);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `note_nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_message` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                note_nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_sync_private_state() -> Quoted {\n    // We obtain the `external` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::external(\"utility\")]` in the returned quote because the latter would result in\n    // the function attribute having the full path in the ABI. This is undesirable because we use the information in\n    // the ABI only to determine whether a function is `external(\"private\")`, `external(\"public\")`, or `external(\"utility\")`.\n    let external = crate::macros::functions::external;\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[external(\"utility\")] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[$external(\"utility\")]\n        unconstrained fn sync_private_state() {\n        }\n    }\n}\n\ncomptime fn generate_process_message() -> Quoted {\n    // We obtain the `external` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::external(\"utility\")]` in the returned quote because the latter would result in\n    // the function attribute having the full path in the ABI. This is undesirable because we use the information in\n    // the ABI only to determine whether a function is `external(\"private\")`, `external(\"public\")`, or `external(\"utility\")`.\n    let external = crate::macros::functions::external;\n\n    quote {\n        #[$external(\"utility\")]\n        unconstrained fn process_message(\n            message_ciphertext: BoundedVec<Field, aztec::messages::encoding::MESSAGE_CIPHERTEXT_LEN>,\n            message_context: aztec::messages::processing::message_context::MessageContext,\n        ) {\n            aztec::messages::discovery::process_message::process_message_ciphertext(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n                message_ciphertext,\n                message_context,\n            );\n        }\n    }\n}\n"
    }
  },
  "functions": [
    {
      "abi": {
        "error_types": {
          "11594563071547591162": {
            "error_kind": "string",
            "string": "Function _validate_emitter_and_update_value can only be called internally"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "18173155084464344029": {
            "error_kind": "string",
            "string": "Emitter not registered"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "emitter_chain_id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 16
            },
            "visibility": "private"
          },
          {
            "name": "emitter_address",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "value",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JwACBAEoAAABBIBnJwAABGcnAgQEIicCBQQAHwoABAAFAEUcAEVFAxwARkYCHABHRwIcAEhIAhwASUkCHABKSgIcAEtLAhwATEwCHABNTQIcAE5OAhwAT08CHABQUAIcAFFRAhwAUlICHABTUwIcAFRUAhwAVVUCHABWVgIcAFdXAhwAWFgCHABZWQIcAFpaAhwAW1sCHABcXAIcAF1dAhwAXl4CHABfXwIcAGBgAhwAYWECHABiYgIcAGNjAhwAZGQCHABlZQIcAGZmBi0IRQEnAgIERicCBQQgLQgBBCcCBgQhAAgBBgEnAwQEAQAiBAIGLQICAy0CBgQtAgUFJQAAASYtCgQCLQhmAyUAAAFYJQAAAYMnAgEEZycCAgQAOw4AAgABAAADBQctAAMILQAECQoACAcKJAAACgAAAVctAQgGLQQGCQAACAIIAAAJAgkjAAABMyYsAABDADBkTnLhMaApuFBFtoGBWF0oM+hIeblwkUPh9ZPwAAAAJwBEBAMmJQAACSMeAgAEAB4CAAUAMyoABAAFAAYnAgQBASQCAAYAAAGsJQAACUkeAgAFAQoiBUMGFgoGBxwKBwgABCoIBQcnAgUBAAoqBgUIJAIACAAAAd8nAgkEADwGCQEeAgAGAAoqBwYIJAIACAAAAfYlAAAJWxwKAQYAJwIBAAAtCAEHJwIIBAQACAEIAScDBwQBACIHAggtCggJLQ4BCQAiCQIJLQ4BCQAiCQIJLQ4BCSsCAAgAAAAAAAAAAAIAAAAAAAAAAC0IAQknAgoEBQAIAQoBJwMJBAEAIgkCCi0KCgstDgELACILAgstDgELACILAgstDgELACILAgstDggLLQgBCAAAAQIBLQ4HCC0IAQcAAAECAS0OCQctCAEKAAABAgEnAgsEAC0OCwotCAEMAAABAgEtDgUMJwINAAcnAg4EASQCAAUAAAMZIwAAAtItCAEPJwIQBAQACAEQAScDDwQBACIPAhAtChARLQ4NEQAiEQIRLQ4BEQAiEQIRLQ4BES0ODwgtDgkHLQ4OCi0OBQwjAAADpS0KCwkjAAADIgwiCUQPJAIADwAACJ0jAAADNC0LCAktCwcPLQsMEC0LDxEAIhECES0OEQ8tCAERJwISBAUACAESAScDEQQBACIPAhInAhMEBAAiEQIUPw8AEgAULQIJAycABAQEJQAACW0tCAUPACoPDhItDg0SLQ4PCC0OEQctDg4KLQ4QDCMAAAOlLQsICS0LBw0tCwwPCioPBRAkAgAQAAADxycCEQQAPAYRASQCAAUAAAQJIwAAA9QnAg8EAi0CCQMnAAQEBCUAAAltLQgFEAAqEA8RLQ4GES0OEAgtDg0HLQ4PCi0OBQwjAAAElS0KCwkjAAAEEgwiCUQNJAIADQAACBcjAAAEJC0LCAktCwcNLQsMDy0LDRAAIhACEC0OEA0tCAEQJwIRBAUACAERAScDEAQBACINAhEnAhIEBAAiEAITPw8AEQATLQIJAycABAQEJQAACW0tCAUNACoNDhEtDgYRLQ4NCC0OEActDg4KLQ4PDCMAAASVLQsMCQoqCQUNJAIADQAABK8nAg8EADwGDwEtCgsGIwAABLgMIgZECSQCAAkAAAeRIwAABMotCwgJLQsHDS0LCg8tCw0QACIQAhAtDhANLQgBECcCEQQFAAgBEQEnAxAEAQAiDQIRJwISBAQAIhACEz8PABEAEy0OCQgtDhAHLQ4PCi0OBAwAKhAOCC0LCAcKKgcBCAoqCAUJJAIACQAABTslAAAJ0S0IAQUnAggEIQAIAQgBJwMFBAEAIgUCCCcCCQQgACoJCAktCggKDioJCgwkAgAMAAAFfC0OAQoAIgoCCiMAAAVhLQgBAQAAAQIBLQ4FAScCBQQgLQoLBiMAAAWXDCoGBQgkAgAIAAAHSyMAAAWpLQsBBy0IAQEAAAECAS0OBwEtCAEHAAABAgEtDgsHJwIIAgAtCAEJJwIKBCEACAEKAScDCQQBACIJAgonAgwEIAAqDAoMLQoKDQ4qDA0PJAIADwAABg0tDggNACINAg0jAAAF8i0IAQgAAAECAS0OCQgtCgsGIwAABiMMKgYFCSQCAAkAAAa/IwAABjUtCwgGLQgBBwAAAQIBLQ4EBy0KCwEjAAAGTwwqAQUIJAIACAAABoMjAAAGYS0LBwEkAgABAAAGciUAAAnjHAoDAQAnAgIACDAKAAEAAiYtCwcIACIGAgoAKgoBCy0LCwkAIgICCwAqCwEMLQsMCgoqCQoLBCoICwktDgkHACoBDggtCggBIwAABk8tCwEJLQsHCgwqCgUMJAIADAAABtklAAAJ9QAiCQINACoNCg8tCw8MACoKDg0OKgoNDyQCAA8AAAb+JQAACgctDgkBLQ4NBxwKDAoCHAoKCQAcCgkKAi0LCAktAgkDJwAEBCElAAAJbS0IBQwAIgwCDQAqDQYPLQ4KDy0ODAgAKgYOCS0KCQYjAAAGIxwKBggAACoHCAkvCgAJAAgtCwEJLQIJAycABAQhJQAACW0tCAUKACIKAgwAKgwGDS0OCA0tDgoBACoGDggtCggGIwAABZctCwgJLQsHDS0LCg8tCwwQDCoGDxEkAgARAAAHsyMAAAgJACINAhIAKhIGEy0LExEAIgkCEwAqEwYULQsUEgAqERITLQINAycABAQFJQAACW0tCAURACIRAhIAKhIGFC0OExQtDgkILQ4RBy0ODwotDhAMIwAACAkAKgYOCS0KCQYjAAAEuC0LCA0tCwcPLQsKEC0LDBEMKgkQEiQCABIAAAg5IwAACI8AIg8CEwAqEwkULQsUEgAiDQIUACoUCRUtCxUTACoSExQtAg8DJwAEBAUlAAAJbS0IBRIAIhICEwAqEwkVLQ4UFS0ODQgtDhIHLQ4QCi0OEQwjAAAIjwAqCQ4NLQoNCSMAAAQSLQsIDy0LBxAtCwoRLQsMEgwqCRETJAIAEwAACL8jAAAJFQAiEAIUACoUCRUtCxUTACIPAhUAKhUJFi0LFhQAKhMUFS0CEAMnAAQEBSUAAAltLQgFEwAiEwIUACoUCRYtDhUWLQ4PCC0OEwctDhEKLQ4SDCMAAAkVACoJDg8tCg8JIwAAAyIoAAAEBHhnDAAABAMkAAADAAAJSCoBAAEF2sX11rRKMm08BAIBJioBAAEFBmE7PQudvTM8BAIBJioBAAEFoOgprtV0yfo8BAIBJi0BAwYKAAYCByQAAAcAAAmDIwAACYwtAAMFIwAACdAtAAEFAAABBAEAAAMECS0AAwotAAULCgAKCQwkAAAMAAAJxi0BCggtBAgLAAAKAgoAAAsCCyMAAAmiJwEFBAECAAYCBiYqAQABBbq7IdeCMxhkPAQCASYqAQABBfw0BEOJlMvdPAQCASYqAQABBeQIUEUCtYwfPAQCASYqAQABBdAH6/TLxmeQPAQCASY=",
      "custom_attributes": [
        "external",
        "internal",
        "public"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "_validate_emitter_and_update_value"
    },
    {
      "abi": {
        "error_types": {
          "14415304921900233953": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "9967937311635654895": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          }
        },
        "parameters": [
          {
            "name": "wormhole_address",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "chain_id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 16
            },
            "visibility": "private"
          },
          {
            "name": "owner",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "message_fee",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "consistency",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "initializer",
        "public"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "constructor"
    },
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "14067204867181196045": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "9921926525851912681": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "wormhole_address",
                "type": {
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                }
              },
              {
                "name": "chain_id",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 16
                }
              },
              {
                "name": "message_fee",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "consistency",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 8
                }
              }
            ],
            "kind": "struct",
            "path": "config::Config"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "utility"
      ],
      "debug_symbols": "TL3LkjQ9b6R5L996FskDAEK3Mou26emDyUzWMuvDSjffFXCC7ht9j/96i84gCc/ISFTWf/zzX/7rf/4///0//ev/+G///r/++Zf/9z/++c//81//7d/+9b//p3/79/////vf//rv/+Pvf/2Pf37f/9nzn39Z/88/e/3zL/73n/3Pv5y//xj+4/hP4D8H/8n6j/3wn4H/TPxn4T8YxTCKYRTDKIZRDKM4RnGM4hjFMYpjFMcojlEcozhGcYwSGCUwSmCUwCiBUQKjBEYJjBIYJTDKwSgHoxyMcjDKwSgHoxyMcjDKwSgHoyRGSYySGCUxSmKUxCiJURKjJEZJjDJ+v/vfcf8773/X/e++/7X7X7//jfvfc/97xxt3vHHHG3e8cccbd7xxxxt3vHHHG3e8ccebd7z5N974fTAbVsNu+BtzrA+8IRpOw9+44+8AjvU38Px+ao2G2bAadoM1/I089wfRcBrywv5Gtg9Gw2z45vxdznf+AdbwN/IaH0TDacgLXy0ARsNsWA27wRp6ZOuRrUf+qmN9y/LVB2A0zIbVsBuswRui4TT0yNEjR48cPXL0yNEjR48cPXL0yNEjR498euTTI58e+fTIp0f+Kmp9W/DVFCAaTkNe+GoLMBpmw2rYDT1y9sjZI2ePnHfk+fs1jIbZsBp2gzV4QzSchh559MijRx498uiRR488euTRI48eefTIo0eePfLskWePPHvk2SPPHnn2yLNHnj3y7JFXj7x65NUjrx559cirR1498uqRV4+8euTdI+8eeffIu0fePfLukXePvHvk3SPvHtl65KrB88FsWA27wRq8IRpOQ16oGizokb1H9h75q8E9PrAGb/gbefsHpyEvfDUIGA2zYTXsBmvwhh45euTokc9NpHlGw2xYDbvBGrwhGk7DzbqZPXL2yNkjfzW484PdYA3eEA2nIQHrq0HAaJgNq2E3WIM3/I1svw9OQ174ahAwGmbDatgN1uANPfLokUeP/NWgxQejYTasht1gDd4QDachL6weefXIq0dePfLqkVePvHrk1SOvHnn1yLtH3j3y7pF3j7x75N0j7x5598i7R949svXI1iNbj2w9svXI1iNbj2w9svXI1iN7j+w9svfI3iN7j+w9svfI3iN7j+w9cvTI0SNHjxw9cvTI0SNHjxw9cvTI0SOfHvn0yKdHPj3y6ZFPj3x65NMj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ySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSbUJjjEKjejEIB5iPqwsuTiIk7iIdEu6Jd0qS8YsPMS8OKuLsHEQJ3ERN9GITgziIdJt0G3QbdBt0G3QbdBt0G3QbdBt0G3SbdJt0m3SbdJt0m3SbdJt0m3SbdFt0W3RbdFt0W3RbdFt0W3RbdFt023TbdNt023TbdNt023TbdNt083oZnQzuhndjG5Gt8qSsQuDeIjlFh9WllwcxElcxE00ohODeIh0C7oF3YJuQbegW9At6BZ0C7oF3Q7dDt0O3Q7dDt0O3Q7dDt0O3Q7dkm5Jt6Rb0i3plnRLuiXdkm753MbvRxzESVzETTSiE4N4iHQbdBt0G3QbdBt0G3QbdBt0G3QbdJt0m3SbdJt0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0W3TbdNt023TbdNt023TbdNt023TbdDO6Gd2MbkY3o5vRzehmdDO6MUsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySxazZDFLFrNkMUsWs2QxSxazZDFLFrNkMUsWs2QxSxazZDFLFrNkMUsWs2QxSxazZDFLFrNk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",
      "is_unconstrained": true,
      "name": "get_config"
    },
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "14067204867181196045": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "9921926525851912681": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 128
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "utility"
      ],
      "debug_symbols": "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bdCNWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWVI9gmOMwklcxE00ohODmMTzsLLkIt0O3Q7dKkvGLDSiE4OYxHNxViNh4yBO4iJuohGdGMQk0m3QbdBt0G3QbdBt0G3QbdBt0G3QbdJt0m3SbdJt0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0W3TbdNt023TbdNt023TbdNt023TzehmdDO6VZaMXbiJRiy3KAxiEs/DypKLgziJi7iJRqSb083p5nQLugXdgm5Bt6Bb0C3oFnQLugXdkm5Jt6Rb0i3plnRLuiXdkm5Jt0O3Q7dDt0O3Q7dDt0O3Q7dDt/Pcxu9HHMRJXMRNNKITg5hEug26DboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptum26Gd2MbkY3o5vRzejGLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLFLFnMksUsWcySxSxZzJLFLFnMksUsWcySxSxZzJLFLFnM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",
      "is_unconstrained": true,
      "name": "get_current_value"
    },
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "14067204867181196045": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "9921926525851912681": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
          },
          "visibility": "public"
        }
      },
      "bytecode": "H4sIAAAAAAAA/+y9CZxd1XEmfp/6daMHLT1J7Huzy2xiR6ySECAWCQuJHRwsUBtkFmFJYGPHjm0QYGxAIFZjQzeLARuDHfvvjD2ZTBIn8WTs2JNl4qzjLOPEnsQxTrzEiRP/fa1b3V9/77vnnXtfve4ndO/vB3p9T52qOnWq6tSps9xasuVpZP9eN7zh6rVvv3l4XfpHLXtZTyY+taTNUwu8a6H0wQVbXkzPCqZBhb6f/TeURD216USoWP33vmk6IyxUP/l5/VpSlv6W9qd1SrY/Gcj+vQrqIy+Gd7uf/TcIvw/Ofg8G6nfI21XToU6J+rU5OfSNt/RZDBWGkqinz+qeqep+f/3XP/bl+z7zWy9ueOH5R2f/2Ywndjh8+1/auPG7e/7TXh9+beOzVvcs4KmWRNMesPpnK9qn/0rfFdd/+t/W7rDkjlff/md/esGtM/Za9Zv73vP8Fb/94L7fvvouq7tE1f3Wh578pearD40MHfZ7PxhY8sA/Xv0v5/bP/7Pf+8Xdv/j+n3z7tc1W9xxV9w+u+Mlffra5+Z3vuO/z75o/d8dVL2/++vf+35e+/ErzX/76k2/7+vFW91xocz0ppuPpc165+mM2fn65+tOs/lKoX8bHLCtXf5bVvwBeDtmP9z334l8uuu/3jvrbn2x/77JVd77j2A/+4aXfeeduLxz0zbd+cq+XZ1vdN6q6f7Nh8YMbdr3phO9M/9p9R4/uufc3vv/CZ//+h7cPz//Hv//W5/b7F6u7XNVt81jdC0Xd3Y455KRbHv9fO/3F3P3/fOGvv3zkw7t//8BT/+K/nDP62r/97r9C3RXZvwXlNdZfK8vVr1v9i8rVH/MPF0P9AjY+pi+XlKs/Rv/ScvXH5HcZvBwK1xkbu63u5fF17em3uleIuoee2njt+XvfszH5qxf+4f4fHvqrC4+Yvc+i2Uf+0ZN/vOfN667c/TWreyUwVKDP9to+2TKunZLFFTv87L8Ds8JbN6y5cc2G2xetXz+8bsPitTfdsmrDmmtuHH7julXX3jh8yfC69WvW3swIa/T34pz3KZ3dJtJZMrzh4i2/Fq+9ecPwOzb0E94a/T2N/u6jv+v0t+Hrz6nHddo9Nk4PEI9DcdWXW/3tytUftvrTy9VfZ/Ub5eq/xepvX67+Wqu/Q7n6N1n9wXL111j9GeXq32z1Z5arf53Vb5arP2T1Z5Wrv97qzy5Xf5XVn1Ou/mqrv2O5+tda/Z3K1b/N6u9crv7tgxn8LvDSfJTh3hXeF/DLe9cIX5JM9FMJ4W8QL0VjtRrhM3rcPvO51vbdBC9NUcY+cjdBZzdBR+HazhHXdEdcDUdc2/doG3dwxDXoiGuGI66Zjriajrg8Ze9pQ7N6FNdsR1yeOuEpe0/9muOIy9O2PXViR0dcnj56J0dcvTo+WpxlsQPGGrWcf40OvzM6DcJVS8rFPapduwp605PWdhXJOxu93QU9FWcZ/B6R/KVjhPmEbF595vA1t163dO11CT081T0rh8W9kons7xZgjfHW6D9+z7j7BCw+afNMTFnzzh7ecO31F6267rrh1T9r5HquwZjOzHlvSrm7qGudvgdxOpREPdNilBrxN4iXskqtlAbbh0pjzj+T6tK1q1YvXnXL+ltvHOY0C04xWCqIFd+pPq0BZ/iuj+DOpL+XinqJwI26tCeUKUkYzplJa5v2zKnHJsvvpgn4PQjXHqKe8d4XqI84sB5rTEirY7TS2pE+zSS//TFT4ZLWs1NZ6+l0KhySdfrwkLBnOXo7hnQUcRo/Juu9RJnh2jv7eyAHl9WtE/xHsn+bSat/Xk409hL84juTT5pufYx4R9mynnQiR8RnfOE7xN9IOtLLWqjfsH2sJ3uVozcnRu7Ij8l6b1FmuPbJ/h7IwWV16wT/UvZvk+DSh/Vkb8EvvkM9eY54R9mynpSU46JYPTH8jaQjvayF+g3bx3qydzl6C2PkjvyYrPcRZYZr3+zvgRxcVrdO8J/L/m0SXPqwnuwj+MV3qCefzn5Pz+F3KIl6blSyLlD/7dOTVtkVqL/B6u9brv710wm+YP13Wf39ytU/yurvX67+u033DoCXbOcHwvsiS5uxdm74G8RLWTs/kOhx+ziFfpDgpSnKOIV+kKBzkKCjcE13xLW9I64dHXFt54hrVo/iGnTENcMR10xHXE1HXHs54vLU+16V196OuDx1dR9HXPs64vKUvWcbZzvi6lVdHXLEtZ8jLouNbLzH+KCW/Ttd1Cs6N0R8xie+Q/wN4qUgvVpILtg+ntMcXI7e7BrVR3qI0/gxWR8iygzX3OzvgRxcVrdO8P2ZQJsElz48pzlE8IvvcE5jHTVT8Mv5naL6iPVZRliP9bGT/kJ8xie+Q/yNpCP9r4X0Q8nF2ndIOXqzYvoX+TFZzxVlhusN2d8DObisbp3gdyZ9nAs8sT7OFfziO9THWbWJvKNsWU9KyvGsWD0x/I2kI72shfoN28d6MrccvTNj5I78mKzfIMoM16HZ3wM5uKxuneD3Jz15A/DEevIGwS++Qz2xvWrTc/gdSuIethHDgbhRLvH9UPterJ4Z/kbSUb/XQnJU9mbtO7QUvdprrBtID3EaPybrw0SZ4To8+3sgB5fVrRP8UaRnSIN1w8qQX3yHenYY+SOULetJOTkmZ8TqieFvJJ3o5bieqH5T9mbtO6wcvUUxckd+TNaHizLDdUT290AOLqtbJ/jTSE8OB57YHx0u+MV3qCfzyR8hv+kzlEQ9NSXrAvVbZIc4DPcR8L5AP/40Vk8NfyNp7ccyenoE0cvrB2v7kYKXpihDGWMZ0jlS0KlwVbgqXBWuCleFq8K1deM6tML1usC1LehXZUNVP1Z+orLHrRVXpV+Vrm6LulrFE5W8qjZWst9acVW6WunEtiivSr+qftwWcVU2VOnEtij7yq9WNlTJq8LVDlc1t6raWPnoSle3VlyVflV8Vbgqe5zMNla4Kp9TjUNVG6s2Vj6nklfVj5V+bb24qlxH1cbK51R+osJV6X1lQ5XsKxuqcPWyrlbxRKUTlewr2U8mrmocquRV2VCFqx2uXteJmdnfeGcYf89F3c91RIAO1je4QVGvlv07XfCX0hlKop7oe8sMfyNpbXMBerWQ/JVcrO3zBC9NUcb9PE/QmSfoVLg6x3VYj+Kq2vj6kNe2wFeF6/Vhj5WfqHBVulr5+8nkq+rHqo2VflVjx9bKV6UTlbwq/ar6scJV2VClE9um7Cu/WtlQJa8KVztc1dyqamPloytd3VpxVfpV8VXhquxxMttY4ap8TjUOVW2s2lj5nEpeVT9W+rX14qpyHVUbK59T+YkKV6X3lQ1Vsq9sqMLVy7paxROVTlSyr2Q/mbiqcaiSV2VDFa52uCqdqHBVuCpcFa4KV4WrwvV6x2X3luGdYUcQnaL3o2F9g1N3k6X/DSVRz0XTRRsK1L/a6h9Vrv7brP7R5eq/w+4uOwZe1rJ/Dfex8L4vHvfRNcKXZPXxHeJvEC8F6Y3d23Ys0eP2mV5Y248TvDRFGevIcYLOcYKOwrWvI67tHHE1HXHt6IhrL0dcsx1xDTri2sERl6dOzHHENc8R1yxHXEc54pruiGsfR1yetj3kiMvTF3ra4wxHXJ79uL8jLk+d8JS9p217ttFTJ7Z3xNWrfsKTr20hZqrGtKmTvac9Nhxxebbx6B7la8gRl2cbbaxVc2Hku81zK881DQfiPh7eF5j3nl4jfEmi59mGv5G0trPMPPt4opcnV2v7CYKXpijjefYJgs4Jgo7Cta8jru0ccTV7tI2DjrhmOOLaxxGXp+yHHHFV/VgM1/6OuDx1Yo4jru0dcXn6r1mOuDxl76mrnrLvVf/lqaue+rWDIy7PfvTUL08b8tSv6Y64ZvdoG3s1lvNso2c80av92Kux3NGOuHo1zvGMMat44vVhQ55+wpMvT/06yhHXsY64PGXvGQPYWGt5oKOgXi37t8Mc2H41wmd84jvE30ha+9IrB4btM7lY+04oR28oph+QH5P1iaLMcM3P/h7IwWV16wR/2sCWf5uCxiFEw8qQX3xn8ulP8Wd4Zwp+2eaU3I8XeJuiPssI67E+luyvvlh9NPyNpCP9r4X0Q8lF6YfVVf3K8o/t1xAuzgtbefpMF/UKyKMeK3/D30g66u9aSC7KT1rb5wtemlSWPssBjsv6xLtpk4yL+yt9hpLgY93RIgvjDfGeBO8L9Et/rB4Y/kbS2i9l9OAkopcnU2v7yYKXJpWlD/fdyYLOyYLO1oILdYh9lJWnT4d6MbusXpT0R0G9UH7T2odyKUBvVkw/ID8m61NEmeE6Nft7IAeX1a0T/FqKF5AGxwtWhvziO4wX3krxAvJ7IuFVcj9J4FXjlcG93ugMinpsXyX1L9rvGv5G0pE910L6ruSi9N3qKj1l+cfq6daIy/Tv5ACdov4d659c0XGnc0KHdE6IpDO/QzrzBZ1BUY/9EOppvF+o/VWsHzL8jaQjv1cL2aGSi7Xv1FL0at/gsRnpIU7jx2R9migzXKdnfw/k4LK6dYJ/jsZ5pMHjvJUhv/gOx/mnaZxHfnleWtT/YX2WEdZjfSzXX0kzVh8NfyPpRP/H9VHph5KLte+0cvRmxvQv8mOyPl2UGa4F2d8DObisbp3gP0v6eDrwxPOV0wW/+A718dUM7/QcfoeSqOcCJesC9f96etIquwL1j7b6C8rVH7H6C8vVf4PVX1Su/n+x+meUq3+W1V9crv7nrP6Z5eq/z+qfVa7+ZVb/7HL132T1l5SrP9fqn1Ou/rFW/9xy9b9l9c8rV/8cq39+ufqft/pLy9W/xeovK1f/Qat/Qbn6i63+G8vV/4HVX16u/marf2G5+q9Z/ZVQv8iaitW/uFz9PuP3InwpeDL8NtatAPhazr+Gi8uMVoNwFeS9FuId+eN46SKgh23Mw3VRQVzTRVmZPlmZ5LcL8Q8GeFF87ge/O23zHEdcpzrimu6I6zRHXKc74lrgiGuhI65FjrgGHHGd4YhrsSOuM3sU11mOuM52xLXEEdc5jrjOdcR1niOunR1xne+Ia6kjrmWOuC5wxOU5drzREddyR1wXOuI6pAdxpY/Fvx3mO87tMF9xcof5imUd5itWdphvWNRhvmFJh/mCMzvMFyy1WPsceFnL/lW5gAJx/wU1wpckev5k+BvES0F6Y/Onc4ket4/XG88TvDRFGdvIeYLOeYKOwjXDEddOjrhmO+LayxHXoCOuOY64mo64dnDEtZ0jrlk9istTV2c64vKU/QJHXJ666mmP+/RoGz3t8VhHXJ421Kuy39cRl6ef8BxrPf2Ep+w95dWr+uUZm3j2o6fstwU/MeSIa6EjrjMccS3qUVyLHXGd6YjLU/bzepSvsxxxDTji8tSJUx1xne2Iy7MfPfny1NWFjrg85XWkIy5PXfXsR0++elVenrq6xBGXp656+q/9HXF5xl8NR1yeOQXPmNxzruCZe7T43vLYZ0G9WvZvhzn8mTXCZ3ziO8TfIF4K0gvm8LF9vDf6vHL0ZsT0A/Jjsj5flBkuW7sdyMFldesE/z8zpW0SXPrw+ub5gl98h3ujf3u7ibyjbFlPSspxr1g9MfyNpCO9rIX6DdvHaz3nC16aooxj4lh5K1zTHXFt74hrR0dc2znimtWjuAYdcc1wxDXTEVfTEddSR1yeNuTZjzs54prtiGsfR1yetu2pX5425OlXtwXZ7+CIy9NHmy+0c4kYz+xKdIrG3ljf4Do877Kiw/Mul3R4XuWNHZ43OdviquXwspb9q86SFIjx3lcjfEmiY0rD3yBeCtIbiykvJHrcPo4pVwpemqKM9w+p8xArBR2Fa4Yjrp0ccc12xLWXI65BR1xzHHE1HXEtdcQ13RGXp+x7VVf3ccS1nSMuT/3y9DnbO+LaFmS/Q4+2cVaP4vK07ZmOuDxlv8ARl6eu9moM4ImrGreL4arG7anTr2rcnjrZV+P21Nl2r47bnvLqVV091hGXp7w8fY6n7Pd1xOVpQ57jdq/66F6NJzzb6Bn7evajp+y3BT8x5IhrwBHXeY64PPPk5zviWuyI60hHXGc44prniOtUR1zLHHFtC7Jf6IhrkSOuMx1xecrrAkdcnrrqaUO9qve92sZtwRd68lWNHa+PseONjrg8YzlPeS1xxHW2I65Fjrg8dcJTXr06duzviMtzztdwxOW5puOZB/DMT3juz+EzNrg3rJb92+GdxzNqhM/4xHeIv0G8FKRXC8kF22dy6fD+38Ea1Ud66o5fk/XFosxwXZL9PZCDy+rWCX6fzJiaBJc+fMbmYsEvvjP5pGdsdm9M5B1ly3pSUo4HxuoJ30ddUi+D91Er+1H9ZnWboozzT7HyVrimO+La3hHXjo64tnPENatHcQ064prhiGumI66mI66ljrhmO+LytMd9HHF56penvPZyxOWpX5425OlXPXXC06/2qm172qOnDe3kiMvTHrcF/drBEZdnDMBnuDBe5jNcRe/Axvp53xux8vTp8Hs0D9YIn/GJ7xB/I2ltc5mYXclfycXafongpSnKOJ93iaBziaCjcM1wxLWTI67Zjrj2csQ16IhrjiOupiOupY64pjvi8pR9r+rqPo64tnPE5alfnj5ne0dc24Lsd+jRNs7qUVyetj3TEZen7Bc44vLU1V6NATxx9eq47Sl7zxjA00d7xhO9qqvVuD11frWKyYvhqmLyqdOvKi6cOv3q1bjQU169qqvHOuLylJenz/GU/b6OuDxtyHPs6FUf3atjmmcbPWNfz370lP224CeGHHENOOJa7IjrPEdcRzri8lwf8pTXEkdc8xxxneqIa5kjLk+dOMMRl6fsPW3b0x49beh8R1ye9rgt6NdCR1yLHHGd6YjLU14XOOLy9IWePrpX9b5X27gtjLWefFWxyetj7HijIy7PeMJTXp4x+dmOuBY54vLUCU959erYsb8jLs+cQsMRl+e6lWeeyTP/5bm/kM9g4t7WWvbvdFEvpTOURD2DNcJnfOI7xN8gXgrSq4XkovZJW/suLUdvhxrVR3qI0/gxWV8mygzX5dnfAzm4rG6d4J/KFuCbBJc+fAbzMsEvvjP5pGcwn9h+Iu8oW9aTknL8jVg9MfyNpCO9rIX6TdmPte+ycvR+PUbuyI/Ru7wcvT7rqysFbuPlquzvgRxerG6d4D9N+nCFqNOksvRhHcSyPvFu2hThulLgQjlan6S28UImC6X/6X9DSdRzDPsFw4G4S+rCpbG2ZfgbSUe6XmM/ZvTyfIzSI6vbFGWL4XcnfZ/+3qdHcW3niGsHR1xLHXF5ymvQEdcMR1wzHXE1e7SN2/coXzs64vK0R89+nOOIy9OGZjni8uxHT13dyRGXp35Nd8S1syMuT73vVZ/j2cYhR1z7OeLa3xGXp7w8YxNP/erVuNBT73s1lpvtiGsvR1zbQizXq3rvGZtUY1oxXL0ay/WqL/SM5Tx9oWc/esqrV+Ov0x1x9Wr81XDE5WnbnjbkKS/PccjThnpV9p7+yzMv16u5IU/98ox9ezXG7NWx41JHXDZ2DBJuK0+fDteb9q4RPuMT3yH+RtLaTq/1Jmxf2fUm3s/eK/7Q0456NVfu6cM8cVXrTcVweebmPG3Isx891wM8Y51ezcN46pcnX726rtOrOQrPfvTcq+Dp7/nuVIyN+O5UFYdcHqCD9Q1uUNSrZf9OF/wViJc21gif8YnvEH8jaW1zmfhMyV/JRe1ds7pNUcb78EP7t5COwjXDEddOjrhmO+LayxHXoCOuOY64mo64ljrimu6Iy1P2vaqr+zji2s4Rl6d+efLl2Y+efHn6VU+d8OzHHRxxecp+Vo/i8vQTMx1xecp+gSMuT13t1XjCE1cVA0zd2FHFAFPHVxUDTF0/VjHA1PmJXo0BPOXVq7p6rCMuT3n1qp/Y1xGXpw316tjRq7Fvr+qXZxzt2Y+est8W/MSQI64BR1znOeLyzN+f74hrsSOuIx1xneGIa16P8uXZj558neqIy1MnPPtxoSOuRY64znTE5SmvCxxxLXPE1au6Wtnj1LWxV/WrGocqvWdcb3TE5RljevbjEkdcZzviWuSIy1MnPOXVq/a4vyMuz7lowxGX57qVZ37CM2/iuZ/Jch22/xDn8icQnQFBZyBAB+sb3HRRbyiJek6x/XtHwssa4UV/3BePu14jfElWH98h/gbxUpDe2N7F04get89kam1fIHhpijLOySwQdBYIOk1RtrwLuKbn8DmURD0Xq/4uUP8GlqfhQN4WwvsCfbtbrC4tzH43ktb+K6NLC4leXr9Y2xcJXpqijPtokaCzSNBRuGY44jqtR/na3hHX3o64PNvYdMS1gyOuWY64Zjri8pTXPo64dnbEtdQR13aOuDxlP+iIa06PtnHIEdd+jrhs/jJZsaqiM79DOvMFnUFRr5b922EscniN8Bmf+A7xN5LWNnvFIkouRWORN8LvTvXJc5w+1hGX5zjdqz5mJ0dcsx1x7eWIa1sYK3o1bvbka0dHXJ5xjWes66kTDUdcnjox3RGXp7w8/VevzjM8+9GTr14dOzz70VP2nra9Lc1Zek1evTpue9p2N8Zam68shHq17N/pol435mqGv0G8FKRXC8llIbzjudqZgpemKON14zMFnTMFHYVr0BHXLEdcOzri2t4R106OuLZzxDW9R/ma44ir6YhryBHXfo649nfE5SmvGY64PO1xH0dcnnrv6Qs9+7HhiMvT53jqxA6OuDxlP7tH+VrqiMtTJzxjE89x27Mfe9V/eeqXpz32qo/2xOWpXzMdcZnsbf1uEZRdSHQWCTqLAnSw/qJJpqPml+l/Q0nUcw3P3wwH4sZ9sAXmktfWCF+S6Lmr4W8krf1WZu66hOjl6Ym1/TzBS1OUnQG/sQzpnCfoKFxHO+Ja6ohrO0dcOzri2qdH2zjHEVfTEZenTsx2xOWpE6c54toWdGKGI67tHXH1qm17yt5TXo0ebeNejrg8+9FT72c64vLU+30dcXnqxJAjLk+dqOKv14eP9hxr5zni2hZ84f6OuDx9ziJHXMc64vK0IU95eY5p2zvi6lV5DTni6tW5lafsPW3IU16eProaO14fY4fn3Gp7R1zTHXFVOYWpsyFP2Xu2cWdHXL06H/KU/aAjrl7NFw454qr8RDFcnvFE5SemTva96ics/uI7M9JnKIl6arZ+ega+JLwl1477a4QvSeLWjs8oRy+4doztK7t27LVWlT7LexyX7X3Avj+L6Cg5LwnQwfoGNyjqsf5hHxTQh1Ni9c/wN5KO9L0Wkr+Si7X9fMFLU5S9EX5jGdI5X9BRuGY74hp0xLWXI67tHHHNccTVdMS1jyOu7R1xebZxxx5t4w6OuJY64jrWEZenfnnao6d+efpCT75mOOLy1PttQSf2dcTlqV+zerSNnrJvOOLy1PvpjrgqP/H68BOebdzZEZdnPNGrsh9yxFXZUDFc8xxxVTY0dbL3nLt7zpH3z37PFG3mOwHnCTrzAnSw/rwAnfkd0pkfSacb7Zku6g0lwaduPzgvargRL/ZVN3LChr9BvBSkVwvposqJWtuXCV6aVJY+nHtdJugsE3S2FlztdJdzwkV196xIOpXN9057pid6HBpKop53Kh9SoP4RbKOGA3m7At4X8BdLY/2T4W8krfZSxj9dQfTy7NPafqXgpSnKPL8zsr0jrm3hG+29+s3eXv2+tGcbPfma54jLU1enO+LytG1P2c/o0TZW/uv14b882+gp+x0dcXnq/bGOuDxtu1ft0dNH9+pY69mPnt9A2xbGoW2hjZ58efrVXh23z+9RvjzldbQjLs9vS3rGJr06plX2OHVt7NVxe1uYp3nqxCJHXL2q90sdcfVqrmMnR1zd8NFqTeAMolN0TQDr98Iax3kd0jmvx9pTrUFV7Ul/X9ghnQsj6VR60DvtKbFvw57jbG3waHhZI7y4HlhgnXJmjfAliV4XNfwN4qUgvbF10VOJHreP10WvELw0RRn2I5YhnSsEnaYoW17hqnBVuFxw9fD+OAupx3wN+ib2syX3n0Tvj+P9JyX9enD/CbaP/eyVgheeh6QP60jZOU2v4trGY5FpX9vxF24deO5N1x5xyIyzvrfbnIfvWPBb971/wSGH83hsuBEvyrCAztZjbcTwN5KObLIW0hHl36ztVwlemqKM7xW4StC5StBRuOY54jos+13NGbZiO/3++q9/7Mv3fea3XtzwwvOPzv6zGU/scPj2v7Rx43f3/Ke9Pvzaxuc6tMVLrf5V5ervaPXfVK7+HKv/C+Xqz7b6V5erf6bVf3O5+ous/qpS9WtjfX8NvB2Kqjve9mvHsBXifaHVX12u/r5Wf7hc/f+0+m8pVb/2mtW/rlT95D+s/vXwcsh+nP4rfVdc/+l/W7vDkjteffuf/ekFt87Ya9Vv7nvP81f89oP7fvvqu63umnK0B63+W8vV38Hq31Cu/p5W/0Z4ORRVNZlmdW8C2tPi60+3+jeXq3+C1V9brv6JVv8WqF9AdkNW/23l6o+1f12p+rVvWP31yFT274F//IXtfvTxB+q//CevrX37Dw7d/D+X3Pdrnzj1od874vT3rvzbR/9pmdXdUIp2MsPq3ypot+F7zNfdNvamWA7L6r+9MO2kbnXfoep+60NP/lLz1YdGhg77vR8MLHngH6/+l3P75//Z7/3i7l98/0++/drDVvd2VfcPrvjJX362ufmd77jv8++aP3fHVS9v/vr3/t+XvvxK81/++pNv+/qYrr4zAy/Y5p2s/rvK1e+3+r9Yrv6A1X93ufrbWf33lKvfsPq/VK7+9lb/vfByKIl6mlb3faLujkcnX9/3G8ffftguJ6x94213fuOiT75np2ff8PfN3f7p1lNv+/FfrLW67xd12zzH9//sf7dkG1EsBrU4Mv29O/xO/7ODf2k9i0F3AxirWyf4Hx40Xm9DRm+Q6hiO9JlO9Qv2xe41wpcket5n+BtJa9vLzPvqRI/bx/O+fsFLU5QNwW8sQzr9go7Ctb8jrqYjrqWOuLZzxDXDEdccR1yDPdrGmY64elW/Zjvimu6Iax9HXJ765SmvvRxxeeqXpw1t74jLUyc8/artfx0U9WrZvxYH7ALvC4zL02qEz/jEd4i/IfgsEwfsQvTy5LJDMj4m3LphzY1rNty+dO2q1YtX3bL+1huHOTLCaIilgljxXS2Z2Hos66N3fQR3Nv29VNRLBO4+oLsrlClJGE6LPrFNu+bUQ1kk4t00Ab8L4dpF1DPe+wL102dQ8DDVGlsyUg5qLLaPI9ddBS9NUYYyzPMYKkIuytcOybg3zyzpzOFrbr1u6drrEnpYdc7KYXE3gluaw1pN4K3Rf/x+N3rXl4RNNTRZilGZJGl1xijq3YhO5YwrZ7x1OOM+UY81ZqZ4z1smi4YyFwp6is7FHdK5WNCZLuoN2Y/3PffiXy667/eO+tufbH/vslV3vuPYD/7hpd95524vHPTNt35yr5fnpHW+TikflD87YOt3TPmo/qoT/BkHjdf784zeDlCeWdgZt954w4rhDevWDN82/DNfjYnmMRElQI7V/QL6+42innpixvCSjifa0Rl+rzFcqVbeWBnv6FghUCqIFd/VkvKO7o30dxlH1y5qYEcXck7YK9MEXXs3Lcl3RMqJca4x5MjSpxqatzzFNXZbHppjNDZ2aM7T2Lyhmev1J/kaXifYf82GjA41e0LmiXmsxoAtTzUGbC1jQJ+oxxoT0uoYrUyS1iBUtX960iqPIfvxNxsWP7hh15tO+M70r9139Oiee3/j+y989u9/ePvw/H/8+299br/vd2hdl3ToFS5O6Q5mrsH6H7MWPLmzdVAMgnHd0+rWCX7P2eP1ZmW/U8vLYmOzvEtW3bhm9aoNw2fd/LZbh28dXn3B2g3D6xfdvPqs24Zv3lA4JF5Cf58j6qkn2KHhZ6BypVuerENXbli7btV1wyuGV61md9gvOMfyCaxk/7JUWQPY/TKepQJPImj10e+awB/jSmuCt+2h7EhBZ1eBz+Btu+oA8IgwbH4Gv29mcumyxaIFW34rl2b8DFJ9K08f0+KjiPehJOqJ1mLD3yBeymrxUUSP21cuIEBnyVJBrPgupOGTERAcA2VKEqzF2KZjcuqx5vK7aQL+KMJ1lKjHAYGqjziwHmsMWxEOYkcK2mxFR4EVnbkgn+6RSasc2JKmCXpmdccQbPqY1R1HbRpKop5LY63O8DeIl7JWdxzR4/aVszrUFKRyCWE1GITF5xLgDOH5b+69flGPH8NTJ57PhVDoZAq9sF0HEt9K2/Edh6pY3+AUnT07pLOnoGOajNvmDqOyAwJlB0HZgVR2MJTxas0hwOdyKpubtLbZyg4P4DxC4Ez77luzx+uk/y0EOKXp7FUXAE2si3/3C1g7+lQn2KtAry4gvUIrZr06pg3fIb06Jsmns2eHdPYUdKxPUH9Zd44TbbWy46GM+/lE4IV15yTRLis7OYDzFIEz7Z9vzJ4ItxDg2OOfA++LTA1jPb7hbxAvZT3+OUSP28fT5nPL0bu4RvWRHuI0fkzWy0WZ4VqR/T2Qg8vq1gl+TdafTYJLktZjs8sFv/gOk4SrSU9QtrWcfw0vv2P7wrYvTCbSQX+zG/Bzc47Pw0gK61pagn3VPFgTexv5KqzPfWf1rVz9myRx7V+YtLZxZtIqmz3gd55+nxOgs0egPd3qzz2IzjGirans3039eS6U9Ym6duSwTvC7QX++l/pT2aKSM49LReV8oKDTbTnz+LLckQ76DUyxpf+tJFwsZ+snk/MKKFtJ9S6CMoTDWddKeH+RoK3wG452OvjgbN22PB00WnWC/48Dx+s9XFIH+UoN7IOFyUQ+jQ+UA8K/KdHtGsiBz2vXkzDrXLJgIk6MKVRfsP81+KcA53kLNJ/YrgXwjpdAlD6sFO1SMr0oaU8b5bw0h/ZAEtbFOsE/L2SqxoWVxDvifgPxsqIN72zfWN/gBkW9Tv2I4rmdTb5S0CbfnP1m3f07sMlPk02GdAR55nlEUTnvKeh0W848R7jIkQ7aDI8LlxMulvObs98m50uh7HKqh9cbIByOC5fDe3XVh8IfOy785mzdtjwdNFp1gv8y6OBvB+bFIR28iMpQpguTiXy284dvJnjjeyAJj7d1gv9KYFxQ9op6w+OCwX8tMC4YXWxXaFxQunipaJeS6eWEa4HAhXLmcUHJFNu/gNpv8H8cOS5YfZWPOJTKMB9xLpVhPoJj1hOhLJSP4NwI5iPY350CZagjnI/YPdCeA6CM832YtzuOyjBvdzyVHQJlJ1IZ5u1OojLM251MZUdA2SnQVsvb8RL1P2TvO1zfkhtt8vKiDIf/JknceLA78Yl0jnKkg7jOJjrHONLhFQekc7ygY/11ItUbSqKe6PVIw99IWm23TJ7sRKLH7Su3MoLehqWCWPFdLZnYeiybjPXIk6BMSYIz59imk3LqoSwS8W6agD+RcJ0o6hnvfYH6iAPrscbU6H3eeqThqBN8PVOLdLRaRqO1ooXy4BHTeM/bWcA8GPx04GHRAo2zntOu43Nw7jlnXB47zNE4E4FTteskahfzcCLxYPBNaNcSWus9SdRPct6lf2NkdFIOf6qfmFcc5fLaw/1k8DsH+uk4wQPa5NI2PDDMSTk87C54EN5t8dpbbs+8W0JPu/0/LHletz1O4Ml7DH+qhaaRvJ7Bnkq9Yw2wumnL7VMIYwf1bhzeMJzT9mmCN0WTt2XaEzOGllxrih5Dea2p0zFU5YjVGGptV3nApihbCL/x73Z00j61T9fADri8Lo0dXGuCrSTJH2RrycSuwDpdXHIsrQYLy9ErvORYLJRC5WSpIFZ8F5J8u972OD2hFkMXCpwq+X1uTr12Tm6agD+HcJ0j6hnvfYH6iAPrLSQcbCF5oRSHHAZ/IgxNZy7Q7bS/r4ffvHVLLTR1uNA9O9aqDH8j6ciKayFdUgtwxaxqIfxGKrMIq8EgLD6zgDOEzxsW7Vkm6vFjeFhLzofAdGH2e2bSqp181BV5CA0f6qgrp0pwU2Pe1pf04ZRRzPYWVXayaJdKJ/HWlwUCZyq3++ZMhFsIcLWcf9MnlDowOautFaix7P3U1g7DtaINrtCy1grCtbINLk6FqiUsTkOqephCvTCCB3wXOtZtcIOiXtk+awZ4Dm3XSnXoKpoUXgRlarSwG2N5GfCzsDRwNdkzpot5GRB5ZlsvKueLBZ1uy5nt+FJHOpji5+UptUSEcrZ+Mjmr5SWrh7dn89KSWsJSt7or/IajnQ7eMke3LU8HjVad4J8AHVwfGFNCOngplaFMFyYT+VTLOKoPasR33lJK3rLbO0UCJWSvyNcywmnw7wacvDyllptUtBLSxctFu5RMryRcKlrF9nACRckU7eYcar/B3ylkqpaneCkJY4Yiy1OxS1C8zIQxA8cvaglKbTtEHbGYgQ9kbMreT09a7aVAxCuXbAyX+iIBLnNhWZKM92foiwRYP/Tlg7kd0pkr6AyKetbuDuUYPf83/F5Hu1R8reTCMSfWVXbEydQDsr93znI8qW4+TfEsHoJiufJS3VAS9ZwQK1fD3yBeysp1d6LH7WO5HiB4aYoyzmsdIOgcIOgoXNs74jrWEdcMR1xzHHE1HXF5ttGzHz3buGOPtnEHR1xLHXHt5YhrO0dc+zjiGnTE5akTnvboaUOeOuEpr5mOuGY54vKUfcMRl6fspzvi8pSXpy+c7YjLU1696gs95eXpc7aFmMlTJzzHbU/Z7+2Iy1PvPWW/ryMuT9l7ttHTT3jGAJ7yGnLEtX/223JMmIeYR3TUnH/3AB2sv3sELpU/CLVR5XEc7zg3FnmZOC8MqAm8NfqP3/MGgj4Bi7jxUrYubtc5pkb4kqS3tusU3bV1AfzGMqRzrqCjcG3viGsHR1xLHXHt5YhrO0dc+zjiGnTE5akTMxxxNR1xeeqEp7xmOuLylFfDEZenvI51xOWpq3MccW0L/TjdEZenvDzHodmOuDzl1avjkKe8PP29p355+hxPe/TUCc+YyVP2ezvi8tR7T9nv64jLU/aebfT0E70afw054to/+60OR8wjOkVvp8L650TgWihwhdrY5TSJsXg0weWFATWBt0b/8fuj6V27NAnvytmYLdVbWmQe4RpK4h61G8xwzSSa6W/c7YZlSRKXqcP6BwToHNQhnYMEnUFRz9rdoRxnoPyQT3yH+BtJa5vLpJfmEb08uVj7FpajN1hLWk21T+A0fviMkHIrZj8DObh4Z6jBP57pfjNpdSl8siHWdaVpyM07TuQdZVvL+dfw8ruQS4zRx7J0UJ/4oseFUMZ2vJDo5LllZccLc3Dhjuc1AHMKwWM/K5yHQTnCP5/1VxpaLs+207bbyf7Cju15PV7wyqej3gU72T+e4VRytn5XerCQyg4QdBVO9o1WliRxfXeQ4CGEC/vrYIK3vhjIgTd83Hefhb7jHfN4gY3Sn4U5PKD+IA95+vNfSujPF3ZszyvWPZhoG/ybQH/+G+kP1g/pD+/mRf1ZmEzEiWW807ro2Ir1Q2P4MVSmeA+NY/MCPCgZKTqXdEjnEkGn2+PDJUTnFEc66hSjmgJcBr+xzOjwO6aD9UOXkM7tkM5cQadP0DkccPBSm8Gkj8VJGEcUiJPqMf2C+BvES0F6Y3GgOg2qpoJ8GSTWbYqyvEvDkU7oQkrEdYAjrhMJl9KbywSuovLqwrTyEoK7KIe1PoG3Rv/x+0voXd600nArk8y7CiJJ4kxS3fM3Waav6JzQIZ0TIunM75DO/Eg6Z3ZI58xIOmd0SOeMSDpLOqSzJJLO600PJqs953VI57wea8/rrX8mqz3LOqSzLJLOZPmdyn7Ktaeyn22vPV288ik6dW74G0lrm8tMmdTKkpJLh1PCsdR56FtIyI+aoqFs0//Kfl/jtOwSRp5SJUncpUBqepamsOZneNVlQ6z3RVctsb7BKTrzO6QzP5LO6609R3dI5+hIOpMlt1M7pHNqj7VnsvTgig7pXBFJp/IHvdOe0HdGU7++ZidNE5c7sK6lWXnJ9qBdx+vdSGPFAVB/gNpYdGkC64eWJuZRGbaBl94OFzhrVIb8HR7gD+sfnlMP+Ukf/saDwaTPdGpPLSkUm0RfYsPbFo4oRy+4bQHbx+nqkwQvTVGGMsyjMyDo1AhXO74c08LG4mEEl3e5e03grdF//P4wepeXFra/TfWxm1n1USwhUSnVP2KS6TAuvKRfub46wS/JviGUuq97MvcVc7cUX3g/lEQ9x8aapeFvJB25gVpI/dXqqLrfbOxjAqLsbPiNZUjnFEFH4Rp0xDXLEdeOjri2d8S1kyOu7RxxTe9RvuY44mo64hpyxLWfI679HXF5ymuGIy5Pe9zHEZen3nv6Qs9+bDji8uxHT//lKa+ljrhmO+LylJenDXnGE57y2ssRV+VXp86vesp+b0dcnnrvKft9HXF5yt6zjZ5+YqYjrl6NV093xGXxquUecI5+ANFR8+GTAnSwPn++FevVsn+nC/4KzNv7aoTP+MR3iL+RtLa5TJ5AyV/JRZ0CsrpNUcbpu6JL14iLPw6qUrXzBK4a1W/XRsdUoLF4DMGtyGFtmsBbo//4PX+9Ni8VaLhVFvzkHL6TJC4LjvUPD9A5vkM6x0fSOahDOgdF0pnbIZ25kXRCBy/YxakM+bwAD6FVFKRzVod0zhJ0+gSdhYCDV0rS37iatcvOE3k6Bsr6RF0+vGPwF+48Xm/3nSfKAOVj962pq+j4K9m44sPDA34xvBurO4a/QbyUHR4OIXrcPnSd8R9TYytFqSBWfFdLWj1bDTjDdwfQ37tTvaWiXiJwo0edC2VKEvyRLmzT3Jx6KItEvJsm4A8hXIeIesZ7X6A+4sB6rDE1ep/3iULDUSf4wzKrUl97VrRQHpwAMd7zvuDLPBj8POCBvyJ8CNRR7WJrnkt/oyc4LYf+meBljt1Z008EfW4fjg55X1I+hHgw+BNBBvxl6MNF/STnHcoA6+b9jbC7Ulv4Qx+si/wV6SPatJ373+BPD/T/QYIHvOxzaRseGGbXHB7OEDx09hVp9nLcS9wTBwk8eY9JI9VY016WDlsH07G/lQZ0+hXpA3JoTkv0M5ho3tJnetLRWBk9Nhv+RqI1byiJemrsPY0et4+nbocIXpqiLM9K29Hp8CvSeYO2chZcP6G6NfEuffCKWhuocXbJ0yE1c8R3oemQwSk6x3dI5/hIOgd1SOegSDpzO6QzN5LOAR3SOUDQYVx5U4hrs991gr8WHDt/3Q+n94wzffjAqMrGHCDaY/ALBfwpoo0qQ7YwgjbKkgfCcwryGtqkj/TVPRnnFuR1xSTzGvoaYRcOWkQPOVN10KLYdBA1lqWCWPFdLZnYeizjkeVwgltCf5eZDnp8szmkWYl4N03An0u4zhX1jPe+QH3EgfVYY1S99O93iDohC4jR4PThIGa5I64VApdZJn6ntoCl7BxrmYa/QbyUtUz1/WZ1xMfarr4T3RRlnMe/SNC5SNBRuE50xHWSE670WV7hqnBVuCpcWzkutXa6gspw/DQcanbAM9Si6+dY/6QAnbM6pHOWoBNap+d/jQ6/YzqKZ2sPjt0st6I3I2F9/j75MVCGi2G/trOmiTNZrLsm+10n+PlwNuI3ds5vI8rZ2sU8TwcaVlYgrpmZzqZX0k1+GOP0A948+8EYbkP2W8US86gM+5q/9Z7XB1+mPjgJylQfGD91gt8P+uCr1AdYn/2HshtFj3VkIAf+JOLP4P9QLCMo/s7JoYfyQDm/M4fe10V2Remd0e5Q73ZWeof2ynoXG3fH6imfvUE9XUi4jhG4UA84Y2P1BxLdB4aPb0j9G9HnsXrO/Wrw34zsVyd/IvsVZcX9uhDKQuNQSA8WAozJpJm09vlxhOs4gQv7OqZfjxH4uV9fC/Sr2lCBfHK/Gvy/RParybIb/YqyiulXhOd+VeP3QoAxmTST1nHyEMKlfHQow7ow+3sg0X3APtrg/zPQryrLHfLDY/R2Gcc5VX4YZRXTr2olILZf2Q9jvy6gstBexcny0TOgf6zPOeZnv5DHn5Jbh4t7vBZ9bg4bO4n6CdWt0budcnAZnvQdplVZ5NbcvIuvWeQGv5MQuTJT5Ee5KGtPh0eNoxcF+KjxMeXoBY8aK5da9Khx0WGxC6qaPkty2KiJ+gnhqol3WKZUFdcHTVXVdkgcoXehmQKqUMxlUCryN3iLQPOiC76gyuAPFubBOJEHjKDYW18q4DEy5m2y2IZLqQzrnZNDB0dH9Pw8Ohr8EZGjo9HuxuiIMuLR8XIo6xPwLO8rBfzlAMNZpSuhjE0aZXwp0WnnOlj/lZ6q2beKxo8PtLfdrIz1C3WCs2hqNqd0weC6kSnB9rAuhGwpfVg2Id1B2TST9nqCdsl7H0J+KX1CuoDZBcuGTQfcSGcoiXoOMTpq9dlwY38W6LNrkSd71FBt7xrES9mhuo/ocft4qGadTJ+mKFsMv7EM6dQFHYWr6YhrqSOu2Y64pjvi2scR16AjLk957eWIy1O/Zjji2t4Rl6dObOeIq+aIa5YjLk+d2NERl6dO7OCIy9Ovetq2p672ql/11AlP/+VpQ5464SmvmY64POU1xxGXp6568lWN21MnL8941dNHe8YAxzri8vRfvaoTnn6iV8chzzmMZxt3dsRV+dXXh//y7MdFjrg85dWrPqdX48KGIy5Pe/Qcaz37sVfj1fN7lC9Pv7qvIy5PP9GrPtqTL0/Z96qf8IzJt4V5ree4vVOP8uU5r/XsR0979JzDeOZ9PXF56gTbUC37G2EOg9+HQjnC24dyOlwrXs1rsYYDcfeXxF0jfEkykc+E8A8KesZXI6dsKAk/H/j0F59c+p3f/XaN6hsv/I73JwwIeLWmbbJCXSkgq2vUHg6jbWWoI/1UhnIxHtJ/r18wkb+BkvzFyA/xNwU87xWL7YvZSasdmZxsXwzi5lNSoQ8qIp2mqL88QGduh3TmCjqMK+8DWtdmv+sEf2TmF9R9IWoPzFzBn8GHTp8gP0o2fLJJnYaP8Q/Il9otfTzRWelIB/daLSQ6FznSUafY1b67Tungvio+zXi5Ix3co3UA0bnSkQ7uC5xHdK5ypHMVwJwC9dK/r4Yy9TG2VYIP88XXwPsCvrge0w7E3yBeCtIb2991DdHj9vH+rtWCl6YouxF+YxnSWS3oKFxHOOKyvp2ZtPY1f8zxakHn6gCdEyLpzO+QznxBZ1DU69RGlGyMzjWOdNBm5hOd1Y50UA92IzrDjnSGAeYwonOu4CGNB96y6/j79L+3QFkf1U0fG1/qBP+fB4zXW5PhNB1cBbSRR6yP8dgq0Q6mdzPNWa6DOgX80YQ5Z0K42snuFpLdKiiLkZ3B/zXIbj3JDtvFtn0DlF1DZTdB2WoquxnKEAeWJdAGfMc6h/UNblDU4/FqLbwv0F/9MbaB+BtJa5vLjFdriR62PX147nZLOXp1o7dO0FP9MCvRMkX6hstsTPnZ66gMfePNVIb+7CYqQ/s+FH4jzrw28U1kyB/rN/K3gsowpl9JZRiH83kIjJ35LA62meNba3M/4Ukfm8fUCXYzfJz4gey38jfsx1cJ3Fb2FlGW4v/4nhPbgj4F5Yhl6dMn3oXGUINTdM7skM6Zgg7jqietc8v0Yb9r8J+hMQR9WQGbvc7kfxO8ZH9X0v9cF+vv8nwv8qV8YUzeq/6lZ3/jC2/9/vKiY0TId54p4Dv0nTLvZbRV3utmKsPck/Gg8l4lx65rYuSH+JsCfjHAFekLhesiJ1zsczvFVZYvy+1h7MPxjTo/h+MSj0ErAnxd1wYXj0tYn33YDW1w8Vh1nWgjxyUM1y9wM+3BpLVt7MtK+snoXIPhb4g2lIndlGzVWMN+HOs2RRnr/E2Czk2CjsJ1kSMuzpd65DGVDp9BPBe9GQ7rX0RlKwUdnjOnv3E+9tVdNT+o9zjf5rjA/v4azMd+n+ZjSDsUW3JOR+W/1TlyldMJ0TmvQzrnCTrdzn9zTucGRzrom84jOjc50kF745zOzY50cFzkucBFgodUZ/+O7GAtlCm7tL6pE/wtYAffDtgB8oj1MdZSuSmm908Uj5eMA2VOx3C1k91rJDuc2ynZsQ8x+JUgu38p4EMwtryBylAeN1HZOihDHFiWQBvwHesc1je4QVHP5Gv9tR7edyOnY/gbSWuby8QF64ketj19eF5yazl6Yzmd2wQ91Q+Y00GZIn3DxTkd9LPDVIa+cR2VoT+7hcrQvjmnM9ymTRxPK/5CufCpijmHy9ELxpzYvrIx52nwG8uQTtE40QMX5+emIhaa3yGd+YLO6yUW4vWtbSUWOni38ffo32PHc4P//v7j9d6Q4exmLHRkRmMqY6GjSHZlY6Gvg+yOJdkhbbZtlBPHQhijcCyEsuL1RitLoA34LrSmynLDejxelYxNomMhw99IOtKPsfFKxYhqvOow1huLhW4V9FQ/YCyEMlVxUSgW4vwC+kaOd9Cf5eVi098cC13Upk2hWIj3gGHuIv0b91fwmpLB/jrY2XmZnak9ZpckE8tQx68GusvIVlEunL8sGjtg/ZuIH4+xSa11c76qaI4a6/Oa6E2CDo/p7F8v203zg/4V4wH2rwb/CvT7ldRnSJv9JPLMMVrR/jwhks55HdI5T9DpdkzDMVq3YhrOV611pIPjJcdotzjSwXGIY7TrBA8/30dDdrAOylS+nvNVBv9GsIP1ATtAHrE+xmg3iHYwvXdQjFZyTJQxmuFqJ7t3kuxugDIlO/YhBn8MyO7dBXwIjsk3UxnKYy2VYS4DcWBZAm3Ad6xzWN/gBkU9k6/1123wvhsxmuFvJK1tLhOjxeaPrH23l6M3FqPdIeipfsAYDWWK9A0Xx2ihvAf6xlupDP3ZeipD++YY7aY2beIYTel+F/d7ROerDH8jaZVjGd1SsZAah3lswrqqbzhfpfaCqJyrwnWDIy7OV+F6OMdCat/aNQE6J0TSmd8hnfmCTrf3SU9VvqpbMRfHQt2KuWJjoU/ReH4LlMWM5wb/h/uN1/tMYB7Ha0W3AL5EwB+WQ++/UCxUMv8hYyFeg8qT3RdIdjdBWYzsDP5zILv/FpAd2zaOO5yvio2TODZVa1T4LhR/cwyJ9Xi8KhmbRMdChr+RtLa5zHgVmz/qMNYbi4VuF/RUP2AspNbrEBfHQuhneV81+kaOd9Cf8boe2jfHQje0aRPHQmrPGOPCs+Uq58Tzjj/O7Cu1tT+inJXap5zCXbX7RLgqDptYV/X92+E3liGd2NhptSOuKg4bp8PvisRh3YqPOA57veWk8nKzP4jISYVyswZ/6X7j9f41EEvE5KRCcZjB/8ck5qTyZPfTiDgsJDuDPxlkNy3z+TFxWJWTGucT3yH+KieVn5MKxWG9kJNS/DGu2DjM4PfI7KvDuEn6DT6bVMVrE+uy/qTPYoDjsqIx1rAjripeG6fD76p4zYdOmXjtpN3H3+MYVDRe+/Oh8XqnBmIOr3htEfndqYjXFpPsysZrvzY0Xu9skl3sXQUcr6l97SqW43GwaN4M629reTM1Xm2tebPQGiLHZOjPOG8Witc88maxOS6mmRfXXUrlBr9q93GcV1PeDPm6Dmj/fZVfe93k1/hOBsTN8VrR+61OEDwrOvM7pDNf0On2PU0cr13nSAdt/vW+zpkXc7yX/Jta5wzFHAZ/9dB4vTsC8ZrXOuc9FK91c50zT3b3OsVrZwyN17svIDu2bRwb2b9U65xbnmqdMz9eC90fhb7Ra53zujZt4ngN+QvdNWTvQnGYwT9PfqNkHCP9Bu9LU/fJdnhPXnS8ZvgbxEtZ/Vd9p+6UUOco+U4zjPMWAxyXheJCNV8cdsQViqOqeG0inVC8NuxIB/uX47VuxYUcr3XrbENsvPZbFHOUPavyt/uO1/tSIEfE+ZybAV8i4A/LofcV8rs4TnTqdw1Xu3OUX82Zy8eeozT43wHZ/T7JDmmzbaOchqkMx1SO5Tz33mJ9lpuai3R47jU6XjP8jaQj/Rgbr9T50tA9oSXnD2PxWuwdFhivqbtBEVcoXuNzlOgb11IZ+rPQeTmO11a3aRPHa0r3VY4Lz1RyjkuNS9NFGwv00cxYHTT8jaRV3mV0UN3JocbrHX7230HZ71s3rLlxzYbblwxvWH7rNTeuufb84dvXL7p59fJV6zasWXXjotWr1w2vX49MI6EZ8B7L8WEY+71CvEcc17VpDCsDdlbMJXuIiy/sU5fsGa6b2uDiC/vU4MZ/9yetfNph32kReNDQ8vjiQ/Zq8SXk5FE530W4sH5ewiUP1y8SLqzPi4uYLGI+WV4hPHkOFPl6N/GVdwg9/e/WNrjeRrjyLvdJ/7utDa73EC41Cee/+5NWPlleITzpf7e34euXiK+8zTfpf3e0wfVWwqU27xiuO9vgWkO4sD7Wxb/7k1Y+WV4hPOl/G9vwtYH4uhPKNlIZ1juH6BSdpGH9yZqknUN0NjrS2Qgwu0G99O+7oExddqoOMdngfze870bCxPA3iJeC9MYG/7uJHrePEyb3CF6aooyTHPcIOvcIOgrXdY647qL25F4EtMdEmmUvs3kVJmFvyHCq2GMjtVHFMeoy0hq1a0DAI746wR+Z8bTdz/5bkl1crWzkuhxeeDyNuRAY7asbNmL4vS4EvovocfvYRu4WvDRFGSctlC3eLegoXDc74uKL9vJs5DQnG3kcbGRhD9rIWQ42gjFUjI10cnkk4jN+8B3i97IRFcuGbOQuwUtTlPHGemWLdwk6Ctd6R1yxNnKRk428D2zk0i7aiMk71kYM/ioHG8G4OcZGOkmGIT7jB98hfi8bUZemhWxkveClKcpwzoRlSCe0OI64bnfEFWsjNzjZyFvBRm7uQRtZX9BGFO/dmHup/NXR8DtPRqEP8Bwt2qPmeEdTe/J05N17aH6UjqS/bf7OC+uXgY68N6AjvbCwemqHdE4VdF4vG+FOJTrrHOnguMILq+sd6aCvjL2g9hGyg1uhTNmB5YvqBP/jfcbrPR6wg7ycZR3eD4t2ML2PZjQ63HgkF1YNVzvZPe00zvwFyO6ZAj4EY3r28SiPdVSGYzLnfVV+Fd+xzmF9gxsU9Uy+1l+Yt+zGwqrhbyStbS4Ta6lcsTr4ae3bWI7e2MKqmkuofsCFVZQp0jdcoYXVYSpD33g7laE/u43K0L5jLuvHNoU2wnHspzbYTNUms5ILtMFNZtg+juPXCV5U37wXfmMZ0gl9iANxrXbEZWsM1Saz1ne9eChgW4mF/neBWChJWsdzg383jOd/Mgmx0F/2QCz0DadY6M0gu7+pYqHQs9XEQneWozcWC20U9IrEQmpN+/UQC/UJ/hAObU/lkxLxrhagxzSmibrvI76x7AqiUTQHdIXgt4t53b5Y+9pa8rq8ht5JLjYm5ulwA2N0PD4ZGxivgHdOm2j7Qv1wXYBeybW8aUYvtLcL6aX+dCBp7cN2H0JBGthfeTZfdj/luja4QvspeR1wfRtcvJ8yb+Myls3NPnyf+uHd9pwIY3sB9wKYPbLfbFMoh5/vJSG40IeAOvlQDuJLEm17/FHETj8EpPoh78M82yVhHcE+yttnula0JUZnQx/WUfwU7VO1qTyFOzQAd5OAU7TSv9WHxTkWPyLDkcp5/YKJbcT6vDd5xTjpMXnhu9DhDLZZpHNCh3ROiKQzv0M68wWdQVGvlvOv0eF3TEfJJnQIsywd1DHODQw70kG74dxAt3IdnBtYLXhIbebMPcffs62Fxos6wddgfrskw6n26Od94ApzA6EDaAa/NKMxGRfr5cnuApKdOoAWkp3B/9+9x+tdGJAd27b60L06MzBMZTg28N66ogfQ1GUQ28oBtNAFT1vDATQ11infyAfQ0J/xATS075gP+YUOoKmxPD1clbkaOFx1/vDtl6y6cc3qVRvWrL15xfDbbh1ev6EOmNXIwR6ePTFeDZX31OjvaVS2gsqXCzh8QqNph1ccREe+hr+RtPZCGctRJ7pUlMFX9WBddVXF++E3liGdmwUdhesaR1z8iYrqKs98OqGrPKtPNufTQX2LjfQ2UrSCx3ZjohX7eyNEK/dQtIKjBu+0Xw34EgHPkZ7B30eRXsmsm4z0ePUdfR3K7oEI2aFPy5Pd9SC7h0h2SJttG+XE/gX7mz8jiLLi3ZkqG6hW51VEMAm7FqIjvcnYtaCuxunw6ouxSE9FlqofMNJDmaqTuBzpoZ9dQWXqGovQFTrKB8VEetimmEjPdOtcQcfKVkHZSip7i2hzancfJ7vDz0UvoXZYGbYD37GNLBH8KDp8nZW18Yvk60pe83TaINExHIj7mpK4Y+0yL25AvhqirB7By492XHjEP49878ka1Tde+N00wI+6jPBLBHyHY87Jg0AjIdpWhuPhNVTWD2XGQ5q1vH7BRP5KrgydHCM/ZftYxp+iLBprIq6VJXHNTibqFdqO2R/6kcuz34NJq02znZS0wej5luFvJK0yKDN+Kd+rfBb7CKzbFGV8Fe+lgs6lgo7Cda4jrlXZb9XPPN86V9A5N0DnBMGzojO/QzrzBZ1BUa+W86/R4XdMR8lmsjPrlzrSQT3g+dbljnQuBxieb+XNGf6W5gzXQFnMnMHgGzBn+LtA7II8Yn0cX1aKdjC9f6AYpOTYIudbvLsiT3bfIdmthLIY2Rn8P+41Xu+1gOzYttX1Vmq+dSmVYZzAOaWi8y2sv63Nt9QYb+0reZPH2HxL5SOLzLfUTVE830I/u5LK1Dxa+TOOudC+eb61sk2beL6l+KtiobhYKH0WAxyXFY1frnbEFYpRqlhoIp0qFipHp0wsdMBe4+/RvxeNhe6D8fzg7Hc3Y6HDMhpTGQsdQbIrGwvdArI7imSHtNm2UU4cC6mcjoqTeF5f9FQS1p+EHbrRsdBk7NBV45XHicD0v3Y3d6pYKG9XIq+XKz/LuWe1G1D5s2uoLBQLrWjTplAsxOvumDdm2OXQXoRdAnZ20175tK4kPpZD2VVUFmufiAPli74C4a+lNhj8BRnfaa7xtgUa57RE6yjm75Nkot1YO6YDXSsroL+/kfK1csE4HdSX9MG8KepLkoRjKoO/UsCjznFseCWUcTyn9BHjC9NHJS/jsRvyQh5i5KXWwGLlxXaP8lpFuFT8izIMyct47Ia8kIcYeak9LrHyMhkoeb2FcLWb4ywleMM9kGifwPGDwb8VfALfyhPy8csFbvSNNcKB7ThYtGOQyrBuinfNTlt+T1aeh2NNdeMO+m/cB4Hwb4dx416SjRqnQ+tbKscR2kmK4/hNEbhWBmirvVM3BWgjX7xHhvfmqHhD+QGTTYd+oF/5AcxXsR9Q/aROPIVkpfpJrbnz3rjYnBPfrBCbc8KTFvfmzEmwHXk+m+0B5zM811HzhJDuqfgZ7Zh1T+VYlf2z31D7apQtsd/AvmW/UXYn/OM0R+3GTnjW73qi9Ttvh/sr4NuezPFt/QVxPgXj0Xlgo0mi19s79AV15QvQ3tkXhHxw+hT1m2y3of2rat0cZcoxgcloQMAjPt6b91JkTBDaXR7KgYfmfWYPqdy/kvHRbg/kp0j30KepuWLeCbKvgT5/huZ4Hn7jcipTe7RCY47SM7V7nz+bHLqxveS+8+hcCu877/TG9th1Ho9PLqf/rRX0VD9gLqXd6U3zVZPt11BOMX5NrTWpPYRsz+gj2A+oPa9qLYbpoY/AWPwrOTlobEdszIL56wPI/tG+2P7RxkNfsuG4AWXIccPNwIuKefgT5wb/x+DDvk2yUbocimPVHlbcl8q32qCu3xKBazhAe52AvyVAG/niG6D4xLmySWWLJptuzDcwLmBbVP2kzqmEZKX6Sd0CcwuVxdounxDD8Z3tGnUbT6J+O2fcxnaoHG+70+mfCqwh9XKu4F/Adgf2noizyhW08lnlCiaWTWaugPXTK1fAe8SqXMH477xcwU5ZX/RyruBQ2O+4a45vK5or2CPDU+UKpi5XcBD0wVTmCs7J+GiXKzicdK9sruB80Od52e8qVyCfKldA9KpcwdTkCs4h2/fKFfwt7UHfWnIFK8CHDZNsqlxBvk1WuYJituuRKxjOGbexHWVyBYfT2I1883l9ZVPK5vm8/nVCFtx/ebkCw1sn+LVgu+8n2YS+Hp0+Re2H50zKfkK4QnuM1gv4dQHayBffwM62rM7Qd3EclbaL9sm2G/KZ6RMjK9VPTYJH2ahzSLzvDcehtVSG4xDbPOo2jrusn2pvU+y4i3uN+P6O4TZ4WZ6hL1mocUPlUEJnxJT9s99AHWW/gX3LfsP6E3UV4TlXYPCbKFdQ8sZVmSvgLwTgvRVKv3luZfAfA9+2Oce39RfE+WhkrsD6sRsxNdo7+4KQD06fon6T7Rb7hu+Mib3Bje1sINExRN6ceTSQK0B/xHGGumlS+SP2Y+o+pVTuv0W5ArRdzBW8SLqn8vroc7jdBv8l0OdPULzh4TdupjL0A3wzpxpzlJ41RX0cQ7me+YEOb0qMzhXwLfad3uQce4u9x03V6X/qi8F5N0crmaqbzEO5gm76tdB6SDu58twd28j2jD6C/QD6CPYfNwXoqfkd+oiQj4ydb2DMspFyBSrHqmyc7R/1neMGlCHHDeuBFxXz4JiN8F8FH/bXJBuly6E4Vt3oj7fx8zpM6Gu/ClcoT6G+knNbgLb6Sg7zkiT5Nqls0WTTjfkGxgVsi6qf1Bc0QrJS/dQkeJRNUdtdT2U4vrNdo26vgzb/dc64je1Q+UoVD+CY/yKN3d2+xTlv7M7L8xlejn3/AWz3P0k2yj+rG5DZfyC8+vJeaL4ewhVaHwvpr6KNfGFdps18Wj1luyabbtiu5/xAyUr1UzNptWu2wdgbpdk+0Y44B6juOlT62e4sa2jcxXVlvtU9tO8ifVieoTyr0j11g7qy/1Bujf0G6ij7Dexb9ht8UzjDc67A4AezK7k7/JKPzBXw1+swn6H0m+dWBr8/fKGguY/G2V8Q55wMT7tcgfVjN2JqtHf2BSEfnD5F/SbbLfZNzF4w9XUZtrOBROcscc8Lwu8NfcC5AvRHnNeMveGe906pr2ykcl+Y8cFrMelvzBUcSLqn8vroc1j3DH4x6PMh2W9Pv8F5S5UzCo05Ss+aoj6OoVzP/ECHc+noXAF/9alkbiL41Sc13+nQb47lCtQcR/UD5grafekslCvopl8LrYe0kyvP3bGNbM/oI9gPoI9g/xHax6ByYegjQj4yNmbBNc8zKVeA9hVaFwt9/S00t+a4QX1RWM256gR/HviwN5FslC6H4th283XOfar5eghXKE9xh4C/PUAb+cK6TDvPJpUtmmy6Md/AuIBtMZSjSZ8YWal+ahI8yqao7d5KZTi+s12jbmMO7E054za2A8dttt28/OGBNHaH1hU9vgbNc+s7gBdeh+dxAOGvA9t9J8nmzmT8idGJjQL+ToBhP4U6sTECV2hP0F0CfmOANvKFdZk282n1lO2abLphu2hvbLuqnxA+Rlaqn5oEj7KxMrXPRtngHVSGY1Toy9S3Q5tZP9X6f96dPGwPuCeIvw6vfGFI99qNWax7asxS9s9+A+2f/QbqKPsN7Fv2G9afqKsIz7kCg7+HcgWoIwV0XeYK7iIe7wQelH7z3MrgnwLf9sEc39ZfEOf9kbkC68duxNRo7+wLQj44fYr6TbZb7BvO6ai8A8qUcwUmowEBj/jqBP9EIFeA/uhO4h39EccgKnes/BHmCn6VcgVou5grGCHdQ5/G/iJ9WPcM/r+DPj9L8YaH31hPZegHOLZWY47SM7VWhGMo1zM/YH4FdbEbuQLD30ha21wmV6DsD8cHzhWU9JtjuYK7BT3VD5grQJkifcMVyhV006+hnGL8GsLz3B3byPaMPoL9APoI9h/rAvTQR2As/qtk+8pHxsYsOD//31nMomyc7R9tnO0f9Z3jBpQhxw13AS8q5sExG+F/B3zYn5JslC6H4th7BPzdAHMbtQd1/Z4IXLcHaH9AwN8ToI18YV2mnWeTyhZNNt2Yb2BcwLao+gnhY2Sl+qlJ8CiborZ7F5Xh+M52jbq9Edr8pznjNrYDx2223dsErxgPbG25gr8F2/0hyUb551CuoOh8HX3YXRG4QvO1kP4q2sgX1mXazKfV66VcgeqnkI9VslL91Exa7ZptcDJzBT/sUq7g6dd5riBmzEddRXjOFYzB77vlX4s/UUcK6LrMFdxNPGI+I2Zeb/B7ZDymfbzdvhpnbK7A4LfP8ExlrgDtnX1ByAenT1G/yXaLfTNVuYKdoQ9CuQLOa3rnCuZnfLTLFexFulc2V3AK6PO+2e9u5grQD3CuQI05Ss9UrgDHUK5nfqDDuXR0rsDwN5LWNpfJFSj7C+UKSvrNsVyBmuOofsBcgZqLIK5ezBW0kyvP3VVOs+h8g/1HmVzBfLJ9r1zBI065AtR3jhtQhhw33A28qJgHx2yEPwN82MUkG6XLoTjWY74ewhXKFdwr4D8QoI18YV2mnWeTk50rwLiAbTGUo0mfGFmpfmoSPMqmqO3eTWU4vrNdo25jDuzinHEb21EmV8DxgDrboHxCjfhF+ND8pN3e0dBeo1upTO3VZzroE7BPNmS/ea/RmyNjaqPdob7P7PY+mnbzQT47g76b97ygjPE8Eo8NeMbl3TQ2YC5qI/EauuuB62IfDOTA834yg18rYvaQPofOfxXVZ2xDp/qMtrGG2mrwt02uPs+Yan1mnUV95pyQ0uda0urDOsnn3NCD+n/XNqT/9/W4/qu5REj/2+VIWP8xfpsK/b+ogP7fFaCp9N/alqf/mE9E+I8G9F/JN6T/7dYIQ/p/D5VhvdU5dFD/sd9Z/w3+uUj9N9rd0H+UEet/aN6UPkXnOrwmgPF7SP95vdZL/08roP+h2Fvpv7U1T/8NH+fLPxvQf2WDoXOMRde6sA13UxnWW51DJy+eZ/03+P8aqf9Guxv67zl/bZdn4HgebSOk/7zO4aX/B5P+4xl3zg3dLHCEzrGH7q6wdqgzm+pMH5/Z/D3IDf0VzZFVjIR7+rsx5w3hCtlnu7sxmLa6G4N5SQSfY2d8gZaVOZ3/6u/2uVYlK9VPTYJH2Sjb4jPu6AND50r4rIq6u0LppzrjHmu7eMb9q7tPxLu2Dd6id7jyHTQ3i/Yp+w/dCcF+Q51jV7rOfoPvQGJ4Xos2+H+itWjUkQK6Ltei+a4aPIev9JvX7sbgh7b8m/bx93J8W39BnN+PHGed7qqpd/uumnZ+k+1WnU2r0d+IS63fsJ0NJHquy/eyGPxPI9ei+T4O9Ed8dv86QVf5I1yL3n9oy28+o5v+xrXogaGJ7S57F+NBQ+P1GtlvT7/B92Gpuw5CY47Ss6aoj2Mo1zM/0OEZ8Oi1aMPfSFrbXGYtOvZ+ug795thatMoTqn7AtWh1hhZxhdaiu+nXQvf4tJMrrw1jG9me0UeE7t5h/3FdgB76CIzFzUeEfOQNAi9/VwLrpnh/K4tZlI2z/Rc9x672zHHccBvwomIeHLMR/vCh8XoLhibiVLocimPvEPCYB+f7g9Q58xCu0Pn6OwX8HQHa6twO85Ik+TapbNFk0435BsYFbIvt1mRjZKX6qUnwKJuitsvr2+ocu7JdzL+zfra7d5xtd63gFeMBdedVaOwO3UHDdyqgXfP9NGqNAf1M3v0U5w6N17tqaCJO7/speM5U9H6K0F187fwG067up5gIr/op5n4KtN3QPVKcY1B3p6i7k3BOx/rZ7ptioXEX75a5l3IF3vdAhu6r5b2iofsjY8f10F0s7Dc4PmR4zhUY/FuHtvxr8SfqSAFdl7kCHsfxzI3Sb55bGfx7h7b8m/bxTUMaZ39BnLdkeNrlCpzG8Xq3x/F2fpPtFvsm5ltFKFPOFZiMBhKdp+D7lw3+XUNb/m2XKygSL6j8nfJHmCt4amjLb87npr8xV/D+oYntLpunGh0ar7cx++3pN0KxNe9bVWOO0jO1NxDHUK5nfsD8CupiN3IFhr+RtLa5TK4gdu7eod8cyxWoOFz1A+YKUKZIH88lp89k+7VQDrSdXHnujm1kew7lE9FHsP+4OUAPfQTG4uYjQj4yNmbB+cZ7KVcQuvs59pwsxw1qPsfjRt6eprxzsi8Ojdf7r0MTcSpd7uROLd6Hj7q+MQJXKMfe7oxu6J6h6k4t3U9F79QK2S7nGHB8Z7tG3cb95ayf7dZk2XbVGjPGAypXcE0ysaxoPkDZPMdpKvZV3x3g2Pe3h8br/cnQRJzeeb6Y+XoIV2i+1i7Px7SrPN9EeNVPMXm+a6CMcwWx9sk2j7qN4y7rp1euYDHlCpRPCOleu/00rHuxZ0jYbxTNByhdZ79h/Ym6ivCcKzD4vxva8q/Fn6gjBXRd5gruJB4xn6H0O+9M8E+Gtvyb9vG3hzTO/oI4/zHDM0n7twufBQ354PQp6jfZbtUYX6O/EZc6A8Z2NpDonGXeeYEfDW35V+UK0B9xXhP9EedA1gq6yh9hrmCP/bb85rlO+htzBf85lExot8rro89h3TP4vfcbr1fLfnv6Dd7jpHJGoTFH6Zla58UxlOuZH+hwLh2dKzD8jaS1zWVyBcr+1HynQ785litQcxzVD5grUHMRxBXKFXTTr4XWQ9rJlefu2MbQt4FDaxjsP9YG6KGPwFjcfETIR8bGLLhf4STKFaB9sf0XzQeouTXHDXcCLyrmwTEb4Q8EH3YiyUbpciiObTdfD93vGXOnVifnnkL3hWBdpp1nk128b6K/23futrtTi+P/0J1asbZ7J5WpfICyXcyBsX6227PJtqu+UYLxwNaWK1gEtnsRyabKFbTyWeUKJpZNZq6A9dMrV/DT3SbirXIF47/zcgXXZH3Ry7mCd4BvG87xbUVzBddneKpcwdTlCtZDH0xlruDRjI92uYJ3ku6VzRU8Afr87ux3lSuQT5UrIHpVrmBqcgWPku175Qp+kDmYrS1XMAI+7DMkmypXkG+TVa6gmO165Ao+kzNuYzvK5AreSWN3KFeAvIXmEZ2eQcA9GXlnEP4b2O7/Itl4n0EI7X/s9hmE0N4rzg1s62cQ+C4QHDPYzkK5AhznPM4gsH6qXIE6UziYtNoD5gq+QLkC7zMIoXtHQmcQ2G+E8g+TfQbh/2R90ctnEL4Pvu2vc3xb0TMI/zfDU51BmLozCN+FPgjlCjjPoXLnnZxBmLP/lt/tziD8kHSv7BmEnfcfr/fjDKen36jOIFRnEH6OPPv39XoGAX0E+wH0ER5nEMxHhHxkbMyCZxA+RbmC2FxhaL1uMs4g7AU+bB7JpjqDkG+T1RmEYrbLa5plziCwfnqdQfghjd1qDXOy9xWo85kc+54EtruUZOO9ryBmvh7CFbrbsN36GNOu9hVMhFf9FLOvAHNivB/Be18B66e62zB23MW7Dd8Zsa8gpHvt9hWE7iQJ7Stgv9FL+wquyPqil/cV3AK+7U05vq3ovoI3Z3iqfQVTt6/gBugDzhWgP+r2voL7KVeQt69gHele2X0FD4I+35r99vQb1b6Cal/Bz5Fn/75e9xWou8y6ta/gfrJ95SNjYxbcV3BLYF8B238v7St4HHzYJ0g21b6CfJus9hUUs12PfQWfyBm3sR1l9hVwPHCzwKv2GtWIX4QPfZdG+ZzQfgUVC6l1zpjvK2DbVmb/8trP5yJj6m6uxXt+O6DdfNBkomKjtVSm7sxtd+/tZTQ21ABuGfFaS1p5rYm2NXPqK1zYL4fB70OhHOG/TnNJlGeBfl02CHUSwIG4S+rMMmyrPSqexNhJ0UufhiirR/Dyxfm/fv4z/37sjBrVN174Hetlv4BfJuBNVgPE+1AS9ZyvbNdoWxm3HcvQ/oyH1GavXzCRv/6S/MXID/E3BfxygCvSF7OTibqA+m72OgxlK6kMfXPoHsyYnDP7N/Tb+B0QXrM3+P8Dsdz3IsZKjJ9ZN0P7nZAfNd+9LQLXcIB2uz1uTFvNZZmXJMmPAbp4Z3x/t7+FoWSl+kmt2XIuaSWUDVNZaF+H+vZNaA+a0s9h0Y4y37Q6inLHKjYL6V672Ix1LzY2Y78Ruj+3aO6I7Qx1FeE5d2zwP6XxvmTOReaOec8pfrunSK5t5wO2/Jv28bQDNM6i+bv+DM8kxbmFcyxF95y285tst6G9B2sFLjW3YjsbSHSMbfjqBD8L+oBzx+iPeG6pzncof8TxO9oM5o6Pzfjg73qkvzF3vCvpnppjoc9h3TP4E0Cf98h+e/oNziup7yOFxhylZ01RH8dQrmd+oMPvxkTnjg1/I2ltc5ncsbI/Nc/s0G+O5Y7vEPRUP2DuWK2FI65Q7ribfi00f28nV87lqrVU5SPYD4T2xt8UoIc+AmPxY8n2lY+MjVnWAt6DKT+A9sX2H7vPNCbnzOOG8mE8ZiP8aeDDlpNslC6H4th2656htbA7I3CF8kOh/KmijXzxvjLeu6JssovrOP3dXp9WslL91CR4lE1R2+X8cGzOGdd9lueM29gO9W0uFQ/gmL8rjd1bS67gCrDdm3Li6SSpcgUJ1atyBa222+1cAeunV67gtV0n4q1yBeO/83IF78r6opdzBQ+Cb3uPU67gfVWuYKxsqnIFH+qRXMGrkbmCzU65gl8GfX60yhWEnipXQPSqXMHU5Ape7VKu4O+ymGVryxV8HnzYV6pcQQvtPJuscgXFbNcjV/CVLuUKOB64SOAdFnhrSasfMvjQPjO1jw3lYbTUGTmOCbDeyhw6KgeRJK37zAz+65ExtdHuhr6jjFjflc9GeJZ36FvLKBO1z5HPaqGMjabxPCxwprx/lcaGVQB3dTKx7C1Qdg2V4R7n1VSGOoJ8YD+hHpwLMIa3TvDfgrHh38lGlA6/Bd5xH4T6DPlReh0zr1kVoN2u/5k28oV1mTbzifpgtKzMZNMNW0H/w7YS8jXpEyMr1U/KVjiuuxrKVlEZnmXmu5NWQxmfsUTdxrOJrJ+rRDvOhXc8NpwreP35+QHKRV0n8IZ0L3T2UuneW0T7lP2z30D7Z78R+iY89i37DZzvJwKec1EG3zhwy782v0EdKaDrMhfF5ytuBh6UfvPc3eD3zXhM+3jwQI2zvyDOZoan3bhp/diNOdtkjptst9g3byFcbxG41PyN7Wwg0TGS4asT/B7QB5yLQn/Ee8vRH/GYv1rQVf4Ic1GnZXyo80mYi9qPdA99moolWfcMfiHo84HZb0+/wTEp+gHEkTfmKD1T8wSOqbCe+QHzK6iL3chFjfmzpLXNZXJRyv7UefkO/eZYLkrNj1Q/YC4KZarmS6FcVDf9Gsopxq+pc0HqjBPbM/oI9gPoI9h/rA7QQx+BsfhpZPvKR8bGLG8BvG+h+QbaF9t/6K5W1HeOG1CGHDfgXU0q5sExG+GXgA+7gmQzFfdShnB1+54L5iVJ8m1ysufmGBewLbbLycTISvWTOgPGa2Gxthv6LjvbNeo25nuvyBm3sR1l7ljZj8buUwBuXjKx7BwoOyCZyM+5gh+EP57gl2d/D+TAG746wV8r4q2ZBJP+PiiHHvKH7zhGwPrLc3Chv8H2/UIO72tEvG44Vwj+DhL8GfxKAb8CYIwfJRvO260Q7UFfv4baY/BrI+cfplMd+oYZyjeg3Ng3hGSUPixTlYdFWXEuAtdmllPZPChbQWVoO+cQD6cIHo6Hd2zXqHdWN5XDF3bc8tv6fyHA9aJdvy/Srk/OoYf8hewa6xe167fm8H53Qbs+WfDXS3Z9X6RdL8x+V3bd3q4XCh5i7drqpnJ4YceJeK+EMqWz3McG/5GAzl6VtPKKMmT5Xi3grwIY1tkroYznB1iP17Ex3rqUeFiVtMoB4dl2Df45kMNtAV03vjrU9UGl66sAgHX9GiiLyf+uFvAYi5pMVCx6JeG6UuDCvuYcmsloINF9YPjqBP9qIIeGdrqKeL+0IO+x9oY2dcucLb9NB9E3LCSalwZoct30v8uzvwdy4A1fneA/L+TFvg7tAPlaRjgN/lcD/uDypLVd58A71kEl+8tFu5RMr6Qy7GPTBWWfBteNsQjbz/YZamv6sGyUb0Xdtf5vJq3+kNeN0TYuJzpqzIvVf9Shq+ZMxHs5lBneY6Dum7PfrLNfDeiXkiGO8UVlaPzMTFplcxWVYb0VVKZkz2MeygHhr00mysHg/zhyvDG+OtTnRUqf0YezPq+CMuXzuS9C4xPKROVFWGeVn8G+5vHGZDSQ6D4wfBz7/HVgvMFYm8fKiwryfozgfTBptRm0qd/MFiFNB9HGFxLNiwI0uS76yIEceF7rMfh/CIw3K4F3jhXT37sQToP/p4A/UOPoAnjHOqhkf6lol5Lp5VSGvJsuKPs0uA7t8wxln9h+ts9QW9On6Fhs/d9MWv3hSipD2+D4W83JYvUfdeiV2Rpv3njzpuw365clz5R+KbvBPAfLUOkj6gmPN6hfoVjnHCpDmXJuQo27CM85R4OfDnIIjTdO+jxnquMnk4mKn9gfKp3FvubxxmQ0kOg+4P2NBr8j9AGPN5gnuJx4X16Q9zL29iCNN5gfWkg0lwdocl30F3njjeHj/NPeQl41ooF2gHLi8cbghwL+QOXoQuNNuxyd8aNkyjkN5N10QdmnwXVonztOda6Nxxv0h5yHQ9tYQXRUXjpW/1GH3k3jzULCi7hQL0L6uBBgTJ6sj8cG9DFkZ+nDMlf6i3q1MPut9JHnPAuhLKSPBtehPl6i9BHbz/oYamv6FLVV6081pw7pI4/PCwUd9CGsj6hHC6GtN8+eCIdrgLXsX9s7czC8LyDzaTXCZzzjO8TfIF4K0hvbj3Qw0eP2Wd/t8LP/srRDcuuGNTeu2XD70rWrVi9edcv6W28cnoaok9YVK5QKYsV3tWRi67Gsj971EdzZ9PdSUS8RuPuA7iFQpiRhOM0qsU2H5NRDWSTi3TQBfzDhOljUM977AvURB9ZjjanRe/SauwjadYJfAV7zzAX5dHdJWuWwC/19vaDXRaubvW1Y3SzCajAIi88s4Azh+W/u0WWiHj+Gp048X501/+f5zey39fyuUNf211rZ7oAb14o3E44DiAf1L/KO73j88vAUvD6ZPpwTOQTqXRjBwyGC56aob3CDol5Z2TQDPBsd9Ca4//nGg5IJbZsLZcoT8fqpwX8DdGht9ttkiRZrPCo5X5xM5KWonC8WdLot54uJzlxHOnMBZjf4nf53BOFiOVs/mZwPh7IjqN6RUIZwOModAe+PFLQVfsPRTgffe5BuW54OGq06wf8W6OAdpINqNOXRN0nCOs96OZADfxDxZ/D3BObxu4g2I1+8TmnwHwzMm3YR7VK+MtQu1Kldctr1QCCfo6IQNbYcSmW7Q5n5cBxb6oTj0ez99KS1PwpECfLMUx7fCGd0DyhHN3oOYvgbSasMy0RDBxA9bl+5aAilz1JBrPiulkxsPZa1m4NcQH+XmYMoL7CrwGkeRcX1XI+tkN9NE/AHEC5lQeydVX3EgfVYY1S99O9+USfGAkrG532xFmD4vSygXb+brlrbDxa8NEUZ8o5lSOdgQUfh2p1w7R7Jc2q12QY5s9qVG9auG87MNqGn3aTjgBw2pon6CdVl0+bAflfRJDSdpTm08wZhw1cn+M+IwSpUP31i1B67qBuO3/B7qX2sCvEkDuuGBvla0tqHk6Sq6XNBDhtqREkIV028Sx8VS06VGv9mIOaaJuqn3vzrsybSbhdn81zP4L8UiDnV3CB0bmOegMf5iPEzk3jAujNFPZ5n4j7lucTDUUmrHBCe98oa/Nci15KNr27slT0KAHhtANdI+gQ898VxAh7XiUwmTYLnfsG/ERf2NduByWgg0X1g+OoE/2cBO8B5+lHE+9yCvCsbVvNatKn30hwUafJQeniAptJZo5PnN/LmyP83MAdVuR/ki+egBv/3AX8QylOkD+ug8h9HiHYpmR5JZZiTwHyQ4Wac3dgri+1n+wy1NX3K+kp1NmMulaFtsP7PFXRi9R91iHOLHwA4wztN4DX4e7O/TccZxurWCf7fQB8XkU/AMO0D1I57gRcb8y28+yDxPpREPdHhneFvEC8F6Y2Fdx8kety+cvN61kiUCmLFd7VkYuuxrF0Udyb9XWZe/yEoU5LgeT226UM59Vhz+d00Af9BwvVBUc947wvURxxYjzWGrQi9+gcEbbaiHbIJqFpbRLofSFrlwJY0T9Azq/sQwaaPWd191KahJOq5LNbqDH+DeClrdfcRPW5fOatDTUEqlxJWg0FYfC4FzhCe/+beu1LU48fw1InnAzMtSrVv5+z3zKRVY/cgvpGHkP9qivoGp+js2SGdPQUd02SMG3ittF+01crugLLdqOxO4GU5lW0U7bKyuwI47w7gvEeUpby/dPBEOPRGtZx/06dPvGOZflDwan2HHoBTC8ra7gvQwfoGNyjqddoexTPHGNjWVL7zDk4mtO1+KFOjge3jrRP8gQvG6x1D9nY/1DcelZzZFovKeQ9Bp9tyZpt6wJHOAwDD67APEi6WM5+v2gRlD1K9h6AM4TAieBDePyRoK/yGo50OLj5Yty1PB41WneAboINnl9TBB6gM+4DHQ+MD5YDwVyW6XQM58HntWgYREecaPijqK94PJl4eCPCePqFVAYPrts4fTHTy9OcS0p9NUKb0x86T1Qn+n08fr3c56Q9GaN1of8iuMZLjWYOyO5alqoc2+oYIHh4UPDdFfYMbFPU61Q3FczvduI504yEoU7rx5ux3neD/HHTjraQb6D+NRyVnjgGLynlPQafbcub4brMjnc0Aw+PbI4SL5fzm7LfJ+WEoe4TqPQplCIfj2yPw/lFBW+GPHd/edbBuW54OGq06wf866OB7AnOakA5upjKUKfpe7utQH9SI74Ec+M3ULoPfKMa3kL2i3rAvN/h7ACfnho0utkvNlkO6+LBol5LpI0l72ijnpTm0BxLd/jxdeSAgU6vfn9MelqnBPxSQqZJRSKbKxh4R7Zop2vwo4VKZNpRzjEyx/R+i9hv8E4E47AFRX8UOHEOqOAzhryZ4ZWMqNmEbezoyhuTYBnMLvFcOcwv3U9kdUMZzsTuhbBOVYW6B8xyYW+Dx724oe4jK7oEy1H3LLdSprS9n7zvMwcs9fR8k3uoAX8v5N0nixlNeP0I63cqbMJ0POdJBXJaRV3O2A+A3lhkdfsd0sH5obtjfIZ1+QYdxoU/GmMjsqU7wvwZ2fTv55PsFf/3wbmmgrWzPiMv6zOwDfV831qgMf4N4KUivFvK52D5eKdgkeGmKsrw+RToHCDpF+doho58+WRb/zOFrbr1u6drrEnrq9PdZOSzuSXBLc1irCbw1+o/f70nv+gQs4p4s05tKOgd2SOdAQafbqc4DiU7edOdPCqaU+coMg38Fpjt/Hpju5Jkd6pq5z/Rh3TZ6ecv9d+Tw91fgeheR671DtPkXAjzfDzSYbvr7sBwevkmhSklXLEMVToUiP3UqQ76xb7AsScZlge9Y5+4VdBhX3jBpcuWQ7h8LDpOhhXrk6X4qw6GJ5aDoKPeu5BCic1CHdA4SdELDfllfonhWUwn0JT8mX/IAlKmQZln2b53gPwK+5CcBX4I88t/KL+eNk3m+5L4c/mrZvijlSzg0xHYqnnEKyHSVLxnjOePBfAkvBQ0lcY/yJbw0gfzwFsOiYyHWn6yxcC7R6fayn0r3s39Ry1GbAnTUklo7e9zpEE1T2SOPawi/Guxx10MmtlGN7TFLdd32vYwrdgwy+H3Bxjsdg+6L4K+etNpU+vsQaHMerkS8M3j0KzwPeIBg7w/A5vmt9Pc12e9u29dp2W9lX4cTf0XtC+vH2teRBe1rOPvN9vVGsK+jyb5wOYDlyksACHsawT4E7Y7F209102c5wT5IeFEn+SrRsfH9kHH887Pfg4JWp7qDqX3WHUxRHwG/sczo8Dumg/UNjm2BdWfhIZom6g7WZd0x+LtBlosPyW8jp1k95GzvH4b3TJeXIB8hWEzlc5r4Yaqr/m3HY1PQeYTwPhrgn5fpHxL1ur3c+gjRecSRDuK6gujk6e7FpLuPQpnSXft0Up3grwLdvYx0F+uz7qJP5S2UKv2Xwv868fwYwJmcrhR1Df5xgkcc6cNziyeyv/PmFla3TvCrxNzC2vaooJe27dqctmF/4DLc40Tb4N8H/fEW6g+Ul/XHzKRVNmwDTwAvDHtajgxuBj5uOCSfFtuFamOK45ZD8uFOE3CMY5qQgeFQfsHqzRT02HYfIxqPBmg8IuopGuyPUWZPAH3TjQ+3KX9CtC0R76YJ+Mdy2psI2o+3wfuowKP8++NUtlmUse/C9qqtWMonot+7OGAveTah9OqxAO9PEO+PCd4fDfCu5If+IxQ32N8xY31N/G38XQfv2MeqpX6Esbq81H9fIB+jtu8gX8M5ODcBTt4+oXQmdCQv1E/Iz8wk384V7+hL+F0olkkED+gLlc7mxXEsD8WD2n6j/CZvv1FxeKxtYjy9cBudYzznNMc4GeanL2zlcwzOmffCHON+wlPNMZLk805zjCbo7q+WnGPwVqp2cwwrM/lOE/X4+IDR+ybEvl8kfP1AC/UmffhqZdxqmIg28bqCwX8Jxr1fpE9KYv3jiB6u66i1HtaJ4wRfee1UYxjL7W9oPYS3Dg8lUc+ikP4b7kdL4o6xH2Xzav7QEGX1CF5u/tGqY1cNvPN32a6MF34XE8scJ+BNVjxvHkqintMGgUZCtK0MdftRKkNdNR5Snb5+wUT+HivJX4z8EH9TlN0Iv4v0hcK1yRHX/SVxzU4m6ijaofL3nLtReeaf+/tsAU/5oWOI16J+COsX8UO8bjNWN+PV9IuP1w0lUc9xofjEcD9SEnesH8qLCZCvhiiL8UPX/2TRLb+54g/3riWt/rZPvIvZkq4+99ChnR+l/BD7GvRDj1AZ6qrxoPxQyTHlqBj5IX6VS2I/FNsXCtcmR1z3l8Rlfii0toB+iOM7dcQW/RCvZ20/dxymf+5EXKFctYrfOMZUZQ8KnCmd3eFOHvRXA9m/F0IZrweqObr9je9Q17EOr6Mb/ByQTZP4w7VsbCfyp/oL99jsNDcf7qEAXCi+V+vgodg/tl94rNiLxoqSF5nIPTyGK91+vEv2O9t+vGR4w8rrV60bXr1y+Np1wxv6ABNyx5jsb2s11uPHOOFdBPfQ37xjbRP9/aDA046m2mFyFPxmujE7TI4SPE8lneM7pHO8oNPtXYTHEx30JDjzP2xuMqFtahch6sOK7F/2yqeeOl7vyEAEyXJGKzwxmchL0d1uWP++io47nZM6pHOSoNPt3YgnUXvQRlhuRe0a698/yXTa2fW5czXNWLs2+O+eMl5vacCu83btYxuLHrBin5SHiz8Qh/V5J+QDAZ4VHXwX0rMQnZj2hOhMZXsMl9rhh31wUYAvnqU82AbXSsKlLvJQOsg8F81OYP3+AJ1NHdLZFElnstpzb4d07o2kc2KHdE4UdAZFvU7HD8VzO3+7jvytuqgJ/e2y7F++0Ogvwd/eSv4WZzyvdzl3a9WYL97L68/3UX+q1dxQfxr8b0N/3hnRn0o2ebsikW6or9XFOTWBK7Rzm+WA8GpM6WJGNfozhbx6U3KVauxwdOjym/TBQ8g7Zb+zLMCi4fVHHzP/zJ+lAG6/ZUNednUWEk0mrqwjfEJ/c72UNz4d2C9opA/rz0MEx/1u7xl/DE/tYNuVK1/3cE47kyTO12H9/hxcaPN4msX6hzNNj2Z2rk6zqJhMXcgSigfUijzC9Yk2bJ9T722J5s/ajDypNhv8RwNt3tSmzRy/q9iRfRPD9Yk2TE9adQBxKBmfnEzkvag+Yf3JGjtPJjp5Y9pLNKapEzRYd132m0/Q/DKMaS/TmKZiwW63n+NXdb32OoDJm9vkndTm3RsG///5rD7KjDKvoNQF/2n7foX6VLU91KcG/xz06Rci+jRkH+qy5pAvuD8Ar+aKKscUihutf3iH7FAS89T+KkZHEX+DeCmoD2PxhroQDdtXNt4wvN+ABiH/7eINrheKNxg2z/Y4BniQ3reLNxRPebCdxBsP5bQzSeLGB6xvcKafJT8wMWS83Ad8qB3MeSd/pyWttqXgVYyhdmmwL6onehzeDcoR/qsQS/xSYFfcKTn8JUlcX2D9yRqrTiE69zrSUbfOqPzqCviNZUYnz8c2Rf3QesFDHdJ5SNCJ1fVbst/tYqK/KpAnR7qcJ78Ixs+/pfFT3aIUysOFTvuzbSVJeNxVud28eKmdnar8+jmEq+jaBtYPndZXvOfd/DMtuwG5w5t/lqvdIWZ/HcZ8y2NsHPGrXQ/GV0OUxewK+3bj1P/5D5958ms1qm+88LuY3NE5Ar6z+CtZpnaF4Y6V9EEdeZDKUJeNB7UrrGS8tixGfoi/KcrwNFCRvmiKsqUlcdlOLjXHniqflJd7sT7l2GF6ZvuxN4moG4tUW++nevcL3n9OP5kot/QZSvTzU3oMn8l/O0HrAWq3wTah3e+nT0M9IHg1H9EXoJGId7UkXzZMY5qouz6ZyNumCN5UPghx3JvDZ4pDrSGy3ha9veQ+wY+ic1aHdM4SdEJjEv9rdPhdaD3yLKKTFzft94ZkQttC613p7w3Zb17vOgPipgMznDNFfV5zVTcZqv0FLPu8GwLYnxj8G8Cu+LSryg9vAJx5ehZ7Ssjgj6R4pht5Jm5TPWn1relzbqLblJcvZhkoPdktAK/Wm3DdjX126FJ9a9txh4/zcPwbirX/vBycxx42jnN+QZzn5+A89w3jOE8J2MaCZCK9ordKYn3egct7StNnetKquwX0MPpyY8PfSFrbXCafpvIDSi7qonZen8WymH0aCwSdGuFqx5fj5cbG4q4EtzSHtZrAW6P/+P2u9E6l5BB3ytMfZqZpar4RYC4l/BsBR594x2qO9Q1O0dm1Qzq7CjohXJcKXAZ/l4DfVcA7qoaxuBfAsJdm1hhvO9Vg3HmqYU8f0Ux/30/1uWuYx5kCRz3Qpj7xjru6LmgpOpd3SOdyQYejhLUUJSD9At7ybv5shOFA3CUz1XfHen7+vAXSM77UZ5ljsh6H/tq7nznlgOvfWKP6xgu/Y5NUs8jLBXyH2ac7VdYDd/+mj8qMqayH8aCyHveX5C9GfohfZak561E0g6DuAS2Ky7Ie+JmUkC1Pls/oBp0QrtDdzSabgUSvFLFPMvjbYfa0hLISSt6JeDctafVHl2X/zhS4TsjhXdE2/OnTFPUNros+sb+oT2wkrW0uEw0r+1ByUef0rC7vUE+f5QCX5y9DKwK9jgt1czBp1d9azr9Gh9+xnD1WBD1Pl/FZz05wqSzZkfAbywwXv+N+wfqbqOwuQUeNQ3dTGcptKZXheH4YtQttkv13UT9UF/yp87SYlXv6DZomZluwLq9mGvxXDh2v98wb8tsYs5MK4fMyXC9MQoarnexeKiC79LmI2mLwr4LsXg7Ijsd+lQlXO8X5pFneJ6qxLEnCO4hUJjjmfrEOV/aixz7vnVUqq6h8TIf3G9WNXuiTrUhvVqJlqu46MxtTvo79Gfo6XoXEcS3vM8np70Phd54/wzZxZlbxN1l+U9G5sEM6Fwo6oTgxRtcVHcVzO1/2ZfJlajUV667JfnN2+qPgy75KvgzrI4/8d8z8wujFfhvG4P8wsDqj2rwmwDPSSJJWu+Gxy+D/hMaukvNpOXbxaV91SrpDutHZeMPfIF7K+uB2q/GY2pyT/c5Sm0vXrlq9eNUt62+9cZhvrszb41gjrPiulkxsPZb10bs7CO4c+nupqJcI3JjxVGdCQvsS1Fq9mpXfK+jy2rw6dx3a42C89wXqI468/SJ9OfXSv28XdTzvCfCc0XRxj9iOsZZp+BvES1nLVPuFVHSkbnAKfcHhDviNZUgnFJ0iro1OuNJneYWrwlXhqnBNAa7QnjKehaXPiuxftXDNZ7OKLlxj/dAC+Vkd0jlL0BkU9cqOyc0AzyrbwnIrmoFUZ0vb7Z874FBNM2//HM/QDP5+mKEdfOhEntUMDWWAMyDsB8PBdacDD1ZWIL6Ymc7SVtJXdlCu3A+hOCT9bXvt1H5q3q+DuhDbR0dTH6n9fqE9jgb/duij47Lfah9XzD4iRY/tcCAHnvc4GvxJGU+4Sqf4uy+HXl5W4U059E4DeueBPlg7E6Ldod7tqPQO/QzrncoEKX8W8hdoW6yLqMO8Mqv27oX2tVr9gUT3geGrE/w5os9j9Zz71eDPj+xXk2U3+hVlxf2qVr0RnvtV6YFaoVeZujsJ150Cl9rHGmvLho9t65JAv1p97Ffkk/vV4C+P7FeTZTf6FWUVE+eo/ZMhPcDxwWSiMuv3UBn6xLwz0EgH9SCmz7F/8vz3sOhzlcHvj+Avb9/pjtnvLAO3csPadcNZCi6hJ5QyS/++P4eNOaJ+QnVr9G4OlSn3GdokZLQHEp2yYvdp8DcKkYfcb/rEbKnG7u5GEtfwe22pbufWOFUUMrPQVGYKVDV9zslhoybqJ4SrJt4lid7mrPbqxXg3JSq1VwvhDR+vW/9iYORQI2HoljAVuas1PtV+vuER68WcJkE14hHN4O+IHNGcZj5yREMZcR+qzELoJK5az1bZ0ibBo+zViJZ3OgjpqChGzawwquSZVbsbQWNOHvPp5/RRs33+nirWC82CDa4bs2BsD+tCqG/TJ+92F4TH/uaoFfcWcOYJbYlvc1CznlhdwGwHZ0LUvsTQDEjd2IBDOM/KDX5U+ADD+UCbtsXMANWpW7WCxydIsR7uKzDcCcF1qI8zPLMy6VPUVtn/oJ7x3nEcCziLg3zi2v+XJ3kPFo/f6uZQNd7VCf5zkDX6XbIRZeOhPlD7j9TNhzOTVn/xSASuuwO01a2ZjwRoI1953zpNBJ/47SujZWUmmw5tpV/ZCvpntpWQL06fGFmpfmoSPMqm6H4w/kZs7H4w/N4L66eKF5UPV7aL+y5fIttF++TZdtGsvRqPOCb+fRgjbs+JifPsekMOzj8KjDvtxtSYODt0uzj6Po6zVVZS+T72i8pfKz/CflF9MxPh876Z+Y1Mfh3eIiz3W+V9E7me6NiL9wAb/A/Ad//NoRpnf0Gc34ycszj5unq3fV27MYn3qWLf5O03RFxqLyrb2UCi50uGj1fbXgtk2tDfsk9Ff8s+9X5BN3TWIJX7jtkfHK+lv3EF60c58yzUPfQ5rHsGvwvcbvBvtILl4Tf4liH1DVq2nyQJ65laFeRveavvO3e45zt6Tzt/07HkHvrgbaEqZ9Ch3xzb065iFdUPsxItU/W9RLx9wvAaTDf9WigX006ufD4I28j2jD6C/UBMTKbo5cVk5iNCPrJMTPY0xWRoX2z/aONs/+rmUDUH4LjhEeBFxTx864vB7w0+7CiSjdLlUI5FfZdZfR94ZtKq649F4Arl+h4X8I8FaCNfWJdp59lk6Pa9bsynMC5gWwzNJdMnRlaqn5oEj7Ipars8D8Pxne0adfthaDPrZ7ucC9vuJsErxgOmG7jctDKZSFMt7eA7HmexvsEpOrt2SGdXQSeEa6XAZfAbBXyXr1cxFg8AmPT9bgHWGG+N/uP3jLtPwOKjuqmew3eSxHWT2qzAuMyFp88KgOFLhTENfRHhUl24McAX1uelMOPrssz8pgv6Bdzb5tDxcMNd8hj/5hrhSxIdZuYdTUO+1JUC9QhevvDihTP+8Dfnj10FEnuEzuBVqv8iAd/hVSqb1BDG16WoY4NFr1IpeQXEphj5IX6VDuerVIoeZ8SyFSVx2VUqOFSa7UyWj+Gp65syW8YU3mTzYsPxNYKXkB9Dn88bv5F3lvHGQLuK+st6JJ2LO6RzsaDT7U3hFxMdtHNMo6ylcOwuKFOp37dmv3nT5X6Hj9dbl+FUWyCQRzX+4BiZPmyvvCmUYe7L4e/toJ98nFa1+a0BnjGFliStfoHTu2PbUGjsLelTZXqXrxVTx7Q7pBu9E2uqrvMpdpyWtyejVBArvqslE1uPZX307g6CO5v+LnOcVn1m4m6BM3SluRp9i1xShXjVpgS+nC802iMOtahnOFS99O/rRR3Piwom62iuWWbJ463Rn43kzyqUjDrHLDO0OSR9uO3qEw8qmc2zqrKfDEh/P+SI634nXOmzvMJV4apw9RwuNQN9gMpwPODPw6tjDTUqQ/5CMy+sH0o8XtghnQsFnUFRr+zY1wzwrDYOstyKXmiI9fmiGYzacSb0xcM0zbyjYjwTMvg5MBP6ncMm8qxmQigDdYagi8fM5AZJlCv3g9o8iv1mR3lDR3SULsT20e9TH+HGa9VHfLTY4P8dFsz+iGarWJ835Yc2iSM9tsPYY6sG/6cwWw0dW707h56avafPshx6fwn0JuHY6myld+hnWO9UxkX5s5C/UGdw1EIWH4MLHX2sCzqhDd3GQ+yRVoP/ttAHHotYN/L4U3JzPgZ3bw4bs0T9hOrW6N2sHFyGJ32H09eYY3DqpCu7iNeEyENdlj7VMbit7hjc2Tls1ET9hHDVxLskaX8MjkeVkIiVqJQXCeXox7xnxpM6Bqc8rIqwQpGAys2HjgGqqOfuHDo4oqG8eEQbW8OCtk7CgX05oqGMuA9jMycG3247NJta6BiKmtnEmmHsMTiO1JS+9Afa2+7YEetX7LGjUFT9ejl2ZHzHHDvC4WgT0VFRVKwu4OzpizlrTIgXdSFvjRZ9AA7heccRDhI+wHDe26ZtMf5OZb1DV4mr64JxPdBwM84O9XFQ6SO2P2aWF/psTDtbZf+DesbbSHEs4DCynd6EtnniGt9amvEhHf4IYNHPtpwr+Fd0du2Qzq6CTgjXuQJXqL+7vFXMWNwTYNL3uwVYY7w1+o/fM+4+AYuP6qaNOXwnSVw3KXVWdOod0qlH0lneIZ3lgg5vBbkyc7sdLjffEbNgVvJkwR01wpckejaVd6oC+VKnHGK2mP1T8+LfvvH7H/t4jeobL/wu5jT8cgHf4amI96qhiU+kov5tpjJ0w8aD2mJW8lTKe2Pkh/jVTRG8xazoSRwsW1oS1+xkol5Nhc/gLWZvhhCKt5hNhf+6sEM6Fwo6KiSq5fxrdPgd01E8t9uKdcPhyYS2qakv1uXktsEfBd+dvjmQhsgLG3CsDH3ZwOjFftnA4NeDTvFWrPtEm9cEeH4AaDDd9PdhOTy8g8aokhsv5FYsnn4iPxxqqw096ksBamHrvgCdSzqkc4mg47kZphngOTTul6WDPtVsTp3yvAx+Y5nR4XdMB+tvCtDZ2CGdjYKOSgvhlEmdCDSZdRhP1WP6BfE3iJeC9IJfO1IL/tb2hwUv6nQjp0JUrPWwoKNw3eGIK+amossErqLycpzqGYuXENxFOaz1Cbw1+o/fX0Lv8qZ6hnuyrsqeLNNvt24+erimmbdunvch5n89YrzecxRaIF8D1MaiO+axfmhnPg+BmFnjrJu6ErxGZchf6ESJWrHoE3SU+90WP3TEQzrWVUN0zCUYA4JOUb4c3ZyxeBjB5d3pVhN427m5w+hdnpuzvydL9RWdhR3SWRhJZ7Lac1+HdO4TdEK4FgpclXpPwK26qT+H7ySJ6yasP9lqp0YQTEq0G+W/RqO8+kxgaJQ3+B1glP8D2M3IexoQ1weTiWUoxw8R/7h+zyMgyqUbI6DhbxAvZUfA2J1pxc4m8ZQBpYJY8V3IUngXDFtlP9UrczZJrc7dKXCqOO6unHooi0S8mybgNxKujaKe8d4XqI84sB5rTI3eo7V9QNDmvZffhHTYMkqHKVooj3b7CxmGeRjbXxhIyW2EOqpdbM18IwB6gtNy6P8neJnvHK7pJ4I+tw+950AOvxuJB4P/ntgdpTwy8qPeoQywbt7fCMsDPf6tdPEDBH9Pm7Zz/xv8vwb6/w7BA/qfpW14YJhpOTz8RPAgvObitbfcnrPXj70a/829xD1xh8CT95g0Uo017WXpsHUwHftbaUDa8p2y32Oh243DG/L2OfKIUM+hOS3Rz2CieUufqdq6ekc5esGtq9i+sltX86y0HZ0Ot67mDdrKWXD9hOrWxLskw3lLtuV6KtcvNnZIRyWJGFdeWHxt9rtO8DtlYbHaTnYf8ME404eTnaHts4YH4dttsWJZqu2QIdqhdb4HC/IayjEjfZUc3VyQ1xWTzOt9gtcurqtEu86pWlcpNq3hzcYoFcSK72rJxNZjGXvIOwhuCf1dZloTe0emuvvx4Zx6rNn8bpqA30y48u6f7suhp3oU67HGqHrp3+8QdUIWEKPB6ZO3UueB6xGByywT70wsYCk7x1qm4W8QL2UtM/aeSGv7Y4KXpijjlIO6u/MxQUfhesgR1/1OuNJneYWrwlXhqnBt5bjUIS++mxfHT76iottXLSg6Z3VI5yxBR11ZUDZWaAZ4Vndds9zUNx8eCdBRu6J5J2r6e8JlfUdomjiTxbq8Q9Tgvw0LPOuOyG8jytnaxTx345txGOOwnNvdT85fTsdYgg8bYV/jneChPvhF6gN1TUjMN9r+APrgl6gPsD7u/sqzG0WPdSTvM7D3E38GfydkO5YEdn4/mEMP5YFyfmcOvXtEdiV0uW2Herdzt+9nb6envP1F3XNvuNQud/XdhBrVH0h0H+Sd3Nks+jxWz7lfDf7RyH518ic7F73SRmXWQgfflR6ob+s1k9Y+z8tEIq7QJ51Vv6orHrlfRwP9qjYJIJ/crwb/XGS/miy70a+hQ6yqX0OHWNX4jf1qMmkmrePknYSr3f6cmH7FPmAfbfCvBvpVZblDftjgf7kH/DDKKqZf1UpAbL+yH8Z+5auAcKxjW54sH/1ros/VTvGYQ8F5e8YcrwLanMPGTqJ+QnVr9G6nHFyGJ32HaVUWuTV3INEpUBa5wf+2ELkyU7VXSx0qm6rdviUP4gZ3+yqXWnS3b9FhsQuqmj5LctioifoJ4aqJd1jW7rqJ0FUaOEJ/jbbgoQrxTEF5PhX5G7xFoHnRheGrE/zXA6NQKApOH/bW7b4AxWdDsQ2PUxnWezCHDo6O6Pl5dDT4/xM5OhrtboyOKCMeHZ+Asj4Bz/L+sIB/AmA4q/RhKGOTRhk/TnTauQ7Wf6WnavatovH+QHvbzcpYv9TXzWaKeqFMicF1I1OC7WFdCNlS+rBsQrqDsmkm7fUE7ZK/ChfyS+kT0gXMLqylrIm68qpGZUgzdDEw1uevCSOdjR3S2SjoMK7YfSpj9Y/c8q/ap6JWgUP7I0JfvkV+lGzwjgimXcv51+jwu7z7FrCvPFeOQxF1aFW5LB30Mw8RnUcd6eT5LPYNndJRK8tq/OqUDvonPqf+hCMd9HUPQD0eE9VtoE8KPmwK8BF4X2AsiD5vbfgbxEtBemNTgI8QPW4fTwE+KnhpirIb4TeWIZ2PCjoK192OuKxvZyatfX0C0VGx1IcDdE6IpDO/QzrzBZ1BUa9TG1GyMTofcaSDNjOf6HzUkQ7qwW5E5ylHOk8BzGFEJ+/r5ycdOf4+/e9pKOMsV/rw188N/vdPHq93aobTdBB9BfKI9TEeeVK0g+ktymiY/xuBOgX8kbx3ZST73U52i0l2T0JZjOwM/rMgu7NJdiNAm217FMo+QmXPQNlHqexZKEMcWJZAG/Ad6xzWN7hBUY/Hq+fgfYH+iv5yvOFvJK1tLjNePUf0sO3pw3ekPV+O3tiX4z8m6Kl+mJVomSJ9w8XXuaKfHaEy9I3PUhn6s2eoDO37UPiNOPPaxDtgkT/Wb+RvM5WpnbMz6e/09yNUpr7sPVO0meNba3M/4Ukf22lTJ9i3HDle55rst/I37MefFLit7GlRluJ/9zET2zIC+FGOWJY+feJdaAw1OEXnzA7pnCnoMC48WIhzRPa7Bn8XjSGjgLeAzV5n8n8GXrK/K+l/rov1d3m+F/lSvjDmfsn6l579jS+89fvLi44RId95poDv0Hdeo3JmRlvdL/kslWGuxnhQ90uWHLuuiZEf4m8K+MUAV6QvFK6LnHCxz+0U1yMlcdm9lxj7jBIulTPEcSl0CoP5GmmDiz9HjPVHCNdoG1y883JEtJHjEobrF7iZ9mDS2jb2ZSX9ZHSuwfA3RBvKxG5KtiPwjnMNSn+aoox1/hlB5xlBR+F6xBEX50s98phKh88gnovuXMX6ebuOEY7nzOnvCZeTHan5Qb3H+TbHBQb/DMzHnqP5GNIOxZac0yl6V98JkXTO65DOeYJOt/PfnNMZdaSDvuk8ovOMIx20N87pPOtIB8dFngs8InhIdfbzZAfPQZmyy5XZv3WCXwx28KsBO0AesT7GWio3xfR+g+LxknGgzOkYrnay+yLJDud2SnbsQwz+YJDd7xTwIRhbjlIZyuMZKvsYlCEOLEugDfiOdQ7rG9ygqGfytf56Ad53I6dj+BtJa5vLxAUvED1se/rwvOTFcvTGcjovCXqqHzCngzJF+oaLczroZ5+islEo+xiVoT97nsrQvjmn81SbNnE8rfgL5cKnKuZ8qhy9YMyJ7Ssbc/L3BTziRA9cnJ+bilhofod05gs6r5dYiNe3tpVY6McFYyEezw3+SyeN1/vJJMRCtXlb/p3KWKhv3sS2lI2FPg6yG8hwqvkk2zbKaZTKMEbhWAhlxeuNVpZAG/BdaE2V5Yb1eLwqGZtEx0KGv5F0pB9j45WKEdV41WGsNxYLvSjoqX7AWAhlquKiUCzE+YVRKON4B/1ZXi42/c2x0CNt2hSKhXgPGOYu0r9xfwWvKRnsZrCzvTM7U3vM+PsYqOMfBrpDZKsolxH4jWXpExM7YP1niB+PsUmtdZ9BPBfNUWN9XhN9RtDhMZ3962HzND/oX0eBH/avBv8+6Pcjqc+QNvtJ5JljtKL9eUIknfM6pHOeoNPtmIZjtG7FNJyves6RDo6XHKM970gHxyGO0UYEDz/fR0N28DEoU/l6zlcZ/P5gB2cH7AB5xPoYo42KdjC98ylGKzkmyhjNcLWT3TKS3SiUKdmxDxmDB9ktL+BDcEx+lspQHs9RGeYyEAeWJdAGfMc6h/UNblDUM/laf70E77sRoxn+RtLa5jIxWmz+yNr38XL0xmK0Twh6qh8wRkOZIn3DxTFaKO+BvvFFKkN/9gKVoX1zjPZMmzZxjKZ0v4v7PaLzVYa/kbTKsYxuqVhIjcM8NmFd1Tecr1J7QVTOVeEadcQV2k/GsZDat/aRAJ0TIunM75DOfEGn2/ukpypf1a2Yi2OhbsVcsbHQHTSePw9lMeO5wX9s/ni9uwLzOF4reh7wJQL+sBx6H6RYqGT+Q8ZCvAY1AmUou/tIds9AWYzsDP4DILtNAdmxbeO4M0plsXESx6ZqjQrfheJvjiGxHo9XJWOT6FjI8DeS1jaXGa9i80cdxnpjsdDHBT3VDxgLqfU6xMWxEPrZZ6hsFMo43kF/xut6aN8cCxnOvDZxLKT2jDGuOrxTOSeed7yU2Vdqay9QzmoEaBjtFG7eURPhqjhsYl3V92+H31iGdGJjp4864qrisHE6/K5IHNat+IjjsNdbTmpU8JD6mP8RkZMaBZocSxj8oRBLfDkQS8TkpEJxmMH/r0nMSeXJ7g8i4rCQ7Ax+BsjufxeIw6qc1Dif+A7xVzmp/JxUKA7rhZyU4o9xxcZhBv8d8hsl4ybpNwxXFa/FxWvpsxjguKxojPWUI64qXhunw++qeM2HTpl4bfCo8fc4BhWN1145cbxeM8PZzXhtp4zGVMZru5DsysZrD4LsdifZIe3QXQUcr6l97SqW43GwaN4M629reTM1Xm2tebNRKkPfyDGZOucQE6+NtmlTTN4sNsfFNPPiukup3OCPO2oc5zGUN1Nn91O4L1T5tddNfm0k+63useB4rej9VicInhWd+R3SmS/odPueJo7XRhzpjADM632dc1TwkPqYleTf1DrnKNDMW+c8BmKOSwLxmtc655UUr3VznTNPdm9yitd2Btm9OSA7tm0cG0eorFrn3PJU65z58Vro/qgRKPNa5zSceW3ieA35G8nBFRuHGfw7yG+UjGOk3+B9aaGvlI6Uoxsdr41kv72+UjpC9Lh9HK89I3jhOV76LAY4LgvFhWq++JQjrlAcVcVrE+mE4rVu3avJ8dqII50RgOF47RlHOirOaRdzPEYxx7NQFhNzGPznThiv9+FAjojzOc8CvkTAH5ZD72nyuzhOdOp38W4x9nUT7qXJmcvHnqM0+CdAds+R7JA22zbK6SkqwzF1hMo8995ifZabmot0eO41Ol4z/I2kI/0YG6+eJ3psFxyvlZw/jMVrsXdYYLyGMlVnKkPxGp+jRN/IZyVHoIxzJ2jfHK99tE2bOF5Tuq9yXHimknNcalyaLtpYoI9mxuqg4W8krfIuo4PqTg41XqefPToo+5199mjJ8Iblt15z45przx++ff2im1cvX7Vuw5pVNy5avXrd8Pr1yDQSmgHvsRwfhrHfm8V7xDHSpjGsDNhZI4RrtA0uvrAP67MDfKYNLr6wTw1u/Hd/0sqnHfadFoEHDS2Pr5XEl1p8CTl5VM53ES6sn5dwycP1i4QL6/PiIiaLmE+WVwhPngNFvt5NfOUdQk//e7ENrrcRrrzLfdL/XmqD6z2ES03C+e/+pJVPllcIT/rfx9vw9UvEV97mm/S/T7TB9VbCpTbvGK6X2+BaQ7iwPtbFv/uTVj5ZXiE86X+fbMPXBuLrZSj7JJVhvQuJTtFJGtafrEnahUTnk450Pgkwu0G99O9XoGwUcIQOMdng/yq870bCxPA3iJeC9MYG/1eJHrePEyafErw0RRknOT4l6HxK0FG4RhxxvULtyb0IiCZhZS+zeT9Mwn5CkzCU0SepjSNJaxvVZaQ1ateAgEd8dYKvHb3l3+2S1s+6flLUV7hxPI25EBjtqxs2Yvi9LgR+hehx+9hGXhW8NEUZJy2ULb4q6Chczzri4ov28mxk1tETaZa1kRvARnbMcPaSjezmYCMYQ8XYSCeXRyI+4wffIX4vG1Gx7Ai8Yxt5RfDSFGW8sV7Z4iuCjsL1giOuWBs5xMlGLgIbObSLNmLyjrURg5/nYCMYN8fYSCfJMMRn/OA7xO9lI+rStBF4xzbyguClKcpwzoRlSCe0OI64Pu6IK9ZGTneykdPARhb1oI2cXdBGFO/dmHup/NXR8DtPRiMCV1PUH6Gyjwo67XRk+dGaH6Uj6W+bv/PC+mGgIysDOtILC6undkjnVEHn9bIR7lSi8zFHOjiu8MLqC4500FfGXlB7PdnBi1Cm7MDyRXWC/8rx4/VuCNhBXs4SF1ZDF9Qa/C0ZjQ43HsmFVcPVTnbrnMaZV0F2txbwIRjTj1AZyuNjVIZjMud9VX4V37HOYX2DGxT1TL7WX5i37MbCquFvJK1tLhNrxR78tPZ9shy9sYVVNZdQ/YALqyhTpG+4QgurfFn/CJR9nMrQn71EZWjfMZf1Y5tCG+GKXNY/Au+7EcePZL+9LusfIXrcPo7jPyZ4UX3zXviNZUgn9CEOxPVRR1y2xlBtMmt914uHAraVWOjFArFQ+vB4bvDLYTz/xCTEQp/qgVjol51ioWNBdv9fFQuFnq0mFnq5HL2xWEitYReJhdSa9ushFuoT/CEc2p7KJyXiXS1Aj2lME3XfR3xj2RVEYwTwxuSArhD8djGv2xdrX1tLXpfX0DvJxcbEPB1uYIyOxydjA+MV8M5pE21fqB9GAvRKruVNM3qhvV1IL/WnA0lrH7b7EArSwP7Ks/my+yk/1gZXaD8lrwO+0AYX76fM27iMZf+exS+pH/6HoyfCPJ/BfBdgvpP9ZptCOfx8LwnBGS6DTR+PD+UgviTRtscfRSy5YT74UURsH+rmdklYR7CPcG/Es/BbXZoVo7PIU4zOFu1Ttak8hfuPANwzAk7RSv9WHxbnWDw5Zss/qZzXL5jYRqw/Cr+xLH36xLvQ4QyDU3RO6JDOCZF05ndIZ76gMyjq1XL+NTr8juko2YQOYZalgzrGuYFuHXTj3MCII50RgOHcwEcFD6nN7HrM+Hu2tdB4wYfe/+i48Xp7ZDjVHv2RRNOLPYBm8PtmNCbjYr082e1HshuFshjZGfyvgOwODMiObRt9/yNUhvLgw2k4NiAOLEugDaEDaOoyiG3lAFrogqet4QCaGuuUb+QDaOrDnMoHxXzIL3QATY3l6eGqfbLf44erzh++/ZJVN65ZvWrDmrU3rxh+263D6zfUATNTx1YkifbEJhHEw0+N/p5GZZupfLmAwyc0mnZ4xUF05Gv4G0lrL5SxHHWiS0UZfFUP1lVXVbwffmMZ0nlW0FG4PuKIy/Smusqz9R3T6YVP4DzjSAdtc6o+2ZwXrVxG0Qoe242JVgz+MohWrqRoBUcN5BFxY6T3iGhHneDfTJFeyaybjPR49R19HcrumgjZoU/Lk90pILthkh3SZttGOY1Smbr2R83YEQeWJUl4dV5FBJOwayE60hvJfndz14K6GqfDqy/GIj0VWap+wEhvBGiqk7ihqzw3U9kolPEKkbpCR/mgmEgP2xQT6ZlubRJ0rOxJKHuYyp4WbU7t7t1kd/i56CXUDivDduA7tpElgh9F59Hsd53a+Cj5upLXPJ02SHQMB+L+SEncsXaZFzcgXw1RVo/g5Uc7Ljzin0e+92SN6hsv/G4a4EddRvglAr7DMefkQaCREG0rw/HwI1TWD2XGQ5q1vH7BRP5KrgydHCM/ZftYdhr8LtIXCtfDJXHNTibqFdqO2R/6kcey34NJq02znZS0wej5luFvJK0yKDN+Kd+rfBb7CKzbFGV8Fe+jgs6jgo7CtckRl40Bqp95vrVJ0NkUoHOC4FnRmd8hnfmCzqCoV8v51+jwO6ajZDPZmfVHHemgHvB86zFHOo8BDM+38uYMn6M5A15DHjNnMPi/OHa83ucDsQvyiPVxfHlYtIPp/RrFICXHFjnf4t0VebL7dZLdw1AWIzuD/+8guy8GZMe2ra63UvOtR6kM4wTOKRWdb2H9bW2+pcZ4a99oOXpj8y2Vjywy30L6vHql/OzDVKbm0cqfccyF9s3zrYfbtInnW4q/KhaKi4XSZzHAcVnR+OXDjrhCMUoVC02kU8VC5eiUiYV+6BQLvRnG8x9PQiz0nz0QCyXHTmxL2VhoMciuL/ut8m9s2ygnjoVUTkfFSTyvL3oqCetPwg7d6FhoMnboqvHK40Rg+t+ooJe3Y1bJdAR+G65QLMS5Z7UbUPmzj1BZKBba3KZNoViI190xb8ywD0J7EXYPsLOFx+bTepz4eBDKnqCyWPtEHChf9BUIfy21weD3y/hOc423LdA4pyVaR83/qNyntWM60LWyAvr7GylfKxeM00F9SR/Mm6K+JEk4pjL4xwU86hzHho9DGcdzSh8xvjB9VPIyHrshL+QhRl5qDSxWXmz3KK8nCZeKf1GGIXkZj92QF/IQIy+1xyVWXiYDJa+nCVe7Oc5SgjfcA4n2Cbxr2uBPA5/At/KEfPyDAjf6xhrhwHbURTsGqQzrpnhHD9/ye7LyPBxrjgAvrAuIl2/cOQ/GjTeRbEaT8SdmfUvlOEYBhneSjkDZMxG4Hg7QflbAPxOgjXzxHhnemzMCv62e8gMmmw79QL/yAyMIAHjz+gnhY2Sl+kmtufPeuNic0wiVxeac8KTFm3LmJNiOPJ/N9oDzGZ7rqHlCSPdCV/Qr3VM5VmX/7DfUvhplS+w3sG/Zb5TdCX9DJrNu7oRn/a4nWr/zdri/D3zbzTm+rb8gzrfBeHQe2GiS6PX2Dn1BXfmCUQBgXxDywelT1G+OZL9j9q+qdfMReMcxgcloQMAjPt6b94uRMcEo8R6bAw/N+8weUrk/nfHRbg/kHaR76jaH0B5Ig38G9PkumuN5+I3HqAz9AJ92Rp0K6ZnavW9woT23He47j86l8L7z0XL0gvvO1TqPxyeX0//UyRnVD5hLaXd603zVZPs1lFOMX1NrTWoPIdsz+gj2A2rPq1qLYXroI0agDU+T7SsfGRuzYP76h5SHRvti+x+BMrZ/1HeOG1CGHDc8C7yomMfw8ifcXgIf9qskG6XLI/COx67nBTzuS+VbbVDXn4/A9VSAtjot/3yANvLFN0A9T38rm1S2OJL97sZ8A+MCtkXVTwgfIyvVT+oWmOepLNZ2n6UyHN9HqQx1G0+i/mrOuI3tUDnedqfT76Cxe2vJFfwO2O6fVrmCFtrMp9WrcgWtttvtXMGfdilXwHvEqlzB+O+8XMHfbwW5gv8A3/b/nHIF36lyBWNlU5Ur+NceyRXsedyW3+1yBT91yhXsA2f+pmW/q1yBfKpcAdGrcgVTkyswHxHykWVyBZ/bSnMFB4EPm0+yqXIF+TZZ5QqK2a5HroD10ytX8FPKFSDffF5f2ZSyeT6vP5K0yoL7Ly9XYHjrBH8G2O7FJBtlP2r/X6z98JxJ2U8IV2iPkboR6WMB2sgX38DOtqzO0HdxHJW2i/bJthvymekTIyvVT+oGXL5pV+W91N0BfEsUjkNs86jbI8l4m1k/1d6m2HEX9xrx/R1PtcHL8hwR8KFb21UOJXRGTNk/+w11a5vSdfYb1p+oqwjPuQKDvzbriw5vXJW5Av5CwPPAg9JvnlsZ/O3g296S49v6C+Jck+FplyuwfuxGTI32zr4g5IPTp6jfZLvFvuE7Y2JvcGM7G0h0DJF3Q+sG6APOFaA/4jhjFMpGqOwZQTd0n1Iq98coV6Bu8kzh3kW6NwJlKi5l3TP4D4M+v4dyBR5+41kqQz+AOPLGHKVn6uY/HEO5nvmBDm9KjM4V8C32z5ejV/gWe4+bqtP/XhT0VD9grqDdTeahXEE3/doIAMT4NYTnuTu2ke0ZfcQIlY1CGfuPZwL01PwOfUTIR8bONzBmuYxyBSMAx/aPNs72j/rOcQPKkOOGF4AXFfPgmI3wo+DDPkuyUbocimPVjf54Gz+vw4S+9qtwjQRoq6/kvBSgrb6Sw7wkSb5NKls02XRjvoFxAdui6if1BY2QrFQ/NQkeZVPUdl+gMhzf2a5Rtz8Gbf5szriN7VD5ShUPjADed9HYjXx34xbnkWRiO1Tsi37G8HLs+2tgu79PslH+Gf1l0biT50xqvh7CNRqgHdJfRRv5wrpMm/m0esp2TTbdsF3P+YGSleqnZtJq12yDsTdKs33G3iiN4y7r56hoR+y4Owp4+VZ3tdYa0r1QnlXp3jOifcr+Q7k19huoo+w31Fc22c5QVxGecwUG/w3KFZT8ko/MFfDX6zCfofSb51YG/wPwbX+T49v6C+L8ZmSuwPqxGzE12jv7gpAPTp+ifpPtFvsmZi8YypRzBSajgUTnLHHPC8K/FsgVoD/ivGbsDfe8d2oEyjBXsOPxW37zWkz6G3MFP8pZP0PdQ5/Dumfwu8AXJf+N4g0PvzFCZSpnFBpzQl/NVesCSp/ND3Q4l47OFfBXn0rmJoJffVLznQ795liuQM1xVD9grqDdl85CuYJu+rXQekg7ufLcHdvI9ow+gv0A+gj2H6F9DCNQD2Nx8xEhHxkbs+Ca566UK0D7Cq2Lsf2jvofm1iPJxHaoLwqrOVed4PcGH3YUyUbpciiObTdf59ynmq+HcIXyFOrLsR8P0Ea+sC7TzrNJZYsmm27MNzAuYFsM5WjSJ0ZWqp+aBI+yKWq7L1KZ+uqjsl3MgbF+tttPwbablz/8USDP342vQfPc+hPAC6/D8ziA8CeD7S4j2bycjD8xOqG+hPwywLCfQp34ZASu0J6gVwT8JwO0kS+sy7SZT6unbNdk0w3bRXtj21X9hPAxslL91CR4lI2VxX6Z+hNUFvtl6o9Dm1k/1fp/3p08bA+4J4i/Dq98YUj32o1ZrHtqzFL2z34D7X+EylBH2W9g37Lf4C+OMzznCgz+yqwvLP5EHSmg6zJX8Arx+DLwoPSb51YG/zbwbb+Q49v6C+JcleFplyuwfuxGTI32zr4g5IPTp6jfZLvFvuGcjso7oEw5V2AyGhDwiK9O8DdCH3CuAP3Ry8T7CJRxDKJyx8ofYa7gAcoVoO1irmA96R76NPYX6cO6Z/APgT7flv329BsvUBn6AY6t1Zij9EytFeEYyvXMD5hfQV3sRq7A8DeS1jaXyRUo+8PxgXMFJf3mWK7gVUFP9QPmClCmSN9whXIF3fRrKKcYv4bwPHfHNrI9o49gPzACZew/Phaghz4CY/EHyPaVj4yNWXB+/mIWsygbZ/tHGx+hMtR3jhtQhhw3vAK8qJgHx2yEfwJ82MskG6XLoTj2UwL+VYB5idqDuv6pCFwfD9D+tID/VIA28oV1mXaeTSpbNNl0Y76BcQHbouonhI+RleqnJsGjbIra7itUhuM72zXq9iehzS/njNvYDhy32XZfErxiPLC15Qo+B7b7uyQb5Z9DuYKi83X0Ya9E4ArN10L6q2gjX1iXaTOfVq+XcgWqn0I+VslK9VMzabVrtsHJzBX8bpdyBete57mCmDEfdRXhOVdg8F+nXAHqSKe5gleJR8xnxMzrDf474Nv+LMe3xeYKDP4veyBXgPbOviDkg9OnqN9ku8W+mapcwbcicwWc1xyBMo9cwQ7Zx0na5Qq+65QrmHnCeL1/noRcAfoBzhWoMUfpmcoV4BjK9cwPdDiXjs4VGP5G0trmMrkCZX+hXEFJvzmWK1BzHNUPmCtQcxHE1Yu5gnZy5bm7ymkWnW+w/yiTKzAfEfKRZXIF1zvlClDfOW5AGXLc8CrwomIeHLMRfmfwYXNJNkqXQ3Gsx3w9hCuUK/hlAf/pAG3kC+sy7TybnOxcAcYFbIuhHE36xMhK9VOT4FE2RW33VSrD8Z3tGnUbc2Csn165Ao4HRgRe5RNqxC/Ch+Yn7faOhvYavUhlaq8+00GfMAIwG7LfvNfo2EzO7WJqo92hvs/s9j6advPBkey3io14zwvKGM8j8dgwArwvp7EBc1G8JyN01wPXxT4YyIHn/WQGfwb08ZIFGifyMALvOtVnbEOn+oy2sYbaavDnTq4+z5hqfWadRX3mnJDS51rS6sM6yeec3oP6f/k2pP9v7nH9V3OJkP63y5Gw/mP8NhX6f0gB/X8lQFPpv7UtT/8xn4jwtwT0X8l3BN4VXSMM6f+nqAzrfTSHDuo/9jvrv8G/PVL/jXY39B9lxPofmjelT9G5Dq8JYPwe0n9er/XS/1kF9H8kQFPpv7U1T/8NH+fL7w7ov7LBUXjX6VoXtuFVKsN6H82hkxfPs/4b/P2R+m+0u6H/nvPXdnmGkey3WusO6T+vc3jp/4+P2vLb+ngU4EJ3OMacY1dnVfh8oTqzqc708ZnNEcgNfYbm3ipGehbedWPOG8I1GqDd7m4Mpq3uxmBeEsGn1evi+a/+bp9rVbJS/dQkeJSNsq1RKos9VxK6Kw/Pi7F+jop2xNruKOAdPWoi3ufa4C16h6vRUvb/PJWF7n5F+485x650nf0GrvclAp7Xog3+N7K+sPUN1JECui7XovmuGjyHr/Sb1+4M/uvg234rx7f1F8T5pchx1umumnq376pp5zfZbtXZtBr9jbjU+g3b2UCi57qGj896/4GI65Q/4vs41H1Nyh89S2VoM7gW/QNai0bbxbXoPyXdQ5/G/iJ98u5i/FfQ57/Ifnv6Db4PS911EBpzlJ41RX0cQ7me+YEOz4BHr0Ub/kbS2uYya9Gx99N16DfH1qJVnlD1A65FqzO0iCu0Ft1Nv4ZyivFrCM9rw9hGtmf0EewH0Eew/xgJ0EMfgbH4D8j2lY8cFXgHqQzrpngfo/kG2lfoPqeYc+xqzxzHDS8BLyrmwTEb4X8KPmzOiRNxKl0OxbHtzpnz/UHqnHkI1/MB2i8L+E8EaKtzO8xLkuTbpLJFk0035hsYF7AttluTjZGV6qcmwaNsitour2+PQFnorjzMv7N+huL89GHbfU7wivHATEE/NHaPUJmKlZRd8/00ao1hFGDy7qfY68TxevNINt73U4xSe4reTxG6i6+d32Da1f0UE+FVP8XcT6Hua1H2yTkGnGfwfESNOUo/231TLDTu4t0yb6Jcgfc9kKx7Km5W9s9+I3ZcZ7+Bfct+g+NDhudcgcGflvWFxZ+oI53mCngcxzM3Sr95bmXwK8G3Lczxbf0FcS7O8LTLFTiN4/Vuj+Pt/CbbLfYNzx/VWIoy5VyByWgg0XkKw8f57QugD0K5giLxgsrfKX+EuYK3ZXxwPjf9jbmCi0n3yuapNoA+X5b99vQbodia962qMUfpmdobiGMo1zM/YH4FdbEbuQLD30ha21wmVxA7d+/Qb47lClQcrvoBcwUoU3V/TyhX0E2/FsqBtpMrz92xjWzPoXziCJSx/3g2QA99BMbib4uYb4wKvCpmwfnGSsoVqP1HRc/Jctyg5nM8buTtaco7J/su8GH3k2yULndypxbvwy96p1Yox/6KgA+dAaju1JoIr/pJnTkJ3akVsl3OMeD4znaNuo37y+/PGbexHWotRMUDOOZfTGM35gr4uxdF8wHK5jlOU7HvqOCVY9/HwXY/0eU83yi1p2ieLzRfa5fnY9pVnm8ivOqnmDwffveCcwWx9sk2j7qN4+4nupQr2IVyBconhHSv3X4a1r3YMyTsN4rmA5Sus9+w/kRdRXjOFRj85ylXgDrSaa7gZeIR8xlKv/POBH8NfNuv5vi2/oI4/3tkrsBp/3bhs6AhH5w+Rf0m260a42v0N+JSZ8DYzgYSnbPMOy/wPwO5AvRHnNdEf8Q5kOcEXeWPMFfwHcoVoO1iruD3SfdUXh99Duuewb8G+vxHFG94+A3e46RyRqExR+mZWufFMZTrmR/ocC4dnSsw/I2ktc1lcgXK/tR8p0O/OZYriL1/D3MFai6CuEK5gm76tdB6SDu58txd3fmifERoDYP9x3MBeugjMBb/Dtm+8pGjAq+KWXC/wiDlCtC+2P6L5gPU3JrjhpeBFxXz4JiN8D8CH7b9/Ik4lS6H4th283Veh1Hz9RCuTs49he4LaXenlrLJLt43IecbGBewLRa9c1fJSvWTOiPG52dibfdlKlP5AGW7mANj/Wy3Z5Nt9wXBK8YDW1uuYKf54/UOIdlUuYJWPqtcwcSyycwVsH565Qr+YN5EvFWuYPx3Xq7g+KwvejlXcD74tvk5vq1oruCUDE+VK5i6XMHZ0AdTmStYk/HRLlewLCfmKJoruBH0eXn2u8oVyKfKFRC9KlcwNbmCNWT7XrmC/5HFLFtbrmA9+LC7qlxBC+08m6xyBcVs1yNXcFeXcgXLaOwO5QqQt1Eq8zyDMAIweWcQNoHtPkuy8T6DMELtmcwzCCNEuzqDMBE+dLdf6AxCKFcwCmUeZxCejcgVjMA7tt0RwWuK9z7KFXifQRjJfhc9g8B+I5R/mOwzCJ+mXEHJmL6rZxC+BL7tszm+regZhF+JzBVUZxBaZep1BuE3I3MFnOcYhTKPMwjfpFxB3hmE3yXdK3sG4Vugz1+heMPDb1RnEKozCD9Hnv37ej2DgD6C/cAolHmcQfgm2b7ykSMCr4pZ8AzCHZQriM0Vsv1P9hmE74IPm3bSRJzVGYR8m6zOIBSzXY8zCKyfXmcQfpfGbuSb7wyarH0FI4JXjn0HTxqvty/JxntfwQi1p+i+gtEA7XbrYyNEu9pXMBFe9VPMvgLMiY1Smfe+AtbPUdGOEXgXGndHAe+yiH0FId1rt69gJPtddF8B+41e2ldwRNYXvbyvYDH4tqNyfFvRfQXHZniqfQVTt6/gdOgDzhWgP+r2voJVGR/t9hWcRbpXdl/BatDnc7Lfnn6j2ldQ7Sv4OfLs39frvgJ1l1m39hWsIttXPnJE4FUxC+4rWBzYV8D230v7Cm4AH/Yekk21ryDfJqt9BcVs12NfwXtyxm1sR5l9BRwPPCvwjgq8NeIX4UfgHctf+ZzQfgUVC6l1zmdy6KBPwLatzP7ltZ8PRMbU3VyL9/x2QLv5oMlExUZ8z6e6M1ftOXsWeD+MxoYawC0jXmtJK6810bZmTn2FC/vlMPh9KJQj/MdpLonyLNCvywahTgI4EHdJnVmGbbVHxZMYOyl66dMQZfUIXr44/9fPf+bfj51Ro/rGC79jvewX8MsEvMlqgHgfSqKe85XtGm0r47ZjGdqf8ZDa7PULJvLXX5K/GPkh/qaAXw5wRfpidjJRF1DfzV7xjt6HqQx98yiVKd8cyjmzf0O/jd8B4TV7g/80xHK/FTFWYvzcjW/ThHCFvkPbbo8b01ZzWeYlSfJjAGUfJptujG2hNdh2MU2MrFQ/qTVbziU9DGX8PapRKOP4UH37JrQHTemn1zet+ih3rGKzkO61i81Y92JjM/Yboftzi+aO2M5QVxGec8cG/wc03pfMucjcMe85fRF4KJJr+xb4tv/tlL/7k8mNcwvnWIruOW3nN9luQ3sPnhO41NyK7Wwg0TG24asT/N8Gcsfoj3huOQploXwSx+9oM5g7Hjh5y+/BpNV2MXf8/3LyR6h76HNY9wy+cfJ4ve9Q7tjDb3BeCf0ArxOoMUfpWVPUxzGU65kfML9Sct9XdO7Y8DeS1jaXyR0r+1PzzA795ljuODZXjbljtRaOuEK54276tdD8vZ1cOZer1lKVj2A/MApl7D+eCdBDH4GxuPmIkI+MjVmeA7w/PnLLb2XjbP+x+0xjcs48bigfxmM2ws8CH3YAyUbpciiObbfuGVoLezkCVyg/1G6PG9NWe9yYlyTJt8kuruP0d3t9WslK9VOT4FE2RW2X88OxOWdc92H9DMX56cO2+7zgFeOBrS1XcATY7kKSTZUraOWzyhVMLJvMXAHrp1eu4ItHTsRb5QrGf+flCi7I+qKXcwWrwbddmOPbiuYKLsrwVLmCqcsVXA19MJW5gvdH5grekhNzFM0VbAR9XpP9rnIF8qlyBUSvyhVMTa7g/V3KFXx+K80VfAh82NNVrqCFdp5NVrmCYrbrkSt4uku5Ao4HHhF4nxJ4a0mrH4rZZ/asgEd58He1UY4cE2C9h3PoqBxE+vA+M4P/eGRMbbS7oe8oI9Z35bMRnuWt5o8YK/P8Wu35U/puNI3npwTOlPdRGhueBLgPJxPLnoYyPss8AmX8rTXUEeQD+wn1YBPAGN46wf9XGBu+SjaidPhpeMd9EOoz5Efpdcy85skA7Xb9z7SRL6zLtJlP1AejZWUmm27YCvoftpWQr0mfGFmpflK2wnHdh6HsSSoL3Z2E31oboTLU7dFkvM2sn0+KdmyCdzw2bBK8/vz8AOWiRgTekO6NCvgRgGHde1q0T9k/+w20f/YbqKPsN7Bv2W/gfD8R8JyLMvi/oFwU6kgBXZe5qOeJx2eBB6XfPHc3+H8G3/aNHN/WXxDn30SOmyPZ727M2SZz3GS7xb55mnA9LXCp+Rvb2UCiYyTDVyf47wRyUeiPniXe0R+NUtlHBV3ljzAXNeuULb/V+STMRX2fdA99moolWfcMfsdTxuv9iHJRSLus3+CYFP0A4mCdCumZmidwTIX1zA+YX0Fd7EYuyvA3ktY2l8lFKfsbhXeciyrpN8dyUWp+pPoBc1EoUzVfCuWiRoB/hPXwayinGL+G8JwbwjayPaOPYD+APoL9x0cD9NBHYCxuPiLkI2NjlqcB70k030D7YvsP3dWK+s5xA8qQ44bngRcV8+CYjfB7gA87gmQzFfdShnCNBmi3O9c0QrRVLp55SZJ8m5zsuTnGBWyL7XIyMbJS/aTOgPFaWKztcn4Lx3e2a9RtzPeyfo6KdozAu9g7VjgeeEDg7Rd4DX4T4OojHOnvDdnvOsEfl7UHY1fD+aDgIXR+arOAfxBgjJ+ZSasf20xlWO/e7LfSd4PrUN9nKH3H9rC+PwxlfQKeZaNyi5hTMvxNgkc5Wdm9UGY0BwkPyjt9d8PhE/lp17esXw8BLtW3t2W/6wR/dkC/lL7cB+9YhiGZIz8ziQesO1PUM/kq/TK4DvVrptIvbA/rV0hf0odl86iARx0yvpsEj3KyMrRLo6nOaz4IvO/3holw6L9qOf8ar/yO5wmIaznxs8mRDrb7MKJzP5ThPO4qGg9QJn2i7i3Z7zrBvwNioKuz3zNF/U1U38quATvbuCC/PvtgHCP6qQzlgT4nr50If1tOO68HPm8L5EqMrw7trqnsDn1fjF9H+KJ+nX032uT9hOt+gUvNAzhGGEh0Hxi+OsGvhz7gXAnK40Hi/d6CvKvxRPkRq5vS/qu5W36rOOAhoqnGMNVXTVH/wRxc0wT/aLfc732JHg8Z3nQC85XKP9cJ/r3QV/cs0DiTHB7uz+F5IAf+YeLB4O8U+hLyA6j/mwmnwd8NOG8viHNdDs57A7GGstOH4F3R8ZTjCZTjo1SGvPO4+AjQZ9hbiT6WoZ4z3STAL4+p7fjl8cbKRmG8eiT7PZ3wFfTVfaG+WiH4je2r+wPtY1xWr5606mPIRlAeHzlF4+wviPNpMaarWOVQwD+aE48kSWs8kj7sl9FnoB1eRTEJ0u8n/m2ceEHYoxrrDVdnY33tr9RYfy9A8FivZIPw7BMeEvDYjxxj43hzCJUhLxxb3SvoxI6l90Jbf2XuRLybAnjT379AfLSL8d6S/WY//LmAH1YyDMlczRFRrryOiv3BOQWls5Otj9h+1sdQW9On6HyY9VGNH0ofOc4K6U36hPQR81IvUWyHvPLc4+EAP+1i7jrBm48fyIFnn2/wXw7EPY8JHkLzhMcF/GOC55nEA9Zl2nn7u5ZRewz+9yP9sVPOY7bSf5Qb639IRunDMn1CwKOseH/XE1D2KJUhL49RmcojhWw21jasbkr7feSrvfNz7KsN/q8L5udCvrpb+bmQr+6mrvZqfg55ic3PrYuIBfoD/Ct93CT4V3kl7nes90DSnq9Ngi81j9kUoHNih3ROFHS6nYM8kdrzYKA9RXMhWP9Bas+Dju1RPLfLqfadmkxom/JtOIfh8c7g9z51vN5A9juUUy2qu/clE/kM5ZDSZwW0P0m6EXPqddvJjDk5rsTxMiZniLqHY6fBJMRjN+SF9hwzZ1R+IyRflaNrJq2yfIDKUN82ER2v/Ou5c9vz/0Cgve30g3MxPbRGN+UxAOtC0TU69pdIR/lL7mP0r9gvvGZl8EdkPlXFjkoPQnrTbk5n/Cjd4HP9Ks/fRR/S03qzmcpU3jFWb0K5wglj9KkTcagcWS2ZOE6iPiN83vrKJsJTo/fbw3usdxO1mWMkxn0zwVs7B3LgDR/HImeCrSwJ5MQUzrXEw+Y2PDxEPBj8OYKHkPzTJxQTTk9abbGA3dRrhM/4wXeIv5Fo/RhKop4ay8/oKT1IH7ZlZU9qrSTkA5WdK1wx69KxuCxuUDHsCUSn6LwI64fmX/M7pDNf0On2/OsEorPZkQ7azHyi87AjHdSD3YjOI450cDzivTMPCB5S/b6e5nmPQpmKGS7K/uU87adOG693A83z0Fcgj1hf5UywHUzvloyG+T/M4xbwR/Kck+FqJ7t1JDu1VhOSncFvBtndGpAd27aKMWYmrfLgmB7zs7z2qvK/+I51TuXIB0U9Hq8wD1xkrhhjG4i/kbS2ucx4pfLcGBPy+ZEPl6M3dn5EnaFU/TAr0TJV5z85v6niDeUbH6cy9Gecp0f7PhR+I428NllsOzPAn4pDMXZT+RbWvcmOlR4qRy8YK6n8UNFYifdf9WqshHxyrFQ054r1HwzQmd8hnfmCTrdzu1WsFE+nTKz0klOsdByM9y/TeI++IiZWeki0g+l9ugdipc9ErCeEZGfwu4LsPheQHdt2FSuN84nvEH8VK+XHSire6Gas9FCbNnGspPhT8U76DCVxT0wshe0r0Hf7xeqm4feKpVRcomIpa98j5egNpbq2fVYP49hV8Fvtf8L+8uo/lZuZqv7bVI5esP9Uzsqz/9C2ivSfss2j4DeWYXtCcSXWn6y48iiikzfG/w2N8WpNC8d43jNg8P8Mewa+SWN87L6A+4FnbrPTOn9f0XNNob3L6VN03y2PUaF1a7WnvJa09knRdWs833pYzrp1DfDeIuqybSP8ZsGHwfNZGobhcy8G/yNYg1mUs98u79xL3jrsvwXWYbt97gXlzOdIsF5oHdbgOrSJ/ZRNYHvYJtQeXhUrGny7Pbys9xjLbiZcbF/ps0zgCvG6qQNeuR+xr3i/scGiXmJ7WC/H9iRm86V2+41N5t3o/9A6vJJpaB2+nUw53xXaixxah2+354Z94gOCBxwTJ2uOyjmDJ4CXPsGr4a0T/D4wzz76tIk4bb6UJHE2q+ZnOOfi89A4N3syAlfIl35EwD8ZoI18YV2mzXxavS7altwnh3Ntti3VTwgfIyvVT+peF75jMna+/ASVxc6XH4c2s36qOCvWdjEvxTkr5atCuhc7VoXOmyj7Z7+hxjhlS+w3sG/Zb3AehOE512jwC7K+sPkX6kgBXZe5xo8Qjx8GHpR+cw7R4C8G33ZGjm/rL4jzrMhx1vqxG/e0ob2zLwj54PQp6jfZbrFvYs4Go0w5rjcZDQh4xMdnq5ZDH/CdCuiPPky8x+bv+LySWkNI5b4+44PPW6W/cb58Keke+jT2F+nDumfwt4E+X5H99vQbvLcT/QDHqWrMUXqm4jMcQ7me+QHzK6iL3ciJG/5G0trmMnmr2Bx1h35zLCf+UUFP9QPmxFGmSN9whe6f7KZfQznF+DWVJ28mrW1ke0YfwX4AfQT7j4cD9NBHYCy+nmxf+cjYmAXXIV+i+QbaF9s/2jjbP+o7xw0oQ44bPgK8qJgHx2yEfzf4sE0kG6XLoThWfQsP7xl8jNqDuv5UBK7HA7TVPaJPBWir+42ZlyTJt0lliyabbsw3MC5gW1T9hPAxslL91CR4lE1R2/0IleH4znaNuo330m/KGbexHThus+0+JnjFeGCy9v555Qo+DLb7yR7PFYTy7VWuYJyfdj7WM1cQuw/RI1fA+qnW32LH3QlnuyNyBZ3cTVE2V8B+o5dyBf91K8gV/D74tl9zyhX8RpUrGCubqlzBVwK5AvRH3c4VfDcyV/CHTrmCfwZ9/uNArqCs36hyBVWu4OfIs39fr7kC9BHdzhV8t0u5gusDuQK2/17KFfwYfNjg6RNxVrmCfJuscgXFbNcjV8D66ZUr4HiA9/Snz5Xwjvey8B7vPD4M3vQkb69VXm5gp6z9uNdK7QtaCm3b5XTdNvQTav7DMd5xp4/X2z37rWIdvtdCxTpJ0uqXGfa0HBnsB3zsc3o+LdOhwUAbUxwHnJ4Pd5qAYxzThAx4fHtI1FNzTz6T8xjReDRA4xFRT9F4mHCizNRZgw+3KX9CtC0R76YJ+Mdy2psI2o+3wfuowKN8TchHcUztFRt8PrssV9lLnk0ovXoswPsTxHu7vYDMu5If+g+1P5LPMrBubRbtrIm/jb/r4B37WHXXO8JYXd6fulD4TMaZtw9wOAfnYsDJ+1OVzhwB73gsDvUT8qP2NT5G9dQdQol4p/rnfoLlXMJpgqe8vx8RePJ4CJ2vDZ3f89pT+BzZprrL0f5+kHhHWL4rhc9msH7n7WdH/UYY1m+Dvzig3+pcIPI1nIPzsoB+K7kfDu+K3p/GcyN1f5riHX0Pv1P9w/rN/ug0wVPe3w8JPHk8qHUn0+8HcnAyTdaH9GH97hd00ndHkn4jHb6nXe31U3vymqI+39FkPKwBXeLvYiCfqo3LcnDeGNBP7/vYQ98Q2hyoh/03XdAash8/DT+Gz2xhuyRfB3m/+gaQ0/sXaF5qzE+bp4vnGIdqhC9JdI5wKz3HuK/HOUY+G5X+xtz2e2i+p2wM667OfrON3QnzrPfl4EySznzTTodMxNutu1uV7YbO/fCdGep7N8aDiiERnu8pN/gPgW3e1vW762vfUzkljBE5Hgmdm0qfonEsf69HrY+E9Evlellv8r6HwN/8MfjHoA943QrvpuWzLg8U5D3vDmC2RbQNtmN1rlDZXMjukW/7Ngrb/UhgbPX+vgyvw6v4Tu3fCZ1HNbhu3IE6mfdOG36Vw+A4Ut1bqnwvni/98cET+VH3LWPfsn4hrj7Bx5uy3/ytvl8O6Jf3Hf58N3PseWez/S6ed54z1eedrW9jzjujL+Rz8uobiinvf0L6pcZJrPvm7DePk18smGsJ2Vy7Mcr4CeVaVE6VdUnl94yH0F6D9Pe1yUQ5GPyXI+MFpz1vi4quB4e+XZM+3BehPXIokybBc7/g34grtP6ivp/02P9f3NWDRhFE4bvc5m7vJ4ZgisiBEcSAEBEC1ygSiQSC+NuoQY02IYUImkYhFoKFBI/ERtAqpYVIEBUstDOCaBEsgkgK/7BQNE1EsVBZ2YcfX96+3c1luG32mHnzzduZN+9vk7cKPtd+WjD8haR/M5uEd03vaucNz9REeN60OJ99Vus7ODwWbU8+gj4q/nyrrBfrs6jc6ynCFPoPhj7QbGod2tLWaOfcq5aP1OIHqzbA2vjzmYFm12hn+2HV9k9boz2p/KMMjZH8oz2/RnNafiyPxXmi5D+qRvoPQ/7j4vLjhCn0v1Lmviz5j/MRLB/Jqssj+sahfz7YbP+c5d/yz9PmeZPKP8rQEfK3tPrJOPZE+JvrJ1fCNU0qXxg3rNYH1WTI0r2cn9F8V97HKDvDcYrQd8I6WP7WGn1zY32z9Tm/e9P8W0t/WrWFNP2p2UvWn92wB1Z+hnNL0yl5T3re8EztIXuDsS/bm2ljTh6L5zrK3gge24atynplaY6ofBDbG6HvNfSBprssexMXr3M+SKuzpcXyVrwudA2ez07X39WKy5WxvUF9yN/LSftdraTyjzK0PZT/xtb14sks8CLYOYXSo7vQ7A73pAjzy91LwMebue8LD/b2neX/ewku2aNSA/jVx6Pz/YufF13hT/Z5HVPD+4dc4c8Xviy/eDZ23RX+R//QYMvDercr/JvLB2pXujYvucK/8XTb0NLhrxvj8NeFv/PQn6MxhfDuQV9ewfOI/mh4BoKzM0y+Sqsy3794yaDLRtw1npEfaSsq9DmFXuYuKfTSV4Y+1LFIg+uFWEXoR/rR8NllT3wYI+Pblfl9ml/jG9taiL6s0JcV+uA5R0iv4bOnfccdXHkaj204t7yfDq5CZiW/uI/Ck6yrr9BLH8oEy0sJ2nMKVoHGCf047SM+j4xvV+bHtchE8I1tvI+afBcV+mB9zvT/53m1OubSy/HbvzvufHKlw+7Xene0Heu57Aq/be7RwXc/z/W4wr/6/s/r+sSGb67wd81cmKzUZu+5wr9bfjXwZMYfcYW/c8tUV/X5+Yor/FavemvT7Ol9cfh/AWoHItj5FAkA",
      "custom_attributes": [
        "external",
        "utility"
      ],
      "debug_symbols": "TJ3LjjQ9b6Tv5V/PonQgRfpWZjGYo2HAsIE5rHzz08kQFbHx94T/txVKSYzKymJX/8c//sf//G//75//y7/82//69//zj3/6z//xj//2v//lX//1X/75v/zrv//3//p//+Xf/+3v//sf//h9/2flP/5p/ad/7D/hf/8Z//in+PvPxH8W/rPxH8N/HP85+E/gP1n/sR/+g1EMoxhGMYxiGMUwimEUwyiGURyjOEZxjOIYxTGKYxTHKI5RHKM4RjkY5WCUg1EORjkY5WCUg1EORjkY5WCUwCiBUQKjBEYJjBIYJTBKYJTAKIFREqMkRkmMkhglMUpilMQoiVESoyRGGb/f/e+4/533v+v+d9//2v2v3/+e+9+4/73jjTveuOONO96444073rjjjTveuOONv/HG74O8MH8No+FvzLE+WA27wRr+xh3+wd/As34qGvLC+jWMhtnwN/LcH+wGa/CGb2T7IBrywnf0x3c53+EHzIa/kdf4YDdYgzechmjIC185AEbDbOiRrUe2HvkrjfUty1ccgGjIC1+JAEbDbFgNu8EaemTvkb1H9h759MinRz498umRT498euTTI58e+fTIp0eOHjl65K+c1rcFX0EBdoM1eMNpiIa88JUXYDT0yNkjZ4+cPXL2yNkjZ4+cd+T5+zWMhtmwGnaDNXjDaYiGHnn0yKNHHj3y6JFHjzx65NEjjx559MijR5498uyRZ488e+TZI88eefbIs0eePfLskVePvHrk1SOvHnn1yKtHXj3y6pFXj7x65N0j7x5598i7R9498u6Rd4+8e+SqwfggL1QNFoyG2bAadoM1eMNp6JGtR/Ye+avBPT6YDavhb+TtH1iDN5yGaMgLXw0CRsNsWA098umRT498biLNEw03kWb8GkbDbFgNu8EavKFHjh45euSvBnd+MBpmw2rYDdbgDachGhKwfr+G0TAbVsPfyPb7wBq84TREQ174ahAwGmbDauiRR488euSvBu18EA154atBwGiYDathN1iDN/TIs0eePfLqkVePvHrk1SOvHnn1yKtHXj3y6pFXj7x75N0j7x5598i7R9498u6Rd4+8e+TdI1uPbD2y9cjWI1uPbD2y9cjWI1uPbD2y98jeI3uP7D2y98jeI3uP7D2y98jeI58e+fTIp0c+PfLpkU+PfHrk0yOfHvn0yNEjR48cPXL0yNEjR48c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INJt0G3QbdBt0I1ZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkllSP4BijcBIXcRON6MRDDGI+rCy5SLekW9KtsmTMQiM68RCDmBdnNRI2DuIkLuImGtGJhxhEug26DboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptum26Gd2Mbka3ypKxCzfRiOV2Cg8xiPmwsuTiIE7iIm6iEenmdHO6Od0O3Q7dDt0O3Q7dDt0O3Q7dDt0O3YJuQbegW9At6BZ0C7oF3YJuQbekW9It6ZZ0S7ol3ZJuSbekWz638fsRB3ESF3ETjejEQwwi3QbdBt0G3QbdBt0G3QbdBt0G3QbdJt0m3SbdJt0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0W3TbdNt023TbdNt023TbdNt023TbdjG5GN6Ob0c3oZnRjlgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslilixmyWKWLGbJYpYsZslilixmyWKWLGbJYpYsZslilixm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wSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksQd/r9zd9F/pegZUlFz+3vQoncRE30YhOPMQg5sPKkot0c7ohS07hJhrRiYcYxHyILAEO4iTS7dDt0O3Q7dDt0O3QLegWdAu6Bd2CbkG3oFvQLegWdEu6Jd2Sbkm3pFvSLemWdEu65XND3+vFQZzERdxEIzrxEINIt0G3QbdBt0G3QbdBt8oSm4WHGMTPzb4jh77Xi4NYZ3IXLuImGtGJhxjEfFhZcnEQ6bbotui26Lbotui26Lbotum26bbptum26bbptum26bbptulmdDO6Gd2MbkY3o5vRzehmdDO6Od2cbk43p5vTzenmdHO6Od2cboduh26Hboduh26Hboduh26HboduQbegW9At6BZ0C7oF3YJuQbegW9It6ZZ0S7ol3ZJuSbekW9Itnxv6Xi8O4iQu4iYa0YmHGES6DboNug26IUtG4SYa0YmHGMR8iPsS4CBOIt0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0W3TbdNt023TbdNt023TbdNt023TbdjG5GN6Ob0c3oZnQzuhndjG5GN6eb083p5nRzujndnG5ON6eb0+3Q7dDt0O3Q7dDt0O3Q7dDt0O3QLegWdAu6Bd2CbkG3oFvQLegWdEu6Jd2Sbkm3pFvSLemWdEu65XND3+vFQZzERfzcLAqN6MTPzfFvg5gPK0t8FQ7iJC7iJhrRiYcYxHw46TbpNuk26TbpNuk26TbpNuk26bbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptulmdDO6Gd2MbkY3o5vRzehmdDO6Od2cbk43p5vTzenmdHO6Od2cboduh26Hboduh26Hboduh26HboduQbegW9At6BZ0C7oF3YJuQbegW9It6ZZ0S7ol3ZJuSbekW9Itnxv6Xi8O4iQu4iYa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",
      "is_unconstrained": true,
      "name": "get_owner"
    },
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14067204867181196045": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "9921926525851912681": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [
          {
            "name": "chain_id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 16
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "array",
            "length": 32,
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            }
          },
          "visibility": "public"
        }
      },
      "bytecode": "H4sIAAAAAAAA/+y9CZxc1XEuflvTM0yj0bQWMGIfdol9R2LzCLFLYl8FxAgQAiwjjCRjsOMVMDuIfbNBFhhsY7Cdzc7fL7ET5yV+ibM4iZ04Thxns53nNXGSF8eJ/1x0a+abr797+tzb1aMWuvf3A/XcU6eqTp2qOnXqLLeWbHzekP27YvmaN924fMW1q9csv3H5VW9a/pZr17z6a+TVkloGUc/+tb/xsXcjSdRTKwA7hrsGddLfU179ry/jq//V/wZe/W+rV/8bfPW/xqv/bf3qf1Nf/W/o1f+mvfrf8Kv/NV/9b/qr/8149b+Zr/4369X/tnn1v22TjZLY7tX/Zr/63/av/rfDq//t+Op/O736386v/rfLq//tajwoIYz0CnPAR5K06+Kfjm4sHcygpkDtviS+SweJarH67/nFQUZYqH7yWn2TfIn6tUGoU6L+az2cPpdCfeYlgX8vhbpcZyj7XRMwqRZtA78PhLpI02gxHivvsL2XWf16ufojQ8BjQrxbGePGsn4oM7hUHi+MbvzdoT5c1qF8RmYm+Tpgur4QKyRRT5/VPVHV/cnqr33k9+/9pS++uOaF5x+d8fVpT0zdf+t333bbD3f8wU5P/ui2DVb3JOAJ3WqbZ8Dqn6xoH/9rfUuv+dRPV0095f2v3PT1vzxj7bSdlv3Wrnc8v/R31u363TfdbnVPUXW/c89T726+8uCzI/t9+d8GTrn/e2/619P65339y+/c/rff97Pv/ughq3uqqvuVpT/7619uPnTL2+/97DvmzZm17KWHvvbjf/7d33+5+a/f+sRbv3aE1T0N2lxP4u3a6p9erv6YX1xUrv4Uq78Y6pfxy0vK1Z9u9c+AlyP2473PvfjXC+798sF//7Ot71qy7Na3H3b3n174/Vtmv7DXP173iZ1emmF1z1R1/27NwnVrtnvLkd8f/KN7D1m/487f/MkLv/ztf795+bzvffs7v7rbv1rds1TdNo/VPVvUnX3oPvNvePyPt/nGnN3/avTzLx348PY/2fPYb3zm1PU/+umX/h/UPSf7t6C8xvrr3HL161b/vHL1x/zD+VC/gI2P6csF5eqP0b+wXP0x+V0EL0fCdcaGN6t7cXxde/qt7lJRd99jGz96/q533Zb87Qv/975/3/dzowfM2GXBjAP/7Kmv7nj9jZds/yOrewkwVKDPdkqjwXTs+vToxhdpZLhnVrh2zbUrr11z84LVq5ffuGbhqrfcsGzNtVesXH7mjcuuXLn8guU3rr521fWMsEZ/L8x5n9KZPZHOKcvXnL/x18JV169Z/vY1/YR3Cv3dR3/X6W+ub3FSfw4extHusXF6K6hfQN/OsvqD5eovt/qNcvVvtPpbl6t/tdWfWq7+Kqs/VK7+W6z+tHL1r7X6w+XqX2/1m+Xqr7D608vVH7H6M8rVX231Z5arv8zqzypX/yqrv025+lda/W3L1X+b1X9Dufo321xpO3hpfs5wz4b3BfzyzjXClyQT/VRC+BvES9FYrUb4jB63D+dJadn2gpemKGMfub2gs72go3ANOuJqOOLa2hHX1B5t45AjrmmOuIYdcTUdcU13xOUpe08bmtGjuGY64vLUCU/Ze+rXLEdcnrbtqRPbOOLy9NHbOuLq1fHR4iyLHTDWqOX8a3T4ndFpEK5aUi7uUe2aLegNJq3tKkBvTI47CHoqzjL4HSP5S3XSfFU2rz5x+RVrVyxetSKhh6e6J+WwuFMykf3tA6wx3hr9x+8Zt1o2wCdtnqlR1ryTl6+58przlq1YsfyqVxu5mmswphNz3ptS7iDqWqfvSJyOJFHPlBilRvwN4qWsUiulwfah0thgmUl18aplVy1cdsPqtSuXc9oFpxgsFcSK71Sf1oAzfMd6eSL9vVjUSwRu1CXUMyUJwzmctLZpp5x6bLL8boqA35Fw7SjqGe99gfqIA+uxxoS0OkYrrR3p00zy2x8zFS5pPduUtZ5Op8IhWacPDwk7laM3K6SjiNP4MVnvLMoM1y7Z3wM5uKxuneCfy/5tElz6nEU0dhb84juTT5pufYZ4R9mynnQiR8RnfOE7xN9IOtLLWqjfsH2sJzuXozczRu7Ij8l6F1FmuHbN/h7IwWV16wT/qezfJsGlD+vJLoJffId68hLxzvFB+nQoxwWxemL4G0lHelkL9Ru2j/Vkl3L0RmPkjvyYrHcVZYZrJPt7IAeX1a0T/G9k/zYJLn1YT3YV/OI71JPPZr8H2/Db5lmpZF2g/k2DSavsCtRfM0jwBetfY/V3K1f/HVZ/93L1D7b6e5Sr/4ume3vCS7bzveB9kaXNWDs3/A3ipayd70X0uH2cQt9b8NIUZZxC31vQ2VvQUbgajrimOuLaxhHXoCOuGT2Ka5ojrmFHXE1HXNMdce3siMtT73tVXrs44vLU1V0dcY044vKUvWcbZzri6lVd3c0R1+6OuCw2svEe44Na9u+gqFd0boj4jE98h/gbxEtBerWQXLB9PKfZpxy9GTWqj/QQp/Fjsp4jygzX3OzvgRxcVrdO8NMygTYJLn14TjNH8IvvcE4zmOEdFvxyfqeoPmJ9lhHWY33spL8Qn/GJ7xB/I+lI/2sh/VBysfbNKUdvekz/Ij8m67mizHDtm/09kIPL6tYJfmfSx7nAE+vjXMEvvkN9nF2byDvKlvWkpBxPitUTw99IOtLLWqjfsH2sJ3PL0TsxRu7Ij8l6X1FmuPbL/h7IwWV16wS/L+nJvsAT68m+gl98h3qyV4Z3MIffkSTuYRsxHIgb5RLfD7Ufx+qZ4W8kHfV7LSRHZW/Wvv1K0av9iHUD6SFO48dkvb8oM1wHZH8P5OCyunWCn0d6hjRYN6wM+cV3qGeHkT9C2bKelJNjckKsnhj+RtKJXo7rieo3ZW/Wvv3L0VsQI3fkx2R9gCgzXHYMcCAHl9WtE/xJpCcHAE/sjw4Q/OI71JNR8kfIb/qMJFFPTcm6QP0W2SEOw41HKAv0489j9dTwN5LWfiyjpwcSvbx+sLYfJHhpijKUMZYhnYMEnQpXhavCVeGqcFW4KlybN679KlyvC1xbgn5VNlT1Y+UnKnvcXHFV+lXp6paoq1U8UcmramMl+80VV6WrlU5sifKq9Kvqxy0RV2VDlU5sibKv/GplQ5W8KlztcFVzq6qNlY+udHVzxVXpV8VXhauyx8lsY4Wr8jnVOFS1sWpj5XMqeVX9WOnX5ourynVUbax8TuUnKlyV3lc2VMm+sqEKVy/rahVPVDpRyb6S/WTiqsahSl6VDVW42uHqdZ2we2HxzjD+nou6n+vAAB2sb3BDol4t+3dQ8JfSGUminuh7ywx/I2ltcwF6tZD8lVys7QcLXpqijPv5YEHnYEGnwtU5rv17FFfVxteHvLYEvipcrw97rPxEhavS1crfTyZfVT9Wbaz0qxo7Nle+Kp2o5FXpV9WPFa7Khiqd2DJlX/nVyoYqeVW42uGq5lZVGysfXenq5oqr0q+KrwpXZY+T2cYKV+VzqnGoamPVxsrnVPKq+rHSr80XV5XrqNpY+ZzKT1S4Kr2vbKiSfWVDFa5e1tUqnqh0opJ9JfvJxFWNQ5W8KhuqcLXDVelEhavCVeGqcFW4KlwVrtc7Lru37CAoO5DoHCToHBSgg/UNTt1Nlv43kkQ95w2KNhSo/yarf0i5+m+1+oeWq//2oQz+MHhZy/413IfD+7543IfUCF+S1cd3iL9BvBSkN3Zv2+FEj9tnemFtP0Lw0hRlrCNHCDpHCDoK14gjrkFHXNMdcW3jiGtnR1wzHXFNc8Q15IjLUydmOeI62BHXDEdchzjiajji2tURl6dt7+aIa8QRl6c9Djvi8uzHPRxxeeqEp+w9bduzjZ46MdURV6/6CU++Rhxx9WrMVI1pm072nva4tSMuzzYe2qN87eaIy7ONNtaquTD6pDbPWp5rGg7EfSS8LzDvPb5G+JJEz7MNfyNpbWeZefaRRC9Prtb2owQvTVF2EPzGMqRzlKCjcI044hp0xDW9R9s4zRHXsCOuXR1xecp+N0dcI464toR+3MMRl6dOzHLENdURl6f/muGIy1P2nrrqKfte9V+euuqpX0OOuDz70VO/PG3IU78ajrhm9mgbezWW82zjiCOuXu3HXo3lDnXE1atxjmeMWcUTrw8b8vQTnnx56tchjrgOd8TlKXvPGMDGWssDHQL1atm/HebAdqsRPuMT3yH+RtLal145MGyfycXad1Q5eiMx/YD8mKzniTLDNT/7eyAHl9WtE/xJAxv/bQoac4iGlSG/+M7k0//qf6MZ3mHBL9uckvuRAm9T1GcZYT3Wx5L91Rerj4a/kXSk/7WQfii5KP2wuqpfWf6x/RrCxXlhK0+fQVGvgDzqsfI3/I2ko/6uheSi/KS1fb7gpUll6XMWwHFZn3g3ZZJxcX+lz0gSfKw7WmRhvCHeo+F9gX7pj9WDo7PfjaS1X8rowdFEL0+m1vZjBC9NKksf7rtjBJ1jBJ3NBRfqEPsoK0+fDvViRlm9KOmPgnqh/Ka175hy9KbH9APyY7I+VpQZruOyvwdycFndOsHfRPEC0uB4wcqQX3yH8cKNFC8gv/MIr5L70QKvGq8M7vVGZ0jUY/sqqX/RftfwN5KO7LkW0nclF6XvVlfpKcs/Vk83R1ymf8cE6BT171j/mIqOO52jOqRzVCSd+R3SmS/oDIl67IdQT+P9Qu1vY/2Q4W8kHfm9WsgOlVysfceVolf7Jo/NSA9xGj8m6+NFmeF6Y/b3QA4uq1sn+JdonEcaPM5bGfKL73Ccf4HGeeSX56VF/R/WZxlhPdbHcv2VNGP10fA3kk70f1wflX4ouVj7ji9Hbzimf5Efk/UbRZnhGs3+HsjBZXXrBP850sc3Ak88X3mj4BffoT7+WoZ3MIffkSTqOUPJukD9bw0mrbIrUP8Qqz9arv6zVn9Bufpzrf4J5ep/xuovLFf/JKt/Yrn6v2r1TypX/71W/+Ry9S+y+qeUq3+Z1T+1XP05Vv+0cvUPs/qnl6v/Hau/qFz9U63+4nL1P2v1l5Srf4PVP6Nc/XVW/8xy9Rda/bPK1f83q392ufoPWf1zytX/kdU/D+oXWVOx+heUq99n/J6PLwVPht/GunMBvpbzr+HiMqPVIFwFea+FeEf+OF46H+hhG/NwnV8Q16AoK9Mn5yX57UL8QwFeFJ+7w+9O2zzLEddxjrgajriOd8T1Rkdco464FjjiOsER11aOuBY64jrREddJPYrrZEdcpzjiOtUR12mOuE53xLXIEdcbHHEtdsS1xBHXGY64znTE5Tl2nOWI62xHXOc44prTg7gS+N1hvuO0DvMVR3eYr1jSYb7i3A7zDQs6zDec0mG+4MQO8wWLLdY+DV7Wsn9VLqBA3H9GjfAliZ4/Gf4G8VKQ3tj86XSix+3j9cZFgpemKGMbWSToLBJ0FK5hR1zbOuKa6YhrZ0dc0xxxzXLENd0R15AjrkFHXDN6FJenrjYdcXnKftQRl6euetrjrj3aRk97PNwRl6cN9arsRxxxefoJz7HW0094yt5TXr2qX56xiWc/esp+S/ATuzniWuCIa6EjrhN6FNeJjrhOcsTlKfuDe5Svkx1xbeWIy1MnjnPEdYojLs9+9OTLU1cXOOLylNdBjrg8ddWzHz356lV5eerqqY64PHXV03/t4YjLM/7a2hGXZ07BMyb3nCt45h4tvrc89slQr5b922EOf7hG+IxPfIf4G8RLQXrBHD62j/dGLypHb1pMPyA/JuvFosxw2drtQA4uq1sn+K9kgViT4NKH10oXC37xHe6N/vJWE3lH2bKelJTjTrF6YvgbSUd6WQv1G7aP13oWC16aooxj4lh5K1wNR1xTHXFt44hr0BHXjB7FNc0R17AjrqYjrumOuJY44vK0Ic9+3NYR10xHXLs64vK0bU/98rQhT7+6Jch+yBGXp482X2jnEjGemU10isbeWN/gOjzvck6H510u6PC8ypkdnjc52eKqs+FlLftXnSUpEOO9t0b4kkTHlIa/QbwUpDcWU55D9Lh9HFOeJ3hpijLeP6TOQ5wn6Chcw464tnXENdMR186OuKY54prliGu6I64ljrgajrg8Zd+rurqrI65BR1ye+uXpc6Y64toSZD/Uo22c0aO4PG276YjLU/ajjrg8dbVXYwBPXNW4XQxXNW5vOv2qxu1NJ/tq3N50tt2r47anvHpVVw93xOUpL0+f4yn7EUdcnjbkOW73qo/u1XjCs42esa9nP3rKfkvwE7s54trKEdciR1yeefLFjrhOdMR1kCOuhY64DnbEdZwjrjMccW0Jsl/giOsER1wnOeLylNeZjrg8ddXThnpV73u1jVuCL/Tkqxo7Xh9jx1mOuDxjOU95neqI6xRHXJ5jradOeMqrV8eOPRxxec75tnbE5bmm45kH8MxPeO7P4TM2uDeslv3b4Z3H02qEz/jEd4i/QbwUpFcLyQXbZ3Lp8P7foRrVR3rqjl+T9QWizHBdmP09kIPL6tYJfu9sgbRJcOnD494Fgl98Z/JJz9js1pjIO8qW9aSkHPeM1RO+j7qkXgbvo1b2o/rN6jZFGeefYuWtcDUccU11xLWNI65BR1wzehTXNEdcw464mo64pjviWuKIa6YjLk973NURl6d+ecprZ0dcnvrlaUOeftVTJzz9aq/atqc9etrQto64PO1xS9CvIUdcnjGAjbV2hgvjZT7DVfQObKyf970RK0+fDr9Hs65G+IxPfIf4G0lrm8vE7Er+Si7W9gsFL01Rxvm8CwWdCwUdhWvYEde2jrhmOuLa2RHXNEdcsxxxTXfEtcQRV8MRl6fse1VXd3XENeiIy1O/PH3OVEdcW4Lsh3q0jTN6FJenbTcdcXnKftQRl6eu9moM4ImrV8dtT9l7xgCePtoznuhVXa3G7U3nV6uYvBiuKibfdPpVxYWbTr96NS70lFev6urhjrg85eXpczxlP+KIy9OGPMeOXvXRvTqmebbRM/b17EdP2W8JfmI3R1xbOeI60RHXIkdcBzni8lwf8pTXqY64DnbEdZwjrjMccXnqxEJHXJ6y97RtT3v0tKHFjrg87XFL0K8FjrhOcMR1kiMuT3md6YjL0xd6+uhe1ftebeOWMNZ68lXFJq+PseMsR1ye8YSnvDxj8lMccXmOtZ464SmvXh079nDE5ZlT2NoRl+e6lWeeyTP/5bm/kM9g4t7WWvbvoKiX0hlJop6hGuEzPvEd4m8QLwXp1UJyUfukrX0XlaM3tUb1kR7iNH5M1heLMsO1NPt7IAeX1a0T/EcyY2oSXPrwuHex4BffmXzSM5jrt57IO8qW9aSkHL8QqyeGv5F0pJe1UL8p+7H2XVyO3udj5I78GL2l5ej1WV9dKnAbL5dlfw/k8GJ16wT/WdKHS0SdJpWlD+sglvWJd1M2Ea5LBS6Uo/VJahuvZLJQ+p/+N5JEPYeyXzAciLukLlwYa1uGv5F0pOs19mNGL8/HKD2yuk1Rxvmysn2f/t61R3ENOuIacsS1xBGXp7ymOeIadsTVdMQ1vUfbOLVH+drGEZenPXr24yxHXJ42NMMRl2c/eurqto64PPWr4YjrDY64PPW+V32OZxt3c8S1uyOuPRxxecrLMzbx1K9ejQs99b5XY7mZjrh2dsS1JcRyvar3nrFJNaYVw9WrsVyv+kLPWM7TF3r2o6e8ejX+eqMjrl6Nv7Z2xOVp25425Ckvz3HI04Z6Vfae/sszL9eruSFP/fKMfXs1xuzVseMiR1w2dgwRbitPnw7Xm3auET7jE98h/kbS2k6v9SZsX9n1Jt7P3iv+0NOOejVX7unDPHFV603FcHnm5jxtyLMfPdcDPGOdXs3DeOqXJ1+9uq7TqzkKz3703Kvg6e/Nr9rdqRgb8d2pKg5ZGqCD9Q1uSNSrZf8OCv4KxEu31Qif8YnvEH8jaW1zmfhMyV/JRe1ds7pNUcb78EP7t5COwjXsiGtbR1wzHXHt7IhrmiOuWY64pjviWuKIq+GIy1P2vaqruzriGnTE5alfnnx59qMnX55+1VMnPPtxyBGXp+xn9CguTz/RdMTlKftRR1yeutqr8YQnrioG2HRjRxUDbDq+qhhg0/VjFQNsOj/RqzGAp7x6VVcPd8TlKa9e9RMjjrg8bahXx45ejX17Vb8842jPfvSU/ZbgJ3ZzxLWVI65Fjrg88/eLHXGd6IjrIEdcCx1xHdyjfHn2oydfxzni8tQJz35c4IjrBEdcJzni8pTXmY64znDE1au6Wtnjpmtjr+pXNQ5Ves+4itzL0w6XZ4zp2Y+nOuI6xRGX57jtqROe8upVe9zDEZfnXHRrR1ye61ae+QnPvInnfibLddj+Q5zLH0V0thJ0tgrQwfoGNyjqjSRRzzG2f+8geFkjvOiP++Jx12uEL8nq4zvE3yBeCtIb27t4PNHj9plMre2jgpemKOOczKigMyroNEXZWV3ANZjD50gS9Zyv+rtA/TezPA0H8rYA3hfo29mxumT4G0lr/5XRpQVEL69frO0nCF6aooz76ARB5wRBR+EadsR1fI/yNdUR1y6OuDzbON0R15AjrhmOuJqOuDzltasjrjc44lriiGvQEZen7Kc54prVo23czRHX7o64bP4yWbGqojO/QzrzBZ0hUa+W/dthLLJ/jfAZn/gO8TeS1jZ7xSJKLkVjEY5Fe2WcPtwRl+c43as+ZltHXDMdce3siGtLGCt6NW725GsbR1yecY1nrOupE1s74vLUiYYjLk95efqvXp1nePajJ1+9OnZ49qOn7D1te0uas/SavHp13Pa07W6MtTZfWQD1atm/g6JeN+Zqhr9BvBSkVwvJBdtncrG2nyR4aYoyXjc+SdA5SdBRuKY54prhiGsbR1xTHXFt64hr0BFXo0f5muWIa7ojrt0cce3uiGsPR1ye8hp2xOVpj7s64vLUe09f6NmPWzvi8vQ5njox5IjLU/Yze5SvJY64PHXCMzbxHLc9+7FX/ZenfnnaY6/6aE9cnvrVdMRlsrf1uxOg7ByiU3ROiPVPmGQ6an6Z/jeSRD1X8PzNcCBu3AdbYC55ZY3wJYmeuxr+RtLab2XmrqcSvTw9sbYvErw0RdlC+I1lSGeRoKNwHeqIa4kjrkFHXNs44tq1R9s4yxHXdEdcnjox0xGXp04c74hrS9CJYUdcUx1x9apte8reU15b92gbd3bE5dmPnnrfdMTlqfcjjrg8dWI3R1yeOlHFX68PH+051h7siGtL8IV7OOLy9DknOOI63BGXpw15ystzTJvqiKtX5bWbI65enVt5yt7Thjzl5emjq7Hj9TF2eM6tpjriajjiqnIKm86GPGXv2cY3OOLq1fmQp+ynOeLq1Xzhbo64Kj9RDJdnPFH5iU0n+171ExZ/8Z0Z6TOSRD01Wz9diC8Jb8m14/4a4UuSuLXjheXoBdeOsX1l14691qrS56wex2V7H7DvTyY6Ss6nBuhgfYMbEvVY/7APCujDMbH6Z/gbSUf6XgvJX8nF2r5Y8NIUZdzPiwWdxYKOwjXTEdc0R1w7O+IadMQ1yxHXdEdcuzrimuqIy7ON2/RoG4cccS1xxHW4Iy5P/fK0R0/98vSFnnwNO+Ly1PstQSdGHHF56teMHm2jp+y3dsTlqfcNR1yVn3h9+AnPNr7BEZdnPNGrst/NEVdlQ8VwHdyjbdwSbMhT9p5zd8858h7Z72HRZr4T8GBB5+AAHax/cIDO/A7pzI+k0432DIp6I0nwqduPoawu5rFqhBf7qhs5YcPfIF4K0quFdFHlRK3tZwhemlSWPpyTO0PQOUPQ2VxwtdNdzgkX1d2TI+lUNt877RlM9Dg0kkQ9tygfUqD+AWyjhgN5uwTeF/AXi2P9k+FvJK32UsY/XUL08uzT2n6p4KUpyjy/MzLVEdeW8I32EUdcvfod1F79zq4nX57fI/LU1YYjLk/b9pT9cI+2sfJfrw//NeKIy1P22zji8tT7wx1xedp2r9qjp4/u1bHWsx89v4G2JYxDW0IbPfny9Ku9Om4v7lG+POV1qCMuz29LesYmvTqmVfa46drYq+P2ljBP89SJExxx9areL3HE1au5jm0dcXXDR6s1gYVEp+iaANbvhTWORR3SWdRj7anWoKr2pL/P6ZDOOZF0Kj3onfaU2Ldhz+G2NngovKwRXlwPLLBOOVwjfEmi10UNf4N4KUhvbF30OKLH7eN10UsEL01Rxms6av31EkGnKcrOqnBVuCpcLrh6eH+cpYnGfA36JvazJfefRO+P4/0nJf16cP8Jto/97KWCF56HpA/rSNk5Ta/i2sJjkSl/NOsX1g48d9mVB+wz7aQfz5758Pvf+MV73/fGffbn8dhwI16UYQGdrcfaiOFvJB3ZZC2kI8q/WdsvE7w0RRnfK3CZoHOZoKNwHeyIa//sdzVn2Izt9Cerv/aR37/3l7744poXnn90xtenPTF1/63ffdttP9zxBzs9+aPbnuvQFi+0+peVqz/L6v9Cufozrf6bytWfYfUvL1f/RKu/rFz9BVb/ilL1a2N9fyW8HYmqO972q8awFeJ91OovL1d/V6t/dbn6/2P1V5SqX/uR1b+mVP3kv63+tfByxH4c/2t9S6/51E9XTT3l/a/c9PW/PGPttJ2W/daudzy/9HfW7frdN33A6l5XjvaQ1X9zufpTrf7KcvV3tPpvgZcjUVWTKVb3eqA9Jb7+oNVfVa7+kVb/hnL1j7L6b4X6BWQ3YvVvLFd/rP2rS9WvfdPqr0Gmsn/3/Oqvb/UfH7u//um/+NGqm/5t34f+zyn3/sbHj33wywcc/55z//7RHyyxumtL0U6mWf23Cdpt+B7zdTeNvSmWw7L6by9MO6lb3ZtV3e/c89S7m688+OzIfl/+t4FT7v/em/71tP55X//yO7f/7ff97Ls/etjq3qLqfmXpz/76l5sP3fL2ez/7jnlzZi176aGv/fiff/f3X27+67c+8davjenqOzLwgm3exuq/s1z9fqv/i+XqD1j9d5Wrv5XVf3e5+g2r/55y9be2+u+FlyNRVZOm1X2fqDvrkORru37ziJv3e8ORq858263fPO8T79pmw9xvN2f/YO2xb/vPb6yyuu8Xdds8R/S/+r+3T9/4h8WgOD/aAX6n//Vnf/cn4zHo9gBjdesEf8U+4/XemdEbojqGI30GqX7Bvti+RviSRM/7DH8jaW17mXlfP9Hj9vG8b0Dw0hRlu8FvLEM6A4KOwrWHI67pjriWOOIadMQ17IhrliOuaT3axqYjrl7Vr5mOuBqOuHZ1xOWpX57y2tkRl6d+edrQVEdcnjrh6Vdt/+uQqFfL/rU4YDt4X2BcnlIjfMYnvkP8DcFnmThgO6KXJ5e0n8021q65duW1a25evGrZVQuX3bB67crlUxB1MjEaYqkgVnxXSya2Hss48qoT3Mn092JRLxG4+4DubChTkjCcFn1im2bn1ENZJOLdFAG/HeHaTtQz3vsC9dNnSPCwqTW2ZKQc1FhsH0euswUvTVGGMszzGCpCLsrX1GQ88sgs6cTlV6xdsXjVioQeVvOTclicTXCLc1irCbw1+o/fz6Z3fUnYVEOTpRiVSR92xgizPdGpnHHljDcPZ9wn6rHGDIv3vGWyaChzjqCn6FzQIZ0LBJ1BUW/Efrz3uRf/esG9Xz7473+29V1Llt369sPu/tMLv3/L7Bf2+sfrPrHTSzNTOX2TUj5s0civ9TumfFR/1Qn+5b3H6/19Rm8q1M0s7IS1K998zvI1N167/G3LX/XVqxN62pnFGfT3maKeemLG8JKOJ9rRGX6vMVypVt5YGe/oWCFQKogV39WS8o7uTPq7jKNrFzWwows5J+4VRTd9piT5jkg5Mc41hhxZ+lRD88anuMZuyUNzjMbGDs15Gps3NHO9/iRfw+sEa+mBDjV7wilb5rEaAzY+1RiwuYwBfaIe8xbS6hittHakTzPJb/9g0iqPEfvxd2sWrluz3VuO/P7gH917yPodd/7mT1745W//+83L533v29/51d1+0qF1XdChVzg/bc82mWuw/sesBU/ubB00b93T6tYJ/t0zx+vNzuillrdXVp5Z3gXLVl571bI1y0+6/q1rl69dftUZq9YsX73g+qtOetvy69cUDolPob9PFfXUo5QLlWKY3qX/8mbImsAXUqyjBK1BUW8kCT5j/qeLLj16w/2mcunW9q0EL00qSx/e2L6VoLOVoLO54EIdGkpadapTp6jsIBSkl6WjMi3c1x50UG6cDxx0pIOLSLZx3GyzAfVGkqhnqzrhOj1ztKmsjp4xsR1bQ0X2C7joVsBOow8ZGP4G8VLWL0wletw+9gtDgpemKOMF6SFBZ0jQaYqys7qAS9nf1lSmbEb5Gr6wW+lmWv8a0iP06dsD3OIZ4++RLwwc0Hefl/1bJ/grIHA4kwIVDk6wDHWKs5Ko34NUhv3PH9Up2mdY3+CGRD22P9xw0I1x2fA3ktY2l7G/aUQvz/6sfcPl6NWNXlPQU/0wPdEyRfqGy2LHIcBrMP3AP8IW5T+1t8+MjtNhObE+t5Mr2yy2sUFlsT5iiMpifcRUaMM1BewUfSzbKdoPb7gwenXRLvRZdYJfRemUkrov0ylDRNN4eCeMw28F/5kkvaFn7cZPW+FpJomMD7AsVs9YP7cK0Msbi56MHIveRWNRA8pixiKDPwnGovd2UcfVOMWxiOozfMdjEdY3uCFRj8eikvYRPRYZ/kaidWskiXpqoTEaY2kei0qOtWNj0bCgp/oBxyKUqRqXNtVYhHJifW4nVx4bWG+wDPuf/YDa/Fd0LMJY88mAnfKYYrygTBGexxSDf4bGlJLzGTmmGC7e98I+bj35OHVAAfNe7OMMfg74uOe64OO2orLKx23ZPk75hNABkDyfgHqmfMJ+8Btp5LWJF0UUf/x3P8GmD8/7cZmP6ysfY/Cfy2wxbe+XRzf+7mKOd7dY3e6hZbtz16y6cdmK5ecsX3YVcohYR+A9luNjMLyLUe1qxL956e+tAg8/JiX83e0MLWdOpzjSwU2rnDmtCzodHm+L1lI+3lYyagoeb8P2sQcuaYUjIauIyYazbNErDuTgsrp1gv/zzAN5rlSkvP1xzizO8Kl/DS+/Cy3XYlTNdoeR1NcpkqpDmVoZRDtH+GGIpP6aIim0k/4cvqxc/Zskce1HGM6Cd9vura1oa4fAb7aZkB01RX3uz7pjexTP7JdZb74XEYFjXdYbg/8xZIt+SHqD9Y3HrRMdoVs71bYOPlywleB1IMCrwf87RCV/PDoRJ66UhUZyg28IeIzgeFaBPo5nDoq22kTGtPN8Is62Ef6/of1/Orrxt7I9jminCNwhX1wDnNzPsWOD4VC6MgkZh91UxgHHhLxxyvjJG0Ni9cdsR80WeXcAtpH7QI39NXhnuqX8BfqE75Ft1wWv3bTdWdn4FGu7yi9vzra7A7SfbVf52ZDtqj7Ecd3awji7YVMoqxibUtuMY/uVM3vYl1tRWd65FNYtla1im1KyxNhtsjJW7F+GgBcVKxreOsEfBLHiCTMn4lSrgCrbg/6d4TkDhO3BTM1wBK7QGK5WZocDtJEvrMu0mU+rp2zLZNOhbfUr28LMW8xqrVqVDslK9VOT4FE2RbNneau7qJvtVndZP9V4GGu7OB6uJ9vlcQHLYnd3sO2iDrHtTgNeVJyFK84Ivxhs900kG2U/amdErP30U3uU/YRwhfzGdAHfDNBGvrCusmWVAVa2a7Lphu2ifaqYOAF+GD5GVqqfmgSPsim6GjaNytB2OSuOuo1jEuunGt/V0QC1wo6r6O8i2+WdU1iG9sm2i/bJtos6xLY7DLwo2+WdGQZ/LdjuO0k2yn7Uqoen/YRwhfzGDAE/PUAb+cK6ypbVbilluyabbtgu2ifbbshnpk+MrFQ/NQkeZVN0twuP12i7PCajbuOYxPq5tWhHrO3iCjnv1DwI4AzvbIHX4O0KZZt/MQwfCTH498P866ujyQQZIK8HUTvwymaTv+XZDyPeR5KoJ/qQmuFvEC8F6Y2tIxxG9Lh95Q6p4QEelgpixXeozVzGGeluHFI7AsqUJHg9Ftt0RE491lx+N0XAH0a4DhP1jPe+QH3EgfVYY9iKcAQ7SNBmK3oYrOgvR/PpHpQkLXJgS+oT9MzqjiDY9DGrO5JwjCRRz4WxVmf4G8RLWas7kuhx+8pZHWoKUrmAsBoMwuJzAXCG8Ly+wb03IOrxYxKrE8+fgDjoQ9lvZWl7Ed9K2/Edr6tgfYNTdHbqkM5Ogo5pMl7luj+V7Rko2xvK9qKyfaCM173nAJ9nUdncpLXNVnZAAOeBAudrY/ms8Trpf6cBnNJ09qoLgCbWxb/7Bax9jqNOsJ8Hvfo06RVaMevVEW34DunVEUk+nZ06pLOToGN9gvrLunOkaKuVzYMy7uejgRfWnWNEu6zs2ADOUYEz7Z+FsybCcf+nj3n80+F9AQ98QazHN/wN4qWsxz+d6HH7eL/G2eXonV+j+kgPcRo/JutzRZnhsp2aAzm4rG6d4L+c2VuT4NKH92ucK/jFd7hf4/dmTuQdZVvL+dfw8ju2L2y79Y/RWQBluO7+FZoXoZ/qE3XtqDz7qqfgnqY/J1+F9bnvlJ2Ubf9poo3DSatsdoTfefp9eoDOjoH2dKs/dyQ6R4i2prL/FvXn2VDWJ+raZ3DqBH8r9Oc/UH8qW1Ry5nGpqJz3EnS6LWceX851pIN+Cq99SP87n3CxnK2fTM7nQdn5VO8iKEM4nHWdD+8vErQVfsPRTgf/baZuW54O8m56g78WdPD/ldTBc6kM+wD9BfKBckD4X0h0uwZy4PPa9XOxds5jCcoK+4L9r8FPmTWOk/cjKN1aAO84x6f04XzRLiXTi5L2tFHOi3NoDyRhXawTfAPaz/sRThP1lR3tS7yc14Z3tm+sb3BDol6nfkTx3M4mZ9Lcpp1NLst+s+6eAza5bYZzOGmvI8gzzyOKynknQafbcuY5wkWOdNBmeFxQn4BEOVs/mZyXQtmlVA8/mYdwOC7gZ/nUpxwV/thxYe9Zum15Omi06gR/FOjgXNJBNa4oHbyIylCmPC6084fLCN74HkjC422d4A8WPixkr6g3PC4Y/GGBccHoYrsWwDseF5QuLhXtUjK9lHAtELhQzjwuKJli+xdQ+w3+6MhxweqrfMR+VIb5iLOpDPMRHLMeDWXnUhnmIzg3gvkI9nejUIY6wvmIHQLtwbwd5/swb3cklWHebh6VzYGyo6kM83bHUBnm7Y6lsgOhbBTaank7vjbtzOx9h+tb8mRpXl6U4fDfJIkbD7CveJ/+YY50ENfJROcIRzpHBNozT9Cx/kJ76cZ6pOFvJK22WyZPdjTR4/aVWxlBb8NSQaz4rpZMbD2WTcZ65DFQpiTBmXNs0zE59VAWiXg3RcAfTbiOFvWM975AfcSB9VhjavQ+bz3ScNQJ/hoYrb4xOg6fRwvlwSOm8Z63s4B5MPiVwMNXRzXOek675uXgfPescXmsmqVxJgKnatcx1C7m4WjiweBXi0igj2CYH/XO5J+Iuvy30pmDCP7YNu3hfjL4mwP9dKTgAW1ycRseGOaYHB5+UfAgvNvCVTfcnHm3hJ5254RZ8rxue6TAk/eYNFItNI3k9Qz2VOoda4DVTVu+TfZ77OMxK5evWZ7Tdvbc9RyaUxL9xIyhJdeaosdQXmvqdAxVOWI1hlrbVR6wKcp4TndaJJ20TzNVwZPyeV0aO7jWBFtcPyFcNfEufbq45FhaDSZrybFYKIXKyVJBrPguJPl2ve1xo79aDD1N4FTJ77Nz6rVzclME/OmE63RRz3jvC9RHHFiPNYYtJC+U4pBjbEEShibb2sV17O9r4ffs7HdooanDhe4ZsVZl+BtJR1ZcC+mSWoArZlXsWo3KdMJqMAiLz3TgDOHzhkV7loh6/JjEWEtegcD0OUolonby55eQh9Dw0RT1OVWCmxr3pzIM8HkLS8z2FlV2rGiXSifx1pcFAmcqtx9HbH2J0fj04ZSj2lqBGsveT23tMFzntcF1DuFSS3mG6/w2uEKpZ6vLaUhVD1Oo50TwgO9CnxozuCFRr2yfNQM8h7ZrpTr0eZoUXgRlarS4LvvNy4AjsDTw22TPmC7mZUDkmW29qJwvEHS6LWe246WOdDDFz8tTaokI5Wz9ZHJWy0tW73Io46UltYR1uaCt8BuOdjr4Z7N02/J00GjVGR508GuBMSWkg0upDGXK461axlF9UCO+85ZS8pbd/iawPKXsFflaQjgN/luB5Sm13KSilZAuXirapWR6GeFS0Sq2hxMoSqZoN6dT+w3+O5HLU7yUhDFDkeWp2CUoXmbCmIHjl1EoY3+3AMpQR35MSzbWnp/Qkk3JdIJcsjFcw0mrDHGZC8uSZLw/1dGipqh/cIDO3A7pzBV0hkQ9a3eHcoye/xt+r6NdKr5WcuGYE+sqO+Jkqi193pzl7V7zX9tMxD0b6LJccamuQDuPjJWr4W8QL2XlugPR4/axXPcUvDRFGW+J3lPQ2VPQUbimOuI63BHXsCOuWY64pvdoGz370bON2/RoG4cccS1xxLWzI65BR1y7OuKa5ojLUyc87dHThjx1wlNeTUdcMxxxecp+a0dcnrJvOOLylJenL5zpiMtTXr3qCz3l5elztoSYyVMnPMdtT9nv4ojLU+89ZT/iiMtT9p5t9PQTnjGAp7x2c8S1R/bbckyYhziY6Kg5/w4BOlh/hwhcKn8QamPeFT3Wb2Nbp65Yu2LxqhUJPXX6+6QcFo8guMU5rNUE3hr9x+95d3SfgEXcaVppG7qpvwvbdQ6tEb4k6a3tOkV3bZ0Jv7EM6Zwt6ChcUx1xDTniWuKIa2dHXIOOuHZ1xDXNEZenTgw74pruiMtTJzzl1XTE5SmvrR1xecrrcEdcnro6yxHXltCPDUdcnvLyHIdmOuLylFevjkOe8vL095765elzPO3RUyc8YyZP2e/iiMtT7z1lP+KIy1P2nm309BO9Gn/t5ohrj+y3OhzBaZKit1Nh/dMjcKn5cKiNXU6TGIuHENziHNZqAm+N/uP3h9C7dmmSevbbUjPfzZbqLS1ScleR3A3Gu7QwHYS73bAsSeIydVh/zwCdvTuks7egMyTqWbs7lOM0lB/yie8QfyNpbXOZ9JLaJafkYu0rmc4aqiWtptoncPLOu5BbMfsZyMHFO0MN/meZ7jeTVpfCu61iXVeahvwP2t2mdg3G9DPiVS4xRh/L0kF94oseUbZsx6F+VXSwft4BUtzxjDutRwke+1nh3B/KEb6x7cZ/0x3C38yQttvJPnXb9rzOE7zWCf7be43XG85wKjlbvys9OI3K9hR0FU72jUX7bm/BQwjXKMDsQ/DWFwM58IaP+2429N2fjk7EafXz9Oe0HB5Qf0bhd57+7FRCf3bZtj2vWHcfom3wXwL92Y30B+uH9Id386L+mIzU2Mo7rYuOrVg/NIbzhdmK99A4FtrtrWSk6FzYIZ0LBZ1ujw8XEp1RRzqjABO6CPhi+I1lRoffMR2sH7qEdG6HdOYKOn2CzgGAg5faDCZ9LE7CE44F4qR6TL8g/gbxUpDeWByoToOqqSBfBol1m6Is79JwpBO6kBJx7emI62jCpfTmYoGrqLy6MK28gODOy2GtT+Ct0X/8/gJ6lzetNNzKJPOugkiSOJNU9/xNlul38WqCaNM2/JN9NYG689/qNpNWtS97V/9k4VIH1+cTnaIZMKx/doDOSR3SOSmSzsIO6SyMpHNqh3ROjaRzeod0To+kM1l6MFntWdQhnUU91p7XW/9MVnvO6JDOGZF0JsvvVPZTrj2V/Wx57enitDR6eWJTTUutfeeVoze2PBGaUiI/fOkMyzb9r+z3Nj6apfOaBJc+HCfHXqDz2iVclCYMfduraPwd+12Y+R3SmR9J5/XWnkM7pHNoJJ3JkttxHdI5rsfaM1l6cEmHdC6JpFP5g95pT+hbrq99E3BbTROXlLCupbLrBL9u9ni9v6CxAlOvW1Ebiy7/YP3Q8g8vy2AbRqnsAIGzRmXI3wEB/rD+ATn1kJ/0Ud+/rWX/drg1JPqiIN4acmA5esGtIdg+zhseI3hpijKUYR6drQSdGuFqx5dj6t1Y3I/g8i7Qrwm8NfqP3+9H79rt6DLVx25m1UexhESlVP/ASabDuOqJdl/bQznC/1L2nabUff0kc18x93fxRwVGkqjnsFizNPxe93cp9Q/d3zUqeFGruafAbyxDOqOCjsI1zRHXDEdc2zjimuqIa1tHXIOOuBo9ytcsR1zTHXHt5ohrd0dcezji8pTXsCMuT3vc1RGXp957+kLPftzaEZdnP3r6L095LXHENdMRl6e8PG3IM57wlNfOjrgqv7rp/Kqn7HdxxOWp956yH3HE5Sl7zzZ6+ommI65ejVff6IjL4lXLPeAcnXMPaj58TIAO1udP5GK9WvbvoOCvwLy9r0b4jE98h/gbSWuby+QJRolenlzUSSurq9LfnL4ruu0ScfEHWFWqVuU2alS/XRsdU4HG4qEEd04Oa1ME3hr9x+8PpXd5qUDDrbLgx+bwnSRxWXCsf0CAzrwO6cyLpLN3h3T2jqQzt0M6cyPphA63sIsreugktIqCdE7ukM7Jgk6foIOHwtQXx3E1631vmMjTEVDWJ+ryASmD/19vGK932xsmygDlY3faqev+DiOeccWHhwf8Kns3VncMf4N4KTs8zCF63D50nfEfrGMrRakgVnxXS1o9Ww04w3d81HUHqlfmM5BzoUxJgj+Ehm2am1MPZZGId1ME/BzCNUfUM977AvURB9ZjjanR+7zPQBqOOsE/llmV+qK2ooXy4IUz4z3vK8nMg8E/BTzwl5rnQB3VLrbmufQ3eoLjc+h/ErzMM2/Q9BNBn9uHo0Pe16rnEA8GvwFkYEdh1Xo18qPeoQywbt7fCDub2sIfU2FdPIjgD2zTdu5/g/9YoP/3FjzghaqL2/DAMLNzeHhZ8NDZl7rZy3EvcU/sLfDkPSaNVGNNe1k6bB1Mx/5WGtDpl7r3zKE5JdHPUKJ5S5/BpKOxMnpsNvyNRGveSBL11Nh7Gj1uH0/d5ghemqIsz0rb0enwS915g7ZyFlw/obo18S598BpgG6hxdsnTITVzxHeh6ZDBKTrzOqQzL5LO3h3S2TuSztwO6cyNpLNnh3T2FHQYV94U4qrsd53g/wgcO39BEaf3jDN9+FDuqGiP2iRn8O3u0WBZYrbotAjaKEseCE8vyGvogCnSV3eRnF2Q13MmmdfQFx+7cEg4esjZVIeEi00HR+E3SwWx4rtaMrH1WMYjywEEdwr9XWY66PFd7JBmJeLdFAF/NuE6W9Qz3vsC9REH1mONUfXSv28WdUIWEKPB6cNBzLmOuM4TuMwy8chOAUvZNtYyDX+DeClrmeqIj7rlwtquvsXdFGWcx79I0LlI0FG4jnbEdYwTrvQ5q8JV4apwVbg2c1xq7fQ8KsPx08rU7GAe8Vd0/RzrHxOgc3KHdE4WdELr9Pyv0eF3TEfxbO3BsZvlVvT2KazP34A/AspwMWzf7TRNnMli3euy33WCfw7ORhywXX4bUc7WLuZ5EGhYWYG4ZjidTX9mdJwOxinGo+HNsx+M4dZmv1UsETqGZDja9cFR1AfHQJnqA+OnTvD3Qh8cTX2A9fkYubIbRY91ZCAH/hjiz+DfmPGEywiKv7wb3VAeKOd35NBbCPQsu6L0zmh3qHfbKr1De2W9i427Y/WUz96gnnLG5giBC/WAMzZWfyDRfWD4+BbaM0Sfx+o596vBnx3Zr07+RPYryor7VWXW1DgU0gPsL5MJX9eQ/s7LRCIu7OuYfj1C4Od+vTTQr2pDBfLJ/Wrwb4rsV5NlN/oVZRXTrwjP/arGb+xXk0kzaR0n5xAu5aNDGVbVr9gH7KMN/rpAv6osd8gPG/xbesAPo6xi+lWtBMT2K/th7NcFVBbaqzhZPvpm0ecc87NfyONPya3DxT1eiz47h41tRP2E6tbo3TY5uAxP+m4U3rHIrbl5l4uzyA3+PULkykyRH+WirD0dHjWOXhTgo8ZHlKMXPGqsXGrRo8ZFh8UuqGr6nJLDRk3UTwhXTbzDMqWquD5oqqq2Q+II/T7auogqxDMF5flU5G/w6oIqhDd8fEHVg4FRKBQFpw9766UCHiNj3iaLbVhKZVjv9Bw6ODqi5+fR0eCfiBwdjXY3RkeUEY+Ol0JZn4BneV8m4C8FGM4qXQZlbNIo46VEp53rYP1Xeqpm3yoan5fkt7fdrIz1C3XiIipTszmlCwbXjUwJtod1IWRL6cOyCekOyqaZtNcTtMuLiE7IL6VPSBcwu2DZsEHAjXRGkqhnH6OjVp8NN/ZngT67EnmyRw3V9q5BvJQdqvuIHrePh2rWyfRpirIT4TeWIZ26oKNwTXfEtcQR10xHXA1HXLs64prmiMtTXjs74vLUr2FHXFMdcXnqxKAjrpojrhmOuDx1YhtHXJ46MeSIy9Ovetq2p672ql/11AlP/+VpQ5464SmvpiMuT3nNcsTlqauefFXj9qaTl2e86umjPWOAwx1xefqvXtUJTz/Rq+OQ5xzGs41vcMRV+dXXh//y7McTHHF5yqtXfU6vxoVbO+LytEfPsdazH3s1Xl3co3x5+tURR1yefqJXfbQnXyOOuHrVT3jG5FvCvNZz3N62R/nynNd69uOIIy7POYxn3tcTl6dOsA3Vsr8RZn/4vR+UI7x9KKfDteKreC3WcCDu/pK4a4QvSSbymRD+IUHP+GrklI0k4efOT/32U4u//6Xv1qi+8cLveH/CgIBXa9omK/ywUAFZXaH2cBhtK0Md6acylIvxkP77wuhE/gZK8hcjP8TfFPB8Ki22L2YkrXZkcpqsU1KKztwO6cwVdBhX3ge0rsp+1wn+ycwvqPtC1L6luYI/g2+3b8n4Ce1bUqerajn/Gh1+x3JDHuYRnYsc6ajTMWo/XKd0cL/T0UTnUkc6uHeKTzNe5kgH9+vtSXQud6RzOcAcTHSucKRzBcCMQr307yuhTH2Mbbngw3zx1fC+gC+ux7QD8TeIl4L0xvZ3XU30uH28v2uF4KUpyt4Cv7EM6awQdBSuAx1xWd8OJ619zXt7rxR0rgzQOT2SzvwO6cwXdIZEvU5tRMnG6FztSAdtZj7RWeFIB/Vge6JzjSOdawBmf6JzruAhjQe+Mnv8ffrfSijro7rpw3voDf66vcbr/XmG03QQfQXyiPUxHlsu2sH0vk5zluuhTgF/NCE3lRCudrL7BsluOZTFyM7gl4Dsvkmyw3axba+Csqup7AYoW0Flq6EMcWBZAm3Ad6xzWN/ghkQ9Hq/WwPsC/dUfYxuIv5G0trnMeLWG6GHb04fnbm8rR69u9G4S9FQ/TE+0TJG+4TIbU372eipD37iaytCf3UBlaN/7wW/EmdcmvokM+WP9Rv7OpzKM6fnMA8bhfN4GY+dLqQzbzPGttbmf8KSPzVPrBPtz+Djxf2W/lb9hP75c4LaylaIsxf+GnSe2BX0KyhHL0qdPvAuNoQan6JzUIZ2TBB3GVU9a55bpw37X4HfNnLnZD/qyAja7wuR/A7xkf1fS/6yI9Xd5vhf5Ur4wJu9V/90NX/j1635yVtExIuQ7TxLwHfpOmfcy2irvtZrKMPdkPKi8V8mx64oY+SH+poBfCHBF+kLhOs8JF/vcTnEtLYnLcnsY+3B8o86U4bjEY9D5Ab6ub4PrHMKF9dmHrWqDi3OH14s2clzCcP0CN9MeSlrbxr6spJ+MzjUY/oZoQ5nYTclWjTXsx7FuU5Sxzt8g6Nwg6ChcSx1xcb7UI4+pdJh9kbKtpQGesf5SKrtI0OE5c/ob52NHb6/5Qb3H+TbHBQZ/DMzHjtt+YvuRdii25JxO0VvzTo+ks6hDOosEnW7nvzmns8qRDvqmRUTnBkc6aG+c01ntSAfHRZ4LLBU8pDp7DtnBGihTdmnzjTrBf2PP8XrnB+wAecT6GGup3BTTW0rxeMk4UOZ0DFc72V1KssO5nZId+xCD/02Q3ZsK+BCMLVdRGcrjBiq7CcoQB5Yl0AZ8xzqH9Q1uSNQz+Vp/3QLvu5HTMfyNpLXNZeKCW4getj19eF5yazl6Yzmd2wQ91Q+Y00GZIn3DxTkd9LPXUBn6xpuoDP3Z26gM7ZtzOte0aRPH04q/UC58U8Wc15SjF4w5sX1lY87j4TeWIZ2icaIHLs7PbYpYaH6HdOYLOq+XWIjXt7aUWOjBgrEQj+cGfzmM549MQiz0ZA/EQk87xUILQXbPkOyQNts2yoljIYxROBZCWfF6o5Ul0AZ8F1pTZblhPR6vSsYm0bGQ4W8kHenH2HilYkQ1XnUY643FQrcKeqofMBZCmaq4KBQLcX4BfSPHO+jP8nKx6W+OhZa2aVMoFuI9YJi7SP++Esp5Tclg9wc7+9XMztQeswuSiWWo41cC3c+SraJcOH9ZNHbA+jcQPx5jk1rrXkg8F81RY31eE71B0OExnf3rF7fX/KB/xXiA/avB7wD9/rvUZ0ib/STyzDFa0f48PZLOog7pLBJ0uh3TcIzWrZiG81VrHOngeMkx2tsc6eA4xDHa9YKH1/bRkB3cBGUqX8/5KoP///YYr/fNgB0gj1gfY7RVoh1M7x8oRis5JsoYzXC1k90/kexWQZmSHfsQg/8QyO67BXwIjsmrqQzlsYbKMJeBOLAsgTbgO9Y5rG9wQ6Keydf66zZ4340YzfA3ktY2l4nRYvNH1r7by9Ebi9E+IOipfsAYDWWK9A0Xx2ihvAf6xlupDP3ZLVSG9s0x2g1t2sQxmtL9Lu73iM5XGf5G0irHMrqlYiE1DvPYhHVV33C+Su0FUTlXhWuVI67QfjKOhdS+tasDdE6PpDO/QzrzBZ1u75PeVPmqbsVcHAt1K+aKjYV22mH8Pfqy2PHc4N8I4/muGU4Vj/Na0dsAXyLg98+ht2dGo8P8h4yFeA0qT3Z7k+xugLIY2Rn87iC7uQHZsW3juMP5qtg4iWNTtUaF70LxN8eQWI/Hq5KxSXQsZPgbSWuby4xXsfmjDmO9sVjodkFP9QPGQmq9DnFxLIR+lvdVo2/keAf9Ga/roX1zLLSqTZs4FlJ7xhgXni1XOSeed5yQ2Vdqa6PZb2XnRjuF+z2Cq+KwiXVV378dfmMZ0omNnVY44qrisHE6/K5IHNat+IjjsNdbTiovN7uMYgmVkwrlZg3+t3cfr3dVIJaIyUmF4jCDv5bisG7mpPJk9+aIOCwkO4P/CMju+gJxWJWTGucT3yH+KieVn5MKxWG9kJNS/DGu2DjM4G8nv1EybpJ+g88mVfHaxLqsP+mzEOC4rGiMdY0jripeG6fD76p4zYdOmXjtead47RSIOV6chHjtEz0Qr73iFK/tC7L7NMkOaYfuKuB4Te1rV7Ecj4NF82ZYf0vLm6nxanPNm4XWEDkmU+ccYuI1j7xZbI6LaebFdRdSucF/GfJrv095M3V2P4U7d8eJcFW8NrHu5pRf4zsZEDfHa0Xvtzpd8KzozO+QznxBp9v3NHG8dr0jHbT51/s6Z17M8b2Idc5QzGHwv7/beL0fTsI6508mcZ0zT3b/7hSvvQyy+8+A7Ni2cWxk/1Ktc258qnXO/HgtdH8U+kavdc7r27SJ4zXkL3TXkL0LxWEGPyOLqQaTVvvq1G/wvjQ+S4B0S96lER2vGf4G8VJW/1XfqTsl1DlKvtMM47yFAMdlobhQzRevccQViqOqeG0inVC81q17NTle61ZcyPFat842xMZrB+84/h59cdGzKmfuNl7vsAxnaK8t04vdo2/w88jvlry7S/pdvFuMfd2Ee2lIdmqPfugcpcEfCrI7jmSHtNm2UU7XUBmOqRzLee69xfosNzUX6fDca3S8ZvgbSUf6MTZeqfOlaBccr5WcP4zFa7F3WGC8pu4GRVyheI3PUaJv5LOS6M9C5+U4XlvRpk0cryndVzkuPFPJOS41Lg2KNhboo+FYHTT8jaRV3mV0UN3Jocbr9PtXe2W/1665duW1a24+Zfmas9ZesfLaKxctv3n1guuvOmvZjWuuXbZywVVX3bh89WpkGgnhR8ywHB+Gsd/ni/eI4/o2jWFlwM6KuWQPcfGFfeqSPcN1QxtcfGGfGtz47/6klc+zsn+nROBBQ8vj61ziSy2+hJw8Kuc7CZe6xDLkGBHXLxIudZkx/92ftPLJ8grhyXOgyNe7iK+8Q+jpf7e2wXUj4cq73Cf977Y2uN5NuNQknP/uT1r5ZHmF8KT/3d6Gr/cQX3mbb9L/PtAG15sJl9q8Y7juaIPrOsKF9bEu/t2ftPLJ8grhSf+7sw1fa4mvO6DsTirDemcTnaKTNKw/WZO0s4nOnY507gSY7aFe+vddUIa+NXSIyQb/u+F9NxImhr9BvBSkNzb43030uH2cMLlH8NIUZZzkuEfQuUfQUbiud8R1F7Un9yIgmoSVvcxmx93G6z1CkzCU0Z3URhXHqMtIa9SuAQGP+OoE/2TG01av/venoxt/Kxu5PocXHk9DiY7BpNW+umEjht/rQuC7iB63j23kbsFLU5Rx0kLZ4t2CjsK12hEXX7SXZyMfdbKR+m7j9V7qQRv5lIONYAwVYyOdXB6J+IwffIf4vWxExbIhG7lL8NIUZbyxXtniXYKOwnWLI65YG/m8k418f2S83m930UZM3rE2YvC/52AjGDfH2EgnyTDEZ/zgO8TvZSPq0rSQjdwieGmKMpwzYRnSCS2OI67bHXHF2sjXnGzkqyPj9b7egzbyzYI2onjvxtxL5a8Ohd95MlK62xT1eWF1haDTTke+u6PmR+lI+tvm77yw/sWR8XrfC+hILyysHtchneMEndfLRrjjiM5NjnRwXOGF1Vsc6aCv5IXVPDuo7TT+Pv3vVihTdmD5ojrBLx8Zr1fPcCo7yMtZ4sJq6ILasTgzo9HhxiO5sGq42sluKsmu7Dhz6sh4veGA7Ni2MaZnH4/yuInKcEzmvK/Kr+I71jmsb3BDop7J1/oL85bdWFg1/I2ktc1lYq3Yg5/WvjvL0RtbWFVzCdUPuLCKMkX6hiu0sMqX9aNvvJ3K0J/dRmVo3zGX9WObQhvhilzWP9mbzDq9rL9dvMhx/E2CF9U374XfWIZ0Qh/iQFwrHHHdkf2uNpm1vuvFQwFbSiy0oEAslD48nhv8d3cdr3fiJMRCp/VALLTIKRb6A5DdGVUsFHo2m1jojnL0xmIhtYZdJBZSa9qvh1ioT/CHcGh7Kp+UiHe1AD2mMUXUfR/xjWWXEI2iOaBLBL9dzOv2xdrX5pLX5TX0TnKxMTFPhxsYo+PxydjAeAm8c9pE2xfqh+sD9Equ5U0xeqG9XUgv9acDSWsftvsQCtLA/sqz+bL7KW9qgyu0n5LXAW9pg4v3U+ZtXMayh7P4JfXDt+40Ecb2At4BMLdnv9mmUA6v7SUhuNCHgEoeAIy2PcPv9SEg1Q95H+bZKgnrCPZR3j5TdWlWjM6GPqyj+Cnap2pTeQr3aADuBgGnaKV/qw+Lcyz+RIYjlfPfjU5sI9ZfBb+xLH36xLvQ4QyDU3RO75DO6ZF05ndIZ76gMyTq1XL+NTr8juko2YQOYZalgzrGuYFrHOmg3XBuoFu5Ds4NrBA8pDbzSZrfqkPvarzgQ+9vgfntL9H8Fu2Axzq8WC8R8Pvn0PsM5Qa6ebFenux+nWSnDqCFZGfwZ4Hs/ldAdmzb6kP36swAH05TH/mrUVkCbQgdQFOXQWwpB9BCFzxtDgfQ1FinfCMfQEN/xgfQ0L5jPuQXOoCmxvL0cNUu2e/xw1WLlt98wbKV1161bM21q64/Z/lb1y5fvaYOmNXIwR6ePbFJBPHwU6O/p1DZ+VR+loDDJzSadnjFQXTka/gbSWsvlLEcdaJLRRl8VQ/WVVdVvB9+YxnSCX12EHFd7YjL9GZY4K6u8pxIpxc+gdOtKwA21Seb86KVH1O0gsd2Y6IVg//xLuP1fkLRCo4avNN+BeBLBDxHegb/nxTplcy6yUiPV9/R16Hs/itCdujT8mT3ZyC7/yHZIW22bZQT+xd17Y+asSMOLEuS8Oq8iggmYddCdKQ3GbsW1NU4HV59MRbpqchS9QNGeihTdRI3dJXn+VSmrrFQ/mwFlRX9ZDO2KSbSM906V9CxsuVQdhGVrRRtTu3uDTtPpI2fiz6V2mFl2A58xzZyquBH0bk0+12nNh6U8TaYtNpcAd06bojoGA7EfXVJ3LF2mRc3IF8NUVaP4OU/Zo0e8C/P/vipGtU3XvjdFMCPuozwpwr4Dseco4eARkK0rQzHw6uprB/KjIc0a/nC6ET+Sq4MHR0jP2X7WMafoiwaayKui0rimpFM1Cu0HbM/9COXZb+HklabZjspaYPR8y3D30haZVBm/FK+V/ks9hFYtynK+CreSwWdSwUdhetcR1w2Bqh+5vnWuYLOuQE6pwueFZ35HdKZL+gMiXq1nH+NDr9jOko2k51Zv9SRDuoBz7cuc6RzGcDwfCtvznDmzuPv0W/FzhkMfi3MGc4JxC7II9bH8eUi0Q6mdyHFICXHFjnf4t0VebK7mGR3EZTFyM7gLwLZXRqQHdu2ut5KzbcupTKMEzinVHS+hfW3tPmWGuOtfavK0Rubb6l8ZJH5lropiudb6GcvojI1j1b+jGMutG+eb13Upk0831L8VbFQXCyUPgsBjsuKxi9XOuIKxShVLDSRThULlaNTJha63ykW+s+dx+s9OAmx0GM9EAs94RQLfQNk9zTJDmmzbaOcOBZSOR0VJ/G8vuipJKw/CTt0o2Ohydihq8YrjxOB6X+rBL28HbNKpiouCsVCnHtWuwGVP7uaykKx0Plt2hSKhXjdHfPGDMt2ZrC/BHb2lzvn07qc+MDbM66gslj75Bs41DoVwl9FbTD4X8/4TnON/ziqcU5JtI4aDyr3ae0YBLpWVkB/v5Dy9ZnRcTqoL+mDeVPUlyQJx1QGf7mAR53j2PByKON4Tukjxhemj0pexmM35IU8xMhLrYHFyovt/nIoW064VPyLMgzJy3jshryQhxh5qT0usfIyGSh5rSRc7eY4iwnecA8k2ifwrmmD/yr4BL6VJ+TjzxO40TfWCAe2Yx/RjiEqw7op3j/fduPvycrzcKx5PfDCuoB4+cadv4dx499JNmqcDq1vqRxHaCcpjuM3ROC6KEBb7Z26IUAb+eI9Mrw3R8Ubyg+YbDr0A/3KD2C+iv2A6id14ikkK9VPas2d98bF5pz4ZoXYnBOetPj3nDkJtiPPZ7M94HyG5zpqnhDSPRU/ox2z7qkcq7J/9htqX42yJfYb2LfsN8ruhK9nOe5u7oRn/a4nWr/zdrjvAHn4rXbROPsL4tw6w5Pa6B+PbvwdWm/v0BfUlS9Ae2dfEPLB6VPUb7LdhvavqnVzlCnHBCajAQGP+Hhv3rbQB6GYILS7PJQDD837zB5Suc/L+Gi3B3In0j11m0NoD6TBHwP6vGv229NvXEZlao9WaMxReqZ27+MYyvXMD3S47zw6l8L7zkuu8wT3nat1ng795lguRZ2cUf2AuZR2pzfNV022X0M5xfg1tdak9hCyPaOPYD+g9ryqtRimhz4CY/F5ZPvKR8bGLJi/vp9yPGhfbP9o42z/qO8cN6AMOW5Qn4xDH4RjNsKfAD7sfJKN0uVQHKv2sKpPb6vTaW+LwHVNgLY6Lf+2AG31eXrmJUnybVLZosmmG/MNjAvYFlU/qXMqIVmpfmoSPMqmqO3yCTEc39muUbfxJOr5OeM2tkPleNudTt+Jxu7NJVfwJrDdG3Pi6SSpcgUJ1atyBa222+1cAeunV67g4ipXUDhX8J7NIFfwKPi29zvlCm6vcgVjZZsqV7CuR3IFvxyZK3jcKVfwa6DPT1W5gtBT5QqIXpUr2DS5gl/uUq7gzM00V/Ab4MP+pMoVtNDOs8kqV1DMdj1yBX/SpVzB4zR2I998Xl/ZlLJ5Pq9/vZAF919ersDw1gn+r8B2f0CyCX09On2K2g/PmZT9hHCF9hjdIuBvCtBGvrCusmV1hr6L46i0XbRPtt2Qz0yfGFmpfmoSPMpGnUPifW84DvEtUTgOsc2jbuO4y/qp9jbFjru41+i/cm5xz8PL8lRnlNCOedxQOZTQGTFl/+w31K1tStfZb1h/oq4iPOcKDP5nlCsoeeOqzBXcQjzivRVKv3luZfAz4ea8n+f4tv6COKdkONvlCqwfuxFTo72zLwj54Nf4J/h2fpPtFvtmKeGKvcGN7Wwg0TFE3g2t06APOFeA/ojjDPRHnANRtyUqf4S5goMzPniuk/7GXME2u05st8rro89h3TP4w0Cft8t+e/qN1VSGfgBx5I05Ss+aoj6OoVzP/ID5lZI3JUbnCvgW+05vco69xb5DvzmWK7hV0Mu7OVrJVN1kHsoVdNOvhdZD2smV5+7YRrZn9BHsB9BHsP+4IUBPze/QR4R8ZOx8A2OWH9P9YCrHqmyc7R/1neMGlCHHDbcALyrmwTEb4Y8GH7aEZKN0ORTH3ibg8TZ+XodBXb8tAlcoT3G7gL8tQFt9JYd5SZJ8m1S2aLLpxnwD4wK2RdVP6gsaIVmpfmoSPMqmqO3eQmU4vrNdo27fBG1ekjNuYztUvlLFAzjmb0Njd2g93eMW57yxOy/PZ3g59r0QbPc6ko3yz+oGZPYfCK++vBear4dwhdbHQvqraCNfWJdpM59WT9muyaYbtus5P1CyUv3UTFrtmm0w9kZptk+0o9CN0jjusn6qta3YcRfXlflW99C+i/RheYbyrEr31A3qyv5DuTX2G6ij7DfUVzbZzlBXEZ5zBQb/9qwvLP4s+SUfmSvgr9dhPkPpN8+tDP4+8G3vyPFt/QVxvisyV2D92I2YGu2dfUHIB6dPUb/Jdot9E7MXTH1dhu1sINE5S9zzgvB3BnIF6I84r4n+KHTDPe+dQpvBXMFLlCtA28VcwQOkeyqvjz6Hdc/gXwF9fojiDQ+/wXlLlTMKjTmhr+aqdQGlz+YHOpxLR+cKDH8jaW1zmVyBsj813+nQb47lCtQcR/UD5grUXARxhXIF3fRrofWQdnLluTu2ke0ZfQT7AfQR7D9C+xhULgx9RMhHxsYsuOb5ScoVoH2F1sXY/lHfQ3NrjhvUF4XVnIu/8Pur4MO+RLJRuhyKY9vN1zn3qebrIVyhPMUHBPztAdrIF9Zl2nk2qWzRZNON+QbGBWyLoRxN+sTISvVTk+BRNkVt91Yqw/Gd7Rp1G3NgX8oZt7EdOG6z7eblDx8I5Pl5roC6wOPzbaJNVna7aBP3B9ouyg7HAYT/U7DdfyLZ3JGMPzE6ob6EfAfAsJ9CnbgzAldoT9BdAv7OAG3kC+sybebT6inbNdl0w3bR3th2VT8hfIysVD81CR5lY2Vqn42ywQ9QWeyXqW+HNrN+qvX/vDt52B5wTxB/HV75wpDutRuzWPfUmKXsn/0G2j/7DdRR9hvYt+w3+IvjDM+5AoP/CeUKUEc6zRXcRTzeATwo/ea5lcFvPbLx37SP/yPHt/UXxPnTyFyB9WM3Ymq0d/YFIR+cPkX9Jtst9g3ndFTeAWXKuQKT0YCAR3x1gu8f2fivyhWgP7qDeEd/xDGIyh0rf4S5gjkjG38PJa22i7mCoZGJ7Uafxv4ifVj3DH6/kfF6zey3p9+4hcrQD3BsrcYcpWdqrQjHUK5nfsD8CupiN3IFhr+RtLa5TK5A2R+OD5wrKOk3x3IFdwt6qh8wV4AyRfqGK5Qr6KZfQznF+DWE57k7tpHtGX0E+wH0Eew/bgrQQx+Bsbj5iJCPjI1ZcH6+gHIFaF9s/2jjbP+o7xw3oAw5brgLeFExD47ZCH/oyHi9k0Ym4lS6HIpj7xHwdwPMbdQe1PV7InDdHqB9r4C/J0Ab+cK6TDvPJpUtmmy6Md/AuIBtUfUTwsfISvVTk+BRNkVt9y4qw/Gd7Rp1+05oM+tnKM5PH7bd2wSvGA9sbrmCM0fG610xMhGn8s+hXEHR+Tr6sLsicIXmayH9VbSRL6zLtJlPq9dLuQLVTyEfq2Sl+qmZtNo12+Bk5gpYP71yBVNf57mCmDEfdRXhOVdg8DeMbPzX4k/UkU5zBXcTj5jPiJnXG/ztIxv/Tft49YjGGZsrMPi3ZXg2Za4A7Z19QcgHp09Rv8l2i32zqXIF7x3Z+G+7XAHnNb1zBc+NbPzdLldwx8jEdpfNFbwwMl7v7ux3N3MF6Ac4V6DGHKVnKleAYyjXMz/Q4Vw6Oldg+BtJa5vL5AqU/YVyBSX95liuQM1xVD9grkDNRRBXL+YK2smV5+4qp1l0vsH+o0yuwHxEyEeWyRXUnHIFqO8cN6AMOW64G3hRMQ+O2Qj/8sh4vS+MTMSpdDkUx3rM10O4QrmC+wT8vQHayBfWZdp5NjnZuQKMC9gWQzma9ImRleqnJsGjbIra7t1UhuM72zXqNubAvjAysR1euQKOB9TZBuUTasQvwofmJ+32job2Gt1KZWqvPtNBn4B9sjb7zXuN/mBk47/tYmqj3aG+D3d7H027+SCfnUHfzXteUMZ4HonHBjzj8t0ds4YmE3WD/T3SQ17VPJl1byAHnveTGfxfjWz8F2P2kD6Hzn8V1WdsQ6f6jLZxHbXV4P9uZLytk6DP0za1PrPOoj5zTkjpcy1p9WGd5HO+1oP6/y8jG//dEvT/P0fG29qL+q/mEiH9b5cjYf3H+G1T6P/nC+j/XQGaSv+tbXn6j/lEhG/stvFfpf9KviH9b7dGGNL/e6gM663IoYP6j/3O+m/w06GtIf032t3Qf5QR639o3pQ+Rec6vCaA8XtI/3m91kv/P1pA/0Oxt9J/a2ue/hs+zpePBPRf2eAqeNfpWhe24W4qw3orcujkxfOs/wa/T6T+G+1u6L/n/LVdnoHjebSNkP7zOoeX/j9I+o9n3EN3OMacY1dnVfh8oTqzqc708ZnN+buN11u820ScKkYK3ZHoMecN4QrZZyi+VrSRL6zLtJlPq9fF81/93T7XqmSl+qlJ8CgbZVt8xj32XEnorjw8L8b6qc64x9ounnE/eseJeNe0wVv0Dle+g0bd4arsP3QnRMw5dqXr7DdwvS8R8PtDOcIvzfrC1jdQRwroulyLvo14xHP4Sr957c7gbwDfdlmOb+sviPPyDE+7cdbprpp6t++qaec32W7V2bQa/Y241PoN29lAoue6fC+Lwb8Z+iC0Fn0L8a7ua1L+iM/coc3gWvR9GR98Rjf9jWvRN5Lulb2LcR3o89rst6ff4Puw0A/wXdNqzFF61hT1cQzleuYHOjwDHr0WbfgbSWuby6xFK/tT53Q79Jtja9EqT6j6Adei1RlaxBVai+6mXwvd49NOrrw2jG1ke0YfEbp7h/3H9QF66CMwFr+PbL/d/Tkcs6wS7UjxHkzzjdC97UXPsas9cxw3jJ0hSnTMg2M2wj8OPuzjJBuly6E49gMCHvPgfH8Q6voHInCFztffIeA/EKCtzu0wL0mSb5PKFk023ZhvYFzAtthuTTZGVqqfmgSPsilqu7y+rc6xK9vF/PvHc8bt9FHjNtuuukcd44FhQT80drN9qlhJ2TXfT6PWGNDP5N1P8Stgu79HslFxZCf3U/CcSe3fDeEK3cXXzm8wbeU3mJckyR9bX8/3U/CcP3Q/Bdpu6B4pzjGou1PU3Uk4p2P9bPdNsdC4i3fL/PsOE/F63wPJuqfiZmX/7Ddix/XQXSzsNzg+ZHjOFRj8V7O+sPgTdaTTXAGP43jmRuk3z60M/nvg2/4yx7f1F8T5jQxPu1yB0zhe7/Y43s5vst1i38R8qwhlyrkCk9FAovMUfP+ywX8b+iCUKygSL6j8nfJHmCvYeveNvzmfm/7GXMEPSPfK5qmm7T5e78cZTk+/EYqted+qGnOUnqm9gTiGcj3zA+ZXUBe7kSsw/I2ktc1lcgWxc/cO/eZYrkDF4aofMFeAMlX394RyBd30a6EcaDu58twd28j2HMonoo9g/7E6QA99BMbi5iNCPjI2ZsH5xveymCW0/6joOVmOG9R8jseNvD1NOGYj/Dbgw/Yh2XjfqcX78NX50xCuUI693Rnd0D1D1Z1aup+K3qkVsl3OMeD4znaNuo37y1k/263Jsu2qNWaMB1Su4OpkYlnRfICyeY7TVOy7SvDKse8hYLsnkmy883wx8/UQrtB8rV2ej2lXeb6J8KqfYvJ8V0MZ5wpi7ZNtHnUbx13WT69cwSuUK1A+IaR77fbTsO7FniFhv1E0H6B0nf2G9SfqKsJzrsDgz8n6wuLPkvdIyVzBHcQj5jOUfuedCb4GfNv5Ob6tvyDOizI8k7R/u/BZ0JAPTp+ifpPtVo3xNfobcakzYGxnA4nOWeadF7gS+iD0nT3Oa6I/4hyIuttd+SPMFdxOuQK0XcwVXEe6p/L66HNY9wz+TtDnt2S/Pf0G73FSOaPQmKP0TK3z4hjK9cwPdDiXjs4VGP5G0trmMrkCZX9qvtOh3xzLFcTev4e5AjUXQVyhXEE3/VpoPaSdXHnuru58UT4itIbB/iN0Vz/6CIzFbyfbVz4yNmbB/QrPU64A7Yvtv2g+QM2tOW64A3hRMQ+O2Qj/APiwDSQbpcuhOLbdfJ3XYdR8PYSrk3NPTLvInVrKJrt434Scb3jeudvuTi2O/0N3asXaLt95p/IBynYxB7YhZ9zGdqh8pYoHcMy/jsbuzSVX8Amw3c9XuYIW2sxnlSuYWDaZuYLPdylX8OYqV1A4V/CHm0Gu4B/At/2JU67gz6pcwVjZpsoVfLNHcgVT9tj4u12u4J+ccgX9e4zX+26VKwg9Va6A6FW5gk2TKzAfEfKRZXIFyzbTXMEQ+LBdSTZVriDfJqtcQTHb9cgVsH565Qr+qUCuAHkLzSM6PYNwPcDknUGYC7Z7LMlG7TPs5AxCaP9jt88ghPZeVWcQwnf7hc4ghHIFOM55nEFg/VS5AnWmcChptQfMFezd5TMIoXtHQmcQ2G+E8g+TfQbh9KwvOozpu3oG4XLwbUtyfFvRMwhnZXiqMwib7gzCJdAHoVwB5zlU7ryTMwjvolxB3hmEK0j3yp5BeC/o8/Lst6ffqM4gVGcQXkOe/ft6PYOAPoL9APoIjzMI7yLbVz4yNmbBMwg7Bc4ghHKFofW6yTiDcAf4sKdINtUZhHybrM4gFLNdjzMIT+WM29iOMmcQrqCxW61hTva+AnU+k2Pf58F2P0Oy8d5XEDNfD+FaFaDdbn2MaVf7CibCq36K2VeAOTHej+C9r4D1c5VoR+y4uwrw/tP2E/EqnxDSvXb7CkJ3koT2FbDf6KV9Bf+bcgW9uK/gG+DbvpTj24ruK/iDyFxBta+gVaZe+wq+FsgVoD/q9r6Cn0buK/ibnPWJovsK/hv0+VsUb3j4jWpfQbWv4DXk2b+v130F6i6zbu0r+GnEvoLYmAX3FXwjczDKxtn+e2lfQX3P8Xrb7TkRZ7WvIN8mq30FxWzXY18B66fXvgKOB2LvO60RvwiPPoTlr3xOaL+CioXUOmfM9xWwbedm//Laz+6ZnNvF1N1ci/f8dkC7+SDftavWa5S+G812995+kcaGGsCdQbzWklZea6JtzZz6Chf2y/7wez8oR/iFWf9bfILyLNCvS4agTgI4EHdJnVmCbbVHxZMYOyl66dMQZfUIXn573ucXffi/DptWo/rGC79jvewX8GcIeJPVAPE+kkQ9i5TtGm0r47ZjGdqf8ZDa7AujE/nrL8lfjPwQf1PAnwVwRfpiRjJRF1DfzV6vgbKLqCz0zQzlm0M5Z/Zv6LeXAgyv2Rv86RDLXRYxVmL83I1v04RwXROg3W6PG9NWc1nmJUnyY4Au3hnfX3QNtl1MEyMr1U9qzZZzSRdB2TVUFtrXob59E9qDpvTzGtGOpfCOY7mlgtcU79OUO1axWUj32sVmrHuxsRn7jdD9uUVzR2xnqKsIz7ljg38zjfclcy4yd8x7Tm8FHork2t4Lvu36HN9WNH/31smNcwvnWEI+OH2K+k2229DeA/U9KTW3YjsbSHSMzd9yM/h3Qh9w7hj9Ec8t1fkO5Y84fkebwdzxMxkfQ0mr7WLu+P2ke2qOhT6Hdc/gPwz6fHv229NvcF4J/QCvE6gxR+lZU9THMZTrmR8wv1Jy31d07tjwN5LWNpfJHSv7U/PMDv3mWO44NleNuWO1Fo64Qrnjbvq10Py9nVw5l6vWUpWPYD8Q2ht/Q4Ae+giMxZ8h22/3zb1QzLIG8D5I+QG0L7b/2H2mMTlnHjeUD+MxG+E/Cj7scyQbpcuhOLbdumdoLeyOCFyh/FC7PW5MW+1xY16SJN8mu7iO09/t9WklK9VPTYJH2RS1Xc4Px+accd3ncznjNrZDfZtLxQM45r+fxu7NJVfwv8F2/7LKFbTQZj6rXMHEssnMFfxll3IFl1a5gsK5gm9vBrmC/wbf9s9OuYLvV7mCsbJNlSv4fz2SK9hxr42/2+UKfu6UK9hlr/F6U7LfVa5APlWugOhVuYJNkyswHxHykWVyBedsprmCvcCHzSPZVLmCfJuscgXFbNcjV8D66ZUr4HhgqcB7jcBbS1r9UMw+M7WPDeVhtNQZOY4JsN5FOXRUDiJ9eJ+ZwS/M5Nwupjba3dB3lBHru/LZCM/yDn1rGWWi9jnyWS2UsdE0nq8ROFPej6axYTnAXZlMLFsJZVdTGe5xXkFlqCPIB/YT6sG5AGN46wR/HowNK8j2lA6vhHfcB6E+Q36UXsfMa5YHaLfrf6at7sNgXhLBJ+qD0bIyk003bAX9D9tKyNekT4ysVD8pW+G47kooW05lobuTVkAZn7FE3caziayfy0U7zoV3PDacK3h97fzA7Il4rxd4Q7oXOnupdG+laJ+yf/YbaP/sN0LfhMe+Zb+B8/1EwHMuyuDXZn1h8xvUkU5zUXy+YjXwoPSb5+4Gfzf4trfn+Lb+gjjfETluWj92Y842meMm2y32zUrCtVLgUvM3trOBRMdIhq9O8LdDH3AuCv0R7y1Hf8Rj/gpBV/kjzEV9lHJRaLuYi7qXdA99moolWfcM/iXQ5wcoF+XhNzgmRT+AOPLGHKVnap7AMRXWMz9gfgV1sRu5KMPfSFrbXCYXpexPnZfv0G+O5aLU/Ej1A+aiUKZqvhTKRXXTr6GcYvyaOhekzjixPaOPYD+APoL9x4oAPfQRGIt/lGxf+cjYmGUl4P1KFrMoG2f7D93VivrOcQPKkOMGvKtJxTw4ZiP8L4EP+98Rc/1u30sZwtXtey6YlyTJt8nJnptjXMC22C4nEyMr1U/qDBivhcXabui77GzXqNuY7/3fOeM2tqPMHSv30tg9CnAHJxPLToeyPZOJ/Jwt+EH4eQRvvmQgB97w1Qn+j0S8NZy0+qe9c+ghf/iOYwSsf24OLvQ32L435fD+5yJeN5znCf72FvwZ/PkC/jyAMX6UbM5PNG1sz9kAcx21x+D/KnL+kRV16humKd+AcmPfEJJR+rBMLxLwKCuTicrNcZ7iYCg7j8rQdk4nHkYFD/PgHds16p3VTeWwy7Ybf1v/nwZwvWjX34+062Nz6CF/IbvG+kXt+s05vP9rQbs+VvDXS3b9n5F2bTpV2XV7uz5N8BBr11Y3lcPUbSfivQzKlM5yHxv8YDa4KJ29PGnlFWXI8r1CwF8OMKyzl0HZFVSG9c6nsiugbCnxYLEYygHh2XYNfjrI4R9HN/5Wun559rtDXR9Sun4lALCuL4eyPgHPfXG1gMf1H5OJilMvI1yXCVzY15xDuzz7eyDRfWD46gS/I/QB59DQTq8k3pcW5D3W3tCm/mzWxt+mg+gbTiOaSwM0uW7636XZ3wM58IavTvB7CXmxr8tbg11COA1+TsAfXJq0tut0eMc6qGR/qWiXkullVIZ9bLqg7NPgujEWYfvZPkNtTR+WzeUCHnXX+r+ZtPrDi6gMbeNSoqPGvFj9Rx36/KyJeC+FMsN7BNRdlv1mnT06oF9KhjjGF5Wh8TOctMrmcirDeudR2eVQxrZrfg3lgPBXZb/rBH9C5HgzNk4DHisroM8LlD6jD2d9xrFF+Xzui9D4hDJpErzSWeVnLod3PN6YjAYS3QeGj2OfJYHxBmNtHisvKsj7EYL3oaTVZtCm9qbxBm2cx5uLAjS5LvrIgRx4w1cn+AsD4835wDvHiunv7QinwS8N+AM1ji6Ad6yDSvZLRbuUTC+lMuTddEHZp8F1aJ8nKPvE9rN9htqaPkXHYuv/ZtLqD8+nMrQNjr/VnCxW/1GHZs7SePPGm1/IfrN+rQzol7IbzHOwDJU+op7weIP6FYp1TqcylCnnJtS4i/CcczT4NZHjjZM+z9zU8RPvrbscytgfKp1Ve7FZbwYS3QeGj2PrdwfGG8wTXEq8n1uQ9zL29m8zN/42HcT8EI835wZocl30F3njDe8HNfg7A+PN2cA75/vUeGPw9wT8gcrRLYB3RXN0vMcK5cI5DeTddEHZp8F1aJ+zNnWujccb9Iech0PbOI/oqLx0rP6jDn1r5kS8nKdDXKgXIX1EuxnIfrM+PhPQx5CdpQ/LXOkv6pXxo/SR5zzIe0gfnXK/Fyh9xPazPobamj5FbdX6U82pQ/rI47PK7y6Ad6yPqEeY3/3KzIlwuAZYy/61vTP7wPsCMp9SI3zGM75D/A3ipSC9sf1I+xA9bp/13dRX/8vEkKxdc+3Ka9fcvHjVsqsWLrth9dqVy6cg6qR1xQqlgljxXS2Z2Hos66N3dYI7mf5eLOolAncf0J0DZUoShtOsEts0J6ceyiIR76YI+H0I1z6invHeF6iPOLAea0yN3qPX3E7QrhP8b4DX/MvRfLrbJUmLHLajv68V9LpodTO2DKubTlgNBmHxmQ6cIXyd/uYeXSLq8WMSqxPPv581P9W+38t+W8/Phrr7JxPLdgDcZyXjOH5OOPYkHtS/yDu+4/HLw1Pw+mT68Lg/B+qdE8HDHMFzU9Q3uCFRr6xsmgGejQ56E9z//Bd7JxPaNhfKlCfi9VODX7TPeL2/ynCaLNFijUcl5wuSibwUlfMFgk635XwB0ZnrSGcuwGwPv9P/DiRcLGfrJ5PzAVB2INU7CMoQDke5A+H9QYK2wm842ung9/bWbcvTQaNVJ/iDQQd/SDqoRlMefZMkrPOslwM58HsTfwb/k8A8fjvRZuSL1ykN/j8C86btRLuUrwy1C3Vqu5x2/Vcgn6OiEDW27EdlO0CZ+XAcW+qEY0oGNJi09keBKEGeecrjG+GM7p7l6EbPQQx/I2mVYZloaE+ix+0rFw2h9FkqiBXf1ZKJrceydnOQM+jvMnMQ5QVmC5zmUVRcz/XYCvndFAG/J+FSFsTeWdVHHFiPNUbVS/8eEHViLKBkfN4XawGG38sC2vW76aq1fR/BS1OUYQYIy5DOPoKOwrUD4dohkufUarMFJLPac9esunF5ZrYJPe0mHXvmsDFF1E+oLps2B/azRZPQdBbn0M4bhA1fneB3zeSKg1WofvrEqD12UTccv+H3UvtYFeJJHNYNDfK1pLUPJ0lV0+eMHDbUiJIQrpp4lz4qluyjepOlxgcKNW4Knqx+Gjt9c/pE2u3ibJ7rGfxhQJtjTjU3CJ3bOFjA43zE+BkmHrDusKjH80zcpzyXeDgsaZUDwvNeWYM/BuQQWks2vrqxV/YwAOC1AVwj6RPw3BdHCnhcJzKZNAme+wX/RlzY12wHJqOBRPeB4asT/MkBO8B5+mHE+9yCvCsbVvNatKnv0RwUafJQekCAptJZo5PnN/LmyGcJedWIBtoB8sVzUIM/N+APQnmK9GEdVP7jQNEuJdODqAxzEpgPMtyMsxt7ZbH9bJ+htqZPWV+pzmbMpTK0Ddb/uYJOrP6jDnFuEb872gf/Ml6Dt+9rDiR67dne1Qn+atDHr44mE9qNYdpd1A7+3mn6WHh3D9EdSaKe6PDO8DeIl4L0xsK7e4get6/cvJ6jHZQKYsV3tWRi67GsXRR3Iv1dZl5/L5QpSfC8Htt0b0491lx+N0XA30O47hH17HdfoD7iwHrMG1sRevW7BG22opvAinhtEeniV4GZF/v7YEHPrO5egk0fs7r7qN5IEvVcFGt1hr9BvJS1uvuIHrevnNWhpiCVCwmrwSAsPhcCZwjP03zuvUtFPX5MYnXi+QHIyb83+z2ctGrsjsS3+haz8l9NUd/gFJ2dOqSzk6Bjmozj+/5UNiDaamW3Qtn2VHYb8HIWld0u2mVlHwjgvCOA805RlrZr2zkT4dAb1XL+TZ8+8Y5leo/g1foOPQCnFpS13Regg/UNbkjU67Q9imeOMbCtqXyf2ieZ0Lb7oUyNBnx20OAfGB2v9yGyt/uhvvGo5My2WFTOOwo63ZYz29QDjnQeABheh32QcLGc+fzeOih7kOo9BGUIhxHBg/D+IUFb4Tcc7XTwlX102/J00GjVCX7t6Hi9T5fUwQeoDPuAx0PjA+WA8HwW1vgcyIHPa9dnA7mGe0R9xfs+xMsDAd7TJ7QqYHDd1vl9iE6e/vwW6c86KFP6c3n2u07wvzA6Xu93SH8wQutG+0N2jZEczxqU3bEsVT200X0jeHhQ8NwU9Q1uSNTrVDcUz+10409JNx6CMqUby7LfdYI/ZXS83ldJN9B/Go9KzhwDFpXzToJOt+XM8d3DjnQeBhge3x4lXCxn6yeT8yNQ9ijVewzKEA7Ht0fh/WOCtsIfO759ex/dtjwdNFp1gt9/dLzePwfmNCEdfJjKUKboe7mvQ31QI74HcuAfpnYZ/I8DuWFlr6g3lxNOg/9JIDdsdLFdarYc0sVHRLuUTB9N2tNGOS/OoT2Q6Pbn6cp/BWRq9ftz2nM54TT4/wnIVMkoJFNlY4+Kdg0nrW1+jHCpTBvKOUam2P57qf1j9jpnvP0chz0g6qvYgWNIFYch/OUEr2xMxSZsY1MDvN8j6qvcAu+Vw9zC/VSGuQWei90GZeuoDHMLnOfA3AKPf/jNl4eoDL9jgrpvuYU6tXV29r7DHLzc03cP8dYP8LWcf5MkbjzFvqoTnW7lTZjOvY50EJdl5NWcjdc0i+YNsH5objjQIZ0BQYdxoU/GmMjsqU7w+4Jdf2d0Is77BX8D8G5xoK1sz4jL+szsA31fN9aoDH+DeClIrxbyudg+3oK0TvDSFGV5fYp09hR0ivI1NaOfPlkW/8TlV6xdsXjVioQeXtg6KYfFHQlucQ5rNYG3Rv/x+x3pXZ+ARdyTZXqbks5eHdLZS9DpdqpzL6KTN905cU4yoW3tUsp8ZYbB7zA6Xu+UDKea7uSZHeqauc/0Yd02ennL/bfm8LcYXK8t99eoDrb5TQGe7wcaTDf9vX8OD2dTqFLSFctQhVOhyE8/lWHogX2DZUkyLgt8xzp3t6DDuPKGSZMrh3QXFRwmQwv1yNP9VIZDE8tB0VHuXckhRGfvDunsLeiEhv2yvkTxrKYS6EuWky95AMpUSMNbxQx+cHS83jUBX4I88t/KL+eNk3m+5L4c/t4S8CUcGmI7Fc84BWS6ypcY/I3kS3gpaCSJe5Qv4aUJ5Ie3GBYdC7H+ZI2Fc4lOt5f9VLqf/YtajloXoKOW1NrZ43vmaJrKHnlcQ/g/fuN4vfdHjO0xS3Xd9r2MK3YMMvi7Hceg+yL4qyetNpX+ngNtzsOViHcGj+Mfpy8eINj7A7B5fiv9fWX2u9v2dXz2W9nXAcRfUfvC+rH29WRB+7o6+8329f+BfX2Q7AuXA1iuvASAsMcT7EPQ7li8/VQ3fc4i2AcJL+rkxcnE9o6N73PH8T9HW4YeIvzq3/SJ0R1M7bPuYIr6QPiNZUaH3zEdrG9wbAusOy/N0TRRd7Au647B/+uc8XqvzMlvI6dZPeRs7x+B90yXlyAfJVhM5XOa+BGqq/5tx2NT0HmU8D4W4J+X6R8S9bq93Poo0XnUkQ7iWkp08nT3C6S7j0GZ0t2V2e86wf8e6O4XSXexPusu+lTeQqnSfyn+/edO5PlxgDM5XSLqGvwTBI840ofnFk9mf+fNLaxuneC/LOYW1rbHBL20bX80R7cN+wOX4Z4g2gb/feiPr1B/oLysP4aTVtmwDTwJvDDs8Tky+Drw8bU5+bTYLlQbUxzfmJMPd7yAYxxThAwMh/ILVm9Y0GPbfZxoPBag8aiop2iwP0aZPQn0TTeealP+pGhbIt5NEfCP57Q3EbSfaIP3MYFH+fcnqOxhUca+C9urtmIpn4h+7wsBe8mzCaVXjwd4f5J4f1zw/liAdyU/9B+huMH+jhnra+Jv4+8aeMc+Vi31I4zV5aX+/wzkY9T2HeTr6hycPwOcvH1C6cyB8I6XikL9hPwMJ/l2rnhHX8LvQrFMInhAX6h0Ni+OY3koHtT2G+U3efuNisNjbRPj6Ze20DnG9LmaZtE5xkdgfjprbn4bN4c5BufMe2GOcT/hqeYYr65fku6WnWO8A3R3Dulu7ByDt1K1m2NYmcl3iqjHxweM3tmQGzmI8A0ALdSb9DkL4FAX66J++pvXFQz+sIxmOu7939GNv4dF/SOIHq7rqLUe1okjBF957VRjGMvtjIzvQWpPLSm0HrIgpP+G+7GSuGPsR9m8mj80RFk9gpfr/2PZYcsGbvkS25Xxwu9iYhl1zbrJiufNI0nUc9wQ0EiItpWhbj9GZZj3Nh5SnX5hdCJ/j5fkL0Z+iL8pyt4Cv4v0hcK1zhHX/SVxzUgm6ijaofL3nLtReea0H1eR30Y/dBjxWtQPYf0ifojXbQx2JfkhPl43kkQ9h4fiE8P9aEncsX4oLyZAvhqiLMYPXfOzBTf81jl/unMtafW3feJdzJZ0dW1Rh3Z+sPJD7GvQDz1KZeiHjAflh0qOKQfHyA/xq1wS+6HYvlC41jniur8kLvNDobUF9EMc36kjtuiHeD3rbRCzvXXuRFyhXLWK3zjGVGUPCpwp7dty4s+x2BLKeD1QzdHtb3yHuo51eB3d4N8FsnkH8Ydr2dhO5E/1F+6xec/cfLiHAnCh+F6tg4di/9h+4bHiDhoreC/kSBL3qD08hivdfvyG7He2/fiU5WvOvWbZjcuvOnf5lTcuX9MHmJA7xmR/W6uxHj/GCe88vpP+5h1r6+jvBwWedjTVDpND4DfTjdlhcojgeVPSObJDOkcKOt3eRXgk0cGREWf+j9HMX+0ixN0p9hED9sovHjde78lABMlyRiucl0zkpehuN6x/X0XHnc7RHdI5WtDp9m7Eo6k9aCMst6J2jfXvn2Q67ez6V+ZqmrF2bfCXgF1/JmDXebv2sY1FD1ixT8rDdQ7hwvqhS0vui6ATuvjjvkg6Me0J0dmU7TFcaocf9sF5Ab54lvJgG1znEi51kYfSQea5aHYC6w8E6KzrkM66SDqT1Z67O6RzdySdeR3SmSfoDIl6nY4fiud2/vZvyN+qi5rQ3/JpDIM/Dfztt8jf4ozn9S7nbq0a88V7ef35/YjV3FB/Gvwh0J8/iuhPJZu8XZFIN9TX6uKcmsAV2rnNckB4NaZ0MaMa/ZlCXr0puUo1djg6dPlN+uAh5G2y31kWYMHy1YccOu/EV1MAN9+wJi+7Oh2JJhNX1hE+ob+5Xsobf+pkQNBIH9afhwiO+93eM/4YntrBtitXvu6RnHYmSZyvw/oDObjyTrNY/3CmaUp2A5c6zaJiMnUhSygeUCvyCNcn2rB1Tr0bE82ftRl5Um0eu4Ag0OZ1bdrM8buKHdk3MVyfaMNg0qoDiEPJ+JhkIu9F9QnrT9bYeQzRyRvTtt03mdA2dYIG667OfvMJml1gTJud4VQn1Car/Ry/quu1VwNM3tymnoOTd28Y/G5Z2ztcfZQZZV5B6Rf8p+/2oD5VbQ/1qcFPhz7dO6JPQ/ahLmsO+YL7A/BqrqhyTKG40fqHd8iOJDFP7W9jdBTxN4iXgvowFm+oC9GwfWXjDcP7TWgQ8t8u3uB6oXiDYfNsj2OAB+l9u3hD8ZQH20m88VBOO5MkbnzA+gZn+lnyAxMjxst9wIfawZx38ndK0mpbCl7FGGqXBvuieqLH4e2hHOGPhljiB6Mbf6u+ODaHvySJ6wusP1lj1bFE525HOurWGZVfPRd+Y5nRyfOxTVE/tF7wUId0HhJ0YnX9rdnvdjHRYho/Q3lypMt58s8fO17vTBo/kfeYPJwad7n9RT+SELLrWDtV+fXTCFfRtQ2sHzqtr3jPu/nneorLSt78c5baHWL212HMd1aMjSN+tevB+GqIsphdYd9tHPt//u8vPfVHNapvvPC7mNzRaQK+s/grWaJ2heGOlfRBHXmQytB+jQe1K6xkvLYkRn6IvynK8DRQkb5oirLFJXHZTi41x95UPikv92L+iWOHNYE8hPJNOP4sDrT1fqp3v+A9fdjnpM9Iop+f02P4TP5bCVp8ia3BvgPa/ePRibw+IHg1H9EXoJGId7UkXzZMY4qouyaZyNu6CN5UPghx3J3DZ4pDrSGy3ha9veQ+wY+ic3KHdE4WdEJjEv9rdPhdaD3yZKKTFzfdS3FTaL0r/b02+83rXS9D3PQAxU1Yn9dcefce+oT0YR9o9fNuCGB/YvCPgF3xaVeVH14LOPP0LPaUkME/OQl5Jm5TPWn1relzWk6b8vLFLAOlJ9sH4NV6E667sc8OXapvbXv2gHEe1u9brP2n5+B8Zv9xnM8VxLkoB+ev7DuO84WAbYwmE+mhfJTM2P6xPu/AxXqmN4NJq+4W0MPoy40NfyNpbXOZfJrKDyi5WNtvFbw0RVnMPo1RQadGuNrx5Xi5sbG4HcEtzmGtJvDW6D9+vx29Uyk5xJ02+Y0Hbvxtan47wFxE+G8HHH3iHas51jc4RWd2h3RmCzohXBcJXAb/AQE/W8A7qoaxuBPAsJdm1hhvO9Vg3HmqYU8f0Ux/30/1uWuYx2GBoz/Qpj7xjru6X9BSdJZ2SGepoMNRwl9RlID0C3jLD5j3uwNesucvman+QKzn589bID3jS32WOSbrse9v/OKHj9njmjNrVN944XdskmoWuVTAd5h9ulVlPXD3b/qozJjKehgPKutxf0n+YuSH+FWWmrMeRTMI6h7Qorgs64GfSQnZ8mT5jG7QCeFSmRCDN9kMJHqliH2Swf8jzJ7s0zp9Sb68E/FuStLqj2zIHBa4jsrhXdE2/OnTFPUNros+sb+oT2wkrW0uEw0r+1ByUef0rC7vUE+fswAuz1+GVgR6HRfq5lDSqr+1nH+NDr9jOXusCHqeLuOznp3gUlmyg+A3lhkufsf9gvXXUdkHBB01Dt1BZSi3xVSm7lRQfoj9d1E/1C/4U+dpMSs3dT9NM++OZF7NNPh5kM0Y3i+/jTE7qRA+L8M1K6MxGTup8mS3bQHZpc951BaD3xFkNzsgOx77VSZc7RTnk2Z5n6jGsiQJ7yBSmeCY+8U6XNmLHvu8d1aprKLyMR3eb1Q3eqFPtiK96YmWqbrrzGxM+Tr2Z+jreBUSx7W8zySnv/eD33n+DNvEmVnF32T5TUXnnA7pnCPohOLEGF1XdBTP7XzZUeTL1Goq1r0u+83Z6Qb4sqPJl2F95JH/jplfGL281Zn7cvh7Y8aTWp1Rbb4uwDPSSJJWu+Gxy+BPpLGr5Hxajl182ledku6QbnQ23vA3iJeyPrjdajymNmdmv7PU5uJVy65auOyG1WtXLuebK/P2ONYIK76rJRNbj2V99O5WgjuV/l4s6iUCN2Y81ZmQ0L4EtVavZuV3C7q8Nq/OXYf2OBjvfYH6iCNvv0hfTr3071tEHc97AjxnNF3cIzYr1jINf4N4KWuZar+Qio44MsS6ag8nLiZhGdIJRaeI63YnXOlzVoWrwlXhqnBtAlyhPWU8C0sfPiuJfpDPZhVduMb6oQXykzukc7KgMyTqlR2TmwGeVbaF5VY0A6nOlrbbP3f/fppm3v45nqEZ/E/3G6/34H4TeVYzNJQBzoCwHwwH1x0EHqysQHwxnM7SPjM6ToflyjP/UByS/ra9dmo/Ne/XQV2I7aMPUh+p/X6hPY4G//fQR8/SLFqt0jK9pA09tsOBHHje42jwz8Ms2lbpFH/35dDLyyr8Qg69jwI9+9qH0juj3aHezVJ6h34mJuOk/FnIX6BtsS6iDvPKrNq7F9rXavUHEt0Hhq9O8L8s+jxWz7lfDf7XIvvVZNmNfkVZxaygq/OBIT1QK/QqU3cb4bpN4FL7WGNt2fCxbf1WoF+tPvYr8sn9avC/E9mveJ7V8FhZp/2KsuJ+VfGH2j8Z0gMcH0wmKrN+J5WhT2S+lP9GPYjpc+yfPP/9J6LPVQY/5ux+3r7TWdnvLAN37ppVNy7PUnAJPaGUWfr3/TlszBT1E6pbo3czqUy5z9AmIaM9kOiUFbtPg/8LIfKQ+02fmC3V2N3dSOIafq8t1e3cGqeKQmYWmspsAlVNn1Nz2KiJ+gnhqol3SaK3OSNejgJD3k2JSu3VQnjDx+vW3wmMHGokDN0SpiJ3tcan2s83PGK9mNMkqEY8ohn8DyNHNKeZjxzRUEY8cqjMQugkrlrPVtnSJsGj7NWIlnc6COmoKEbNrDCq5JlVuxtBY04eI6+sX2pfg9pbEZoFG1w3ZsHYHtaFUN+mT97tLgiP/c1RK+4t4MwT2hLf5qBmPbG6gNmO+3PWqhFvaAZ0P+BSQzjPyg1+Wragq745+UCbtsXMANWpW7WCxydIsR7uKzDcCcF1qI/TPLMy6VPUVtn/oJ7x3nEcCziLg2MIrv0fNcl7sHj8VjeHqvGObw7dHfZeHLH/RJzKxkN9oPYfqZsPh5NWf/FoBK47ArTVrZmPBmgjX3nfOk0En/jtK6NlZSabDm2lX9kK+me2lZAvTp8YWal+ahI8yqbofjD+RmzsfjD83gvrp4oXlQ9Xtov7Lrcl20X7ZFkXzdqr8Yhj4uNgjODbJNrtrV2bg3M0MO60G1Nj4uzQ7eLo+zjOVllJ5fvYLyp/rfwI+0X1zUyE5/1WBr8oK+jwFmG53yrvm8h4GwWOZ7wH2OCXge8+Y3+Ns78gzrOF3nTR19W77evajUm8TxX7Jm+/IeJSe1HZzgYSPV8yfLzadin0AWfa0N+yT0V/yz71fkE3dNYglfu7sz84Xkt/4wrWlaR7ar6MPod1z+DfB/p8dfbb02/wLUPqG7RsP0kS1jO1Ksjf8lbfd+5wz3f0nnb+pmPJPfTB20JVzqBDvzm2p13FKqofcE+72seOuMxXTbZfC+Vi2smVzwdhG9me0UewH4iJyRS9vJjs3V2KyaZSTIb2xfaPNs72r24OVXMAjhseBV5UzMO3vhj8neDDnibZKF0O5VjUd5nV94GHk1ZdfzwCVyjX94SAfzxAG/nCukw7zyaVLZpsujGfwriAbTE0l0yfGFmpfmoSPMqmqO3yPAzHd7Zr1O1HoM1P54zb2A4ct9l21ReTMB4w3bgN4M5LJtJUSzv4jsdZrG9wis7sDunMFnRCuM4TuAxera10+XoVY3EPgEnfbx9gjfHW6D9+z7j7BCw+qpv6c/hOkrhuUpsVGJe58PTB41T3EV+Yhj6fcBXdfIj1eSnM+PoiTTGRfgH39lDoeLjhLnmM/6Ea4UsSHWbmHU1DvtSVAjFXqfz6i2dP+9Pfmjd2FUjsETqDV6n+8wV8h1epPKCGML4uRR1ZLnqVSskrIB6IkR/iV+lwvkql6HFGLCt7NNKuUsGhkjcSd9vH8NT1SyKFN9m82HD8h4F0YrtNTLzxG3kPbdaO2Sx1e2S7QnQu6JDOBYJOtzeFX0B0cMqDaZS/onDsA1CmUr9vzn7zpst74eLJv6FQTG2+ryV6/MExMn3YXnlTKMPcl8Pf34N+8nFa1eY3B3jGFFqStPoFTu+ObUOhsbekT5XpXb5WrAvX+UTvxNpU1/kUO07L25NRKogV39WSia3Hsj56xxuuTqa/F4t6icCNEa76zMQdAmfoSnM1+ha5pArxqk0JfDlfaLRHHGpRz3Coeunf14o6nhcVTNbRXLPMksdboz8byZ9VKBl1jllmaHNI+nDb1SceVDKbZ1VlPxmQ/n7IEdf9TrjS56wKV4WrwtVzuNQM9AEqw/GAPw+vjjXUqAz5C828sH4o8XhOh3TOEXSGRL2yY18zwLPaOMhyU9dv3B+gg/X5ohmc9eFM6KADNE2cFWBdngkZ/LtgJnToARN5VjMhlIE6Q9DFY2ZygyTKlWfYavMo9psd5Q0d0VG6ENtHx1EftTvOx0eLDX4F9NFo9jvmWGhokzjSYzvMO7DAx54M/qSMp3bHVu/Ioadm7+mzJIfeaUBvEo6tzlB6h34mJrOj/FnIX6gzOGohi4/BhY4+9gs6oQ3d6hhc6EirwZ8v9IHHItaNPP6U3JyPwd2dw8Z0UT+hujV6Nz0Hl+FJ3+H0NeYYnDrpyi7iUiHyUJelT3UMbrM7BndyDhs1UT8hXDXxLknaH4PjUSUkYiUq5UVCOXqDXylUOuRhVYQVigRUbj50DFBFPXfk0MERDeXFI5rBr44c0ZwiKTmioYzYM8dmTgy+3XZoNrXQMRQ1s4k1w9hjcBypKX0JHYNrd+yI9Sv22FEoqn69HDsy/DHHjnA44iuWVRQVqws4e+KZVbvLKvLWaNEH4BCedxxhnfABhvPuNm2L8Xcq6x26SlxdFxw6lmlwHerjkNJHbH/MLC/02Zh2tsr+B/WMt5HiWMBhZDu9CW3zxDW+v6L1SaRzOtEs+tmW0wX/is7sDunMFnRCuE4XuEL93eWtYsbijgCTvt8+wBrjrdF//J5x9wlYfFQ33Z7Dd5LEdZNSZ0Wnv0M6/ZF0zu6QztmCDm8F+d3M7Xa43Pz+mAWzkicL3l8jfEmiZ1N5pyqQL3XKIWaL2Q+a5//Oyp985GM1qm+88LuY0/BnC/gOT0W8Rw1NfCJVnXRTW8yMB7XFrOSplPfEyA/xq5sieItZ0ZM4WLa4JC7bYhY6Xd9tn8FbzP4AQijeYrYp/Nc5HdI5R9BRIVEt51+jw++YjuK53Vasr+VMmfK2YnFy2+Cfhu9Of52S2+omgVqi/XT6r7qrnfnDrVgIc18Of98EneKtWPeJNl8X4Bm/Gc9009/75/DwDzRGldx4Ibdi8fQT+eFUjtrQo74UoBa27gvQubBDOhcKOp6bYZoBnkPjflk66FPN5tQpz4vhN5YZHX7HdLD+ugCd2zukc7ugo9JCOGVSJwJNZh3GU/WYfkH8DeKlIL3g147Ugr+1/RHBS+i2oBqVIZ1HBB2F61ZHXDE3FV0scBWVl+NUz1i8gODOy2GtT+Ct0X/8/gJ6lzfVM9yTdVX2ZJl+u3XzaQdqmnnr5nkfYr7qoPF602mFA/naitpYdMc81g/tzOchEDNrnHVTV4LXqAz5C50oUSsWfYKOcr9q+Hy9f+iIh3Ssq4bomEswthJ0ivLl6OaMxf0ILu9Ot5rA287N7Ufv8tyc/T1Zqq/oLOiQzoJIOpPVnvs6pHOfoBPCtUDgqtR7Am7VTQM5fCdJXDepqyE25QiCSYl2o/wxNMqrzwSGRnmDv+nA8XrHw2/e04C47kkmlqEc7yX+cf2eR8CS55GjR0DD3yBeyo6AsTvTip1N4ikDSgWx4ruQpfAuGN6gNED1ypxNUqtztwmcKo77QE49lEUi3k0R8LcTrttFPeO9L1AfcWA91pgavUdru0vQ5r2XZ2dWlcYz3xgdh8+jhfJot7+QYZiHsf2FwAOn5PAmAdUutma+EQA9wfE59K8DL3PxgZp+Iuhz+9B7DuTwezvxYPCXgQx4w5/y/EnOO5QB1s37m8/LYVv6qIx18S6Cv7NN27n/Df6qQP/fKnhAv7C4DQ8M05fDwzWCB+E1F6664eacvX4ca7CX417inrhV4Ml7rCUpDdNelg5bB9Oxv5UGpC3fJvs9FrqtXL4mb58jjwj9OTSnJPoZSjRv6bOptq7eWo5ecOsqtq/s1tU8K21Hp8Otq3mDtnIWXD+hujXxLslovD3bcr0p1y9u75COShIxrryw+Krsd53g3wMOireT3Qd8MM704WRnaPus4UH4dlusWJZqO2SIdmid78GCvIZyzEhfJUcfLsjrOZPM632C1y6uq0S7zk21rlJsWpN3f3yNsOK7WjKx9VjGHpKnCqfQ32WmNbF3ZKq7Hx/Jqceaze+mCPiHCVfe/dN9OfRUj2I91hhVL/37ZlEnZAExGpw+eSt1HrgeFbjMMvHOxAKWsm2sZRr+BvFS1jJj74m0tj8ueGmKMk45qLs7Hxd0FK6HHHHd74Qrfc6qcFW4KlwVrs0clzrkxXfz4vjJV1SgT+3GVQuKzskd0jlZ0FFXFpSNFZoBntVd1yw39c2HRwN0sP6j1B7c5Tjhsr4DNU2cyWJd3iFq8OcfNF7vbw7MbyPK2drFPA8CDSsrENfIb8ZhjMM7i9vdT85fTsdYgg8bYV/jneChPvgO9YG6JiTmG23HQx/8X+oDrI+7v/LsRtFjHRnIgb+f+DP4H4l0uOLvwRx6KA+U8zty6P1EZFdCl9t2qHfbdvt+9nZ6yttf1D33hkvtckc94IyN+gYM9kHeyZ2fiz6P1XPuV4OfctA4zlC/OvmTbYteaaMya6GD70oP1Lf1mklrn+dlIhFX6JPOql/VFY/cr9OgD7hf1SYB5JP71eCnR/arybIb/Ro6xKr6NXSIVY3f2K8mk2bSOk7eRrja7c+J6VfsA/bRBr9joF9Vljvkhw1+l8h+7aYfRlnF9KtaCYjtV/bD2K98FRCOdWzLk+Wj9xV9zjE/+4U8/vL2jDleBfRwDhvbiPoJ1a3Ru21ycBme9B2mVVnk1tyBRKdAWeQGf4gQuTJTtVdLHSrbVLt9Sx7EDe72VS616G7fosNiF1Q1fU7JYaMm6ieEqybeYVm76yZCV2ngCH0MzRRQhXimoDyfivwN3iLQvOjC8NUJfmFgFApFwenD3rrdF6D4bCi24Qkqw3oP5tDB0RE9P4+OBn965OhotLsxOqKMeHR8Esr6BDzL+ykB/yTAcFbpKShjk0YZP0F02rkO1n+lp2r2raLx0LVC7WZlrF/q62bDol4oU2Jw3ciUYHtYF0K2lD4sm5DuoGyaSXs9Qbvkr8KF/FL6hHQBswt/Rb5QXXlVozKkGboYGOvz14SRzu0d0rld0GFcsftUDP4twkcZTrUKHNofEfryLfKjZIN3RDDtWs6/Roff5d23gH3luXIciqhDq8pl6aCfeYjoPOZIJ89nsW/olI5aWVbjV6d00D/dR3SedKSDvu4BqMdjoroN9GnBh00BPgjvC4wF0eetDX+DeClIb2wK8EGix+3jKcCHBC9NUfYW+I1lSOdDgo7CdYcjLuvb4aS1r48iOiqWeipA56hIOvM7pDNf0BkS9Tq1ESUbo/NBRzpoM/OJzocc6aAebE90nnGk8wzA7E908r5+/vxB4+/T/56FMs5ypQ9//dzgj4O7Yl7McJoOoq9AHrE+xrJPi3YwvU9kNMz/rYc6BfyRvHfFcLWT3Ssku6ehLEZ2Bj8Csvs0yQ7bxbb9YSj7IJVtgLIPUdlzUIY4sCyBNuA71jmsb3BDoh6PV8/D+wL9Ff3leMPfSFrbXGa8ep7oYdvTh+9I+0g5emNfjn9B0FP9MD3RMkX6hstsTPnZ9VSGvvE5KkN/toHK0L73g9+IM69NvAMW+WP9Rv4epjK1c3aY/k5/P0pl6svew6LNHN9am/sJT/rYTps6wX4FVu3/MPut/A378acFbit7VpSl+L972MS2rAf8KEcsS58+8S40hhqconNSh3ROEnQYFx4sxDki+12D/xcaQ9CXFbDZFSb/DfCS/V1J/7Mi1t/l+V7kS/nCmPsl67+74Qu/ft1Pzio6RoR850kCvkPfeYXKmRltdb/kc1SGORHjQd0vWXLsuiJGfoi/KeAXAlyRvlC4znPCxT63U1yPlsRl915i7MPxjcoZ4rgUOoXBfK1vg4s/TIX12Yd9uA0u3nm5XrSxL2ltM8L1C9xMeyhpbRv7spJ+MjrXYPgbog0F6NVCslVjDftxrNsUZazzGwSdDYKOwvWoIy7Ol3rkMZUOLySei+5cxfp5u44RjufM6e8Jl5MdrPlBvcf5NscFY/EgzMemHzyx/Ug7FFtyTqfoXX1HRdJZ1CGdRYJOt/PfnNP5sCMd9E2LiM4GRzpob5zTec6RDo6LPBd4VPCQ6uxeZAfPQ5myy3Ozf+sE/8ox4/XmBOwAecT6GGup3BTTOyCj0WEcKHM6hqud7A4i2eHcTsmOfYjBPwiyO7SAD8HY8sNUhvLYQGUvQBniwLIE2oDvWOewvsENiXomX+uvF+F9gf6KzukY/kbS2uYyccGLRA/bnj48L/loOXpjOZ2PCXqqHzCngzJF+oaLczroZ5+hMvSNL1AZ+rOPUBnaN+d0nmnTJo6nFX+hXPimijmfKUcvGHNi+8rGnPx9AY840QMX5+c2RSw0v0M68wWd10ssxOtbW0ostLxgLMTjucEfBuP5NZMQC72lB2KhVU6x0BtAdjeS7JA22zbKiWMhjFE4FkJZ8XqjlSXQBnwXWlNluWE9Hq9KxibRsZDhbyQd6cfYeKViRDVedRjrjcVCHxX0VD9gLIQyVXFRKBbi/AL6Ro530J/l5WLT3xwLPdqmTaFYiPeAYe4i/Rv3V/CaksH+/OjxOndmdqb2mF2QTCxDHX8K6N5DtopyWQ+/sSxJ4mIHrL+B+PEYm9Ra90LiuWiOGuvzmugGQYfHdPavjx2s+UH/ivEA+1eD/z70+5PUZ0ib/STyzDFa0f48KpLOog7pLBJ0uh3TcIzWrZiG81XPO9LB8ZJjtI840sFxiGO09YKH1/bRkB28AGUqX8/5KoO/D+zg0wE7QB6xPsZoHxbtYHq/RjFayTFRxmiGq53sPkuy+zCUKdmxDzH4t4LsPlfAh+CY/ByVoTyepzLMZSAOLEugDfiOdQ7rG9yQqGfytf76GLzvRoxm+BtJa5vLxGix+SNr38fL0RuL0V4S9FQ/YIyGMkX6hotjtFDeA33jR6kM/dmLVIb2zTHahjZt4hhN6X4X93tE56sMfyNplWMZ3VKxkBqHeWzCuqpvOF+l9oKonKvC9WFHXKH9ZBwLqX1rHwzQOSqSzvwO6cwXdLq9T3pT5au6FXNxLNStmCs2FvohjecfgbKY8dzgZ8J4/i+BeRyvFX0E8CUCfv8cev9BsVDJ/IeMhXgNKk92/0my2wBlMbIz+H+bP17vZwHZsW3juMP5qtg4iWNTtUaF70LxN8eQWI/Hq5KxSXQsZPgbSWuby4xXsfmjDmO9sVjo44Ke6geMhdR6HeLiWAj97AYqQ9/I8Q76M17XQ/vmWOjDbdrEsZDaM8a46vBO5Zx43rHtIRv/TW1tVvZb2bnRTuGeIrgqDptYV/X92+E3liGd2NjpQ464qjhsnA6/KxKHdSs+4jjs9ZaTysvNHn7I+Hv0q7G5WYN/FGKJozKcKpaIyUmF4jCDPzajMRk5qTzZHU+yU3FYSHYGfzPIbkFAdmzbVU5qnE98h/irnFR+TioUh/VCTkrxx7hi4zCDv5j8Rsm4SfoNPptUxWsT67L+pM9CgOOyojHWM464qnhtnA6/q+I1Hzpl4rW3O8VrO0DM8Y5JiNfe0wPx2vuc4rX/njde7zaSHdIO3VXA8Zra165iOR4Hi+bNsP6WljdT49XmmjcLrSFyTKbOOcTEax55s9gcF9PMi+supHKDfxbyax+ivJk6u5/C7X3oRLgqXptYd3PKr1m/qnssOF4rer/VUYJnRWd+h3TmCzrdvqeJ47X1jnTQ5l/v65x5Mcdvkn9T65yhmMPgPwQxx28F4jWvdc7fpXitm+ucebL7klO89l6Q3R8EZMe2jWPjeiqr1jk3PtU6Z368Fro/aj2Uea1zGs68NnG8hvytz8EVG4cZ/D+Q3ygZx0i/YbjUXn/W//Xl6EbHa4bf6yulqu9CXyndIHjhOV76LAQ4LgvFhWq++IwjrlAcVcVrE+mE4rVu3avJ8dp6RzpomxyvbXCko+KcdjFH36Hj79EXFz2rsjvEHAMZztBeW6YXu0ff4KdmNDq8u0v6XcPV7hzlNJKd2qMfOkc5Bg+ym06yQ9ps2yinZ6gMx9T1VOa59xbrs9zUXKTDc6/R8ZrhbyQd6cfYeKXOl6JdcLxWcv4wFq/F3mGB8Zq6GxRxheI1PkeJvpHPSq6HstB5OY7XPtSmTRyvKd1XOS48U8k5LjUuDYo2Fuij4VgdNPyNpFXeZXRQ3cmhxuv0s0d7Zb+zzx6dsnzNWWuvWHntlYuW37x6wfVXnbXsxjXXLlu54Kqrbly+ejUyjYSmwXssx4dh7PfD4j3iWN+mMawM2FnrCdeH2+DiC/uwPjvADW1w8YV9anDjv/uTVj7tsO+UCDxoaHl8nUt8qcWXkJNH5Xwn4VKXWIYcI+L6RcKF9XlxEZNFzCfLK4Qnz4EiX+8ivvIOoaf/fbQNrhsJV97lPul/H2uD692ES03C+e/+pJVPllcIT/rfx9vw9R7iK2/zTfrfS21wvZlwqc07husTbXBdR7iwPtbFv/uTVj5ZXiE86X8vt+FrLfH1CSh7mcqw3jlEp+gkDetP1iTtHKLzsiOdlwFme6iX/v0KlKFvDR1issH/k/C+GwkTw98gXgrSGxv8P0n0uH2cMPmU4KUpyjjJ8SlB51OCjsK13hHXK9Se3IuAaBJW9jKbHxw1Xu8amoShjF6mNq5PWtuoLiOtUbsGBDziqxP8WzKetkpaP+v6sqivcON4Gkp0DCat9tUNGzH8XhcCv0L0uH1sI58UvDRFGSctlC1+UtBRuJ5zxMUX7eXZyDudbORrYCPv7kEbudXBRjCGirGRTi6PRHzGD75D/F42omLZkI28InhpijLeWK9s8RVBR+F60RFXrI085GQjnwcbebSLNmLyjrURg3/KwUYwbo6xkU6SYYjP+MF3iN/LRtSlaSEbeVHw0hRlOGfCMqQTWhxHXB93xBVrIx9zspGPgo18ogdt5NMFbUTx3o25l8pfHQq/82SkdLcp6q+nsg8JOu105HOHan6UjqS/bf7OC+uPgY78ZkBHemFh9bgO6Rwn6LxeNsIdR3RecKSD4wovrL7oSAd9JS+s5tnBn5EdfBTKlB1YvqhO8PPADr4WsIO8nGXsBbUG/w1aWC258UgurBqudrL7G6dxZkeQ3bcK+BCM6ddTGcrjBSrDMZnzviq/iu9Y57C+wQ2JeiZf6y/MW3ZjYdXwN5LWNpeJtWIPflr7Xi5Hb2xhVc0lVD/gwirKFOkbrtDCKl/Wvx7KPk5l6M8+RmVo3zGX9WObQhvhilzWj7x3I443/F6X9a8netw+juNfELyovnkv/MYypBP6EAfi+pAjLltjqDaZtb7rxUMBW0ostM1h4+/Rv8eO5wb/uSPH621HHz/tRiy0U0ZjU8ZCu5DsysZCz4DsdgvIroqFNp9Y6BPl6I3FQmoNu0gspNa0Xw+xUJ/gD+HQ9lQ+KRHvagF6TGOKqPs+4hvLLiEayEdMDugSwW8X87p9sfa1ueR1eQ29k1xsTMzT4QbG6Hh8MjYwXgLvnDbR9oX6YX2AXsm1vClGL7S3C+ml/nQgae3Ddh9CQRrYX3k2X3Y/5QttcIX2U/I64IttcPF+yryNy1i2IotfUj984WETYWwv4CUAc3H2m20K5fDaXhKCC30IqOQBwGjbM/xeHwJS/ZD3YZ6tkrCOYB9tgN95+0RfBLr2Lk9nQx/WUfwU7VO1qTyFuzYAt0HAKVrp3+rD4hyLr8xwpHL+u9GJbcT6H4bfWJY+feJd6HCGwSk6R3VI56hIOvM7pDNf0BkS9Wo5/xodfsd0lGxChzDL0kEd49xAtw66cW5gvSMd9BGcG/iQ4CG1mffT/BZtLTRe8KH3UZjf3k7zW7QD5BHrxx5AM/i7KTfQzYv18mR3L8lOHUALyc7g9wDZPRCQHds2+v5HqQzlwYfTcGzgvXVFD6Bh/S3tANoGeLc5HkBTY53yjXwATX2YU/mgmA/5hQ6gqbE8PVy1S/Z7/HDVouU3X7Bs5bVXLVtz7arrz1n+1rXLV6+pA2Y1crCHX09/49VQeU+N/p5CZQ9T+VkCDp/QaNrhFQfRka/hbyStvVDGcjYQPW4fz/qfE7yoqyreD7+xDOk8J+goXB90xGV6U13l2fqO6fTCJ3A2ONJB29xUn2zOi1a+SNEKHtuNiVYM/otHjNf7XYpWcNTgnfYfAnyJgOdIz+D/gCK9klk3Genx6jv6OpTdH0bIDn1anuxeANn9CckOabNto5zYv6hrf9SMHXFgWZKEV+dVRDAJuxaiIz3D381dC+pqnA6vvhiL9FRkqfoBIz2UqTqJG7rK82EqU9dYhK7QUT4oJtLDNsVEeqZb6wQdK3sayh6hsmeT1jandvddsjv8XPSp1A4rw3bgO7aRUwU/is5j2e86tXHK4Rv/HUxaba6Abh03RHQMB+L+YEncsXaZFzcgXw1RVo/g5T9mjR7wL8/++Kka1Tde+N0UwI+6jPCnCvgOx5yjh4BGQrStDMfDD1JZP5QZD2nW8oXRifyVXBk6OkZ+yvax7Hj4XaQvFK5HSuKakUzUK7Qdsz/0I49nv4eSVptmOylpg9HzLcPfSFplUGb8Ur5X+Sz2EVi3Kcr4Kt7HBJ3HBB2Fa50jLhsDVD/zfGudoLMuQOcowbOiM79DOvMFnSFRr5bzr9Hhd0xHyWayM+uPOdJBPeD51uOOdB4HGJ5v5c0Zdj98/D36rdg5g8GfCnOGvTKcKqZAHrE+ji+PiHYwvX0pBik5tsj5Fu+uyJPd/iS7R6AsRnYGvx/I7qCA7Ni21fVWar71GJVhnMA5paLzLay/pc231Bhv7ftwOXpj860Ngl6R+Za6KYrnW+hnH6EyNY9W/oxjLrRvnm890qZNPN9S/FWxUFwslD4LAY7LisYvTzniCsUoVSw0kU4VC5WjUyYWusIpFvqDw8frLZ+EWOi6HoiFVjrFQq+A7FaR7JA22zbKiWMhldNRcRLP64ueSsL6k7BDNzoWmowdumq88jgRmP73YUEvb8eskinS5/Vy5Wc596x2Ayp/9kEqC8VCD7dpUygW4nV3zBsz7IPQXoS9HezspcPzaT1BfDwIZU9SWax9Ig6UL/oKhL+K2mDw92Z8p7nGfxzVOKckWkfN/6jcp7VjEOhaWQH9/ULK12dGx+mgvqQP5k1RX5IkHFMZ/BMCHnWOY8MnoIzjOaWPGF+YPip5GY/dkBfyECMvtQYWKy+2e5TX04RLxb8ow5C8jMduyAt5iJGX2uMSKy+TgZLXs4Sr3RxnMcEb7oFE+wTeNW3wHwWfwLfyhHz8gwI3+sYa4cB29It2DFEZ1n3tswAHbvw9WXkejjXXAy+sC4iXb9z5VRg3vkSyUeN0aH1rg4AP7SRdD2UbInA9EqCt9k5tCNBGvniPDO/NQT6tnvIDJpsO/UC/8gPrEQDw5vUTwsfISvWTWnPnvXGxOaf1VBabc8KTFl/KmZNgO/J8NtsDzmd4rqPmCSHdC13Rr3RP5ViV/bPfUPtqlC2x38C+Zb/BuUSGz9sJ/zWao3ZjJzzrdz3R+p23w/374Nu+nuPb+gvi/GsYj/54dOPv0Hp7h76grnwB2jv7gpAPTp+ifpPtNrR/Va2bo0w5JjAZDQh4xMd7874TGROEdpeHcuCheZ/ZQyr3qdk6T7s9kD8k3VO3OYT2QI75CFhX+hea43n4jcepTO3RCo05Ss/U7n0cQ7me+YEO951H51IMv9eN7bHrPB6fXE7/e17QU/2AuRSUqTq9ab5qsv0ayinGr6m1JrWHkO0ZfQT7AbXnVa3FMD30EeuhDeYjQj4yNmbB/PUVZP9oX2z/aONs/6jvHDegDDluUJ+MQx+EYzbCbws+bA7JRunyenjHY5faw4r7UvlWG9T1j0TgeiZAW52W/0iANvLFN0DxiXNlk8oWTTbdmG9gXMC2qPpJnVMJyUr1k7oF5iNUFmu7fEIMx3e2a9TtDdBm1s9QnJ8+bLt5p9N/OMl7QrxyBYeC7Z5EsqlyBa18VrmCiWWTmStg/fTKFexf5QoK5wrOzfqil3MF14JvuyDHtxXNFVyc4alyBZsuV3AV9MGmzBV8IDJX8OacmKNoruAu0Ofrs99VrkA+Va6A6FW5gk2TK/hAl3IFu2+muYJ14MOeq3IFLbTzbLLKFRSzXY9cwXNdyhW8mcZu5JvP6yubUja/gcrWJ62y4P7LyxUY3jrBvwy2+wWSTejr0elT1H54zqTsJ4QrtMdI3Yj0QoA28sU3sLMtqzP0XRxHpe2ifbLthnxm+sTISvWTugGXb9pVeS91dwDfEoXjENs86vb6ZLzNrJ9qb1PsuIt7jf4w5xb3PLwsz/UCPnRru8qhhM6IKftnv6FubVO6zn7D+hN1FeE5V2Dwf0S5gpI3rspcAX8hAO+tUPrNcyuD/0fwbV/J8W39BXH+eWSuwPqxGzE12jv7gpAPTp+ifpPtFvuG74yJvcGN7Wwg0TFE3g2tfxvIFaA/4jgD/dF6Ktsg6IbuU3pNb47c+JvnOulvzBV8m3QPfZqKS1n3DH4AboL8Z4o3PPzGc1SGfgBxsE6F9Ezd/IdjKNczP9DhTYnRuQK+xb7Tm5xjb7H3uKk6/U99MTjv5mglU3WTeShX0E2/hnKK8WsIz3N3bCPbM/oI9gPoI9h/bAjQU/M79BEhHxk738CY5Yt0TxHaF9s/2jjbP+o7xw0oQ44bXsQ2Jq0+CMdshJ8GPmyEZKN0ORTHqhv98TZ+XocJfe1X4VofoK2+kvOxAG31lRzmJUnybVLZosmmG/MNjAvYFlU/qS9ohGSl+qlJ8Ciborb7IpXh+M52jbr9ArSZ9XO9aIfKV6p4YD3g/TaN3aH1dBWXFL3FGX0Dtj8vz2d4OfbdF2z3OJKN8s/oL4vGnTxnUvP1EK7Q+lhIfxVt5AvrMm3m0+op2zXZdMN2PecHSlaqn5pJq12zDcbeKM32GXujNI67rJ/tzrKGxl1cV+Zb3UP7LtKH5RnKsyrd2yDap+w/lFtjv4E6yn5DfWWT7Qx1FeE5V2Dwi7K+6PBLPjJXwF+vw3yG0m+eWxn8MvBtZ+T4tv6COM/O8LTLFVg/diOmRntnXxDywelT1G+y3WLfbCBcau1PfV2G7Wwg0TlL3POC8JdCH3CuAP0R5zVjb7jnvVProQxzBe+mXAHaLuYKriTdU3l99Dmsewb/PtDnq7Pfnn5jPZWpnFFozAl9NVetCyh9Nj/Q4Vw6OlfAX30qmZsIfvVJzXc69JtjuQI1x1H9gLmCdl86C+UKuunXQush7eTKc3dsI9sz+gj2A+gj2H+E9jGsh3oYi7+bbF/5yNiYBdc830+5ArSv0LoY2z/qe2huje1DvVE+jMdshL8TfNjTJBuly6E4tt18nXOfar4ewhXKU7wk4D8eoI18YV2mnWeTyhZNNt2Yb2BcwLYYytGkT4ysVD81CR5lU9R2P0pl6quPynYxB/Z0zriN7cBxm203L394JY3d3f4aNM+tXwJeeB2exwGE/wjY7mdJNvZl4iSJ04mXBTx+3Zj9FOrEyxG4QnuCXhHwLwdoI19Yl2kzn1ZP2a7Jphu2i/bGtqv6CeFjZKX6qUnwKBsri/0y9UtUFvtl6o9Dm1k/1fp/3p08bA+4J4i/Dq98YUj32o1ZrHtqzFL2z34D7Z/9Buoo+w3sW/Yb1p+oqwjPuQKD/13KFaCOdJoreIV4/ATwoPSb51YG/9fg2/5Pjm/rL4jzy5G5AuvHbsTUaO/sC0I+OH2K+k22W+wbzumovAPKlHMFJqMBAY/46gT/F4FcAfqjTxDv66GMYxCVO1b+CHMF/0W5ArRdzBV8k3QPfRr7i/Rh3TP4/wF9/juKNzz8xotUhn6AY2s15ig9U2tFOIZyPfMD5ldQF7uRKzD8jaS1zWVyBcr+cHzgXEFJvzmWK/ikoKf6AXMFKFOkb7hCuYJu+jWUU4xfQ3ieu2Mb2Z7RR7AfWA9l7D9eCNBDH4Gx+H9FrJ3Hxiw4P9+GcgVoX2z/aONs/6jvHDegDDlueAV4UTEPjtkT4I8arzf7qIk4lS6H4thPCfhPAszHqD2o65+KwPXxAO1PC/hPBWgjX1iXaefZpLJFk0035hsYF7Atqn5C+BhZqX5qEjzKpqjtvkJlOL6zXaNuvwxtZv0Mxfnpw7b7McErxgObW65gd7DdI0g2yj+HcgVF5+vow16JwBWar4X0V9FGvrAu02Y+rV4v5QpUP4V8rJKV6qdm0mrXbIOTmStg/fTKFfzNoRPxvt5yBTFjPuoqwnOuwOAXZn1h8SfqSKe5gk8Sj5jPiJnXG/zFR238N+3jk4/SOGNzBQZ/WoZnU+YK0N7ZF4R8cPoU9Ztst9g3mypXcB70QShXwHnN9VDmkSu4KeOjXa7gEtK9srmCW0CffyH73c1cAfoBzhWoMUfpmcoV4BjK9cwPdDiXjs4VGP5G0trmMrkCZX+hXEFJvzmWK1BzHNUPmCtQcxHE1Yu5gnZy5bm7ymkWnW+w/yiTK7iJbN8rV/BnWczSaa4A9Z3jBpQhxw2fBF5UzINjNsK/F3zYwyQbpcuhONZjvh7CFcoV/JKA/3SANvKFdZl2nk1Odq4A4wK2xVCOJn1iZKX6qUnwKJuitvtJKsPxne0adRtzYA/njNvYjjK5Ao4H1gu8yifUiF+ED81P2u0dDe01+iiVqb36TAd9AvbJ2uw37zV6JjKmNtod6vtwt/fRtJsPmkxUbMR7XlDGeB6Jx4b1wPvnaGzAXBTvyQjd9cB1sQ8GcuB5P5nBvyxi9pA+r4d3neoztqFTfUbbuI7aavC/Mrn6PG1T6zPrLOoz54SUPteSVh/WST7nYz2o/7+zBen/H/S4/qu5REj/2+VIWP8xftsU+v9QAf1/JUBT6b+1LU//MZ+I8N8I6L+S73p4V3SNMKT/n6IyrPehHDqo/9jvrP8G//eR+m+0u6H/KCPW/9C8KX2KznV4TQDj95D+83qtl/6/s4D+rw/QVPpvbc3Tf8PH+fJ/Dei/ssHQOcaia13Yhk9SGdb7UA6dvHie9d/gfxqp/0a7G/rvOX9tl2cwmai17pD+8zqHl/4vJ/3HM+6hOxxjzrGrsyobqB3qzKY608dnNofmjdfbdd5EnCpGCt2R6DHnDeEK2We7uzGYtrobg3lJBJ9Wr4vnv/q7fa5VyUr1U5PgUTbKtviMe+y5Ej6rgrqN58VYP9UZ91jbxTPu02gt+vk2eIve4cp30Kg7XJX9h+6EiDnHrnSd/QbfgcTw+0M5wh+Q9YWtb6COFNB1uRbNd9XgOXyl37x2Z/ALwbcdnOPb+gviPCzD026cdbqrpt7tu2ra+U22W3U2rUZ/Iy61fsN2NpDouS7fy2Lwx0MfhNai+T4OdV+T8kd85g5tBteil2V88Bnd9DeuRZ9Eulf2LsarQJ9PzX57+o0NVKbuOgiNOUrPmqI+jqFcz/xAh2fAo9eiDX8jaW1zmbXo2PvpOvSbY2vRKk+o+gHXotUZWsQVWovupl8L3ePTTq68NoxtZHtGHxG6e4f9x/oAPfQRGIsvI9tvd38OxyzqG0+v+Q2ab4TubS96jl3tmeO44WPIS9Lqg3DMRvg3gw97F8lG6XIojn1JwGMenO8PUufMQ7hC5+tDZ0UVbXVuh3lJknybVLZosunGfAPjArbFdmuyMbJS/dQkeJRNUdvl9e31UBa6Kw/z7+/KGbexHeqeDRUP4Jh/Eo3dSD80drN9qlhJ2TXywW1kH4R4Oea/A2z3KZKN9/0UPGcqej/FhgDtdn6DaVf3U0yEV/0Ucz+Fuq9F2SfnGNTdKVamxhylnxtEO2LH3Q2A90uHTMTrfQ9k6L5a3isauj8ydlwP3cXCfoPjQ4bnXIHBf5RyBagjneYKeBzHMzdKv3luZfC/Cb7tpRzf1l8Q5yuRuQKncbze7XG8nd9ku8W+iflWEcqUcwUmo4FE5yn4/mWD//XIXEGReEHl75Q/wlzBX1OuAG0XcwVfcMpT/S3o8xcp3vDwG6HYmvetqjFH6ZnaG4hjKNczP2B+BXWxG7kCw99IWttcJlcQO3fv0G+O5QpUHK76AXMFKFOkj+eS02ey/VooB9pOrjx3xzayPYfyieuhjP3HcwF66CMwFv/riPlGbMyC843fzGKW0P6joudkOW5Q8zkeN/L2NOWdk/02+LCfkmy879Tiffjq/GkIVyjHrvYahM4AVHdqTYRX/aTOnPAe81jb5RwDju9s16jbuL/8pxFr52otRMUDOOZ/IZAr4O9eFM0HKJvnOE3Fvuq7Axz71ueP19tu/kSc3nm+mPl6CFdovtYuz8e0qzzfRHjVTzF5PvzuBecKYu2TbR51G8dd1k+vXMH7KFegfEJI99rtp2Hdiz1Dwn6jaD5A6Tr7DetP1FWE51yBwe+V9YXFnyXvkZK5gk8Qj5jPUPqddyb4GPBtc3J8W9FzxvtleCZp/3bhs6AhH5w+Rf0m260a42v0N+JSZ8DYzgYSnbPMOy9wJPRB6Dt7nNdEf8Q5kOcFXeWPMFdwccYHz3XS35grOI50T+X10eew7hn8paDPo9lvT7/Be5xUzig05ig9U+u8OIZyPfMDHc6lo3MFhr+RtLa5TK5A2Z+a73ToN8dyBWqOo/oBcwVqLoK4QrmCbvq10HpIO7ny3B3byPaMPiK0hsH+4/kAPfQRGItfTLavfGRszIL7Fd5OuQK0L7b/ovkANbfmuEHdJ6vuJuL7ZK8EH/Y2ko3S5VAc226+zuswar4ewtXJuafQfSHt7tRSNqls0em+if5u37nb7k4tjv9Dd2rF2i7feafyAcp2MQf2tpxxG9uh8pUqHsAx/zgauzeXXMF7wHYfqnIFLbSZzypXMLFsMnMFD3UpV3B8lSsonCtYvxnkCn4NfNtzTrmCF6pcwVjZpsoVfLpHcgV/Hpkr+KxTruAvQJ8/V+UKQk+VKyB6Va5g0+QK/rxLuYLDN9NcwTfBh/1LlStooZ1nk1WuoJjteuQK/qVLuYLPFsgVIG+heUSnZxDWA0zeGYSfge02j56I0/sMwnpqz2SeQWDa1RmEifChu/1CZxBCuQIc5zzOILB+qlzBenjHtrte8Jri/c+DJ+L1PoPAuhd7BoH9Rij/MNlnEHbO+qLDmL6rZxAOy3hM+3gkx7cVPYOwR4anOoOw6c4gHAh9EMoVcJ5D5c47OYNwdsZHuzMIR5DulT2DcB7o87zst6ffqM4gVGcQXkOe/TvZfm2yziCgj2A/gD7C4wzC2WT7ykeuF3hVzIJnEH6YxSxFc4Wh9brJOINwCfiw60k21RmEfJtUtrglnkGItV2PMwjX54zb2I4yZxCOoLFbrWFO9r6C9YJXjn3fDrZ7N8nGe1/BempP0X0FobsN262PMe1qX8FEeNVPMfsKMCfG+xG89xWwfqq7DdfDu9C4i3cbfpZyBconhHSv3b4C1r3YfQXsN3ppX8ETlCvoxX0Fr4BvezrHtxXdV/BMZK6g2lfQKlOvfQUfC+QK0B91e1/BlylXkLev4FOke2X3Ffwx6PMvU7zh4TeqfQXVvoLXkGf/vl73FaCP6Pa+gi+T7SsfuV7gVTEL7it4hXIF6h7CXtxX8DXwYf9Msqn2FeTbZLWvoJjteuwr+OeccRvbUWZfAccDzwm8aq9RjfhF+PXwjuWvfE5ov4KKhdQ654YcOugTsG3nZv/y2s+/RcbU3VyLRxmxvrfLERWdD/Jdu2q9Rum70VR7zvDe28dobKgB3BnEay1p5bUm2tbMqa9wYb/sD7/3g3KEf8MxG/+1+ATlWaBflwxBnQRwIO6SOrME22qPiicxdlL00qchyuoRvPz2vM8v+vB/HTatRvWNF37Hetkv4M8Q8CarAeJ9JIl6FinbNdpWxm3HMrQ/4yG12RdGJ/LXX5K/GPkh/qaAPwvgivTFjGSiLqC+m73iHb2PUBn65tA9mDE5Z/Zv6LfxOyC8Zm/wOx8zXu/gYybiVD4Q4+ei31iI+TZNCFfoO7Tt9rgxbTWXZV6SJD8GUPZhsunG2BZagy36LQwlK9VPas2Wc0mPQBl/jyq0rwPHRF4HVnvQlH56fdNqFeWOVWwW0r12sRnrXmxsxn4jdH9u0dwR2xnqKsJz7tjgj6fxvmTOReaOec8pfrunSK7tPPBtC3J8W9H83YkZnkmKcwvnWIruOW3nN9luQ3sPnhe41NyK7Wwg0TG24asT/JnQB5w7Rn/Ec0t1vkP5I47f0WYwd3xjxsdQ0mq7mDu+gHRPzbHQ57DuGfxa0OeLs9+efoPzSugHeJ1AjTlKz5qiPo6hXM/8gPmVkvu+onPHhr+RtLa5TO5Y2Z+aZ3boN8dyx7G5aswdq7VwxBXKHXfTr4Xm7+3kyrlctZaqfAT7gdDe+A0BeugjMBa/kWxf+cjYmOV5wLuc8gNoX2z/sftMY3LOPG4oH8ZjNsK/E3zY/SQbpcuhOLbdumdoLewTEbhC+aF2e9yYttrjxrwkSb5NdnEdp7/b69NKVqqfmgSPsilqu5wfjs0547rP/TnjNrZDfZtLxQM45l9AY/fmkit4Amz3pSpX0EKb+axyBRPLJjNX8FKXcgUHVbmCwrmCX98McgV/DL7tfznlCj5f5QrGyjZVruD3eyRX8IPIXMFXnHIFPwZ9/vMqVxB6qlwB0atyBZsmV/CDLuUK9tpMcwX/D3zY1GMn4qxyBfk2WeUKitmuR66A9dMrV8DxwKMC7zMCby1p9UMx+8zUPjaUB39XW+1fUnftPJJDR+Ug0of3mRn8GzI5t4upjXY39B1lxPqufDbCs7xD31pGmah9jnxWC2VsNI3nZwTOlPdpNDY8DXBPJRPLnoUyPsu8Hsr4W2uoI8gH9hPqwTqAMbx1gt/n2PF6R5PtKR1+Ft5xH4T6DPlReh0zr3k6QLtd/zNtdR8G85IIPlEfjJaVPZv97oatoP9hWwn5mvSJkZXqJ2UrHNc9BWVPU1no7iT81tp6KkPdxrOJrJ9Pi3asg3c8NqwTvL52fuCgiXjXC7wh3QudvVS696xon7J/9hto/+w3UEfZb2Dfst/A+X4i4DkXZfCnZn1h8xvUkQK6LnNRfL7iOeBB6TfP3Q3+F8C3Lcrxbf0FcZ4ROW5aP3ZjzjaZ4ybbLfbNs4TrWYFLzd/YzgYSHSMZvjrBXwx9wLko9Ee8txz9EY/5HxJ0lT/CXNQ7Mz7U+STMRV1Ouoc+TcWSrHsG/27Q5yuz355+g2NS9AOIg3UqpGdqnsAxFdYzP2B+BXWxG7kow99IWttcJhel7E+dl+/Qb47lotT8SPUD5qJQpmq+FMpFrQf+EdbDr6GcYvyaOhekzjg9S2XoI9gPoI9g//GhAD30ERiLv5Ns/9mktR2xMcuzgPf5LGZRNs72jzbO9o/6znEDypDjBryrScU8OGYj/O3gw56ImOuH4tjQWSTkR+XrX4zA1e17LpiXJMm3ycmem2NcwLbYLicTIyvVT+oMGK+Fxdpu6LvsbNeo25jvfSJn3MZ2rId3ofPKOOZzPPCAwDsg8Br8OsDVRzjS32uz33WCf1bErobzQcFDP7zjPn1YwD8IMMbPcNLqxx6mMqx3d/Zb6bvBdajv05S+Y3tY3x+Bsj4Bz7JRuUXMKVnfNgke5WRld0OZ0RwiPCjvlPevHTCRn3Z9y/r1EOBSfXtT9rtO8J8O6JfSl/vgHcswJHPkZ5h4wLrDop7JV+mXwXWoX8NKv7A9rF8hfUkfls1jAh51yPA3CR7lZGVol0ZziPCgvNN39+47EQ79Vy3nX+OV3/E8AXGdRfysc6SD7d6f6NwPZTiP+z3y2yiTPlH3rdnvOsH/A8RAv0/zOKy/jupb2R+Cnf1kNL8++2AcIwaoDOWBPievnQh/U047/wz4/MfRjb+V3RlfHdpdU9kd+r4Yv47wRf06+260yfsJ1/0Cl5oHcIwwkOg+MHx1gv9mIFeC48eDxPvdBXlX44nyI1Y3fbc48yMqDniIaKoxTPVVU9R/MAfXFME/2i33e1+ix0OGN53AfKXyz3WC/x701X+MapxJDg/35/A8kAP/CPFg8D8S+hLyA6j/DxNOg/9XwPmdgjhX5+D890Csoez0IXhXdDzleALl+BiVIe88Lj4K9Bn2bUQfy1DPmW4S4JfH1Hb88nhjZdOO2/hv2ke17Pcg4Svoq/tCfXWu4De2r+4PtI9xWb160qqPIRtBeQwep3H2F8Q5NcODY7qKVfYD/NOItvKR6KvZL6PPQDv8PYpJkP4A8W/jxCzgP7QuYrg6G+trf6vG+rsBgsd6JRuEZ5/wkIDHfuQYG8ebOVSG4yzHVncLOrFj6d3Q1j32nYh3XQBv+vtNxEe7GG9F9pv98O6i30MyDMlczRFRrryOiv3BOQWls5Otj9h+1sdQW9On6HyY9VGNH0ofOc4K6U36hPQR81LbUmyHvPLc45EAP+1ibpar+fiBHHj2+QZ/FOgxxz2PCx5C84QnBPzjgudh4gHrMu28/V1LqD0Gf1ykP3bKecxQ+o9y434KySh9WKZPCniUFe/vehLKHqMy1P/HqUzlkUI2G2sbVjd99/25E/F65+fYVxv8koCvVm0L+epu5edCvrqbutqr+TnU1dj83N+QfimfPhDgX+njOsG/yitxv2O9B5L2fK0TfKl5zLoAnXkd0pkn6HQ7BzmP2vNgoD1FcyFY/0Fqz4OO7VE8t8uprqI5jPJtOIfh8c7g74Q52Y3Z71BOtaju3pdM5DOUQ0qfc5Lx9idJN2JOvW47mTEnx5U4XsbkDFH3cOw0mIR47Ia80J5j5ozKb4Tkq3J0zaRVlg9QGerbOqLjlX/9lbnt+X8g0N52+sG5mB5ao9vkMQDrQtE1OvaXSEf5S+5j9K/YL7xmZfBPBGJHpQchvWk3pzN+lG7wuX6V5++iD+lpvXmYylTeMVZvQrlCHKNt/A7lyGrJxHES9Rnh89ZX1hGeGr3fGt5jveupzRwjMe5VBG/tHMiBN3wci3wykEt4qA0PNxAPD7fh4SHiweB/WfAQkn/6hGLCwaTVFgvYTb1G+IwffIf4G4nWj5Ek6qmx/Iye0oP0YVtW9qTWSkI+UNm5wjXgiMviBhXDHkV0is6LsH5o/jW/QzrzBZ1uz7+OIjoPO9JBm5lPdB5xpIN6sD3RedSRDo5H+xOdBwQP6TjwZzTPewzKVMzAZyAMfqc3jtf7Gs3z0Fcgj1gfx/0HRTuY3jdovRPzuAX8kTznZLjaye5vctb5YmVn8D8/frzetwKyY9tWMcZw0ioPjukxP8trryr/i+9Y51SOfEjU4/EK88BF5ooxtoH4G0lrm8uMVyrPjTEhnx95qhy9sfMj6gyl6gc8P4IyVec/zcaUn+WcAfrGJ6gM/Rnn6dG+94PfSCOvTRbbDgf4U3Eoxm4q38K6N9mx0kPl6AVjJZUfKhor8f6rXo2VkE+OlYrmXLH+gwE68zukM1/Q6XZut4qV4umUiZW2PX78Pfr/orHSszDez85+q7xJTKz0kGgH09s5o7EpY6VdSXZqPSEkO4N/P8hu94Ds2LarWGmcT3yH+KtYKT9WUvFGN2Olh9q0iWMlxZ+Kd9JnJIl7YmIpbF+BvtstVjcNv1cspeISFUtZ+x4tR28k1bWts3oYx14Bv9X+J+wvr/5TuZlN1X/rytEL9p/KWXn2H9pWkf5TtnkI/MYybE8orsT6kxVXHkJ08sb4M2iMV2taOMbzngGD/wUY48+mMT52X8D9wDO32Wmdv6/ouabQ3uX0Kbrvlvcrhdat1Z7yWtLaJ0XXrfF862M569Y1wPtWUZdtG+EfFnwYPJ+lYRg+92LwV2Y6lfbfV0c1z3nnXvLWYa8GnJN97gXlzOdIsF5oHdbgOrSJ3ZRNYHvYJtQeXhUrGny7Pbys9xjLPky42L7SZ4nAFeJ1XQe8cj9iX/F+Y4NFvcT2sF4a/NuFXqr+N5l3o/9D6/BKpqF1+HYy5XxXaC9yaB2+3Z4b9okPCB5wTJysOSrnDJ4EXvoEr4a3TvB3wRj8QRrXbb6UJHE2q+ZnOOfi89A4N3s6AlfIl35QwD8doI18YV2mzXxavS7altwnh3Ntti3VTwj//7d3dSFeFVH87veuu7bZByiCGuEHkQWGFIW7tyVBQrPeCsuMXOslqF5aqGAxIiy/SFf/u8uyvgVZLVJRlAWWCpUP0qeEYEkUGWaCgQ+Scb3/WX/729+c/9zde90t9r7M/Thz5szMOWfOnDtzJqStVD+puC4cYzJ0vtxH30Lny71Q5wGPbwnrESq76Jdin5XSVRbvhY5V1n4TJf+sN9QYp2SJ9Qb2LesN9oMwPPsaHfxe8jUij2TgdelrHCAa+4EGxd/sQ3TwB0C3vePRbXUZce4LHGddPxYRpw3lnXWBpYOTK6veZLnFvgnZG4xtyna9a6N6AY/4eG/VfugDjqmA+qifaA/13/F+JfUPIWn3E2U6eL9Vco/z5c+J91Cnsb5ILuY9B38S+Pkw2Rt56A1e24l6gO1UNeYoPlP2GY6hnM/pAadXkBeL8Ik7/E3R6DqPxW8V6qMep94c9oljTESrH9Anjm2K5TtcVvzJIvUatlOIXlN+8tZodB1ZnlFHsB5AHcH6o8coD3UE2uInPP8SsR6hNgv+h7ye5B/li+UfZZzlH/md7QZsQ7YbBoAWZfPgmI3wv4MOu0Bto3jZsmPVWXgYZ7BE9UFeHwzA1WuUvUfADxplq/jGTEsU+WVSyaJrmyLmG2gXsCyqfkL4kLZS/dRK8Ng2WWV3gL7h+M5yjbyNcekveMZtrAeO2yy7JUEr2gNXau1fXr6Celj7Oat9JM7J5iuw/O1TvoLL9FTSsXn6CkLXIebhK2D+VP/fQsfdEXu7aS1w3rEpxuorYL0xmXwFC8t9MZl9BctAt93k0W1ZfQWLy3imfAUT5yu4A/qAfQWoj4r2Fawp01HJV9BOvDdWX8Fa4OeO8n2eemPKVzDlK7iEvJz+X30FqCOK9hWsIdnPy1fwLe01Qvli+Z9MvoJO0GFd1DZTvgK/TE75CrLJbh6+gi7PuI31GIuvgO0BXtOfXGvgHa9l4TXePjoc/PBcP9JrrXy+gW6ws9xaK7UuaCXUbaOnbqgn1PyHbbw9oCdeNmwdjmuhbJ0oGq2XGbbN0wZbgI5X2/1lOR5qMeqY4NjW7odrE3CMo1q0AY9vO0Q+NffkPTklKmO3UcYukU+V0UM4sc3UXoP+Ct/7RN0i8a5awJc89Y1E2b0V8O4WeJSusXQU29R52Qbzy2s5lbz4ZELxVcmgvY9or7QWkGlX7Yf6Q62P5L0MzFs7RT2rxLOj70l4xzpWxXpHGJeX16e+JXQm4/StA9zgwTkkfA4Wz9wC73gstvoJ6VHrGkuUT8UQisQ71T/bCJZ9CW2CJt/zLoHHR4O1v9bav5fXmsKrSTZVLEf3/DrRjrAcK4X3ZjB/8x5fjMNTI2CYvx38AYO/1b5ApGuDB+dBg79Vuy+Gd1njp/HcSMVPU7Sj7uF3qn+Yv1kftQmafM87BB4fDeq/k4r1GRKjWp2X1hKN5hWMUd23KL1X7ctx2tVaP7Umr1Xk5xhNjobvgJf4XAykU9VxlQfnMYM/847Hbp0htNPIh/3XKMqa524u2pfD52ShIfLzIK9X/wna6WysaalieipcBe5jnFdF+KJI+wj/o/sY5+axj5H3RiX36Ns+RfM9JWOYt7N8zzL2F8yzTntwRtH4dFP3opF4Q2NzhI4t1p42a9/PVvqmzrtxNCgbEuE5TrmDPw+yaZ0blk8s0KqzyqeENiL7lKx9U8mV1Y7l83rU/xGLv5Svl/nGdx4Cn/kzrLfjNFX/rTA2Le912Z6Rdl8MYJZFlA2W47zPT320fM9y3xKnaej5qeM5X8Y6P5X9SCrGsJIXB1dEDNQrGXeaz09V/Kz2o7oyle7F/aWdpHtVvGXsW+YvxFUj6Fhbvuez+ubEaar4K+8Y/hybOWsc9AL3O18z0fudXd9mjdPN++TVGYoJ7fcQf6lxEvM+Vr7ncfLWOE1DfS2WzFUaoxw9lq9F+VSZl5R/z9FgrTVI7tdHI9vBwd8eR8PtYNkLOa15uzvr/2Dr7Jrk4r6w1shhm7QSPPcLPiMu6/+LOj+pJPBz7KeOOE0r7YmxfMwhtCu9q+QNZeq3hem9muezzWqdg8N5ceyp98D75p8r4zS1YkT7fK/rCKeDXw04Q2K0b4F3WWO0s+9V+SPV/MGKDZCPPR91THSMdh4/rNj+WWO0h/I/8tA3xP84nm+mMi07lvNiOT7+98VIfzxOU8X/leblDxNOB78BcIb4viz+r2QjWDaSFZfH6ZsC7fPlE22fM/9b9nlWP28o/yMPfbZwJF4VPxnzPlK+5/jJXXGahvIXzhvGaoMqHrJ0L/tnlO3K/egbZ3ie4uC742i4HSx7K6czN66daH3O/96UfWvpTyu2kNKfarxk/flanKaV/DPWWdAhtIfKG8rUEI03OPfl8Wa7USbnRbn2jTcOH48NPXGaqvEG52bKH8TjjYMvAc6Q+bo13lSar7M/SMXZUnN5a77u4MYpn9cVfa5WJV8ZjzeoD/m8nKznaoXyP/JQP4w3ydVAeDF1eRze5GoU8O5bE3zD/kquafC+RuBqoHwOfl+cpleVn9Gv5PK3ivLRfxZ56MZ31QTfJOCbBHzSPm/Gl2keH792vVhFZdZFI/sjIvy1BP9BPJLWKkhrA+j48dDf379375KnZlD+5HJ1Tuqp+qOG8mCf1gj4aviO8PvjNE3q/mn53vFYnSgveXfEgKvypIpmpMfihRoB78qeJuDdt2b4hroHYbC9EFcTfEf4L+M0dX2CfO3yt4ryG6l8RTe+YxlpFvDNAv7Svt44vW+Cdw5X1n+/yVVP+fEdlj0tGrssfPTxDT9svG3m+kqyMFb8vzTev7z6/c1zi8J/tOGPc18dfmJ7Ufhn7+882n781PGi8G9aUjtj60OrVhSFv3TuvqUvzbzxTFH4ew4uXnHmgdNzisL/wpFn3/hnxt5fi8L/7tKb75z+4ILuovBPP/Th6p/PP72gKPyvnLx4bPPzs/4sCv+ywec2tSwd2lcU/rebv+74ZLBxbVH475q/debsL55pKQp/Xe3s3nlD61ZWwv8vFYugaAtICQA=",
      "custom_attributes": [
        "external",
        "utility"
      ],
      "debug_symbols": "TL3NkjQ7j5x5L2etRRIkALJvZRay0Ywka7M2tZl+Vn3zqoATdN/0eby/t+gMkvCMikRl/sc///9//S//57//53/9H//t3//XP//y//zHP//lf/7rv/3bv/73//xv//7//b//+1///X/8/X//45/f939W/vMv8z/9s/Y//xJ//zn//Mv+T//4D/8Z+I/hPxP/WfiP4z+B/yT+s/EfjBIYJTBKYJTAKIFRAqMERgmMEhglMEpilMQoiVESoyRGSYySGCUxSmKUxCgbo2yMsjHKxigbo2yMsjHKxigbo2yMcjDKwSgHoxyMcjDKwSgHoxyMcjDKwSjj97v/Hfe/dv8773/X/a/f/8b9b97/7vvfO96444073rjjjTveuOONO96444073rjjjTue3fHsjmd3PLvj2R3P7nj2N974fZANu+FcmH9jjvnBaLCG2fA37ogP/ga2+qloyIbdcC6sX8PfyLY+sIbZsBq+kf2DaMiGb87f5XxFUPCVAeBv5Dk+sIbZsBq8IRqyYTecC19pAHrk6JGjR/5KZH7L8hUJIBqyYTecC1+5AEaDNcyGHjl75OyRs0fOHjl75N0j7x5598i7R9498u6Rd4+8e+TdI+8e+Sur+W3BV1gAa5gNq8EboiEbdsMB2O/XMBqsYTasBm+IhmzYDT3y6JFHjzx65NEjjx559MijRx498uiRR49sPbL1yNYjW49sPbL1yNYjW49sPbL1yLNHnj3y7JFnjzx75Nkjzx559sizR5498uqRV4+8euTVI68eefXIq0dePfLqkVeP7D2y98jeI3uP7D2y98hVg/uDbNgN50LVYMFosIbZsBq8oUeOHjl65K8G11/l2leDgNHwN/KKD2bDavCGaMiG3XAufDUIGA098u6Rd4+8byLZjoZs2A03kez8GkaDNcyG1dAjnx759MhfDa7zwQHMrwYBo8EaZsNq8IZoyIbd0COPHnn0yF8N+u+D2bAavCEasmE3nAtfDQJGQ49sPbL1yF8Nen4QDdmwG86FrwYBo8EaZsNq6JFnjzx75Nkjzx559cirR1498uqRV4+8euTVI68eefXIq0f2Htl7ZO+RvUf2Htl7ZO+RvUf2Htl75OiRo0eOHjl65OiRo0eOHjl65OiRo0fOHjl75OyRs0fOHjl75OyRs0fOHjl75N0j7x5598i7R9498u6Rd4+8e+TdI+8e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Yz+P/Tz289jP4zyP8zzO8zjP4zyP8zzO8zjP4zyP0x7VHHVpPLJH89F65I/iUT7aj57HeB7jeYznMZ7HeB7jeYznMZ7HeB7jedjzsOdhz8Oehz0Pex72POx52POw5zGfx3we83nM5zGfx3we83nM5zGfx3we63ms57Gex3oe63ms57Gex3oe63ms5+HPw5+HPw9/Hv48/Hn48/Dn4c/Dn0c8j3ge8Tziebw691fn/urcX537q3N/de6vzv3Vub8691fn/urcX537q3N/de6vzv3Vub8691fn/urcX537q3N/de6vzv3Vub8691fn/urcX51X41V60Xy0HvmjeJSP9qNzqRqwLo1H9mg+Wo/8UTzKR/vR8xjPYzyP8TzG8xjPYzyP8Tzqj+PwJ1r70WmqP5EDjUf2aD5aj/xRPHoeX51vKzpNX51fGo/s0Xy0HvmjeJSPnsd8Hut5rOfx1fleRfPReuSP4lE+2o9OU/01KWg8eh7+PPx5+PPw5+HPw5+HP494HvE84nnE84jnEc8jnkc8j3ge8TzyeeTzyOeRzyOfRz6PfB7156l1wuovVEGnqf5ONYrGI3v0eeyi9cgf/XmcOk1fnV/aj/48Tn701fml8ejP49QoX51fWo/8+yvOX2EQk7iJp7E6vRoH0YiTuIhODGISy20UnofjRyy3VWjESVxEJwYxiZt4HtqPSDejm9HNys0LnRjEJG7ieVh/PXtxEI04iXSbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0W3RzujndnG5ON6eb083p5nRzujndgm5Bt6Bb0C3oFnQLugXdgm5Bt6Rb0i3plnRLuiXdkm5Jt6Rb0m3TbdNt023TbdNt023TbdNt023T7dDt0O3Q7dDt0O3Q7dDt0O3Q7Ty3/fsRB9GIk7iITgxiEjeRboNug26DboNug26DboNug26DboNuRjejG7JkF07iIjoxiEncxPMQWQIcRLpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui26Od2cbk43p5vTzenmdHO6Od2cbkG3oFvQLegWdAu6Bd2CbkG3oFvSLemWdEu6Jd2Sbkm3pFvSLem26bbptum26bbptum26bbptum26Xboduh26Hboduh26Hboduh26Hae2/n9iINoxElcRCcGMYmbSLdBt0G3QbdBt0G3QbdBt0G3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mCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1lizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZgr7X77t9J/peL27i57bmh5UlFwfRiJO4iE4MYhI3kW5JN2RJFhpxEhfRiUFM4iaeh8gSIN023TbdNt023TbdNt023TbdDt0O3Q7dDt0O3Q7dDt0O3Q7dznND3+vFQTTiJC6iE4OYxE2k26DboNug26DboNug26DboNug26Cb0c3oZnQzulWWuBU6MYifm8/CTTwPK0vWKhxEI07iIjoxiEncxPNw0W3RbdFt0W3RbdFt0W3RbdFt0c3p5nRzujndnG5ON6eb083p5nQLugXdgm5Bt6Bb0C3oFnQLugXdkm5Jt6Rb0i3plnRLuiXdkm5Jt023TbdNt023TbdNt023TbdNt023Q7dDt0O3Q7dDt0O3Q7dDt0O389zQ93pxEI04iYvoxCAmcRPpNug26DboNug26DboNug26DboNuhmdEOWjEIjTuIiOjGISdzE8xD3JUC6TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui26Od2cbk43p5vTzenmdHO6Od2cbkG3oFvQLegWdAu6Bd2CbkG3oFvSLemWdEu6Jd2Sbkm3pFvSLem26bbptum26bbptum26bbptum26Xboduh26Hboduh26Hboduh26HaeG/peLw6iESdxEZ0YxCRuIt0G3QbdKkt8F07iIn5ugX8bxCR+bjELz8PKkouDaMRJXEQnBjGJdDO6TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26LbotujndnG5ON6eb083p5nRzujndnG5Bt6Bb0C3oFnQLugXdgm5Bt6Bb0i3plnRLuiXdkm5Jt6Rb0i3ptum26bbptum26bbptum26bbptul26Hboduh26Hboduh26Hboduh2nhv6Xi8OohEncRGdGMQkbiLdBt0G3QbdBt0G3Qbd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",
      "is_unconstrained": true,
      "name": "get_registered_emitter"
    },
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14067204867181196045": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "9921926525851912681": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [
          {
            "name": "chain_id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 16
            },
            "visibility": "private"
          },
          {
            "name": "emitter_address",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "boolean"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "utility"
      ],
      "debug_symbols": "TJ3LsjS7bpzf5Yw9aAIkQOpVPHD4qlCEQorwZaSX9yokwcyJz5fW/pksspBdXYVV/R//+B//87/9v3/+L//yb//r3//PP/7pP//HP/7b//6Xf/3Xf/nn//Kv//7f/+v//Zd//7e//9//+Mfv+39O/OOf/D/94+Q//in+/mf/45/23/+c+p/x+93/Hfd/7f6v3/+d93/X/d+4/5v3f/f93zveuOONO96444073rjjjTveuOONO9644407nt3x7I5ndzy749kdz+54dsezO57d8eyO53c8v+P5Hc/veH7H8zue3/H8jud3PL/jzTvevOPNO96848073rzjzTvevOPNO96846073rrjrTveuuOtO96646073rrjrTveuuPFHS/ueHHHizte3PHijhd3vLjjxR0v7nh5x8s7Xt7x8o6Xd7z8G2/8PoiGbNgNf2OOvzNz7F/DaLCGv3FHfPA3sH3/aq+GaMiG3XAunL+RbX4wGqzBG76R1werIRq+OX+H81UN4ADsKxwfH4wGa/CG2bAaoiEbdsO5MHrk0SOPHvmrIvcPZsNqiIZs2A3nwldMgNFgDT2y9cjWI1uPbD2y9cjWI3uP7D2y98jeI3uP7D2y98jeI3uP/NWX/22BfQUGGA3W4A2zYTVEQzbshh559cirR1498uqRV4+8euTVI68eefXIq0eOHjl65OiRo0eOHjl65OiRo0eOHjl65OyRs0fOHjl75OyRs0fOHjl75OyRs0fePfLukXePvHvk3SPvHnn3yLtH3j3y7pFPj3x65NMjnx759MinRz498umRT4987sj++zWMBmvwhtnwjbw/iIZs2A3nQtVgwWiwBm+YDT3y6JFHj/zV4BwfnAtfDQL+Rp7xgTV4w2xYDdGQDbvhXPhqENAje4/sPbLfRHJfDdGQDbvhJpLPX8NosAZv6JFnjzx75K8G5/lgN5wLXw0CRoM1eMNsWA3R0COvHnn1yNEjfzW4fh9YgzfMhtUQDdmwG86FrwYBPXL2yNkjfzW48oPVEA3ZsBvOha8GAaPBGryhR9498u6Rd4+8e+TdI58e+fTIp0c+PfLpkU+PfHrk0yOfHvnckefv1zAarMEbZsNqiIZs2A098uiRR488euTRI48eefTIo0cePfLokUePbD2y9cjWI1uPbD2y9cjWI1uPbD2y9cjeI3uP7D2y98jeI3uP7D2y98jeI3uPPHvk2SPPHnn2yLNHnj3y7JFnjzx75Nkjrx559cirR1498uqRV4+8euTVI68eefXI0SNHjxw9cvTI0SNHjxw9cvTI0SNHj5w9cvbI2SNnj9w1OLsGZ9fg7BqcXYOza3B2Dc6uwdk1OLsGZ9fg7BqcXYOza3B2Dc6uwdk1OLsGZ9fg7BqcXYOza3B2Dc6uwdk1OLsGV9fg6hpcXYOra3B1Da6uwdU1uLoGV9fg6hpcXYOra3B1Da6uwdU1uLoGV9fg6hpcXYOra3B1Da6uwdU1uLoGV9fg6hpcXYOra3B1Da6uwdU1uLoGV9fg6hpcXYOra3B1Da6uwdU1uLoGV9fg6hpcXYOra3B1Da6uwdU1uLoGV9fg6hpcXYOra3B1Da6uwdU1uLoGV9fg6hpcXYOra3B1Da6uwdU1uLoGV9fg6hpcXYOra3B1Da6uwdU1uLoGV9fg6hpcXYOra3B1Da6uwdU1uLoGV9fg6hpcXYOra3B1Da6uwdU1uLoGV9fg6hpcXYOra3B1Da6uwdU1uLoGV9fg6hpcXYOrazC6BqNrMLoGo2swugajazC6BqNrMLoGo2swugajazC6BqNrMLoGo2swugajazC6BqNrMLoGo2swugajazC6BqNrMLoGo2swugajazC6BqNrMLoGo2swugajazC6BqNrMLoGo2swugajazC6BqNrMLoGo2swugajazC6BqNrMLoGo2swugajazC6BqNrMLoGo2swugajazC6BqNrMLoGo2swugajazC6BqNrMLoGo2swugajazC6BqNrMLoGo2swugajazC6BqNrMLoGo2swugajazC6BqNrMLoGo2swugajazC6BqNrMLoGo2swugajazC6BqNrMLoGo2swuwazazC7BrNrMLsGs2swuwazazC7BrNrMLsGs2swuwazazC7BrNrMLsGs2swuwazazC7BrNrMLsGs2swuwazazC7BrNrMLsGs2swuwazazC7BrNrMLsGs2swuwazazC7BrNrMLsGs2swuwazazC7BrNrMLsGs2swuwazazC7BrNrMLsGs2swuwazazC7BrNrMLsGs2swuwazazC7BrNrMLsGs2swuwazazC7BrNrMLsGs2swuwazazC7BrNrMLsGs2swuwazazC7BrNrMLsGs2swuwazazC7BrNrMLsGs2swuwazazC7BrNrMLsGs2swuwazazC7BrNrcHcN7q7B3TW4uwZ31+DuGtxdg7trcHcN7q7B3TW4uwZ31+DuGtxdg7trcHcN7q7B3TW4uwZ31+DuGtxdg7trcHcN7q7B3TW4uwZ31+DuGtxdg7trcHcN7q7B3TW4uwZ31+DuGtxdg7trcHcN7q7B3TW4uwZ31+DuGtxdg7trcHcN7q7B3TW4uwZ31+DuGtxdg7trcHcN7q7B3TW4uwZ31+DuGtxdg7trcHcN7q7B3TW4uwZ31+DuGtxdg7trcHcN7q7B3TW4uwZ31+DuGtxdg7trcHcN7q7B3TW4uwZ31+DuGtxdg7trcHcN7q8G4+8e0f5qEDAa/kaO+YE3zIbVEA3ZsBsO4Hw1CBgN1uANs2E1REM27IYeefTIo0cePfLokUePPHrk0SOPHnn0yKNHth7ZemTrka1Hth7ZemTrka1Hth7ZemTvkb1H9h7Ze2Tvkb1H9h7Ze2Tvkb1Hnj3y7JFnjzx75Nkjzx559sizR5498uyRV4+8euTVI68eefXIq0dePfLqkVePvHrk6JGjR44eOXrk6JGjR44eOXrk6JGjR84eOXvk7JGzR84eOXvk7JGzR84eOXvk3SPvHnn3yLtH3j3y7pF3j7x75N0j7x759MinR+4aPF2Dp2vwdA2ersHTNXi6Bk/X4N+D9d+j8cge+aP5aD2KR/loP3oe43mM5zGex3ge43mM5zGex3ge43mM52HPw56HPQ97HvY87HnY87DnYc/Dnoc/D38e/jz8efjz8Ofhz8Ofhz8Pfx7zecznMZ/HfB7zecznMZ/HfB7zecznsZ7Heh7reaznsZ7Heh7reaznsZ7Heh7xPOJ5xPOI5xHPI55HPI94HvE84nnk88jnkc8jn0c+j3we+TzyeeTzyOexn8d+Hvt57Oexn8d+Hvt57Oexn8d+Hud5nOdxnsd5Hud5nOdxnsd5Hud5vDofr87Hq/Px6ny8Oh+vzser8/HqfLw6H6/Ox6vz8ep8vDofr87Hq/Px6ny8Oh+vzser8/HqfLw6H6/Ox6vz8ep8vDofr87Hq/Px6ny8Oh+vzser8/HqfLw6H6/Ox6vz8ep8vDofr87Hq/Px6ny8Oh+vzser8/HqfLw6H6/Ox6vz8ep8vDofr87Hq/Px6ny8Oh+vzser8/HqfLw6H6/Ox6vz8ep8vDofr87Hq/Px6ny8Oh+vzser8/HqfLw6H6/Ox6vz8ep8vDofr87Hq/Px6ny8Oh+vzser8/HqfLw6H6/Ox6vz8ep8vDofr87Hq/Px6ny8Oh+vzser8/HqfLw6H6/Ox6vz8ep8vDofr87Hq/Px6ny8OrdX5/bq3F6d26tze3Vur87t1bm9OrdX5/bq3F6d26tze3Vur87t1bm9OrdX5/bq3F6d26tze3Vur87t1bm9OrdX5/bq3F6d26tze3Vur87t1bm9OrdX5/bq3F6d26tze3Vur87t1bm9OrdX5/bq3F6d26tze3Vur87t1bm9OrdX5/bq3F6d26tze3Vur87t1bm9OrdX5/bq3F6d26tze3Vur87t1bm9OrdX5/bq3F6d26tze3Vur87t1bm9OrdX5/bq3F6d26tze3Vur87t1bm9OrdX5/bq3F6d26tze3Vur87t1bm9OrdX5/bq3F6d26tze3Vur87t1bm9OrdX5/bq3F6d26tzf3Xur8791bm/OvdX5/7q3F+d+6tzf3Xur8791bm/OvdX5/7q3F+d+6tzf3Xur8791bm/OvdX5/7q3F+d+6tzf3Xur8791bm/OvdX5/7q3F+d+6tzf3Xur8791bm/OvdX5/7q3F+d+6tzf3Xur8791bm/OvdX5/7q3F+d+6tzf3Xur8791bm/OvdX5/7q3F+d+6tzf3Xur8791bm/OvdX5/7q3F+d+6tzf3Xur8791bm/OvdX5/7q3F+d+6tzf3Xur8791bm/OvdX5/7q3F+d+6tzf3Xur8791bm/OvdX5/7q3F+d+6tzf3Xur8791bm/OvdX5/7q3F+d+6tzf3Xur8791bm/Op+vzuer8/nqfL46n6/Oq3sp0PQdj/LRn0f+ik7TV+eXxiN75I/mo/UoHuWj5zGehz0Pex72POx52POw52HPw56HPQ97Hv48/Hn48/Dn4c/Dn4c/D38e/jz8ecznMZ/HfB7zecznMZ/HfB7zecznMZ/Heh7reaznsZ7Heh7reaznsZ7Heh7recTziOcRzyOeRzyPeB7xPOJ5xPOI55HPI59HPo98Hvk88nnk88jnkc8jn8d+Hvt57Oexn8d+Hvt57Oexn8d+Hvt5nOdxnsd5Hud5nOdxnsd5Hud5nOdx2qOaoy6NR/bIH81H61E8ykf70fN4db5ena9X59UplVY0H61H8Sgf7UenqeocNB7Zo+dhz8Oehz0Pex72POx5+PPw5+HPw5+HPw9/Hv48/Hn48/DnMZ/HfB7zecznMZ/HfB7zecznMZ/HfB7reaznsZ7Heh7reaznsZ7Heh7reaznEc8jnkc8j3ge8TziecTziOcRzyOeRz6PfB75PPJ55PPI55HPI59HPo98Hvt57Oexn8d+Hvt57Oexn8d+Hvt57Odxnsd5Hud5nOdxnsd5Hud5nOdxnsdpj2rAujQe2SN/NB+tR/EoH+1Hz2M8j/E8xvN4dR6vzuPVebw6j1fn8eo8Xp3Hq/N4dR6vzuPVebw6j1fn8eo8Xp3Hq/N4dR6vzuPVebw6j1fn8eo8Xp3Hq/N4dR6vzuPVebw6r06tXEX2yB/NR+tRPMpH+9FpqjoHPY/1PNbzWM9jPY/1PNbzWM9jPY94HvE84nnE84jnEc+j/ppuFOWj/eg01V/VgcYje+SP5qP16Hl8db5rxb86v3Savjq/NB7ZI380H61H8eh57Oexn8d5Hl+d71lkj/zRfLQexaN8tB+dS9XkdWk8skf+aD5aj+JRPtqPnsd4HuN5jOcxnsd4HuN5jOcxnsd4HuN52POw52HPw56HPQ97HvVXrqsoH+1Hn8f3N5PVAnZpPPo88Ceb/mg++vM4oyge5aM/j5NFp+mr80t/Hgd/BGqP/NH8/uzzV7iIQUziJp6HX7U3DqIRnUi3RbdFt1VudVRrE8/DKLda7hhEIzpxEhcxiEncxPMw6ZZ0S7pludX+5iQuYhCTuInnYf3B7cVBNCLdNt023TbdNt023TbdDt0O3Q7dDt0O3Q7dDt0O3Q7dznOrBrTGQTSiEydxEYOYxE2k26DboNug26DboNug26DboNug26Cb0c3oZnQzuhndjG5GN6Ob0c3o5nRzujndnG5ON6eb083p5nRzuk26TbpNuk26TbpNuk26TbpNuk26Lbotui26Lbotui26Lbotui26LboF3YJuQbegW9At6BZ0C7oF3YJuSTdkyS40ohMncRGDmMRNPA+RJUC6bbptum26bbptum26bbptuh26Hboduh26Hboduh26Hbodup3ndn4/4iAa0YmTuIhBTOIm0m3QbdBt0G3QbdBt0G3QbdBt0G3QzehmdDO6Gd2MbkY3o5vRzehmdHO6Od2cbk43p5vTzenmdHO6Od0m3SbdJt0m3SbdJt0m3SbdJt0m3RbdFt0W3RbdFt0W3RbdFt0W3Rbdgm5Bt6Bb0C3oFnQLugXdgm5Bt6Qbs+QwSw6z5DBLDrPkMEsOs+QwSw6z5DBLDrPkMEsOs+QwSw6z5DBLDrPkMEsOs+QwSw6z5DBLDrPkMEsOs+QwSw6z5DBLzssS+70ssd/LEvu9LLHfyxL7vSyx38sS+70ssd/LEvu9LLHfj26DboNug26DboNug26DboNug26DbkY3o5vRzehmdDO6Gd2MbkY3o5vTzenmdHO6Od2cbk43p1tlycAbXM7DypKLg2hEJ07iIgYxiXSbdFt0qywZVmhEJ07iIgYxiZt4HlaWXKRb0C3oFnQLugXdgm5Bt6Bb0i3plnRLuiXdkm5Jt6Rb0i3ptum26bbptum26bbptum26bbptul26Hboduh26Hboduh26Hboduh2nlv1HDYOohGdOImLGMQkbiLdKkvGLBxEI5ZbFk7iIgYxiZt4HlaWXBxEI9LN6GZ0M7oZ3YxuRjenm9PN6eZ0c7o53ZxuTjenm9Nt0m3SbdJt0m3SbdJt0m3SbdJt0m3RbdFt0W3RbdFt0W3RbdFt0W3RLegWdAu6Bd2CbkG3oFvQLegWdEu6Jd2Sbkm3pFvSLemWdEu6Jd023TbdNt023TbdNt023TbdNt023Q7dDt0O3Q7dDt0O3Q7dDt0O3c5zs9+POIhGdOIkLmIQk7iJdBt0G3QbdGOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWZJdWKO75WmVq2YFytLLg6iEZ04iYsYxCTSbdPt0K2yxEahEZ04iYsYxCRu4mms/szGQTSiEydxEYOYxE2k26DboNug26DboNug26DboNug26Cb0c3oZnQzuhndjG5GN6Ob0c3o5nRzujndnG5ON6eb083p5nRzuk26TbpNuk26TbpNuk26TbpNuk26Lbotui26Lbotui26Lbotui26LboF3YJuQbegW9At6FZZYl6YxE0st/iwsuTiIBrRiZO4iEFM4ibSbdNt023TbdNt023TbdNt023TbdPt0O3Q7dDt0O3Q7dDt0O3Q7dDtPLf1+xEH0YhOnMRFDGISN5Fug26DboNug26DboNug26DboNug25GN6Ob0c3oZnQzuhndjG5GN6Ob083p5nRzujndnG5ON6eb083pNuk26TbpNuk26TbpNuk26TbpNum26Lbotui26Lbotui26Lbotui26BZ0C7oF3YJuQbegW9At6BZ0Y5YsZslilixmyWKWLGbJYpYsZslilixmyWKWLGbJYpYsZslilixmyWKWLGbJYpYsZslilixmyWKWLGbJYpYsZslilixmyWKWLGbJYpYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJkl6Hu1U+jESVzEICZxE89DZAlwEOmWdEu6VZbUD4Wg7/ViEjfxPMQPzQAH0YhOnES6bbptum26bboduh26HbodulWWuBUuYhCTuImnEX2vFwfRiE6cxEUMYhI3kW6DboNug26DboNug26DboNug26DbkY3o5vRzehmdDO6Gd2MbkY3o5vTzenmdHO6Od2cbk43p5vTzek26TbpNuk26TbpNuk26TbpNuk26bbotui26Lbotui26Lbotui26LboFnQLugXdgm5Bt6Bb0C3oFnQLuiXdkm5Jt6Rb0i3plnRLuiXdkm6bbptum26bbptum26bbptum26bboduh26HboduzJLNLNnMks0s2cySzSw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsOcySwyxB36vPQidO4iIGMYmbeB4iS4CDSLdNt023TbdNt023TbdNt0O3Q7dDt0O3Q7dDt0O3Q7dDt9Nujr7Xi4NoRCdO4iIGMYmbSLdBt0G3QbdBt0G3QbdBt0G3QbdBN6Ob0c3oZnQzuhndjG5GN6Ob0c3p5nRzuiFLonASF7HcdmESN/E8RJYAB9GITpzERaTbpNuk26Tbotui26Lbotui26Lbotui26LbolvQLegWdAu6Bd2CbkG3oFvQLeiWdEu6Jd2Sbkm3pFvSLemWdEu6bbptum26bbptum26bbptum26bboduh26Hboduh26Hboduh26Hbqd54a+14uDaEQnTuIiBjGJm0i3QbdBt0G3QbdBt0G3QbdBt0G3QTejm9HN6GZ0M7oZ3YxuRjejm9HN6eZ0c7o53ZxuTjdmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJM0ucWeLMEmeWOLMEfa/1Y8Doe72YxM9teuF5WFlycRCN6MRJXMQgJpFug27IkiwcRCM6cRIXMYhJ3MTz0OnmdHO6Od2cbk43p5vTzenmdJt0m3SbdJt0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0W3QLugXdgm5Bt6Bb0C3oFnQLugXdkm5Jt6RbZcmywklcxM9t1SlXWXJxE+uc/L7oou/14iAa0YmTuIhBTOIm0u3Q7dDt0O3Q7dDt0O3Q7dDt0O08N/S9XhxEIzpxEhcxiEncRLoNug26DboNug26DboNug26DboNuhndjG5GN6Ob0c3oZnQzuhndjG5ON6eb083p5nRzujndnG5ON6fbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26LbotuiW9At6BZ0C7oF3YJuQbegW9At6IYswS/HD6IRnTiJixjEJG7iebjptum26bbptum26bbptum26bbpduh26Hboduh26Hboduh26Hbodp4b+l4vDqIRnTiJixjEJG4i3QbdBt0G3QbdBt0G3QbdBt0G3QbdjG5GN6Ob0c3oZnQzuhndjG5GN6eb083p5nRzujndnG5ON6eb023SbdJt0m3SbdJt0m3SbdJt0m3SbdFt0W3RbdFt0W3RbdFt0W3RbdEt6FZZsnahEZ34uQX+20UM4ucWXriJ52FlycVBNKITJ3ERg0i3pFvSbdNt023TbdNt023TbdNt023TbdPt0O3Q7dDt0O3Q7dDt0O3Q7dDtPDf0vV4cRCM6cRIXMYhJ3ES6DboNug26DboNug26DboNug26DboZ3YxuRjejm9HN6GZ0M7oZ3YxuTjenm9PN6eZ0c7o53ZxuTjen26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26LbolvQLegWdAu6Bd2CbkE3ZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYkswR9r9+vhTj6Xi8OohGdOImLGMQkbiLdNt023TbdKksyCidxEcvNCpO4iechsgQ4iEZ04iQuIt0O3Q7dznND3+vFQTSiEydxEYOYxE2k26DboNug26DboNug26DboNug26Cb0c3oZnQzuhndjG5GN6Ob0c3o5nRzujndnG5ON6eb083p5nRzuk26TbpNuk26TbpNuk26TbpNuk26Lbotui26Lbotui26Lbotui26LboF3YJuQbegW9At6BZ0C7oF3YJuSbekW9It6ZZ0S7ol3ZJuSbek26bbptum26bbptumG7NkM0s2s2QzSzazZDNLNrNkM0s2s2QzSzazZDNLNrNkM0sOs+QwSw6z5DBLDrPkMEsOswR9r9sLN/E8rCz5Xuju6Hu9aMTPbZ/CSVzEz+38CpO4iedhZcnFQTSiEydxEelmdDO6Gd0qS04UDqIR/9z+HrEXTuIixoe1Dl+WNG7in5t9r0r06nttHET7sPbiy5LGSfzcRk3ny5LGJG7iebh+xEE0ohMnkW6Lbotui26LbkG3oFvQLegWdAu6Bd2CbkG3oFvSLemWdEu6Jd2Sbkm3pFvSLem26bbptum26bbptum26bbptum26Xboduh26Hboduh26Hboduh26HbabVbfa+MgGtGJk7iIQUziJtJt0G3QbdBt0G3QbdBt0G3QbdBt0M3oZnQzuhndjG5GN6Ob0c3oZnRzujndnG5ON6eb083p5nRzujndJt0m3SbdJt0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0W3YJuQbegW9At6BZ0C7oF3YJuQbekW9It6ZZ0S7ol3ZJuSbekW9Jt023TbdNt023TbdNt023T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",
      "is_unconstrained": true,
      "name": "is_emitter_registered"
    },
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "14067204867181196045": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "9921926525851912681": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [
          {
            "name": "message_ciphertext",
            "type": {
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 17,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec"
            },
            "visibility": "private"
          },
          {
            "name": "message_context",
            "type": {
              "fields": [
                {
                  "name": "tx_hash",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "unique_note_hashes_in_tx",
                  "type": {
                    "fields": [
                      {
                        "name": "storage",
                        "type": {
                          "kind": "array",
                          "length": 64,
                          "type": {
                            "kind": "field"
                          }
                        }
                      },
                      {
                        "name": "len",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "std::collections::bounded_vec::BoundedVec"
                  }
                },
                {
                  "name": "first_nullifier_in_tx",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "recipient",
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::messages::processing::message_context::MessageContext"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "H4sIAAAAAAAA/+y9CbwdR3Eu3kd3sa50paN9t3WuJEuybMuLvIFtRd43yRaWN8wqW/ICBhlLAgwkOICBEIgBL2Bs2fLO5gUwYJaADEnIvpEX3iPhkUcWSAIEwpIF/uTP2FP3fvc73/Tpmem590ia+f1snTtdXVVdXVVdXb1Mwz37NNN/r79h25Vbt29/ySt++b/NV2+9+JevGmlRb/rvAem/yfvpbvRjsC0X9DRywI6ulINGw1VPY4KrnkaPq55Gr6ueRp+rnka/q57GAa56GhNd9TQGXPU0JrnqaUx21dMYdNXTmOKqpzHVVU+j6aqnMc3lp1GEznQ3NnRmhMM+g3udeJeH3kxXfR/NctXTmO2qpzHHVU9jrquexjxXPY35rnoaC1z1NBa66mksctXTONBVT+MgVz2Nxa56Gi1XPY0hVz2NJa56Gktd9TSWueppHOyqp7HcVU9jhauexkpXPY1DXPU0VrnqaRzqqqdxmKuexuGuehqrXfU0jnDV0zjSVU/jKFc9jaNd9TTWuOppHOOqp3Gsq57Gca56Gse76mmc4Kqn8RxXPY3nuuppnOiqp3GSq57Gya56Gmtd9TR+xVVPY52rnsYprnoap7rqaZzmqqdxuquexhmuehpnuuppnOWqp3G2q57GOa56Gue66mmc56qnsd5VT2ODq57G+a56Ghe46mlsdNXTeJ6rnsaFLj+NInQ2ubGhc5EbGzoXuwJ0LiGCyYaGZMNBsiEgWbBPFtSTBe9kQTpZME4WdJMF12RBNFmwTBYUkwW/ZEEuWSxLFrKSxaVk8SdZnEkWT5LFjWTxIVkcSJL3SXI9SX4nyekkeWzJ3aFf/pckL5PkYpL8S5JzSfIsSW4lyackOZQkb5LkSpL8SJITSfIgmdwnk+9kcpxMXpPJZTL5SyZnyeQpmdwkk49kcpAE70lwnQS/SXCaBI9JcLful/8lwVESvCTBRTL4J4NzMngmg1sy+CSDQ+K8E+eaOL/EOSXOIzHuxPgS40iUN1GspNMvdtmPdW7G/pubL3v29cS0eAJUy7EfpDGRyOWrf9PHJzLCXPXdM/WTOhOL1b/E6g8Uq/+M+ibPC6E+8mJ4e9J/XwF1X0E0DeZxgHmcYIzfYvJ2LyzZ3umDbnQbDYcD3iYVwz0D22RPD71D/AOuVN83GoTP6HH7zDYGAcboNaisV/BpZX1QZvJPXN8qgOO+nUhlxkvyvILKeqDslem/1ifIVw4ZbSupL+sq1JdT9kZ96aWyGPqCOFhfDEfyPE5l/VD2BJUdAGUfA9rHwu8L0t8lfdKwDy84Bj0TEjB9xGX82tND/yaPyclkP1HAW9kAlKHsk2cSvO8RuA6gegZ/TPrv1PRf7Bur3xT0+4m+4lvpZkPg6hHvDD6Rz+HAs+E8DWBbLujpsbqnq7o/3v61h//oXZ/4nQ/ueOShO6Z/fcqdkw+b9Mabb/63hd9f9IEf3PyA1T0D2tFwwbT7rf6ZivbaT/dcfs3H/nvb5LPe/Phrvv5/zt85ZdHmLy1++0OX/+57Fv/zS95qdc9Sdb/zzrve2Hz8vbtbh/7JT/rPuuW7L/nROX0nfP1P3jD/y2/6+T//4Fare7aq+5eX//wbTzZvfd1r3/WZ15+wcubmj976tR/+y1f+6LHmj/7fo6/62rFW9xxoc579tFb/3GL1h2O884rVn2D110P9IjHmhmL1p1n98+Fly378+oMf/MYp7/qTI//+55PesWHzW1675je/eun3XjfvkYP/8WWPLvrodKt7gar7rR2nvWfH3Fcc972Jf/auo+5beOA3f/zIk9/+6Y1bT/jut7/zqaEfWd2Nqm6Hx+o+T9Sdd/SK51z//j+f9bcrl/zNuj0fXX3b/B8vO+lvnzr7vh/89x/8J9S9MP03p7yG+2tTsfq9Vv+iYvWH/cPFUD+HjQ/ryyXF6g/Tv7RY/WH5XQYvW/46wyGM1X1+eF17+qzu5aLuqpMGfvDQO37tZvd3j/zrb/101efXHT79oFOmr/6ru/564StveMH8H1jdFwBDOfpsUTImJGPburTRyRR+WVq4c8e1112748ZTtm/fesOO07a94vrNO6694rqtF9yw+crrtl6y9Ybt1257JSNs0N+nZbxP6MwbTeesrTsufvbXadteuWPra3f0EV6ORQfo70n092T6m+Mze6/ivJDHYq4phE/961x7jJs8Nk43CRe2x+KsqVCWQ683Wv1msfpbrf60YvVvsPrTi9W/yurPKFZ/eC40s1j9V1j9WcXqX2v1Zxer/0qrP6dY/aut/txi9VtWf16x+tut/vxi9Tdb/QXF6m+x+guL1b/S6i8qVv/VVv/AYvVvND9zELw0H2K4F8P7HP7/wBA/hfgHiJe8MWGD8Bk9bh/OxVFWWLcpynw+ske8m+DB1YyIa1pEXNMj4poREVfMNs6MiGtWRFyzI+KaExHX3Ii4Yso+pg3N61Jc8yPiiqkTMWUfU78WRMQV07Zj6sTCiLhi+uhFEXF16/hocZbFDhhrNDL+NTr8zugMEK6GKxb3tIge82f0Jrr2duWgNyzHIUFPxVkGvySQv2Rubf2fzt9P33rFzqvXb7va0cNT6jMyWFzkRrPf8rDGeBv0H79n3D0CFp+keeaK0+aduXXHlddctPnqq7du+WUjt3MNxnR6xntTyiFR1zp9CXHackHPhBClRvwDxEtRpVZKg+1DpTFnlkp1/bbNW07bfP32nddtxSVSVFOm0iCs+E71aQM4w3eTCO50+nu9qOcEbtSlpVCmJGE4p7r2Ni3NqMcmy+8mCPglhGuJqGe893jqIw6sxxrj0+oQrbR2JE/TZbc/ZCpc0HpmFbWeslNhn6yTh4eEpcXozfTpKOI0fkzWy0SZ4To4/bs/A5fV7SX430//bRJc8mwkGssEv/gOlzq/TLyjbFlPysgR8Rlf+A7xD7hSetnw9Ru2j/VkWTF6M0LkjvyYrA8WZYZrefp3fwYuq9tL8P8r/bdJcMnDenKw4BffoZ78OfGOsmU9KSjH4G0uhn/AldLLhq/fsH2sJwcXo7cuRO7Ij8l6uSgzXCvSv/szcFndXoL/Vvpvk+CSh/VkueAX36GefCP9PTGD35YLeq5Tss5R/zUTXbvsctTfYfVXFKt/jdVfWaz+663+IcXqH2n1VxWr/6ume4fCS7bzw+B9niXUUDs3/APES1E7P4zocfs4hX644KUpyjiFfrigc7igo3BNi4hrRkRcCyPiakbENa9Lcc2KiGt2RFxzIuKaGxHXsoi4Yup9t8rr4Ii4Yurq8oi4VkTEFVP2Mds4PyKubtXVlRFxHRIRF28vx/igkf47UdTLOzdEfMYnvkP8A8RLTnoNn1ywfTynWV2M3vQG1Ud6iNP4MVkfIcoM15Hp3/0ZuKxuL8EflQq0SXDJw3OaIwS/+A7nNIeleKcKfjm/k1cfsT7LCOuxPpbpL8RnfOI7xD/gSul/w6cfSi7WviOK0ZsW0r/Ij8n6SFFmuI5K/+7PwGV1ewn+FNLHI4En1scjBb/4DvXxpMZo3lG2rCcF5XhGqJ4Y/gFXSi8bvn7D9rGeHFmM3ukhckd+TNZHiTLDdXT6d38GLqvbS/Dnk54cBTyxnhwl+MV3qCfnpHgnZvDbcmEP24jhQNwol/B+aPwwVM8M/4Ar1e8NnxyVvVn7ji5Er/ED1g2khziNH5P1GlFmuOwIVX8GLqvbS/AvJD1DGqwbVob84jvUs0vJH6FsWU+KydGdGqonhn/AldHLET1R/abszdq3phi9U0LkjvyYrI8RZYbLjjD2Z+Cyur0Efy3pyTHAE/ujYwS/+A71ZAv5I+Q3eVou6GkoWeeo3yY7xGG4j4X3Ofrxf0L11PAPuPZ+LKKnxxK9rH6wth8neGmKMpQxliGd4wSdGleNq8ZV46px1bhqXHs3rqNrXPsErv1Bv2obqvux9hO1Pe6tuGr9qnV1f9TVOp6o5VW3sZb93oqr1tVaJ/ZHedX6Vffj/oirtqFaJ/ZH2dd+tbahWl41rk646rlV3cbaR9e6urfiqvWr5qvGVdvjWLaxxlX7nHocqttYt7H2ObW86n6s9WvvxVXnOuo21j6n9hM1rlrvaxuqZV/bUI2rm3W1jidqnahlX8t+LHHV41Atr9qGalydcHW7Tti9sHhn2FKio+7nOtZDB+sb3KCo10j/nSj4S+i0XNATfG+Z4R9w7W3OQa/hk7+Si7X9eMFLU5RxPx8v6Bwv6NS4yuNa06W46jbuG/LaH/iqce0b9lj7iRpXrau1vx9Lvup+rNtY61c9duytfNU6Ucur1q+6H2tctQ3VOrF/yr72q7UN1fKqcXXCVc+t6jbWPrrW1b0VV61fNV81rtoex7KNNa7a59TjUN3Guo21z6nlVfdjrV97L64611G3sfY5tZ+ocdV6X9tQLfvahmpc3ayrdTxR60Qt+1r2Y4mrHodqedU2VOPqhKvWiRpXjavGVeOqcdW4alz7Oi67twzvDDuW6OS9Hw3rG5y6myz5r+WCnosmijbkqP8Sq39CsfqvsvrPKVb/tXZ32XPhZSP913CfCO97wnEf1SB8Lq2P7xD/APGSk97wvW0nEj1un+mFtf0kwUtTlLGOnCTonCToKFwrIuJqRsQ1NyKuhRFxLYuIa35EXLMi4poZEVdMnVgQEdfxEXHNi4jrhIi4pkXEtTwirpi2vTIirpi+MKY9zo6IK2Y/roqIK6ZOxJR9TNuO2caYOjEjIq5u9RMx+dofYqZ6TBs/2ce0x+kRccVs43O6lK+Y8UTMNtpYq+bCyX8tF/Ts5Lmm4UDcJ8P7HPPetQ3C59L6+A7xD7j2dhaZZ59M9LLkam1fK3hpijKeZ68VdNYKOgrXioi4mhFxze3SNs6KiGt2RFzLI+KKKfuVEXHV/ZgP16qIuGLqxIKIuGZExBXTf82LiCum7GPqakzZd6v/iqmrMfVrZkRcMfsxpn7FtKGY+jUtIq75XdrGbo3lYrYxZjzRrf3YrbHccyLi6tY4J2aMWccT+4YNxfQTMfmKqV8nRMR1YkRcMWUfMwawsdbyQCdAvUb6b8kc2FCD8Bmf+A7xD7j2voyVA8P2mVysfWuL0WuF9APyY7L+FVFmuNalf/dn4LK6vQR/bf+z/zYFjSOIhpUhv/jO5NP3y/+2pHinCn7Z5pTcTxZ4m6I+ywjrsT4W7K+eUH00/AOulP43fPqh5KL0w+qqfmX5h/arDxfnha08eSaKejnk0Rsqf8M/4Er1d8MnF+Unre3rBC9NKkuejQDHZT3i3YQxxsX9lTwt532sO9pkYbwh3lPgfY5+6QvVA8M/4Nr7pYgenEL0smRqbT9V8NKksuThvjtV0DlV0NlbcKEOmWxQlqwXWC9HP00P1QvDP+BK6WHDJxdsH8cLpxWjN61B9ZEe4jR+TNanizLDdUb6d38GLqvbS/B3UbyANDhesDLkF99hvHAHxQvKhorqI9Y3uH2NzqCox/ZVUP+C/a7hH3Cl7Lnh03clF6XvVlfpKcs/VE/3Rlymf6d56Pj8iqKD9U+r6USns7YknbWBdNaVpLNO0BkU9dgPoZ6G+4XG34X6IcM/4Er5vYbPDpVcrH1nFKLX+GaD6iM9xGn8mKzPFGWG66z07/4MXFa3l+D/nMZ5pMHjvJUhv/gOx/k/onEe+eV5aV7/h/VZRliP9bFYf7lmqD4a/gFXRv9H9FHph5KLte/MYvSmhvQv8mOyPkuUGa6z07/7M3BZ3V6C/zvSx7OAJ56vnCX4xXeoj3+T4p2YwW/LBT3nK1nnqP//Jrp22eWof5TVP7tY/d1W/5xi9Q+x+ucWq/+U1T+vWP0zrP76YvU/ZfU3FKv/61b//GL1L7P6FxSr/yKrv7FY/ZVW/3nF6q+x+hcWq/8dq7+pWP2zrf5Fxep/xupfXKz+9Vb/kmL132P1Ly1W/zSrf1mx+j+x+s8vVv9Wq395sfo/sPovhPp51lSs/ouL1e8xfl+ELwVPht/GuhcAfCPjX8PFZUZrgHDl5L3h4x3543jpRUAP25iF60U5cU0UZUX65IUuu12If9DDi+LzEPhdts0LIuI6IyKuaRFxnRkR11kRcZ0dEdc5EXGdGxHX1Ii4zouIa31EXBu6FNf5EXFdEBHXxoi4nhcR14URcW2KiOvAiLguiojr4oi4LomI69KIuGKOHZdFxPX8iLguj4jriC7ElTymqyXzHeeUzFc8t2S+YkPJfMWmkvmGU0rmG84qmS84vWS+YL3F2s+Dl430X5ULyBH3n98gfM7p+ZPhHyBectIbnj9dSPS4fbzeuEnw0hRlbCObBJ1Ngo7CNTsirkURcc2PiGtZRFyzIuJaEBHX3Ii4ZkbE1YyIa16X4oqpq3Mi4oop+7Mj4oqpqzHtcXmXtjGmPZ4YEVdMG+pW2a+IiCumn4g51sb0EzFlH1Ne3apfMWOTmP0YU/b7g59YGRHXORFxnRcR17ldimt9RFwbIuKKKfvju5Sv8yPimhoRV0ydOCMirgsi4orZjzH5iqmr3eoLj4uIK6auxuzHmHx1q7xi6urGiLhi6mpM/7UqIq6Y8df0iLhi5hRixuQx5woxc48W31se+3yo10j/LZnDn9ogfMYnvkP8A8RLTnreHD62j/dGbypGb0pIPyA/JuuLRJnhsrXb/gxcVreX4H96wLP/NgkuedjHXST4xXe4N/qHB4zmHWXLelJQjotC9cTwD7hSetnw9Ru2j9d6LhK8NEUZx8Sh8la4pkXENSMiroURcTUj4prXpbhmRcQ1OyKuORFxzY2I6+KIuGLaUMx+XBQR1/yIuJZHxBXTtmPqV0wbiulX9wfZz4yIK6aPNl9o5xIxnllMdPLG3ljf4Eqed7mw5HmXS0qeV7mg5HmTMy2uej68bKT/qrMkOWK8X28QPud0TGn4B4iXnPSGY8rLiR63j2PKFwpemqKM9w+p8xAvFHQUrtkRcS2KiGt+RFzLIuKaFRHXgoi45kbEdXFEXNMi4oop+27V1eURcTUj4oqpXzF9zoyIuPYH2c/s0jbO61JcMW17TkRcMWV/dkRcMXW1W2OAmLjqcTsfrkURcdXjdj5c9bg9frKvx+3xs+1uHbdjyqtbdfXEiLhiyiumz4kp+xURccW0oUURcXWrj+7WeCJmG2PGvjH7Mabs9wc/sTIirqkRcW2KiCtmnvyiiLjWR8R1XERc50XEdXxEXGdExHVJRFz7g+zPiYjr3Ii4NkTEFVNel0bEFVNXY9pQt+p9t7Zxf/CFMfmqx459Y+y4LCKumLFcTHltjIjrgoi4Yo61MXUipry6dexYFRFXzDnf9Ii4Yq7pxMwDxMxPxNyfw2dscG9YI/235J3HUxqEz/jEd4h/gHjJSa/hkwu2z+RS8v7fwQbVR3rqjl+T9YtFmeF6Sfp3fwYuq9tL8OcOPPtvk+CSh33ciwW/+M7kk5yxOWNgNO8oW9aTgnJcFqonfB91Qb303ket7Ef1m9VtijLOP4XKW+GaFhHXjIi4FkbE1YyIa16X4poVEdfsiLjmRMQ1NyKuiyPimh8RV0x7XB4RV0z9iimvZRFxxdSvmDYU06/G1ImYfrVbbTumPca0oUURccW0x/1Bv2ZGxBUzBuAzXBgv8xmuvHdgY/2s741YefKU/B7NexqEz/jEd4h/wLW3uUjMruSv5GJtf4ngpSnKOJ/3EkHnJYKOwjU7Iq5FEXHNj4hrWURcsyLiWhAR19yIuC6OiGtaRFwxZd+turo8Iq5mRFwx9Sumz5kREdf+IPuZXdrGeV2KK6Ztz4mIK6bsz46IK6audmsMEBNXt47bMWUfMwaI6aNjxhPdqqv1uD1+frWOyfPhqmPy8dOvOi4cP/3q1rgwpry6VVdPjIgrprxi+pyYsl8REVdMG4o5dnSrj+7WMS1mG2PGvjH7Mabs9wc/sTIirqkRca2PiGtTRFzHRcQVc30oprw2RsR1fERcZ0TEdUlEXDF14ryIuGLKPqZtx7THmDZ0UURcMe1xf9CvcyLiOjcirg0RccWU16URccX0hTF9dLfqfbe2cX8Ya2PyVccm+8bYcVlEXDHjiZjyihmTXxARV8yxNqZOxJRXt44dqyLiiplTmB4RV8x1q5h5ppj5r5j7C/kMJu5tbaT/ThT1EjotF/QMNgif8YnvEP8A8ZKTXsMnF7VP2tr30mL0JjeoPtJDnMaPyXqzKDNcV6R/92fgsrq9BP+Hk579t0lwycM+brPgF9+ZfJIzmL87aTTvKFvWk5fC+xxyfDpUT16a/h5wpfSy4es3ZT/Wvs3F6O0JkTvyY/SuKEavx/pqi8BtvGxN/+7P4MXq9hL8N0gfrhR1mlSWPKyDWNYj3k0YJ1xbBC6Uo/VJYhtfTWWh9D/5r+WCnqPZLxgOxF1QFy4NtS3DP+BK6XqD/ZjRy/IxSo+sblOUcb6saN8nv5d3Ka5mRFwzI+K6OCKumPKaFRHX7Ii45kTENbdL2zijS/laGBFXTHuM2Y8LIuKKaUPzIuKK2Y8xdXVRRFwx9WtaRFwHRsQVU++71efEbOPKiLgOiYhrVURcMeUVMzaJqV/dGhfG1PtujeXmR8S1LCKu/SGW61a9jxmb1GNaPlzdGst1qy+MGcvF9IUx+zGmvLo1/jorIq5ujb+mR8QV07Zj2lBMecUch2LaULfKPqb/ipmX69bcUEz9ihn7dmuM2a1jx0sj4rKxY5BwW3nylFxvOrBB+IxPfIf4B1x7O3PQ8643vRTeFV1v4v3s3eIPY9pRt+bKY/qwmLjq9aZ8uGLm5mLaUMx+jLkeEDPW6dY8TEz9islXt67rdGuOImY/xtyrENPf892pGBstJjoqDrnCQwfrG9ygqNdI/50o+MsRL93cIHzGJ75D/AOuvc1F4jMlfyUXtXfN6jZFGe/D9+3fQjoK1+yIuBZFxDU/Iq5lEXHNiohrQURccyPiujgirmkRccWUfbfq6vKIuJoRccXUr5h8xezHmHzF9KsxdSJmP86MiCum7Od1Ka6YfmJORFwxZX92RFwxdbVb44mYuOoYYPzGjjoGGD++6hhg/PqxjgHGz090awwQU17dqqsnRsQVU17d6idWRMQV04a6dezo1ti3W/VrWURcMfsxpuz3Bz+xMiKuqRFxbYqIK2b+/qKIuNZHxHVcRFznRcR1fJfyFbMfY/J1RkRcMXUiZj+eExHXuRFxbYiIK6a8Lo2I65KIuLpVV2t7HL82dqt+1eNQrfeM67KIuGLGmDH7Mc/dQ51wXRARV8xxO6ZOxJRXt9rjqoi4Ys5Fp0fEFXPdKmZ+YllEXDH3M1muw/Yf4lx+LdGZKuhM9dDB+gY3UdRruaDnRNu/dxy8bBBe9Mc94bh7G4TPpfXxHeIfIF5y0hveu3gm0eP2mUyt7WcLXpqijHMyZws6Zws6TVG2sQJcEzP4bLmg52LV3znqv5zlaTiQN5yv5ujbeaG6ZPgHXHv/FdGlc4heVr9Y288VvDRFGffRuYLOuYKOwjU7Iq4zu5SvGRFxHRwRV8w2zo2Ia2ZEXPMi4poTEVdMeS2PiOvAiLgujoirGRFXTNnPiohrQZe2cWVEXIdExLUq/T1Wsaqis64knXWCzqCo10j/LRmLHNYgfMYnvkP8A669zbFiESWXvLEI5266ZZw+MSKumON0t/qYRRFxzY+Ia1lEXPvDWNGtcXNMvhZGxBUzrokZ68bUiekRccXUiWkRccWUV0z/1a3zjJj9GJOvbh07YvZjTNnHtO39ac7SbfLq1nE7pm1XMdbafAXnN43034miXhVzNcM/QLzkpNfwyQXbx3O1DYKXpii7AH5jGdLZIOgoXLMi4poXEdfCiLhmRMS1KCKuZkRc07qUrwURcc2NiGtlRFyHRMS1KiKumPKaHRFXTHtcHhFXTL2P6Qtj9uP0iLhi+pyYOjEzIq6Ysp/fpXxdHBFXTJ2IGZvEHLdj9mO3+q+Y+hXTHrvVR8fEFVO/5kTEZbK39Tucj11OdPLOCbH+uWNMR80vk/9aLui5gudvhgNx416vHHPJKxuEzzk9dzX8A66934rMXTcSvSw9sbZvErw0RRnv4d0k6GwSdBSu50TEdXFEXM2IuBZGxLW8S9u4ICKuuRFxxdSJ+RFxxdSJMyPi2h90YnZEXDMi4upW244p+5jymt6lbVwWEVfMfoyp93Mi4oqp9ysi4oqpEysj4oqpE3X8tW/46Jhj7fERce0PvnBVRFwxfc65EXGdGBFXTBuKKa+YY1q3xoXdOqZ169wqpuxj2lBMecX00fXYsW+MHTHnVjF94bSIuOqcwvjZUEzZx2zjgRFxdet8KKbsZ0XE1a35wphxTu0n8uGKGU/UfmL8ZN+tfsLiL74zI3laLuhp2PrpefiS8BZcO+5rED7nwtaOzytGz7t2jO0runYca63Kufa7V7oNl+19QNznEx0l540eOljf4AZFPdY/7IMc+nBiqP4Z/gFXSt8bPvkruVjbLxK8NEUZn5G+SNC5SNBRuOZHxDUrIq5lEXE1I+JaEBHX3Ii4lkfENaNL27iwS9s4MyKuiyPiOjEirpj6FdMeY+pXTF8Yk6/ZEXHF1Pv9QSdWRMQVU7/mdWkbY8p+ekRcMfV+WkRctZ/YN/xEzDYeGBFXzHiiW2W/MiKu2oby4Tq+S9u4P9hQTNnPiogr5hzZcptTRZv5TsDjBZ3jPXSw/vEeOutK0lkXSKeK9kwU9VrO+/TaD86LGm7Ei31VRU7Y8A8QLznpNXy6qHKi1vZLBC9NKksezr1eIuhcIujsLbiU7mLfc044r81j/Ys8dNaWpLM2kM66knTW7QftUT4g+a/lgp7XWf1LitU/3Gz0SnjJ/gm/hZDDX6wP9U+Gf4B4Keqf1LcesH3sn7YKXpqijL8zslXQ2SroKFwzIuJaHhFXMyKuuRFxrYiIa35EXPMi4oopr5htjMnXRRFxxdTVaRFxxbTtmLKf3aVtrP3XvuG/YrYxpuwXRsQVU+9PjIgrpm13qz3G9NHdOtbG7McFEXHtD+PQ/tDGmHzF9KvdOm5f0qV8xZTXcyLimhURV8zYpFvHtNoex6+N3Tpu7w/ztJg6cW5EXN2q9xdHxNWtuY5FEXFV4aNtTQDHS74D7zmCznM8dLD+czx01pakszaQzqaSdDZ1WXvWlaSzrm7PPtGey0vSuTyQTq0H3dOeiaJeywU9x9ja4BnwskF4C+7bmNogfM6F7ds4oxg9774NbB+vi24RvDRFGc8f1frrFkGnKco21rhqXDWuKLjGaq/MRFGv5bzPFPvBvsZwI16MxavYH2f4B1y7byviZ9VcQ/Wdtf0qwUuTypKHdeQqQecqQWdvwYU6ZLqLfc+6m3dOh/W3euisK0lnnaAzUdRruVHPhD+b+eKd/Q++6MrDV0w544fzZtz25l/5nXe96VdWHMZ6YrgR79XwPofO9obaiOEfcO19VsRGriZ6WTpibb9G8NIUZXyvwDWCzjWCjsK1NSKuNenvfU2v9ys7/fH2rz38R+/6xO98cMcjD90x/etT7px82KQ33nzzvy38/qIP/ODmB0va4qVW/5pi9Wda/WuL1Z9h9V9WrP50q//yYvVPt/rXFat/itV/RaH6jeG+fyW8bQXVHWn7tmFsuXhfZ/WvL1Z/sdV/VbH6v7D6NxSq3/iB1d9eqL77/6z+DnjZsh9rP91z+TUf++9tk8968+Ov+fr/OX/nlEWbv7T47Q9d/rvvWfzPL3mb1d1ZjPag1X91sfqTrf5ritVfaPVfCy9bQVXdBKt7I9CeEF5/otV/XbH6x1n91xerf7zVfwPUzyG7ltX/1WL1h9v/a4XqN75p9d+ITKX/Lvvrzx7wHx++pffj//sH217zk1W3/uFZ7/rCR056758cvvamTX9/x/c3WN2bCtF2U6z+rwvaHfge9nVvGn6TL4dl9d+cm7brtbpvUXW/88673th8/L27W4f+yU/6z7rluy/50Tl9J3z9T94w/8tv+vk//+A2q3uzqvuXl//8G082b33da9/1mdefsHLm5o/e+rUf/stX/uix5o/+36Ov+tqwrr41Bc/Z5llW/23F6vdZ/bcXq99v9X+jWP0DrP47itUfsPq/Waz+JKv/TnjZCqrqmlb3XaLuzKPc1xZ/89gbD51z3LYLXv2Wb1706K/NeuCQbzfnfX/nSa/+r7/dZnV/S9Tt8Bzb98v/3Z0umFoMOjEtTH4Pwe/kv4H076SexaAtgLG6vQT/s7Uj9Xan9AapjuFwbiROHYD3OfpifoPwOafnfYZ/wLW3vci8b4Docft43jdZ8NIUZSvhN5YhncmCjsK1KiKuuRFxXRwRVzMirtkRcS2IiGtWl7ZxTkRc3apf8yPimhYR1/KIuGLqV0x5LYuIK6Z+xbShGRFxxdSJmH7V9r8OinqN9F+LAwbhfY5xeUKD8Bmf+A7xDwg+i8QBg0QvSy7JO+vrnTuuve7aHTeu37Z5y2mbr9++87qtExC1Gx0NsVQQK75ruNGtx7IeejeJ4M6kv9eLek7g7gG6B0GZkoThtOgT23RQRj2UhRPvJgj4QcI1KOoZ7z2e+s6NaOwA0U+e8dLYgpGyV2OxfRy5HiR4aYoylGGWx1ARcl6+JrsR75Ra0ulbr9h59fptuBbzzNNLf5+RweI8glufwVpD4G3Qf/x+Hr3rcX5T9U2WQlQmedgZ42SnRXRqZ1w7473DGfeIeqwxU8V73jKZN5S5XNBTdF5cks6LBZ2Jol7Lfvz6gx/8xinv+pMj//7nk96xYfNbXrvmN7966fdeN++Rg//xZY8u+uiMZ1I300fzi/KfSPxav2PKR/VXL8GfBSmfA1J6Cb8WcqcWdurO615+4dYdN1y79dVbf+mrtzt6OpnF+fT3BaKeekLG8IKOJ9jRGf5YY7hSrayxMtzRsUKgVBArvmu44o7uAvq7iKPrFDWwo/M5J+yViYKuvZvgsh2RcmKca/Q5Mufqobm4xu7PQ3OIxoYOzVkamzU0c70+l63hvQS7LB0ySmr2qBuimcd6DHj2qceAvWUM6BH1WGN8Wh2ildaO5Gm67PZPdO3yaNmPb+047T075r7iuO9N/LN3HXXfwgO/+eNHnvz2T2/cesJ3v/2dTw39uKR1XVLSK1yceKITKAjGrAVP7obSv7PWPa1uL8E/cMhIvZMgCD44LU8t75LN1127ZfOOrWe88lU7t+7cuuX8bTu2bj/llVvOePXWV+7IHRKfRX+fLeqpxwSBjZ9CZZOgjA19EvHI71ipGqINjCtL4Iarl+BPT4V8wC//O/Oy0TiVIaHSr/e01TfDYznkneE1AukcXpLO4YKOL6gs6iwUz5y/wv5M+vh500feo2Fj/6Oj2ZD+20vw7wGDu4gMHGlnpSVxEMFBLSv31+9GZIIwEzL4ez7o5zmknxOozdhOxfMg0GC6ye81GTy8mEKrKdT2lgt7VGjF/gL5OZL4R/kqmbNeYX1OR2cFIPiv0eF3TEfxbHQGI9LBwauV/ja5YZ9w8DWF6PA7X553CrWnIXhI9O+66Zom2qPyW70E/3ywx20ee5xA7cc+GKSyrACK/ViITwzxCaFjkMG/JucYhH6Nx6AJAfz1unabSn4fAW3OwuXEO4PH8W8SwQ4S7GQPbJbfSn7bZvSq7cum6Mq+jiH+8toX1g+1r7fmtC/b+M72dTrY12+QfeFiPcsVZcOwZxLsNGh3KN4+qps8/OHOJuFFnXy+G91ew/vj6SP4353+HhS0yuoObsph3cFx71j4jWVGh98xHaxvcGwLrDvvn65pZmXoWXcM/psgy7umZ7dxGvEVQ872fga8Z7rTCXYmweImmSbxOIPqqn878dgUdGYS3lke/puEZ5qoN+h0W9W/ofxOF/wOOs2/+jeUDuK6nOhk6e6jpLuzoEzprh066SX4J0F3n/CsZrHuYlvXUBmOCejH5s0YzTNu9DI5vUDUNfg5BI84kofnFrZCljW3sLq9BP8ZMbewts0S9JK2fW66bhv2B24EnEO0Df7/QH98gfoD5WX9MdW1y4ZtYC7wwrBnZsjg94CPL0/PpsV2odqY4Pj96dlwZwo4xjFByMBwKL9g9aYKemy7s4nGLA+NmaKeosH+GGU2F+ibbszrUD5XtM2JdxME/OyM9jpBe04HvLMEHuXf51DZdFHGvgvbi/GQ2Znyiej3HvXYS5ZNKL2a7eGdN7rOFrzP8vCu5If+wxc32N8hY31D/G384eFL9rGm3/1OjyNWt5fg/9GTj5kJ7ewRfL0qA+d3AOd6wql05lh4x9vffP2E/Ex12XaueEdfwu98sYwTPKAvVDqbFcexPBQPMwQe5Tf5A9sqDg+1TYyn37+fzjF+HmmOcQTMT/9nL59jcM68G+YYkwlPPcf4JW8UrxedY/SC7s5KceadYxxNZZ3mGFZm8p0g6k0hfo3eyTNG8C0kfA2ghXqTPHzB0QzA70SbeF3B4BenP5Jx74J03Jsq6p9EeFkn+B3rBNd3nnaqMYzl9tyU74mu3RZzrIec4tN/wz2rIO4Q+1E2r+YPA6KsN4CXV/7H5jWb+1/3B2xXxgu/C4llThLwJiueN7dc0HMybt5wRFutmc2isj4oMx4SnV5F/M0uyF+I/BB/U5S9Fn7n6QuFa0pEXJML4pruRuso2qHy95y7UXnmpB9fQH4bbeW5xGtD8OrzQ1zfib+VH1LrNslzGfkhzLPn0K9jfPGJ4Z5ZEHeoH8qKCZCvAVEW4oeu+fkp13/pwq8e2HDt/rZHvGM/pHTyuQK+pJ0fqfwQ+xr0QzOpDP2Q8aD8UMEx5cgQ+SF+lUtiPxTaFwrXlIi4JhfEZX7It7aAfojju2miPeiHeD3rCojZXjRjNC60J/Z3Kn7jGFOVNQXOhParMuLP/vTf50EZrweqObqDNtg71HWsw+voBv8ykM3VxB/aNLYT+VP9hXtsrpuRDTfNA4f9wv2v1sF9sX9ov/BYsYPGClyrz+ED5B4ew5W0xeKfdKPiWVt3bLpm8w1bt2zaeuUNW3fwTsQG/Z21awDr8WM4+DTlAfQ371ibQn83BZ5ONNUOkxPgN9MN2WFyguB5POmcXJLOyYKO8kqNjH+NDr/z7SI8mdqDlsTXcebdvYH1p3jorCtJZ10gnb25PWoEsj4uGdUOhegR4h9w7W0ucqCiSfSy5GLtm1aMXqtB9ZEe4uRoRGU4DJcNmv0ZuHBkRvgPpD9Utu8IohGajU5Gs9tpJMVRvAVwd1MGT+0GxizvhdQOgz9qxUi9e2kmqHbDqZ3fp7jRvOTd5Y71Da6mE4/OqSXpnCroDIp6jYx/jQ6/YzqKZ9+4WfKIy/RQf2n4x/pIZ8nd59NCxi3kR0XavIpsvrE/AxdnkA3+i+QvkQb7SzWe4Dv0l5/1rDpk7apFvIMCr4qvWEaoHy3g53cC/DLqW5Zf/oflI/W+4vHLkwLaqE5pKD/BfT2lA64LCRfW98VVkwLo+OKqSYF0QtrjozOe7fHZAvbBRR6+ONaZ1gHXJsKF9XlX2gQPz3lPrWB93ymHZkk6zUA6Y9WeiSXphJ4OmVySzmRBZ1DUa2T8a3T4HdNRPHfyt98jf6tOpCDNDem/fCLlL8Hf/oD8bd72l5znBMclhn/AtcuvSFzSyT9wXDK9GL3huMQ3L0J+eLWGZZv8p3a3IS5csUf4X1BcgjQ4Lpkh+MV3GJf8F83jqtoVNVb22CI6WfbYP3PkPfZBqD0a/GfBHgdSnMoepxHPKJvJGe1Buj6fqGJyn600PfBK11VMUOHKZLBf4V0QBXd7DPsVtZqo7GYywKbZ9FO2bj/q6BNO/2Uq/cbrd2StUrJtzSS8rHOqD61tvKNngqCRPBsycLFfmk7v1Y6hTjx1gu1UrmKCGRntdC4sJlCrU4wr61So9U8vwS9MC0JPhaIOrfe01Xe9CI+Z3IZJGfV+1Wn+rM3Ik2qzwS/xtHlKhzbz/Av5m0L1MCZVJ/nx/UTXrgOIQ8n4NDea97z6hPXHakw7jehkjWmraUzrdBLVPiXDJ1EfgTHtKBrTVCxfdft5/jFRtAs/i8PzCNxlqXDyLkiDf27a9pLrHXJllnP/DcH/M1fNUJ+qtvv61ODvhD79lYA+9dmH75Jf5QsGPfAqb6ByvL74tFyc3/i7EB1F/APES059GI43VJyO7Ssabxjeb0KDkP9O8QbX88UbDJtlexwDNOl9p3hD8ZQFWybemJbRTufCxgc15+HrtXLqS8t4mQR8qLlj1g0aE1y7bSl4FWOo3Y7si3qdHodbUI7wmyCWuJB2l2P90zP4cy6sL7D+WI1VpxOdqm/5VvlxPMGMZUYny8c2RX3fet20knSmCTqhum6f4esUE22l8dOXd0O6HP+eA+PnNTR+Iu8heVQ17nL7UW98467KzWfFS53sVMXnzyNcefcYYX3frTeKd47LDP5tFJcVXFfdWOEel40hNo741Zqm8TUgykJ2V//zwEl/+K+fuOvPGlTfeOF3Ibmj5wn4knnWDWp3NeZUkwd1pElluLvaeFC7qwvGaxtC5If41ToOf+47tC+aomx9QVy2I1qtPY6XTwq9kcvg35Uz94Ljz3pPW0OudnWu3ec4l61H/0OP4TP5HyBoob4j7G3Q7osvG83roODVfESPh4YT7xouWzZMY4Koa5+XVfmcLN7U+jXimJjBZ4JjPNftzy9J53xBxzcm8b9Gh9/51nnPJzqIs5X+TmzyYYqbmlCm4qab0t+9BH88xE0forgJ6/NaNu+CR5+QPOwDrX7oLZ4G/xjYVadbPLGdPj0LvcXT4D8xBnkmblOva/etyXOO023KyhezDJSetDzwar0JdZl9tm/Pq7XtT+aM8PDZmfnaf24Gzi/NHsH52zlxnpeB809njuDc47GNs91oemz//I7tn+snz6CoZ78nunbdzaGHwRfmG/4B197mIvk0lR9QchkEGsxLU5Tx2KjonC3oNAhXJ74muxH7KfnhM0M5l+DWZ7DWEHgbTquc/T2X3qmmIe5nLg5JK5mao6t8KeFHXnrEO+4yrG9wis7iknQWCzo+XC8VuAy+T8AvFvARVcPKFwEMe2lmjfF2Ug3GnaUa9vQQzeQ3r/5x1zCPUwWOhqdNPeIdd3VD0FJ0rihJ5wpBh6OEH1OUgPRzeMu3mffrh5fs+Qtmqt+G8rJHeX7DPyjoGV/qQ+4hWY9VX/jV+09ces0FDapvvPA7Nkk1i7xCwJfMPr1FZT1wN2HyqMyYynrYO5X1KHgK4C0h8kP8KkvNWY+8GQR1n3ZeXJb16If6PlseK59RBR0fLpUJMXiTTb/TK0Xskwz+FzB7uoyyEkreTryb4Nr9UYpqWG6Ia20G74q24U8edarS4Cr0iX3YT8gnvkP8A669zUWiYWUfSi7qvLvV5Z3VybMR4LL8pW9FoNtxoW4Ounb9bWT8a3T4Hcs5xopgzFPafGdCGVwqS3Yc/MYyw8XvuF+w/hQq6xN01DjUT2Uot/VUpu4mUn6I/XdeP9QQ/HU6TbtslqapTtOiD2e//QLIZqyYld3GrJNJvYJ3lBfHroelNMyXToU6OXybzHAZrk6yW51DdslzEbXF4NeC7I7yyI7HfpUJn+ra5cEnmNWKYIPKnAtbRVKnrgZFPR77Cq6cBY99fEKkYAbUe0LEd9K/4Mplr9FTO7lUP0xzWqZZJ0Cc076O/Rn6uiaV4bg2lcrU/Uc+f6ZWIad6+Bsrv6noXF6SzuWCji9ODNF1RUfx3MmXbSRfplZTse7O9Ddnpw8DX7aJfBnW5/7j2BTHmuTJmqtlrc5MyuDvspQntTqj2rzTwzPScK7dbnjsMvgX0dhVcD4txy4+PahuKShJt/DnawveQ+X9fK3aDZbAdc/nawcI7mz6e72o5wRuzHiqs+6+fQlqrV7NyicKurw2r7586dvjYLz3eOojjqz9Ij0Z9ZK/bxZ1Yt7TEXNGE7JHrGA0OzPUMg1/rHuQphI9bh+3vSl4UXuc+FO7Rfc4Jb97I+FKno01rhpXjavGNQ64fHvKeBaWPHxWMmsvEZYhf76Fa6xvcIOiHo9vBcebqaHjG+9z7i1Gb3h8UxlGJZeS4/cU33iKOHlvny+jo+6tQlxWl++t+nA6S4mp18nM6qFZo3mval+ib8NGlXqPvLfS30m7Pz5L08za/8gzbIM/EGbYn5w1mmc1w86SAeqQ4eA24TkPK8tjr8ks+wX0tUHki1cZld7jrPum9HfTteuxTxc425LVR3uoj9R+zYbgh/fh9UMffZmyIFg/ZB+Yosc61J8Bz3tUDf73IQtymedrLJMy6GVlha7NoPfHQG896IO10xHtkno3U+kd2jPrncrkKfv3jQeopz5dZNoNgcu3L9nq9zvdB4avl+C/Jvo8VM+5Xw3+64H9GsmfyH5FWYXsWkB4lpvSA7XDQmVaWY97BC7sa+7XTrZs+Ni2/tHTr1Yf+xX55H41+O8E9ivGPYYH+W25oEf2K8qK+0CN1wgfsimSeU0etTJyAJWxT8Tfyn+jHoT0uZIv9/mPRZ9z7K/8Quh+5iS/Zve2pBnUTTu23bA1TaE6enwpz4bLvoZvhqjvqG6D3vH1Pcp9+jZ5DQ/RTqcc2X0a/M+EyH3uN3lCtsRjd1eRhLd3sbbEd3JrnOrzmZkvJB8HVU2eszPYaIj6jnA1xLvkUdvUES9HgT7vpkTFJ5UY3vDxHorJaZSqRg5fhOMED74MMPKj2j+Vynwn7wwWRzRUIx7RDH4GtNU3ohntKkY0lBGPaGoGjfAsb98tfCiTJsGj7NWINpXodDJDc69qZoVRJc+slL74IjOffJR+qdPdam+MbxZscFXMgrE9rAsxblhUN9Y0CV7pie8W5U5Rl08XcOb48Yy9BojXNwNSN27gEH5T+ptveThS+ADDOdihbSEzQHVq2ndDnbo9HDMVhtsRXEl9nKL0EdsTkpVRq3uhtupbpeO9/zjD4qwn0sW9GxvHeA8dj9/4fTAVIhpezrieAVmjy2aPxhl6i6rBq/1jaPe8vxb9xYwAXL5YQH1Pb4aHdta355k284nfKzdaVhZpHO9TtoL+mW3F54uTJ0RWqp+aBI+yybufj28VCd3P14Q2s36qzIny4cp2cd/sarJdFUP6fLBv3zfWx33HyMNLYYzg20A67Y2+KQPnlZ5xR7WhIdoQ4ouVbaHv88XZ7BfR97FfVP5a+RH2i+pbjwjP++UM/pWp/GzKXPBWZrlfjn0d3h6oYi/ew23wbwHf/arZGmdfTpw7xnbO0lu1r+s0JplMmq69b7L2iyIutZeY7azf6fmS4eM58hvFHFn5W/ap6G/Zp04WdJW/xW993p/ywfFa8rsFcG8l3VPzZfQ5rHsG/xDo82+kv2P6Db4lCv0Az+t8X71LHvbzWJ+/pBD/ttfwMwmxb3tV9qdyBiX95vCZBBWrqH7AMwnqHALiwtVzw2swVfo1Xy6mk1z5fBe2ke0ZcbMfCInJFL2smOz+imKyZRSToX2x/aONs/2rL1SoOQDHDTOAFxXz4JiN8B8FH/ZFko3SZV+ORX3JQX2ffKpr1/VZAbh8ub7ZAn6WhzbyhXWZdpZNKls02VQxn8K4gG3RN5dMnhBZqX5qEjzKJq/t8jzM95UW1G38QswXM8ZtbAeO22y7UwSvGA+YbmCfvtCNpqmWdvAdj7NY3+AUncUl6SwWdHy4XihwGbzKYVZ8PY6xuBRgkvctD2uMt0H/8XvGraaS+KhuamTw7VxYNzWIvsLVB78vBBi+FBrdy4sIV97Nelifl8KMl2/TFLOge7vVd7zfcBe8huFWlK89KszMOlqIfKkrIUKuwvnsB5835atfOmH4KpfQI5AGr1L9LxLwJa/Cebcawvi6G3XkPO9VOAWv8Hh3iPwQv0qHnwm/8/RFU5RdWBCXXYWD8uKNt1X7GLNlc9ffFSm8sebFhuMfetKJnZbTeOM+8u7b3MztyusvG4F0XlySzosFHd/hgRD/p+gonjsdh/4FhWN9UKZSv69Of/Omy8/CxaGN9LfaAsH9x+MPjpHJw/bKm0IZZlIGf/0pT+o4tGrzqz08YwrNuXa/wOldg5+c8lDSp8r0Ll8LV8F1TME7scbrOqZ8x6F5AoZSQaz4ruFGtx7Leugdb7g6k/4uchxafSakX+D0XUmvRt88l4whXrUpgS9X9I32iEMt6hkOVS/5e4eoE/OiibE6Wl3yuFjwZz/5uFjBqNN7XAzbx21XG5JUMpujF98xMaTjS4zHwDU5Eq7k2VjjqnHVuLoOl5qBDlIZjge2sKhmL5wVyDvzwvoGNyjq8ThS8MKbKaHjCF9401OMnvfCGyWXktmSwQbVR3qIky8Xyvq0LupQfwYu3oBj8BelswHekJo8rNehG4CSGOqCOaN5j3HRpUr4G/xY6z3y3kp/J+1+4RxNM+uoH89kDf4jMJN9yZzRPKuZbJYM+EJqtpHkqWKDq+/4p9J7pG1HsX1HrJQuhB4Nfxn1UafjmHw03OBvgz56BWUbsD4fquh07HgnwVs/hR47NvgbINvgO3bcn0FPZV+SZ0MGvVcDvTE4djxd6R3ac8gxRmX/vvFAnaFSusjHGH1HVxuCjm9DvjrGyLw7136M8U1CHziWYN3I4k/JLfIxxokZbEwT9R3VbdC7aRm4DE/yN6YfQo4xqpPK7CJ+Q4jc12XJUx9j3OuOMZ6ZwUZD1HeEqyHeJU+nY4xssT4RK1GZtwo9AG/wdwqVDvGYTvCgIgGObLPaz1sa1TZPpqMO5icPj2gGvztwRDPaVYxoKCN2OaGZL4PvtJ2dTc13jEjNTEPNMPQYI0dqSl98xxg7HRtj/cI+9R0b80XV+8qxMZONOjbGeqKO24W6fp8uYCTKM6tOl41krbGjD0AZ3pT+5vWyLwgfYDgndmhbiL9TqxbqOAn7O7UHQOmjwZXUx0Glj9j+kFme77NNnWyV/Y+6cEqFCBxGdtIb3zZdXKP9BW31Qzqse3k/m3Sh4F/RWVySzmJBx4frQoHL198Vb/UzFhcCTPK+5WGN8TboP37PuJWZ46O6qTeDb+fCukmps6LTKEmnEUjn+SXpPF/Q4a08P46zTeHNIQueBU+ivBnlZY+aTeHJWaZnfA2IspAtgt9vXvy71/344Q83qL7xwu9CTok9X8CbrHB3dw5Z3aSGJqOttgjyaWMcXowHtUWw4Kmbm0Lkh/jVaRSeBob2RVOUrS+Iy7YI+m5HqNpn8BbB/4IQircIVs2LClXY/gsu5AQvVLGNF/RlDd9Qq+RSckPH8EKVb+EH+eHbVli2qLP9GbisLp9KHkhTITwdSZ4y9+P2zh3NuxonQvoZ8aqFC9bHrK2QU+eObov6SgrWzfoyzMHLR+pNz3EbFutm8q/vyzBWP/TLMAY/J+VJbYWcJNqMiyITM3joFXST32syeFiY8lDSTuRWSE4fID88BqsNdepLK2phcpKHzktK0nmJoBNzM1rTw3PV9thKf6tT1pvhN5YZHX7HdLD+FA+d3pJ0egUd5VNxyss+2mCSp2Q83BvSL6N8OvFSdDxUsZHy93wCEuuqWxA4laViZXU6UuEaiIiLV7OU3mwWuPLKK+JU3Vi8hOAuymCtR+Bt0H/8/hJ6lzVVN9zKJEOyUj6TxPpjbfqKztqSdNYG0llXks66QDobStLZEEjnvJJ0zgukU3SPVVPU35/0YKzas6kknU1d1p51Jems20/bc2VJOlcG0hkrv1PbT7H2rCtJZ13dnr2uPWr1vZH+a1OmglOY4BSi4Y/1CUmVIlNyKTklHE4hdkqrGz9qioayTf6z9H+/86foewn+Nkoh4nSL47DQ6Vkytb6F0mvIL+t9aGpS6b3BKTrrStJZF0hnX2vPGSXpnBFIZ6zktqUknS1d1p51JemsC6RzVUk6VwXSqf1B97Sn0zmRPXM1zaxzIpZm5eXP780bqfdlGiswj8O77/Le8IH1fTeJ8JKBun1H7UDLuoEC+fPdgKNuAOoRdFS6Wi03lDxnGLwZns8ZTipGz3vOUC3D8BII1lVLGiGX9qpzqHn5ipgWNhYPJbj1Gaw1BN4G/cfvD6V3PQIWcY+V6is655Skc04gnbFqz6SSdCYJOj5c5whctXqPwq26aUIG386FdRPWH2u1C7lrqKDHDv4AtuGPdddQpxt2eHZe5qR9lmkgTl78HxRlhsuyCP0ZuHCzBsL/J83OceGfZ+e+k/PJg7PzH80dDYf84qapTtHgzwI25mBdjgaHaUE0+Iu5I7/trFfCnzrTFOLOJgsZKBvl66DVKeqidHoFHcaVJbNt6W8+czaQykydwZgMfCjfxyvMKiPoO6PW6cwUyxJtY2oAbXX1uME3c/LqW9hH+lMFf9Nz8nrhGPM6WfBa4WaW4NnBeG1myXfPHGosSwWx4ju2JCzroXd8IvYs+rvIPXMqB9sUOE1DVA7Yp1lOvJsg4KcTruminvHe46mPOLAea4yql/z9FlHHZwEhGpw8WdujYuCaKXCZZeKl+jksZXaoZRr+AeKlqGX6PkqQPNx232X3WMZbw9Sl+rMFHYVrWkRcg5FwJc/GGleNq8ZV49rLcVkZjtkzqQzHT76XT51oblAZ8jfo4Q/rD3ro9Jeko06hV709n7NIOHaz3NRHa2Z66GD9mdQePFrSSn8ns9Ut8zTNrI8i70x/8x6E/wuz/6vnZbcR5WztYp5LnuiXH8rGGIdP9Hf6MNJN6W8VS0yiMuxrw9GpD15FfaBudfF9mNrgvwJ9sIP6QH1oyGc3ih7rSH8GPGfCDP5GyHZc5jku2cygh/JAOb81g96viuyK0jujXVLvZiu9Q3tlvQuNu0P11Nqm9JQzNuoIKuoBZ2w63cPJR2QN/u2iz0P1nPvV4H8zsF8j+ZPZeW8vUpk1NQ759AD7i7/egn2elYlEXNjXIf06UeDnfr3D068qg4x8cr8a/J2B/RrpJqLZeW9+Uf3qu/lFjd/Yr7zmzfN4xKV8tC/DqvrVt1ph8A96+lVluX1+2OAf6QI/jLIK6Ve1EhDar+yHsV/5/kwc69iWx8pHf0L0Ocf87Bey+FNyi3x/5vQMNmaJ+o7qNujdrAxchid5h2nVrAXurFP/LHKD/6wQuTJTtZBXwY0PwYsC43XjA29VV2amFq+4nzrRiaiqyXNWBhsNUd8RroZ4h2VKVbGOqapa/8UR+me0cw9ViGcKyvOpyN/gLQLNii7w880I/8eeUcgXBScPe+s5Ah4jY75EBtswh8qwXjODDo6O6Pl5dDT4rwaOjka7itERZcSj41wo6xHwLO95An4uwHBWaR6UsUmjjOcQnU6ug/Vf6amafatofIKnvZ1mZaxf6rPKU0U9X6bE4KrIlGB7WBd8tpQ8LBuf7qBsmq6znqBdziY6Pr+UPD5dwOzCFsqaYKgRss7vuwQL6xucotNbko66bIxxhe5TMfifevapqNVs3/4I36e4kR8lG85qxljRVZFuyGpvUTpo/3x50qyIdNCXTCM6syPSQVvkL7vMiUgH/cYA0ZkbkQ76IN4fOC8iHTXumT3MhzLEYXwsEHzYFGAhvM8xFgRfcmP4B4iXnPSGpwALiR63j21xkeClKcpeC7+xDOksEnQUrv6IuKxvp7r2vuZTR/MFnfkeOmsD6awrSWedoDMo6pW1ESUbo7MwIh20mXVEZ1FEOqgHLaJzYEQ6BwLMGqLTFDwk8cDq+SPvk/8OgjLe/ZU8tgLcS/C/d/BIvaNSnKaD6CuQR6yP8csC0Q6md1xKw/wf3v2cwx/Jy+4MVyfZnUCyWwBlIbIz+A+B7E4k2WG72LaHoGwhlS2BskVUthTKEAeWOWgDvmOdw/oGNyjq8Xi1DN7n6K++ENtA/AOuvc1FxqtlRA/bnjx8huHgYvR6jd5yQU/1wzSnZYr0DZfZmPKzi6kMfeNSKkN/toTK0L6Pht+IM6tNNl9TYxfrN/I3g8owpp9JZRiHz6IyjJ15jo5t5vjW2txHeJLHdtr0EuwL5o/UuTT9rfwN+/EFAreVHSTKEvw3HDi6LehTUI5Yljw94p1vDDU4RWdDSTobBB3G1eva55bJw37X4F9PY8gQ4M1hs1eb/JfAS/Z3Bf3P1aH+Lsv3Il/KF4Zcyt77lQee/uzLfrwx7xjh850bBHxJ33mFypkZbVz5dK5dZsmDeS/jQV3KXnDsuiJEfoi/KeBPA7g8faFwXRQJF/vcsrhmFcRll8Vj7DNEuFSeF8clHoNmePha3AHXhYQL67MPG+qAi3deLhZt5LiE4foEbqY96Nrbxr6soJ8MzjUY/gHRhiKxm5KtGmvYj2PdpihjnV8i6CwRdBSuWRFxcb40Rh5T6fB5xLOyrVkenrE+nyiZKejwnDn53Up/J7p9x3zND+o9zrc5LjD498F87E6ajyFtX2zJOZ28u3rXBtLZVJLOJkGn6vw353SGItJB37SJ6CyJSAftrUV0lkakg+MizwVmCR4SnX2M7GAZlCm7NDn1EvwJYAcf89gB8oj1MdZSuSmm9ymKxwvGgTKnY7g6ye4pkh3O7ZTs2IcY/EKQ3edy+BCMLYeoDOWxhMqWQxniwDIHbcB3rHNY3+AGRT2Tr/XXCnhfRU7H8A+49jYXiQtWED1se/LwvGRlMXrDOZ1DBD3VD5jTQZkifcPFOR30swdS2RCULacy9GcHUxnaN+d0DuzQJo6nFX++XPh4xZwHFqPnjTmxfUVjzjPhN5YhnbxxYgxcnJ8bj1hoXUk66wSdfSUWWkd09pdY6Ps5YyEezw3+88tG6v1wDGKhn3ZBLPSfkWKhe0F2PyPZIW22bZTTEJVhjMKxEMqK1xutzEEb8J1vTZXlhvV4vCoYmwTHQoZ/wJXSj+HxSsWIarwqGesNx0IrBT3VDxgLoUxVXOSLhTi/MARlHO+gP8vKxSa/ORaa1aFNvliI94Bh7iL5G/dX8JqSwb4d7GxGulCk9pjZl4VUPmU+0J29YDS/KBfOX+aNHbD+EuInxtik1ro5X5U3R431eU10iaDDYzr719YCzQ/61yHgh/2rwb8a+n0p9RnSZj+JPHOMlrc/1wbS2VSSziZBp+qYhmO0qmIazlcti0gHx8sW0Tk4Ih0chzhGWyx4eGYfDdnBcihT+XrOVxn8XLCDEz12gDxifYzRhkQ7mN66lEbJMVHGaIark+xOJdkNQZmSHfsQg//vpSP1zsjhQ3BMXkplKI9lVIa5DMSBZQ7agO9Y57C+wQ2KeiZf669D4H0VMZrhH3DtbS4So4Xmj6x9q4rRG47RDhX0VD9gjIYyRfqGi2M0X94DfeNKKkN/toLK0L45RlvSoU0coyndr3C/R3C+yvAPuHY5FtEtFQupcZjHJqyr+obzVWoviMq5KlxDEXH59pNxLKT2rS300FkbSGddSTrrBJ2q90mPV76qqpirRXSqirlCY6HX0nh+MJSFjOcGfxeM56/3zON4rehgwOcE/JoMejdRLFQw/yFjIV6DypLdm0h2S6AsRHYG/2sgu5s9smPbxnFniMpC4ySOTdUaFb7zxd8cQ2I9Hq8KxibBsZDhH3DtbS4yXoXmj0rGesOx0CpBT/UDxkJqvQ5xcSyEfnYJlQ1BGcc76M94XQ/tm2Mhw5nVJo6F1J4xxtUL71TOiecd96T2ldja3ZSzUvuUE7hlC0fD1XHY6Lqq798Mv7EM6YTGTosi4qrjsBE6/C5PHFZVfLSO6OxrOakhwUPiY347ICc1BDQ5ljD4xRBL7PHEEiE5KV8cZvC/O4Y5qSzZfSUgDvPJzuAngOz+MEccVuekRvjEd4i/zkll56R8cVg35KQUf4wrNA4z+G+R3ygYN0m/YbjqeC0sXkue0wCOy/LGWAdGxFXHayN0+F0dr8WhUyReaywceY9jUN547YElI/V6U5xVxmsDKY3xjNcmk+yKxmtvBdlNJdkhbd9dBRyvqX3tKpbjcTBv3gzr7295MzVe7a15syEqQ9/IMZk65xASrw11aFNI3iw0x8U0s+K6S6nc4A9ZOIJzBeXN1Nn9BO7xOr+2z+TX+E4GxM3xWt77rdYKnhWddSXprBN0qr6nieO1xRHpoM2vIzr72jrnkOAh8TFnk39T65xDQDNrnXMFxBzneeK1WOucGyleq3KdM0t2F0aK1yaB7C72yI5tG8dG9i/1OuezT73OmR2v+e6PQt8Ya51zcYc2cbyG/PnuGrJ3vjjM4F9BfqNgHCP9Bu9LU/fJlrwnLzheM/wDxEtR/Vd9p+6UUOco+U4zjPNOAzgu88WFar54YERcvjiqjtdG0/HFa1Xdq7mO6FQVF7aIzpKIdFSc0ynmeCfFHEuhLCTmMPiPDI3Uu8WTI+J8zlLA5wT8mgx6t5HfxXGirN/Fu8XY17XS38/cS5Mxlw89R2nwvwWyu5Nkh7TZtlFOB1IZjqkcy8Xce4v1WW5qLlLy3GtwvGb4B1wp/Rger9T5UrQLjtcKzh+G47XQOywwXlN3gyIuX7zG5yjRN/JZSfRnnDtB++Z4bVGHNnG8pnRf5bjwTCXnuNS4NFG0MUcfTQ3VQcM/4NrlXUQH1Z0carxO7u03XUg/e3TW1h0bd15x3bVXnrf1xu2nvHLLxs037Lh283WnbNlyw9bt25FpJITfYMJyfBjGfs8Q7xHH4g6NYWXAzgq5ZA9x8YV96pI9w7WkAy6+sE8Nbvx3n2vn0w77TgjAg4aWxdcm4kstvvicPCrn2wgX1s9KuGThejvhwvq8uIjJIuaT5eXDk+VAka/fIL6yDqEn/63sgOtXCVfW5T7Jf4d0wPUOwqUm4fx3n2vnk+Xlw5P8t6oDX79JfGVtvkn+O7QDrlcTLrV5x3Ad1gHXTsKF9bEu/t3n2vlkefnwJP8d3oGvm4ivw6DscCrDelOITt5JGtYfq0naFKJzeEQ6hwNMC+olf6+GsiHA4TvEZIP/EfC+ioSJ4R8gXnLSGx78jyB63D5OmBwpeGmKMk5yHCnoHCnoKFyLI+JaTe3JvAiIJmFFL7N5zdBIvR/SJAxldDi1UcUx6jLSBrWrX8Ajvl6C/2nK0wGu/bOuh4v6CjeOpyEXAqN9VWEjhj/WhcCriR63j23kCMFLU5Rx0kLZ4hGCjsK1NCIuvmgvy0b6Fo2mWdRGXjo0Um9iirObbGRKylMZG8EYKsRGylweifiMH3yH+GPZiIplfTayWvDSFGW8sV7Z4mpBR+FaERFXqI0simQj5wyN1FtcoY2YvENtxOCXRbARjJtDbKRMMgzxGT/4DvHHshF1aZrPRlYIXpqiDOdMWIZ0fIvjiGtVRFyhNrImko0cPTRS77gutJETc9qI4r2KuZfKX50Bv7Nk5PsAzxmiPWqOdwa1J0tHzlik+VE6kvy2+TsvrLdAR8726Eg3LKxuKUlni6Czr2yE20J0lkekg+NKi+isiEgHfWXoBbUvIjtYCWXKDm5Kf/cS/NOtkXov9dhBVs4SF1Z9F9Qa/NaURsmNR3Jh1XB1kt3VkcaZB1sj9V6Ww4dgTM8+HuWxnMpwTOa8r8qv4jvWOaxvcIOinsnX+gvzllUsrBr+Adfe5iKxVujBT2vf4cXoDS+sqrmE6gdcWEWZIn3D5VtY5cv60TeuojL0Z4dQGdp3yGX92CbfRrg8l/WP9Sazspf1d4oXOY5fLnhRffNO+I1lSMf3IQ7EtSgiLltjqDeZtb/rxkMB+0sstCtHLJQ8PJ4b/BmtkXq7xyAWeqgLYqFHIsVCK1sj9T5cx0K+Z6+JhQ4rRm84FlJr2HliIbWmvS/EQj2CP4RD21P5JCfeNTz0mMYEUfddxDeWXUU08uaArhL8VpjX7Qm1r70lr8tr6GVysSExT8kNjMHx+FhsYLwK3kXaRNvj64fFHnoF1/ImGD3f3i6kl/jTftfeh50+hII0sL+ybL7ofsrlHXD59lPyOuCKDrh4P2XWxmUs+0GKIPHDf7doNIztBfwHgPlW+pttCuXwzF4SguN9hckT40M5iM85bXv8UcSCG+a9H0VUBw4T3TzA+XUE+wj3RiyF38tEW0J0FnkK0dm8fao2lSdw/+6BWyLgFK3kb/VhcY7FfwLrS9dfNrqNWH8IfmNZ8vSId77DGQan6KwtSWdtIJ11JemsE3QGRb1Gxr9Gh98xHSUb3yHMonRQx9YRnaoOurWITlW5Ds4NLBI8JDYzeODIe7Y133jBh97/YPFIvWaKU+3Rz/rAVegBNIOfldIYi4v1smQ3h2Q3BGUhsjP4j4Ls5ntkx7aNvn8WlaE8+HAajg2IA8sctMF3AE1dBrG/HEBTh4/3pgNoaqxTvpEPoKkPcyofFPIhP98BNDWWJ4erDkp/jxyuOm/rjZdsvu7aLZt3XLvtlRdufdXOrdt39AJmpo6tcE57YpMI4uGnQX9PoLIZVL5RwOHjG01LXnEQHPka/gHX3gtFLEed6FJRBl/Vg3XVVRW/Bb+xDOksFXQUroURcZne1Fd5tr9jOt3wCZwlEemgbbaIztKIdFDfQiO9DRSt4LHdkGjF4DdAtLKRohUcNZBHxI2R3izRjl6Cv5givYJZNxnp8eo7+rpW+jtp56UBskOfliW7I0F2l5PskDbbNsppiMrUtT9qxo44sMw5/+q8igjGYNdCcKQ3FrsW1NU4Ja++GI70VGSp+gEjPZSpOonru8pzBpUNQRmvEKE/W0RlaN8hkR62KSTSM91qCjpWtgDKZlLZQaLNid3dQHaHn4veSO2wMmwHvmMb2Sj4UXRmp797qY2/Sb6u4DVPJw8SHcOBuBcWxB1ql1lxA/I1IMp6A3j5j5nrDv/33T+8q0H1jRd+NwHwoy4j/EYBX3LMee4g0HBE28pwPFxIZX1QZjwkWctVxF/BlaHnhshP2T6WnQm/8/SFwjWzIK7pbrReoe2Y/aEfmZP+HnTtNs12UtAGg+dbhn/AtcugyPilfK/yWewjsG5TlL0ZfrNv6RHvJnhwNSPisjFA9TPPt5qCTtNDZ63gWdFZV5LOOkFnUNRrZPxrdPgd01GyGevM+uyIdFAPWkRnTkQ6cwCG51tZc4aP0JwBryEPmTMY/F8cNFLvMU/sgjxifRxfZop2ML1PUAxScGyR8y3eXZElu0+S7GZCWYjsDP5JkN1THtmxbavrrdR8azaVYZzAOaW88y2sv7/Nt9QYb+0bKkZveL6l8pF55ltIn1evlJ+dSWVqHq38GcdcaN8835rZoU0831L81bFQWCyUPKcBHJfljV/mR8Tli1HqWGg0nToWcoXoFImF/jVSLHQxjOffH4NY6EddEAv9JFIsdALI7j89uWe2bZQTx0Iqp6PiJJ7X5z2VhPXHYIducCw0Fjt01XgV40Rg8t+QoJe1Y1bJVMVFvliIc89qN6DyZwupzBcLzejQJl8sxOvumDdm2OnQ3lFtAzs79qBsWnOJD/QR86gs1D4RB8oXfQXCb6M2GPyclO8k17j9Mo1zgtM6av5H5T6tHROBrpXl0N+nE75ecNkIHdSX5MG8KeqLc/6YyuDnCnjUOY4N50IZx3NKHzG+MH1U8jIeq5AX8hAiL7UGFiovtnuU1wLCpeJflKFPXsZjFfJCHkLkpfa4hMrLZKDkdRDh6jTHWU/whrvfaZ/Au6YN/mjwCXwrj8/HTxe40Tc2CAe2oyHaMUhlWDfBuycV1ljleTjWVDfuoP/GfRAI/yswblxIshlyI0/I+pbKcQwBDO8kxXF8SQCumR7aSwX8Eg9t5Iv3yPDeHBVvKD9gsinpB/qUH8B8FfsB1U/qxJNPVqqf1Jo7740LzTnxzQqhOSc8acH6qfJPWT6b7QHnMzzXUfMEn+75ruhXuqdyrMr+2W+ofTXKlthvYN+y3yi6E/6laV9UuROe9bvXaf3O2uH+avBtV2b4tr6cOK+C8Wg92Khzer29pC/oVb5gCADYF/h8cPLk9Ztst9g3vNag1s1RphwTmIz6BTzi4715rwqMCYaI99AcuG/eZ/aQyP22lI9OeyBfS7qnbnPw7YE0+PeBPr+e5ngx/MYcKkM/wKedUad8eqZ27xucb89tyX3nwbkU3nc+VIyed9+5WueJ8cnl5D91ckb1A+ZSOp3eNF811n4N5RTi19Rak9pDyPaMPoL9gNrzqtZimB76CIzFbyPbVz4yNGbB/PW/Ui4V7YvtH22c7R/1neMGlCHHDUuBFxXzGF7+hNs94MM+RrJRuuyLY9UeVtyXyrfaoK4fHIDrQA9tdVr+YA9t5ItvgOIT58omlS2abKqYb2BcwLao+gnhQ2Sl+qlJ8CibvLa7lMpwfB+iMtRtPIn6sYxxG9uhcrydTqe/lsbuvSVX8Dmw3T+tcwVttJlPq1fnCtptt+pcwZ9WlCv4ZJ0ryJ0r+Nu9IFfw7+DbvhkpV/CtOlcwXDZeuYLvdUmuYFrKbKdcwY8j5Qpmwpm//6hzBb6nzhUQvTpXMD65AvMRPh9ZJFfwkb00V7AAfNjhJJs6V5Btk3WuIJ/txsgVsH7GyhX8mMZu5JvP6yubUjbP5/XVp925/7JyBYa3l+CPB9s9l2Sj7Eft/wu1H54zKfvx4fLtMVI3Ii330Ea++AZ2tmV1hr7CcVTaLton267PZyZPiKxUPzUJHmWjziHxvrchKONbonAcYptH3cZxl/VT7W0KHXdxrxHf33FgB7wsT9+XLNS4oXIovjNiyv7Zb6hb25Sus9+w/kRdRXjOFRj8ZSkzJW9clbkC/kIA3luh9JvnVgb/SvBtL8jwbX05cb44xdMpV2D9WEVMjfbOvsDng5Mnr99ku8W+4TtjQm9wYzvrdzqGyLqh9VroA84VoD/iOGMIyjgHskTQVf4IcwXvpFyBuskzgbuedE/l9dHnsO4Z/C2gz9vT3zH9xlIqQz/AN3OqMUfpWVPUxzGU65kfKHlTYnCugG+xL3jzZO5b7GPcVJ38t1LQU/2AuYJON5n7cgVV+jXfekgnufLcHdvI9ow+gv3AEJSx/1jioafmd+gjfD4ydL6BMcsGyhWoHKuycbZ/1HeOG1CGHDesAF5UzINjNsLfAT7sQyQbpcu+OFbd6I+38fM6jO9rvwqXL0+hvpJziIe2+koO8+Jctk0qWzTZVDHfwLiAbVH1k/qChk9Wqp+aBI+yyWu7K6gMx3e2a9Tt5dDmD2WM29gOla9U8QCO+dfT2I18V3GLc9bYnZXnM7wc+34CbPf3SDbKP6O/zBt38pxJzdd9uIY8tH36q2gjX1iXaTOfVk/ZrsmmCtuNOT9QslL91HTtds02GHqjNNtn6I3SOO6yfg6JdoSOu0OAl291V2utPt3z5VmV7i0R7VP278utsd9AHWW/ob6yyXaGuorwnCsw+L+iXEHBL/nIXAF/vQ7zGUq/eW5l8P8Cvu1rGb6tLyfOrwfmCqwfq4ip0d7ZF/h8cPLk9Ztst9g3IXvBUKacKzAZ9Tuds8Q9Lwj/j55cAfojzmuG3nDPe6fUVzYSuU9sPfub12KS3y2A+27G+hnqHvoc1j2Dn9waqfdvFG/E8Buct1Q5I9+Y4/tqrloXUPpsfqDkXDo4V8BffSqYm/B+9UnNd0r6zeFcgZrjqH7AXEGnL535cgVV+jXfekgnufLcHdvI9ow+gv0A+gj2H759DCoXhj7C5yNDYxZc8xykXAHal29djO0f9d03t+a4QX1RWM25egl+Rmuk3sGt0TiVLvvi2E7zdc59qvm6D5cvT6G+HLvKQxv5wrpMO8smlS2abKqYb2BcwLboy9EkT4isVD81CR5lk9d2V1IZju9s16jbmANj/ey0n4JtNyt/+F1Pnr+Kr0Hz3PpQ4IXX4XkcQPgjWiP1Tm2NxnmYG3lCdEJ9CfkwgGE/hTpxeAAu356g1QL+cA9t5AvrMm3m0+op2zXZVGG7aG9su6qfED5EVqqfmgSPsrGy0C9TH0ploV+mXgVtZv1U6/9Zd/KwPeCeIP46vPKFPt3rNGax7qkxS9k/+w20f/YbqKPsN7Bv2W/wF8cZnnMFBr+x9ey/Fn+ijuTQdZkrWE08HgY8KP3muZXBX9V69t+kjze1NM6+nDgvSfF0yhVYP1YRU6O9sy/w+eDkyes32W6xbzino/IOKFPOFZiM+gU84usl+M2tZ/9VuQL0R4cR7+iPOAZRuWPljzBX8JbWs78HXbvttgDumtbodqNPY3+RPKx7Bv+21ki9l6e/Y/qNFVSGfoBjazXmKD1Ta0U4hnI98wPmV1AXq8gVGP4B197mIrkCZX84PnCuoKDfHM4VHCHoqX7AXAHKFOkbLl+uoEq/hnIK8WsIz3N3bCPbM/oI9gPoI9h/LPfQQx+Bsbj5CJ+PDI1ZcH6+K22EsnG2f7Rxtn/Ud44bUIYcN6wGXlTMg2M2wv9Wa6Tefa3ROJUu++LYIwX8EQBzCLUHdf3IAFyrPLSPEvBHemgjX1iXaWfZpLJFk00V8w2MC9gWVT8hfIisVD81CR5lk9d2V1MZju9s16jbh0Ob72uNbocvzk8ett1DBK8YD+xtuYKPtEbqfaE1Gqfyz75cQd75Ovqw1QG4fPM1n/4q2sgX1mXazKfV66Zcgeonn49VslL91HTtds02OJa5AtbPWLmCq/fxXEHImI+6ivCcKzD4P249+6/Fn6gjZXMFRxCPmM8Imdcb/Ldaz/6b9PGftTTO0FyBwf9limc8cwVo7+wLfD44efL6TbZb7JvxyhV8o/Xsv51yBZzXjJ0rsM1GnXIF/9Aa3e6iuYKeoZF6305xVpkrQD/AuQI15ig9U7kCHEO5nvmBknPp4FyB4R9w7W0ukitQ9ufLFRT0m8O5AjXHUf2AuQI1F0Fc3Zgr6CRXnrurnGbe+Qb7jyK5AvMRPh9ZJFfwoki5AtR3jhtQhhw3HAG8qJgHx2yEnwQ+7ECSjdJlXxwbY77uw+XLFRwj4I/y0Ea+sC7TzrLJsc4VYFzAtujL0SRPiKxUPzUJHmWT13aPoDIc39muUbcxB8b6GStXwPFAp+/ac9yk9lj55ied9o769hqtpDK1V5/poE/APrkp/c17jVamcu4UUxvtkvo+tep9NJ3mg3x2Bn0373lBGeN5JB4b8IzLGTQ2YC6K92T47nrgutgH/RnwvJ/M4I+HPr7sMo0TefCd/8qrz9iGsvqMtrGT2mrwa8dWn6eMtz6zzqI+c05I6XPDtfuwMvmcNV2o/+fvR/p/cZfrv5pL+PS/U46E9R/jt/HQ/0U59H+1h6bSf2tblv5jPhHht3r0X8nXp/+d1gh9+n8klWG9RRl0UP+x31n/Df66QP032lXoP8qI9d83b0qevHMdXhPA+N2n/7xeG0v/+3Lovy/2Vvpvbc3Sf8PH+fI3ePRf2eAQvCu71oVtOILKsN6iDDpZ8Tzrv8G/OVD/jXYV+h9z/topz8DxPNqGT/95nSOW/n8/PahvfTwEcL47HEPOsauzKny+UJ3ZVGf6+Mzm7UMj9T44NBqnipGWwrsq5rw+XEMe2p3uxmDa6m4M5sUJPq1ehee/+qo+16pkpfqpSfAoG2VbQ1QWeq7Ed1cenhdj/RwS7Qi13SHAe8fC0XiXdcCb9w5Xo6Xs/2Aq8939mvccu9J19hu43ucEPK9FG/yn0kbZ+gbqSA5dl2vRfFcNnsNX+s1rdwb/x+DbPpPh2/py4vx8iqfTOBvprprequ+q6eQ32W7V2bQG/Y241PoN21m/03Ndw8dnvb8CfeBbi+b7ONR9TcofLaUytBlci/6XlA8+o5v8bgHcn5LuqftoQu5i/B7o81+kv2P6Db4PS911wPbjnF/PmqI+jqFcz/xAyTPgwWvRhn/Atbe5yFp06P10Jf3m8Fq0yhOqfsC1aHWGFnH51qKr9Gu+e3w6yZXXhrGNbM/oI3x377D/8N2/hz4CY/F/IdtXPnJI4B2kMqyb4H0nzTfQvnz3OYWcY1d75jhuOAR4UTEPjtkI/2PwYQcsGY1T6bIvju10zpzvD1LnzH24fOfrDxPwh3poq3M7zItz2TapbNFkU8V8A+MCtsVOa7IhslL91CR4lE1e2+X1bXWOXdku5t9ZP31xfvKw7S4TvGI8MFXQ943dvjtollIZ2jXfT6PWGIYAJut+iulLRuotI9nEvp9iiNqT934K3118nfwG067vpxgNr/op5H4KdV+Lsk/OMeA8g+cjasxR+tnpm2K+cRfvlrmQcgWx74Fk3VNxs7J/9huh4zr7Dexb9hscHzI85woM/uhUIBZ/oo6UzRXwOI5nbpR+89zK4M8G33Zshm/ry4nzhBRPp1xBpHG8t+pxvJPfZLvFvuH5oxpLUaacKzAZ9TudpzB8nN8+DfrAlyvIEy+o/J3yR5gruCrlg/O5ye8WwJ1Lulc0T3Ut6POG9HdMv+GLrXnfqhpzlJ6pvYE4hnI98wPmV1AXq8gVGP4B197mIrmC0Ll7Sb85nCtQcbjqB8wVoEzV/T2+XEGVfs2XA+0kV567YxvZnn35RPQR7D+Weuihj8BY/KqA+caQwKtiFpxvnE25ArX/KO85WY4b1HyOx42sPU1Z52SvBx/2ZpKN0uUyd2rxPvy8d2r5cuyrBbzvDEB9p9ZoeNVP6syJ704tn+1yjgHHd7Zr1G3cX/7mjHEb26HWQlQ8gGP+uTR2Y66Av3uRNx+gbJ7jNBX7DgleOfZ9F9ju7orzfEPUnrx5Pt98rVOej2nXeb7R8KqfQvJ8+N0LzhWE2ifbPOo2jru7K8oVTKZcgfIJPt3rtJ+GdS/0DAn7jbz5AKXr7DesP1FXEZ5zBQb/GOUKUEfK5goOIx4xn6H0O+tM8O+Ab/tYhm/Le874ycBcQaT927nPgvp8cPLk9Ztst2qMb9DfiEudAWM763c6Z5l1XuCLnlwB+iPOa6I/4hzIMkFX+SPMFXyLcgVouy2A+z3SPZXXR5/Dumfw/wj6/AcUb8TwG7zHSeWMfGOO0jO1zotjKNczP1ByLh2cKzD8A669zUVyBcr+1HynpN8czhWE3r+HuQI1F0FcvlxBlX7Ntx7SSa48d1d3vigf4VvDYP+xzEMPfQTG4t8i21c+ckjgVTEL7ldoUK4A7YvtP28+QM2tOW44DHhRMQ+O2Qj/XfBh/0OyUbrsi2M7zdd5HUbN1324ypx78t0X0ulOLWWTFd43IecbGBewLea9c1fJSvWTOiPG52dCbfcwKlP5AGW7mAP7n4xxG9uh8pUqHsAx//f20lzBwNKReouWjsZZ5wra+axzBaPLxjJXwPoZK1fwlQWj8da5gpHfWbmCVSkD3ZwrWAe+7fAM35Y3V3BkiqfOFYxfruBE6IPxzBW8OEXYKVdwKule0VzBZtDnM9Lfda5APnWugOjVuYLxyRW8mGw/Vq7gt9OYZW/LFVwDPuz1JJs6V5Btk3WuIJ/txsgVvD5j3MZ2FMkVnEpjty9XgLwNUVnMMwi4JyPrDMLNYLvvJ9nEPoPg2/9Y9RkE396r+gyC/24/3xkEX65gCMpinEF4f0CuQJ0pHHTt9oC5gjdRriD2GQTfvSO+MwjsN3z5h7E+g/Aw5QoKxvSVnkH4PPi2D2X4trxnED4amCuozyC0yzTWGYRPB+YKOM8xBGUxziB8nXIFWWcQvkC6V/QMwjdAn5+meCOG36jPINRnEJ5Bnv67r55BQB/BfmAIymKcQfg62b7ykaExC55BeC3lCkJzhWz/Y30G4R/Ah/0HyaY+g5Btk/UZhHy2G+MMwn9kjNvYjiJnEL5AYzfybfOMsd5XoM5ncuzbWDZSb9ay0Thj7ysIma/7cA15aHdaH2Pa9b6C0fCqn0L2FWBObIjKQu0zdF8B6+eQaEfouDsEeE8N2Ffg071O+wp8d5L49hWw3+imfQVLUiLdvK/gBPBtB2f4trz7ClameOp9BeO3r2AN9AHnCtAfVb2v4JK0Uqd9Bc8l3Su6r+D5oM8np79j+o16X0G9r+AZ5Om/++q+AnWXWVX7Ci4h21c+MjRmwX0FJ3j2FbD9d9O+gpeCD9tOsqn3FWTbZL2vIJ/txthXsD1j3MZ2FNlXwPHAUoF3SOBtEL8I7/sujfI5vv0KKhZS65xLMuigT8C2bUr/5bWfXwuMqatci4/57YBO80GTiYqNllEZythoqj1nS4H3Fo0NDYC7knhtuHZeG6JtzYz6Chf2yxr4fTSUI/y9NJdEeebo1w2DUMcBDsRdUGc2YFvtUfEkxk6KXvIMiLLeAF6+fMKe8+7/2ZopDapvvPA71ss+AX+lgDdZ9RPvLRf0nKds12hbGbcdy9D+jIfEZlcRf30F+QuRH+JvCviNAJenL6a70bqA+m72inf0zqQy9M1DVKZ8sy/nzP4N/TZ+B4TX7A3+YYjlPhMwVmL8zLrp2++E/Kj57iEBuHzfoe20x41pq7ks8+Jcdgyg7MNkU8XY5luD7RTThMhK9ZNas+Vc0kwo4+9RDUEZx4c4JvI6MOo2xiOsn7G+afWf80fjVbGZT/c6xWase6GxGfsN3/25eXNHbGeoqwjPuWOD/wqN9wVzLjJ3zHtOVwIPeXJt3wDf9oeR8nd/MrZxbu4cS949p538Jtutb+/BMoFLza3YzvqdjrENXy/B/29P7hj9Ec8th6DMl0/i+B1tBnPHP6PcMdpuC+C+mZE/Qt1Dn8O6Z/C/AH3+FuWOY/gNziuhH+B1AjXmKD1rivo4hnI98wPmVwru+wrOHQ+fzXftbS6SO1b2p+aZJf3mcO44NFeNuWO1Fo64fLnjKv2ab/7eSa6cy1VrqcpHsB8YgjL2H0s89NBHYCz+M7J95SNDY5ZlgPf7acyibJztP3SfaUjOmccN5cN4zB4Ff/BIvXkHj8apdNkXx3Za9/SthR0WgMuXH+q0x41pqz1uzItz2TZZ4TpOX9Xr00pWqp+aBI+yyWu7nB8OzTnjug/rpy/OTx623YMFrxgP7G25giVgu8eSbOpcQTufda5gdNlY5gpYP2PlCp6qcwW5cwWnpYx2c67g+eDbzszwbXlzBeekeOpcwfjlCi6CPhjPXMFrUj465QpekBFz5M0VvA70+cXp7zpXIJ86V0D06lzB+OQKXkO2HytX8Nhemiv4dfBht9W5gjbaWTZZ5wry2W6MXMFtFeUKOB6YJfAeKPA2XLsfMnjfPrOlAh7lwd/VRjlyTID1ZmbQUTmI5OF9ZgZ/b2BMbbSr0HeUEeu78tkIz/JW80eMlXl+rfb8KX03msbzgQJnwvsdNDYsALi0aLjsICjjs8y4x5m/tYY6gnxgP6EeNAHG8PYS/BMwNnyZbETp8EHwjvvA12fIj9LrkHnNAg/tTv3PtJEvrMu0mU/UB6NlZSabKmwF/Q/bis/XJE+IrFQ/KVvhuG4+lC2gMt/dSfitNT5jibo95EbazPq5QLSjCe94bGgKXhO8J1AuarHA69O9IQGPdsy6d5Bon7J/9hto/+w3UEfZb2Dfst/A+b4T8JyLMvi/oFwU6kgOXZe5qIOJx6XAg9Jvnrsb/LfBt/1Vhm/ry4nza4HjpvVjFXO2sRw32W6xbw4iXAcJXGr+xnbW73SMZPh6Cf5bnlwU+qOlxDv6oyEqWyToKn+Euai+NMBU55NaAPfPpHvo01Qsybpn8BOXj9T7LuWiYvgNjknRDyAO1imfnql5AsdUWM/8gPkV1MUqclGGf8C1t7lILkrZ3xC841xUQb85nItS8yPVD5iLQpmq+ZIvF1WlX0M5hfg1hOfcELaR7Rl9BPsB9BHsPxZ56KGPwFjcfITPR4bGLAcB3tU030D7Yvv33dWK+s5xA8qQ44aDgRcV8+CYjfBN8GFLSDbjcS+lD9eQh3anc00h91wwL85l2+RYz80xLmBb7JSTCZGV6id1BozXwkJtl/NbOL6zXaNuY76X9XNItKPIHSscD0wUeCcIvAY/BXD1EI7k903p716CPyRtD8auhrMpeGjAO+7T6QIefZXxM5V4wLpTRT3Tc6XvBldS36cofcf2sL7PgLIeAc+ymSngZwAMx0aYb5pCZYNQZjQHCQ/KO+F96tzR/HTqW9avaYBL9e2b0t+9BH+iR7+UvkyCdyxDn8yRn6nEA9adKuqZfJV+GVxJ/Zqq9Avbw/rl05fkYdmo3DXnhZOnSfAoJytDuzSag4QH5Z3w/vDM0XCDwE8j41/jld+xLSCujcTPlIh0sN1riM5kKGulv5N2P4/GA5RJj6j7hvR3L8G/AmKgi9LfU0X9KVTfyi4FO3v1Zdn1TZZTXbsv4XOWKA8cS7LaifBvymjni4DP7Z5cib0raXdNZXfo+0L8OsLn9evsu9EmJxOuyQIX6jf7ZJNRv9N9YPh6Cf4a6APOlWD7OOc7MSfvajxRfsTqJn2xNRWQigOmEU01hqm+aor6zQxcEwT/aLfc7z1Oj4cMbzqB+Urln3sJfif01Y2XaZwug4fJGTz3Z8DPIB4M/kahLz4/gPo/nXAa/BsA55k5cf5aBs43emINZafT4F3e8ZTjCZQj7zNF3nlcnAn0GfbXiT6WoZ4zXefhV8WQPn55vLGyO2C8ekf6eyLhy+mre3x99QLBb2hfTfa0j3FZvV7Xro8+G0F5vGe5xtmXE+dtYkxXscrRgP+OjHjEufZ4JHnYL6PPQDt8HsUkSH8C8W/jxN3CHtVYb7jKjfWNv1NjPc6jeaxXskF49gnTBDyPI87p8eYIKlPztIbgIe9YinO+k2aOxjvFgzf592XER6cY74b0N/vhj3j8sJKhT+ZqjohyNX6UH+acgtLZsdZHbD/ro6+tzuWfD7M+qvFD6SPHWT69SR6fPmJeajXFdtMFTeWj88bcDfptPr4/A559vsHv8cQ9swUP6FeZ5zkCfjbBYPtxXJrjNG20S5TJBmqPwf9eoD+OlPOYrvQf5cb675NR8rBM5wp4lJXJpEnwKF/lq2dTGdJlPVM2G2obVjeRQz/56tD5FPvVrLwD+2qD/+uc+Tmfr+7kjzgOC83P+Xx1lbrarfk5pY+d5tXfmzGalop9Jnj4D4191FjLvh3rTXGd+fLN6bF+00Nnckk6Ki5W+aRGxr9Gh98xHcWzshduj+qfaYHtmUbtmRaxPYpnzhEnv1vp70RX/5PmMOgne6hu8vB4Z/AzVozU+xnNX5A2602o7k5yo/mcBjJQPvtCN9J+5ypZx+ob73Us9lXo4wYJ16DAhbqHY6fBOBfV7/flzQ/7/GDyhIyJaBPWNhWjc+4Y9Y19r5Il6p4vDhmEtv7OjM78T/G0t5N+8PoDjvN8XkrNV5QuGFwVMQC2h3XBN6YnD8tGzRlwnGddwPnBdCrD/uc4QsVtyl9yH6N/xX7hNSuDX5L619B8q09vOsVHPJdXOTzfvHKsY8du0RvO+6Lvyas37EPUPgQcv5W/m0C/VSyJ8D0ZeJqEp0HvJ8F7rHcjtZljJMb9OoK3dvZnwBs+jkWeA7ZymWeepXC+nniY0YEHXnMx+JMFDz75J48vJpzo2m0xh9304hhkD8eUiH/Aaf1ouaCnwfIzekoPkodtWdkTlvGYrHygsnOFqxERl8UNKoZdS3Tyzouwvm/+ta4knXWCTtXzr7VEZ0ZEOmgz64jOzIh0UA9aRGdWRDo4Hq0hOlnzvBetGHmP41bWPI/PQBj8QytH6r00xanmzLzWNxvwOQG/JoPe1pSG+T/MOebwR/Kck+HqJLurSXYq/+eTncG/HWT3Mo/s2LZVjDHVtcuDY3rMwXL+W+Vz8R3rHNY3uEFRj8erefA+z1wxxDYQ/4Brb3OR8Woe0cO2Jw+fH5lfjN7w+RF1hlL1A54fQZmq859mY8rPcs4AfeNcKkN/NofK0L6Pht9II6tNFtv69h2pOBRjN5VvYd0b61hpejF63lhJ5Yfyxkq8xtitsRLyybFS3pwr1p/mobOuJJ11gk7Vud06VgqnUyRWuidSrHQIjPf30XiPviIkVpou2sH0Hu6CWOmDJLtO6wksu+EzFiC7j3hkx7Zdx0ojfOI7xF/HStmxkoo3qoyVpndoE8dKij8V7yRPy4U9IbEUti9H3w2F6qbhjxVLqbhExVIl99G2kv6YlNbDOPYV8Btlh3RmEA9l+0/lZsar/5rF6Hn7T+WsYvYf2lae/lO2yXst8saVal286rhyCtHJGuO/RmO8WtPy7Rkw+G/DnoGv0xiPtH37AnCfA7c50jp/z3jvLfXF6LwepfaaNFx7n6h9SLzmNEHQSdp6d8a6dQPwvkHUZdtG+BmCD4PnPaUMw3v6Df67sAZzTsZ5HrWvE/lnnf03zzqsWmv07e/otNboW6OfTWVqD5uyCYMraRND473flPUeY1neN8r2lTwbBC4fr80SvHI/Yl/NJVx4fkXt6WC9HNbZdL7Uab+xybyK/vetwyuZ+tbhO8mU812h+405l6V8b+g6PPqQr43xHJVzBvOAlx7Bq+HtJfiZMM9evnI0TpsvORdms2p+hnMu3o+Ec7MFAbh8vnShgF/goY18YV2mzXxavQptS+6Tw7k225bqJ4QPkZXqpybBo2zyzpfnUVnofHkutJn1M9YeGs5ZKV/l073QsUrZ/1wqw3rsN9QYp2yJ/Qb2LfsNzoMwPOcaDf6YtC9s/oU6kkPXZa5xIfE4H3hQ+s05RIM/F3zb8Rm+rS8nzucGjrPWj1Xc04b2zr7A54OTJ6/fZLvFvuE8qYpnUaYc15uM+gU84usl+DOgD/hOBfRH84n30Pwdn0lSawiJ3K9J+Rh07bbbArj1pHvo09hfJA/rnsG/HPT5gvR3TL/BezvRD3CcqsYcpWcqPsMxlOuZHzC/grpYRU7c8A+49jYXyVuF5qhL+s3hnPgiQU/1A+bEUaZI33D57p+s0q+hnEL8msqTN117G9me0UewH0Afwf5jpoce+giMxa8h21c+MjRmwXXIe2i+gfbF9o82zvaP+s5xA8qQ44aFwIuKeXDMRvgbwIfdTLJRuuyLY9W38PCewTnUHtT1AwNwzfXQVveIHuihre43Zl6cy7ZJZYsmmyrmGxgXsC2qfkL4EFmpfmoSPMomr+0upDIc39muUbfxXvqbM8ZtbAeO22y7cwSvGA+M1d6/WLmCW8B27+/yXIEv317nCkb46eRjY+YKQvchxsgVsH6q9bfQcRf3+14dkCvw6V5VuQL2G92UK3hiL8gV/B74tk9EyhV8qs4VDJeNV67gaU+uAP1R1bmCfwjMFfx+pFzBt0Gf/8iTKyjqN+pcQZ0reAZ5+u++mitAH1F1ruAfKsoVvMiTK2D776ZcwffBhzUOGY2zzhVk22SdK8hnuzFyBayfsXIFv5/hE6zfkgfva83ay9Jwel7OcZbRztprxXGWwQ+k7ce9Vuo8x3po2+RDdNvQT6i7+drOWRwyUm9q+lvNnzgvirLhvc/YBwx7ptMymAN8zDwkm5bp16CnjQmOeYdkw50p4BjHBCED394Y9kNqL5ojnBMELNNQ8bKiMYNwKptIHhX/+85osO3xuwkCfnZGe52gPacD3lkCj/JD7Numi7KGa7epvLEBfjd3esqAspcsm1B6NdvDO88HfPseFe9Kfug/fHuu7G/WreminQ3xt/G3Hd5l7WfFuSnCWF3es3es8JmMM+ueoFdl4DwBcIbsTz0W3uXdn8r3BCk7V7yjL+F3qn8mEyzHl2cKnrL+Vnv5s3hQd+uP5d0+P0//UHflDRLvTeIdYfksAv6t9LtBv62tqN8Iw/pt8Od69FvdoYB8vSoD5waPfiu5HwPv8u675/uu1R2qinf0PfxO9Q/rN/ujMwVPWX9nnZdXPDQFHtPvwQycTJP1IXlYvxuCTtLvbyX9Rjp8T3ve8zMTBf/8PbYXgy7xdzHUN96wjRsycG726Gfs+9iNH9833lQ97L+JglbLfvyP/zF8ZgsHuGwd5HMU14KcLr5M89Jgfjo8vvNRJe+EaKEO26NyhON1f1bJc36L8Rwc6hGeg1P3uGN/8TnEBtBP7Gg7zfeUjWHd69PfbGM3wjzr1Rk4nSvnm66bPhpv7DNdnHdT34Hz3c/t+96N8dDpLMkN6W+OIX8dbHN75XfXN3443nc68lkSnNdkxU6Iy3d2De8wVH3A3/wx+HdCH/i+G8b37g/m5L0peFd2jLbBdqzOFU4UeH12j3zbt1HY7m/3jK3qjju0+7x3rPM6fOg91WNwHnX6eJ9HNf5VDoPjSN/d5xij4fnS55HvfTfAGT+YJ2b9ek/6d1YO0+r2EvwjYr5i7RiA+u+mdrwHeDGds/H4vcR7ywU9E3BcskfFG4Z/gHjJSW843ngv0eP2ma4k/Wr9vnPHtdddu+PG9ds2bzlt8/Xbd163FU8Vo8SZSoOw4ju2YCzroXeTCO4C+nu9qOcEbvQct0KZkoThNC+Abbo1ox5rLr+bIODfS7jeK+oZ7z2e+ogD67HGsBWhl363oM1W9BRY0Rsuy6b7btcuB7akiYKeWd2tBOvciNXdRm1quaDn0lCrM/wDxEtRq7uN6HH7ilkdagpSuYSwGgzC4nMJcIbwk+hv7r3Joh4/JrFe4vkvIMb/EuV5sV2HEd9K2/Ed5wmwvsEpOktL0lkq6JgmD0HZGio71FO2GsoOo7KtUNaisquBz41Udo1rb7OVvdyD8xaBM+m761eN1En+uwvglKazV/0A0MS6+HefgOU1OoP9B9Crvya9Qitmvbq1A98+vbrVZdNZWpLOUkHH+gT1l3XnNtFWK7sdylpUdgfwwrrzPtEuK3u/B+edAucze21XjYbj/k8e8/h3w/scHviSUI9v+AeIl6Ie/26ix+3jvM6uYvQublB9pIc4jR+T9T2izHDdm/7dn4HL6vYS/A9Te2sSXPJsJBr3CH7xnckn0ZPv0jo5yraR8a/h5XdsX9h26x+jg/6mBfz8lObH6Kd6RF2b+7CvOmbtSL3/Il+F9bnvlJ0Ubf9doo1TXbtslsDvLP2+20Nniac9VfXnEqJzq2hrIvs+GsN2QVmPqHtt+ruX4A+E/pyY4pzqsm1RyZnHpbxyPkzQqVrOPL7cE5EO+qkW/E7+2024WM7WTybne6FsN9W7D8oQDmddu+H9fYK2wm84Oung/FW6bVk6aLR6CX4C6OCigjp4D5VhH6C/QD5QDgh/rdPt6s+Az2rX0rQt6psvVh9lhX3B/tfglwNOzjfudu3t+gC845ya0ofdol1Kpve5zrRRzuszaPc7vy72EvzhQqZqXNhNvCPuo4iXezvwzvaN9Q1uUNQr60cUz51s8ricNnld+pt1919PHqn3HLLJ3VCfdQR55nlEXjkvFXSqljPPEe6LSAdtpgW/k/8eIFwsZ+snk/P9UPYA1XsQyhAOx4UH4P2DgrbCHzounLtKty1LB41WL8H/OejgBtJBNa4oHbyPynZDGY8L9wk5IPx1BG989zv/eNtL8Bd5xgWrj7JCveFxweAv9YwLRhfb5RsXlC7eL9qlZPoA4fqAwIVy5nFByRTbb/hYpi8OHBesvspHHE1lmI/YRWWYj+CY9Q4ou4fKMB/BuRHMR7C/uxPKdqe/VT5iyNMezNtxvg/zdrdRGebtbqeyq6HsDirDvN37qAzzdu+nslug7E5oq+Xteqmt29P3Jde35FnerLwow+G/zoWNB9hXk4jOeyPSQVxnEp1bI9K51dOe2wUd6y+0lyrWIw3/gGu33SJ5sjuIHrev2MoIehuWCmLFdw03uvVYNhbrke+DMiUJzpxjm96XUQ9l4cS7CQL+DsJ1h6hnvPd46iMOrMca06D3WeuRhqOX4N8Jo9UbabRWtFAePGIa71k7C5gHg3838MA7oe+AOqpdt2fgfGDViDxuXaVxOoFTtet91C7m4Q7iweDfJyKBHoJhftS75G9c631fBn+qn5hXHOWy2sP9ZPC7PP10m+ABbXJ9Bx4Y5n0ZPNwneBDe7bRt19+YejdHTy/8Zm+kJM/rtrcJPFmPSSPRQtNIXs9gT6XesQZY3aTltlcvbfnpW6/bumNrRtvZc0/KoDnB6SdkDC241hQ8hvJaU9kxVOWI1RhqbVd5wKYo4zndXYF0kj61fYtpn27ase2GrC4NHVwbgi2u7whXQ7xLngqXHAurwVgtOeYLpVA5WSqIFd/5JN+pt8+kv4uEUmox9C6BUyW/d2XU6+TkJgj4uwnX3aKe8d7jqY84sB5rDFtIVijFIYfBfxGGJtvaxXXs7x3wm7duqYWmkgvd00OtyvAPuFJW3PDpklqAy2dV7FqNyjTCajAIiw9+ThXhs4ZFezaIevyYxEKGzIK9Oli0V8sOmapX1VBm7bunGL3JDaqP9BAnp8TuFWWGa3f6d94ltK+m1s2p+uTh7RmhywuJh/lTSiWZbv8dTGD+F6WclVdl74W01TjWdNkekbduJ7+ztkglD291CtkGpcreL9ql0o4tKvuAwJnI7bBDR8Oh3jYy/k0eX4rJ18fo2XiUVDrGOpmF60LClbVUnvx3XwdcFxEurG91OZzFer7lKLN3XuppuaBnSqg/M/wDxEtRf6aWJbB97M8eKEZvsEH1kR7iNH5M1lnLaMl/D6V/9zv/klovwf+U/BkuvbE/U8ty+A792Q9pGQBlW9Tmmq697dY/PBdB/5Dw8zNK/twHZSpq3Jn+5uX+z8AS4C/IH6P+GY9qeZR9tdK7+z3tv13QqVrO7Idvj0hHbaX16RzK2frJ5Kx03uo9BGVsu6zPCI84FH7D0UkHm4fqtmXpoNHqJfh7QAdnHDq6/VifdRDldjuVYR9wrKT0E+F3Erzx3Z8Bn7W8Pj9ti1qGVolt5IuvGjD4RYCTl6GV/1WzEp8uKn+tZPog4VKzUmwPJ0qVTNE+76b2G/xSIVOVpuIlY4z5fMvQvJyMCx28ZIwJ6t1UhjEfx58Y891HZbjFF3XEYj4+eHVE+n6ia++jHGO4XJplm0IZ4nI2ljk30p/qCGFT1H+Ph841JelcI+gMinrW7pJyDM7zGf5YRzhvJ3pZclE+3eqq7Ry8aGJbHJ5MfyS6uZbmI3x9ZfKYXIfgfY52HhcqV8M/QLwUlesQ0eP2sVwPFbw0Rdll8BvLkM6hgo7CNSMirhMj4podEdeCiLjmdmkbY/ZjzDYujIgrZhtnRsR1cURcyyLiakbEtTwirlkRccXUiZj2GNOGYupETHnNiYhrXkRcMWU/PSKumLKfFhFXTHnF9IXzI+KKKa9u9YUx5RXT5+wPMVNMnYg5bseU/cERccXU+5iyXxERV0zZx2xjTD8RMwaIKa+VEXGlSxvDOaYhKHsP0RkSdIY8dLD+UAAulT/wtTHrKi7zMcNbJK/YefX6bXjRyzMP7+g8I4PFYwlufQZrDYG3Qf/x+2PpXY+ARdxJWumENG6rcFve0Q3C55xOK43Xtry8uzMvhd9YhnR2CToK14yIuGZGxHVxRFzLIuJqRsS1PCKuWRFxxdSJ2RFxzY2IK6ZOxJTXnIi4YsprekRcMeV1YkRcMXV1QURc+0M/TouIK6a8Yo5D8yPiiimvbh2HYsorpr+PqV8xfU5Me4ypEzFjppiyPzgirph6H1P2KyLiiin7mG2M6Se6Nf5aGREXp0lwXs1pkry30GH9uwNwqfmwr40Vp0mMxaMIbn0Gaw2Bt0H/8fuj6F2nNAnvyll22LP/Wlqk4K4iuRuMd2lhOgh3u2GZc2GZOqx/qIfO6pJ0Vgs6g6KetbukHIN3/hv+Adfe5iLpJbVLTsnF2lcwnTW88993Ogf54bOAyq2Y/fRn4OKdoQZ/fKr7TdfuUnjnf6jrStKQRx82mne1azCknxGvcokh+liUDupTK/2tdlizHec9daV2vTIu3PGMO63vJHjsZ4VzDZQj/OlpfyU7hN9EH0xRO/MTfs48rDOvtwte+XTbTSeP1DsnxankbP2u9OAuKjtU0FU42Tfm7bvVggcfLuyvrQRvfdGfAW/4uO82Qd/xjnm8qErpz10ZPKD+IA9Z+nNpAf15/mGdecW6W4m2wV8B+vNC0h+s79Mf3s2L+mMyUmMr77TOO7Zifd8YzhfjK95945hvt7eSUchub9SLHOPf0yH+GPHH2u19J9HLkkvJ5bE9bEtID3HeSfR2FaPXo04687iwO/27P4OXrJPON9I4rk6uNqkseYpeUj/WuHyns7FPEt+yjWSB+tTI+Nfw8jvmEfsrxAaL0kEbaqW/1bR1M/zupMuKDtb3XZB9TUk61wg6Sr9fDjh8J8BL3lLQG+rbDP+AK2X7DZ9NqPSF8hVWtynKsj5ogXR8lyUjrkMj4rqDcCm92Sxw5ZVXBamQSwjuogzWegTeBv3H7y+hd1mpEMOtTDLrmiLnwkxS3UE7VqZf4bU5waZt+Mf62hw1RFvdvXGIrtBN9+1Lbjp5il46s7fgSn7/SvpbXaKygejk1T+sz4eZ1TdYJgr+qtA/wz/gSul7wyd/JRdr+27BS1OUnQm/sQzp7BZ0mqJsY5fjUhfvlNVzrO/7bkDZcOzuQDq7StLZNY7tGRT12G53w/sq7HZ3+nvAlfITDZ/eKrnwhUxYt0llycN6e5+gc5+gs7fgSn4fn/5Wl1yx/u0WdHZ76GD93R46u0rS2RVIZ19rz5Ul6VwZSOeeknTuCaQzVv0Tcqmcj869Xdae2n72v/YMinqN9F8bx++D91VsMTD8A669zUXG8fuIXpZcSl6eOLzF4H5BD3EaPybrB0SZ4bLLq7Iun7K6fFHZjMOf/bdJcMnD4/wDgl98h1sMpqR41cVmrPdK7vcJvErvDU7R2VWSzq5AOntzeyq8JHRqqB0b/rG+JFTZldVtirLnwO889hDTtmpcNa4a12hc6gJX9sm+sVbRwfoG57vAteSFw8G5C8M/4Er55oZP/kou6oJjq9uksuQpejHx3oIr+c0XdGPfs/7l1XOs/4CHzq6SdHYF0rmqJJ2rAunsa3Lbm9ujvuXZSn8nMf6WwzVN3CKIdW2bB1+Au+rIkXpX07wBtyVMpTbm3c6H9X3b+XhLKraBjwy8XOBsUBny93IPf1j/5Rn1kJ/k4e+fGkzylNzqH3zxK2/1v6UYPe9Wf2wfj0nvE7w0RRnKMIvOVEGnQbg68RVxW4qxeCjBrc9grSHwNug/fs+78nsELOI21cduZtVHsfhEpVT/ljGmw7jwA5bK9fUS/Pojnv03cV9vTt1XyA5d/hhkywU9a0LN0vDH2qGr1N93H/Odghe1o/IC+I1lSOdOQUfhmhUR17yIuBZGxDUjIq5FEXE1I+Ka1qV8LYiIa25EXCsj4jokIq5VEXHFlNfsiLhi2uPyiLhi6n1MXxizH6dHxBWzH2P6r5jyujgirvkRccWUV0wbihlPxJTXsoi4ar86fn41puwPjogrpt7HlP2KiLhiyj5mG2P6iTkRcXVrvHpWRFx8WQzO0Tn3oObD7/PQwfoGp7612kj/LXmSt6dB+IxPfIf4B1x7m4vkCZT8lVzUzRlWV6W/OX2X90gS4rqNcKlUrcptNKh+pzZGTAUai0cT3IUZrE0QeBv0H78/mt5lpQINt8qCvz+Db+fCsuBY/+UeOreXpHN7IJ3VJemsDqRzTUk61wTS8V1WwC4u72UFWD/PZQW3wvscLid4h5Hhj5UKvZXoZcnF2ndbMXpTfO4GcRo/akUEZYsutj8Dl9XlizzmpYrMKyvJw6vqoUNjkjKfuXo0HPKLl7TwSlfyuwV4Fq4ezcNtUNYj6vKFJQZ/yeqRegelv9Uq4ZAbXTYEZe8lnnHFjnX/anhfxeqc4R8gXorq/tVEj9uHQ59N4dKhb/22zVtO23z99p3XbZ2AqF27l0WpIFZ813CjW49lPfSOF7mGqN56Uc8J3DgiXgNlShL8YXls0zUZ9VAWTrybIOCvJlxXi3rGe4+nPuLAeqwxDXqPFvZuQbuX4I9MC5LriN5IVyIpWigPXvg03s2bMQzzYPDHAA/nXKZx9ma0i635Gvp7CH6fmUH/HPAyJ6zW9J2gz+1L/rPRvT+D36uJB4M/CWRgV1Op/QYcqvI7lAHWzfobYQ+itvDHTVkX303wt3RoO/e/wZ/m6f/Vggf8wMn6DjwwzEEZPJwleBBe87Rt19+Yek1HD8f27OW4l7gnVgs8WY9J45mL4GjMxl7bKuqtpr+VBiQtt7TT8FTpuq07tma0nUeEQzNoTnD6GXSat+SZ6EqNlcFjs+EfcFrzWi7oabD3NHrcPp56Xy14aYqyLCvtRCfpU/tOStqnm3ZsuyGrS0MHbeUsuL6jug3xLnmeccDpMpLK+vB0Nm/WB+sbnKJze0k6twfSWV2SzupAOteUpHNNIJ0qsnKMK2sKsS393Uvw14BjX3+ZxjlB4EwevnBI3VOpNjkavO/aaSVLzC7eHUAbZZl1T3Qor74LV5C+uqDonpy8XjjGvL5P8FrhpTnBQ854XZqTbzrIN5+iVBArvmu40a3HMh5ZXk5wZ9HfRaaD6nqMXQKnuiLn3ox6rNn8boKAv4dw3SPqGe89nvqIA+uxxqh6yd9vEXV8FhCiwcnDQcy9EXHtFrhKHmeeHWqZhn+sjzPzsSas2xRlvA6T92gV4rojIq47I+FKno01rhpXjavGtZfjUse7dlMZjp98pBF9Ks9Q8+6zUF8bUHTeU5LOewSdsboVWl2/wnLb7drbs9tDB+vvpvbgwl0r/Z3MVr+8WtPEmSzWta8O8A3jJx8xUu/3Vme3EeVs7WKeJwINK8uz2JvMpl9AXy+4DwD6AG+W/dwHMDelv1UscSuVYV8bjk598OfUB3dCmeqDm9LfvPC6HPrgq9QHWJ+vlVJ2o+ixjmQtDN9J/Bn8/xbLCIq/rGuIUB4o57dm0PtbkV1Reme0S+rdbKV3uwGA9Q510mffoXrKe6JQTzljozYKoB5wxqbTV00MH39R5Nuiz0P1nPvV4P8lsF93p7+r6FeUFferyqypccinB2oPWtO193lWJhJxYV+H9Ktvk4fB/8TTr2pDBfLJ/Wrw/xnYrybLKvoVZRXSrwjP/bpbwGO/8lnH3VB2NeHqtFcypF+xD9hHD391IR1DVL+qLLfPDxt8P+AcLz+MsgrpV7USENqv7Id3Q9kHqAzHOrblsfLRM0Sfc8zPfiGLv6y9rSUW93gt+p4MNmaJ+o7qNujdrAxchid5h2nVrOP0WR/sY5Eb/HwhcmWmyI9yUdaeklvAgxcFeAt4wf2K3i3gyqVa21G2bGZq8Yr7qROdiKqaPGdlsNEQ9R3haoh3WKZUFdcHTVXVdkgcoRfSTAFVKOQCWhX5G7xFoFnRheHrJfhDPaOQLwpOHvbWDwh4jIyNH9X+B6gM62VdpIOj426A4dHR4I8OHB2NdhWjI8qIR0e85KpHwLO8HxLweBnW7vR3k+CVSavLhkJdB+u/0lM1+75P4L3dZbe306yM9Ws3lN1PZfcJHpUuGFwVmRJsD+uCz5aSh2Xj0x2UTdN11hO0y/uJzm5BJ1QXdkNbLRs2EXAjnZYLelYYnQnwkodq7M8cfXYl8mSPGqrt3QDxUnSo7iF63D4eqlknk6cpyjik6hV0egUdhWtuRFwXR8Q1PyKuaRFxLY+Ia1ZEXDHltSwirpj6NTsirhkRccXUiWZEXI2IuOZFxBVTJxZGxBVTJ2ZGxBXTr8a07Zi62q1+NaZOxPRfMW0opk7ElNeciLhiymtBRFwxdTUmX/W4PX7yihmvxvTRMWOAEyPiWhYRV7fqREw/0a3jUMw5TMw2HhgRV+1X9w3/FbMfz42IK6a8utXndGtcOD0irpj2GHOsjdmP3RqvXtKlfMX0qysi4orpJ7rVR8fkK6bsu9VPLIuIa3+Y18Yctxd1KV8x57Ux+zGmPcacw8TM+8bEFVMn2IYa6d8IswZ+Hw3lCG8fOiq5VryF12INB+LuK4i7QficG82nI/yDgp7xNZBR1nL+5zc+9uW71n/vD/65QfWNF37H+xP6Bbxa0zZZHQD1c8jqCrWHw2hbGepIH5WhXIyH5N9VxF9/Qf5C5If4mwKeT6WF9sV0125HJifbF/MglPEpqQcFnQcFnaao/6CHzjUl6Vwj6DCurA+gbUt/9xL8mtQvqPtC1L6rawR/Bv+wgMe9WMaPko3VHRS0Gxn/Gh1+x3JDHm4nOg9HpPMwwNxFdB6JSOcRgLmD6HwwIp0PAgzfGv2hiHQ+BDCHEp0PR6TzYYDh05kfiUjnIwDzHqiX/P1RKMPNv8bHo4IP88WPwfscvrg3pB2If4B4yUlveH/XY0SP28f7ux4XvDRF2WvhN5YhnccFHYXrloi4rG+nuva+5tNyHxV0Puqhc3cgnV0l6ewSdAZFvbI2omRjdB6LSAdthm+CeTwiHdSDFtF5IiKdJwBmDdF5QPCQxAMvP3LkffLfx6Csh+omz0Xpv70E33PySL1XpjhNB9FXII9YH+OxR0U7mN52mrN8HOrk8Eej8s6OcHWS3U6S3aNQFiI7g/+nk0bqvZZkh+1i2/4ElD1GZU9C2eNU9kkoQxxY5qAN+I51Dusb3KCox+PVp+B9jv4K/iC54R9w7W0uMl59iuhh25OH526fLkav1+g9JeipfpjmtEyRvuEyG1N+9uNUhr7xk1SG/uxJKkP7Php+I86sNtnebDV2sX4jfw9RGcb0D1MZxuGPUBnGzh+kMmwzx7fW5j7Ckzw2T+0l2PfDx6VvS38rf8N+/FGB28o+JsoS/I8fM7ot6FNQjliWPD3inW8MNThFZ0NJOhsEHcbV69rnlsnDftfgn6IxBH1ZDpu92uT/JLxkf1fQ/1wd6u+yfC/ypXxhSN6r9ysPPP3Zl/14Y94xwuc7Nwj4kr5T5r2Mtsp7fZLKMPdkPKi8V8Gx64oQ+SH+poA/DeDy9IXCdVEkXOxzy+J6pCAuy+1h7MPxzSMCF45LPAY95OHr4x1wXUi4sD77sE90wMU3YH1ctJHjEobrE7iZ9qBrbxv7soJ+MjjXYPgHRBuKxG5KtmqsYT+OdZuijHX+SUHnSUFH4XokIi7Ol8bIYyod5qsRlG094uEZ6z9CZQ8LOjxnTn630t/P3EJ1pOYH9R7n2xwXGPxfwXzsr2k+hrR9sSXndFT+G9/5cjo+OveWpHOvoFN1/ptzOp+ISAd9071E58mIdNDeWkTnkxHp4LjIc4FHBA+Jzv4r2cGnoEzZ5ab0316C3wl28H2PHSCPWB9jLZWbYno/oni8YBwoczqGq5PsfkKyw7mdkh37EIO/DGT3nzl8CMaWn6AylMeTVPYUlCEOLHPQBnzHOof1DW5Q1DP5Wn99Bt5XkdMx/AOuvc1F4oLPED1se/LwvOSzxegN53Q+J+ipfsCcDsoU6Rsuzumgn32CytA3PkVl6M8+TWVo35zTeaJDmzieVvz5cuHjFXM+UYyeN+bE9hWNOc+E31iGdPLGiTFwcX5uPGKhXSXp7BJ09pVYiNe39pdY6NCjRt6jfw8dzw3+v04cqbc6xVllLLQmpTGesdCxJLuisdDfguxOINkhbbZtlBPHQhijcCyEsuL1Ritz0AZ851tTZblhPR6vCsYmwbGQ4R9wpfRjeLxSMaIar0rGesOx0GcFPdUPGAuhTFVc5IuFOL+AvpHjHfRnWbnY5DfHQo90aJMvFuI9YJi7SP7G/RW8pmSwvwt2dkFqZ2qPmZ3RUfmUjwLdC8lWUS6cv8wbO2D9J4mfGGOTWuvmfFXeHDXW5zXRJwUdHtPZv77oKM0P+leMB9i/GvwnoN9fSn2GtNlPIs8co+Xtz7sD6dxbks69gk7VMQ3HaFXFNJyv+lREOjhetojOpyPSwXGIY7SPCx6e2UdDdvAUlKl8PeerDP4isIPXeuwAecT6GKN9QrSD6f0qxWgFx0QZoxmuTrJ7I8nuE1CmZMc+xOCPB9m9KYcPwTH5k1SG8vgUlWEuA3FgmYM24DvWOaxvcIOinsnX+utz8L6KGM3wD7j2NheJ0ULzR9a+zxejNxyj/bagp/oBYzSUKdI3XByj+fIe6Bs/S2Xozz5DZWjfHKM92aFNHKMp3a9wv0dwvsrwD7h2ORbRLRULqXGYxyasq/qG81VqL4jKuSpcn4iIy7efjGMhtW/tMQ+duwPp7CpJZ5egU/U+6fHKV1UVc7WITlUxV2gs9Ekazz8NZSHjucH/7+eO1HvKM4/jtaJPAz4n4Ndk0PttioUK5j9kLMRrUFmy+yLJ7kkoC5GdwX8OZPclj+zYtnHc4XxVaJzEsalao8J3vvibY0isx+NVwdgkOBYy/AOuvc1FxqvQ/FHJWG84Fvq8oKf6AWMhtV6HuDgWQj/L+6rRN3K8g/6M1/XQvjkW+kSHNnEspPaMMS48W65yTjzv+JvUvhJb+z+Us1L7lBO4zUePhqvjsNF1Vd+/GX5jGdIJjZ0ej4irjsNG6PC7PHFYVfERx2H7Wk4qKzf73wE5KV9u1uBfCLHE/+eJJUJyUr44zOAnpL5xLHJSWbLrPXp0W1Qc5pOdwf8KyO6AFGdIHFbnpEb4xHeIv85JZeekfHFYN+SkFH+MKzQOM/jF5DcKxk3Sb/DZpDpeG12X9Sd5TgM4LssbYz0REVcdr43Q4Xd1vBaHTpF4bS3FHEXjtb97zki9UzwxR6x47cwuiNfOjhSvfRlkdx7JLvSuAo7X1L52FcvxOJg3b4b197e8mRqv9ta8mW8NkWMydc4hJF6LkTcLzXExzay47lIqN/irjh7BuYXyZursfgL33Tq/ts/k1/hOBsTN8Vre+63uFjwrOrtK0tkl6FR9TxPHax+PSAdtfl9f58yKOW4m/6bWOX0xh8FvgZjj7Z54LdY657soXqtynTNLdrdEitfOAtm91yM7tm0cG9m/1Ouczz71Omd2vOa7Pwp9Y6x1zo93aBPHa8if764he+eLwwz+w+Q3CsYx0m/wvjR1n2zJe/KC4zXDP0C8FNV/1XfqTgl1jpLvNMM47zSA4zJfXKjmi09ExOWLo+p4bTQdX7xW1b2aHK9VFRe2iE5VZxtC47U/oJij6FmV75wwUu+PPTkizud8EvA5Ab8mg95fkN8teHeX9Lt4txj7ulb6+5l7aTLm8qHnKA3+j0B2f02yQ9ps2yinJ6gMx1SO5WLuvcX6LDc1Fyl57jU4XjP8A66UfgyPV+p8qe+e0ILzh+F4LfQOC4zX1N2giMsXr/E5SvSNfFYS/ZnvvBzHa493aBPHa0r3VY4Lz1RyjkuNSxNFG3P00dRQHTT8A65d3kV0UN3Jocbryb/87+D0984d11537Y4bz9q6Y+POK6679srztt64/ZRXbtm4+YYd126+7pQtW27Yun07Mo2EpsB7LMeHYez3Q+I94vh4h8awMmBnhVyyh7guJFzqkj3D9WQHXBcRLjW48d99rp1PO+w7IQAPGloWX5uIL7X44nPyqJxvI1zqEkufY0Rcbydc6jJj/rvPtfPJ8vLhyXKgyNdvEF9Zh9CT/z7bAdevEq6sy32S/z7XAdc7CJeahPPffa6dT5aXD0/y3+c78PWbxFfW5pvkv9/ugOvVhEtt3jFcX+iAayfhwvpYF//uc+18srx8eJL/vtiBr5uIry9A2RepDOvtJjp5J2lYf6wmabuJzhcj0vkiwLSgXvL3HihTl52qQ0w2+D8N76tImBj+AeIlJ73hwf9posft44TJlwQvTVHGSY4vCTpfEnQUro9HxLWH2pN5EdCa0TSLXmbzJEzCVqc4VezxRWqjimPUZaQNale/gEd8vQS/JuUpubj6ssue/a1s5OMZvCS/cTwNuRB4D7yvwkb2pL9jXQi8h+hx+9hGnha8NEUZJy2eFnSeFnQUrk9GxMUX7WXZyKmRbGQX2MgZXWgj50awEYyhQmykzOWRiM/4wXeIP5aNqFjWZyN7BC9NUcYb6/cIOnsEHYXrMxFxhdrI8yPZyFvBRl5YoY2YvENtxOA3R7ARjJtDbKRMMgzxGT/4DvHHshF1aZrPRj4jeGmKMpwzYRnS8S2OI67PR8QVaiPXR7KRbWAj27vQRl6b00YU71XMvVT+6j74nSUj3wd47hPtUXO8+6g9WTrypjWaH6UjyW+bv/PC+otAR2726Eg3LKzeX5LO/YLOvrIR7n6i81REOjiutIjOZyLSQV8ZekHtB8gOPgtlyg5uSn/3Evwvjh+pt8tjB1k5y9ALag3+/rSg5MYjubBquDrJ7sFI48z/A9k9ksOHYEzPPh7l8RSV4ZjMeV+VX8V3rHNY3+AGRT2Tr/UX5i2rWFg1/AOuvc1FYq3Qg5/Wvi8Woze8sLpH0FP9MM1pmSJ9w+VbWOXL+tE3fp7K0J99jsrQvnlh9YkObfJthMtzWf9YbzIre1l/p3iR4/inBC+qb94Jv7EM6fg+xIG4Ho+Iy9YY6k1m7e+68VDA/hILfT1HLJQ8PJ4b/JtgPP/GGMRC3+qCWOgfIsVCW0F2365jId+z18RCXyhGbzgWUmvYeWIhtaa9L8RCPYI/hFMfHkR4J941PPSYxgRR913EN5ZdRTTy5oCuEvxWmNftCbWvvSWvy2voZXKxITFPyQ2MwfH4WGxgvAreRdpE2+Prh4976BVcy5tg9Hx7u5Be4k/7XXsfdvoQCtLA/sqy+aL7KZ/qgOtCwvXxjDZk9YFvP2XWxmUsO/yYZ/9N/PCBx4yGsb2AQwCzOP3NNoVyeGYvCcH5PgRU5kM5iM85bXv8UcSyHwJS/ZD1YZ4DnF9HsI+y9pmqS7NCdNb3YR3FT94+VZvKE7gjPHBPCjhFK/kb9z0bDo7Fj05xJHK+/rLRbcT6vDf5oRHSw/LCd77DGQan6Nxdks7dgXR2laSzS9AZFPUaGf8aHX7HdJRsfIcwi9JBHePcQFUH3VpEp6pcB+cGHhc8JDZzzjEj79nWfOMFH3rvh/nt+hSn2qPPYx1erOcE/JoMes9LaYzFxXpZsttEslMH0HyyM/h/Pm6k3iUe2bFto+9/hMpQHnw4TX3kr0FlDtrgO4CmLoPYXw6g+S542hsOoKmxTvlGPoCmPsypfBDnBh7p0CaON9RYnhyuOij9PXK46rytN16y+bprt2zece22V1649VU7t27f0QuY1cjBHp49MV4NlfU06O8JVPYQlW8UcPj4RtOSVxwER76Gf8C190IRy1EnulSUwVf1YN2mKPst+I1lSMf32UHE9VhEXPyJivoqz2w6vqs86082Z9PxfbI5K1p5B0UreGw3JFox+HdAtPIuilZw1OCd9o8DPifgOdIz+PdSpFcw6yYjPV59R1/XSn8n7bwtQHbo07Jk9wqQ3ftIdkibbRvlxP4F+/tJKkNZIQ4sc86/Oq8igjHYtRAc6Y3FrgV1NU7Jqy+GIz0VWap+wEgPZapO4vqu8nyIytQ1FsqfPU5leT/ZjG0KifRMtx4QdKzsUSh7mMo+Jtqc2N3jZHf4ueiN1A4rw3bgO7aRjYIfReeD6e9eauPvk68reM3TyYNEx3Ag7scK4g61y6y4AfkaEGW9Abz8x8x1h//77h/e1aD6xgu/mwD4UZcRfqOALznmPHcQaDiibWU4Hj5GZX1QZjwkWctVxF/BlaHnhshP2T6W8aco88aaiOvhgrimu9F6hbZj9od+5EPp70HXbtNsJwVtMHi+ZfgHXLsMioxfyvcqn8U+Aus2Rdmb4Tf7lh7xboIH1wMRcdkYoPqZ51sPCDoPeOjcLXhWdHaVpLNL0BkU9RoZ/xodfsd0lGzGOrP+wYh0UA9aROdDEel8CGB4vpU1Z/gOzRnwGvKQOcPwHADmDP/qiV2QR6yP48vDoh1M7wcUgxQcW+R8i3dXZMnu30l2D0NZiOwM/ofHjtT7iUd2bNvqeis13/oglWGcwDmlvPMtrL+/zbfUGG/tK3iTx/B8S+Uj88y31E1RPN9CP/swlal5tPJnHHOhffN86+EObeL5luKvjoXCYqHkOQ3guCxv/PLRiLh8MUodC42mU8dCrhCdIrHQymNH3qN/zxsLvRfG80PT31XGQkemNMYzFjqaZFc0FtoJsjuWZIe02bZRThwLqZyOipN4Xp/3VBLWH4MdusGx0Fjs0FXjVYwTgcl/nW7uVLFQ1q5EXi9XfpZzz2o3oPJnj1GZLxZ6qEObfLEQr7tj3phhH4T2Iux6sLMbjs2m9WHi40Eo+wiVhdon4kD5oq9A+G3UBoPflPKd5Bq3X6ZxTnBaR83/qNyntWMi0LWyHPr7dMLXCy4boYP6kjyYN0V9cc4fUxn8hwU86hzHhh+GMo7nlD5ifGH6qORlPFYhL+QhRF5qDSxUXmz3KK9HCZeKf1GGPnkZj1XIC3kIkZfa4xIqL5OBktfHCFenOc56gjfc/U77BN41bfDbwCfwrTw+H/+gwI2+sUE4sB1bRTsGqQzrJni3HP7s77HK83CsqW7cQf+N+yAQ/g0wbtxCslHjtG99S+U4fDtJcRx/MgDXwx7avk8BKtrIF++R4b05Kt5QfsBkU9IP9Ck/gPkq9gOqn9SJJ5+sVD+pNXfeGxeac+KbFUJzTnjS4paMOQm2I8tnsz3gfIbnOmqe4NM93xX9SvdUjlXZP/sNta9G2RL7Dexb9htFd8LvojlqFTvhWb97ndbvrB3unwDftjvDt/XlxPkAjEfrwUad0+vtJX1Br/IFaO/sC3w+OHny+k22W9/+VbVujjLlmMBk1C/gER/vzXssMCbw7S735cB98z6zh0Tuf5Hy0WkP5CdJ99RtDr49kAb/V6DPT9EcL4bf+BCVqT1avjFH6ZnavY9jKNczP1By33lwLoX3nZe9sT10nSfGJ5eT/9TJGdUPmEvpdHrTfNVY+zWUU4hfU2tNag8h2zP6CPYDas+rWotheugjMBb/i4wcNLYjNGbB/PVKsn+0L7Z/tHG2f9R3jhtQhhw3qE/GoQ/CMRvh/wZ82PdJNkqXfXGs2sOqPr2tTqd9OgDXEx7a6rT8pz201efpmRfnsm1S2aLJpor5BsYFbIuqn9Q5FZ+sVD81CR5lk9d2+YQYju9s16jbeBL1+xnjNrZD5Xg7nU7/pGcNqZtzBf8Jtjv5uNE461xBO591rmB02VjmClg/Y+UKeI9YnSsY+Z2VK5if9kU35wqOgP2OizJ8W95cweIUT50rGL9cwSrog/HMFWxI+eiUKziKdK9ormAj6PMx6e86VyCfOldA9OpcwfjkCjaQ7cfKFXyH9qDvLbmCS8GHvYxkU+cKsm2yzhXks90YuYKXZYzb2I4iuYKjaOxGvofP6rhsm1I2z+f11afduf+ycgWGt5fgd4Dtvo1k4/t6dPLktR+eMyn78eHy7TFSNyI95aGNfPEN7GzL6gx9heOotF20T7Zdn89MnhBZqX5qEjzKRp1D4n1vOA7xLVE4DrHNo27juMv6qfY2hY67uNeI7+94ogNelqfvSxZq3FA5FN8ZMWX/7DfUrW1K19lvWH+iriI85woM/nbKFRS8cVXmCvgLAXhvhdJvnlsZ/EfAt70/w7f15cR5V2CuwPqxipga7Z19gc8HJ09ev8l2i33Dd8aE3uDGdtbvdAyRdUPrw55cAfojjjPUTZPKH7EfU/cpJXL/A8oVqJs8E7hHSfdUXh99Duuewf8x6PMTFG/E8BufpDL0A3wzpxpzlJ41RX0cQ7me+YGSNyUG5wr4FvuyNzmH3mIf46bq5D/1xeCsm6OVTNVN5r5cQZV+zbce0kmuPHfHNrI9o49gP4A+gv3Hkx56an6HPsLnI0PnGxizvINyBSrHqmyc7R/1neMGlCHHDZ8BXlTMg2M2wn8VfNg/kWyULvviWHWjP97Gz+swvq/9Kly+PIX6Ss7nPLTVV3KYF+eybVLZosmmivkGxgVsi6qf1Bc0fLJS/dQkeJRNXtv9DJXh+M52jbr9FLT5nzLGbWyHyleqeADH/Edp7K76FuessTsrz2d4Ofb9Adhuz/GjcSr/rG5AZv+B8OrLe775ug+Xb33Mp7+KNvKFdZk282n1lO2abKqw3ZjzAyUr1U9N127XbIM4//at47F9ht4oPSoHRvrZ6Syrb9zFdWW+1d237yJ5WJ6+PKvSPXWDurJ/X26N/QbqKPsN9ZVNtjPUVYTnXIHBT0/7ouSXfGSugL9eh/kMpd88tzL4FfCFglkZvq0vJ865KZ5OuQLrxypiarR39gU+H5w8ef0m2y32TcheMPV1GbazfqdzlrjnBeGXQB9wrgD9Eec1Q2+4571T6isbidzPSPngtZjkdwvgDiHdU3l99DmsewZ/NujzYenvmH6D85YqZ+Qbc3xfzVXrAkqfzQ+UnEsH5wr4q08FcxPerz6p+U5JvzmcK1BzHNUPmCvo9KUzX66gSr/mWw/pJFeeu2Mb2Z7RR7AfQB/B/sO3j0HlwtBH+HxkaMyCa57nUK4A7cu3Lsb2j/rum1tz3KC+KKzmXPyF3wvAh11BslG67ItjO83XOfep5us+XL48hfpy7Oc9tJEvrMu0s2xS2aLJpor5BsYFbIu+HE3yhMhK9VOT4FE2eW33s1SmvvqobBdzYFdkjNvYDhy32Xaz8oeH0NjtW1eM8TVonlv/NvDC6/A8DiD8dWC7byTZ2JeJnQvTCfUlZPy6Mfsp1IkvBuDy7QnaI+C/6KGNfGFdps18Wj1luyabKmwX7Y1tV/UTwofISvVTk+BRNlam9tkoG/xtKgv9MvXnoc2sn2r9P+tOHrYH3BPEX4dXvtCne53GLNY9NWYp+2e/gfbPfgN1lP0G9i37Df7iOMNzrsDg30W5gj1Qp2yuYA/x+AXgQek3z60M/gHwbe/O8G19OXHeGpgrsH6sIqZGe2df4PPByZPXb7Ld7oEyzumovAPKlHMFJqN+AY/4egn+Hk+uAP3RF4h39Eccg6jcsfJHmCt4mnIFaLstgHuIdA99GvuL5GHdM/jfAX3+IMUbMfzGZ6gM/QDH1mrMUXqm1opwDOV65gfMr6AuVpErMPwDrr3NRXIFyv5wfOBcwZ5i9IZzBU8LeqofMFeAMt0Dvw2XL1dQpV9DOYX4NYTnuTu2ke0ZfQT7AfQR7D+e8tBDH4Gx+NNk+8pHhsYsOD//euqIlI2z/aONs/2jvnPcgDLkuGEP8KJiHhyzEf6PwIf9X5KN0mVfHPslAf80wHyO2rMHyr4UgOvzHtpfFvBf8tBGvrAu086ySWWLJpsq5ht7EADwZvUTwofISvVTk+BRNnltdw+V4fjOdo26/UVo8//NGLexHThus+1+TvCK8cDeliv4Dtjuz0g2yj/7cgV7BLxvvo4+bE8ALt987WkBv8dDG/nCukyb+bR63ZQrUP3k87FKVqqfmq7drvdQ2VjmCn5WUa7gwX08VxAy5qOuIjznCgx+4IRn/7X4E3WkbK7gaeIR8xkh83qDX5zymPTx4AkaZ2iuYDhHluIZz1wB2jv7gj1Q1iPg8/pNtlvsm/HKFSyAPvDlCjivGTtXcHLKR6dcwRDpXtFcwTrQ52Xp7ypzBegHOFegxhylZypXgGMo1zM/UHIuHZwr2JP+HnDtbS6SK9hD9LDtycO5gqeL0RvOFag5juoHzBXsAZpI33B1Y65gD5SF5Ar2QP2iuQL2H0VyBSeT7cfKFXwgUq4A9Z3jhj1QxnHD08CLinlwzEb4s8CHXU6yUbrsi2NjzNd9uHy5gt8R8F/20Ea+sC7TzrLJsc4VPI0AgDernxA+RFaqn5oEj7LJa7tPUxmO72zXqNt73EibL88Yt7EdRXIFHA90+q49x01qj5VvftJp76hvr9FnqUzt1Wc66g6w5PdN6W/ea7Q1MKY22iX1fWrV+2g6zQf57Az6bt7zgjLG80g8NuAZlzfR2IC5KN6T4bvrgetiH/RnwPN+MoPfIWJ2nz77zn/l1WdsQ1l9RtvYSW01+NePrT5PGW99Zp1FfeackNLnhmv3YWXyOdd3of7/5n6k/+/tcv3fA2Uh+v+0gN8DMKz/T0PZeOj/83Po/x4PTaX/1rYs/Td8HPff79F/JV+f/ndaI/Tp/5eoDOs9nkEH9X8PwLD+G/yHAvXfaFeh/ygj1n/fvCl58s519qS/Vfzu039er42l/6fm0H9f7K30f0/6d5b+Gz7Ol3/Go/97BA++c4xPC/g9AOPT/6epDOs9nkEnK55n/Tf4PYH6vyf9XYX+o4zKzl875Rk4nkfb8On/00Qnlv4fSvqPZ9w5N5T3HLvv7gprhzqzqc708ZnNv4Tc0D/SHFnFSL47EmPMeX24fPbZ6W4Mpq3uxmBenODT6lV4/quv6nOtSlaqn5oEj7JRtsVn3EPPlfjuysPzYqyf6ox7qO3iGfevHj0a76c64M17hyvfQaPucFX277sTIuQcu9J19ht8BxLD81q0wf+I1qJRR3LoulyL5rtq8By+0m9euxs+t/qcZ/9N+vinGb6tLyfO/wocZyPdVdNb9V01nfwm2606m9agvxGXWr9hO+t3eq7L97IMj2Fpv3Zai+b7ONR9Tcof8Zk7tBlci16R8sFndJPfLYCb/JzR7S56F+Mq0Oep6e+YfoPvw1J3HfjGHKVnTVEfx1CuZ36g5Bnw4LVowz/g2ttcZC069H66kn5zeC1a5QlVP+BatDpDi7h8a9FV+jXfPT6d5Mprw9hGtmf0Eb67d9h/+O7fQx+BsfgKsv1O9+dwzKK+8fTMPXtpzKJsnO0/7zl2tWeO44bPAS8q5sExG+GPAh92OslG6bIvju10zpzvD1LnzH24fOfrfWdFFW11bod5cS7bJpUtmmyqmG9gXMC22GlNNkRWqp+aBI+yyWu7vL6tzrEr28X8++kZ4za2Q92zoeIBHPMn09iN9H1jt+8OGr5TAe2a76dRawzoZ7LupzgfbHczySb2/RQ8Z8p7P4XvLr5OfoNp1/dTjIZX/RRyP4W6r0XZJ+cY1N0p6u4knNOxfnb6pphv3MW7ZW6hXIFayyxzD6TvvlreK4r12G+Ejuu+u1jYb3B8yPCcKzD4bWlfWPyJOlI2V8DjOJ65UfrNcyuDvxl82w0Zvq0vJ86dME/15QoijeO9VY/jnfwm2y32Tci3ilCmnCswGfU7nafg+5cN/qbAXEGeeEHl75Q/wlzBA5QrQNttAdzbSPeK5qkeBn1+B8UbMfyGL7bmfatqzFF6pvYG4hjK9cwPmF9BXawiV2D4B1x7m4vkCkLn7iX95nCuQMXhqh8wV4AyVff3+HIFVfo1Xw60k1x57o5tZHv25RPRR7D/+KSHHvoIjMUfCJhvhMYsON+4mXIFvrufQ8/Jctyg5nM8bmTtaco6J/so+LA9JJvYd2rxPvy8d2r5cux7BLzvDEB9p9ZoeNVP6syJ704tn+1yjgHHd7Zr1G3cX74nY9zGdqi1EBUP4Jj/Nk+u4DE3uixvPkDZPMdpKvZV3x3g2PcPwXa/UXGeL2S+7sPlm691yvMx7TrPNxpe9VNInu8xKONcQah9ss2jbuO4+42KcgVnU65A+QSf7nXaT8O6F3qGhP1G3nyA0nX2G9afqKsIz7kCg/9XyhUUvEdK5gq+QDxiPkPpd9aZ4MZzn/036ePvZ/i2vOeMfxiYK4i0fzv3WVCfD06evH6T7VaN8Q36G3GpM2BsZ/1O5yyzzgv83JMrQH/EeU30R5wDUXe7K3+EuYLFqX7xXCf53QK4nueObrfK66PPYd0z+CWgz/3p75h+g/c4qZyRb8xReqbWeXEM5XrmB0rOpYNzBYZ/wLW3uUiuQNmfmu+U9JvDuYLQ+/cwV6DmIojLlyuo0q/51kM6yZXn7urOF+UjfGsY7D98d/Wjj8BYfDHZvvKRoTEL7ldYS7kCtC+2/7z5ADW35rhB3Ser7ibi+2QPAR92EslG6bIvjt0j4NV9Pr75ug9XmXNPvvtCsC7TzrLJCu+b6Kv6zl0lK9VPIXdqhdou33mn8gHKdjEHdlLGuI3tUPlKFQ+MGvNp7N5bcgVngu0+n2RT5wra+axzBaPLxjJXwPoZK1fQW+cKcucKrk77optzBb8Kvu1lGb4tb67gFSmeOlcwfrmC10IfjGeu4K7AXMEbI+UK7gF9flOdK/A9da6A6NW5gvHJFdxVUa7gv4969vfelit4CHzYU3WuoI12lk3WuYJ8thsjV/BURbmCN+bIFSBvvnlE2TMIuCcj6wzCl8B2/xfJJvYZBN/+x6rPIPj2XtVnEPx3+/nOIPhyBTjOxTiD8L8CcgXqTOGga7cHzBV88ajReGOfQfDdO+I7g8B+w5d/GOszCH9PuYKCMX2lZxD+C3zbP2X4trxnEP45MFdQn0Fol2msMwg/DswVcJ5D5c7LnEGYe+KzvzudQfgZ6V7RMwgLThyp9wuKN2L4jfoMQn0G4Rnk6b/76hkE9BHsB9BHxDiDYD7C5yNDYxY8g/BJyhWE5gp963VjcQZhCHzYMSSb+gxCtk3WZxDy2W6MMwisn7HOIPyMxm61hjnW+wrU+UyOfdeC7T6PZBN7X0HIfN2Hy3e3Yaf1MaZd7ysYDa/6KWRfAebEeD9C7H0FrJ/qbsPQcRfvNnwj5QqUT/DpXqd9Bb47SXz7CthvdNO+gpekfdHN+wp2gm+7IsO35d1XsDXFU+8rGL99BddDH3CuAP1R1fsKbqVcQda+gteQ7hXdV3AH6PPr0t8x/Ua9r6DeV/AM8vTffXVfgbrLrKp9BbeS7SsfGRqz4L6CnZ59BWz/3bSvYBf4sCdINvW+gmybrPcV5LPdGPsKnsgYt7EdRfYVcDwQet9pg/hFeN93aZTP8e1XULGQWucM+b4Ctm1T+i+v/XwuMKauci0eZVT22wGd5oN8165ar1H6bjQ73Xv7IhobGgB3JfHacO28NkTbmhn1FS7slzXw+2goR/i/pbkkyjNHv24YhDoOcCDugjqzAdtqj4onMXZS9JJnQJT1BvDy5RP2nHf/z9ZMaVB944XfsV72CfgrBbzJqp94b7mg5zxlu0bbyrjtWIb2ZzwkNruK+OsryF+I/BB/U8BvBLg8fTHdjdYF1HezV7yj92Eq830zQ/lmX86Z/Rv6bfwOCK/ZG/zfQyz304CxEuPnKr5N48Pl+w5tpz1uTFvNZZkX57JjgArvjO+r+lsYSlaqn9SaLeeSHoYy/h6Vb1+H+vaNbw+a0s9Y37Q6lnLHKjbz6V6n2Ix1LzQ2Y7/huz83b+6I7Qx1FeE5dzwMf9Kz/5bcDyJzx7zn9LPAQ55c24KUx6SPDzhJ48ybv5uU4hmjOLe36j2nnfwm261v74H6npSaW7Gd9TsdY/O33Ax+NvQB547RH/HcUp3vUP6I43e0Gcwdn5Dywd/1SH63AG4R6Z6aY6HPYd0z+BNBnxenv2P6Dc4roR/gdQI15ig9a4r6OIZyPfMDJb8bE5w7NvwDrr3NRXLHyv7UPLOk3xzOHYfmqjF3rNbCEZcvd1ylX/PN3zvJlXO5ai1V+Qj2A7698U966KGPwFj8BLL9Tt/c88UsnwK8h1J+AO2L7T90n2lIzpnHDeXDeMxG+FPBh11MslG67ItjO617+tbCvhCAy5cf6rTHjWmrPW7Mi3PZNlnhOk5f1evTSlaqn5oEj7LJa7ucHw7NOeO6z8UZ4za2Q32bS8UDOOYvorF7b8kVvARs94aMeNq5OlfgqF6dK2i33apzBayfsXIFPzlyNN46VzDyOytXcNNekCu4A3zbmyPlCt5a5wqGy8YrV/CeLskVPBmYK3h/pFzBp0Gf76pzBb6nzhUQvTpXMD65gicryhX8axqz7G25gi+AD/uLOlfQRjvLJutcQT7bjZEr+IuKcgUcDzwi8D4h8DZcux8K2Wem9rGhPPi72mr/krpr5+EMOioHkTy8z8zg/zYwpjbaVeg7yoj1XflshGd5+761jDJR+xz5rBbK2Ggaz08InAnvX6Wx4VGA+6gbXfYxKHuMynCP8+NUhjqCfGA/oR48ADCGt5fgvwdjgzt5NE6lwx+Dd9wHvj5DfpReh8xrHvXQ7tT/TFvdh8G8OMEn6oPRsjKTTRW2gv6HbcXna5InRFaqn5StcFz3USh7lMp8dyc9DmV8xhJ1G88msn4+KtrxALzjseEBwesz5wcoF/Vxgdene76zl0r3Pibap+yf/QbaP/sN3zfhsW/Zb+B83wl4zkUNn4tI+8LmN6gjOXRd5qL4fMUngQel3zx3N/hlKY9JH0/P8G19OXHOSvF0GjetH6uYs43luMl2i33zMcL1MYFLzd/YzvqdjpEMXy/BL4Y+4FwU+iPeW47+iMf8xwVd5Y8wF3Vqyoc6n9QCuOWke+jTVCzJumfwZ4A+H5L+juk3OCZFP4A4ssYcpWdqnsAxFdYzP2B+BXWxilyU4R9w7W0ukotS9qfOy5f0m8O5KDU/Uv2AuSiUqZov+XJRVfo1lFOIX1PngtQZJ7Zn9BHsB9BHsP943EMPfQTG4qeS7SsfGRqzfAzwvpzmG2hfbP++u1pR3zluQBly3IB3NamYB8dshF8PPuwlJJvxuJfSh6vqey6YF+eybXKs5+YYF7AtdsrJhMhK9ZM6A8ZrYaG26/suO9s16jbme1+SMW5jO4rcsbKcxu47Ae49bnTZ3VB2qBvNzy7BD8LfTvD3pH/3Z8Abvl6Cv0bEW1MJJvm9OoMe8ofvOEbA+vdk4EJ/g+17WQbvrxTxuuG8V/C3WvBn8LsF/L0AY/wo2ex2mja2ZxfA7KT2GPyOwPmH6VRJ3zBF+QaUG/uG3VDWI+BZpvcJ+N0AYzJpEjzK18reA2X3Uhnazt3Ew52Ch9vhHds16p3VTeTw/MOe/W39fxfAdaNdvzXQrt+fQQ/589k11s9r16/O4P2dOe36/YK/brLr9wbatelUbded7fouwUOoXVvdRA5nHjYa74NQ1uPabZ372ODv8+jsQ4JXlCHL92EB/5DgfyrxgHWninr3UxmuhbDfeUTIAeHZdg3+QyCH7R5dN75K6vqg0nVcI2Nd/yCUqTU17osPCfgPAozJpEnw3C/4N+LCvuYcmsmo3+k+MHy9BP+kJ4d2P9TndbPbc/J+l+B90LXbDNpUMzVq08H7AG4X0XzAQ5PrIp3+DHjDx7b7BSEv9nVq7S15NhBOg3/a4w+ULO+Gd6yDyn88KNqlZPoQlWHOwXRB2afBVTEWYfvZPn1tTZ6ivlKt/95HZWgbrP/3CTqh+o869LNVo/E+AGWG91aoe136u5fgv5pTv3bDu7z6ZfwoHWL9wnr3Uhn2C9vuw0IOCL/NjZaDwf9N4HhjfJXU51OUPqMOsj6rvSgIz33hG59QJk2C537BvxEX9jWPN8p/PiTws//8J894g7E2j5X35eT9VsH7oGu3GbSpc1N7Mx3cDXB3Ec37PDS5LvqL/gx4w9dL8D/wjDe7gXeOFRtu9L0yCP8jjz8wutiuD8A71kEl+/tFu5RMfWOR6YKyT4MraZ+nKvvE9rN9+tqaPCwb5VtRd63/m67dH+6mMrSN+4nObkEnVP93Q1uPW6XxZo0316a/Wb/61j77r9Kv+1w7r5jnYBkqfUQ94fFmN5TxHAbr3U1lKFPOTahxF+E552jwU0AOvvEmkj7PUPqMOsv67NPP5Mk79ptMmq59PNhNuHYLXNjXPN6YjPqd7gPDx7H1POgDHm8wT/AA8X5PTt6L2Nt8Gm9wTsPjzT0emlwX/UXWeGP4OP+0RMirQTTQDlBOPN4Y/MEef6BydL7xZreAv1e0S8l0N5Uh76YLyj4NrqR9zhzvXBuPN+gPOQ+HtnEv0VF56VD9Rx3qo/GG83SIC/XCp49oN5PT36yPJ3j00WdnycMyV/qLesX5N9RHnvMg7z59jJT7vUTpI7af9dHX1uTJa6vWn03Xrqs+feTxWeV30YewPqIeYX73p4eMhsM1wEb6r+2d2Qrvc8h8QoPwGc/4DvEPEC856Q3vR9pK9Lh91neJzcxIf+/cce111+64cf22zVtO23z99p3XbZ2AqF37ihVKBbHiu4Yb3Xos66F3kwjuTPp7vajnBO4eoHs1lClJGE6zSmzT1Rn1UBZOvJsg4LcSrq2invHe46mPOLAea0yD3qPXHBS0ewn+UvCab7gsm+6ga5fDIP29Q9Cr0Oqm7x9WN42wGgzC4jMNOEP4SfQ39+gGUY8fk1gv8bwl1aJE+zanv63nD4K6tr/WyoYAt90z+8x5LsJxKPGg/kXe8R2PXzE8Ba9PJs9FVO9qqHd5AA9XC56bor7BDYp6RWXT9PBsdNCbtNLfSV+9au3I++S/a6BMeSJePzX4fwAd2pH+NlmixRqPSs4vdqN5ySvnFws6Vcv5xUTnmoh0rgGYFvxO/ruFcLGcrZ9Mzi+Hsluo3ruhDOFwlLsF3r9b0Fb4DUcnHbx5rW5blg4arV6C/wPQwbeTDqrRlEdf9/+39y7wepXVnfB+c04OOeSQA4qfUhw5SuvXirYUpEWnwAmQECDEEEQiFCtIBBS5CAhYdVJpvVSrCASTnFz2SUIukAvhIjfHqWNtbes49rOfth17/dqxw0zbr/xwnGmtTjfZ65z/+3//z9rPvp2T4Pv+fvlln/2sZ631rGet9axnPZed+DrPejkUgP9p4s/gf8OZx4+INiNfvE5p8Hc586YR0S7lK712oU6NBNp1r5PPUVGIGltOorJXQpn5cBxbBgnHRP5+XtLbHyWiBHnmKcQ3whndE6rRjZ6DGP7hpFeGVaKhE4get69aNITSZ6kgVnzXSbpbj2VFc5Bl9HeVOYjyAq8QOM2jqLie67EV8rs5Av4EwqUsiL2zqo84sB5rjKqX/T1f1ImxgIrx+UCsBRj+piygqN9NV63tqwQvo6LscHjGMqSzStBRuF5JuF4ZyXPWhy/On3OrveiWG967KjfbhH5Fk44TAmzMEfUTqsumzYH9K0ST0HSWBmiHBmHDN0jwT4jByqufJHFqj13UhuM3/E2pfawK8SQO63qDfCfp7cMZUtXstyzAhhpREsLVEe+yn4ol51G9mVLj33Firnmi/vNx5VHdtIvibJ7rGfxXnZhTzQ28cxufEfA4HzF+FhAPWHeBqMfzTNynfA3xcHfSKweE572yBv+HkWvJxlcbe2XvBgBeG8A1kgEBz31xr4DHdSKTySjBc7/g34gL+5rtwGQ0lOg+MHyDBP/njh3gPP1u4v2akrwrG1bzWrSpX6M5KNLkofTdDk2ls0Yn5DdCc+T/5sxBVe4H+eI5qMH/D8cfeHmK7Mc6qPzHp0W7lEzvojLMSWA+yHAzzjb2ymL72T69tma/qr5Snc24hsrQNlj/rxF0YvUfdYhzi+gvDO88gdfgbT+76TjDYH8h/A9BH88ln/BKqH8vtQPPn3Ty/y28u494H0uiftHhneEfJl5K0psK7+4jety+avN6jnZQKogV33WS7tZjWVEUdzb9XWVe/1koU5LgeT226bOBeqy5/G6OgL+PcN0n6hnvA059xIH1WGPYitCr3ytosxUdecaB/9XaItLFqIF5sb9XCXpmdZ8l2CSZtrq11KaxJOq3MtbqDP8w8VLV6tYSPW5fNatDTUEqlxBWg0FY/F0CnCE8T/O5964W9fhnEhsknn8q16JM+34sf16Q9Grsq4hv5MHzX6OiPp8JRTrH16RzvKBjmjwMZbxWOl+01VsXUfHDciq7S7TLyj7j4LzbwXmPKMv6bu8Z3XDojTqB/7PfgHjHMr1P8Gp9hx4AUx4ha1vr0MH6Bjci6tVtj+KZYwxsaybf158x/T77h2fX1WhgcdYgwf/Uyul6P0/2hndZGI9KzmyLZeX8KkGnbTmzTa1vkA7uTRuD5+zfBsLFcrZ+8vYTWr3QXmOMCNTdAYhD4TccRTq45AzdtpAOGq1Bgl8AOnh+RR1cT2XYBzweensNsQ+4XUMB+FC7VkBExLmG+0R9xTvfw7Le4T37efewGFzbOv/TRCekP5eR/uA+TqU/nKMw+O9dMl3vbaQ/GKG10X7PrjGS41mDsjuWpaqHNvqzETyoc8ajoj7uVeZ6dXVD8VykG9eRbqh94lj3uvyZ94n/BejGDaQb6D/5LBHyzDFgWTkfL+i0LWeO7zY1SAf3bo/Bc/YvJVwsZ+snkzPuJU+p3iSUIRyObym8nxS0Ff7Y8W31GbptIR00WnyW7sugg3c6cxpPB70zMXymQp1/UH3QIb6HAvChc0a/LsY3z15Rb9iXG/xvAM6Yc0ZqtuzpYtlzRh5tlPPSAO2hRLc/pCv3OjJV9ythe1imBv9ZR6Zp0tsuT6aTAj4V7VLnsyYJl8q0oZxjZIrtN3ws001OHLZe1FexA8eQKg5D+HcTvLIxFZuwjW2LjCE5tsHcAu+Vw9zCOirD3ALPxTDvP0FlmFvgPAfmFnj8uxvKNlKZOuuIuYVBauv+/H3NHLzc03cf8TYM8J3A/0kSN55iXx1OdNrKmzCdzzZIB3FZRl7N2XhNs2zeAOt7c8P5NenMF3QYF/rkMYDhPbAG/yWw68Xkk9UdhvPh3VKnrWzPiMv6zOwDfV8ba1SGf5h4KUmv4/lcbB9vQZoQvIyKslCfIp0TBJ2yfM3P6We/PIt/9qorb7166Q142uD53yD9vSjA4rEEtzTAWkfg7dA/fn8svRsQsIh7pkxvNum8tiad1wo6bac6X0t0QtOdPy2ZUuYrMwz+EZju/IUz3QmZHeqatxXO6IWW+0cC/P0NuN5zI45VvMvheR3QYLrZ88kBHp6hUKWiK5ahCqdCkZ9hKsPQg6+ExBBnQLxjnVsj6DCu0DBpcuWQ7h9LDpPeQj3ytI7KcGhiOSg6yr0rOXh0XleTzusEHW/Yr+pLFM9qKjGWP2d9/APyJeuhTIU0vFXM4CfBl3TGDzwrX4I88t/KL4fGyZAvWRvgb2j8wP/Kl3BoiO1UPOMUkOkqX2Lw88cP/G++hJeCxpK4n/IlvDSB/JxI/JcdC7H+TI2FJxKdtpf9VLqf/Ytajppw6KgltSJ7PGZc01T2yOMawl8L9vjy8e42qrE9Zqmubd/LuGLHIIP/8fED/zcxBq2N4G8w6bWp7PlnoM0hXIl4Z/A4/nH6Yj3BrnNgQ34re74+f27bvuwSEWVfryf+ytoX1o+1r5PHNc2Qfd2UP7N9vRns6+fGu9uIywEsV14CQNjFBLsR2h2Ldy7VzX7LCXYD4UWdfGvS3d6p8X18Gv9p+fOIoFVXdzC1z7qDKepT4BnLjA6/YzpY3+DYFlh3Fo1rmqg7WJd1Z+ozCuPT9ZaMh9vIadYm5GzvN8N7pstLkCnBYiqf08Sbqa76v4hHdQ1nSngnHf55mX6jqNf2cmtKdNIG6aRQdinRCenupePT71EOId29LX/mKx6vGJ+ud3n+rLbDsO6iT+UtlCr9l+H/8ng3z1sAzuR0mahr8FsJHnFkP55bbMv/Ds0trC5fs/zO8QP/49zC2jYp6GVtu2Zctw37YxJobyXaBv+R8el6786f1TWr1h/qqnC2AfwsAMMuDsjg5vHpOjeOh2ml+fOI08YMx63jYbjFAo5xzBEyMBzKL1g9dX1tmnTT2EI0Jh0aqajnXcE8J+mVmbo69v6CcvUZgkS8myPgtwTamwjaWwvwTgo8yr9vpbJNoox9F7Y39gpC9HvmE71rie3vbdSuLU67Nol6bOfI+6TDu5If+g8vbrC/Y8b6jvjb+LsZ3rGPTfO/Q1surS4v9d89fuB/lY9JoZ1qS8ZNAZxrAGfMVdinwDteKvL6CfnxrsJWvKdJ9w/febFMInhAX6h0NhTHsTwUD2r7jfKbKfGj4vBY28R42mLtH7U5xq5xTbPsHOMMmJ/uHg+38VCYY3DO/GCYY6wjPP05RpJ8YXz6Pcqh7BzjaNDdL+Y4y84xeCtV0RzDyky+c0Q9Pj5g9J4Zn8b3FcI3H2ih3mS/5QCHujgo6mfPvK5g8F8dP/B/Nu69KR/3Foj6v0D0cF1HrfWwTvyC4CvUTjWGsdy+M37g/3lJry2WWA9Z6Om/4Z6siDvGfpTNI700fx4WZYMRvFz/vStOvmLo/b/LdmW88LuYWOYXBLzJiufNY0nU77QRoJEQbVzjT5JemWW/uVBmPGQ6/Rrib0tF/mLkh/jV1f23w3OZvlC4Yj5zFItrXUVcRyXdOop2qPw9525Unjnrx3kLDzwrP/RG4rWsH8L6ZfwQr9tMwea8mn7x8bqxJOr3ei8+MdxpRdyxfijNn0eScL8Oi7IYP3TN9xfe+B9XfOPfdJJefzsg3sVsSX+jgK9p5ycqP8S+Bv1QSmXoh4wH5YcqjiknxsgP8atcEvshD1f2m+PgmmgQ17qKuMwPeWsL6Ic4vlNHbNEP8XrW6MJpmMMXduPyctUqfuMYU5VtEDgz2q9YOF0H/dVQ/v+FUMbrgWqObn/jO9R1rMPr6Ab/UpDN0cQfrmVjO5E/1V+4x+aYhWG4jQ6cF9+rdXAv9o/tFx4rXkljRcWLTOQeHsOV0fq/8ud8+/E5q2656Jor3rvqqotWveO9q24ZAEzIHWOyv63VWI9/xgnvPL6H/uYdaxP09waBp4im2mFyKjwz3ZgdJqcKnmeTzmk16Zwm6LS9i/A0ooM7U8by58xaTlw4/R71DWf+uDtlRf4/e+WFF0/XOznHqSJIljNa4cKkm5eyu92w/to+ncbpnFmTzpmCTtu7Ec+k9qCNsNzK2jXWXzfDdIrsetlCTTPWrg3+uTdP17vQsevQrn1sY9kDVuyTQrhWEC6s711asjaCjnfxR+zlKDHt8ejMZnsMl9rhh33wZocvnqVsKMB1EeFSF3koHWSey2YnsP58h85ETToTkXRmqj1ratJZE0lnYU06CwWdEVGvE/jf6PA776TaQqIT8re3kb9VFzWhv+XTGAb/V+Bv30/+Fmc8L3Q5t7VqPEZ0Qv35EepPtZrr9afB/x7058cj+lPJJrQrEul6fa0uzukIXN7ObZYDwqsxpcWMavRnCtP8eZh4KUlv6nD0JNHj9uEh5KPz5zwLsHDVzT970qln/2sK4I4bbwllV49Eokn3yjrCJ/Q318t4GySY+YJG9mP92Uhw3O/2nvHH8FQEW1SufN3mQDuTJM7XYf35AVyh0yxp/syZpomFB/5Xp1lUTKYuZPHiAbUij3ADog2HB+p9MNH8WZuRJ9Vmg9/itHmioM0cv6vYkX0Tww2INsxLenUAcSgZn5V0815Wn7D+TI2dZxGd0Ji2d+H0e5SDGtOy5w/lz3yC5nEY0/bnONUJtZlqP8ev6nrtDwFMaG4zGMDJuzcM/qm87TVXH2VGmVdQhgX/Wfs+T32q2u71qcHvgj79DxF96tmHuqzZ8wXrHHg1V1Q5Ji9utP7hHbJjScyv8xcxOor4h4mXkvowFW+oC9GwfVXjDcP759Ag5L8o3uB6XrzBsCHb4xhgA70vijcUTyHYOvHGxkA7kyRufMD6Bmf6WfEDE2PGy1rgQ+1gDp38nZP02paCVzGG2qXBvmgw0ePwGJQj/DcWHvg/iyVWOLvizg7wlyRxfYH1Z2qsOpvorGmQjrp1RuVX8eQVlhmdkI8dFfW99YKNNelsFHRidf0D+XNRTPQ3C7vxenlypMt58rfC+Pm3OU7vFiUvDxdzk0/ZjyR4dh1rpyq/fiHhKru2gfW90/qK99DNP4fliz41b/5ZrnaHmP3VjPmWx9g44le7HoyvYVEWsyvsvw3/wu/990cm/nOH6hsv/C4md3ShgK8XfyUXqF1huGMl+6GObKAy3BVmPKhdYRXjtQti5If41WXSeBqoTF+MirKlFXHZTi41x54tnxTKvZh/4tjhiNz2Y28SUTcWebcfsU/jNrLPSZKwHv2QfobP5H+YoMWX2Brs0dDui1d287pe8Go+YsChkYh3nSQsG6YxR9T9d0k3bxMRvKl8EOJYE+Azw6HWEFlvy95eslbwo+gsq0lnmaDjjUn8v9Hhd9565DKiE4qbXn3m9Hv0J6G4aXX+zOtd50Dc9FM5TnWbHK+5qpsM1f4Cln3ohgD2Jwb/02BXfNpV5YdXA86QnsWeEjL4kymeaSPPxG0aTHp9a/Y7N9FtCuWLWQZKT8YceLXehOtu7LO9S/WtbW9YNM3DG88s1/7zAjhPPXsa52klcZ4fwLnszGmc445tLEm66ZW9VRLr8w5cdQn3vKRXd0voYfTlxoZ/OOltc5V8msoPKLlY20cEL6OiLGafxhJBp0O4ivianzR2ubGx+FKCWxpgrSPwdugfv38pvVMpOcSdqfkf5Yyq74e/nfCrb/XiO1ZzrM/fJUY6x9Wkc5yg4+F6u8Bl8Or7wscJ+AZVw1h8OcCwl2bWGG+RajDukGrYb4BoZs98/yh3DfOoPjs/7LRpQLzjrh4WtBSdK2vSuVLQ4SjhFooSkH4Jb/lR8374SUr2/BUz1R+N9fz8eQukZ3ypzzLHZD1e84UPbvm3x1/zpg7VN174HZukmkVeKeBrZp9+VWU9cPdv9lOZMZX1MB5U1qPiJwN+NUZ+iF9lqTnrUTaDoO4BLYvLsh74mRTPlmfKZ7RBx8Pl3d1sshlK9EoR+ySD/xDMnlZSVkLJOxHv5iS9/ihHNSU3xHV6gHdF2/Bnv1FR3+Ba9Ilzy/rE4aS3zVWiYWUfSi7qnJ7V5R3q2Y/vxii7InCw40LdHEl69bcT+N/o8DuWcxMrgk2eLuOznnVwqSzZz8Ezlhkufsf9gvUnqOwzgo4ah+6mMpTbUipTdyooP8T+u6wfGhb8qfO0Y/lzNt5vO1PTxGyLOrXDfvsPzpqut+PMcBtjdlIhfCjDtXsGMlxFsttbQnbZ783UFoN/FGS335Edj/0qE652ivNJs9AnqrEsSfwdRCoTHHO/WM2Vveixr+mdVSqrqHxMzfuNBo1eKuipfjgy0TJVd52ZjSlfx/4MfR2vQuK4FvpMcvZ8EjyH/Bm2iTOzir+Z8puKzqU16Vwq6HhxYoyuKzqK5yJf9nXyZWo1Fevemj9zdnoL+LJvkC/D+sgj/x0zvzB6sd+GMfg/clZnVJtvdXhGGknSazc8dhn8n9LYVXE+LccuPu2rTknXpBudjTf8w8RLVR9ctBqPqc0X5c95anPpDVdcddYVN95863Wr5iDqJLzHsUNY8V0n6W49lg3QuxGCW0J/LxX1EoEbM57qTIi3L0Gt1atZ+RpBl9fm1blrb4+D8T7g1Eccof0iA4F62d+/Juo0eU9AkzOaFveIvTjWMg3/MPFS1TLVfiEVHakbnLwvOOBiEpYhHS86RVx3NYQr+y3v4+rj6uPq45oFXN6eMp6FZb8V+f9q4ZrPZpVduMb63gL5spp0lgk6I6Je1TF51OFZZVtYbmUzkOpsadH+uZ88S9MM7Z/jGZrB3wMztBPO6uZZzdBQBjgDwn4wHFx3HvBgZSXiiwXZLO0y+soOyhVXLIvikOx5df6s9lPzfh3Uhdg++jnqI7Xfz9vjaPAfgD56Q/6s9nHF7CNS9NgOhwLwvMfR4E/PecJVOsXf2gC9UFbh2gC9M4HeUtAHa2dCtGvq3YuV3qGfYb1TmSDlzzx/gbbFuog6zCuzau+et6/V6g8lug8M3yDBXyD6PFbPuV8Nfnlkv5os2+hXlBX3q1r1VucDPT1QK/QqU/dpwvVpgUvtY421ZcPHtnWZ06/qC+HIJ/erwb8tsl/xPKvhsbK6/Yqy4n5V8YfaP+npAY4PJhOVWb+HytAncuZa+W/Ug5g+x/4J+e93iT737gCLGV+yH2bgXpw/5xm4i2654b2r8hRcQj8vZZb9vS7AxotE/YTqdujdi6hMuU9vk5DRHkp0yordp8HfJETuud/sF7OlGru7jSSu4W9qS3WRW+NUkWdm3lRmFlQ1+y0JsNER9RPC1RHvsp/a5qxu+YnxbkpUaq8Wwhs+Xrf+FWfkUCOhd0uYitzVGp9qP9/wiPViTpOgGvGIZvAfixzRGpr5yBENZcQjmsoseCdx1Xq2ypaOEjzKXo1oodNBSEdFMWpmhVElz6yKbgTl9nryUfql9jWovRXeLNjg2pgFY3tYF7y+zX6h210QHvubo1bcW8CZJ7Qlvs1BzXpidQGzHZwJUfsSvRmQurEBh/DV+TPfErBd+ADDub6gbTEzQHXqVq3g8QlSrIf7Cgx3QnA19fGIJrMy2a+srbL/QT3jveM4FnAWR92kgXshZmoPFo/f6uZQNd7xzaFPQ9boa2Qjysa9PkgFvLr5UH1nMo3AdbdDe1LApw5t5AvrMm3mE799ZbSszGRT01bmKltB/8y24vni7BcjK9VPowSPsim7H4y/ERu7Hwy/98L6qeJF5cOV7eK+y71ku2ifPNsum7VX4xHHxN+EMWJxICYO2fXqAM4/dsadojE1Js72bhdH38dxtspKKt/HflH5a+VH2C+qb2YifOibmX+dy6/mLcJyv1VKPOIJchV78R5gg/8n8N3fOUvjnFsS5zORc5aGfN1g274uFfDo63ifagplof2GiEvtRWU7G0r0fMnw8Wrbd51MG/pb9qnob9mnrhN0vbMGmdxfdvaBZ47XsucxgPt+YJ6Fuoc+h3XP4I+F2w1+SCtYTfgNvmVIfYOW7SdJfD1Tq4L8LW/1feeae76j97TzNx0r7qF3bwtVOYOafnNqT/ukoKf64chEyzSFZ8Nlvmqm/ZqXiymSK58PwjayPaOPYD8QE5MpeqGYzHyE5yOrxGTbKCZD+2L7Rxtn+1c3h6o5AMcNKfCiYh6+9cXgXwU+7BSSjdJlL8eyRcBPAgzP6VMo2xKBy8v1bRXwWxzayBfWZdohm/Ru32tjPpUiAOAN9RPCx8hK9dMowaNsytpuSmU4vrNdo25vhjazfhblXNh21ReTMB4w3cDlpl9MummqpR18x+Ms1jc4Ree4mnSOE3Q8XL8ocBm8Wltp+XoVY/F4gMnejzmsMd4O/eP3jHtAwOJPddNwgO8kiesmtVmBcZkLz34rAIYvFcY09OWEq+zmQ6zPS2HG1+W5+c0T9Eu4t3u84+GGu+Ix/ns6hC9JdJgZOpqGfKkrBWKuUnlq54VHfOM/njp1FUjsETqDV6n+ywV8zatU7lJDGF+Xoo4sl71KpeIVEHfFyA/xq3Q4X6VS9jgjlq2oiMuuUsGhkjcSt+1jeOp6ZW7LmMKbaV5sOL5a8OL5MfWBTsW7t1mb21XWXw5H0nlbTTpvE3Ta3hT+NqITOk57C4Vjn4Eylfp9X/7Mmy5fDRdP3pbjVFsg+HATjz84RmY/tlfeFMowawP8fQD0k4/Tqja/z+EZU2hJ0usXOL07tQ2Fxt6KPlWmd/lasRau84neiTVb1/mUO07L25NRKogV33WS7tZj2QC94w1Xi+nvKsdp1Wcm7hY4vSvN1ehb5pIqxKs2JfDlfN5ojzjUop7hUPWyv28RdZq8qGCmjuaaZVY83hr92Uj+rELFqHPKMr3NIdmP264+8aCS2TyrqvrJgOx5Y4O41jWEK/st7+Pq4+rjOuhwqRnoeirD8YA/D6+ONXSoDPnzZl5Y30s8XlqTzqWCzoioV3XsG3V4VhsHWW5lLzTE+nzRTOhI5FfO1jRDR8V4JmTwL4WZ0O+f3c2zmgmhDNQZghaPmckNkihXXqRQm0ex3+wor3dER+lCbB99k/qo6DgfHy2eWhSEPvpjmq16x0KLjq3eSvDWxthjqwb/ZzBb9Y6t3h2gp2bv2e+CAL2/AnozcGz1KKV36GdijsEpf+b5C3UGRy1k8TE47+hj2SOt6hicd6TV4P9e6AOPRawbIf6U3Bo+BrcmwMaRon5CdTv07sgALsOTvcPpa8wxOHXSlV3Ed4XIvS7Lfv1jcIfcMbjFATY6on5CuDriXfYrOgbHo4onYiWqqgeo5+Y8qWNwysN6H69WkYDKzXvHAFXUc3eAjjrYnf14RDP4EWjrDBzYlyMayohHtNjMicEXbYdmU/OOoXjXHDd1DI4jNaUv3jG4omNHrF+xx468qPqFcuyIj8F5x45wOOIrllUUFasLOHv6SmCNCfGiLoTWaNEH4BC+On/m9ZbXCB9gONcUtC3G36mst3eVuLou2DuWaXA19XFE6SO2P2aW5302pshWvUtieBspjgUcRhbpjbfNE9f4bqEZH9Jh3Sv72ZYVgn9F57iadI4TdDxcKwQur79b3ipmLB4LMNn7MYc1xtuhf/yecQ8IWPypbrorwHeSxHWTUmdFZ7gmneFIOm+tSeetgg5vBXl73tk1l5vvjFkwq3iy4M4O4UsSPZsKnapAvtQph5gtZn8/evGXr3tu+wMdqm+88LuY0/BvFfA1T0WsVkMTn0hVJ93UFrM0f1ZbzCqeSlkdIz/EPyrKeBpY9iQOli2tiMu2mHmn69v2GbzFbBWEULzFbDb816U16Vwq6KiQqBP43+jwO6ajeC7ainXjoun3qAexXzYw+FPgu9M3O2mIUNiAY6X3ZQOjF/tlA4O/HXSKt2KtFW2+1eEZvxnPdLPnkwM8fJDGqIobL+RWLJ5+Ij+cylEbetSXAtTC1lqHzi/VpPNLgk6Tm2FGHZ69cb8qHfSpY/mzOuV5BTxjmdHhd0wH6084dO6qSUfd+arSQjhlUicCTWY146nBmH5B/MPES0l67teO1IK/tX2z4GVUlHEqRMVamwUdhWukQVwxNxVdIXCVlVeDUz1j8S0E9+YAawMCb4f+8fu30LvQVM9wz9RV2TNl+kXr5tsXaZqhdfPQh5j/ZfF0vV0UWiBfC6iNZXfMY31vZz4PgZhZ46ybuhK8Q2XIn3eiRK1YDAg6yv3+KH7oiId0rKuG6JhLMBYIOmX5atDNGYsnEFzoTreOwFvk5k6gdyE3Z3/PlOorOufWpHNuJJ2Zas/amnTWCjoernMFrr56d+FW3RS6MjZJ4rpJXQ0xmyMIJiWKRvk/pFFefSbQG+UN/kgY5b8FO+V4TwPiui/pLkM5fpb4x/V7HgErnkeOHgEN/zDxUnUEjN2ZVu5sEk8ZUCqIFd95lsK7YHiD0nyqV+Vsklqd+7TAqeK4zwTqoSwS8W6OgL+LcN0l6hnvA059xIH1WGM69B6t7V5Bm/dePgPpsH9H6TBFC+VRtL+QYZiHqf2FTkoObxJQ7WJr5hsB0BMsDtAfAI/z7CJN/3k4os/tQ+85FOD3LuLB4P+n2B2lPDLfXsHvUAZYN/Q3ws6jtuDfShfvJfh7CtrO/W/w/+L0/4jgwfjKfksLeGCYeQEeOot7eRBe86wbbrwjsNePYw32ctxL3BMjAk/oZ9J43tpzzlk6bB1Mx/5WGpC1/Oj8eSp0u27VLaF9jjwiDAdozkn0byTRvCXJ7G1dHalGz926iu2runU1ZKVFdGpuXQ0N2spZcP2E6nbEu+yXqfOGIw88z+b6xV016agkEeMKhcU35M/8NexjwEEtDaxbzRE4sx8nO73ts4YH4Yu2WLEs1XZIj7a3zrehJK9ejhnpq+ToppK8rphhXtcKXltcV4l2nbO1rlJuWhO6P75DWPFdJ+luPZaxh+Spwjn0d5VpTewdmerux82BeqzZ/G6OgN9EuEL3Tw8E6KkexXqsMape9vevijqeBcRocPYLrdQ1gSsVuMwyJ+F9CUt5SaxlGv5h4qWqZU4SPW4ft32L4GVUlHHKYYugs0XQUbg2NohrXUO4st/yPq4+rj6uPq5DHJc65JVSGY6ffEVF21ctKDrLatJZJuioKws6gf+NDr9jOopnddc1yy1NetuTOnSwfkrtwV2OY/nz8wdXFmuaOJPFurxD1OD/HtKtty0OtxHlbO1intv4ZtwkAPDhJGU/kwCzOn9WsQQfNsK+NhxFffAr1AdVv9H2LeiDX6U+wPq4+ytkN4oe60joM7DriD+D/zhkO1Y6O783BOihPFDOHwnQ+w2RXfEut62pdy9p+372Ij3l7S+op5yxUbvc1XcTOlR/KNF9EDq5s1b0eayec78a/ERkv6b5cxv96l1pozJr3sF3pQfq23qjSW+fhzKRiMv7pLPqV3XFI/frdqdf1SYB5JP71eB3RfarybKNfvUOsap+9Q6xpgIe+9VkMpr0jpOfJlxF+3Ni+hX7gH20wT/q9KvKcnt+2OAfPwj8MMoqpl/VSkBsv7IfTqGMrwLCsY5teaZ89JdEn6ud4jGHgkN7xhq8CmhTgI2jRf2E6nbo3dEBXIYne4dpVRa5NXco0SlQFrnB/54QuTJTtVdLHSqbrd2+FQ/iurt9lUstu9u37LDYgqpmv3MCbHRE/YRwdcQ7LCu6bsK7SgNH6D+kLXioQjxTSAVNFfkbvEWgoejC8A0S/LedUciLgrMfe+utAh4jY+9r01upDOttCNDB0TEFGB4dDf7/ixwdjXYboyPKiEfHbVA2IOBZ3vcL+G0Ak+bPowSvTBplvJXoFLkO1n+lp2r2PSnwetcKFc3KWL9SKNtCZZOCR6ULBtdGpgTbw7rg2VL2Y9l4uoOyGU2K9QTtcgvRSQWdWF1Ioa23UNZEXXnVoTKk6V0MrL5irujcVZPOXYIO44rdp2LwQ/lApvapqFVgb3+E9+Vb5EfJBu+IYNqdwP9Gh9+x3JCH+USniZVjL6L2VpWr0kkBZiPRmWyQTshnsW+oS0etLKvxqy4d9E98Tn1bg3TQ162HejwmqttAtws+bAqwA96XGAuiz1sb/mHipSS9qSnADqLH7eMpwE7By6goux2esQzp7BR0FK67G8Rlfbsg6e3r04mOiqXud+icHklnvCadcUFnRNSrayNKNkZnR4N00GbGic7OBumgHowRnV0N0tkFMCcTndDXz08/Z/p99u8BKOMsV/bjr58b/Dcvmq63MMdpOoi+AnnE+hjLbhftYHqLcxrm/x6EOiX8kbx3xXAVyW4JyW47lMXIzuCfBNmdT7LDdrFt74ayHVS2B8p2UtleKEMcWJZAG/Ad6xzWN7gRUY/Hq33wvkR/RX853vAPJ71trjJe7SN62PbsZ3Kx9j1Ujd7Ul+P3C3qqH45MtEyRvuEyG1N+9kEqQ9+4l8rQn+2hMrTvk+AZcYbaxDtgkT/Wb+RvE5WpnbPqq+kplaVQNkll2GaOb63NcwlP9rOdNoME++5zputcnT8rf8N+fLvAbWUPiLIM/4fP724L+hSUI5ZlvwHxzhtDDU7RuaAmnQsEHcaFBwtxjsh+1+A/QWMI+rISNnu1yX8PvGR/V9H/XB3r70K+F/lSvjDmfsnB39n6xafe9dzysmOE5zsvEPA1feeVKmdmtNX9knupDPNexoO6X7Li2HVljPwQ/6iAPwvgyvSFwvXmhnCxz62LK62Iy+69xNiH45tU4MJxyTuFkRKuBwtw8eeIsT77sN0FuHjn5YOijRyXMNxcgZtpjyS9bWNfVtFPRucaDP+waEOV2E3JVo017Mex7qgoY53fI+jsEXQUrrRBXJwvbSKPqXT4fOI5TXp5Th2esX5KZZsFHZ4zZ89j+fPzl5Odo/lBvcf5NscFBr8D5mO7aD6GtL3YknM6Ze/qOz2SzkU16Vwk6LSd/+aczu4G6aBvuojo7GmQDtrbGNHZ2yAdHBd5LpAKHjKd/QLZwT4oU3Zpchok+CVgB1907AB5xPoYa6ncFNP7bYrHK8aBMqdjuIpk9xWSHc7tlOzYhxj8CSC73y/hQzC23E1lKI89VLYfyhAHliXQBnzHOof1DW5E1DP5Wn89DO/byOkY/uGkt81V4oKHiR62PfvxvOSRavSmcjqPCnqqHzCngzJF+oaLczroZ3dRGfrG/VSG/uwhKkP75pzOroI2cTyt+PNy4bMVc+6qRs+NObF9VWNO/r5AE3FiE7g4PzcbsdB4TTrjgs4LJRYaJzo/KrHQD0rGQjyeG/xXV0zX6yw58NxmLDSU05jNWGjeku62VI2F9oHs5pPskDbbNsqJYyGMUTgWQlnxeqOVJdAGfOetqbLcsB6PVxVjk+hYyPAPJ7X0Y2q8UjGiGq9qxnpTsdAjgp7qB4yFUKYqLvJioZTK0DdyvIP+LJSLzZ45FkoTv01eLIR18W9bU8L9FbymZLBrwc5eldvZiMBvl9yrfMr9QPcnyFZRLpy/LBs7YP09xE8TY5Na6+Z8VdkcNdbnNdE9gg6P6exfT1yi+UH/ivEA+1eD/wj0+8nUZ0ib/STyzDFa2f48PZLORTXpXCTotB3TcIzWVkzD+ap9DdLB8XKM6DzUIB0chzhGe1Dw8Pw+GrKD/VCm8vWcrzL4/xvs4HzHDpBHrI8x2m7RDqa3nGK0imOijNEMV5HsVpDsdkOZkh37EIM/HGR3cQkfgmPyXipDeeyjMsxlIA4sS6AN+I51Dusb3IioZ/K1/noU3rcRoxn+4aS3zVVitNj8kbXvsWr0pmK0zwl6qh8wRkOZIn3DxTGal/dA3/gIlaE/e5jK0L45RttT0CaO0ZTut7jfIzpfZfiHk145VtEtFQupcZjHJqyr+obzVWoviMq5Kly7G8Tl7SfjWEjtW9vh0Dk9ks54TTrjgk7b+6RnK1/VVsw1RnTairliY6GP0Xj+EJTFjOcG/+CF0/U+4czjeK3oIcCXCPiTA/TuolioYv5DxkK8BhWS3d0kuz1QFiM7g/8UyG6NIzu2bRx3OF8VGydxbKrWqPCdF39zDIn1eLyqGJtEx0KGfzjpbXOV8So2f1Qz1puKhR4T9FQ/YCyk1usQF8dC6Gd5XzX6Ro530J/xuh7aN8dCuwvaxLGQ2jPGuAbhXQq43kLlBr83t6/M1nZTzkrtU87gXn9uN1w/Duuuq/r+TnjGMqQTGzvtbBBXPw6bpsPvysRhbcVH40TnhZaTCuVm/1NETsrLzRr8z0As8XUnlojJSXlxmMH/vzOYkwrJ7lsRcZgnO4N/EcjuT0rEYf2c1DSf+A7x93NS4ZyUF4cdDDkpxR/jio3DDP5Z8hsV4ybpN/hsUj9e667L+pP9zgI4LisbY+1qEFc/Xpumw+/68VozdKrEa0edO/0ex6Cy8dojy6frHZ3jbDNeOyanMZvx2rEku6rx2n0gu1eQ7JC2d1cBx2tqX7uK5XgcLJs3w/o/ankzNV4dqnkzbw2RYzL0Z5w38+K1JvJmsTkuphmK6y6hcoN/w7nTOH+e8mbq7H4G9x/6+bUXTH6N72RA3Byvlb3f6nTBs6IzXpPOuKAzIup1Av8bHX7n3dPE8dqDDdJBmx8nOi+0dc5QzLGS/Jta5/RiDoP/eYg5LnPitabWOd9O8Vqb65wh2V3ZULz2YyC7VY7s2LZxbGT/0l/nPPDrr3OG4zXv/ij0jU2tcz5Y0CaO15A/764he5cCLo7DDP6D5DcqxjHSb/C+tBTgWf8r3qURHa8Z/qa+Uqr6LoV33jlKvtMM47yzAI7LvLhQzRd3NYjLi6P68Vo3HS9ea+tezXGi01ZcOEZ02jrbEBuvbaCYo+pZlaffNF1vs5Mj4nzOXsCXCPiTA/S2kd/FcaKu3zVc7HdZdtsDc/nYc5QGvwlkt4tkh7TZtlFOu6gMx1SO5Zrce4v1WW5qLlLz3Gt0vGb4h5Na+jE1XqnzpWgXHK9VnD9MxWuxd1hgvKbuBkVcXryWUhn6xn1Uhv7MOy/H8drOgjZxvJZCfR5vdgjeVY5LjUvzRBtL9NGCWB00/MNJr7yr6KC6k0ON1/P/9d9P5M/5Z4/OWXXL8luvvO7ad5y/6o6bF15/1fIr3nvLtVdct/Cqq9676uabkWkkdAS8x3L8MYw9bxLvEceDBY1hZcDOirlkD3GtIFzqkj3DtacAF1/YpwY3/ntu0sunHfadE4EHDS3E10XEl1p88Zw8KudHCRfWDyVcQrg+RriwPi8uYrKI+WR5eXhCDhT5+jjxFTqEnv17pADXBwlX6HKf7N+jBbh+nXCpSTj/PTfp5ZPl5eHJ/j1WwNcniK/Q5pvs3+cKcL2PcKnNO4br8QJctxIurI918e+5SS+fLC8PT/bviQK+VhNfj0PZE1SG9S4lOmUnaVh/piZplxKdJxqk8wTAjEG97O8noQx964h4ZzRs8H8K3reRMDH8w8RLSXpTg/9TRI/bxwmTpwUvo6KMkxxPCzpPCzoK14MN4nqS2pNC2Vj+/PxFQDQJq3qZzUdhEtY578Czij2eoDaqOEZdRtqhdg0JeMQ3yPA5T4clvZ91fULUV7hxPPUSHfOSXvtqw0YMf1MXAj9J9Lh9bCNPCV5GRRknLZQtPiXoKFx7G8TFF+2lUDaWP2f6/JLzumlWtZEbwUZedhDayL9pwEYwhoqxkTqXRyI+4wffIf6mbETFsp6NPCl4GRVlvLFe2eKTgo7C9XCDuGJt5LUN2chbwUZ+pkUbMXnH2ojBv74BG8G4OcZG6iTDEJ/xg+8Qf1M2oi5N82zkYcHLqCjDOROWIR1vcRxxPdYgrlgbOashGzkTbGTxQWgj55e0EcV7G3Mvlb9aBM8hGXkf4Fkk2qPmeIuoPSmUjeXPz18ydJ7mR+lI9mzzd15YPxF0ZKWjIwfDwupVNelcJei8UDbCXUV09jdIB8eVMaLzcIN00FfGXlD7HrKDR6BM2cHq/HmQ4P9g2XS9Gx07COUsYy+oNfhbcxo1Nx7JhVXDVSS72xoaZx4F2b2/hA/BmJ59PMpjP5XhmMx5X5VfxXesc1jf4EZEPZOv9RfmLdtYWDX8w0lvm6vEWrEHP619T1SjN7WwquYSqh9wYRVlivQNl7ewypf1o298jMrQnz1KZWjfMZf1Y5u8jXBlLuuf6U1mdS/rL4oXOY7fL3hRffNJeMYypON9iANx7WwQl60x9DeZ9b47GA8F/KjEQntKxELZj8dzg78YxvOHZiAWeuwgiIUebygWOhVk91Q/FvJ+h0ws9Hg1elOxkFrDLhMLqTXtF0IsNCD4Qzi0PZVPSsS7jkOPacwRdX+D+MaydxKNsjmgdwp+W8zrDsTa16GS1+U19Dq52JiYp+YGxuh4fCY2ML4T3jW0iXbA64cHHXoV1/LmGD1vbxfSy/zpUNLbh0UfQkEa2F8hm6+6n3J/AS5vPyWvAz5cgIv3U4Y2Lnfxdf6B/zI//P+f1w1jewGfO28a5tn8mW0K5fD8XhKC8z4EVOdDOYgvSbTt8UcR634ISPVD6MM8hyW+jmAfhfaZ7hNtidFZ78M6ip+yfZoC3E6Am3N+GG6PgFO0sr/Vh8U5Fp+b48jkfOPK7jZi/d3wjGXZb0C88w5nGJyic3pNOqdH0hmvSWdc0BkR9TqB/40Ov2M6SjasF03QSQFmnOi0ddBtjOi0levg3MBOwUNmMy8/f/o925o3XvCh9z++YLrecTlOtUc/9IGr2ANoBv/jOQ0bDypemBJ1sV5Idq8m2akDaJ7sDP7zILufcmTHtq0+dK/ODPDhNBwbeG9d2QNo6jKIH5UDaN4FT4fCATQ11infyAfQ0J/xATS075gP+XkH0NRYPv9f/70if54+XHX+qjvecsV11151xS3X3nD9ilU33brq5lsGAbMaOdjDsyfGq6FCvw79PYfKNlH5cgGHP280rXnFQXTka/iHk95eqGI56kSXijL4qh6sq66q+BQ8YxnS2SvoKFw7GsRleqOuKetf5dlN52D4BM4L7ZPNoWjlcopWUiiLiVYM/nKIVt5O0UoKtHmn/U7Alwh4jvQMfhVFehWzbjLS49V39HVj+XPWzqsjZIc+LSS7cZDdu0h2SJttO4Uy9i/q2h81Y0ccWJYk/uq8ighmYNdCdKQ3E7sWUnjHkV7FyHIq0lORpeoHjPRQpuokrneV5yYqU9dYKH+2k8rQvmMiPWxTTKRnujUh6FjZdijbTGUPiDZndvdhsjv8XPRyaoeVYTvwHdvIcsGPojOZPw9SGyfI16VQp4RunTZCdAwH4t5REXesXYbiBuRrWJQNRvDyvRePv+7Z9B8nOlTfeOF3cwA/6jLCLxfwNcecN44AjYRoWxmOhzuobC6UGQ9Z1vI1xF/FlaE3xshP2T6W8acoy8aaiGtzRVxHJd16hbZj9od+ZEv+PJL02jTbSQrv25hvpfnzcNIrgyrjV0r0Qj6LfQTWHRVld8Iz+5YB8W6Og2uiQVw2Bqh+5vnWhKAz4dA5XfCs6IzXpDMu6IyIep3A/0aH3zEdJZuZzqxPNkgH9WCM6GxpkM4WgOH5VmjO8DTNGfAa8pg5g8H/5dLpel9wYhfkEevj+LJZtIPpfYlikIpji5xv8e6KkOy+TLLbDGUxsjP43wLZfcWRHdu2ut5KzbcmqQzjBM4plZ1vYf0ftfmWGuOtfbur0Zuab6l8ZJn5lropiudb6Gc3U1kKZTzfmoQyjrnQvnm+tbmgTTzfUvz1Y6G4WCj7nQVwXFY2frm/QVxejNKPhbrp9GOhpBKdKrHQPzcUC62C8fwHMxALDeT0ZjMWmru0uy1VY6ElILt5+bPKv7Fto5xSKlM5HRUn8by+7KkkrD8DO3SjY6GZ2KGrxqsmTgRm/3YLeqEds0qmKi7yYiHOPadQxvHOJJTtoDIvFtpU0CYvFuJ1d8wbM+yGZLq9CHsc2NmipWFaW4mPDVC2jcpi7RNxoHzRVyD8DdQGg391zneWa7x5pcY5J9E6av5H5T6tHfOArpWV0N8vZnxdtnKaDupL9sO8KepLkvgxlcFvFfCoc2n+PErw2TPHc0ofU3hn+qjkZTy2Ia8UAGLkhfBl5cV2j/LaTrgmBS6UoSevNH9uQ17IQ4y81B6XWHmZDJS8HiBcqcCF9riU4A33UKJ9guEbJPgzwSfwrTyej98gcKNv7BAObMewaMcIlWHdDO/2RQeeZyrPw7GmunEH/Tfug0D4N8G4cSXJRo3T3vqWynF4O0lxHN8TgWuzQ1vtndrj0Ea+eI8M781R8YbyAyabmn5grvIDmK9iP6D6SZ148mSl+kmtufPeuNicE9+sMAllXs4JT1pcGZiTYDtCPpvtAeczPNdR8wRP97wr+pXuqRyrsn/2G2pfjbIl9hvYt+w3qu6Ev5HmqG3shGf9Hky0fod2uH8EfNvNAd82tyTO98F4tBRsNEn0entNXzCofAHaO/sCzwdnv7J+k+3W27+q1s1RphwTmIyGBDzi4715vxIZE3i7y70cuDfvM3vI5L4t56NoD+THSPfUbQ7eHkiD3wH6/Ama4zXhN7ZQmdqj5Y05Ss/U7n0cQ7me+YGa+86jcym877ziOo+771yt89T0m1O5lH2CnuoHzKUUnd40XzXTfg3lFOPX1FqT2kPI9ow+gv1ACmXsPyYdeugjMBbfRravfGRszIL563+mPDTaF9s/2nhKZajvk1SGMuS4YS/womIeHLMRfi/4sC+SbJQue3Gs2sOK+1L5VhvU9YcicO1yaKvT8g85tJEvvgGKT5wrm1S2aLJpY76BcQHbouondU7Fk5XqJ3ULzENUFmu7fEJsEsrYrlG38STqFwPjNrZD5XhVPIBj/sdo7D5UcgW/D7b7Z/1cQQ9t5rOfK+gum8lcwZ+1lCvgPWL9XMH0cyhX8D8OgVzBHDgj9Q8N5Qqe7ecKpspmK1fwLwdJrmAs16+iXMHgBd3trporOB70+bD8uZ8rkL9+roDo9XMFs5MrGCPbbypX8PQhmit4Dfiw00g2/VxB2Cb7uYJytttEruC0wLiN7aiSKxiksTsFOD6vr2xK2Tyf139QyIL7L5QrMLyDBH8O2O6lJBvv69HZr6z98JxJ2Y+HK3VoqxuR9ju0kS++gZ1tWZ2hb3EclbaL9sm26/nM7BcjK9VPowSPslHnkFIqw3FoH5XhOMQ2j7qN4y7rZ5r0tiN23E0BL9/fsasAL8vT+5KFGjdS0T7vjJiyf/YbqKPsN7Bv2W9Yf6KuIjznCgz+mrwvat64KnMF/IUAvLdC6TfPrQz+Q+Db3h3wbXNL4rw+x1OUK7B+bCOmRntnX+D54OxX1m+y3WLfpIQrFbhQppwrMBkNJTqGMHw8Z74D+oBzBeiPOM5Af8Q5EHVbovJHmCvYQLkCdZNnBreadE/l9dHnsO4Z/GbQ5zsp3mjCb+ylMvQDfDOnGnOUno2K+jiGcj3zAzVvSozOFfAt9nVvco69xb6m35zKFagvBodujlYyVTeZe7mCNv2atx5SJFeeu2MbUypDH8F+AH0E+489Dj01v0Mf4fnI2PlGCngvp1yByrEqG2f7R33nuAFlyHHDw8CLinlwzEb47eDDniTZKF324lh1oz/exs/rMN7XfhUuL0+hvpLzqENbfSWHeUmSsE0qWzTZtDHfwLiAbVH1k/qChicr1U+jBI+yKWu7D1MZju9s16jb+6HNTwbGbWyHyleqeADH/NU0dnvr6U3c4hwau0N5PsPLse+XwHa/SbJR/lndgMz+A+HVl/e8+bqHy1sf8/RX0Ua+sC7TZj6tnrJdk00bttvk/EDJSvXTaNJr12yDsTdKs33G3iiN4y7rp1rbih13cV2Zb3X39l1kP5anl2dVuqduUFf27+XWUipDHWW/ob6yyXaGuorwnCsw+L+mXEHFL/nIXAF/vQ7zGUq/eW5l8P8Evu07Ad82tyTOZyJzBdaPbcTUaO/sCzwfnP3K+k22W+ybmL1g6usybGdDic5Z4p4XhP+ukytAf8R5zRTKOAeicvTKH2Gu4GXLDjzzWkz2PAZw3w+sn6Huoc9h3TP4Y5dN1/shxRtN+A3OW6qckTfmeF/NVesCSp/ND9ScS0fnCvirTxVzE+5Xn9R8p6bfnMoVqDmO6gfMFRR96czLFbTp17z1kCK58twd28j2jD6C/UAKZew/vH0MKheGPsLzkbExC655vpxyBWhf3rpYSmWo797cmuMG9UVhNefiL/y+CnzYKSQbpcteHFs0X+fcp5qve7i8PIX6cuxjDm3kC+sy7ZBNKls02bQx38C4gG3Ry9FkvxhZqX4aJXiUTVnbfYTK1Fcfle1iDoz1s2g/BdtuKH/4fSfPz3OFJr4GzXPrzwEvvA7P4wDCnwG2u4JkY18mTpI4nVBfQsavG6fUHtSJJyJweXuCnhTwTzi0kS+sy7SZT6unbNdk04btor2x7ap+QvgYWal+GiV4lI2VqX02ygY/R2WxX6Z+DNrM+qnW/1N4x7abCl4zvPx1eOULPd0rGrPS/Nkbs5T9s99A+2e/gTrKfgP7lv0Gf3Gc4TlXYPBvz/vC4k/Ukbq5gieJx8eBB6XfPLcy+PeBb3tHwLfNLYnznTmeolyB9WMbMTXaO/sCzwdnv7J+k+0W+4ZzOirvgDLlXIHJaEjAI75Bgr8J+oBzBeiPHife0R9xDKJyx8ofYa7gXsoVoO2OAdztpHvo09hfZD/WPYP/LOjzL+fPTfqNh6kM/QDH1mrMUXqm1opwDOV65gfMr6AutpErMPzDSW+bq+QKlP3h+MC5gop+cypX8JSgp/oBcwUoU6RvuLxcQZt+DeUU49cQnufu2Ea2Z/QR7AfQR7D/2O/QQx+Bsfi9ZPvKR6YCr4pZcH6+J49ZlI2z/aONs/2jvnPcgDLkuOFJ4EXFPDhmI/wm8GH7STZKl7049mkB/xTAPErtQV1/OgLXYw7tzwv4px3ayBfWZdohm1S2aLJpY76BcQHbouonhI+RleqnUYJH2ZS13SepDMd3tmvU7SegzfsD4za2A8dttt1HBa8YDxxquYKnwXa/RrJR/tnLFZSdr6MPezIClzdf8/RX0Ua+sC7TZj6t3sGUK1D95PlYJSvVT6NJr12zDc5kruBrLeUKbnuB5wpixnzUVYTnXIHBf5tyBagjdXMFTxGPmM+Imdcb/LPg2/484NticwUG/1cHQa4A7Z19geeDs19Zv8l2i30zW7mCv4vMFXBes+lcwZFvOvBclCt4rqFcwYvfNF3vezOQK0A/wLkCNeYoPVO5AhxDuZ75gZpz6ehcgeEfTnrbXCVXoOzPyxVU9JtTuQI1x1H9gLkCNRdBXAdjrqBIrjx3VznNsvMN9h9VcgXmIzwfmQq8RbmC9zSUK0B957gBZchxw1PAi4p5cMxG+B8DH/Y6ko3SZS+ObWK+7uHycgX/XsB/3qGNfGFdph2yyZnOFWBcwLbo5WiyX4ysVD+NEjzKpqztPkVlOL6zXaNuYw6M9bOpXAHHA0Xftee4Se2x8uYnRXtH0/zZ23Ov9hrtDNBBn4B9sjp/5r1Gp+ZyLoqpjXZNfV/Q9j6aovkgn51B3817XlDGeB6JxwY843IxjQ2Yi+I9Gd5dD1wX+2AoAM/7yQz+HOjjlSs1TuTBO/9VVp+xDXX1GW3jVmqrwS+bWX0+Yrb1mXUW9ZlzQkqfO0mvD6uTzznrINT/t/0I6f+qg1z/1VzC0/+iHAnrP8Zvs6H/ry2h/086NJX+W9tC+o/5RIS/1dF/JV9P/4vWCNMk3P6nqQzr7QzQQf3Hfmf9N/gPROq/0W5D/1FGrP/evCn7lZ3r8JoAxu+e/vN6bVP6/5IS+u/F3kr/ra0h/Td8nC//pKP/ygZ3w7u6a13YhqeoDOvtDNAJxfOs/wZ/T6T+G+029L/J+WtRnoHjebQNT/95naMp/f/BuQeerY/xjLt3h2PMOXZ1VoXPF6ozmynAGF4+s3k/5IaeoLm3ipFwT38bc14Pl2efRXdjpERb3Y3BvCSCT6vX4vmvuW2fa1WyUv00SvAoG2VbfMY99lwJn1VRd1co/VRn3FN459kunnHffm433n0FeMve4cp30OwV7VP2790JEXOOXek6+w2+A4nheS3a4H877wtb30AdKaHrci2a76rBc/hKv3ntzuC/Db7tdwO+bW5JnF+NHGetH9tYs2nyrpoiv8l2q86mdehvxKXWb9jOhhI91zV8fNb7WyKuU/6I7+NQ9zUpf8Rn7tBmcC36n2gtGm13DOD+jHSv6l2M/wL6/Jf5c5N+g+/DUncdeGOO0rNRUR/HUK5nfqDmGfDotWjDP5z0trnKWnTs/XQ1/ebUWrTKE6p+wLVodYYWcXlr0W36Ne8enyK58towtpHtGX2Ed/cO+w/v/j30ERiL/xPZvvKRuwXeESrDuhneDTTf8O5tL3uOXe2Z47jhUeBFxTw4ZiP84PLpei9d3o1T6bIXxxadM99H7VHnzD1c3vl676yooq3O7TAvSRK2SWWLJps25hsYF7AtFq3JxshK9dMowaNsytour2+rc+zKdjH/zvpZdO842+4+wSvGAwsEfW/s9u6g2UtlaNfIB7eRfRDi5Zj/lWC7ryfZNH0/Bc+Zyt5P4d3FV+Q3mHb/fopueNVPo0mvD+S9Iuq+FmWfnGPAeQbPR9SYo/Sz6Jti3riLd8tcSbmCpu+BZN1TcbOyf/YbseM6+w3sW/YbHB8yPOcKDP7MvC8s/kQdqZsr4HEcz9wo/ea5lcGvBN+2KODb5pbEuSTHU5QraGgcH2x7HC/ym2y32Dcx3ypCmXKuwGQ0lOg8Bd+/bPAXQR94uYIy8YLK3yl/hLmC9+V8cD43ex4DuEtJ96rmqe4Afb48f27Sb3ixNe9bVWOO0jO1NxDHUK5nfsD8CupiG7kCwz+c9La5Sq4gdu5e029O5QpUHK76AXMFKFN1f4+XK2jTr3k50CK58twd28j27OUT0Uew/9jr0EMfgbH4+yLmG7ExC843VlKuwLv7OfacLMcNaj7H40ZoT1PonOxq8GH3kGyavlOL9+GXvVPLy7EXndH17hnq36ml+0mdOfHu1PJsl3MMOL6zXaNu4/7yewLjNrZDrYWoeADH/Etp7FbfBK2aD1A2z3Gain13C1459t0ItvtQy3m+mPm6h8ubrxXl+Zh2P8/XDa/6KSbPh9+94FxBrH2yzaNu47j7UEu5gmMpV6B8gqd7RftpWPdiz5Cw3yibD1C6zn7D+hN1FeE5V2DwX6BcQcV7pGSu4HHiEfMZSr9DZ4L/EHzbFwO+rew549+KzBU0tH+79FlQzwdnv7J+k+1WjfEd+htxqTNgbGdDic5Zhs4L/GcnV4D+iPOa6I84B7JP0FX+CHMFz1KuAG13DOC+Sbqn8vroc1j3DP67oM9/TPFGE36D9zipnJE35ig9U+u8OIZyPfMDNefS0bkCwz+c9La5Sq5A2Z+a79T0m1O5gtj79zBXoOYiiMvLFbTp17z1kCK58txd3fmifIS3hsH+Y59DD30ExuLPku0rHxkbs+B+haMoV4D2xfZfNh+g5tYcN6j7ZNXdRHyf7PfBh41e2I1T6bIXxxbN1737PWPu1Kpz7sm7L6ToTi1lky3eNzG37Tt3i+7U4vjfu1Mr1nb5zjuVD1C2izkw1s+iPZtsu+obJRgPHGq5gmMunK73WpJNP1fQy2c/V9BdNpO5AtbPpnIF31rSjbefK5h+DuUK3pj3xcGcK1gOvu20gG8rmysYz/H0cwWzlys4H/pgNnMF1+d8FOUKVgRijrK5gptAny/On/u5Avnr5wqIXj9XMDu5guvJ9pvKFfynPGY51HIFt4MP+0Q/V9BDO2ST/VxBOdttIlfwiZZyBSto7PZyBcibN4+oewYB92SEziCsAdvdSbJp+gyCt/+x7TMI3t6r/hkE/24/7wyClyvAca6JMwg7I3IF6kzhSNJrD5gruJtyBU2fQfDuHfHOILDf8PIPM30G4XOUK6gY07d6BuGr4NueDPi2smcQPh+ZK+ifQeiVaVNnEH4nMlfAeQ6VO69zBuEZyhWEziB8jXSv6hmEvwN9/gOKN5rwG/0zCP0zCM8jz/9/oZ5BQB/BfgB9RBNnEJ4h21c+MjZmwTMIH6NcQWyu0Fuvm4kzCM+BDztsRTfO/hmEsE32zyCUs90mziCwfjZ1BuFrNHarNcyZ3legzmdy7HvUiul6P06yaXpfQcx83cO126FdtD7GtPv7CrrhVT/F7CvAnBjvR2h6XwHr527RjthxdzfgXRGxr8DTvaJ9Bd6dJN6+AvYbB9O+gpPyvjiY9xUsAd92SsC3ld1XcGqOp7+vYPb2FZwFfcC5AvRHbe8reGfOR9G+gvNI96ruK7gW9PmC/LlJv9HfV9DfV/A88vz/F+q+AnWXWVv7Ct5Jtq98ZGzMgvsKljj7Ctj+D6Z9BTeCD7uTZNPfVxC2yf6+gnK228S+gjsD4za2o8q+Ao4H9gq8aq9Rh/hFeO+7NMrnePsVVCyk1jljvq+Abbso/5/Xfj4VGVO3uRaPMqr77YCi+aDJRMVG+6hM3Zmr9pztBd5PpLGhA3DvIF47SS+vHdG20UB9hQv75WR4PgnKEX4fzSVRniX69YIRqJMADsRdUWcuwLbaT8WTGDspetlvWJQNRvDypVN/8/wt/3zyER2qb7zwO9bLuQL+HQLeZDVEvI8lUb/zle0abSvjtmMZ2p/xkNnsa4i/uRX5i5Ef4h8V8MsBrkxfHJV06wLqu9kr3tG7mcrQN7PfVr7Zyzmzf0O/nQIMr9kb/OcglvvdiLES4+c2vk3j4fK+Q1u0xy0l2mouy7wkSTgGUPZhsmljbPPWYItimhhZqX5Sa7acS9oMZfw9Km9fh/r2jbcHTelnU9+0mke5YxWbebpXFJul+XPZ2Iz9hnd/btncEdsZ6irCc+7Y4L9F433FnIvMHfOe00eAhzK5tr8D3/YnDeXv/nRm49zBtvecFvlNtltv78E+gUvNrdjOhhIdYxs+/j7M3zq5Y/RHPLdU5zuUP+L4HW0Gc8fz88nQSNJru2MA9w+B/BHqHvoc1r0pH3HRdL1nKXfchN/gvBL6AV4nUGOO0rNRUR/HUK5nfqDmd2Oic8eGfzjpbXOV3LGyPzXPrOk3p3LHsblqzB2rtXDE5eWO2/Rr3vy9SK6cy1VrqcpHsB/w9sbvceihj8BY3HyE5yNTgVfFLPsA7w/OOfCsbJztP3afaUzOmccN5cN4zEb4l4AP+0mSjdJlL44tWvf01sIej8Dl5YeK9rgxbbXHjXlJkrBNtriOM7ft9WklK9VPowSPsilru5wfjs0547oP66cX52c/tt2HBK8YDxxquYKTwHYXkWz6uYJePvu5gu6ymcwVsH42lSv4yjndePu5gunnUK7gorwvDuZcwbXg294S8G1lcwVvzfH0cwWzlyu4CvpgNnMFH43MFbw7EHOUzRX8Oujz9flzP1cgf/1cAdHr5wpmJ1fw0ZZyBV84RHMFnwEftq2fK+ihHbLJfq6gnO02kSvY1lKugOOBVODdJfB2kl4/FLPPTO1jQ3nwd7XV/iV1187mAB2Vg8h+ebOnfILB74uMqY12G/qOMmJ9Vz4b4Vneav6IsXKaP6t9jnxWC2VsNI3nXQJnxvt2Ghu2A9z9SXfZA1DGZ5lxj/NOKkMdQT6wn1APJgDG8A4S/G/C2PANshGlww/AO+4Dr8+QH6XXMfOa7Q7tov5n2sgX1mXazCfqg9GyMpNNG7aC/odtxfM12S9GVqqflK1wXHc/lG2nMu/uJPzWGp+xRN3Gs4msn9tFOybgHY8NE4LX588PUC7qQYHX0z3v7KXSvQdE+5T9s99A+2e/4X0THvuW/QbO9xMBz7kog/9LykWhjtTNRfH5ir3Ag9Jvnrsb/PfAt/11wLfNLYnzO5HjpvVjG3O2mRw32W6xbx4gXA8IXGr+xnY2lOgYyfANEvyzTi4K/RHvLUd/xGP+TkFX+SPMRb0kVxJ1PmkM4P436R76NBVLsu4Z/MvePF3v+5SLasJvcEyKfgBxhMYcpWdqnsAxFdYzP2B+BXWxjVyU4R9OettcJRel7E+dl6/pN6dyUWp+pPoBc1EoUzVf8nJRbfo1lFOMX1PngtQZJ7Zn9BHsB9BHsP/Y6dBDH4GxuPkIz0fGxiwPAN7Tab6B9sX2793VivrOcQPKkOMGvKtJxTw4ZiP8ceDDTiLZzMa9lB6u3Q5tb/1X0Va5eOYlScI2OdNzc4wL2BaLcjIxslL9pM6A8VpYrO1632Vnu0bdxnwv66cX52c/tt3QHSscD6wXeOcLvAY/AbgGCEf2vDp/HiT4N+TtwdjVcG4QPAzDO+7TTQJ+A8AYPwuSXj+2icqw3pr8Wem7wdXU9yOUvmN7WN83Q9mAgGfZpAIec0rWt6MEj3KysjVQZjRHCA/KO+P9xkXd/BT1LevXRsCl+vbD+fMgwZ/v6JfSl7XwjmXoyRz5WUA8YN0Fop7JV+mXwdXUrwVKv7A9rF8plA0IeJbNpIBPAcb6dpTgUU5WhnZpNEcID8o74/3VZ3bDof/qBP43XvkdzxMQ13LiZ6JBOtjuk4nOOigby5+zdl9B4wHKZEDU/UD+PEjwH4QY6Kr8eYGoP0H1rexqsLP3rQzXZx+MY8R8KkN5oM8JtRPhPxxo53uAz5udXInxVdPuRpXdoe+L8esIX9avs+9OoWwd4VoncKl5AMcIQ4nuA8M3SPC3Qx9wrgTHjw3E+5qSvKvxRPkRq5v1xd8sPPCs4oCNRFONYaqvRkX9DQFccwT/aLfc7wOJHg8Z3nQC85UpwAxDOcL/GvTVHSs1ziTAw7oAz0MB+M3Eg8F/XOiL5wdQ/zcRToP/JOBcXBLnhwI4P+3EGmky/TOcG+Fd2fGU4wmU4ySVIe88LqZAn2F/hehjGeo5000cfnlMLeKXxxsr2w7j1fr8eR7hK+mrB7y+ukzwG9tX65z2MS6rh3dwxNgIymPyzRrn3JI4t4kxXcUqJwH+7YF4JPtxPJL92C+jz0A7vIJiEqQ/n/i3cWK3sEc11huuemN95y/UWL8GIHisV7JBePYJGwU89iPH2Dje/AyV4TjLsdUaQSd2LF0Dbf38wm68Ew7e7PldxEdRjPfe/Jn98NOOH1Yy9GSu5ogoV15Hxf7gnILS2ZnWR2w/66PX1uxXdj7M+qjGD6WPHGd5epP9PH3EvNTeXB/VHJznHpsdflLBz2bRbh4fhgLwhm+Q4L/uxD1bBA/ePGGrgN8ieF5APGBdph3a33UBtcfgvxnpjxvKeRyl9B/lxvrvySj7sUy3CXiUVZo/jxI8ylfp/xYqU3kkz2ZjbcPqZnL4yMJuvE3n59hXG/x/LZmf83x1W/k5z1e3qasHa34OdTU2P3cb6Zfy6fMd/pU+Tgj+VV6J+x3rrU+K+ZoQfKl5zIRDZ2FNOgsFnbZzkAupPRuc9pTNhWD9DdSeDQ22R/FclFOdd/H0+5BvwzkMj3cG/6qLp+vNz5+9nGpZ3V2bdPPp5ZCy3wpof5K0EXPqdduZjDk5rsTxMiZniLqHY6fBJMRjG/JCe46ZMyq/4clX5ehGk15Zrqcy1LcJotNU/nXZwmL+1zvtLdIPzsUcRGt0sx4DsC5MQlnMGh37S6Sj/CX3MfpX7BdeszL4k3KfqmJHpQee3qQCXs0BlW6kVKby/C36kINabzZRmco7xuqNlyvEMdrGby9H1km6x0nUZ4QPra9MEJ4OvT8c3mO9O6jNHCMx7vcTvLVzKABv+DgWORdsZaWTE1M4f5l42FTAw0biweAvEDx48s9+Xkw4L+m1xRJ2M9ghfMYPvkP8w4nWj7Ek6tdh+Rk9pQfZj21Z2ZNaK/F8oLJzhWt+g7gsblAx7OlEp+y8COt786/xmnTGBZ2251+nE51NDdJBmxknOpsbpIN6MEZ00gbppADDe2fWCx6yceI9NM+bhDIVM/AZCIN/7C3T9W6keR76ijTR9HDc3yDawfRuzWmY/8M8bgl/JM85Ga4i2d1GslNrNZ7sDH4tyO79juzYtiehjNdZUB4c02+FMsSBZUnSm8/NfqxzWN/gRkQ9Hq8wD1xmrhhjG4h/OOltc5XxSuW5J+Ednx+5vxq9qfMj6gyl6gc8P4IyVec/zcaUn+WcAfrGrVSG/ozz9CmUnQTPSCPUJottFzj8qTgUYzeVb2Hdm+lYaWM1em6spPJDZWMl3n91sMZKyCfHSmVzrlh/g0NnvCadcUGn7dxuP1aKp5MCTGystLehWOkNMN7vp/EefUWaaHoYK20U7WB6nzsIYqUnItYTPNkZ/MtBdk87smPbnoSyfqzU3Yf9WGn6ORQrqXijzVhpY0GbOFZS/Kl4J/uNJXG/mFgK21ei714Zq5uGv6lYSsUlKpay9qXV6I1lunZ4Xg/j2PfAs9r/hP3VVP+p3Mxs9d9ENXpu/6mcVZP9h7ZVpv+UbZ4Kz1iG7fHiSqw/U3HlqUQnNMZ/h8Z4taaFYzzvGTD478GegWdojI/dF7AOeOY2N7TOP1D2XJO3dzn7ld13y/uVvHVrtae8k/T2Sdl1azzfeuJCzX8H8H5A1GXbRvhNgg+DT/O/bU8pw/C5F4P/PqzBnBvYbxc69xJah/2hsw6bJtM/b8wx+EkBnwKMt0Y/SWVYz1uHNbiaNvFKZRPYHrYJtYcX4cvu4WW9x1h2E+Fi+8p+FwhcHq8TNXjlfkyhbCvhMljUS2wP66XBH5XPl4r2G5vM2+h/bx1eydRbhy+SKee7UI4plXnr8EV7btgnrhc84Jg4U3PUlNqxDXgZELwa3kGCPx7m2T/3lm6cNl9KkjibVfMznHPxeWicm22PwOX50h0CfrtDG/nCukyb+bR6LdqW3CeHc222LdVPCB8jK9VP6l4XvmMydr68jcpi58tboc2snyrOirVdzEtxzkr5Kk/3Yscq77yJsn/2G2qMU7bEfgP7NiXeOQ/C8JxrNPiz876w+RfqSAldl7nGHcTj/cCD0m/OIRr8peDbzgn4trklcZ4XOc5aP7ZxTxvaO/sCzwdnv7J+k+0W+2aScE0KXChTjutNRkMCHvHx2aqLoQ/4TgX0R/cT77H5u0kqS6EM75+8PeeDz1tlz2MA94uke+jT2F9kP9Y9g/9l0Odfyp+b9BsplaEf4DhVjTlKz1R8hmMo1zM/YH4FdbGNnLjhH05621wlbxWbo67pN6dy4jsFPdUPmBNHmSJ9w+XdP9mmX0M5xfg1lScfTXrbOEll6CPYD6CPYP+x2aGXQj2MxW8n258U7YiNWSYB716ab6B9sf2jjbP9o75z3IAyTJPuduwAXlTMg2M2wn8YfNgako3SZS+O3SXg8Z7BLdQe1PVdEbi2OrTVPaK7HNrqfmPmJUnCNqls0WTTxnwD4wK2RdVPCB8jK9VPowSPsilruzuoDMd3tusUyvBe+jWBcRvbgeM22+4WwSvGAzO19y9NuttRNVewGWz34YM8V+Dl2/u5gml+inxsk7mC2H2ITeQKWD/V+lvsuNt1tjsiV1DnboqquQL2GwdTruA3D4FcwTfBt32poVzBb/dzBVNlk4RrUuBqI1fwB06uAP1R27mC5yJzBX/UUK7ge6DP/8XJFVT1GymV9XMF0fT6uYKkvl+bqVwB+oi2cwXPtZQreI+TK2D7P5hyBT8AH3bUJd04+7mCsE32cwXlbLeJXAHrZ1O5Ao4HeE9/9rsM3vFelq0EH+LD4E1PQnutQrmBY/L2414rtS9oKbTt2Et029BPTALtrUTb4N9wyXS9V+TPKtbhey1UrJMkvX6ZYRcnWgavBj6OvyRMK82fR5w2Zjh+8pIw3GIBxzjmCBnw+LZR1FNzzzTpprGFaEw6NFJRT9HYTDhRZuqswf0F5dtE2xLxbo6A3xJobyJoby3AOynwKF/j+SiOqSeT3vZWiQ2+MH7gWdlLyCaUXm1xeN9GvBftBWTelfzQf6j9kXyWgXVrk2hnR/xt/N0M79jHpvnfODdFGKvL+1MXCZ/JONEXIl83BXAuAZy8P1XpzCnwjsdir5+QH7WvcQvVU3cIJeKd6p91BDtJfC4WPIX+TgWeEA/e+Vrv/F5Tewp3jR949u5ytL83EO8Iy3el8NkM1m8+44v38AwIGNZvg7/U0W91LhD5uimA83JHv5XcXw/vWL+L7k/juZG6P03xjr6H36n+Yf1mf7RY8BT6e6PAE+JBrTupuz5j7qhW30sbSXp1Be+oPnn8wLOSL9/Trvb6qT156vspfEeT8XA96BJ/F0N94w3beEEA502OfjZ9H7v3DaFNTj3sv3mC1pg9/ND/GT6zhcOSsA7yfvU7QE4Xr9S8dJifgl+L5xjHOoQvSXSO8BA9x3hcE+cY+WxUB+hndnQnzfeUjWHdG/NntrGPwzzrIwGcSVLPNx0z3o23rbtble165374zgz1vRvjIYX2DAh4vqfc4D8Dtnlz63fXd/5R5ZRSgOCc0iSUDQj4snEsf69HrY94+qVyvaw3oe8h8Dd/DH4D9AGvW+HdtCnxvr4k76E7gNkW0TbYjpv+fqp9G4Xt/n5nbG36+zLe91M5j6TuGFb2YnBt3IE6k/dO8/dTlT6r86hGU/lePF/6gzO6+VH3LWPfsn4hrgHBx7X58yDBP+7oV9N3+PPdzGXvQW/xvPOLZvu8s/Vt2Xu6+Zy8+oZixvufkn6lUDYg6l6XP/M4+ZWSuRbP5orGKOPHy7WonCrrksrvGQ9bk145IPwNSbccDP7rkfGC8VVTPxeWXQ9WuWFvve5+Aa9yw6MEz/2CfyMub/3FZDSU6D4wfHz3039x4oXYPbNpBO/K7yp7s7pZX6zO7U3N8zlm9b6Dw3Vx7BkKwIfmn38j5MX+LJR7fTfhNPi/dfyBGlM/C+9YB1MBr/KR3n1iav7g3Q3QTDyfnDnbd7Tz+IH+kM+olr2jPVb/UYeuI/3H8fw+ounFsVwX6YT0P3RH+vcd/S+al19NOA3+hyVzX57+F8UIXozk3ctj/qbF+HzRbMfnrP9efF42zxur/6hDl1G8pe5PxrrX5M+DBH9ULtNY/cJ5Q9UYVOmQ53s5P6NiV+7H0DjD8xSDPwbk4MVbDX1z48Wz7c957Q39Od9xpPynd7eQ8p9qvGT/+ePQB15+xvsWdAzvsfaGNrWExhuc+/J4s96hyXXRrkPjjeHjseGnhbw6RCOUD+LxxuB/1vEHynd5403RfJ3zQeqeLTWX9+brBlfTPo9u+7taRbkyHm/QH/L3csp+VytW/1GHXp/rfz253v5wB3gx3AMCcpD+N5hFeZ/gPWr2/2AEH3/y5e9+89HzTnoPn3vJftZHh9fAf8SXn3jTX/6vG1/dFv5jP7/q62d8+5lvt4X/r+ctXzTnsU8e1xb+j/7VD//ok798zN+3hf+0zbd9fOSUffvbwr9n/v9z5r/fPO9tbeH/+mH//bnf/+2r7yrCvyB/HoLyAapzWP7/IJQNCXyDBP9LuY1ltnkFxUJzBb3s3Q0OXCfwv+IZ+bF3wwJ+QMAb7cMFvJVhfhl9OMKgvBDXMJQj/HvytlufzIM6Vn9U0J9H9BXf+G4Owc8X8Cp/nrXzneQ3se1l19Cz3xDVx3dIu44tfOCr793xg6Me/K9t2dojp7z2jUesfPXqtvD/25/41MuO/d2bRtrCP3fw2HVj+96+tC38Hz9p8KhPvfWCJW3hX/vcslPufNnx/9AW/jW/9bol/3Dh372iCP//AWknTlXBqwwA",
      "custom_attributes": [
        "external",
        "utility"
      ],
      "debug_symbols": "TJ3LsjS7bpzf5Yw9aIIEQOpVPHD4qlCEQorwZaSX9yokwcyJ95fW+ZmoYiG7uhrd6z/+8T/+53/7f//8X/7l3/7Xv/+ff/zTf/6Pf/y3//0v//qv//LP/+Vf//2//9f/+y///m9//7//8Y/f9//sv/93/qd/7PGPf4q//9g//mn9/WfiPwv/8X/80/77T+A/if9s/OfUf84P/xn4j+E/E/9Z+A9WOVjlYJWDVQ5WGb/f/e+4/7X733n/u+5//f437n/z/nff/971xl1v3PXGXW/c9cZdb9z1xl1v3PXGXW/c9eyuZ3c9u+vZXc/uenbXs7ue3fXsrmd3vXnXm3e9edebd71515t3vXnXm3e9edebd71111t3vXXXW3e9dddbd71111t3vXXXW3c9v+v5Xc/ven7X87ue3/X8rud3Pb/r+V0v7npx14u/9cbvg9mwGrzhb80xP8iG3XAu5N+6Iz74W9i+f5XWMBtWgzdEw9/Ktj7YDefC1x6Ab2X/wBpmw1fzdzhfowCi4W/lOT7YDefC1zKA0WANs2E1eEM09MqnVz53Zfu6aM4PRoM1zIbV4A3RkA274VwYvfLolUevPHrl0SuPXnn0yqNXHr3y6JWtV7Ze2Xpl65WtV7Ze+euv6R9kw244F74eA4wGa5gNq8EbeuXZK89eefbKq1devfLqlVevvHrl1SuvXnn1yqtXXr2y98reK3uv7L2y98reK3uv7L2y98reK0evHL1y9MrRK0evHL1y9MrRK0evHL1y9srZK2evnL1y9srZK2evnL1y9srZK+9eeffKu1fevfLulXevvHvl3SvvXnn3yqdXPr1y9eD+YDasBm+IhmzYDQcwqwcLRoM1zIbV8LfyGh9EQzb8rbzig3Ph60HAaLCG2bAavCEasqFXHr2y9cp2E2maNcyG1eAN0ZANu+Em0py/hl559sqzV/56cJ0PvCEasmE3nAtfDwJGgzXMhl559cqrV1698teD/vvgXPh6EDAarGE2rAZviIZs6JW9V45e+etBzw+sYTasBm+IhmzYDefC14OAXjl75eyVs1fOXjl75eyVs1fOXnn3yrtX3r3y7pV3r7x75d0r715598q7Vz698umVT698euXTK59e+fTKp1c+vfK5K6/fr2E0WMNsWA3eEA3ZsBt65dErj1559MqjVx698uiVR688euXRK49e2Xpl65WtV7Ze2Xpl65WtV7Ze2Xpl65Vnrzx75dkrz1559sqzV5698uyVZ688e+XVK69eefXKq1devfLqlVevvHrl1SuvXtl7Ze+VvVf2Xtl7Ze+VvVf2Xtl7Ze+Vo1fuHlzdg6t7cHUPru7B1T24ugdX9+DqHlzdg6t7cHUPru7B1T24ugdX9+DqHlzdg6t7cHUPru7B1T24ugdX9+DqHlzdg6t7cHUPru7B1T24ugdX9+DqHlzdg6t7cHUPru7B1T24uge9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwd39+DuHtzdg7t7cHcP7u7B3T24uwd39+DuHtzdg7t7cHcP7u7B3T24uwd39+DuHtzdg7t7cHcP7u7B3T24uwd39+DuHtzdg7t7cHcP7u7B3T24uwd39+DuHtzdg7t7cHcP7u7B3T24uwd39+DuHtzdg7t7cHcP7u7B3T24uwd39+DuHtzdg7t7cHcP7u7B3T24uwd39+DuHtzdg7t7cHcP7u7B3T24uwd39+DuHtzdg7t7cHcP7u7B3T24uwd39+DuHtzdg7t7cH89GL8PsmE3/K0c38dyXw8CRoM1zIbV4A3RkA27oVc+vfLplU+vfHrl0yufXvn0yqdXPr3yuSuf369hNFjDbFgN3hAN2bAbeuXRK49eefTKo1cevfLolUevPHrl0SuPXtl6ZeuVrVe2Xtl6ZeuVrVe2Xtl6ZeuVZ688e+XZK89eefbKs1eevfLslWevPHvl1SuvXnn1yqtXXr3y6pVXr7x65dUrr17Ze2Xvlb1X9l7Ze2Xvlb1X9l7Ze2XvlaNXjl45euXolaNXjl45euXolaNXjl45e+XslbNXzl45e+XslbNXzl45e+XuwdM9eLoHT/fg6R483YOne/B0D57uwdM9eLoHT/fg6R483YOne/B0D57uwdM9eLoHT/fg6R78+5T992g8skfz0Xrkj+JRPtqPnsd4HuN5jOcxnsd4HuN5jOcxnsd4HuN52POw52HPw56HPQ97HvY87HnY87DnMZ/HfB7zecznMZ/HfB7zecznMZ/HfB7reaznsZ7Heh7reaznsZ7Heh7reazn4c/Dn4c/D38e/jz8efjz8Ofhz8OfRzyPeB7xPOJ5xPOI5xHPI55HPI94Hvk88nnk88jnkc8jn0c+j3we+TzyeeznsZ/Hfh77eeznsZ/Hfh77eeznsZ/HeR7neZzncZ7HeR7neZzncZ7HeR6vz8fr8/H6fLw+H6/Px+vz8fp8vD4fr8/H6/Px+ny8Ph+vz8fr8/H6fLw+H6/Px+vz8fp8vD4fr8/H6/Px+ny8Ph+vz8fr8/H6fLw+H6/Px+vz8fp8vD4fr8/H6/Px+ny8Ph+vz8fr8/H6fLw+H6/Px+vz8fp8vD4fr8/H6/Px+ny8Ph+vz8fr8/H6fLw+H6/Px+vz8fp8vD4fr8/H6/Px+ny8Ph+vz8fr8/H6fLw+H6/Px+vz8fp8vD4fr8/H6/Px+ny8Ph+vz8fr8/H6fLw+H6/Px+vz8fp8vD4fr8/H6/Px+ny8Ph+vz8fr8/H6fLw+H6/Px+vz8fp8vD4fr8/H6/Px+ny8Ph+vz8fr8/H6fLw+H6/P7fW5vT631+f2+txen9vrc3t9bq/P7fW5vT631+f2+txen9vrc3t9bq/P7fW5vT631+f2+txen9vrc3t9bq/P7fW5vT631+f2+txen9vrc3t9bq/P7fW5vT631+f2+txen9vrc3t9bq/P7fW5vT631+f2+txen9vrc3t9bq/P7fW5vT631+f2+txen9vrc3t9bq/P7fW5vT631+f2+txen9vrc3t9bq/P7fW5vT631+f2+txen9vrc3t9bq/P7fW5vT631+f2+txen9vrc3t9bq/P7fW5vT631+f2+txen9vrc3t9bq/P7fW5vT631+f2+txen9vrc3t9bq/P7fW5vT631+f2+ny+Pp+vz+fr8/n6fL4+n6/P5+vz+fp8vj6fr8/n6/P5+ny+Pp+vz+fr8/n6fL4+n6/P5+vz+fp8vj6fr8/n6/P5+ny+Pp+vz+fr8/n6fL4+n6/P5+vz+fp8vj6fr8/n6/P5+ny+Pp+vz+fr8/n6fL4+n6/P5+vz+fp8vj6fr8/n6/P5+ny+Pp+vz+fr8/n6fL4+n6/P5+vz+fp8vj6fr8/n6/P5+ny+Pp+vz+fr8/n6fL4+n6/P5+vz+fp8vj6fr8/n6/P5+ny+Pp+vz+fr8/n6fL4+n6/P5+vz+fp8vj6fr8/n6/P5+ny+Pp+vz+fr8/n6fL4+n6/P5+vz+fq8BpYCc9jz0Xr055G/oniUj/ajc6kGly6NR/ZoPlqP/FE8ykf70fMYz2M8j/E8xvMYz2M8j/E8xvMYz2M8D3se9jzsedjzsOdhz8Oehz0Pex72PObzmM9jPo/5PObzmM9jPo/5PObzmM9jPY/1PNbzWM9jPY/1PNbzWM9jPY/1PPx5+PPw5+HPw5+HPw9/Hv48/Hn484jnEc8jnkc8j3ge8TziecTziOcRzyOfRz6PfB75PPJ55PPI55HPI59HPo/9PPbz2M9jP4/9PPbz2M9jP4/9PPbzOM/jPI/zPM7zOM/j9fl6fb5en6/X5+v1eQ1HpRWNR/ZoPlqP/FE8ykf70Wkaz2M8j/E8xvMYz2M8j/E8xvMYz2M8D3se9jzsedjzsOdhz8Oehz0Pex72PObzmM9jPo/5PObzmM9jPo/5PObzmM9jPY/1PNbzWM9jPY/1PNbzWM9jPY/1PPx5+PPw5+HPw5+HPw9/Hv48/Hn484jnEc8jnkc8j3ge8TziecTziOcRzyOfRz6PfB75PPJ55PPI55HPI59HPo/9PPbz2M9jP4/9PPbz2M9jP4/9PPbzOM/jPI/zPM7zOM/jPI/zPM7zOM/jtEe8Po/X5/H6PF6fx+vzeH0er8/j9Xm8Po/X5/H6PF6fx+vzeH0er8/j9Xm8Po/X5/H6PF6fx+vzeH0er8/j9Xm8Po/X5/H6PF6f13BWetFpqj4HjUf2aD5aj/xRPMpHz2M+j/U81vNYz2M9j/U81vNYz2M9j/U81vPw5+HPw59HfYFuFK1H/ige5aP96DTV1+lA45E9eh5fn+8641+fX4pH+Wg/Ok1fn18aj+zRfPQ88nnk88jn8fX5XkWn6evzS+ORPZqP1iN/FI/y0fPYz+M8j/M8zvM4z+M8j/M8zvM4z+M8j9MeNeR1aTyyR/PReuSP4lE+2o+ex3ge43mM51FfbPWi9cgffR74mmQ+2o8+j+8dSw1+XRqP/jzOKJqP1qM/j5NF8Sgf/XkcrHKavj6/NL5vetb3ML9Gb5zERXRiEJO4iefh1/CNdFt0W3Rb5VZHtZwYxHKr07028Tz0H3EQjTiJi+jEINLN6eZ0i3Kr/Y1BNOIkLqITg5jETTwPk25Jt6Rb0i3plnRLuiXdkm5Jt023TbdNt023TbdNt023TbdNt023Q7dDt0O3Q7dDt0O3Q7dDt0O389xqGq1xEI04iYvoxCAmcRPpNug26DboNug26DboNug26DboNuhmdDO6Gd2MbkY3o5vRzehmdDO6TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26LbotujndnG5ON6eb083p5nRzuiFL8KX18xBZAhxEI07iIjoxiEmkW9At6ZZ0S7ol3ZJuSbekW9It6ZZ023TbdNt023TbdNt023TbdNt023Q7dDt0O3Q7dDt0O3Q7dDt0O3Q7z+38fsRBNOIkLqITg5jETaTboNug26DboNug26DboNug26DboJvRzehmdDO6Gd2MbkY3o5vRzeg26TbpNuk26TbpNuk26TbpNuk26bbotui26Lbotui26Lbotui26Lbo5nRzujndnG5ON6eb083pxiw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsOS9L7PeyxH4vS+z3ssR+L0vs97LEfi9L7PeyxH4vS+z3ssR+P7oNug26DboNug26DboNug26DboNuhndjG5GN6Ob0a2yZNRPq1SWXEziJp6HlSUXB9GIk7iIdJt0m3SrLBlWeB5WllwcRCNO4iI6MYhJpNuim9PN6eZ0c7o53ZxuTjenm9PN6RZ0C7oF3YJuQbegW9At6BZ0C7ol3ZJuSbekW9It6ZZ0S7ol3ZJum26bbptum26bbptum26bbptum26Hboduh26Hboduh26HbpUlYxVu4mmsAcQxsnAQjTiJi+jEICZxE8/DQbdBt0G3QbdBt0G3QbdBt0G3QTejm9HN6GZ0M7oZ3YxuRjejm9Ft0m3SbdJt0m3SbdJt0m3SbdJt0m3RbdFt0W3RbdFt0W3RbdFt0W3RzenmdHO6Od2cbk43p5vTzenmdAu6Bd2CbkG3oFvQLegWdAu6Bd2Sbkm3pFvSLemWdEu6Jd2Sbkm3TbdNt023TbdNt023TbdNt023TbdDt0O3Q7dDt0O3Q7dDt0O3Q7fz3IxZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMktqEnN8v2JqNYrZmMRNPA8rSy4OohEncRHplnRLulWW2Cg8DytLLg6iESdxEZ0YxCTSbdPt0O3Q7dDt0O3Q7dDt0O3Q7dDtPLca1mwcRCNO4iI6MYhJ3ES6DboNug26DboNug26DboNug26DboZ3YxuRjejm9HN6GZ0M7oZ3Yxuk26TbpNuk26TbpNuk26TbpNuk26Lbotui26Lbotui26Lbotui26Lbk43p5vTrbLEZuEiOrHcojCJm3geVpZcHEQjTuIiOpFuQbegW9At6ZZ0S7ol3ZJuSbekW9It6ZZ023TbdNt023TbdNt023TbdNt023Q7dDt0O3Q7dDt0O3Q7dDt0O3Q7z81/P+IgGnESF9GJQUziJtJt0G3QbdBt0G3QbdBt0G3QbdBt0M3oZnQzuhndjG5GN6Ob0c3oZnSbdJt0m3SbdJt0m3SbdJt0m3SbdFt0W3RbdFt0W3RbdFt0W3RbdFt0c7o53ZxuTjenm9ONWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4sySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWYK5VzsfIkuAg2jESVxEJwYxiZtIt6Bb0K2ypP42COZeLy6iE4OYxE08DytLLg4i3ZJuSbekW9It6ZZ0S7ptulWWTCs04iQuohODmMRNPA8rSy7S7dDt0O3Q7dDt0O3Q7dDtPDfMvV4cRCNO4iI6MYhJ3ES6DboNug26DboNug26DboNug26DboZ3YxuRjejm9HN6GZ0M7oZ3Yxuk26TbpNuk26TbpNuk26TbpNuk26Lbotui26Lbotui26Lbotui26Lbk43p5vTzenmdHO6Od2cbk43p1vQLegWdAu6Bd2CbkG3oFvQLeiWdEu6Jd2Sbkm3pFvSLemWdEu6bboxSzazZDNLNrNkM0s2s2QzSzazZDNLNrNkM0s2s2QzSzazZDNLNrNkM0s2s2QzSw6z5DBLDrPkMEsOs+QwSw6z5DBLDrPkMEsOs+QwSw6z5DBLDrPkMEsOs+QwSw6z5DBLDrPkMEsOs+QwSw6z5DBLDrPkMEsOs+QwSw6z5DBLDrPkMEsOs+QwSw6z5DBLDrPkMEsOs+QwSw6z5DBLDrPkMEsOs+QwSw6z5DBLDrPkMEsOs+QwSw6z5DBLDrPkMEsOswRzr/ObecLc68VBNOIkLqITg5jETaRb0i3plnRLuiXdkm5Jt6Rb0i3ptum26bbptum26bbptum26bbptul26Hboduh26Hboduh26Hboduh22m1i7vXiIBpxEhfRiUFM4ibSbdBt0G3QbdBt0G3QbdBt0G3QbdANWRKFg2jEctuFi+jEICZxE89DZAlwEI1It0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0U3p5vTzenmdHO6Od2cbk43p5vTLegWdAu6Bd2CbkG3oFvQLegWdEu6Jd2Sbkm3pFvSLemWdEu6Jd023TbdNt023TbdNt023TbdNt023Q7dDt0O3Q7dDt0O3Q7dDt0O3c5zw9zrxUE04iQuohODmMRNpNug26DboNug26DboNug26DboNugm9HN6GZ0Y5YMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWYJ5l4X/oTuJC7i57ZmYRCTuImnEXOvFwfRiJO4iE4MYh1bFm7ieYgsAQ6iESdxEZ0YRLoNug26Gd2MbkY3o5vRzehmdDO6Gd2MbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui25ON6eb083p5nRzujndnG5ON6dbZYlb4SAa8XPzuuQqSy46sa7JVZjETTwPK0suDqIRJ3ERnUi3pFvSLem26bbptum26bbptum26bbptum26Xboduh26Hboduh26Hboduh26HaeG+ZeLw6iESdxEZ0YxCRuIt0G3QbdBt0G3QbdBt0G3QbdBt0G3YxuRjejm9HN6GZ0M7oZ3YxuRrdJt0m3SbdJt0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0U3p5vTzenmdHO6Od2cbsiSUbiJ5yHuS4CDaMRJXEQnBpFuQbegW9It6ZZ0S7ol3ZJuSbekW9It6bbptum26bbptum26bbptum26bbpduh26Hboduh26Hboduh26Hbodp4b5l4vDqIRJ3ERnRjEJG4i3QbdBt0G3QbdBt0G3QbdBt0G3QbdjG5GN6Ob0c3oZnQzuhndjG5Gt0m3SbdJt0m3SbdJt0m3SbdJt0m3RbdFt0W3RbdFt0W3RbdFt8oS34XnYWXJxc8t6n9bWXJxEj+3mIVODGISN/E8rCy5OIhGnES6Bd2CbkG3oFvQLemWdEu6Jd2Sbkm3pFvSLemWdNt023TbdNt023TbdNt023TbdNt0O3Q7dDt0O3Q7dDt0O3Q7dDt0O88Nc68XB9GIk7iITgxiEjeRboNug26DboNug26DboNug26DboNuRjejm9HN6GZ0M7oZ3YxuRjej26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26LbopvTzenmdHO6MUuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSWYe/3+WsjE3OvFTTwPkSXAQTTiJC6iE+kWdAu6Bd0qSzIKB9GI5WaFi+jEICZxE89DZAlwEI1It023TbdNt023TbdNt0O3Q7dDt0O3Q7dDt0O3Q7dDt/PcMPd6cRCNOImL6MQgJnET6TboNug26DboNug26DboNug26DboZnQzuhndjG5GN6Ob0c3oZnQzuk26TbpNuk26TbpNuk26TbpNuk26Lbotui26Lbotui26Lbotui26Lbo53ZxuTjenm9PN6eZ0c7o53ZxuQbegW9At6BZ0C7oF3YJuQbegW9It6ZZ0Y5ZsZslmlmxmyWaWbGbJZpZsZslmlmxmyWaWbGbJZpZsZslmlmxmyWaWbGbJZpZsZslmlmDudc9CJwbxc/t+0H1i7vXiacTc6z6Fg2jEz+38ChfRiUFM4iaeh5UlFwfRiHQbdBt0G3SrLDlRuInn4Zclf59pFw6iEeeHdR6+LGl04p+bfT+VOGvutXETz4ffXtTca+Mgfm6jyvmypHERnRjEJG7iebh+xEGk26Lbotui26Lbotui26Kb083p5nRzujndnG5ON6eb083pFnQLugXdgm5Bt6Bb0C3oFnQLuiXdkm5Jt6Rb0i3plnRLuiXdkm6bbptum26bbptum26bbptum26bboduh26Hboduh26Hboduh26HbqfdVs29Ng6iESdxEZ0YxCRuIt0G3QbdBt0G3QbdBt0G3QbdBt0G3YxuRjejm9HN6GZ0M7oZ3YxuRrdJt0m3SbdJt0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0U3p5vTzenmdHO6Od2cbk43p5vTLegWdAu6Bd2CbkG3oFvQLegWdEu6Jd2Sbkm3pFvSLemWdEu6Jd023TbdNt023TbdNt023TbdNt0qS75fjVk199o4iJ+b7cJJXMTP7ftG5aq518Ykfm6z3CpLCmvutfFz+z7hXzX32jiJn9v3ud6qudfGIH5uyws38TysLPlGAFbNvTYa8XPzWqyy5KITP7f4FSZxEz+3qHorSy4O4uf2vVVeNffauIifW1a9lSUXk/i5ZZ2zyhJgZcnFzy1PoREncRGdGMQkbuJ5WFlykW6Lbotui26Lbotui26LbotuTjenm9PN6eZ0c7o53ZxuTjenW9At6BZ0qyzZdT1Ullx04ue2a7MqSy5u4nlYWXJxEI04iYvoRLol3ZJuSbfKku8vMK2ae2004ud2rHARnfi5nTrMypKLm3geVpZcHEQjTuIiOpFuh25flsxf1ftlCbDmXhvHh1ZoxElcH+5CJwYxPzyFm3ge1jvs+p9+F98cv8JvgVEO32XWuInn4XeZNQ6iESdxEZ1It6Bb0C3olnRLuiXdkm5Jt6Rb0i3plnRLum26bbptum26bbptum26bbptum26Hboduh26Hboduh26Hboduh26nedWI5GNg2jESVxEJwYxiZtYbl/D1khk4yAacRIXsdxOYRCTuImf2/djjKtGIhs/t++X5laNRDZO4iI6MYhJ/NxsFZ6H80cstyg04iSWW9U7nRjEJG7iefi9ZM3vJxJWjUQ2GnESP7dZlX0vWY1B/NxWnajvJavxPPxesuaqxb6XrEYj1lFk4bdu3cLUmOOfz4eVD6tKr3y4aMRJXEQnfuvWjU2NOTZu4nlY+VD3ODXm2Pi5eRVZ+XBxEZ0YxCR+blEXQeUDsPLh4iB+blEdUPlw8XOLKrLy4WIQk1huZVz5AKx8uDiIRpzEzy2rnMqHi0FM4ueWVWTlQ2GNOTaWmxcacRI3sVb4jqKGFGfdyuHPqhdUXafQiUH86vr+eueqEcXG87B6e5dB9fbFz6vuDWpEsXERP7ddNVRvX0ziJp6H1dsXa91dWCtUvdWv3xO+VWOHjedh9evFr966/aixw8ZJXEQnfm6njqL69eImltt3pdfYYeMgGnESF7Hcaquqiy/mw+rii7VCnZLq14u1Qu1F9evFJFa9dc6qX4HVrxf/6l1131OjhI3zwzoPX782+odV+tev61fn4evXvze4hX9ua2CF8/Dr18bPbVRlX782TuK37iiLXSuUxakVyuLUCnXwp1aoS+PrwVUvPTUIuOp9Zw0CNm7it65969YgYOMgfkdcLxw13LcqZ2u47++CLzwPR62wC2uFU2jESVzE70zOX2EQk7iJ5+HXhY2DaMRadxTWClXkrP/BLPzKqVehmsdrdGIQz8NVK9TZWZNYK9SJWlV6nSiv/22dEp/ERSy3Og8exCTut66f9/8bP+IgGnG+I45FdGIQeWz5ewdUzXCRR1yXPa6HuuzrNbqm3taqU12X/cXzsC77i4NoxEn86l1V2fcy1RjEcqst3OVWpVeL1NOJmnpb9dpfU2/3oq0WuTiJtW6ds2qRi5v4retfZTXf1jiIX73f9yVWzaytug2ombW/vi08D6tF6o6gZtb+9rTQiJO4iN958CgMYhI38TysFrk4iEasdbOwVqgiq0XqIUwNlK26p6iBssYkbuJnXHcaNVDWOIhGnMRFdGIQk7iJdHO6Od2cbk43p5vTzenmdHO6Od2CbkG3oFvQLegWdKt+q9usmhdrHEQjTuIiOjGISdxEum26bbptum26bbptum26bbptum26Hboduh26Hbodup3nVhNcf/9vYblF4edW9401q7XqDrEGqf5enwuNOImfRd0L1iDVqpu9GqRqTOImnoffnVjjIBpxEheRbpNu1UN1Y1iDVI3nYfXQrnqrhy4a8XOr+7MapGp04udWtz41SNW4iZ9b3X7VIFXjIBpxEhfRiUFM4ibSLegWdKtuqfvJGo5adbNXw1Hr+3Plq4ajLlbjXBxEI07iIjoxiEmkW9Jt023TbdNt023TbdOtGqfuMms4qnETz8NqnIuDaMRJXEQn0u3Q7dDte1Hz74+urxqOahzE9eEozA+tcH84C8/D8SMOohEncRGdGMQk0m3Qzehm5bYKjTiJi+jEICZxE8/D+SPSbdJt0m3SbdJt0m2WWxRu4nm4fsRBNGKtm4W1wi78Vqg3FTXE1DiIRpzERXRiEJO4iXQLugXdotzqMopJXEQnBjEfZq1be5y1Qp2+XEQn1gpemMRNPA/3jziIRpzERXQi3TbddrnVtuzz8PyI5XYKjfi51Tu1GkzyesRXg0leb89qMKkxiZ9bvT2rwSRgDSZ53ZnXYJLX7W0NJnm9z6rBpMZFdGIQ82F1d72jqmEjr3dUNWzk9Taqho0ag/itUG8qatio8TysPr44iLVuHVD1Zr3zqQEir3dUNUB0sXrz4iAacRIX0YlBLLc64urNi+dh9Wa93akBokYjTuLnVu9maoCoMYifW72FqQGixvOw+rje7tQAUaMRJ3ERnVhudVKrjy9uYrnVqa4+vjiIRnRirVDbEudhdWy9YaqhoEYjfvV6nZ3q44tODGISN/E8rD6+OIhGpNum26bbptum26bbptuh26Hboduh26Hboduh26HboVv18fd20msoqHEQy20WTuIilpsXBrHcduEmnofV3RcHsdxO4SR+bt/7Qq+hII+qrHr+e2PjNRTUuImfW6wPq+cvDuLn9t3bew0FNS6iE4OYDysJvsfOXoM+HnUU1fNRpVfPXwxiEr96sw6oeh5YPX9xEI34uWUdZvV81lmvns8qp3o+y6J6HljdvetMVh/vWqw6dtdi1bEXN/GrbNd2V8deHEQjTuIiOrHc6vTVK+/F/bBaGpVVS180YlnUqa6WvujEz+Lgf5vETfwO6FQ51dIXP7dTR1wtfXESP7dT10619MUgJnETz8Nq6YuDaMRJpNuh26Hboduh23luNZvTOIhGnMRFdGIQk1huXngeVktfLLcsNOIkltsudGIQk1hup/DPLb43Cl6zOfG9O/CazWk04vxwFi6iE4OYxE08D+ePOIhGpNuk26TbLLdRmMRNPA/XjziIRpzEcquzvpwYxHKLwk08D/1HLLfaITfiJAaxVqht+UIhRm3LFwqNRpzEb4VRO/S9jMeos5M/4iAacRIX8TviUYeZQUziJp6H+0ccRCOWW53fvYhODGK51enbm1hudf2eH3EQPzerU/L1fOMiOjGI2VjTMvHdunvNxcT3YYjXXEx89+teczGNQUziV+93F+81F3Nx/IiDaMTPbVYNXx83OjGISdzEz+278fb6PbjGQTRiuZVx9fFFJ5ZbFn5uqyyqjy9+bqtOVPXxxc9t1TmrPr44iYvoxCAmcRPPw+rji3RbdFt0W3RbdFt0W3RbdFt0c7o53ZxuTjenm9PN6eZ0c7o53YJuQbegW9At6BZ0C7oF3YJuQbekW9It6Vb5sOqqrny46MQglltdO5UPF8/DyoeLg2jESVxEJwaRbptum26Hboduh26Hboduh26n1v1ypwaa/j65KDRirbALF9GJQUziJp6HlQTf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",
      "is_unconstrained": true,
      "name": "process_message"
    },
    {
      "abi": {
        "error_types": {
          "11594563071547591162": {
            "error_kind": "string",
            "string": "Function _validate_emitter_and_update_value can only be called internally"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14415304921900233953": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15546539856497705002": {
            "error_kind": "string",
            "string": "u16 to u8 conversion failed"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16810041750452690220": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 27
          },
          "17765343328382640478": {
            "error_kind": "string",
            "string": "Source chain IDs and emitter addresses length mismatch"
          },
          "18173155084464344029": {
            "error_kind": "string",
            "string": "Emitter not registered"
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "6788092787179896647": {
            "error_kind": "string",
            "string": "Caller is not owner"
          },
          "8228371833434187583": {
            "error_kind": "string",
            "string": "Trying to read from uninitialized PublicImmutable"
          },
          "9967937311635654895": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          }
        },
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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JwIOBA8tCAAPLQoMEC0KBBEtCE8SLQoJEwAIAA4AJQAALPgtAgAALQoQDScCCQQOLQgADi0KBw8tCgUQAAgACQAlAAAshy0CAAAtCg8EACIESwctCwcFHAoFBwYcCgcEAB4CAAUAHgIABwAzKgAFAAcACSQCAAkAABkcJQAAKgEnAgkEDi0IAA4ACAAJACUAACglLQIAAC0KDwUtChAHJAIABQAAGUwnAgkEADwGCQEeAgAFAAoqBwUJJAIACQAAGWMlAAAt8C0IAQUnAgcEAwAIAQcBJwMFBAEAIgUCBy0KBwktDgsJACIJAgktDgoJJwIJBA4tCAAOLQoFDy0ITRAtCEcRAAgACQAlAAAuAi0CAAAtCg8HCiIHSQUKIgVHCSQCAAkAABnKJQAAL5QtCAEFJwIJBCEACAEJAScDBQQBACIFAgknAgoEIAAqCgkKLQoJCw4qCgsMJAIADAAAGgstDEkLACILAgsjAAAZ8C0IAQkAAAECAS0OBQktCEgDIwAAGiEMIgNQBSQCAAUAAB0kIwAAGjMtCwkFLQgBBwAAAQIBLQ4FBy0IAQUAAAECAS0MSAUtCAEJJwIKBCEACAEKAScDCQQBACIJAgonAgsEIAAqCwoLLQoKDA4qCwwOJAIADgAAGpItDggMACIMAgwjAAAadycCCgQOLQgADi0KBw8tCgUQLQhSES0KCRIACAAKACUAACz4LQIAAC0KDwgtCAEFAAABAgEtDEoFLQhIAyMAABrTDCIDUAckAgAHAAAc6CMAABrlLQsFAyQCAAMAABr2JQAAL6YwCgAEAAYtCwIDACIDAgMtDgMCACICAgUtCwUEJwIGBAIAKgUGAzsOAAQAAyMAABsnJwICAlUnAgMCbicCBAJrJwIFAm8nAgYCdycCBwIgJwIIAnMnAgkCZScCCgJsJwILAmMnAgwCdCcCDQJyJwIOAnsnAg8CfS0IARAnAhEEHAAIAREBJwMQBAEAIhACES0KERItDgISACISAhItDgMSACISAhItDgQSACISAhItDgMSACISAhItDgUSACISAhItDgYSACISAhItDgMSACISAhItDgcSACISAhItDggSACISAhItDgkSACISAhItDgoSACISAhItDgkSACISAhItDgsSACISAhItDgwSACISAhItDgUSACISAhItDg0SACISAhItDgcSACIS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",
      "custom_attributes": [
        "external",
        "public"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "public_dispatch"
    },
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "14067204867181196045": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15711892660910782274": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16216212843441549037": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "2014890719615096298": {
            "error_kind": "string",
            "string": "Field failed to decompose into specified 40 limbs"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "3378875131383195299": {
            "error_kind": "string",
            "string": "Invalid destination chain ID"
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "4648451262681811962": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "7555607922535724711": {
            "error_kind": "string",
            "string": "Preimage mismatch"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9589626482238399944": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "9921926525851912681": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "anchor_block_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "sponge_blob_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "vaa",
            "type": {
              "kind": "array",
              "length": 2000,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "length",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "note_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 32,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "log",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "fields",
                                          "type": {
                                            "kind": "array",
                                            "length": 18,
                                            "type": {
                                              "kind": "field"
                                            }
                                          }
                                        },
                                        {
                                          "name": "length",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::log::Log"
                                    }
                                  },
                                  {
                                    "name": "note_hash_counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "anchor_block_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "sponge_blob_hash",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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hS6X0OUWujxCl1fo8gldfqErIHQFha6Q0BUWuiJCV1ToigldcaErIXQlha6U0JUWujJCV1boygldeaGrIHQVha6S0FUWuipCV1XoqglddaGrIXQ1ha6W0NUWujpCV1fo6gldfaFrIHQNha6R0DUWuiZC11Tomgldc6FrIXQtha6V0LUWujZC11bo2glde6HrIHQdha6T0HUWui5C11Xougldd6HrIXQ9ha6X0PUWuj5C11fo+gldf6EbIHQDhW6Q0A0WuiFCN1TohgndcKEbIXQjhW6U0I0WujFCN1boxgndeKGbIHQThW6S0E0WuilCN1XopgnddKGbIXQzhW6W0M0WujlCN1fo5gndfKFbIHQLhW6R0C0WuiVCt1TolgndcqFbIXQrhW6V0K0WujVCt1bo1gndeqHbIHQbhW6T0G0Wui1Ct1XotgnddqHbIXQ7hW6X0O0Wuj1Ct1fo9gndfqE7IHQHhe6Q0B0WuiNCd1TojgndcaE7IXQnhe6U0J0WujNCd1bozgndeaG7IHQXhe6S0F0WuitCd1XorgnddaG7IXQ3he6W0N0WujtCd1fo7gndfaF7IHQPhe6R0D0WuidC91Tongndc6F7IXQvhe6V0L0WujdC91bo3gnde6H7IHQfhe6T0H0Wui9C91Xovgndd6H7IXS+/P/3zkfofAudH6HzK3T+hM6/0AUQuoBCF0joAgtdEKELKnTBhC640IUQupBCF0roQgtdGKELK3ThhC680EUQuohCF0noIgtdFKGLKnTRhC660MUQuphCF0voYgtdHKGLK3TxhC6+0CUQuoRCl0joEgtdEqFLKnTJhC650KUQupRCl0roUgtdGqFLK3TphC690GUQuoxCl0noMgtdFqHLKnTZhC670OUQupxCl0vocgtdHqHLK3T5hC6/0BUQuoJCV0joCgtdEaErKnTFhK640JUQupJCV0roSgtdGaErK3TlhK680FUQuopCV0noKgtdFaGrKnTVhK660NUQuppCV0voagtdHaGrK3T1hK6+0DUQuoZC10joGgtdE6FrKnTNhK650LUQupZC10roWgtdG6FrK3TthK690HUQuo5C10noOgtdF6HrKnTdhK670PUQup5C10voegtdH6HrK3T9hK6/0A0QuoFCN0joBgvdEKEbKnTDhG640I0QupFCN0roRgvdGKEbK3TjhG680E0QuolCN0noJgvdFKGbKnTThG660M0QuplCN0voZgvdHKGbK3TzhG6+0C0QuoVCt0joFgvdEqFbKnTLhG650K0QupVCt0roVgvdGqFbK3TrhG690G0Quo1Ct0noNgvdFqHbKnTbhG670O0Qup1Ct0vodgvdHqHbK3T7hG6/0B0QuoNCd0joDgvdEaE7KnTHhO640J0QupNCd0roTgvdGaE7K3TnhO680F0QuotCd0noLgvdFaG7KnTXhO660N0QuptCd0vobgvdHaG7K3T3hO6+0D0QuodC90joHgvdE6F7KnTPhO650L0QupdC90roXgvdG6F7K3TvhO690H0Quo9C90noPgvdF6H7KnTfhO670P0QOl8B/nvnI3S+hc6P0PkVOn9C51/oAghdQKELJHSBhS6I0AUVumBCF1zoQghdSKELJXShhS6M0IUVunBCF17oIghdRKGLJHSRhS6K0EUVumhCF13oYghdTKGLJXSxhS6O0MUVunhCF1/oEghdQqFLJHSJhS6J0CUVumRCl1zoUghdSqFLJXSphS6N0KUVunRCl17oMghdRqHLJHSZhS6L0GUVumxCl13ocghdTqHLJXS5hS6P0OUVunxCl1/oCghdQaErJHSFha6I0BUVumJCV1zoSghdSaErJXSlha6M0JUVunJCV17oKghdRaGrJHSVha6K0FUVumpCV13oaghdTaGrJXS1ha6O0NUVunpCV1/oGghdQ6FrJHSNha6J0DUVumZC11zoWghdS6FrJXStha6N0LUVunZC117oOghdR6HrJHSdha6L0HUVum5C113oeghdT6HrJXS9ha6P0PUVun5C11/oBgjdQKEbJHSDhW6I0A0VumFCN1zoRgjdSKEbJXSjhW6M0I0VunFCN17oJgjdRKGbJHSThW6K0E0VumlCN13oZgjdTKGbJXSzhW6O0M0VunlCN1/oFgjdQqFbJHSLhW6J0C0VumVCt1zoVgjdSqFbJXSrhW6N0K0VunVCt17oNgjdRqHbJHSbhW6L0G0Vum1Ct13odgjdTqHbJXS7hW6P0O0Vun1Ct1/oDgjdQaE7JHSHhe6I0B0VumNCd1zoTgjdSaE7JXSnhe6M0J0VunNCd17oLgjdRaG7JHSXhe6K0F0VumtCd13obgjdTaG7JXS3he6O0N0VuntCd1/oHgjdQ6F7JHSPhe6J0D0V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79gCuOvemeeub/6hXRz/lsBd93t77vrmH8Zl10P3+7lnaJ1hdLr75rkXVs7hJOElEVy/fya6h1bAXTfXc9e3PUR0cd6xNXDXvTPPXd/8I7k4/m2Au+739tz1zT+yy66H7vdzz0g6I+t0981zL4qco0qiSaK7fv9MdA9tgbturueub3uI4eK8Yzvgrntnnru++cd0cfzbA3fd7+2565t/LJddD93v554xdcbS6e6b515sOcdxcyRxXb9/JrqHDsBdN9dz17c9xHNx3rEjcPd/dqb/h2/+8V0c/07AXfd7e+765p/AZddD9/u5Z3ydCXTGdf37XkI5J5IkliRx/f6Z6B46A3fdXM9d3/aQ1MV5xy7AXffOPHd980/m4vh3Be6639tz1zf/5C67Hrrfzz2T6Uyu0903z70Uck4pSSVJ7fr9M9E9dAPuurmeu77tIY2L847dgbvunXnu+ubv4+L49wDuut/bc9c3/7Quux663889fXSm1enum+deOjmnl2SQZHT9/pnoHnoCd91cz13f9pDJxXnHXsBd9848d33zz+zi+PcG7rrf23PXN/8sLrseut/PPTPrzKLT3TfPvaxyzibJLsnh+v0z0T30Ae66uZ67vu0hp4vzjn2Bu+6dee765p/LxfHvB9x1v7fnrm/+uV12PXS/n3vm0plbp7tvnnt55JxXkk+S3/X7Z6J76A/cdXM9d33bQwEX5x0HAHfdO/Pc9c2/oIvjPxC4635vz13f/Au57Hrofj/3LKizkE533zz3Csu5iKSopJjr989E9zAIuOvmeu76tofiLs47DgbuunfmueubfwkXx38IcNf93p67vvmXdNn10P1+7llCZ0md7r557pWSc2lJGUlZ1++fie5hKHDXzfXc9W0P5VycdxwG3HXvzHPXN//yLo7/cOCu+709d33zr+Cy66H7/dyzvM4KOt1989yrKOdKksqSKq7fPxPdwwjgrpvruevbHqq6OO84Erjr3pnnrq//Sy4ujv8o4K77vT13ff1fYnHZ9dD9fu5ZTWd1ne6+ee7VkHNNSS1Jbdfvn4nuYTRw18313PX1f3DAxXnHMcBd9848d339HyZwcfzHAnfd7+256+v/SIDLrod1XP+adXXW0+num+defTk3kDSUNHL9/pnoHsYBd91cz13f9tDYxXnH8cBd9848d33zb+Li+E8A7rrf23PXN/+mLrseut/PPZvobKrT3TfPvWZybi5pIWnp+v0z0T1MBO66uZ67vu2hlYvzjpOAu+6dee765t/axfGfDNx1v7fnrm/+bVx2PXS/n3u21tlGp7tvnntt5dxO0l7SwfX7Z6J7mALcdXM9d33bQ0cX5x2nAnfdO/Pc9c2/k4vjPw24635vz13f/Du77Hrofj/37KSzs0533zz3usi5q6SbpLvr989E9zAduOvmeu76toceLs47zgDuunfmueubf08Xx38mcNf93p67vvn3ctn10P1+7tlTZy+d7r557vWWcx9JX0k/1++fie5hFnDXzfXc9W0P/V2cd5wN3O3j8rv/ABfHfw5w1/3enru++Q902fXQ/X7uOUDnQJ3uvnnuDZLzYMkQyVDX75+J7mEucNfN9dz1bQ/DXJx3nAfcde/Mc9c3/+Eujv984K77vT13ffMf4bLrofv93HO4zhE63X3z3Bsp51GS0ZIxrt8/E93DAuCum+u569sexro477gQuOvemeeub/7jXBz/RcBd93t77vrmP95l10P3+7nnOJ3jdbr75rk3Qc4TJZMkk12/fya6h8XAXTfXc9e3PUxxcd5xCXDXvTPPXd/8p7o4/kuBu+739tz1zX+ay66H7vdzz6k6p+l0981zb7qcZ0hmSma5fv9MdA/LgLturueub3uY7eK843Lgrntnnru++c9xcfxXAHfd7+2565v/XJddD93v555zdM7V6e6b5948Oc+XLJAsdP3+megeVgJ33VzPXd/2sMjFecdVwF33zjx3ffNf7OL4rwbuut/bc9c3/yUuux663889F+tcotPdN8+9pXJeJlkuWeH6/TPRPawB7rq5nru+7WGli/OOa4G77p157vrmv8rF8V8H3HW/t+eub/6rXXY9dL+fe67SuVqnu2+ee2vkvFayTrLe9ftnontYD9x1cz13fdvDBhfnHTcAd90789z1zX+ji+O/Ebjrfm/PXd/8N7nseuh+P/fcqHOTTnffPPc2y3mLZKtkm+v3z0T3sAm46+Z67vq2h+0uzjtuBu66d+a565v/DhfHfwtw1/3enru++e902fXQ/X7uuUPnTp3uvnnu7ZLzbskeyV7X75+J7mErcNfN9dz1bQ/7XJx33Abcde/Mc9c3//0ujv924O4el9/9D7jseuh+P/fcr/OATnffPPcOyvmQ5LDkiOv3z0T3sAO46+Z67vq2h6MuzjvuBO66d+a565v/MRfHfxdw1/3enru++R932fXQ/X7ueUzncZ3uvnnunZDzSckpyWnX75+J7mE3cNfN9dz1bQ9nXJx33APcde/Mc9c3/7Mujv9e4K77vT13ffM/57Lrofv93POsznM63X3z3Dsv5wuSi5JLrt8/E93DPuCum+u569seLrs477gfuOvemeeub/5XXBz/A8Bd93t77vrmf9Vl10P3+7nnFZ1Xdbr75rl3Tc7XJTckN12/fya6h4PAXTfXc9e3Pdxycd7xEHDXvTPPXd/8b7s4/oeBu+739tz1zf+Oy66H7vdzz9s67+h0981z766c70nuSx64fv9MdA9HgLturueub3t46OK841Hgrntnnru++T9ycfyPAXfd7+2565v/Y5ddD93v556PdD7W6e6b594TOT+VPJM8d/3+megejgN33VzPXd/28MLFeccTwF33zjx3ffN/6eL4nwTuut/bc9c3/1cuux663889X+p8pdPdN8+913J+I3kreef6/TPRPZwC7rq5nru+7eG9i/OOp4G77p157vrm/8HF8T8D3HW/t+eub/4fXXY9dL+fe37Q+VGnu2+ee5/k/FnyRfLV9ftnons4C9x1cz13fdvDNxfnHc8Bd90789z1zf+7i+N/Hrjrfm/PXd/8f7jseuh+P/f8rvOHTnffPPd+yvmXxIkr/1nc3z8T3cMF4K6b67nr2x78x+W840Xgrntnnru++Qcg+V8C7jpx/e4fMK5dD93v554BdAbU6e6b514gOQeWBJEEtezhZeBuIGAPwUjveAW4GxjwD07yvwrcDQL4h7DsYTDtXXCdIXQGNXoYUs6hJKElYSx7eA24GxLYQ1jSO14H7oYC/MOR/G8Ad0MD/uEtexhWexdOZ3idYYweRpBzREkkSWTLHt4E7kYA9hCF9I63gLsRAf+oJP/bwN1IgH80yx5G0d5F1RlNZ2Sjh9HlHEMSUxLLsod3gLvRgT3EJr3jXeBuDMA/Dsn/HnA3JuDvsuxhbO1dHJ0unbGMHsaVczxJfEkCyx7eB+7GBfaQkPSOD4C78QD/RCT/h8Dd+IB/YsseJtTeJdKZWGcCo4dJ5JxUkkyS3LKHj4C7SYA9pCC942PgblLAPyXJ/wlwNxngn8qyhym0dyl1ptKZ3OhhajmnkfhI0lr28ClwNzWwh3Skd3wG3E0D+Kcn+T8H7voA/hkse5hOe5deZwadaY0eZpRzJklmSRbLHr4A7mYE9pCV9I4vgbuZAP9sJP9XwN3MgH92yx5m1d5l05ldZxajhznknFOSS5Lbsoevgbs5gD3kIb3jG+BuTsA/L8n/LXA3F+Cfz7KHebR3eXXm05nb6GF+OReQFJQUsuzhO+BufmAPhUnv+B64WwDwL0Ly/wDcLQj4F7XsYWHtXRGdRXUWMnpYTM7FJSUkJS17+BG4WwzYQynSO34C7hYH/EuT/D8Dd0sA/mUse1hKe1daZxmdJY0elpVzOUl5SQXLHn4B7pYF9lCR9I5fgbvlAP9KJP9vwN3ygH9lyx5W1N5V0llZZwWjh1XkXFVSTVLdsoffgbtVgD3UIL3jD+BuVcC/Jsn/J3C3GuBfy7KHNbR3NXXW0lnd6GFtOdeR1JXUs+zhL+BubWAP9Unv6F6OX+/WAfwbkPz9Af51Af+Glj2sr71roLOhznpGDxvJubGkiaSpZQ/9A3toBOyhGekdAwD+jQH/5iT/gIB/E8C/hWUPm2nvmutsobOp0cOWcm4laS1pY9nDQMAeWgJ7aEt6x8CAfyvAvx3JPwjg3xrwb2/Zw7bau3Y62+tsY/Swg5w7SjpJOlv2MCiwhw7AHrqQ3jEY4N8R8O9K8g8O+HcC/LtZ9rCL9q6rzm46Oxs97C7nHpKekl6WPQwB7KE7sIfepHcMCfj3APz7kPxDAf49Af++lj3srb3ro7Ovzl5GD/vJub9kgGSgZQ9DA3voB+xhEOkdwwD+/QH/wST/sID/AMB/iGUPB2nvBusconOg0cOhch4mGS4ZYdnDcMAehgJ7GEl6x/CA/zDAfxTJPwLgPxzwH23Zw5Hau1E6R+scYfRwjJzHSsZJxlv2MCKwhzHAHiaQ3jES4D8W8J9I8o8M+I8D/CdZ9nCC9m6izkk6xxs9nCznKZKpkmmWPYwC7GEysIfppHeMCvhPAfxnkPyjAf5TAf+Zlj2crr2boXOmzmlGD2fJebZkjmSuZQ+jA3uYBexhHukdYwD+swH/+ST/mID/HMB/gWUP52nv5utcoHOu0cOFcl4kWSxZYtnDWMAeFgJ7WEp6x9iA/yLAfxnJPw7gvxjwX27Zw6Xau2U6l+tcYvRwhZxXSlZJVlv20AXsYQWwhzWkd4wL+K8E/NeS/OMB/qsA/3WWPVyjvVurc53O1UYP18t5g2SjZJNlD+MDe1gP7GEz6R0TAP4bAP8tJP+EgP9GwH+rZQ83a++26Nyqc5PRw21y3i7ZIdlp2cNEwB62AXvYRXrHxID/dsB/N8k/CeC/A/DfY9nDXdq73Tr36Nxp9HCvnPdJ9ksOWPYwKbCHvcAeDpLeMRngvw/wP0TyTw747wf8D1v28KD27pDOwzoPGD08IuejkmOS45Y9TAHs4QiwhxOkd0wJ+B8F/E+S/FMB/scA/1OWPTyhvTup85TO40YPT8v5jOSs5JxlD1MDezgN7OE86R3TAP5nAP8LJH8fwP8s4H/RsofntXcXdF7Uec7o4SU5X5ZckVy17GFaYA+XgD1cI71jOsD/MuB/neSfHvC/AvjfsOzhNe3ddZ03dF41enhTzrcktyV3LHuYAdjDTWAPd0nvmBHwvwX43yP5ZwL8bwP+9y17eFd7d0/nfZ13jB4+kPNDySPJY8seZgb28ADYwxPSO2YB/B8C/k9J/lkB/0eA/zPLHj7R3j3V+UznY6OHz+X8QvJS8sqyh9mAPTwH9vCa9I7ZAf8XgP8bkn8OwP8l4P/WsoevtXdvdL7V+cro4Ts5v5d8kHy07GFOYA/vgD18Ir1jLsD/PeD/meSfG/D/APh/sezhJ+3dZ51fdH40evhVzt8k3yU/LHuYB9jDV2APP0nvmBfw/wb4/yL55wP8vwP+Tjy7Hv7U3v3S6f489/xh9NCf/Jx/SQBJwHi/fya6h/zAHvzF8/seAsXjvGMBwN8/4B+Y5F8Q8A8A+Aex7GEg7V1gnUF0uvvmuRdUzsEkwSUhLHtYCNhDUGAPIUnvWBjwDwb4hyL5FwH8gwP+oS17GFJ7F0pnaJ0hjB6GkXNYSThJeMseFgX2EAbYQwTSOxYD/MMC/hFJ/sUB/3CAfyTLHkbQ3kXUGUlneKOHkeUcRRJVEs2yhyWAPUQG9hCd9I4lAf8ogH8Mkn8pwD8q4B/TsofRtXcxdMbUGc3oYSw5x5bEcbMse1ga2EMsYA9xSe9YBvCPDfjHI/mXBfzjAP7xLXsYV3sXT2d8nS6jhwnknFCSSJLYsoflgD0kAPaQhPSO5QH/hIB/UpJ/BcA/EeCfzLKHSbR3SXUm05nY6GFyOaeQpJSksuxhRWAPyYE9pCa9YyXAPwXgn4bkXxnwTwn4+1j2MLX2Lo1OH52pjB6mlXM6SXpJBsseVgH2kBbYQ0bSO1YF/NMB/plI/tUA//SAf2bLHmbU3mXSmVlnBqOHWeScVZJNkt2yh9WBPWQB9pCD9I41AP+sgH9Okn9NwD8b4J/Lsoc5tHc5debSmd3oYW4555HkleSz7GEtYA+5gT3kJ71jbcA/D+BfgORfB/DPC/gXtOxhfu1dAZ0FdeYzelhIzoUlRSRFLXtYF9hDIWAPxUjvWA/wLwz4Fyf51wf8iwD+JSx7WEx7V1xnCZ1FjR6WlHMpSWlJGcseNgD2UBLYQ1nSOzYE/EsB/uVI/o0A/9KAf3nLHpbV3pXTWV5nGaOHFeRcUVJJUtmyh42BPVQA9lCF9I5NAP+KgH9Vkn9TwL8S4F/NsodVtHdVdVbTWdnoYXU515DUlNSy7GEzYA/VgT3UJr1jc8C/BuBfh+TfAvCvCfjXtexhbe1dHZ11ddYyelhPzvUlDSQNLXvYEthDPWAPjUjv2Arwrw/4Nyb5twb8GwD+TSx72Eh711hnE50NjR42lXMzSXNJC8setgH20BTYQ0vSO7YF/JsB/q1I/u0A/+aAf2vLHrbU3rXS2VpnC6OHbeTcVtJO0t6yh+2BPbQB9tCB9I4dAP+2gH9Hkn9HwL8d4N/JsocdtHcddXbS2d7oYWc5d5F0lXSz7GEnYA+dgT10J71jZ8C/C+Dfg+TfBfDvCvj3tOxhd+1dD509dXYzethLzr0lfSR9LXvYFdhDL2AP/Ujv2A3w7w349yf5dwf8+wD+Ayx72E9711/nAJ19jR4OlPMgyWDJEMse9gD2MBDYw1DSO/YE/AcB/sNI/r0A/8GA/3DLHg7V3g3TOVznEKOHI+Q8UjJKMtqyh72BPYwA9jCG9I59AP+RgP9Ykn9fwH8U4D/OsodjtHdjdY7TOdro4Xg5T5BMlEyy7GE/YA/jgT1MJr1jf8B/AuA/heQ/APCfCPhPtezhZO3dFJ1TdU4yejhNztMlMyQzLXs4ENjDNGAPs0jvOAjwnw74zyb5Dwb8ZwD+cyx7OEt7N1vnHJ0zjR7OlfM8yXzJAsseDgH2MBfYw0LSOw4F/OcB/otI/sMA//mA/2LLHi7U3i3SuVjnAqOHS+S8VLJMstyyh8OBPSwB9rCC9I4jAP+lgP9Kkv9IwH8Z4L/KsocrtHcrda7Sudzo4Wo5r5Gslayz7OEoYA+rgT2sJ73jaMB/DeC/geQ/BvBfC/hvtOzheu3dBp0bda4zerhJzpslWyRbLXs4FtjDJmAP20jvOA7w3wz4byf5jwf8twD+Oyx7uE17t13nDp1bjR7ulPMuyW7JHsseTgD2sBPYw17SO04E/HcB/vtI/pMA/92A/37LHu7V3u3TuV/nHqOHB+R8UHJIctiyh5OBPRwA9nCE9I5TAP+DgP9Rkv9UwP8Q4H/MsodHtHdHdR7Tedjo4XE5n5CclJyy7OE0YA/HgT2cJr3jdMD/BOB/huQ/A/A/Cfiftezhae3dGZ1ndZ4yenhOzuclFyQXLXs4E9jDOWAPl0jvOAvwPw/4Xyb5zwb8LwD+Vyx7eEl7d1nnFZ0XjR5elfM1yXXJDcsezgH2cBXYw03SO84F/K8B/rdI/vMA/+uA/23LHt7U3t3SeVvnDaOHd+R8V3JPct+yh/OBPdwB9vCA9I4LAP+7gP9Dkv9CwP8e4P/IsocPtHcPdT7Sed/o4WM5P5E8lTyz7OEiYA+PgT08J73jYsD/CeD/guS/BPB/Cvi/tOzhc+3dC50vdT4zevhKzq8lbyRvLXu4FNjDK2AP70jvuAzwfw34vyf5Lwf83wD+Hyx7+E57917nB51vjR5+lPMnyWfJF8sergD28BHYw1fSO64E/D8B/t9I/qsA/8+A/3fLHn7V3n3T+V3nF6OHP+T8U/LL3cH4v38muofVwB5+AHvwF5/zjmsA/5+Av3+S/1rA/xfgHyC+XQ/d7+ee/nUG0Onum+deQDkHkgSWBLHs4TpgDwHj+30PQUnvuB7wDwT4ByP5bwD8AwP+wS17GFR7F0xncJ1BjB6GkHNISShJaMsebgT2EALYQxjSO24C/EMC/mFJ/psB/1CAfzjLHobR3oXVGU5naKOH4eUcQRJREsmyh1uAPYQH9hCZ9I5bAf8IgH8Ukv82wD8i4B/VsoeRtXdRdEbVGcnoYTQ5R5fEkMS07OF2YA/RgD3EIr3jDsA/OuAfm+S/E/CPAfjHsexhLO1dbJ1xdMY0euiSc1xJPEl8yx7uAvbgAvaQgPSOuwH/uIB/QpL/HsA/HuCfyLKHCbR3CXUm0hnf6GFiOSeRJJUks+zhXmAPiYE9JCe94z7APwngn4Lkvx/wTwr4p7TsYXLtXQqdKXUmM3qYSs6pJWkkPpY9PADsIRWwh7SkdzwI+KcG/NOR/A8B/mkA//SWPUyrvUunM71OH6OHGeScUZJJktmyh4eBPWQA9pCF9I5HAP+MgH9Wkv9RwD8T4J/NsodZtHdZdWbTmdnoYXY555DklOSy7OExYA/ZgT3kJr3jccA/B+Cfh+R/AvDPCfjntexhbu1dHp15deYyephPzvklBSQFLXt4EthDPmAPhUjveArwzw/4Fyb5nwb8CwD+RSx7WEh7V1hnEZ0FjR4WlXMxSXFJCcsengH2UBTYQ0nSO54F/IsB/qVI/ucA/+KAf2nLHpbU3pXSWVpnCaOHZeRcVlJOUt6yh+eBPZQB9lCB9I4XAP+ygH9Fkv9FwL8c4F/JsocVtHcVdVbSWd7oYWU5V5FUlVSz7OElYA+VgT1UJ73jZcC/CuBfg+R/BfCvCvjXtOxhde1dDZ01dVYzelhLzrUldSR1LXt4FdhDLWAP9UjveA3wrw341yf5Xwf86wD+DSx7WE97V19nA511jR42lHMjSWNJE8se3gD20BDYQ1PSO94E/BsB/s1I/rcA/8aAf3PLHjbV3jXT2VxnE6OHLeTcUtJK0tqyh7eBPbQA9tCG9I53AP+WgH9bkv9dwL8V4N/OsodttHdtdbbT2droYXs5d5B0lHSy7OE9YA/tgT10Jr3jfcC/A+DfheT/APDvCPh3texhZ+1dF51ddXYyethNzt0lPSQ9LXv4ENhDN2APvUjv+Ajw7w749yb5Pwb8ewD+fSx72Et711tnH509jR72lXM/SX/JAMsePgH20BfYw0DSOz4F/PsB/oNI/s8A//6A/2DLHg7U3g3SOVjnAKOHQ+Q8VDJMMtyyh8+BPQwB9jCC9I4vAP+hgP9Ikv9LwH8Y4D/KsocjtHcjdY7SOdzo4Wg5j5GMlYyz7OErYA+jgT2MJ73ja8B/DOA/geT/BvAfC/hPtOzheO3dBJ0TdY4zejhJzpMlUyRTLXv4FtjDJGAP00jv+A7wnwz4Tyf5vwf8pwD+Myx7OE17N13nDJ1TjR7OlPMsyWzJHMsefgD2MBPYw1zSO34E/GcB/vNI/p8A/9mA/3zLHs7V3s3TOV/nHKOHC+S8ULJIstiyh5+BPSwA9rCE9I5fAP+FgP9Skv9XwH8R4L/MsodLtHdLdS7Tudjo4XI5r5CslKyy7OE3YA/LgT2sJr3jd8B/BeC/huT/A/BfCfivtezhau3dGp1rda4yerhOzuslGyQbLXv4E9jDOmAPm0jv+AvwXw/4byb5O/79fncD4L/FsoebtHebdW7RudHo4VY5b5Nsl+yw7KE/YA9bgT3sJL2jf8B/G+C/i+QfAPDfDvjvtuzhTu3dLp27de4werhHznsl+yT7LXsYENjDHmAPB0jvGAjw3wv4HyT5Bwb89wH+hyx7eEB7d1DnIZ37jR4elvMRyVHJMcseBgH2cBjYw3HSOwYF/I8A/idI/sEA/6OA/0nLHh7X3p3QeVLnMaOHp+R8WnJGctayh8GBPZwC9nCO9I4hAP/TgP95kn9IwP8M4H/BsofntHfndV7Qedbo4UU5X5Jcllyx7GEoYA8XgT1cJb1jaMD/EuB/jeQfBvC/DPhft+zhVe3dNZ3XdV4xenhDzjcltyS3LXsYFtjDDWAPd0jvGA7wvwn43yX5hwf8bwH+9yx7eEd7d1fnPZ23jR7el/MDyUPJI8seRgD2cB/Yw2PSO0YE/B8A/k9I/pEA/4eA/1PLHj7W3j3R+VTnI6OHz+T8XPJC8tKyh5GBPTwD9vCK9I5RAP/ngP9rkn9UwP8F4P/GsoevtHevdb7R+dLo4Vs5v5O8l3yw7GE0YA9vgT18JL1jdMD/HeD/ieQfA/B/D/h/tuzhR+3dJ52fdX4wevhFzl8l3yTfLXsYE9jDF2APP0jvGAvw/wr4/yT5xwb8vwH+vyx7+EN791PnL53fjR46CeTnJP4lARL8/pnoHuIAe3BzPXd920PABJx3dAH+/gD/QCT/uIC/f8A/cAK7Hrrfzz0D6Qys0903z70gcg4qCSYJbtnDeMAeggB7CEF6x/iAf1DAPyTJPwHgHwzwD2XZwxDau5A6Q+kMbvQwtJzDSMJKwln2MCGwh9DAHsKT3jER4B8G8I9A8k8M+IcF/CNa9jC89i6Czog6wxk9jCTnyJIokqiWPUwC7CESsIdopHdMCvhHBvyjk/yTAf5RAP8Ylj2Mpr2LrjOGzqhGD2PKOZYktiSOZQ+TA3uICezBRXrHFIB/LMA/Lsk/JeAfG/CPZ9lDl/Yurs54OuMYPYwv5wSShJJElj1MBewhPrCHxKR3TA34JwD8k5D80wD+CQH/pJY9TKy9S6Izqc5ERg+TyTm5JIUkpWUPfYA9JAP2kIr0jmkB/+SAf2qSfzrAPwXgn8ayh6m0d6l1ptGZ0uihj5zTStJJ0lv2MD2wBx9gDxlI75gB8E8L+Gck+WcE/NMB/pkse5hBe5dRZyad6Y0eZpZzFklWSTbLHmYC9pAZ2EN20jtmBvyzAP45SP5ZAP+sgH9Oyx5m197l0JlTZzajh7nknFuSR5LXsodZgT3kAvaQj/SO2QD/3IB/fpJ/dsA/D+BfwLKH+bR3+XUW0JnX6GFBOReSFJYUsexhDmAPBYE9FCW9Y07AvxDgX4zknwvwLwz4F7fsYVHtXTGdxXUWMXpYQs4lJaUkpS17mBvYQwlgD2VI75gH8C8J+Jcl+ecF/EsB/uUse1hGe1dWZzmdpY0elpdzBUlFSSXLHuYD9lAe2ENl0jvmB/wrAP5VSP4FAP+KgH9Vyx5W1t5V0VlVZyWjh9XkXF1SQ1LTsocFgT1UA/ZQi/SOhQD/6oB/bZJ/YcC/BuBfx7KHtbR3tXXW0VnT6GFdOdeT1Jc0sOxhEWAPdYE9NCS9Y1HAvx7g34jkXwzwrw/4N7bsYUPtXSOdjXU2MHrYRM5NJc0kzS17WBzYQxNgDy1I71gC8G8K+Lck+ZcE/JsB/q0se9hCe9dSZyudzY0etpZzG0lbSTvLHpYC9tAa2EN70juWBvzbAP4dSP5lAP+2gH9Hyx6219510NlRZzujh53k3FnSRdLVsodlgT10AvbQjfSO5QD/zoB/d5J/ecC/C+Dfw7KH3bR33XX20NnV6GFPOfeS9Jb0sexhBWAPPYE99CW9Y0XAvxfg34/kXwnw7w3497fsYV/tXT+d/XX2MXo4QM4DJYMkgy17WBnYwwBgD0NI71gF8B8I+A8l+VcF/AcB/sMsezhEezdU5zCdg40eDpfzCMlIySjLHlYD9jAc2MNo0jtWB/xHAP5jSP41AP+RgP9Yyx6O1t6N0TlW5yijh+PkPF4yQTLRsoc1gT2MA/YwifSOtQD/8YD/ZJJ/bcB/AuA/xbKHk7R3k3VO0TnR6OFUOU+TTJfMsOxhHWAPU4E9zCS9Y13AfxrgP4vkXw/wnw74z7bs4Uzt3Syds3XOMHo4R85zJfMk8y17WB/YwxxgDwtI79gA8J8L+C8k+TcE/OcB/osse7hAe7dQ5yKd840eLpbzEslSyTLLHjYC9rAY2MNy0js2BvyXAP4rSP5NAP+lgP9Kyx4u196t0LlS5zKjh6vkvFqyRrLWsodNgT2sAvawjvSOzQD/1YD/epJ/c8B/DeC/wbKH67R363Vu0LnW6OFGOW+SbJZssexhC2APG4E9bCW9Y0vAfxPgv43k3wrw3wz4b7fs4Vbt3Tad23VuMXq4Q847Jbskuy172BrYww5gD3tI79gG8N8J+O8l+bcF/HcB/vsse7hHe7dX5z6du40e7pfzAclBySHLHrYD9rAf2MNh0ju2B/wPAP5HSP4dAP+DgP9Ryx4e1t4d0XlU5yGjh8fkfFxyQnLSsocdgT0cA/ZwivSOnQD/44D/aZJ/Z8D/BOB/xrKHp7R3p3We0XnS6OFZOZ+TnJdcsOxhF2APZ4E9XCS9Y1fA/xzgf4nk3w3wPw/4X7bs4UXt3SWdl3VeMHp4Rc5XJdck1y172B3YwxVgDzdI79gD8L8K+N8k+fcE/K8B/rcse3hDe3dT5y2d140e3pbzHcldyT3LHvYC9nAb2MN90jv2BvzvAP4PSP59AP+7gP9Dyx7e19490PlQ5z2jh4/k/FjyRPLUsod9gT08AvbwjPSO/QD/x4D/c5J/f8D/CeD/wrKHz7R3z3W+0PnU6OFLOb+SvJa8sezhAGAPL4E9vCW940DA/xXg/47kPwjwfw34v7fs4Vvt3Tud73W+MXr4Qc4fJZ8kny17OBjYwwdgD19I7zgE8P8I+H8l+Q8F/D8B/t8se/hFe/dV5zedn40efpfzD8lPyS/LHg4D9vAd2IOTkPOOwwH/H4C/P5L/CMD/J+DvP6FdD93v557+dPrX+cvoYQD5uYCSQJLACX//THQPI4E9BEjo9z0EIb3jKMA/IOAflOQ/GvAPBPgHs+xhEO1dUJ3BdLr75rkXXM4hJCEloSx7OAbYQ3BgD6FJ7zgW8A8B+Ich+Y8D/EMC/mEtexhaexdGZ1idoYwehpNzeEkESUTLHo4H9hAO2EMk0jtOAPzDA/6RSf4TAf8IgH8Uyx5G0t5F1hlFZ0Sjh1HlHE0SXRLDsoeTgD1EBfYQk/SOkwH/aIB/LJL/FMA/OuAf27KHMbV3sXTG1hnD6GEcN0MSVxLPsodTgT3EAfYQn/SO0wB/F+CfgOQ/HfCPC/gntOxhfO1dAp0JdcYzephIzoklSSRJLXs4A9hDImAPyUjvOBPwTwz4Jyf5zwL8kwD+KSx7mEx7l1xnCp1JjR6mlHMqSWpJGssezgb2kBLYgw/pHecA/qkA/7Qk/7mAf2rAP51lD320d2l1ptOZxuhhejlnkGSUZLLs4TxgD+mBPWQmveN8wD8D4J+F5L8A8M8I+Ge17GFm7V0WnVl1ZjJ6mE3O2SU5JDkte7gQ2EM2YA+5SO+4CPDPDvjnJvkvBvxzAP55LHuYS3uXW2cenTmNHuaVcz5JfkkByx4uAfaQF9hDQdI7LgX88wH+hUj+ywD//IB/YcseFtTeFdJZWGcBo4dF5FxUUkxS3LKHy4E9FAH2UIL0jisA/6KAf0mS/0rAvxjgX8qyhyW0dyV1ltJZ3OhhaTmXkZSVlLPs4SpgD6WBPZQnveNqwL8M4F+B5L8G8C8L+Fe07GF57V0FnRV1ljN6WEnOlSVVJFUte7gW2EMlYA/VSO+4DvCvDPhXJ/mvB/yrAP41LHtYTXtXXWcNnVWNHtaUcy1JbUkdyx5uAPZQE9hDXdI7bgT8awH+9Uj+mwD/2oB/fcse1tXe1dNZX2cdo4cN5NxQ0kjS2LKHm4E9NAD20IT0jlsA/4aAf1OS/1bAvxHg38yyh020d011NtPZ2Ohhczm3kLSUtLLs4TZgD82BPbQmveN2wL8F4N+G5L8D8G8J+Le17GFr7V0bnW11tjJ62E7O7SUdJB0te7gT2EM7YA+dSO+4C/BvD/h3JvnvBvw7AP5dLHvYSXvXWWcXnR2NHnaVczdJd0kPyx7uAfbQFdhDT9I77gX8uwH+vUj++wD/7oB/b8se9tTe9dLZW2cPo4d95NxX0k/S37KH+4E99AH2MID0jgcA/76A/0CS/0HAvx/gP8iyhwO0dwN1DtLZ3+jhYDkPkQyVDLPs4SFgD4OBPQwnveNhwH8I4D+C5H8E8B8K+I+07OFw7d0InSN1DjN6OErOoyVjJGMte3gU2MMoYA/jSO94DPAfDfiPJ/kfB/zHAP4TLHs4Tns3XucEnWONHk6U8yTJZMkUyx6eAPYwEdjDVNI7ngT8JwH+00j+pwD/yYD/dMseTtXeTdM5XecUo4cz5DxTMksy27KHp4E9zAD2MIf0jmcA/5mA/1yS/1nAfxbgP8+yh3O0d3N1ztM52+jhfDkvkCyULLLs4TlgD/OBPSwmveN5wH8B4L+E5H8B8F8I+C+17OFi7d0SnUt1LjJ6uEzOyyUrJCste3gR2MMyYA+rSO94CfBfDvivJvlfBvxXAP5rLHu4Snu3WucanSuNHq6V8zrJeskGyx5eAfawFtjDRtI7XgX81wH+m0j+1wD/9YD/ZssebtTebdK5WecGo4db5LxVsk2y3bKH14E9bAH2sIP0jjcA/62A/06S/03Afxvgv8uyhzu0dzt17tK53ejhbjnvkeyV7LPs4S1gD7uBPewnveNtwH8P4H+A5H8H8N8L+B+07OF+7d0BnQd17jN6eEjOhyVHJEcte3gX2MMhYA/HSO94D/A/DPgfJ/nfB/yPAP4nLHt4THt3XOcJnUeNHp6U8ynJackZyx4+APZwEtjDWdI7PgT8TwH+50j+jwD/04D/ecsentXendN5XucZo4cX5HxRckly2bKHj4E9XAD2cIX0jk8A/4uA/1WS/1PA/xLgf82yh1e0d1d1XtN52ejhdTnfkNyU3LLs4TNgD9eBPdwmveNzwP8G4H+H5P8C8L8J+N+17OFt7d0dnXd13jJ6eE/O9yUPJA8te/gS2MM9YA+PSO/4CvC/D/g/Jvm/BvwfAP5PLHv4SHv3WOcTnQ+NHj6V8zPJc8kLyx6+AfbwFNjDS9I7vgX8nwH+r0j+7wD/54D/a8sevtTevdL5WucLo4dv5PxW8k7y3rKH74E9vAH28IH0jh8A/7eA/0eS/0fA/x3g/8myhx+0dx91ftL53ujhZzl/kXyVfLPs4SdgD5+BPXwnveNnwP8L4P+D5P8F8P8K+P+07OF37d0PnT91fjN6+MvdvUTy8xL/iX7/THQPX4E9/AL2ECAR5x2/Af5OIr/7ByT5fwf8/QH+gRLZ9dD9fu4ZUGcgne6+ee4FlnMQSVBJMMse/gD2EBjYQ3DSO/4E/IMA/iFI/r8A/6CAf0jLHgbX3oXQGVJnMKOHoeQcWhJGEtayh+4/wK93QwF7CEd6R3+Af2jAPzzJ3z/gHwbwj2DZw3Dau/A6I+gMa/QwopwjSSJLolj2MACwh4jAHqKS3jEg4B8J8I9G8g8E+EcG/KNb9jCq9i6azug6oxg9jCHnmJJYktiWPQwM7CEGsIc4pHcMAvjHBPxdJP+ggH8swD+uZQ/jaO9cOuPqjG30MJ6c40sSSBJa9jAYsId4wB4Skd4xOOAfH/BPTPIPAfgnAPyTWPYwkfYusc4kOhMaPUwq52SS5JIUlj0MCewhKbCHlKR3DAX4JwP8U5H8QwP+yQH/1JY9TKm9S6Uztc4URg/TyNlHklaSzrKHYYA9pAH2kJ70jmEBfx/APwPJPxzgnxbwz2jZw/Tauww6M+pMZ/Qwk5wzS7JIslr2MDywh0zAHrKR3jEC4J8Z8M9O8o8I+GcB/HNY9jCb9i67zhw6sxo9zCnnXJLckjyWPYwE7CEnsIe8pHeMDPjnAvzzkfyjAP65Af/8lj3Mq73LpzO/zjxGDwvIuaCkkKSwZQ+jAnsoAOyhCOkdowH+BQH/oiT/6IB/IcC/mGUPi2jviuosprOw0cPici4hKSkpZdnDGMAeigN7KE16x5iAfwnAvwzJPxbgXxLwL2vZw9LauzI6y+osZfSwnJzLSypIKlr2MDawh3LAHiqR3jEO4F8e8K9M8ncB/hUA/yqWPaykvauss4rOikYPq8q5mqS6pIZlD+MCe6gK7KEm6R3jAf7VAP9aJP/4gH91wL+2ZQ9rau9q6ayts4bRwzpyriupJ6lv2cMEwB7qAHtoQHrHhIB/XcC/Ick/EeBfD/BvZNnDBtq7hjob6axv9LCxnJtImkqaWfYwMbCHxsAempPeMQng3wTwb0HyTwr4NwX8W1r2sLn2roXOljqbGT1sJefWkjaStpY9TAbsoRWwh3akd0wO+LcG/NuT/FMA/m0A/w6WPWynvWuvs4POtkYPO8q5k6SzpItlD1MCe+gI7KEr6R1TAf6dAP9uJP/UgH9nwL+7ZQ+7au+66eyus4vRwx5y7inpJelt2cM0wB56AHvoQ3pHH8C/J+Dfl+SfFvDvBfj3s+xhH+1dX539dPY2ethfzgMkAyWDLHuYDthDf2APg0nvmB7wHwD4DyH5ZwD8BwL+Qy17OFh7N0TnUJ2DjB4Ok/NwyQjJSMseZgT2MAzYwyjSO2YC/IcD/qNJ/pkB/xGA/xjLHo7S3o3WOUbnSKOHY+U8TjJeMsGyh1mAPYwF9jCR9I5ZAf9xgP8kkn82wH884D/ZsocTtXeTdE7WOcHo4RQ5T5VMk0y37GF2YA9TgD3MIL1jDsB/KuA/k+SfE/CfBvjPsuzhDO3dTJ2zdE43ejhbznMkcyXzLHuYC9jDbGAP80nvmBvwnwP4LyD55wH85wL+Cy17OF97t0DnQp3zjB4ukvNiyRLJUsse5gX2sAjYwzLSO+YD/BcD/stJ/vkB/yWA/wrLHi7T3i3XuULnUqOHK+W8SrJassayhwWAPawE9rCW9I4FAf9VgP86kn8hwH814L/esodrtXfrdK7Xucbo4QY5b5Rskmy27GFhYA8bgD1sIb1jEcB/I+C/leRfFPDfBPhvs+zhFu3dVp3bdG42erhdzjskOyW7LHtYDNjDdmAPu0nvWBzw3wH47yH5lwD8dwL+ey17uFt7t0fnXp27jB7uk/N+yQHJQcselgT2sA/YwyHSO5YC/PcD/odJ/qUB/wOA/xHLHh7S3h3WeUTnQaOHR+V8THJccsKyh2WAPRwF9nCS9I5lAf9jgP8pkn85wP844H/asocntXendJ7WecLo4Rk5n5Wck5y37GF5YA9ngD1cIL1jBcD/LOB/keRfEfA/B/hfsuzhBe3dRZ2XdJ43enhZzlckVyXXLHtYCdjDZWAP10nvWBnwvwL43yD5VwH8rwL+Ny17eF17d0PnTZ3XjB7ekvNtyR3JXcseVgX2cAvYwz3SO1YD/G8D/vdJ/tUB/zuA/wPLHt7T3t3X+UDnXaOHD+X8SPJY8sSyhzWAPTwE9vCU9I41Af9HgP8zkn8twP8x4P/csodPtXfPdD7X+cTo4Qs5v5S8kry27GFtYA8vgD28Ib1jHcD/JeD/luRfF/B/Bfi/s+zhG+3dW53vdL42evhezh8kHyWfLHtYD9jDe2APn0nvWB/w/wD4fyH5NwD8PwL+Xy17+Fl790XnV52fjB5+k/N3yQ/JT8seNgT28A3Ywy/SOzYC/L8D/k5ijn9jwP8H4O8vsV0Pf2nv3Hvwp5/nnj+NHvqXnwsgCSgJlPj3z0T30ATYg//Eft9DYNI7NgX8AwD+QUj+zQD/gIB/UMseBtbeBdEZVKe7b557weQcXBJCEtKyh82BPQQD9hCK9I4tAP/ggH9okn9LwD8E4B/GsoehtHehdYbRGdLoYVg5h5OEl0Sw7GErYA9hgT1EJL1ja8A/HOAfieTfBvAPD/hHtuxhRO1dJJ2RdUYwehhFzlEl0STRLXvYFthDFGAPMUjv2A7wjwr4xyT5twf8owH+sSx7GEN7F1NnLJ3RjR7GlnMcN0cS17KHHYA9xAb2EI/0jh0B/ziAf3ySfyfA3wX4J7DsYTztXXydCXTGNXqYUM6JJIklSSx72BnYQ0JgD0lJ79gF8E8E+Ccj+XcF/BMD/skte5hUe5dMZ3KdSYweppBzSkkqSWrLHnYD9pAC2EMa0jt2B/xTAv4+JP8egH8qwD+tZQ/TaO98dKbVmdroYTo5p5dkkGS07GFPYA/pgD1kIr1jL8A/PeCfmeTfG/DPAPhnsexhJu1dZp1ZdGY0ephVztkk2SU5LHvYB9hDVmAPOUnv2Bfwzwb45yL59wP8swP+uS17mFN7l0tnbp05jB7mkXNeST5Jfsse9gf2kAfYQwHSOw4A/PMC/gVJ/gMB/3yAfyHLHhbQ3hXUWUhnfqOHheVcRFJUUsyyh4OAPRQG9lCc9I6DAf8igH8Jkv8QwL8o4F/SsofFtXcldJbUWczoYSk5l5aUkZS17OFQYA+lgD2UI73jMMC/NOBfnuQ/HPAvA/hXsOxhOe1deZ0VdJY1elhRzpUklSVVLHs4AthDRWAPVUnvOBLwrwT4VyP5jwL8KwP+1S17WFV7V01ndZ1VjB7WkHNNSS1Jbcsejgb2UAPYQx3SO44B/GsC/nVJ/mMB/1qAfz3LHtbR3tXVWU9nbaOH9eXcQNJQ0siyh+OAPdQH9tCY9I7jAf8GgH8Tkv8EwL8h4N/UsoeNtXdNdDbV2cjoYTM5N5e0kLS07OFEYA/NgD20Ir3jJMC/OeDfmuQ/GfBvAfi3sexhK+1da51tdLY0ethWzu0k7SUdLHs4BdhDW2APHUnvOBXwbwf4dyL5TwP82wP+nS172FF710lnZ50djB52kXNXSTdJd8seTgf20AXYQw/SO84A/LsC/j1J/jMB/26Afy/LHvbQ3vXU2Utnd6OHveXcR9JX0s+yh7OAPfQG9tCf9I6zAf8+gP8Akv8cwL8v4D/Qsof9tXcDdA7U2c/o4SA5D5YMkQy17OFcYA+DgD0MI73jPMB/MOA/nOQ/H/AfAviPsOzhMO3dcJ0jdA41ejhSzqMkoyVjLHu4ANjDSGAPY0nvuBDwHwX4jyP5LwL8RwP+4y17OFZ7N07neJ1jjB5OkPNEySTJZMseLgb2MAHYwxTSOy4B/CcC/lNJ/ksB/0mA/zTLHk7R3k3VOU3nZKOH0+U8QzJTMsuyh8uAPUwH9jCb9I7LAf8ZgP8ckv8KwH8m4D/XsoeztXdzdM7VOcvo4Tw5z5cskCy07OFKYA/zgD0sIr3jKsB/PuC/mOS/GvBfAPgvsezhIu3dYp1LdC40erhUzsskyyUrLHu4BtjDUmAPK0nvuBbwXwb4ryL5rwP8lwP+qy17uFJ7t0rnap0rjB6ukfNayTrJessergf2sAbYwwbSO24A/NcC/htJ/hsB/3WA/ybLHm7Q3m3UuUnneqOHm+W8RbJVss2yh5uAPWwG9rCd9I6bAf8tgP8Okv8WwH8r4L/TsofbtXc7dO7Uuc3o4S4575bskey17OFWYA+7gD3sI73jNsB/N+C/n+S/HfDfA/gfsOzhPu3dfp0HdO41enhQzockhyVHLHu4A9jDQWAPR0nvuBPwPwT4HyP57wL8DwP+xy17eFR7d0zncZ1HjB6ekPNJySnJacse7gb2cALYwxnSO+4B/E8C/mdJ/nsB/1OA/znLHp7R3p3VeU7naaOH5+V8QXJRcsmyh/uAPZwH9nCZ9I77Af8LgP8Vkv8BwP8i4H/VsoeXtXdXdF7Vecno4TU5X5fckNy07OFBYA/XgD3cIr3jIcD/OuB/m+R/GPC/AfjfsezhLe3dbZ13dN40enhXzvck9yUPLHt4BNjDXWAPD0nveBTwvwf4PyL5HwP87wP+jy17+FB790jnY50PjB4+kfNTyTPJc8seHgf28ATYwwvSO54A/J8C/i9J/icB/2eA/yvLHr7Q3r3U+Urnc6OHr+X8RvJW8s6yh6eAPbwG9vCe9I6nAf83gP8Hkv8ZwP8t4P/RsofvtXcfdH7U+c7o4Sc5f5Z8kXy17OFZYA+fgD18I73jOcD/M+D/neR/HvD/Avj/sOzhN+3dd50/dH41evhTzr/c/Usi/1mS3z8T3cMFYA8/gT34T8J5x4uA/y/APwDJ/xLg7yTxu3/AJHY9dL+fewbQGVCnu2+ee4HkHFgSRBLUsoeXgT0EAvYQjPSOVwD/wIB/cJL/VcA/COAfwrKHwbR3wXWG0BnU6GFIOYeShJaEsezhNWAPIYE9hCW943XAPxTgH47kfwPwDw34h7fsYVjtXTid4XWGMXoYQc4RJZEkkS17eBPYQwRgD1FI73gL8I8I+Ecl+d8G/CMB/tEsexhFexdVZzSdkY0eRpdzDElMSSzLHt4B9hAd2ENs0jveBfxjAP5xSP73AP+YgL/LsoextXdxdLp0xjJ6GFfO8STxJQkse3gf2ENcYA8JSe/4APCPB/gnIvk/BPzjA/6JLXuYUHuXSGdinQmMHiaRc1JJMklyyx4+AvaQBNhDCtI7Pgb8kwL+KUn+TwD/ZIB/KsseptDepdSZSmdyo4ep5ZxG4iNJa9nDp8AeUgN7SEd6x2eAfxrAPz3J/zng7wP4Z7DsYTrtXXqdGXSmNXqYUc6ZJJklWSx7+ALYQ0ZgD1lJ7/gS8M8E+Gcj+b8C/DMD/tkte5hVe5dNZ3adWYwe5pBzTkkuSW7LHr4G9pAD2EMe0ju+AfxzAv55Sf5vAf9cgH8+yx7m0d7l1ZlPZ26jh/nlXEBSUFLIsofvgD3kB/ZQmPSO7wH/AoB/EZL/B8C/IOBf1LKHhbV3RXQW1VnI6GExOReXlJCUtOzhR2APxYA9lCK94yfAvzjgX5rk/xnwLwH4l7HsYSntXWmdZXSWNHpYVs7lJOUlFSx7+AXYQ1lgDxVJ7/gV8C8H+Fci+X8D/MsD/pUte1hRe1dJZ2WdFYweVpFzVUk1SXXLHn4H9lAF2EMN0jv+APyrAv41Sf4/Af9qgH8tyx7W0N7V1FlLZ3Wjh7XlXEdSV1LPsoe/gD3UBvZQn/SO7qX49W4dwL8Byd8f4F8X8G9o2cP62rsGOhvqrGf0sJGcG0uaSJpa9tA/sIdGwB6akd4xAODfGPBvTvIPCPg3AfxbWPawmfauuc4WOpsaPWwp51aS1pI2lj0MBOyhJbCHtqR3DAz4twL825H8gwD+rQH/9pY9bKu9a6ezvc42Rg87yLmjpJOks2UPgwJ76ADsoQvpHYMB/h0B/64k/+CAfyfAv5tlD7to77rq7Kazs9HD7nLuIekp6WXZwxDAHroDe+hNeseQgH8PwL8PyT8U4N8T8O9r2cPe2rs+Ovvq7GX0sJ+c+0sGSAZa9jA0sId+wB4Gkd4xDODfH/AfTPIPC/gPAPyHWPZwkPZusM4hOgcaPRwq52GS4ZIRlj0MB+xhKLCHkaR3DA/4DwP8R5H8IwD+wwH/0ZY9HKm9G6VztM4RRg/HyHmsZJxkvGUPIwJ7GAPsYQLpHSMB/mMB/4kk/8iA/zjAf5JlDydo7ybqnKRzvNHDyXKeIpkqmWbZwyjAHiYDe5hOeseogP8UwH8GyT8a4D8V8J9p2cPp2rsZOmfqnGb0cJacZ0vmSOZa9jA6sIdZwB7mkd4xBuA/G/CfT/KPCfjPAfwXWPZwnvZuvs4FOucaPVwo50WSxZIllj2MBexhIbCHpaR3jA34LwL8l5H84wD+iwH/5ZY9XKq9W6Zzuc4lRg9XyHmlZJVktWUPXcAeVgB7WEN6x7iA/0rAfy3JPx7gvwrwX2fZwzXau7U61+lcbfRwvZw3SDZKNln2MD6wh/XAHjaT3jEB4L8B8N9C8k8I+G8E/Lda9nCz9m6Lzq06Nxk93Cbn7ZIdkp2WPUwE7GEbsIddpHdMDPhvB/x3k/yTAP47AP89lj3cpb3brXOPzp1GD/fKeZ9kv+SAZQ+TAnvYC+zhIOkdkwH++wD/QyT/5ID/fsD/sGUPD2rvDuk8rPOA0cMjcj4qOSY5btnDFMAejgB7OEF6x5SA/1HA/yTJPxXgfwzwP2XZwxPau5M6T+k8bvTwtJzPSM5Kzln2MDWwh9PAHs6T3jEN4H8G8L9A8vcB/M8C/hcte3hee3dB50Wd54weXpLzZckVyVXLHqYF9nAJ2MM10jumA/wvA/7XSf7pAf8rgP8Nyx5e095d13lD51WjhzflfEtyW3LHsocZgD3cBPZwl/SOGQH/W4D/PZJ/JsD/NuB/37KHd7V393Te13nH6OEDOT+UPJI8tuxhZmAPD4A9PCG9YxbA/yHg/5TknxXwfwT4P7Ps4RPt3VOdz3Q+Nnr4XM4vJC8lryx7mA3Yw3NgD69J75gd8H8B+L8h+ecA/F8C/m8te/hae/dG51udr4wevpPze8kHyUfLHuYE9vAO2MMn0jvmAvzfA/6fSf65Af8PgP8Xyx5+0t591vlF50ejh1/l/E3yXfLDsod5gD18Bfbwk/SOeQH/b4D/L5J/PsD/O+DvJLXr4U/t3S+d7s9zzx9GD/3Jz/mXBJAETPr7Z6J7yA/swV9Sv+8hUFLOOxYA/P0D/oFJ/gUB/wCAfxDLHgbS3gXWGUSnu2+ee0HlHEwSXBLCsoeFgD0EBfYQkvSOhQH/YIB/KJJ/EcA/OOAf2rKHIbV3oXSG1hnC6GEYOYeVhJOEt+xhUWAPYYA9RCC9YzHAPyzgH5HkXxzwDwf4R7LsYQTtXUSdkXSGN3oYWc5RJFEl0Sx7WALYQ2RgD9FJ71gS8I8C+Mcg+ZcC/KMC/jEtexhdexdDZ0yd0YwexpJzbEkcN8uyh6WBPcQC9hCX9I5lAP/YgH88kn9ZwD8O4B/fsodxtXfxdMbX6TJ6mEDOCSWJJIkte1gO2EMCYA9JSO9YHvBPCPgnJflXAPwTAf7JLHuYRHuXVGcynYmNHiaXcwpJSkkqyx5WBPaQHNhDatI7VgL8UwD+aUj+lQH/lIC/j2UPU2vv0uj00ZnK6GFaOaeTpJdksOxhFWAPaYE9ZCS9Y1XAPx3gn4nkXw3wTw/4Z7bsYUbtXSadmXVmMHqYRc5ZJdkk2S17WB3YQxZgDzlI71gD8M8K+Ock+dcE/LMB/rkse5hDe5dTZy6d2Y0e5pZzHkleST7LHtYC9pAb2EN+0jvWBvzzAP4FSP51AP+8gH9Byx7m194V0FlQZz6jh4XkXFhSRFLUsod1gT0UAvZQjPSO9QD/woB/cZJ/fcC/COBfwrKHxbR3xXWW0FnU6GFJOZeSlJaUsexhA2APJYE9lCW9Y0PAvxTgX47k3wjwLw34l7fsYVntXTmd5XWWMXpYQc4VJZUklS172BjYQwVgD1VI79gE8K8I+Fcl+TcF/CsB/tUse1hFe1dVZzWdlY0eVpdzDUlNSS3LHjYD9lAd2ENt0js2B/xrAP51SP4tAP+agH9dyx7W1t7V0VlXZy2jh/XkXF/SQNLQsoctgT3UA/bQiPSOrQD/+oB/Y5J/a8C/AeDfxLKHjbR3jXU20dnQ6GFTOTeTNJe0sOxhG2APTYE9tCS9Y1vAvxng34rk3w7wbw74t7bsYUvtXSudrXW2MHrYRs5tJe0k7S172B7YQxtgDx1I79gB8G8L+Hck+XcE/NsB/p0se9hBe9dRZyed7Y0edpZzF0lXSTfLHnYC9tAZ2EN30jt2Bvy7AP49SP5dAP+ugH9Pyx5219710NlTZzejh73k3FvSR9LXsoddgT30AvbQj/SO3QD/3oB/f5J/d8C/D+A/wLKH/bR3/XUO0NnX6OFAOQ+SDJYMsexhD2APA4E9DCW9Y0/AfxDgP4zk3wvwHwz4D7fs4VDt3TCdw3UOMXo4Qs4jJaMkoy172BvYwwhgD2NI79gH8B8J+I8l+fcF/EcB/uMsezhGezdW5zido40ejpfzBMlEySTLHvYD9jAe2MNk0jv2B/wnAP5TSP4DAP+JgP9Uyx5O1t5N0TlV5ySjh9PkPF0yQzLTsocDgT1MA/Ywi/SOgwD/6YD/bJL/YMB/BuA/x7KHs7R3s3XO0TnT6OFcOc+TzJcssOzhEGAPc4E9LCS941DAfx7gv4jkPwzwnw/4L7bs4ULt3SKdi3UuMHq4RM5LJcskyy17OBzYwxJgDytI7zgC8F8K+K8k+Y8E/JcB/qsse7hCe7dS5yqdy40erpbzGslayTrLHo4C9rAa2MN60juOBvzXAP4bSP5jAP+1gP9Gyx6u195t0LlR5zqjh5vkvFmyRbLVsodjgT1sAvawjfSO4wD/zYD/dpL/eMB/C+C/w7KH27R323Xu0LnV6OFOOe+S7JbssezhBGAPO4E97CW940TAfxfgv4/kPwnw3w3477fs4V7t3T6d+3XuMXp4QM4HJYckhy17OBnYwwFgD0dI7zgF8D8I+B8l+U8F/A8B/scse3hEe3dU5zGdh40eHpfzCclJySnLHk4D9nAc2MNp0jtOB/xPAP5nSP4zAP+TgP9Zyx6e1t6d0XlW5ymjh+fkfF5yQXLRsoczgT2cA/ZwifSOswD/84D/ZZL/bMD/AuB/xbKHl7R3l3Ve0XnR6OFVOV+TXJfcsOzhHGAPV4E93CS941zA/xrgf4vkPw/wvw7437bs4U3t3S2dt3XeMHp4R853Jfck9y17OB/Ywx1gDw9I77gA8L8L+D8k+S8E/O8B/o8se/hAe/dQ5yOd940ePpbzE8lTyTPLHi4C9vAY2MNz0jsuBvyfAP4vSP5LAP+ngP9Lyx4+19690PlS5zOjh6/k/FryRvLWsodLgT28AvbwjvSOywD/14D/e5L/csD/DeD/wbKH77R373V+0PnW6OFHOX+SfJZ8sezhCmAPH4E9fCW940rA/xPg/43kvwrw/wz4f7fs4Vft3Ted33V+MXr4Q84/Jb/cHUz2+2eie1gN7OEHsAd/yTjvuAbw/wn4+yf5rwX8fwH+AZLZ9dD9fu7pX2cAne6+ee4FlHMgSWBJEMsergP2EDCZ3/cQlPSO6wH/QIB/MJL/BsA/MOAf3LKHQbV3wXQG1xnE6GEIOYeUhJKEtuzhRmAPIYA9hCG94ybAPyTgH5bkvxnwDwX4h7PsYRjtXVid4XSGNnoYXs4RJBElkSx7uAXYQ3hgD5FJ77gV8I8A+Ech+W8D/CMC/lEtexhZexdFZ1SdkYweRpNzdEkMSUzLHm4H9hAN2EMs0jvuAPyjA/6xSf47Af8YgH8cyx7G0t7F1hlHZ0yjhy45x5XEk8S37OEuYA8uYA8JSO+4G/CPC/gnJPnvAfzjAf6JLHuYQHuXUGcinfGNHiaWcxJJUkkyyx7uBfaQGNhDctI77gP8kwD+KUj++wH/pIB/SsseJtfepdCZUmcyo4ep5JxakkbiY9nDA8AeUgF7SEt6x4OAf2rAPx3J/xDgnwbwT2/Zw7Tau3Q60+v0MXqYQc4ZJZkkmS17eBjYQwZgD1lI73gE8M8I+Gcl+R8F/DMB/tkse5hFe5dVZzadmY0eZpdzDklOSS7LHh4D9pAd2ENu0jseB/xzAP55SP4nAP+cgH9eyx7m1t7l0ZlXZy6jh/nknF9SQFLQsocngT3kA/ZQiPSOpwD//IB/YZL/acC/AOBfxLKHhbR3hXUW0VnQ6GFROReTFJeUsOzhGWAPRYE9lCS941nAvxjgX4rkfw7wLw74l7bsYUntXSmdpXWWMHpYRs5lJeUk5S17eB7YQxlgDxVI73gB8C8L+Fck+V8E/MsB/pUse1hBe1dRZyWd5Y0eVpZzFUlVSTXLHl4C9lAZ2EN10jteBvyrAP41SP5XAP+qgH9Nyx5W197V0FlTZzWjh7XkXFtSR1LXsodXgT3UAvZQj/SO1wD/2oB/fZL/dcC/DuDfwLKH9bR39XU20FnX6GFDOTeSNJY0sezhDWAPDYE9NCW9403AvxHg34zkfwvwbwz4N7fsYVPtXTOdzXU2MXrYQs4tJa0krS17eBvYQwtgD21I73gH8G8J+Lcl+d8F/FsB/u0se9hGe9dWZzudrY0etpdzB0lHSSfLHt4D9tAe2ENn0jveB/w7AP5dSP4PAP+OgH9Xyx521t510dlVZyejh93k3F3SQ9LTsocPgT10A/bQi/SOjwD/7oB/b5L/Y8C/B+Dfx7KHvbR3vXX20dnT6GFfOfeT9JcMsOzhE2APfYE9DCS941PAvx/gP4jk/wzw7w/4D7bs4UDt3SCdg3UOMHo4RM5DJcMkwy17+BzYwxBgDyNI7/gC8B8K+I8k+b8E/IcB/qMsezhCezdS5yidw40ejpbzGMlYyTjLHr4C9jAa2MN40ju+BvzHAP4TSP5vAP+xgP9Eyx6O195N0DlR5zijh5PkPFkyRTLVsodvgT1MAvYwjfSO7wD/yYD/dJL/e8B/CuA/w7KH07R303XO0DnV6OFMOc+SzJbMsezhB2APM4E9zCW940fAfxbgP4/k/wnwnw34z7fs4Vzt3Tyd83XOMXq4QM4LJYskiy17+BnYwwJgD0tI7/gF8F8I+C8l+X8F/BcB/ssse7hEe7dU5zKdi40eLpfzCslKySrLHn4D9rAc2MNq0jt+B/xXAP5rSP4/AP+VgP9ayx6u1t6t0blW5yqjh+vkvF6yQbLRsoc/gT2sA/awifSOvwD/9YD/ZpK/E8jvdzcA/lsse7hJe7dZ5xadG40ebpXzNsl2yQ7LHvoD9rAV2MNO0jv6B/y3Af67SP4BAP/tgP9uyx7u1N7t0rlb5w6jh3vkvFeyT7LfsocBgT3sAfZwgPSOgQD/vYD/QZJ/YMB/H+B/yLKHB7R3B3Ue0rnf6OFhOR+RHJUcs+xhEGAPh4E9HCe9Y1DA/wjgf4LkHwzwPwr4n7Ts4XHt3QmdJ3UeM3p4Ss6nJWckZy17GBzYwylgD+dI7xgC8D8N+J8n+YcE/M8A/hcse3hOe3de5wWdZ40eXpTzJcllyRXLHoYC9nAR2MNV0juGBvwvAf7XSP5hAP/LgP91yx5e1d5d03ld5xWjhzfkfFNyS3LbsodhgT3cAPZwh/SO4QD/m4D/XZJ/eMD/FuB/z7KHd7R3d3Xe03nb6OF9OT+QPJQ8suxhBGAP94E9PCa9Y0TA/wHg/4TkHwnwfwj4P7Xs4WPt3ROdT3U+Mnr4TM7PJS8kLy17GBnYwzNgD69I7xgF8H8O+L8m+UcF/F8A/m8se/hKe/da5xudL40evpXzO8l7yQfLHkYD9vAW2MNH0jtGB/zfAf6fSP4xAP/3gP9nyx5+1N590vlZ5wejh1/k/FXyTfLdsocxgT18Afbwg/SOsQD/r4D/T5J/bMD/G+D/y7KHP7R3P3X+0vnd6KGTXH5O4l8SIPnvn4nuIQ6wBzfXc9e3PQRMznlHF+DvD/APRPKPC/j7B/wDJ7frofv93DOQzsA63X3z3Asi56CSYJLglj2MB+whCLCHEKR3jA/4BwX8Q5L8EwD+wQD/UJY9DKG9C6kzlM7gRg9DyzmMJKwknGUPEwJ7CA3sITzpHRMB/mEA/wgk/8SAf1jAP6JlD8Nr7yLojKgznNHDSHKOLIkiiWrZwyTAHiIBe4hGesekgH9kwD86yT8Z4B8F8I9h2cNo2rvoOmPojGr0MKacY0liS+JY9jA5sIeYwB5cpHdMAfjHAvzjkvxTAv6xAf94lj10ae/i6oynM47Rw/hyTiBJKElk2cNUwB7iA3tITHrH1IB/AsA/Cck/DeCfEPBPatnDxNq7JDqT6kxk9DCZnJNLUkhSWvbQB9hDMmAPqUjvmBbwTw74pyb5pwP8UwD+aSx7mEp7l1pnGp0pjR76yDmtJJ0kvWUP0wN78AH2kIH0jhkA/7SAf0aSf0bAPx3gn8myhxm0dxl1ZtKZ3uhhZjlnkWSVZLPsYSZgD5mBPWQnvWNmwD8L4J+D5J8F8M8K+Oe07GF27V0OnTl1ZjN6mEvOuSV5JHkte5gV2EMuYA/5SO+YDfDPDfjnJ/lnB/zzAP4FLHuYT3uXX2cBnXmNHhaUcyFJYUkRyx7mAPZQENhDUdI75gT8CwH+xUj+uQD/woB/ccseFtXeFdNZXGcRo4cl5FxSUkpS2rKHuYE9lAD2UIb0jnkA/5KAf1mSf17AvxTgX86yh2W0d2V1ltNZ2uhheTlXkFSUVLLsYT5gD+WBPVQmvWN+wL8C4F+F5F8A8K8I+Fe17GFl7V0VnVV1VjJ6WE3O1SU1JDUte1gQ2EM1YA+1SO9YCPCvDvjXJvkXBvxrAP51LHtYS3tXW2cdnTWNHtaVcz1JfUkDyx4WAfZQF9hDQ9I7FgX86wH+jUj+xQD/+oB/Y8seNtTeNdLZWGcDo4dN5NxU0kzS3LKHxYE9NAH20IL0jiUA/6aAf0uSf0nAvxng38qyhy20dy11ttLZ3Ohhazm3kbSVtLPsYSlgD62BPbQnvWNpwL8N4N+B5F8G8G8L+He07GF77V0HnR11tjN62EnOnSVdJF0te1gW2EMnYA/dSO9YDvDvDPh3J/mXB/y7AP49LHvYTXvXXWcPnV2NHvaUcy9Jb0kfyx5WAPbQE9hDX9I7VgT8ewH+/Uj+lQD/3oB/f8se9tXe9dPZX2cfo4cD5DxQMkgy2LKHlYE9DAD2MIT0jlUA/4GA/1CSf1XAfxDgP8yyh0O0d0N1DtM52OjhcDmPkIyUjLLsYTVgD8OBPYwmvWN1wH8E4D+G5F8D8B8J+I+17OFo7d0YnWN1jjJ6OE7O4yUTJBMte1gT2MM4YA+TSO9YC/AfD/hPJvnXBvwnAP5TLHs4SXs3WecUnRONHk6V8zTJdMkMyx7WAfYwFdjDTNI71gX8pwH+s0j+9QD/6YD/bMseztTezdI5W+cMo4dz5DxXMk8y37KH9YE9zAH2sID0jg0A/7mA/0KSf0PAfx7gv8iyhwu0dwt1LtI53+jhYjkvkSyVLLPsYSNgD4uBPSwnvWNjwH8J4L+C5N8E8F8K+K+07OFy7d0KnSt1LjN6uErOqyVrJGste9gU2MMqYA/rSO/YDPBfDfivJ/k3B/zXAP4bLHu4Tnu3XucGnWuNHm6U8ybJZskWyx62APawEdjDVtI7tgT8NwH+20j+rQD/zYD/dssebtXebdO5XecWo4c75LxTskuy27KHrYE97AD2sIf0jm0A/52A/16Sf1vAfxfgv8+yh3u0d3t17tO52+jhfjkfkByUHLLsYTtgD/uBPRwmvWN7wP8A4H+E5N8B8D8I+B+17OFh7d0RnUd1HjJ6eEzOxyUnJCcte9gR2MMxYA+nSO/YCfA/DvifJvl3BvxPAP5nLHt4Snt3WucZnSeNHp6V8znJeckFyx52AfZwFtjDRdI7dgX8zwH+l0j+3QD/84D/ZcseXtTeXdJ5WecFo4dX5HxVck1y3bKH3YE9XAH2cIP0jj0A/6uA/02Sf0/A/xrgf8uyhze0dzd13tJ53ejhbTnfkdyV3LPsYS9gD7eBPdwnvWNvwP8O4P+A5N8H8L8L+D+07OF97d0DnQ913jN6+EjOjyVPJE8te9gX2MMjYA/PSO/YD/B/DPg/J/n3B/yfAP4vLHv4THv3XOcLnU+NHr6U8yvJa8kbyx4OAPbwEtjDW9I7DgT8XwH+70j+gwD/14D/e8sevtXevdP5Xucbo4cf5PxR8kny2bKHg4E9fAD28IX0jkMA/4+A/1eS/1DA/xPg/82yh1+0d191ftP52ejhdzn/kPyU/LLs4TBgD9+BPTgpOO84HPD/Afj7I/mPAPx/Av7+U9j10P1+7ulPp3+dv4weBpCfCygJJAmc4vfPRPcwEthDgBR+30MQ0juOAvwDAv5BSf6jAf9AgH8wyx4G0d4F1RlMp7tvnnvB5RxCElISyrKHY4A9BAf2EJr0jmMB/xCAfxiS/zjAPyTgH9ayh6G1d2F0htUZyuhhODmHl0SQRLTs4XhgD+GAPUQiveMEwD884B+Z5D8R8I8A+Eex7GEk7V1knVF0RjR6GFXO0STRJTEsezgJ2ENUYA8xSe84GfCPBvjHIvlPAfyjA/6xLXsYU3sXS2dsnTGMHsZxMyRxJfEsezgV2EMcYA/xSe84DfB3Af4JSP7TAf+4gH9Cyx7G194l0JlQZzyjh4nknFiSRJLUsoczgD0kAvaQjPSOMwH/xIB/cpL/LMA/CeCfwrKHybR3yXWm0JnU6GFKOaeSpJaksezhbGAPKYE9+JDecQ7gnwrwT0vynwv4pwb801n20Ed7l1ZnOp1pjB6ml3MGSUZJJssezgP2kB7YQ2bSO84H/DMA/llI/gsA/4yAf1bLHmbW3mXRmVVnJqOH2eScXZJDktOyhwuBPWQD9pCL9I6LAP/sgH9ukv9iwD8H4J/Hsoe5tHe5debRmdPoYV4555PklxSw7OESYA95gT0UJL3jUsA/H+BfiOS/DPDPD/gXtuxhQe1dIZ2FdRYwelhEzkUlxSTFLXu4HNhDEWAPJUjvuALwLwr4lyT5rwT8iwH+pSx7WEJ7V1JnKZ3FjR6WlnMZSVlJOcsergL2UBrYQ3nSO64G/MsA/hVI/msA/7KAf0XLHpbX3lXQWVFnOaOHleRcWVJFUtWyh2uBPVQC9lCN9I7rAP/KgH91kv96wL8K4F/DsofVtHfVddbQWdXoYU0515LUltSx7OEGYA81gT3UJb3jRsC/FuBfj+S/CfCvDfjXt+xhXe1dPZ31ddYxethAzg0ljSSNLXu4GdhDA2APTUjvuAXwbwj4NyX5bwX8GwH+zSx72ER711RnM52NjR42l3MLSUtJK8sebgP20BzYQ2vSO24H/FsA/m1I/jsA/5aAf1vLHrbW3rXR2VZnK6OH7eTcXtJB0tGyhzuBPbQD9tCJ9I67AP/2gH9nkv9uwL8D4N/FsoedtHeddXbR2dHoYVc5d5N0l/Sw7OEeYA9dgT30JL3jXsC/G+Dfi+S/D/DvDvj3tuxhT+1dL529dfYwethHzn0l/ST9LXu4H9hDH2APA0jveADw7wv4DyT5HwT8+wH+gyx7OEB7N1DnIJ39jR4OlvMQyVDJMMseHgL2MBjYw3DSOx4G/IcA/iNI/kcA/6GA/0jLHg7X3o3QOVLnMKOHo+Q8WjJGMtayh0eBPYwC9jCO9I7HAP/RgP94kv9xwH8M4D/BsofjtHfjdU7QOdbo4UQ5T5JMlkyx7OEJYA8TgT1MJb3jScB/EuA/jeR/CvCfDPhPt+zhVO3dNJ3TdU4xejhDzjMlsySzLXt4GtjDDGAPc0jveAbwnwn4zyX5nwX8ZwH+8yx7OEd7N1fnPJ2zjR7Ol/MCyULJIssengP2MB/Yw2LSO54H/BcA/ktI/hcA/4WA/1LLHi7W3i3RuVTnIqOHy+S8XLJCstKyhxeBPSwD9rCK9I6XAP/lgP9qkv9lwH8F4L/GsoertHerda7RudLo4Vo5r5Osl2yw7OEVYA9rgT1sJL3jVcB/HeC/ieR/DfBfD/hvtuzhRu3dJp2bdW4werhFzlsl2yTbLXt4HdjDFmAPO0jveAPw3wr47yT53wT8twH+uyx7uEN7t1PnLp3bjR7ulvMeyV7JPsse3gL2sBvYw37SO94G/PcA/gdI/ncA/72A/0HLHu7X3h3QeVDnPqOHh+R8WHJEctSyh3eBPRwC9nCM9I73AP/DgP9xkv99wP8I4H/CsofHtHfHdZ7QedTo4Uk5n5Kclpyx7OEDYA8ngT2cJb3jQ8D/FOB/juT/CPA/Dfift+zhWe3dOZ3ndZ4xenhBzhcllySXLXv4GNjDBWAPV0jv+ATwvwj4XyX5PwX8LwH+1yx7eEV7d1XnNZ2XjR5el/MNyU3JLcsePgP2cB3Yw23SOz4H/G8A/ndI/i8A/5uA/13LHt7W3t3ReVfnLaOH9+R8X/JA8tCyhy+BPdwD9vCI9I6vAP/7gP9jkv9rwP8B4P/EsoePtHePdT7R+dDo4VM5P5M8l7yw7OEbYA9PgT28JL3jW8D/GeD/iuT/DvB/Dvi/tuzhS+3dK52vdb4wevhGzm8l7yTvLXv4HtjDG2APH0jv+AHwfwv4fyT5fwT83wH+nyx7+EF791HnJ53vjR5+lvMXyVfJN8sefgL28BnYw3fSO34G/L8A/j9I/l8A/6+A/0/LHn7X3v3Q+VPnN6OHv9zdSyk/L/Gf8vfPRPfwFdjDL2APAVJy3vEb4O+k9Lt/QJL/d8DfH+AfKKVdD93v554BdQbS6e6b515gOQeRBJUEs+zhD2APgYE9BCe940/APwjgH4Lk/wvwDwr4h7TsYXDtXQidIXUGM3oYSs6hJWEkYS176AT2+91QwB7Ckd7RH+AfGvAPT/L3D/iHAfwjWPYwnPYuvM4IOsMaPYwo50iSyJIolj0MAOwhIrCHqKR3DAj4RwL8o5H8AwH+kQH/6JY9jKq9i6Yzus4oRg9jyDmmJJYktmUPAwN7iAHsIQ7pHYMA/jEBfxfJPyjgHwvwj2vZwzjaO5fOuDpjGz2MJ+f4kgSShJY9DAbsIR6wh0SkdwwO+McH/BOT/EMA/gkA/ySWPUykvUusM4nOhEYPk8o5mSS5JIVlD0MCe0gK7CEl6R1DAf7JAP9UJP/QgH9ywD+1ZQ9Tau9S6UytM4XRwzRy9pGklaSz7GEYYA9pgD2kJ71jWMDfB/DPQPIPB/inBfwzWvYwvfYug86MOtMZPcwk58ySLJKslj0MD+whE7CHbKR3jAD4Zwb8s5P8IwL+WQD/HJY9zKa9y64zh86sRg9zyjmXJLckj2UPIwF7yAnsIS/pHSMD/rkA/3wk/yiAf27AP79lD/Nq7/LpzK8zj9HDAnIuKCkkKWzZw6jAHgoAeyhCesdogH9BwL8oyT864F8I8C9m2cMi2ruiOovpLGz0sLicS0hKSkpZ9jAGsIfiwB5Kk94xJuBfAvAvQ/KPBfiXBPzLWvawtPaujM6yOksZPSwn5/KSCpKKlj2MDeyhHLCHSqR3jAP4lwf8K5P8XYB/BcC/imUPK2nvKuusorOi0cOqcq4mqS6pYdnDuMAeqgJ7qEl6x3iAfzXAvxbJPz7gXx3wr23Zw5rau1o6a+usYfSwjpzrSupJ6lv2MAGwhzrAHhqQ3jEh4F8X8G9I8k8E+NcD/BtZ9rCB9q6hzkY66xs9bCznJpKmkmaWPUwM7KExsIfmpHdMAvg3AfxbkPyTAv5NAf+Wlj1srr1robOlzmZGD1vJubWkjaStZQ+TAXtoBeyhHekdkwP+rQH/9iT/FIB/G8C/g2UP22nv2uvsoLOt0cOOcu4k6SzpYtnDlMAeOgJ76Ep6x1SAfyfAvxvJPzXg3xnw727Zw67au246u+vsYvSwh5x7SnpJelv2MA2whx7AHvqQ3tEH8O8J+Pcl+acF/HsB/v0se9hHe9dXZz+dvY0e9pfzAMlAySDLHqYD9tAf2MNg0jumB/wHAP5DSP4ZAP+BgP9Qyx4O1t4N0TlU5yCjh8PkPFwyQjLSsocZgT0MA/YwivSOmQD/4YD/aJJ/ZsB/BOA/xrKHo7R3o3WO0TnS6OFYOY+TjJdMsOxhFmAPY4E9TCS9Y1bAfxzgP4nknw3wHw/4T7bs4UTt3SSdk3VOMHo4Rc5TJdMk0y17mB3YwxRgDzNI75gD8J8K+M8k+ecE/KcB/rMsezhDezdT5yyd040ezpbzHMlcyTzLHuYC9jAb2MN80jvmBvznAP4LSP55AP+5gP9Cyx7O194t0LlQ5zyjh4vkvFiyRLLUsod5gT0sAvawjPSO+QD/xYD/cpJ/fsB/CeC/wrKHy7R3y3Wu0LnU6OFKOa+SrJassexhAWAPK4E9rCW9Y0HAfxXgv47kXwjwXw34r7fs4Vrt3Tqd63WuMXq4Qc4bJZskmy17WBjYwwZgD1tI71gE8N8I+G8l+RcF/DcB/tsse7hFe7dV5zadm40ebpfzDslOyS7LHhYD9rAd2MNu0jsWB/x3AP57SP4lAP+dgP9eyx7u1t7t0blX5y6jh/vkvF9yQHLQsoclgT3sA/ZwiPSOpQD//YD/YZJ/acD/AOB/xLKHh7R3h3Ue0XnQ6OFROR+THJecsOxhGWAPR4E9nCS9Y1nA/xjgf4rkXw7wPw74n7bs4Unt3Smdp3WeMHp4Rs5nJeck5y17WB7YwxlgDxdI71gB8D8L+F8k+VcE/M8B/pcse3hBe3dR5yWd540eXpbzFclVyTXLHlYC9nAZ2MN10jtWBvyvAP43SP5VAP+rgP9Nyx5e197d0HlT5zWjh7fkfFtyR3LXsodVgT3cAvZwj/SO1QD/24D/fZJ/dcD/DuD/wLKH97R393U+0HnX6OFDOT+SPJY8sexhDWAPD4E9PCW9Y03A/xHg/4zkXwvwfwz4P7fs4VPt3TOdz3U+MXr4Qs4vJa8kry17WBvYwwtgD29I71gH8H8J+L8l+dcF/F8B/u8se/hGe/dW5zudr40evpfzB8lHySfLHtYD9vAe2MNn0jvWB/w/AP5fSP4NAP+PgP9Xyx5+1t590flV5yejh9/k/F3yQ/LTsocNgT18A/bwi/SOjQD/74C/k4rj3xjw/wH4+0tl18Nf2jv3Hvzp57nnT6OH/uXnAkgCSgKl+v0z0T00AfbgP5Xf9xCY9I5NAf8AgH8Qkn8zwD8g4B/UsoeBtXdBdAbV6e6b514wOQeXhJCEtOxhc2APwYA9hCK9YwvAPzjgH5rk3xLwDwH4h7HsYSjtXWidYXSGNHoYVs7hJOElESx72ArYQ1hgDxFJ79ga8A8H+Eci+bcB/MMD/pEtexhRexdJZ2SdEYweRpFzVEk0SXTLHrYF9hAF2EMM0ju2A/yjAv4xSf7tAf9ogH8syx7G0N7F1BlLZ3Sjh7HlHMfNkcS17GEHYA+xgT3EI71jR8A/DuAfn+TfCfB3Af4JLHsYT3sXX2cCnXGNHiaUcyJJYkkSyx52BvaQENhDUtI7dgH8EwH+yUj+XQH/xIB/csseJtXeJdOZXGcSo4cp5JxSkkqS2rKH3YA9pAD2kIb0jt0B/5SAvw/JvwfgnwrwT2vZwzTaOx+daXWmNnqYTs7pJRkkGS172BPYQzpgD5lI79gL8E8P+Gcm+fcG/DMA/lkse5hJe5dZZxadGY0eZpVzNkl2SQ7LHvYB9pAV2ENO0jv2BfyzAf65SP79AP/sgH9uyx7m1N7l0plbZw6jh3nknFeST5Lfsof9gT3kAfZQgPSOAwD/vIB/QZL/QMA/H+BfyLKHBbR3BXUW0pnf6GFhOReRFJUUs+zhIGAPhYE9FCe942DAvwjgX4LkPwTwLwr4l7TsYXHtXQmdJXUWM3pYSs6lJWUkZS17OBTYQylgD+VI7zgM8C8N+Jcn+Q8H/MsA/hUse1hOe1deZwWdZY0eVpRzJUllSRXLHo4A9lAR2ENV0juOBPwrAf7VSP6jAP/KgH91yx5W1d5V01ldZxWjhzXkXFNSS1LbsoejgT3UAPZQh/SOYwD/moB/XZL/WMC/FuBfz7KHdbR3dXXW01nb6GF9OTeQNJQ0suzhOGAP9YE9NCa943jAvwHg34TkPwHwbwj4N7XsYWPtXROdTXU2MnrYTM7NJS0kLS17OBHYQzNgD61I7zgJ8G8O+Lcm+U8G/FsA/m0se9hKe9daZxudLY0etpVzO0l7SQfLHk4B9tAW2ENH0jtOBfzbAf6dSP7TAP/2gH9nyx521N510tlZZwejh13k3FXSTdLdsofTgT10AfbQg/SOMwD/roB/T5L/TMC/G+Dfy7KHPbR3PXX20tnd6GFvOfeR9JX0s+zhLGAPvYE99Ce942zAvw/gP4DkPwfw7wv4D7TsYX/t3QCdA3X2M3o4SM6DJUMkQy17OBfYwyBgD8NI7zgP8B8M+A8n+c8H/IcA/iMsezhMezdc5widQ40ejpTzKMloyRjLHi4A9jAS2MNY0jsuBPxHAf7jSP6LAP/RgP94yx6O1d6N0zle5xijhxPkPFEySTLZsoeLgT1MAPYwhfSOSwD/iYD/VJL/UsB/EuA/zbKHU7R3U3VO0znZ6OF0Oc+QzJTMsuzhMmAP04E9zCa943LAfwbgP4fkvwLwnwn4z7Xs4Wzt3Rydc3XOMno4T87zJQskCy17uBLYwzxgD4tI77gK8J8P+C8m+a8G/BcA/ksse7hIe7dY5xKdC40eLpXzMslyyQrLHq4B9rAU2MNK0juuBfyXAf6rSP7rAP/lgP9qyx6u1N6t0rla5wqjh2vkvFayTrLesofrgT2sAfawgfSOGwD/tYD/RpL/RsB/HeC/ybKHG7R3G3Vu0rne6OFmOW+RbJVss+zhJmAPm4E9bCe942bAfwvgv4PkvwXw3wr477Ts4Xbt3Q6dO3VuM3q4S867JXskey17uBXYwy5gD/tI77gN8N8N+O8n+W8H/PcA/gcse7hPe7df5wGde40eHpTzIclhyRHLHu4A9nAQ2MNR0jvuBPwPAf7HSP67AP/DgP9xyx4e1d4d03lc5xGjhyfkfFJySnLasoe7gT2cAPZwhvSOewD/k4D/WZL/XsD/FOB/zrKHZ7R3Z3We03na6OF5OV+QXJRcsuzhPmAP54E9XCa9437A/wLgf4XkfwDwvwj4X7Xs4WXt3RWdV3VeMnp4Tc7XJTckNy17eBDYwzVgD7dI73gI8L8O+N8m+R8G/G8A/ncse3hLe3db5x2dN40e3pXzPcl9yQPLHh4B9nAX2MND0jseBfzvAf6PSP7HAP/7gP9jyx4+1N490vlY5wOjh0/k/FTyTPLcsofHgT08AfbwgvSOJwD/p4D/S5L/ScD/GeD/yrKHL7R3L3W+0vnc6OFrOb+RvJW8s+zhKWAPr4E9vCe942nA/w3g/4Hkfwbwfwv4f7Ts4Xvt3QedH3W+M3r4Sc6fJV8kXy17eBbYwydgD99I73gO8P8M+H8n+Z8H/L8A/j8se/hNe/dd5w+dX40e/pTzL3f/Ust/lvr3z0T3cAHYw09gD/5Tc97xIuD/C/APQPK/BPg7qf3uHzC1XQ/d7+eeAXQG1Onum+deIDkHlgSRBLXs4WVgD4GAPQQjveMVwD8w4B+c5H8V8A8C+Iew7GEw7V1wnSF0BjV6GFLOoSShJWEse3gN2ENIYA9hSe94HfAPBfiHI/nfAPxDA/7hLXsYVnsXTmd4nWGMHkaQc0RJJElkyx7eBPYQAdhDFNI73gL8IwL+UUn+twH/SIB/NMseRtHeRdUZTWdko4fR5RxDElMSy7KHd4A9RAf2EJv0jncB/xiAfxyS/z3APybg77LsYWztXRydLp2xjB7GlXM8SXxJAsse3gf2EBfYQ0LSOz4A/OMB/olI/g8B//iAf2LLHibU3iXSmVhnAqOHSeScVJJMktyyh4+APSQB9pCC9I6PAf+kgH9Kkv8TwD8Z4J/KsocptHcpdabSmdzoYWo5p5H4SNJa9vApsIfUwB7Skd7xGeCfBvBPT/J/Dvj7AP4ZLHuYTnuXXmcGnWmNHmaUcyZJZkkWyx6+APaQEdhDVtI7vgT8MwH+2Uj+rwD/zIB/dsseZtXeZdOZXWcWo4c55JxTkkuS27KHr4E95AD2kIf0jm8A/5yAf16S/1vAPxfgn8+yh3m0d3l15tOZ2+hhfjkXkBSUFLLs4TtgD/mBPRQmveN7wL8A4F+E5P8B8C8I+Be17GFh7V0RnUV1FjJ6WEzOxSUlJCUte/gR2EMxYA+lSO/4CfAvDviXJvl/BvxLAP5lLHtYSntXWmcZnSWNHpaVczlJeUkFyx5+AfZQFthDRdI7fgX8ywH+lUj+3wD/8oB/ZcseVtTeVdJZWWcFo4dV5FxVUk1S3bKH34E9VAH2UIP0jj8A/6qAf02S/0/AvxrgX8uyhzW0dzV11tJZ3ehhbTnXkdSV1LPs4S9gD7WBPdQnvaMTxO936wD+DUj+/gD/uoB/Q8se1tfeNdDZUGc9o4eN5NxY0kTS1LKH/oE9NAL20Iz0jgEA/8aAf3OSf0DAvwng38Kyh820d811ttDZ1OhhSzm3krSWtLHsYSBgDy2BPbQlvWNgwL8V4N+O5B8E8G8N+Le37GFb7V07ne11tjF62EHOHSWdJJ0texgU2EMHYA9dSO8YDPDvCPh3JfkHB/w7Af7dLHvYRXvXVWc3nZ2NHnaXcw9JT0kvyx6GAPbQHdhDb9I7hgT8ewD+fUj+oQD/noB/X8se9tbe9dHZV2cvo4f95NxfMkAy0LKHoYE99AP2MIj0jmEA//6A/2CSf1jAfwDgP8Syh4O0d4N1DtE50OjhUDkPkwyXjLDsYThgD0OBPYwkvWN4wH8Y4D+K5B8B8B8O+I+27OFI7d0onaN1jjB6OEbOYyXjJOMtexgR2MMYYA8TSO8YCfAfC/hPJPlHBvzHAf6TLHs4QXs3UeckneONHk6W8xTJVMk0yx5GAfYwGdjDdNI7RgX8pwD+M0j+0QD/qYD/TMseTtfezdA5U+c0o4ez5DxbMkcy17KH0YE9zAL2MI/0jjEA/9mA/3ySf0zAfw7gv8Cyh/O0d/N1LtA51+jhQjkvkiyWLLHsYSxgDwuBPSwlvWNswH8R4L+M5B8H8F8M+C+37OFS7d0ynct1LjF6uELOKyWrJKste+gC9rAC2MMa0jvGBfxXAv5rSf7xAP9VgP86yx6u0d6t1blO52qjh+vlvEGyUbLJsofxgT2sB/awmfSOCQD/DYD/FpJ/QsB/I+C/1bKHm7V3W3Ru1bnJ6OE2OW+X7JDstOxhImAP24A97CK9Y2LAfzvgv5vknwTw3wH477Hs4S7t3W6de3TuNHq4V877JPslByx7mBTYw15gDwdJ75gM8N8H+B8i+ScH/PcD/octe3hQe3dI52GdB4weHpHzUckxyXHLHqYA9nAE2MMJ0jumBPyPAv4nSf6pAP9jgP8pyx6e0N6d1HlK53Gjh6flfEZyVnLOsoepgT2cBvZwnvSOaQD/M4D/BZK/D+B/FvC/aNnD89q7Czov6jxn9PCSnC9LrkiuWvYwLbCHS8AerpHeMR3gfxnwv07yTw/4XwH8b1j28Jr27rrOGzqvGj28KedbktuSO5Y9zADs4Sawh7ukd8wI+N8C/O+R/DMB/rcB//uWPbyrvbun877OO0YPH8j5oeSR5LFlDzMDe3gA7OEJ6R2zAP4PAf+nJP+sgP8jwP+ZZQ+faO+e6nym87HRw+dyfiF5KXll2cNswB6eA3t4TXrH7ID/C8D/Dck/B+D/EvB/a9nD19q7Nzrf6nxl9PCdnN9LPkg+WvYwJ7CHd8AePpHeMRfg/x7w/0zyzw34fwD8v1j28JP27rPOLzo/Gj38Kudvku+SH5Y9zAPs4Suwh5+kd8wL+H8D/H+R/PMB/t8BfyeNXQ9/au9+6XR/nnv+MHroT37OvySAJGCa3z8T3UN+YA/+0vh9D4HScN6xAODvH/APTPIvCPgHAPyDWPYwkPYusM4gOt1989wLKudgkuCSEJY9LATsISiwh5CkdywM+AcD/EOR/IsA/sEB/9CWPQypvQulM7TOEEYPw8g5rCScJLxlD4sCewgD7CEC6R2LAf5hAf+IJP/igH84wD+SZQ8jaO8i6oykM7zRw8hyjiKJKolm2cMSwB4iA3uITnrHkoB/FMA/Bsm/FOAfFfCPadnD6Nq7GDpj6oxm9DCWnGNL4rhZlj0sDewhFrCHuKR3LAP4xwb845H8ywL+cQD/+JY9jKu9i6czvk6X0cMEck4oSSRJbNnDcsAeEgB7SEJ6x/KAf0LAPynJvwLgnwjwT2bZwyTau6Q6k+lMbPQwuZxTSFJKUln2sCKwh+TAHlKT3rES4J8C8E9D8q8M+KcE/H0se5hae5dGp4/OVEYP08o5nSS9JINlD6sAe0gL7CEj6R2rAv7pAP9MJP9qgH96wD+zZQ8zau8y6cysM4PRwyxyzirJJslu2cPqwB6yAHvIQXrHGoB/VsA/J8m/JuCfDfDPZdnDHNq7nDpz6cxu9DC3nPNI8kryWfawFrCH3MAe8pPesTbgnwfwL0DyrwP45wX8C1r2ML/2roDOgjrzGT0sJOfCkiKSopY9rAvsoRCwh2Kkd6wH+BcG/IuT/OsD/kUA/xKWPSymvSuus4TOokYPS8q5lKS0pIxlDxsAeygJ7KEs6R0bAv6lAP9yJP9GgH9pwL+8ZQ/Lau/K6Syvs4zRwwpyriipJKls2cPGwB4qAHuoQnrHJoB/RcC/Ksm/KeBfCfCvZtnDKtq7qjqr6axs9LC6nGtIakpqWfawGbCH6sAeapPesTngXwPwr0PybwH41wT861r2sLb2ro7OujprGT2sJ+f6kgaShpY9bAnsoR6wh0akd2wF+NcH/BuT/FsD/g0A/yaWPWykvWuss4nOhkYPm8q5maS5pIVlD9sAe2gK7KEl6R3bAv7NAP9WJP92gH9zwL+1ZQ9bau9a6Wyts4XRwzZybitpJ2lv2cP2wB7aAHvoQHrHDoB/W8C/I8m/I+DfDvDvZNnDDtq7jjo76Wxv9LCznLtIukq6WfawE7CHzsAeupPesTPg3wXw70Hy7wL4dwX8e1r2sLv2rofOnjq7GT3sJefekj6SvpY97ArsoRewh36kd+wG+PcG/PuT/LsD/n0A/wGWPeynveuvc4DOvkYPB8p5kGSwZIhlD3sAexgI7GEo6R17Av6DAP9hJP9egP9gwH+4ZQ+Hau+G6Ryuc4jRwxFyHikZJRlt2cPewB5GAHsYQ3rHPoD/SMB/LMm/L+A/CvAfZ9nDMdq7sTrH6Rxt9HC8nCdIJkomWfawH7CH8cAeJpPesT/gPwHwn0LyHwD4TwT8p1r2cLL2borOqTonGT2cJufpkhmSmZY9HAjsYRqwh1mkdxwE+E8H/GeT/AcD/jMA/zmWPZylvZutc47OmUYP58p5nmS+ZIFlD4cAe5gL7GEh6R2HAv7zAP9FJP9hgP98wH+xZQ8Xau8W6Vysc4HRwyVyXipZJllu2cPhwB6WAHtYQXrHEYD/UsB/Jcl/JOC/DPBfZdnDFdq7lTpX6Vxu9HC1nNdI1krWWfZwFLCH1cAe1pPecTTgvwbw30DyHwP4rwX8N1r2cL32boPOjTrXGT3cJOfNki2SrZY9HAvsYROwh22kdxwH+G8G/LeT/McD/lsA/x2WPdymvduuc4fOrUYPd8p5l2S3ZI9lDycAe9gJ7GEv6R0nAv67AP99JP9JgP9uwH+/ZQ/3au/26dyvc4/RwwNyPig5JDls2cPJwB4OAHs4QnrHKYD/QcD/KMl/KuB/CPA/ZtnDI9q7ozqP6Txs9PC4nE9ITkpOWfZwGrCH48AeTpPecTrgfwLwP0PynwH4nwT8z1r28LT27ozOszpPGT08J+fzkguSi5Y9nAns4Rywh0ukd5wF+J8H/C+T/GcD/hcA/yuWPbykvbus84rOi0YPr8r5muS65IZlD+cAe7gK7OEm6R3nAv7XAP9bJP95gP91wP+2ZQ9vau9u6byt84bRwztyviu5J7lv2cP5wB7uAHt4QHrHBYD/XcD/Icl/IeB/D/B/ZNnDB9q7hzof6bxv9PCxnJ9InkqeWfZwEbCHx8AenpPecTHg/wTwf0HyXwL4PwX8X1r28Ln27oXOlzqfGT18JefXkjeSt5Y9XArs4RWwh3ekd1wG+L8G/N+T/JcD/m8A/w+WPXynvXuv84POt0YPP8r5k+Sz5ItlD1cAe/gI7OEr6R1XAv6fAP9vJP9VgP9nwP+7ZQ+/au++6fyu84vRwx9y/in55e6gz++fie5hNbCHH8Ae/Plw3nEN4P8T8PdP8l8L+P8C/AP42PXQ/X7u6V9nAJ3uvnnuBZRzIElgSRDLHq4D9hDQx+97CEp6x/WAfyDAPxjJfwPgHxjwD27Zw6Dau2A6g+sMYvQwhJxDSkJJQlv2cCOwhxDAHsKQ3nET4B8S8A9L8t8M+IcC/MNZ9jCM9i6sznA6Qxs9DC/nCJKIkkiWPdwC7CE8sIfIpHfcCvhHAPyjkPy3Af4RAf+olj2MrL2LojOqzkhGD6PJObokhiSmZQ+3A3uIBuwhFukddwD+0QH/2CT/nYB/DMA/jmUPY2nvYuuMozOm0UOXnONK4kniW/ZwF7AHF7CHBKR33A34xwX8E5L89wD+8QD/RJY9TKC9S6gzkc74Rg8TyzmJJKkkmWUP9wJ7SAzsITnpHfcB/kkA/xQk//2Af1LAP6VlD5Nr71LoTKkzmdHDVHJOLUkj8bHs4QFgD6mAPaQlveNBwD814J+O5H8I8E8D+Ke37GFa7V06nel1+hg9zCDnjJJMksyWPTwM7CEDsIcspHc8AvhnBPyzkvyPAv6ZAP9slj3Mor3LqjObzsxGD7PLOYckpySXZQ+PAXvIDuwhN+kdjwP+OQD/PCT/E4B/TsA/r2UPc2vv8ujMqzOX0cN8cs4vKSApaNnDk8Ae8gF7KER6x1OAf37AvzDJ/zTgXwDwL2LZw0Lau8I6i+gsaPSwqJyLSYpLSlj28Aywh6LAHkqS3vEs4F8M8C9F8j8H+BcH/Etb9rCk9q6UztI6Sxg9LCPnspJykvKWPTwP7KEMsIcKpHe8APiXBfwrkvwvAv7lAP9Klj2soL2rqLOSzvJGDyvLuYqkqqSaZQ8vAXuoDOyhOukdLwP+VQD/GiT/K4B/VcC/pmUPq2vvauisqbOa0cNacq4tqSOpa9nDq8AeagF7qEd6x2uAf23Avz7J/zrgXwfwb2DZw3rau/o6G+isa/SwoZwbSRpLmlj28Aawh4bAHpqS3vEm4N8I8G9G8r8F+DcG/Jtb9rCp9q6ZzuY6mxg9bCHnlpJWktaWPbwN7KEFsIc2pHe8A/i3BPzbkvzvAv6tAP92lj1so71rq7OdztZGD9vLuYOko6STZQ/vAXtoD+yhM+kd7wP+HQD/LiT/B4B/R8C/q2UPO2vvuujsqrOT0cNucu4u6SHpadnDh8AeugF76EV6x0eAf3fAvzfJ/zHg3wPw72PZw17au946++jsafSwr5z7SfpLBlj28Amwh77AHgaS3vEp4N8P8B9E8n8G+PcH/Adb9nCg9m6QzsE6Bxg9HCLnoZJhkuGWPXwO7GEIsIcRpHd8AfgPBfxHkvxfAv7DAP9Rlj0cob0bqXOUzuFGD0fLeYxkrGScZQ9fAXsYDexhPOkdXwP+YwD/CST/N4D/WMB/omUPx2vvJuicqHOc0cNJcp4smSKZatnDt8AeJgF7mEZ6x3eA/2TAfzrJ/z3gPwXwn2HZw2nau+k6Z+icavRwppxnSWZL5lj28AOwh5nAHuZa7mGu/rpn6Zytc46xh3lyni9ZIFmoPy+/nP/dwd/9cDl++RHkjJvl/r33v3r6/TMcfwkdvMsoI5HjfUZix/uMJI73GUkd7zOSOd5nJHe8z0jheJ+R0vE+I5XjfUZqx/uMNI73GT6O9xlpHe8z0jneZ6R3vM/I4HifkdHxPiOT431GZsf7jCyO9xlZHe8zsjneZ2R3vM/I4XifkdPxPiOX431Gbsf7jDyO9xl5He8z8jneZ+R3vM8o4HifUdDxPqOQ431GYcf7jCKO9xlFHe8zijneZxR3vM8o4XifUdLxPqOU431Gacf7jDKO9xllHe8zyjneZ5R3vM+o4HifUdHxPqOS431GZcf7jCqO9xlVHe8zqjneZ1R3vM+o4XifUdPxPqOW431Gbcf7jDqO9xl1He8z6jneZ9R3vM9o4Hif0dDxPqOR431GY8f7jCaO9xlNHe8zmjneZzR3vM9o4Xif0dLxPqOV431Ga8f7jDaO9xltHe8z2jneZ7R3vM/o4Hif0dHxPqOT431GZ8f7jC6O9xldHe8zujneZ3R3vM/o4Xif0dPxPqOX431Gb8f7jD6O9xl9He8z+jneZ/R3vM8Y4HifMdDxPmOQ433GYMf7jCGO9xlDHe8zhjneZwx3vM8Y4XifMdLxPmOU433GaMf7jDGO9xljHe8zxjneZ4x3vM+Y4HifMdHxPmOS433GZMf7jCmO9xlTHe8zpjneZ0x3vM+Y4XifMdPxPmOW433GbMf7jDmO9xlzHe8z5jneZ8x3vM9Y4HifsdDxPmOR433GYsf7jCWO9xlLHe8zljneZyx3vM9Y4XifsdLxPmOV433Gasf7jDWO9xlrHe8z1jneZ6x3vM/Y4HifsdHxPmOT433GZsf7jC2O9xlbHe8ztjneZ2x3vM/Y4XifsdPxPmOX433Gbsf7jD2O9xl7He8z9jneZ+x3vM844HifcdDxPuOQ433GYcf7jCOO9xlHHe8zjjneZxx3vM844XifcdLxPuOU433Gacf7jDOO9xlnHe8zzjneZ5x3vM+44HifcdHxPuOS433GZcf7jCuO9xlXHe8zrjneZ1x3vM+44XifcdPxPuOW433Gbcf7jDuO9xl3He8z7jneZ9x3vM944Hif8dDxPuOR433GY8f7jCeO9xlPHe8znjneZzx3vM944Xif8dLxPuOV433Ga8f7jDeO9xlvHe8z3jneZ7x3vM/44Hif8dHxPuOT433GZ8f7jC+O9xlfHe8zvjneZ3x3vM/44Xif8dPxPuOX432G+w/w413jD8IY/ggM/wRGAAIjIIERiMAITGAEITCCEhjBCIzgBEYIAiMkgRGKwAhNYIQhMMISGOEIjPAERgQCIyKBEYnAiExgRCEwohIY0QiM6ARGDAIjJoERi8CITWDEITBcBEZcAiMegRGfwEhAYCQkMBIRGIkJjCQERlICIxmBkZzASEFgpCQwUhEYqQmMNASGD4GRlsBIR2CkJzAyEBgZCYxMBEZmAiMLgZGVwMhGYGQnMHIQGDkJjFwERm4CIw+BkZfAyEdg5CcwChAYBQmMQgRGYQKjCIFRlMAoRmAUJzBKEBglCYxSBEZpAqMMgVGWwChHYJQnMCoQGBUJjEoERmUCowqBUZXAqEZgVCcwahAYNQmMWgRGbQKjDoFRl8CoR2DUJzAaEBgNCYxGBEZjAqMJgdGUwGhGYDQnMFoQGC0JjFYERmsCow2B0ZbAaEdgtCcwOhAYHQmMTgRGZwKjC4HRlcDoRmB0JzB6EBg9CYxeBEZvAqMPgdGXwOhHYPQnMAYQGAMJjEEExmACYwiBMZTAGEZgDCcwRhAYIwmMUQTGaAJjDIExlsAYR2CMJzAmEBgTCYxJBMZkAmMKgTGVwJhGYEwnMGYQGDMJjFkExmwCYw6BMZfAmEdgzCcwFhAYCwmMRQTGYgJjCYGxlMBYRmAsJzBWEBgrCYxVBMZqAmMNgbGWwFhHYKwnMDYQGBsJjE0ExmYCYwuBsZXA2EZgbCcwdhAYOwmMXQTGbgJjD4Gxl8DYR2DsJzAOEBgHCYxDBMZhAuMIgXGUwDhGYBwnME4QGCcJjFMExmkC4wyBcZbAOEdgnCcwLhAYFwmMSwTGZQLjCoFxlcC4RmBcJzBuEBg3CYxbBMZtAuMOgXGXwLhHYNwnMB4QGA8JjEcExmMC4wmB8ZTAeEZgPCcwXhAYLwmMVwTGawLjDYHxlsB4R2C8JzA+EBgfCYxPBMZnAuMLgfGVwPhGYHwnMH4QGD8JjF8EhuPf+wx/BIZ/AiMAgRGQwAhEYAQmMIIQGEEJjGAERnACIwSBEZLACEVghCYwwhAYYQmMcARGeAIjAoERkcCIRGBEJjCiEBhRCYxoBEZ0AiMGgRGTwIhFYMQmMOIQGC4CIy6BEY/AiE9gJCAwEhIYiQiMxARGEgIjKYGRjMBITmCkIDBSEhipCIzUBEYaAsOHwEhLYKQjMNITGBkIjIwERiYCIzOBkYXAyEpgZCMwshMYOQiMnARGLgIjN4GRh8DIS2DkIzDyExgFCIyCBEYhAqMwgVGEwChKYBQjMIoTGCUIjJIERikCozSBUYbAKEtglCMwyhMYFQiMigRGJQKjMoFRhcCoSmBUIzCqExg1CIyaBEYtAqM2gVGHwKhLYNQjMOoTGA0IjIYERiMCozGB0YTAaEpgNCMwmhMYLQiMlgRGKwKjNYHRhsBoS2C0IzDaExgdCIyOBEYnAqMzgdGFwOhKYHQjMLoTGD0IjJ4ERi8CozeB0YfA6Etg9CMw+hMYAwiMgQTGIAJjMIExhMAYSmAMIzCGExgjCIyRBMYoAmM0gTGGwBhLYIwjMMYTGBMIjIkExiQCYzKBMYXAmEpgTCMwphMYMwiMmQTGLAJjNoExh8CYS2DMIzDmExgLCIyFBMYiAmMxgbGEwFhKYCwjMJYTGCsIjJUExioCYzWBsYbAWEtgrCMw1hMYGwiMjQTGJgJjM4GxhcDYSmBsIzC2Exg7CIydBMYuAmM3gbGHwNhLYOwjMPYTGAcIjIMExiEC4zCBcYTAOEpgHCMwjhMYJwiMkwTGKQLjNIFxhsA4S2CcIzDOExgXCIyLBMYlAuMygXGFwLhKYFwjMK4TGDcIjJsExi0C4zaBcYfAuEtg3CMw7hMYDwiMhwTGIwLjMYHxhMB4SmA8IzCeExgvCIyXBMYrAuM1gfGGwHhLYLwjMN4TGB8IjI8ExicC4zOB8YXA+EpgfCMwvhMYPwiMnwTGLwLDCeB9hj8Cwz+BEYDACEhgBCIwAhMYQQiMoARGMAIjOIERgsAISWCEIjBCExhhCIywBEY4AiM8gRGBwIhIYEQiMCITGFEIjKgERjQCIzqBEYPAiElgxCIwYhMYcQgMF4ERl8CIR2DEJzASEBgJCYxEBEZiAiMJgZGUwEhGYCQnMFIQGCkJjFQERmoCIw2B4UNgpCUw0hEY6QmMDARGRgIjE4GRmcDIQmBkJTCyERjZCYwcBEZOAiMXgZGbwMhDYOQlMPIRGPkJjAIERkECoxCBUZjAKEJgFCUwihEYxQmMEgRGSQKjFIFRmsAoQ2CUJTDKERjlCYwKBEZFAqMSgVGZwKhCYFQlMKoRGNUJjBoERk0CoxaBUZvAqENg1CUw6hEY9QmMBgRGQwKjEYHRmMBoQmA0JTCaERjNCYwWBEZLAqMVgdGawGhDYLQlMNoRGO0JjA4ERkcCoxOB0ZnA6EJgdCUwuhEY3QmMHgRGTwKjF4HRm8DoQ2D0JTD6ERj9CYwBBMZAAmMQgTGYwBhCYAwlMIYRGMMJjBEExkgCYxSBMZrAGENgjCUwxhEY4wmMCQTGRAJjEoExmcCYQmBMJTCmERjTCYwZBMZMAmMWgTGbwJhDYMwlMOYRGPMJjAUExkICYxGBsZjAWEJgLCUwlhEYywmMFQTGSgJjFYGxmsBYQ2CsJTDWERjrCYwNBMZGAmMTgbGZwNhCYGwlMLYRGNsJjB0Exk4CYxeBsZvA2ENg7CUw9hEY+wmMAwTGQQLjEIFxmMA4QmAcJTCOERjHCYwTBMZJAuMUgXGawDhDYJwlMM4RGOcJjAsExkUC4xKBcZnAuEJgXCUwrhEY1wmMGwTGTQLjFoFxm8C4Q2DcJTDuERj3CYwHBMZDAuMRgfGYwHhCYDwlMJ4RGM8JjBcExksC4xWB8ZrAeENgvCUw3hEY7wmMDwTGRwLjE4HxmcD4QmB8JTC+ERjfCYwfBMZPAuMXgeEE9D7DH4Hhn8AIQGAEJDACERiBCYwgBEZQAiMYgRGcwAhBYIQkMEIRGKEJjDAERlgCIxyBEZ7AiEBgRCQwIhEYkQmMKARGVAIjGoERncCIQWDEJDBiERixCYw4BIaLwIhLYMQjMOITGAkIjIQERiICIzGBkYTASEpgJCMwkhMYKQiMlARGKgIjNYGRhsDwITDSEhjpCIz0BEYGAiMjgZGJwMhMYGQhMLISGNkIjOwERg4CIyeBkYvAyE1g5CEw8hIY+QiM/ARGAQKjIIFRiMAoTGAUITCKEhjFCIziBEYJAqMkgVGKwChNYJQhMMoSGOUIjPIERgUCoyKBUYnAqExgVCEwqhIY1QiM6gRGDQKjJoFRi8CoTWDUITDqEhj1CIz6BEYDAqMhgdGIwGhMYDQhMJoSGM0IjOYERgsCoyWB0YrAaE1gtCEw2hIY7QiM9gRGBwKjI4HRicDoTGB0ITC6EhjdCIzuBEYPAqMngdGLwOhNYPQhMPoSGP0IjP4ExgACYyCBMYjAGExgDCEwhhIYwwiM4QTGCAJjJIExisAYTWCMITDGEhjjCIzxBMYEAmMigTGJwJhMYEwhMKYSGNMIjOkExgwCYyaBMYvAmE1gzCEw5hIY8wiM+QTGAgJjIYGxiMBYTGAsITCWEhjLCIzlBMYKAmMlgbGKwFhNYKwhMNYSGOsIjPUExgYCYyOBsYnA2ExgbCEwthIY2wiM7QTGDgJjJ4Gxi8DYTWDsITD2Ehj7CIz9BMYBAuMggXGIwDhMYBwhMI4SGMcIjOMExgkC4ySBcYrAOE1gnCEwzhIY5wiM8wTGBQLjIoFxicC4TGBcITCuEhjXCIzrBMYNAuMmgXGLwLhNYNwhMO4SGPcIjPsExgMC4yGB8YjAeExgPCEwnhIYzwiM5wTGCwLjJYHxisB4TWC8ITDeEhjvCIz3BMYHAuMjgfGJwPhMYHwhML4SGN8IjO8Exg8C4yeB8YvAcAJ5n+GPwPBPYAQgMAISGIEIjMAERhACIyiBEYzACE5ghCAwQhIYoQiM0ARGGAIjLIERjsAIT2BEIDAiEhiRCIzIBEYUAiMqgRGNwIhOYMQgMGISGLEIjNgERhwCw0VgxCUw4hEY8QmMBARGQgIjEYGRmMBIQmAkJTCSERjJCYwUBEZKAiMVgZGawEhDYPgQGGkJjHQERnoCIwOBkZHAyERgZCYwshAYWQmMbARGdgIjB4GRk8DIRWDkJjDyEBh5CYx8BEZ+AqMAgVGQwChEYBQmMIoQGEUJjGIERnECowSBUZLAKEVglCYwyhAYZQmMcgRGeQKjAoFRkcCoRGBUJjCqEBhVCYxqBEZ1AqMGgVGTwKhFYNQmMOoQGHUJjHoERn0CowGB0ZDAaERgNCYwmhAYTQmMZgRGcwKjBYHRksBoRWC0JjDaEBhtCYx2BEZ7AqMDgdGRwOhEYHQmMLoQGF0JjG4ERncCoweB0ZPA6EVg9CYw+hAYfQmMfgRGfwJjAIExkMAYRGAMJjCGEBhDCYxhBMZwAmMEgTGSwBhFYIwmMMYQGGMJjHEExngCYwKBMZHAmERgTCYwphAYUwmMaQTGdAJjBoExk8CYRWDMJjDmEBhzCYx5BMZ8AmMBgbGQwFhEYCwmMJYQGEsJjGUExnICYwWBsZLAWEVgrCYw1hAYawmMdQTGegJjA4GxkcDYRGBsJjC2EBhbCYxtBMZ2AmMHgbGTwNhFYOwmMPYQGHsJjH0Exn4C4wCBcZDAOERgHCYwjhAYRwmMYwTGcQLjBIFxksA4RWCcJjDOEBhnCYxzBMZ5AuMCgXGRwLhEYFwmMK4QGFcJjGsExnUC4waBcZPAuEVg3CYw7hAYdwmMewTGfQLjAYHxkMB4RGA8JjCeEBhPCYxnBMZzAuMFgfGSwHhFYLwmMN4QGG8JjHcExnsC4wOB8ZHA+ERgfCYwvhAYXwmMbwTGdwLjB4Hxk8D4RWA4gb3P8Edg+CcwAhAYAQmMQARGYAIjCIERlMAIRmAEJzBCEBghCYxQBEZoAiMMgRGWwAhHYIQnMCIQGBEJjEgERmQCIwqBEZXAiEZgRCcwYhAYMQmMWARGbAIjDoHhIjDiEhjxCIz4BEYCAiMhgZGIwEhMYCQhMJISGMkIjOQERgoCIyWBkYrASE1gpCEwfAiMtARGOgIjPYGRgcDISGBkIjAyExhZCIysBEY2AiM7gZGDwMhJYOQiMHITGHkIjLwERj4CIz+BUYDAKEhgFCIwChMYRQiMogRGMQKjOIFRgsAoSWCUIjBKExhlCIyyBEY5AqM8gVGBwKhIYFQiMCoTGFUIjKoERjUCozqBUYPAqElg1CIwahMYdQiMugRGPQKjPoHRgMBoSGA0IjAaExhNCIymBEYzAqM5gdGCwGhJYLQiMFoTGG0IjLYERjsCoz2B0YHA6EhgdCIwOhMYXQiMrgRGNwKjO4HRg8DoSWD0IjB6Exh9CIy+BEY/AqM/gTGAwBhIYAwiMAYTGEMIjKEExjACYziBMYLAGElgjCIwRhMYYwiMsQTGOAJjPIExgcCYSGBMIjAmExhTCIypBMY0AmM6gTGDwJhJYMwiMGYTGHMIjLkExjwCYz6BsYDAWEhgLCIwFhMYSwiMpQTGMgJjOYGxgsBYSWCsIjBWExhrCIy1BMY6AmM9gbGBwNhIYGwiMDYTGFsIjK0ExjYCYzuBsYPA2Elg7CIwdhMYewiMvQTGPgJjP4FxgMA4SGAcIjAOExhHCIyjBMYxAuM4gXGCwDhJYJwiME4TGGcIjLMExjkC4zyBcYHAuEhgXCIwLhMYVwiMqwTGNQLjOoFxg8C4SWDcIjBuExh3CIy7BMY9AuM+gfGAwHhIYDwiMB4TGE8IjKcExjMC4zmB8YLAeElgvCIwXhMYbwiMtwTGOwLjPYHxgcD4SGB8IjA+ExhfCIyvBMY3AuM7gfGDwPhJYPwiMJwg3mf4IzD8ExgBCIyABEYgAiMwgRGEwAhKYAQjMIITGCEIjJAERigCIzSBEYbACEtghCMwwhMYEQiMiARGJAIjMoERhcCISmBEIzCiExgxCIyYBEYsAiM2gRGHwHARGHEJjHgERnwCIwGBkZDASERgJCYwkhAYSQmMZARGcgIjBYGRksBIRWCkJjDSEBg+BEZaAiMdgZGewMhAYGQkMDIRGJkJjCwERlYCIxuBkZ3AyEFg5CQwchEYuQmMPARGXgIjH4GRn8AoQGAUJDAKERiFCYwiBEZRAqMYgVGcwChBYJQkMEoRGKUJjDIERlkCoxyBUZ7AqEBgVCQwKhEYlQmMKgRGVQKjGoFRncCoQWDUJDBqERi1CYw6BEZdAqMegVGfwGhAYDQkMBoRGI0JjCYERlMCoxmB0ZzAaEFgtCQwWhEYrQmMNgRGWwKjHYHRnsDoQGB0JDA6ERidCYwuBEZXAqMbgdGdwOhBYPQkMHoRGL0JjD4ERl8Cox+B0Z/AGEBgDCQwBhEYgwmMIQTGUAJjGIExnMAYQWCMJDBGERijCYwxBMZYAmMcgTGewJhAYEwkMCYRGJMJjCkExlQCYxqBMZ3AmEFgzCQwZhEYswmMOQTGXAJjHoExn8BYQGAsJDAWERiLCYwlBMZSAmMZgbGcwFhBYKwkMFYRGKsJjDUExloCYx2BsZ7A2EBgbCQwNhEYmwmMLQTGVgJjG4GxncDYQWDsJDB2ERi7CYw9BMZeAmMfgbGfwDhAYBwkMA4RGIcJjCMExlEC4xiBcZzAOEFgnCQwThEYpwmMMwTGWQLjHIFxnsC4QGBcJDAuERiXCYwrBMZVAuMagXGdwLhBYNwkMG4RGLcJjDsExl0C4x6BcZ/AeEBgPCQwHhEYjwmMJwTGUwLjGYHxnMB4QWC8JDBeERivCYw3BMZbAuMdgfGewPjwB4w/4czz+QNOQElQSaC/+0RQYGasP/uFOggnyo0hv0GRP/ZPl/QHnBmxOJwAfr/r+DfOi3z+NRf7KDSAzkV/syD/oJT5GWnql2x7x2d20s2lC2zs06dyjSTpHhfusqX1mHx3Pox7Lf/5Er8/iD/T0/PHuQsczPn34n77A0DvxUA5/P1lUuHuX3QY5/cX9fzAHsuf08Hxu2NHv9/92x8uv1zy9/uva6k2ddlfm+r+D17+5efcl8L+5fMCInCLhfxT01/9cvwtBf6sWPaHX6b++vi+cRCn5b85/fNt802W6zu53yGU47c/UxFvv7h4fqzwsQC6/+D/+2fXP/+RK4AvbyuBx/jTX4Ob4Q/8NawEy4h+5VumXg72x/1XvwrOdvzuO8fB9vHXHy6/XPrLV8HVup81f/0quPpvvgqu+S98FZzt/NlCfPsquBoo+RrSV0HEae0ffhVc64Wvgqv/8Kvguj/9KugGrvuDr4LrgK+C6738VdD9a1j/B18F13v5q+Aa9XKwP+4fvwqG9eWz/lrCuf9w96+X5/3T3b9cnv+Pd3+/vOCf7/52eaEvd83Li3y7a1xe7Ovdf19e4vvd/7281A93PZeX+eWuXl7up7v/urzCb3f/5/JKP951X17l17tyebUD/Hnh97t/+8P1Hz73rz9h/vmzUf883PTX/2/r/g96/uXn3Jf6/IcPc+n07YvSJuCL3uZ/+EL06y8/TM/Nf+MZ/i+ef/3x/3+B+PvL//8XiP83v0D85c+d6n/5c8ffRuDPs03/pb/69M0fcdryD05hpq0ZEftkrYuFVm0t0rPnornmn/tb9OvWf/OvPjf+g8tf/1iTt/VP/+rTDdzq4/uC//o5W4G/+tzm5b/6dP8atvn4/leHf/2cbZZ/9emXsm/zw27/+icUsq/t4LdXPeXd/jf/j8v1l+nbx7Vw/P7Fp6Vf74pcKz/edf86Wvvt7v88XRs/3f3XK7f1y10tRDs/3PV0p73vd//3z2vfv2n67y8Bvn4X2fhq0cnx+/+z7+z4/S8iujh+/4uTro7f/6Knm+P3v5jq7vj9r057/Me7//dLec//dPf/XnV6/Ye7f3PV6f33d//u6v/8+ery21Wn79/d/furTr+/ufsfrjr9/+/d/3TVGfB/7v7Hq87Av979z1edQX+5+w9XncG/3/2nq86Q3+7+41VnqHn3n686wxy/fz3f8Yd/geT6y/Tlh7/hfr7rzxnh17uyh5F+vOte2Si/3f2f7Y72091/PcQYv9zVNxvrh7ue5x3n+93/bcJ4X+/+uzQTfLtr9Gui4/ev3ZMcv3/tnuz4/Wv3FMfvX7unOn7/2j3N8fvX7umO3792z3D8/rV7puP3r92zHL9/7Z7t+P1r9xzH71+7/+6bB//h6t998+A/Xf2bbx78x6v/95sH//nq//nmwT9c/es3D/7p6l++efCPV3//5sE/X/3tmwe+fe3e+Ydfu4PqdPntuj+/fZPif6769ZsU/7MHL3yT4n+267dvUvzrIfz0TQp9s3/4JsX/eZtd4N8nhXT+/dt77v97h/795U6du3SujPXve7vl5/ZI9kr2+fz+meg3L2f5/Z918of8lp7bNbjjt29W+Mbd/Yd9/98f6Hd1lgB/Y7z/D/8ZqL/74/66GN/YB/zOTm7DOehHzuHq86fZcA75zklgfvZf/+Q5oH+yHNS5TKf7cz33Dsv5iOSo5Nhf/uQJ8BdfX3748+1vcM27h4FOHf/DwqP+nYG7RwD/EyT/LsDdo4D/Scsv4se1dyd0ntR5zOjhKTmflpyRnLXsYVfg7ilgD+dI79gNuHsa8D9P8u8O3D0D+F+w7OE57d15nRd0njV6eFHOlySXJVcse9gDuHsR2MNV0jv2BO5eAvyvkfx7AXcvA/7XLXt4VXt3Ted1nVeMHt6Q803JLcltyx72Bu7eAPZwh/SOfYC7NwH/uyT/vsDdW4D/Pcse3tHe3dV5T+dto4f35fxA8lDyyLKH/YC794E9PCa9Y3/g7gPA/wnJfwBw9yHg/9Syh4+1d090PtX5yOjhMzk/l7yQvLTs4UDg7jNgD69I7zgIuPsc8H9N8h8M3H0B+L+x7OEr7d1rnW90vjR6+FbO7yTvJR8sezgEuPsW2MNH0jsOBe6+A/w/kfyHAXffA/6fLXv4UXv3SednnR+MHn6R81fJN8l3yx76/TclHX9fgD38IL2jn3+jVO5+Bfx/kvz9+pu37rvfAP9flj38ob37qfOXzu9GD5208nMS/5IAaX//THQPfvyN6X/ppfX7HgKm5byj336z/F93/QH+gUj+Y4C7/gH/wGnteuh+P/cMpDOwTnffPPeCyDmoJJgkuGUP/fIPJ3juBgH2EIL0jn74Byb+925QwD8kyd/3f4jj33eDAf6hLHsYQnsXUmconcGNHoaWcxhJWEk4yx76+g+oGHdDA3sIT3pH3/6hGfNuGMA/Askf+Kfm/YUF/CNa9jC89i6Czog6wxk9jCTnyJIokqj68yGcf+/g7364HD/9iO9mxbf4DPP3Rf0Bf5z7+p/82wRQBvD7mH/MAH6v8Y8ZwO8H/jED+L22P2YAvx/2xwzg96z+mAH8ftAfM4Dfs/ljBvD7Kn/M6O14n9HH8T4D+N7/HzOA76v/MQP43vcfM4DvT/8xA/je7x8zgO/P/jED+B7qHzOA70/+MQP4HuIfM4Dv8/0xA/ge2h8zgO9z/TED+F7UHzOA7/P8MQP4XswfM4Dvl/wxA/hexB8zgO8X/DED+Hv6P2YAf7/8xwzg72n/mPGn/21tlBPpD/8++n9/oP8g8X7gm9fR/C732z9I7Pnj3H/Da/6N829/AOjtz/l/+0FQzn5SwZB/o+ff/kD/8X3zrm9yH//w32WLOgHl8feJ5OTf8bvTZ5ITUBZ/X/5LTr5xvgbxu/8k0r8m9xvp38H8ncT5QXrLn8BbTiO95S/Sjt3/XTc/3v3LH4hx/JE4/kmcACROQBInEIkTmMQJQuIEJXGCkTjBSZwQJE5IEicUiROaxAlD4oQlccKROOFJnAgkTkQSJxKJE5nEiULiRCVxopE40UmcGCROTBInFokTm8SJ84ccb34PxvVfcvKNEzeo3/2nk/5+NB7p3eOTOAlInIQkTiISJzGJk4TESUriJCNxkpM4KUiclCROKhInNYmThsTxIXHSkjjpSJz0JE4GEicjiZOJxMlM4mQhcbKSONlInOwkTg4SJyeJk4vEyQ38PYwNJw/p15OXxMlH4uQncQqQOAVJnEIkTmESpwiJU5TEKUbiFCdxSpA4JUmcUiROaRKnDIlTlsQpR+KUJ3EqkDgVSZxKJE5lEqcKiVOVxKlG4lQncWqQODVJnFokTm0Spw6JU5fEqUfi1CdxGpA4DUmcRiROYxKnCYnTlMRpRuI0J3FakDgtSZxWJE5rEqcNidOWxGlH4rQncTqQOB1JnE4kTmcSpwuJ05XE6UbidCdxepA4PUmcXiRObxKnD4nTl8TpR+L0J3EGkDgDSZxBJM5gEmcIiTOUxBlG4gwncUaQOCNJnFEkzmgSZwyJM5bEGUfijCdxJpA4E0mcSSTOZBJnCokzlcSZRuJMJ3FmkDgzSZxZJM5sEmcOiTOXxJlH4swncRaQOAtJnEUkzmISZwmJs5TEWUbiLCdxVpA4K0mcVSTOahJnDYmz9g856H/3dh3wz63vJv3L8taTfu0bgF/7EtKvfSOpX5tInM0kzhYSZyuJs43E2U7i7CBxdpI4u0ic3STOHhJnL4mzj8TZT+IcIHEOkjiHSJzDJM4REucoiXOMxDlO4pwgcU6SOKdInNMkzhkS5yyJc47EOU/iXCBxLpI4l0icyyTOFRLnKolzjcS5TuLcIHFukji3SJzbJM4dEucuiXMP+N6W+cOb/z7B+6Tv6z0Afu0zSf8+wYd+dHr1OF5n8w/05v92xCPSezwG3mMe6fusT0i/9qfAr31GLI7TM8BpEek9npO+Lr4gcV6SOK9InNckzhsS5y2J847EeU/ifCBxPpI4n0iczyTOFxLnK4nzjcT5TuL8IHF+kji/SBwnGIfjj8TxT+IEIHECkjiBSJzAJE4QEicoiROMxAlO4oQgcUKSOKFInNAkThgSJyyJE47ECU/iRCBxIpI4kUicyCROFBInKokTjcSJTuLEIHFikjixSJzYJE4cEsdF4sQlceKROPFJnAQG5/+V329L+Ie/dm86JSI5Ib8Plvi/5OQbJwnQkUhpOU5JAaf9pN8LSkb6czY5iZOCxElJ4qQicVKTOGlIHB8SJy2Jk47ESU/iZCBxMpI4mUiczCROFhInK4mTjcTJTuLkIHFykji5SJzcJE4eEicviZOPxMlP4hQgcQqSOIVInMIkThESpyiJU4zEKU7ilCBxSpI4pUic0iROGRKnLIlTjsQpT+JUIHEqkjiVSJzKJE4VEqcqiVONxKlO4tQgcWqSOLVInNokTh0Spy6JU4/EqU/iNCBxGpI4jUicxiROExKnKYnTjMRpTuK0IHFakjitSJzWJE4bEqctidOOxGlP4nQgcTqSOJ1InM4kThcSpyuJ043E6U7i9CBxepI4vUic3iROHxKnL4nTj8TpT+IMIHEGkjiDSJzBJM4QEmcoiTOMxBlO4owgcUaSOKNInNEkzhgSZyyJM47EGU/iTCBxJpI4k0icySTOFBJnKokzjcSZTuLMIHFmkjizSJzZJM4cEmcuiTOPxJlP4iwgcRaSOItInMUkzhISZymJs4zEWU7irCBxVpI4q0ic1STOGhJnLYmzjsRZT+JsIHE2kjibSJzNJM4WEmcribONxNlO4uwgcXaSOLtInN0kzh4SZy+Js4/E2U/iHDA4yL9DAuUcJP16DpE4h0mcIyTOURLnGIlznMQ5QeKcJHFOkTinSZwzJM5ZEucciXOexLlA4lwkcS6ROJdJnCskzlUS5xqJc53EuUHi3CRxbpE4t0mcOyTOXRLnHolzn8R5QOI8JHEekTiPSZwnJM5TEucZifOcxHlB4rwkcV6ROK9JnDckzlsS5x2J857E+UDifCRxPpE4n0mcLyTOVxLnG4nzncT5QeL8JHF+kThOcA7HH4njn8QJQOIEJHECkTiBSZwgJE5QEicYiROcxAlB4oQkcUKROKFJnDAkTlgSJxyJE57EiUDiRCRxIpE4kUmcKCROVBInGokTncSJQeLEJHFikTixSZw4JI6LxIlL4sQjceKTOAlInIQkTiISJzGJk4TESUriJCNxkpM4KUiclCROKhInNYmThsTxIXHSkjjpSJz0JE4GEicjiZOJxMlM4mQhcbKSONlInOwkTg4SJyeJk4vEyU3i5CFx8pI4+Uic/CROARKnIIlTiMQpTOIUIXGKkjjFSJziJE4JEqckiVOKxClN4pQhccqSOOVInPIkTgUSpyKJU4nEqUziVCFxqpI41Uic6iRODRKnJolTi8SpTeLUIXHqkjj1SJz6JE4DEqchidOIxGlM4jQhcZqSOM1InOYkTgsSpyWJ04rEaU3itCFx2pI47Uic9iROBxKnI4nTicTpTOJ0IXG6kjjdSJzuJE4PEqcnidOLxOlN4vQhcfqSOP1InP4kzgASZyCJM4jEGUziDCFxhpI4w0ic4STOCBJnJIkzisQZTeKMIXHGkjjjSJzxJM4EEmciiTOJxJlM4kwhcaaSONNInOkkzgwSZyaJM4vEmU3izCFx5pI480ic+STOAhJnIYmziMRZTOIsIXGWkjjLSJzlJM4KEmclibOKxFlN4qwhcdaSOOtInPUkzgYSZyOJs4nE2UzibCFxtpI420ic7STODhJnJ4mzi8TZTeLsIXH2kjj7SJz9JM4BEucgiXOIxDlM4hwhcY6SOMdInOMkzgkS5ySJc4rEOU3inCFxzpI450ic8yTOBRLnIolzicS5TOJcIXGukjjXSJzrJM4NEucmiXOLxLlN4twhce6SOPdInPskzgMS5yGJ84jEeUziPCFxnpI4z0ic5yTOCxLnJYnzisR5TeK8IXHekjjvSJz3JM4HEucjifOJxPlM4nwhcb6SON9InO8kzg8S5yeJ84vEcUJwOP5IHP8kTgASJyCJE4jECUziBCFxgpI4wUic4CROCBInJIkTisQJTeKEIXHCkjjhSJzwJE4EEiciiROJxIlM4kQhcaKSONFInOgkTgwSJyaJE4vEiU3ixCFxXCROXBInHokTn8RJQOIkJHESkTiJSZwkJE5SEicZiZOcxElB4qQkcVKROKlJnDQkjg+Jk5bESUfipCdxMpA4GUmcTH/I8f8XTpr6Jdve8ZmddHPpAhv79KlcI0m6x4W7bGk9Jt+dD+Ney3+ewPG7U+b/kpNvnCwh/O4fLS1nTwEdv/tnJb1dIMfvTtlIToEdvztlJzkFcfzulIPkFNTxu1NOklMwx+9OuUhOwR2/O+UmOYVw/O6Uh+QU0vG7U16SUyjH7075SE6hHb875Sc5hXH87lSA5BTW8btTQZJTOMfvToVITuEdvzsVJjlFcPzuVITkFNHxu1NRklMkx+9OxUhOkR2/OxUnOUVx/O5UguQU1fG7U0mSUzTH706lSE7RHb87lSY5xXD87lSG5BTT8btTWZJTLMfvTuVITrEdvzuVJznFcfzuVIHk5HL87lSR5BTX8btTJZJTPMfvTpVJTvEdvztVAZwCqEv9AP/6vz/KNyY+ST5Lvki+Sr5Jvkt+SH5Kfrm/eSHfLPAn8S8JIAkoCSQJLAkiCSoJJgkuCSEJKQklCS0JIwkrCScJL4kgiSiJJIksiSKJKokmiS6JIYkpiSWJLYkjcUniSuJJ4ksSSBJKEkkSS5JIkkqSSZJLUkhSSlJJUkvSSHwkaSXpJOklGSQZJZkkmSVZJFkl2STZJTkkOSW5JLkleSR5Jfkk+SUFJAUlhSSFJUUkRSXFJMUlJSQlJaUkpSVlJGUl5STlJRUkFSWVJJUlVSRVJdUk1SU1JDUltSS1JXUkdSX1JPUlDSQNJY0kjSVNJE0lzSTNJS0kLSWtJK0lbSRtJe0k7SUdJB0lnSSdJV0kXSXdJN0lPSQ9Jb0kvSV9JH0l/ST9JQMkAyWDJIMlQyRDJcMkwyUjJCMloySjJWMkYyXjJOMlEyQTJZMkkyVTJFMl0yTTJTMkMyWzJLMlcyRzJfMk8yULJAsliySLJUskSyXLJMslKyQrJaskqyVrJGsl6yTrJRskGyWbJJslWyRbJdsk2yU7JDsluyS7JXskeyX7JPslByQHJYckhyVHJEclxyTHJSckJyWnJKclZyRnJeck5yUXJBcllySXJVckVyXXJNclNyQ3JbcktyV3JHcl9yT3JQ8kDyWPJI8lTyRPJc8kzyUvJC8lrySvJW8kbyXvJO8lHyQfJZ8knyVfJF8l3yTfJT8kPyW/JO5vzPmT+JcEkASUBJIElgSRBJUEkwSXhJCElISShJaEkYSVhJOEl0SQRJREkkSWRJFElUSTRJfEkMSUxJLElsSRuCRxJfEk8SUJJAkliSSJJUkkSSXJJMklKSQpJakkqSVpJD6StJJ0kvSSDJKMkkySzJIskqySbJLskhySnJJcktySPJK8knyS/JICkoKSQpLCkiKSopJikuKSEpKSklKS0pIykrKScpLykgqSipJKksqSKpKqkmqS6pIakpqSWpLakjqSupJ6kvqSBpKGkkaSxpImkqaSZpLmkhaSlpJWktaSNpK2knaS9pIOko6STpLOki6SrpJuku6SHpKekl6S3pI+kr6SfpL+kgGSgZJBksGSIZKhkmGS4ZIRkpGSUZLRkjGSsZJxkvGSCZKJkkmSyZIpkqmSaZLpkhmSmZJZktmSOZK5knmS+ZIFkoWSRZLFkiWSpZJlkuWSFZKVklWS1ZI1krWSdZL1kg2SjZJNks2SLZKtkm2S7ZIdkp2SXZLdkj2SvZJ9kv2SA5KDkkOSw5IjkqOSY5LjkhOSk5JTktOSM5KzknOS85ILkouSS5LLkiuSq5JrkuuSG5KbkluS25I7kruSe5L7kgeSh5JHkseSJ5KnkmeS55IXkpeSV5LXkjeSt5J3kv+PvSuBk6K43j3ssDCwMCAeKKirqCjghYgoKiIIoiAgAkajcgZRBOXwSoy7CN54gbfGxTuJR+77n8SY25j7NPcdcx/mvv6v4rzdb799XdPdU7OMMv37fb+d7ap6r+rVq1evXldXvyT4s+Avgr8K/ib4u+Afgn8K/iX4t+A/gv8KXBA8J+ghaBDkBT0FjYJegt6CgqCPoK+gSdBP0F9QFAwQDBTsIBgk2FGwk2BnwS6CwYJdBbsJhgiGCnYX7CHY071HI9hLsLdgmGAfwb6C/QTDBfsLDhCMEIwUjBIcKDhIcLDgEMGhgtGCwwRjBIcLxgqOEIwTHCk4SjBecLTgGMGxggmC4wQTBccLJgkmC04QTBG479S7b8i777u7b6+776K7b5a774m7b32773C7b2S771e7b0u77z67bzK77yW7bxm77wy7bwC77/O6b+e679q6b86678G6b7W676i6b5y674+6b4O673a6b2q67126b1G670S6bzi67yu6bx+67xK6bwa67/m5b+257+C5b9S578e5b7u57665b6K575W5b4m573y5b3C572O5b1e570q5bz657zG5byW57xi5bwy57/+4b/O47+a4b9q47824b8G477S4b6i475u4b4+474K4b3a472m4b12471C4b0S47ze4byu47x64bxK47wW4s/zdOfvuDHx3Pr07O96d6+7OXHfnobuzyt054u6Mb3f+tjsb251b7c6Uduc9u7OY3TnJ7gxjd76wO/vXncvrzsx159m6s2bdObDujFZ3fqo729SdO+rOBHXndbqzNN05l+4MSnc+pDu70Z2r6M48dOcRurMC3Tl+7ow9d/6dO5vOnRvnznRz5625s9DcOWXuDDF3vpc7e8udi+XOrHLnSbmzntw5TO6MJHd+kTtbyJ37487kcefluLNs3Dkz7gwYdz6LOzvFnWvizhxx54G4szrcORrujAt3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",
      "custom_attributes": [
        "external",
        "private"
      ],
      "debug_symbols": "TL3LzjQ7j5x7L2vsQelAiuxb2QNjex+MBhpuwIdRw/fuNxmiIib9PdH/ehXKlBiVlcXK+o9//t//77/8r//6n//1v/3///4//vmX/+s//vkv//1f/+3f/vW//ud/+/f/5//+n//67//t7//7H//8vv8z9j//Ms3X//5P/4xPr/znX8Z/+mf/8M/APxP/LPyz8Y/hH8c/B/8E/sEohlEMoxhGMYxiGMUwimEUwyiGUQyjOEZxjOIYxTGKYxTHKI5RHKM4RnGMcjDKwSgHoxyMcjDKwSgHoxyMcjDKwSiBUQKjBEYJjBIYJTBKYJTAKIFRAqMkRkmMkhglMUpilMQoiVESoyRGSYwyfr/777j/zvvvuv/u+6/df/3+e+6/cf+944073rjjjTveuOONO964442/8db377n/xv038e/8G8+/f8f9d95/1/33b7z8/v3Gqz/whtMQDXlh/Rq+WZ4PZsNq2A3fyPGBN5yGb+TvKGrHf1B7vuBv5Lk/mA2rYTdYgzechmjIC18dAHpk65GtR/7qYX5n5asIgDechmjIC19tAEbDbFgNPbL3yN4je4/sPbL3yKdHPj3y6ZFPj3x65NMjnx759MinRz498ldD81uCr4oAs2E17AZr8IbTEA15IXvk7JGzR84eOXvk7JGzR84eOXvkvCPP369hNMyG1bAbrMEbTkM09MijRx498uiRR488euTRI48eefTIo0cePfLskWePPHvk2SPPHnn2yLNHnj3y7JFnj7x65NUjrx559cirR1498uqRV4+8euTVI+8eeffIu0fePfLukXeP/NXgGh+chmjIC18NAkbDbFgNu8EaemTrka1H/mpw/VXu/GoQMBq+kfOD1bAbrMEbTkM05IWvBgGjoUc+PfLpkc9NpHm84TREw02kGb+G0TAbVsNu6JGjR44e+avBPT/IC18NAkbDbFgNu8EavOE09Mh5R16/X8No+EZeH6yG3WAN3nAaoiEvfDUIGA098uiRR4/81aD9PvCG0xANeeGrQcBomA2rYTf0yLNHnj3y7JFnj7x65NUjrx559cirR1498uqRV4+8euTVI+8eeffIu0fePfLukXePvHvk3SPvHnn3yNYjW49sPbL1yNYjW49sPbL1yNYjW4/sPbL3yN4je4/sPbL3yN4je4/sPbL3yKdHPj3y6ZFPj3x65NMjnx759MinRz49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V+fj1fl4dT5enY9X5+PV+Xh1Pl6dj1fn49X5eHU+Xp2PV+fj1fl4dT5enY9X5+PV+Xh1Pl6dj1fn49X5eHU+Xp2PV+fj1fl4dT5enY9X5+PV+Xh1Pl6dj1fn49X5eHU+Xp2PV+fj1fl4dT5enY9X5+PV+Xh1Pl6dj1fn49X5eHU+Xp2PV+fj1fl4dT5enY9X5+PV+Xh1Pl6dj1fn49X5eHU+Xp2PV+fj1fl4dT5enY9X5+PV+Xh1Pl6dj1fn49X5eHU+Xp2PV+fj1fl4dT5enY9X5+PV+Xh1Pl6dj1fn49X5fHU+X53PV+fz1fl8dT5fnc9X5/PV+Xx1Pl+dz1fn89X5fHU+X53PV+fz1fl8dT5fnc9X5/PV+Xx1Pl+dz1fn89X5fHU+X53PV+fz1fl8dT5fnc9X5/PV+Xx1Pl+dz1fn89X5fHU+X53PV+fz1fl8dT5fnc9X5/PV+Xx1Pl+dz1fn89X5fHU+X53PV+fz1fl8dT5fnc9X5/PV+Xx1Pl+dz1fn89X5fHU+X53PV+fz1fl8dT5fnc9X5/PV+Xx1Pl+dz1fn89X5fHU+X53PV+fz1fl8dT5fnc9X5/PV+Xx1Pl+dz1fn89X5fHU+X53PV+fz1fl8dT5fnc9X5/PV+Xx1Pl+dz1fn89X5fHU+X53PV+fz1fl6db5ena9X5+vV+Xp1vl6dr1fn69X5enW+Xp2vV+fr1fl6db5ena9X5+vV+Xp1vl6dr1fn69X5enW+Xp2vV+fr1fl6db5ena9X5+vV+Xp1vl6dr1fn69X5enW+Xp2vV+fr1fl6db5ena9X5+vV+Xp1vl6dr1fn69X5enW+Xp1XC5JXS+9X55fi0Z+HV+PwV+eXxqP5aD3aj+yRPzqP4tHz8Ofhz8Ofhz8Pfx7+PPx5+PPw5+HP4zyP8zzO8zjP4zyP8zzO8zjP4zyP8zziecTziOcRzyOeRzyPeB7xPOJ5xPPI55HPI59HPo98Hvk88nnk88jnke1RjUuXxqP5aD3aj+yRPzqP4tHzGM9jPI/xPMbzGM9jPI/xPMbzGM9jPI/5PObzmM9jPo/5PObzmM9jPo/5PObzWM9jPY/1PNbzWM9jPY/1PNbzWM9jPY/9PPbz2M9jP4/9PPbz2M9jP4/9PF6d71fn+9X5fnW+X51Xu5NbkT3yR+dRPMqmqnPQeDQfrUfPw5+HPw9/Hv48/Hmc53Gex3ke53mc53Gex3ke53mc53GeRzyPeB7xPOJ5xPOI5xHPI55HPI94Hvk88nnk88jnkc8jn0c+j3we+TyyPao56tJ4NB+tR/uRPfJH51E8eh7jeYznMZ7HeB7jeYznMZ7HeB7jeYznMZ/HfB7zecznMZ/HfB7zecznMZ/HfB7reaznsZ7Heh7reaznsZ7Heh7reaznsZ/Hfh77eeznsZ/Hfh77eeznsZ/Hfh72POx52POw5/Hq3F6d26tze3Vur87t1bm9OrdX5/bq3F6d26tze3Vur87t1bm9OrdX5/bq3F6d26tze3Vur87t1bm9OrdX5/bq3F6d26tze3Ve7VYeRevRfmSP/NF5FI+yqeocNB49j3we+TzyeeTzyOeRzyPboxqwLo1H89F6tB/ZI3/053F2UTzKpq/OL41H89F6tB/ZI3/0PL46P1aUTV+dXxqP5qP1aD+yR/7oPHoe83ms57Gex1fn5xStR/uRPfJH51E8yqavzi+NR89jP4/9PPbz2M9jP4/9PPbzsOdhz8Oehz0Pex72POx52POw52HPw5+HPw9/Hv48/Hn48/Dn8dX5qR321fmlbPrq/GTReDQf/XnEKNqP7NGfR9Ru+ur8Ujz688jfR1+dXxqP/jyyRvnq/NJ+9OeRq8gfnUfxKJu+Or80Hs1H69F+9DzyeeTz+Oo86zi+Oi+qJq9Ln8cpmo/Wo/3IHvmj8ygeZdNX55eex3ge43l8dZ5RZI/80XkUj7Lpq/NL49F8tB49j/k85vOYz2M+j/k81vNYz2M9j/U81vNYz2M9j/U81vNYz2M/j/089vPYz2M/j/089vPYz2M/j/087HnY87DnYc/Dnoc9D3se9jzsedjz8Ofhz8Ofhz8Pfx7+PPx5+PPw5+HP4zyP8zzO8zjP4zyP8zzO8zjP4zyP8zziecTziOcRzyOeRzyPeB7xPOJ5xPPI55HPI59HPo98Hvk88nnk88jnke1RjWSXxqP5aD3aj+yRPzqP4tHzGM9jPI/6jvtvFC7iJhrRiYcYxHz41XvjINJt0m3SbdJt0m3SbdJt0m3RbdFt0W3RbdFt0W3RbdFt0W3RbdNt023TbdNt023TbdNt023TbdPN6GZ0M7oZ3YxuRjejm9HN6GZ0c7o53ZxuTjenm9PN6eZ0c7o53Q7dDt0O3Q7dDt0O3Q7dDt0O3Q7dgm5Bt6Bb0C3oFnQLugXdgm5Bt6Rb0i3plnRLuiXdkm5Jt6RbPrdqgmscxElcxE00ohMPMYh0G3QbdGOWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJYks+a7GE1kCHMRJXMRNNKITDzGIdEu6Jd2QJVa4iJtoRCceYhDz4vwhS4CDOImLuIlGdOIhBpFug26DboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptum25GN2TJKZzERfzcxq/QiE48xCDmw8qSi4M4iYtIN6eb083p5nRzuh26Hboduh26Hboduh26Hboduh26Bd2CbkG3oFvQLegWdAu6Bd2Cbkm3pFvSLemWdEu6Jd2Sbkm3fG54RtfFQZzERdxEIzrxEINIt0G3QbdBt0G3QbdBt0G3QbdBt0G3SbdJt0m3SbdJt0m3SbdJt0m3SbdFt0W3RbdFt0W3RbdFt0W3RbdFt023TbdNt023TbdNt023TbdNt003o5vRzehmdGOWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJYpYsZslilixmyWKWLGbJYpYsZslilixmyWKWLGbJYpYsZslilixmyWKWLGbJYpYsZMn6EFkCHMRJXMRNNKITDzGIdFt0W3RDluzCRdxEIzrxEIOYD5ElwEGk26bbptum26bbptum26ab0c3oZnQzuhndjG5GN6Ob0c3o5nRzujndnG5ON6eb083p5nRzuh26Hboduh26Hboduh26Hboduh26Bd2CbkG3oFvQLegWdAu6Bd2Cbkm3pFvSLemWdEu6Jd2Sbkm3fG779yMO4iQu4iYa0Ynl5oVBzIfIkiwcxElcxE00ohMPMYj5cNJt0m3SbdJt0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0W3TbdNt023TbdNt023TbdNt023TzehmdDO6Gd2MbkY3o5vRzehmdHO6Od2cbk43p5vTzenmdHO6Od0O3Q7dDt0O3Q7dDt0O3Q7dDt0O3YJuQbegW9At6BZ0C7oF3YJuQbekW9It6ZZ0S7ol3ZJuSbekWz43+/2IgziJi7iJRnTiIQaRbswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZslhlhxmyWGWVCvq32cfhZtoRCceYhDzYWXJxUGcRLoNug26VZZ8P7cxqzG1MYj5sLLk4iBO4iJuohHpNuk26Tbptui26Lbotui26FZZMq3QiYcYxHxYWXJxECdxETeRbptum26bbptuRjejm9HN6GZ0M7oZ3YxuRjejm9PN6eZ0c7o53ZxuTjenm9PN6Xboduh26Hboduh26Hboduh26HboFnQLugXdgm5Bt6Bb0C3oFnQLuiXdkm5Jt6Rb0i3plnRLuiXd8rlVr2vjIE7iIm6iEZ14iEGk26DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26IbsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWYK+13kKN9GITjzEIOZDZAlwECeRbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptum25GN6Ob0c3oZnQzuhndjG5GN6Ob083p5nRzujndnG5ON6eb083pduh26HboduiGLMlCIzrxc6uf90Lf68V8WFlycRAncRE30YhOpFvQLeiWdEu6Jd2Sbkm3pFvSLemWdMt2W+h7vTiIk7iIm2hEJx5iEOk26DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26Tbptui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26WZ0M7oZ3YxuRjejm9HN6GZ0M7o53ZxuTjenm9PN6eZ0c7o53Zxuh26Hboduh26Hboduh26Hboduh25Bt6Bb0C3oFnQLugXdgm5Bt6Bb0i3plnRLuiXdkm5Jt6Rb0o1ZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1mCvtfvJ3UX+l4vBrHc/ENkCXAQJ3ERN9GITjzEINLN6YYs+RVO4iJuohGdeIhBzIfIEiDdDt0O3Q7dDt0O3Q7dDt0O3YJuQbegW9At6BZ0C7oF3YJuQbekW9It6ZZ0S7ol3ZJuSbekWz439L1eHMRJXMRNNKITDzGIdBt0G3QbdBt0qyzZVmhEJ35u2wuDmA+RJadwECdxETfRiE48xCDmw0W3RbdFt0W3RbdFt0W3RbdFt0W3TbdNt023TbdNt023TbdNt023TTejm9HN6GZ0M7oZ3YxuRjejm9HN6eZ0c7o53ZxuTjenm9PN6eZ0O3Q7dDt0O3Q7dDt0O3Q7dDt0O3QLugXdgm5Bt6Bb0C3oFnQLugXdkm5Jt6Rb0i3plnRLuiXdkm753ND3enEQJ3ERN9GITjzEINJt0A33XnfhJC7iJhrRiYcYxHyIe69Auk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptum26Gd2MbkY3o5vRzehmdDO6Gd2Mbk43p5vTzenmdHO6Od2cbk43p9uh26Hboduh26Hboduh26HboduhW9At6BZ0C7oF3YJuQbegW9At6JZ0S7ol3ZJuSbekW9It6ZZ0y+eGvteLg/i52ShcxE383Az/rRMP8XMzL8yHlSUXB3ESF3ETjejEQ6TboNuk26TbpNuk26TbpNuk26TbpNuk26Lbotui26Lbotui26Lbotui26Lbptum26bbptum26bbptum26bbppvRzehmdDO6Gd2MbkY3o5vRzejmdHO6Od2cbk43p5vTzenmdHO6Hboduh26Hboduh26Hboduh26HboF3YJuQbegW9At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JeCVgFcCXgl4JeCVgFcCXgl4JeCVgFcCXgl4JeCVgFcCXgl4JeCVgFcCXgl4JeCVgFcCXgl4JeCVgFcCXgl4JeCVglcKXil4peCVglcKXil4peCVglcKXil4peCVglcKXil4peCVglcKXil4peCVglcKXil4peCVglcKXil4peCVglcKXil4peCVglcKXil4peCVglcKXil4peCVglcKXil4peCVglcKXil4peCVglcKXil4peCVglcKXil4peCVglcKXil4peCVglcKXil4peCVglcKXil4peCVglcKXil4peCVglcKXil4peCVglcKXil4peCVglcKXil4peCVglcKXil4peCVglcKXil4peCVglcKXil4peCVglcKXil4peBVAa8KeFXAqwJeFfCqgFcFvCrgVQGvCnhVwKsCXhXwqoBXBbwq4FUBrwp4VcCrAl4V8KqAVwW8KuBVAa8KeFXAqwJeFfCqgFcFvCrgVQGvCnhVwKsCXhXwqoBXBbwq4FUBrwp4VcCrAl4V8KqAVwW8KuBVAa8KeFXAqwJeFfCqgFcFvCrgVQGvCnhVwKsCXhXwqoBXBbwq4FUBrwp4VcCrAl4V8KqAVwW8KuBVAa8KeFXAqwJeFfCqgFcFvCrgVQGvCnhVwKsCXhXwqoBXBbwq4FUBrwp4VcCrAl4V8KqAVwW8KuBVAa8KeFXAqwJeGXhl4JWBVwZeGXhl4JWBVwZeGXhl4JWBVwZeGXhl4JWBVwZeGXhl4JWBVwZeGXhl4JWBVwZeGXhl4JWBVwZeGXhl4JWBVwZeGXhl4JWBVwZeGXhl4JWBVwZeGXhl4JWBVwZeGXhl4JWBVwZeGXhl4JWBVwZeGXhl4JWBVwZeGXhl4JWBVwZeGXhl4JWBVwZeGXhl4JWBVwZeGXhl4JWBVwZeGXhl4JWBVwZeGXhl4JWBVwZeGXhl4JWBVwZeGXhl4JWBVwZeGXhl4JWBVwZeGXhl4JWBVwZeGXhl4JWBVwZeOXjl4JWDVw5eOXjl4JWDVw5eOXjl4JWDVw5eOXjl4JWDVw5eOXjl4JWDVw5eOXjl4JWDVw5eOXjl4JWDVw5eOXjl4JWDVw5eOXjl4JWDVw5eOXjl4JWDVw5eOXjl4JWDVw5eOXjl4JWDVw5eOXjl4JWDVw5eOXjl4JWDVw5eOXjl4JWDVw5eOXjl4JWDVw5eOXjl4JWDVw5eOXjl4JWDVw5eOXjl4JWDVw5eOXjl4JWDVw5eOXjl4JWDVw5eOXjl4JWDVw5eOXjl4JWDVw5eOXjl4JWDVw5eOXjl4JWDVw5eVfCqglcVvKrgVQWvKnhVwasKXlXwqoJXFbyq4FUFryp4VcGrCl5V8KqCVxW8quBVBa8qeFXBqwpeVfCqglcVvKrgVQWvKnhVwasKXlXwqoJXFbyq4FUFryp4VcGrCl5V8KqCVxW8quBVBa8qeFXBqwpeVfCqglcVvKrgVQWvKnhVwasKXlXwqoJXFbyq4FUFryp4VcGrCl5V8KqCVxW8quBVBa8qeFXBqwpeVfCqglcVvKrgVQWvKnhVwasKXlXwqoJXFbyq4FUFryp4VcGrCl5V8KqCVxW8quBVBa8qeFXBqwpeVfCqglcVvKrgVQOvGnjVwKsGXjXwqoFXDbxq4FUDrxp41cCrBl418KqBVw28auBVA68aeNXAqwZeNfCqgVcNvGrgVQOvGnjVwKsGXjXwqoFXDbxq4FUDrxp41cCrBl418KqBVw28auBVA68aeNXAqwZeNfCqgVcNvGrgVQOvGnjVwKsGXjXwqoFXDbxq4FUDrxp41cCrBl418KqBVw28auBVA68aeNXAqwZeNfCqgVcNvGrgVQOvGnjVwKsGXjXwqoFXDbxq4FUDrxp41cCrBl418KqBVw28auBVA68aeNXAqwZeNfCqgVcNvGrgVQOvGnjVwKt28kq2k1d7OaGcURaUFeWCsqHsKFeUUW9CvQn1JtSbUG9CvQn1JtSbUG9CvQn1ZtSbUW9GvRn1ZtSbUW9GvRn1ZtSbUa+gXkG9gnoF9QrqFdQrqFdQr6BeQb2KehX1KupV1KuoV1Gvol5FvYp6FfUW1FtQb0G9BfUW1FtQb0G9BfUW1FtQr6FeQ72Geg31Guo11Guo11CvoV5DvY56HfU66nXU66jXUa+jXke9jnod9VbUW1FvRb0V9VbUW1FvRb0V9VbUW1FvQ70N9TbU21BvQ70N9TbU21BvQ73gFfx2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47XsZ9YJX8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8Nv3MuoFr+C3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd++l1EveAW/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsV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bvDbDX67wW83+O0Gv93gtxv8doPfvpdRL3gFv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX77Xka94BX8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w2/fp0BQr6NeR72Oeh31Oup11Ouo11Gvo96Keivqrai3ot6Keivqrai3ot6Keivqbai3od6Gehvqbai3od6GehvqbagXvILf7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX77Xka94BX8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67f/rtlo+yonzUa3aUj3qtHmVH+ajX2lFuZ7nzyo/8nVd+5Oy88uPfdl59lhXlgrKh7ChXlNtZ7rz6LCeUj3rrcQydV59lRbmgbCg7yhXldpY7rz7LCeVe73EOO68+y4pyQdlQdpQryu0sd159lhPKqLeg3oJ6P3i1LwRtR9lQdpQryu0oH7/rg1d7uRzldJT9KGeU5aOcjvP/watRLigbyo5yRbmdZd9QTihnlFGvo15HvY56HfU66nXUW1FvRb0V9VbUW1FvRb0V9VbUW1FvRb0N9TbU21BvQ70N9TbU21BvQ70N9baz3sNvH+WEckZZUFaUC8qG8lFvLke5otzOctpQPurNx79NR72SjrKgfNQr8q/f/vB///iPv/zxf/31z//5h//x33v4f/7rb3/651/+/rfP8J//7388/uZ//eMvf/3rX/6ff/+Pf/z9T3/+3//1jz//+1///qePv/vD9vH/Pg7hfyb7Lad/2//j9Pnn+5/kvVmnj234/u23P0j/k/3g0semePuffP6zVOW3j/9//FHq/5Xmj/9K9SNfHlWU7bdSPv5IPv7oI6Gm30p6pCr5t+Iff63nQbXf8pGkjD/K+ltuH39k449Ef5Pjj/yRV/JvmkfevRL7+Ot6/ov2Wz+49vgX++86f9T46/R75yfFtaTzB+f0W97/7F//+rd//X8=",
      "is_unconstrained": false,
      "name": "receive_value",
      "verification_key": "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"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17765343328382640478": {
            "error_kind": "string",
            "string": "Source chain IDs and emitter addresses length mismatch"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "6788092787179896647": {
            "error_kind": "string",
            "string": "Caller is not owner"
          }
        },
        "parameters": [
          {
            "name": "source_chain_ids",
            "type": {
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 8,
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 16
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec"
            },
            "visibility": "private"
          },
          {
            "name": "emitter_addresses",
            "type": {
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 8,
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "public"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "register_emitter"
    },
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "14067204867181196045": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "14401109495927734611": {
            "error_kind": "string",
            "string": "Field failed to decompose into specified 16 limbs"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15546539856497705002": {
            "error_kind": "string",
            "string": "u16 to u8 conversion failed"
          },
          "15711892660910782274": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16216212843441549037": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "2014890719615096298": {
            "error_kind": "string",
            "string": "Field failed to decompose into specified 40 limbs"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "4648451262681811962": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "7555607922535724711": {
            "error_kind": "string",
            "string": "Preimage mismatch"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9589626482238399944": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "9921926525851912681": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "anchor_block_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "sponge_blob_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "destination_chain_id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 16
            },
            "visibility": "private"
          },
          {
            "name": "value",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "fee_nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "note_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 32,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "log",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "fields",
                                          "type": {
                                            "kind": "array",
                                            "length": 18,
                                            "type": {
                                              "kind": "field"
                                            }
                                          }
                                        },
                                        {
                                          "name": "length",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::log::Log"
                                    }
                                  },
                                  {
                                    "name": "note_hash_counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "anchor_block_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "sponge_blob_hash",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "private"
      ],
      "debug_symbols": "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6BZ0C7oF3YJuQbegW9It6ZZ0S7ol3ZJuSbekW9Itn1s1wTUO4iQu4iYa0YmHGES6DboNujFLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkkSWfFfjiSwBDuIkLuImGtGJhxhEuiXdkm7IEitcxE00ohMPMYh5cf6QJcBBnMRF3EQjOvEQg0i3QbdBt0G3QbdBt0G3QbdBt0G3QbdJt0m3SbdJt0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0W3TbdNt023TbdNt023TbdNt023TTejG7LkFE7iIn5u41doRCceYhDzYWXJxUGcxEWkm9PN6eZ0c7o53Q7dDt0O3Q7dDt0O3Q7dDt0O3Q7dgm5Bt6Bb0C3oFnQLugXdgm5Bt6Rb0i3plnRLuiXdkm5Jt6RbPjc8o+viIE7iIm6iEZ14iEGk26DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26ab0c3oZnQzujFLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksm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GcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySxB3+v3k7oLfa8Xg1hu/iGyBDiIk7iIm2hEJx5iEOnmdEOW/AoncRE30YhOPMQg5kNkCZBuh26Hboduh26Hboduh26HbkG3oFvQLegWdAu6Bd2CbkG3oFvSLemWdEu6Jd2Sbkm3pFvSLZ8b+l4vDuIkLuImGtGJhxhEug26DboNug26VZZsKzSiEz+37YVBzIfIklM4iJO4iJtoRCceYhDz4aLbotui26Lbotui26Lbotui26Lbptum26bbptum26bbptum26bbppvRzehmdDO6Gd2MbkY3o5vRzejmdHO6Od2cbk43p5vTzenmdHO6Hboduh26Hboduh26Hboduh26HboF3YJuQbegW9At6BZ0C7oF3YJuSbekW9It6ZZ0S7ol3ZJuSbd8buh7vTiIk7iIm2hEJx5iEOk26IZ7r7twEhdxE43oxEMMYj7EvVcg3SbdJt0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0W3TbdNt023TbdNt023TbdNt023TbdjG5GN6Ob0c3oZnQzuhndjG5GN6eb083p5nRzujndnG5ON6eb0+3Q7dDt0O3Q7dDt0O3Q7dDt0O3QLegWdAu6Bd2CbkG3oFvQLegWdEu6Jd2Sbkm3pFvSLemWdEu65XND3+vFQfzcbBQu4iZ+bob/1omH+LmZF+bDypKLgziJi7iJRnTiIdJt0G3SbdJt0m3SbdJt0m3SbdJt0m3SbdFt0W3RbdFt0W3RbdFt0W3RbdFt023TbdNt023TbdNt023TbdNt083oZnQzuhndjG5GN6Ob0c3oZnRzujndnG5ON6eb083p5nRzujndDt0O3Q7dDt0O3Q7dDt0O3Q7dDt2CbkG3oFvQLegWdAu6Bd2CbkG3pFvSLemWdEu6Jd2Sbkm3pFs+N/S9XhzESVzETTSiEw8xiHRjljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPkMEsOs+QwSw6z5DBLDrPkMEsOs+QwSw6zBH2v3891LPS9XpzERdxEIzrxEIOYDyfdJt0m3SbdKks8C43oxDo2KwxiPkSWAAdxEhdxE43oRLotui26bbptum26bbptum26bbptum26bboZ3YxuRjejm9HN6GZ0M7oZ3YxuTjenm9PN6eZ0c7o53ZxuTjen26Hboduh26Hboduh26Hboduh26Fb0C3oFnQLugXdgm5Bt6Bb0C3olnRLuiXdkm5Jt6Rb0i3plnTL54a+14uDOImLuIlGdOIhBpFug26DboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSxB3+vxwnxYWXLxc/ueqL7Q93pxET+3mIVGdOLnFqswiPmwsuTiIE7iIm6iEZ1IN6eb0+3QrbIksnASF/FzyzoPlSUXnfi5ZZ2HypKL+fDLkvk9KnFV32vjJK4Pay2+LGk0on9Y0/mypDGI+TB/xEGcxEXcRCPSLemWdMvnVn2vjYM4iYu4iUZ04iEGkW6DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26bbkY3o5vRzehmdDO6Gd2MbkY3o5vTzenmdHO6Od2cbk43p5vTzel26Hboduh26Hboduh26Hboduh26BZ0C7oF3YJuQbegG7MkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS/Jlyf69LNm/lyX797Jk/16W7N/Lkv17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Pv2y1b6O/csu/v7nv/7jX//4+59//+df//63fz/+MtTjyHaoeWjjHLc3MPSzFDcuhXG0O0qRS2mUdhaLmUtllPYOj8SlUcdxOT82LvVxjts/Jm2jtH96ClyKXEqjtKOkzKUySrtuJOJS5VLj0qjjsAnmUcfxNnUOXBp1HM6BnLiUuVS4NOo4dvB51HFwf25c6mepjDqORKIlcClyadRxPLpeMpcKl0YdZf+2MuvY6y2NS/0s0axjHy0adRzRRzTqOFiGEpdmHXs/06jj2GgRcalyqXGpn6W6cSlwKXIpcSlzieuoXEflOirXUbmOxnU0rqNxHY3raFxH4zoa19G4jsZ1NK6jcx2d6+hcR+c6OtfRuY7OdXSuo3MdnevYN5xSDFKMUkxSzFIsUiQpzrriUWxSHLUd1LDvb6UYpBilmKSYpVikSFKsUmxSlNqi1Baltii1RaktSm1RaotSW5TaotQWpbYktSWpLUltSWpLUluS2pLUlqS2JLUlqS1LbVlqy1Jbltqy1Jaltiy1ZaktS21ZaitSW5HaitRWpLYitRWprUhtRWorUluR2khqI6mNpDaS2khqI6mNpDaS2khqI6mtSm1VaqtSW5XaqtRWpbYqtVWprUptVWprUluT2prU1qS2JrU1qa1JbU1qa1Jbk9q61Nalti61damtS21dautSW5fautTWuba4bVIMUoxSTFLMUixSJClWKTYpSm3CJVG4JAqXROGSKFwShUuicEkULonCJVG4JAqXROGSKFwShUuicEkULonCJVG4JAqXROGSKFwShUuicEkULonCJVG4JAqXROGSKFwShUuicEkULonCJVG4JAqXROGSKFwShUuicEkULonCJVG4JAqXROGSKFwShUuicEkULonCJVG4JAqXROGSKFwShUuicEkULonCJVG4JAqXROGSKFwShUuicEkULonCJVG4JAqXROGSKFwShUuicEkULonCJVG4JAqXROGSKFwShUuicEkULonCJVG4JAqXROGSKFwShUuicEkULonCJVG4JAmXJOGSJFyShEuScEkSLknCJUm4JAmXpAeXHPvxwSV1bOYHlzyKUYpJinkUw1EsUqRRzEexjiIdxSbFzsU4azs2+DFIcdR2PLCZBpc8ilmKo7bDoJsGlzyKo7bDZJ0GlzyKnYuDS+oRG58GlzyKo7Z4NGdwST38xmlwyaM4ajuexEuDSx7FUdtx+kiDSx7FzsXBJcPBmAaXPIqjtuMBiTS45FHMUhy1HaeVNLjkURy1HSeXNLjkURy1HWeINLjkUQxSHLUdh4c0uORRHLUddu40uKQeZuY0uORRrFIctR1vNafBJbM4uKQeJrE0uORRjFIctR1WwDS45FEctR0b5DS45FGsUhy1HXvlNLhkFgeX1OPpiDS4pB62kTS45FEctbVxdsxSHLUdp9s0uORRrFIctY0ZMLhkFgeXtCP5Yxpc8ihGKaZRPJozuORRLKN4NGdwyaN41NaOF1rT4JJHsXNxcEk73o9Mg0sexVHbUNrBJY9ilmKR4qjtOBqnwSWP4qhtaPXgknaoch5c8igGKY7aDq3Og0sexVHbOF4PLnkUSYqjtkOr8+CSR3HUdqhyHlzyKAYpjtrGcXxwyaM4ahtH88El7Xi4Kw8ueRRHbcf5Ow8ueRRHbcdpOw8ueRSDFEdtx2TIg0sexVHbocp5cMmjSFIctR3Wyzy45FEctR325Dy45FEctR120Dy45FFMUhy1HaaXPLjkURy1HVqdB5e0NuwXTYqdi4NL2qHVeXDJozhqO1Q5Dy55FLMUR22HVufBJY/iUVs/VDkPLnkUOxcHl/RDq/PgkkcxjuIwqKRRPNowuORRPGrrx1vPeXDJozhqOwg6Dy55FDsXB5f0YzLkwSWP4qjtIOg8uORRzFIctcVh1SEpjtqGVg8ueRRHbcebmXlwyaMYpDhqOwx/eXDJozhqO16nzoNL+vHSWx5c0o8rwXlwyaM4ahsKPrhkFgeXPIpBiqO24zJvHlzyKGYpztqOD2okxSrFJsVZ29HevkkxSHHUNmbL4JJHcdQ2psjgkkdx1HaYp/Lgkl4GQpNiP4tlcMmjGKQYpZikmKVYpEhSrFJsUpTagtQWpLYgtQWpLUhtg0v6ceemDC55FKsUmxQ7FweXPIpBilGKSYpZilJblNqi1Baltii1JaktSW1JaktSW5LaktSWpLYktSWpLUltWWrLUluW2rLUlqW2LLVlqS1LbVlqy1JbkdqK1FaktiK1FamtSG1FaitSW5HaitRGUhtJbSS1kdRGUhtJbSS1kdRGUhtJbVVqq1Jbldqq1Faltiq1VamtSm1VaqtSW5PamtTWpLYmtTWprUltTWprUluT2prU1qW2LrV1qa1LbV1q61Jbl9q61Nalts610bZJMUgxSjFJMUuxSJGkWKXYpCi1BaktSG1BagtSW5DahEtIuISES0i4hCaXHHeraHLJLAYpjtqOCA6aXHLE4NPkklkctR0vadHkklkctR3XV2hyyXht7f/8/o+//v4//vjLv+9uoMNT9B9/+/PpFdrFf/7ffzt/8z/+8dc//vjr//7Xf/vH3//8l//5H//4y+FBGs6jbXiQ9v/+992tHsPhYQqPn+8/2W1Qv+3/jfVf9v3k/Mm+sO7/Te1ffjv/bDfY/Xb8d/wozH+1r5jHf/OBF7mKfUNXyvGjdPzoANwX2RJOqH2BKvX4dZZG9d/iACn8o30XEPvxI+IfpfxbGj+qGLedv07xtxz51/u/pePXXQD7b7PtYTv/ZP9u+ejH7w+P3P8D",
      "is_unconstrained": false,
      "name": "send_value_private",
      "verification_key": "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"
    },
    {
      "abi": {
        "error_types": {
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15546539856497705002": {
            "error_kind": "string",
            "string": "u16 to u8 conversion failed"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "8228371833434187583": {
            "error_kind": "string",
            "string": "Trying to read from uninitialized PublicImmutable"
          }
        },
        "parameters": [
          {
            "name": "destination_chain_id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 16
            },
            "visibility": "private"
          },
          {
            "name": "value",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "fee_nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "public"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "send_value_public"
    },
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "14067204867181196045": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "9921926525851912681": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "utility"
      ],
      "debug_symbols": "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4iYa0YmHGES6DboNug26MUuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySahEcYxQO4iQu4iYa0YmHGMR8mHRLuiXdKkvGLNxEIzrxEIOYF2d1EjYO4iQu4iYa0YmHGES6DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26bboZ3YxulSVjFy7iJpbbKXTiIQYxH1aWXBzESVzETaSb083p5nRzuh26Hboduh26Hboduh26Hboduh26Bd2CbkG3oFvQLegWdAu6Bd2Cbkm3pFvSLemWdEu6Jd2Sbkm3fG7j9yMO4iQu4iYa0YmHGES6DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26bboZ3YxuRjejm9GNWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWbKYJYtZspgli1mymCWLWbKYJYtZspgli1mymCWL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26DboNug26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptumW2XJ960xu/peG534uc0oDGI+rCz5fqNyV99r4yR+bqvcKksuGvFz+z7h39X32hjEz+37XG9X32vjIH5u2woXcRM/N6sLqiy5eIifm2GwfFhZcvFz81/hJC7i5+Y138qSi0783LzWrLLkYj6sLDk138qSi5P4uZ1as8qSi0b83E6temXJxSDmw8qSi4M4iYu4iUakW9It6ZbPrfpeGwdxEhdxE43oxEMMIt0G3QbdBt0G3QbdBt0G3QbdKku+++pdfa8XK0sufm7fX1Da1ffauIibaEQnHmIQ82FlyUW6Lbotui26VZZ8f4FpV99r4yF+bjkL82FlycXPLesyK0suLuImGtGJhxjEfFhZcpFuRrcvS9av5vtlSaMR/cOa75cljUHMD796q77XxkGcH9Z2+yLuRnRKRtE37Piqv1oi1/eOYFdLZOMibqIRnXiIQcyH3zFrpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptumm9HN6GZ0M7oZ3YxuRjejm9HN6OZ0c7o53ZxudcyGFRrRiYcYxHx4yq0O6hnESVzEz23W+f1esho/t++b5na1RDYGMR9+L1mNgziJn9vchZtoxHLzwkMMYrnVfPNHHMRJXMRN/Ny+r0jY1RLZeIhB/Ny+34Tb1RLZOIif2/4VLuImfm5f2+uulsjG83DUVZzCb9y6hak2x7W9sEbIQiceYhDzYeXDxW/curGpNsfGRdzEz63ucarNsfFzs5pk5cPFfFj5cHEQJ/Fz+zosdrU5NhrRiZ/b98RrV5tj4+fmNcnKh4uDOInlVsaVDxeN6MRDDOLndmo6lQ8XB3ESP7dTk6x8uGjEcrPCQ4yHVfMXa4S6iqruupWrzsS/J+AfVklfHMRJXMRvsKhJVklfdOIhBjEfVknXPUN1JjZO4iKWW823SvqiE8utZlYlfTEfVklHHdoq6awaqpKuu47qTGzcRCM68TRWD+LfvyocxElcxE20h1WF35+d3NUg2FgW33yrFXDXXUe1AjZO4iJuoj1c9f+t+S4jOvEQg5gP9484iJO4iHTbdNt023TbdNt0sxp3FdYIu7BG8MJDDGKN8G13teE1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",
      "is_unconstrained": true,
      "name": "sync_private_state"
    }
  ],
  "name": "MessageBridge",
  "noir_version": "1.0.0-beta.14+82ec52a8c755d30ce655a2005834186a4acfa0c7-aztec",
  "outputs": {
    "globals": {
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "minters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Wormhole"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "state",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "sequences",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "owner",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "receiver_address",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000009"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "token_address",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000d"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_1",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000011"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_2",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000012"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_3",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000013"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_4",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000014"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_5",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000015"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_6",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000016"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_7",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000017"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_8",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000018"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_9",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000019"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_10",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_11",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001b"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_12",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001c"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_13",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001d"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_14",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001e"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_15",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001f"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_16",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000020"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_17",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000021"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_18",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000022"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_19",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000023"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "current_guardian_set_index",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000024"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "MessageBridge"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "config",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "owner",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "registered_emitters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "current_value",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "emitter_chain_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 16
                    }
                  },
                  {
                    "name": "emitter_address",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "value",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "MessageBridge::_validate_emitter_and_update_value_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::_validate_emitter_and_update_value_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "wormhole_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "chain_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 16
                    }
                  },
                  {
                    "name": "owner",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "message_fee",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "consistency",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  }
                ],
                "kind": "struct",
                "path": "MessageBridge::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "MessageBridge::get_config_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "wormhole_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "chain_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 16
                    }
                  },
                  {
                    "name": "message_fee",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "consistency",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  }
                ],
                "kind": "struct",
                "path": "config::Config"
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::get_config_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "MessageBridge::get_current_value_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::get_current_value_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "MessageBridge::get_owner_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::get_owner_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "chain_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 16
                    }
                  }
                ],
                "kind": "struct",
                "path": "MessageBridge::get_registered_emitter_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "array",
                "length": 32,
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 8
                }
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::get_registered_emitter_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "chain_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 16
                    }
                  },
                  {
                    "name": "emitter_address",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "MessageBridge::is_emitter_registered_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "boolean"
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::is_emitter_registered_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "message_ciphertext",
                    "type": {
                      "fields": [
                        {
                          "name": "storage",
                          "type": {
                            "kind": "array",
                            "length": 17,
                            "type": {
                              "kind": "field"
                            }
                          }
                        },
                        {
                          "name": "len",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 32
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "std::collections::bounded_vec::BoundedVec"
                    }
                  },
                  {
                    "name": "message_context",
                    "type": {
                      "fields": [
                        {
                          "name": "tx_hash",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "unique_note_hashes_in_tx",
                          "type": {
                            "fields": [
                              {
                                "name": "storage",
                                "type": {
                                  "kind": "array",
                                  "length": 64,
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              },
                              {
                                "name": "len",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "std::collections::bounded_vec::BoundedVec"
                          }
                        },
                        {
                          "name": "first_nullifier_in_tx",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "recipient",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::messages::processing::message_context::MessageContext"
                    }
                  }
                ],
                "kind": "struct",
                "path": "MessageBridge::process_message_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::process_message_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "vaa",
                    "type": {
                      "kind": "array",
                      "length": 2000,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "length",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "MessageBridge::receive_value_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::receive_value_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "source_chain_ids",
                    "type": {
                      "fields": [
                        {
                          "name": "storage",
                          "type": {
                            "kind": "array",
                            "length": 8,
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 16
                            }
                          }
                        },
                        {
                          "name": "len",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 32
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "std::collections::bounded_vec::BoundedVec"
                    }
                  },
                  {
                    "name": "emitter_addresses",
                    "type": {
                      "fields": [
                        {
                          "name": "storage",
                          "type": {
                            "kind": "array",
                            "length": 8,
                            "type": {
                              "kind": "array",
                              "length": 32,
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 8
                              }
                            }
                          }
                        },
                        {
                          "name": "len",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 32
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "std::collections::bounded_vec::BoundedVec"
                    }
                  }
                ],
                "kind": "struct",
                "path": "MessageBridge::register_emitter_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::register_emitter_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "destination_chain_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 16
                    }
                  },
                  {
                    "name": "value",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "fee_nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "MessageBridge::send_value_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::send_value_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "destination_chain_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 16
                    }
                  },
                  {
                    "name": "value",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "fee_nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "MessageBridge::send_value_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::send_value_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "MessageBridge::sync_private_state_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::sync_private_state_abi"
        }
      ]
    }
  },
  "transpiled": true
}
