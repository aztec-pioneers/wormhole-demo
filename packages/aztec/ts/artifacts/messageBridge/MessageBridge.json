{
  "file_map": {
    "100": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr",
      "source": "use super::utils::compute_fn_selector;\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::utils::get_params_len_quote;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault, panic};\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let seen_selectors =\n        &mut UHashMap::<Field, Quoted, BuildHasherDefault<Poseidon2Hasher>>::default();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n        let fn_name = function.name();\n\n        // Since function selectors are computed as the first 4 bytes of the hash of the function signature,\n        // it's possible to have collisions. With the following check, we ensure it doesn't happen within\n        // the same contract.\n        if seen_selectors.contains_key(selector) {\n            let existing_fn = seen_selectors.get(selector).unwrap();\n            panic(\n                f\"Public function selector collision detected between functions '{fn_name}' and '{existing_fn}'\",\n            );\n        }\n        seen_selectors.insert(selector, fn_name);\n\n        let params_len_quote = get_params_len_quote(parameters);\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $params_len_quote] = dep::aztec::context::public_context::calldata_copy(1, $params_len_quote);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index: &mut u32 = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[external(\"public\")]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "104": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/macros/functions/call_interface_stubs.nr",
      "source": "//! Stubs are auto-generated wrapper functions that provide an ergonomic interface for cross-contract calls.\n//! Instead of manually serializing arguments and creating call interfaces, stubs allow natural syntax, e.g. for\n//! enqueuing calls to public functions:\n//!\n//!   ExternalContract.at(address).some_method(arg1, arg2).enqueue()\n\nuse crate::macros::utils::{AsStrQuote, compute_fn_selector, is_fn_view};\nuse super::stub_registry;\nuse protocol_types::meta::utils::derive_serialization_quotes;\nuse std::meta::unquote;\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\npub comptime fn register_private_fn_stub(f: FunctionDefinition) {\n    let stub = if is_fn_view(f) {\n        create_private_static_stub(f)\n    } else {\n        create_private_stub(f)\n    };\n    stub_registry::register(f.module(), stub);\n}\n\npub comptime fn register_public_fn_stub(f: FunctionDefinition) {\n    let stub = if is_fn_view(f) {\n        create_public_static_stub(f)\n    } else {\n        create_public_stub(f)\n    };\n    stub_registry::register(f.module(), stub);\n}\n\npub comptime fn register_utility_fn_stub(f: FunctionDefinition) {\n    let stub = create_utility_stub(f);\n    stub_registry::register(f.module(), stub);\n}\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, Quoted, u32, Field) {\n    // Dear privacy adventurer,\n    // Chances are, you've command+clicked on the name of an external function\n    // call -- seeking to view that function -- only to end up here.\n    // Here's an explanation:\n    // The external contract that you're calling was likely annotated with the `#[aztec]`\n    // annotation -- as all good aztec contracts are. This triggers a macro which generates\n    // a \"contract interface\" for that contract, which is effectively a pretty interface\n    // that gives natural contract calling semantics:\n    //\n    // `MyImportedContract.at(some_address).my_method(arg1, arg2).enqueue();\n    //\n    // Unfortunately, the usage of macros makes it a bit of a black box.\n    // To actually view the target function, you could instead command+click on\n    // `MyImportedContract`, or you can just manually search it.\n    // If you want to view the noir code that gets generated by this macro, you can\n    // use `nargo expand` on your contract.\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n\n    let (serialized_args_array_construction, _, serialized_args_array_name) =\n        derive_serialization_quotes(fn_parameters, false);\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name,\n        fn_name_str, fn_name_len, fn_selector,\n    )\n}\n\ncomptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, serialized_args_array_name, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            )\n        }\n    }\n}\n\ncomptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, serialized_args_array_name, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, serialized_args_array_name, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            )\n        }\n    }\n}\n\ncomptime fn create_utility_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, serialized_args_array_name, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::UtilityCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::UtilityCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            )\n        }\n    }\n}\n"
    },
    "105": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\n// Used by `create_mark_as_initialized` (you won't find it through searching)\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\n// Used by `create_mark_as_initialized` (you won't find it through searching)\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\n// Used by `create_init_check` (you won't find it through searching)\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\n// Used by `create_init_check` (you won't find it through searching)\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\n// Used by `create_assert_correct_initializer_args` (you won't find it through searching)\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender().unwrap()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n// Used by `create_assert_correct_initializer_args` (you won't find it through searching)\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender().unwrap()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "108": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{\n        auth_registry::AUTHORIZE_ONCE_REGISTRY,\n        call_interface_stubs::{\n            register_private_fn_stub, register_public_fn_stub, register_utility_fn_stub,\n        },\n    },\n    notes::NOTES,\n    utils::{\n        fn_has_authorize_once, fn_has_noinitcheck, is_fn_contract_library_method, is_fn_external,\n        is_fn_initializer, is_fn_internal, is_fn_test, is_fn_view, modify_fn_body,\n        module_has_initializer, module_has_storage,\n    },\n};\nuse dep::protocol_types::meta::utils::derive_serialization_quotes;\nuse std::meta::{ctstring::AsCtString, type_of};\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) {\n    register_private_fn_stub(f);\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    let (args_serialization, _, serialized_args_name) =\n        derive_serialization_quotes(original_params, false);\n\n    let context_creation = quote {\n        $args_serialization\n        let args_hash = dep::aztec::hash::hash_args_array($serialized_args_name);\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, args_hash);\n    };\n\n    let function_name = f.name();\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        let assertion_message = f\"Function {function_name} can only be called internally\";\n        quote { assert(context.msg_sender().unwrap() == context.this_address(), $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        let assertion_message =\n            f\"Function {function_name} can only be called statically\".as_ctstring().as_quoted_str();\n        quote { assert(context.inputs.call_context.is_static_call, $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (\n            quote { aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_private(context); },\n            quote { aztec::macros::functions::initialization_utils::mark_as_initialized_private(&mut context); },\n        )\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        quote { aztec::macros::functions::initialization_utils::assert_is_initialized_private(&mut context); }\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any. Note that the message\n    // discovery call syncs private events as well. We do not sync those here if there are no notes because we don't\n    // have an API that would access events from private functions.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f, true)\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is serialized and hashed before being passed to the context.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n\n        let (return_serialization, _, serialized_return_name) =\n            derive_serialization_quotes([(return_value_var_name, return_value_type)], false);\n\n        body = body_without_return;\n\n        quote {\n            $return_value_assignment\n            $return_serialization\n            context.set_return_hash($serialized_return_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    // A quote to be injected at the beginning of the function body.\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) {\n    register_public_fn_stub(f);\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n\n    let args_len_quote = if original_params.len() == 0 {\n        // If the function has no parameters, we set the args_len to 0.\n        quote { 0 }\n    } else {\n        // The following will give us <type_of_struct_member_1 as Serialize>::N + <type_of_struct_member_2 as Serialize>::N + ...\n        original_params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n            <$param_type as $crate::protocol_types::traits::Serialize>::N\n        }\n            })\n            .join(quote {+})\n    };\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len_quote] = dep::aztec::context::public_context::calldata_copy(1, $args_len_quote);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    let name = f.name();\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        let assertion_message = f\"Function {name} can only be called internally\";\n        quote { assert(context.msg_sender().unwrap() == context.this_address(), $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        let name = f.name();\n        let assertion_message =\n            f\"Function {name} can only be called statically\".as_ctstring().as_quoted_str();\n        quote { assert(context.is_static_call(), $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (\n            quote { aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_public(context); },\n            quote { aztec::macros::functions::initialization_utils::mark_as_initialized_public(&mut context); },\n        )\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        quote { aztec::macros::functions::initialization_utils::assert_is_initialized_public(&mut context); }\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f, false)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    register_utility_fn_stub(f);\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage(f.module()) {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process or they may be used to sync private events from TypeScript\n    // (`sync_private_state` function gets invoked by PXE::getPrivateEvents function).\n    let message_discovery_call = create_message_discovery_call();\n\n    // A quote to be injected at the beginning of the function body.\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Injects an authwit verification check of the form:\n/// ```\n///   if (!from.eq(context.msg_sender().unwrap())) {\n///         assert_current_call_valid_authwit::<N>(&mut context, from);\n///     } else {\n///         assert(authwit_nonce, \"Invalid authwit nonce. When 'from' and 'msg_sender' are the same, authwit_nonce must be zero\");\n///     }\n/// ```\n/// where `from` and `authwit_nonce` are the names of the parameters that are expected to be present in the function definition.\n/// This check is injected by the `#[authorize_once(\"from_arg_name\", \"nonce_arg_name\")]`, which allows the user to define\n/// which parameters to use.\n///\n/// # Arguments\n/// * `f` - The function definition to inject the authwit verification check into. The function must have parameters\n///         matching the names specified in the `#[authorize_once]` attribute.\n/// * `is_private` - Whether the function is a private function (`true`) or a public function (`false`). This determines\n///                  which authwit verification method to use: `assert_current_call_valid_authwit` for private functions\n///                  or `assert_current_call_valid_authwit_public` for public functions.\npub(crate) comptime fn create_authorize_once_check(\n    f: FunctionDefinition,\n    is_private: bool,\n) -> Quoted {\n    let maybe_authorize_once_args = AUTHORIZE_ONCE_REGISTRY.get(f);\n    let authorize_once_args = if maybe_authorize_once_args.is_some() {\n        maybe_authorize_once_args.unwrap()\n    } else {\n        // We need to for authorize_once to have already executed so that we can retrieve its params - this depends on\n        // the order in which the attributes are applied.\n        panic(\n            f\"Functions marked with #[authorize_once] must have the #[external(\\\"private\\\")] or #[external(\\\"public\\\")] attribute placed last\",\n        )\n    };\n\n    let (from_arg_name, nonce_arg_name) = authorize_once_args;\n    let name: Quoted = f.name();\n\n    let from_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{from_arg_name}\".quoted_contents());\n    let (from_arg_name_quoted, from_arg_type) = if from_arg_candidates.len() == 1 {\n        from_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {from_arg_name} parameter. Please specify which one to use in #[authorize_once(\\\"...\\\", \\\"authwit_nonce\\\")]\",\n        )\n    };\n    if from_arg_type\n        != quote { dep::protocol_types::address::aztec_address::AztecAddress }.as_type() {\n        panic(\n            f\"Argument {from_arg_name_quoted} in function {name} must be of type AztecAddress, but is of type {from_arg_type}\",\n        )\n    }\n\n    let nonce_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{nonce_arg_name}\".quoted_contents());\n    let (nonce_arg_name_quoted, nonce_arg_type) = if nonce_arg_candidates.len() == 1 {\n        nonce_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {nonce_arg_name}. Please specify which one to use in #[authorize_once(\\\"from\\\", \\\"...\\\")]\",\n        )\n    };\n    if nonce_arg_type != quote { Field }.as_type() {\n        panic(\n            f\"Argument {nonce_arg_name_quoted} in function {name} must be of type Field, but is of type {nonce_arg_type}\",\n        );\n    }\n\n    let nonce_check_quote = f\"{nonce_arg_name_quoted} == 0\".quoted_contents();\n\n    let fn_call = if is_private {\n        // At this point, the original args of the fn have already been altered by the macro\n        // to include PrivateContextInputs, so we need to adjust the args_len accordingly.\n        let args_len = f.parameters().len() - 1;\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit::<$args_len> }\n    } else {\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit_public }\n    };\n    let invalid_nonce_message = f\"Invalid authwit nonce. When '{from_arg_name}' and 'msg_sender' are the same, '{nonce_arg_name}' must be zero\"\n        .as_ctstring()\n        .as_quoted_str();\n    quote {         \n        if (!$from_arg_name_quoted.eq(context.msg_sender().unwrap())) {\n            $fn_call(&mut context, $from_arg_name_quoted);\n        } else {\n            assert($nonce_check_quote, $invalid_nonce_message);\n        }\n    }\n}\n\n/// Checks if each function in the module is marked with either #[external(...)], #[contract_library_method], or #[test].\n/// Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_external(f) & !is_fn_contract_library_method(f) & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[external(...)], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "110": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/macros/notes.nr",
      "source": "use crate::note::note_getter_options::PropertySelector;\nuse std::{collections::bounded_vec::BoundedVec, meta::{ctstring::AsCtString, type_of}};\n\n/// Maximum number of note types within 1 contract.\ncomptime global MAX_NOTE_TYPES: u32 = 128;\n\n/// A BoundedVec containing all the note types within this contract.\npub comptime mut global NOTES: BoundedVec<Type, MAX_NOTE_TYPES> = BoundedVec::new();\n\ncomptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < MAX_NOTE_TYPES,\n        f\"A contract can contain at most {MAX_NOTE_TYPES} different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_type_impl(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n    let typ = s.as_type();\n    let note_type_name: str<_> = f\"{name}\".as_ctstring().as_quoted_str!();\n    let max_note_packed_len = crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                // This static assertion ensures the note's packed length doesn't exceed the maximum allowed size.\n                // While this check would ideally live in the Packable trait implementation, we place it here since\n                // this function is always generated by our macros and the Packable trait implementation is not.\n                // Note: We set the note type name and max packed length as local variables because injecting them\n                // directly into the error message doesn't work.\n                let note_type_name = $note_type_name;\n                let max_note_packed_len: u32 = $max_note_packed_len; // Casting to u32 to avoid the value to be printed in hex.\n                let note_packed_len = <$typ as Packable>::N;\n                std::static_assert(note_packed_len <= $max_note_packed_len, f\"{note_type_name} has a packed length of {note_packed_len} fields, which exceeds the maximum allowed length of {max_note_packed_len} fields\");\n\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullification: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullification: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::traits::Packable::pack(self).concat( [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::context::PrivateContext,\n                note_hash_for_nullification: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullification, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullification: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullification, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _, _)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates the core note functionality for a struct:\n///\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - NoteHash trait implementation: Handles note hash and nullifier computation\n///\n/// # Requirements\n///\n/// The note struct must:\n/// - Have an `owner` field\n/// - Implement the `Packable` trait\n/// - Not exceed `MAX_NOTE_PACKED_LEN` when packed\n///\n/// # Registration\n///\n/// Registers the note in the global `NOTES` BoundedVec to enable note processing functionality.\n///\n/// # Generated Code\n///\n/// For detailed documentation on the generated implementations, see:\n/// - `generate_note_properties()`\n/// - `generate_note_type_impl()`\n/// - `generate_note_hash_trait_impl()`\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n    assert_has_packable(s);\n\n    // We register the note in the global `NOTES` BoundedVec because we need that information inside the #[aztec] macro\n    // to generate note processing functionality.\n    NOTES.push(s.as_type());\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_type_impl = generate_note_type_impl(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n\n    quote {\n        $note_properties\n        $note_type_impl\n        $note_hash_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n///\n/// # Requirements\n///\n/// The note struct must:\n/// - Implement the `Packable` trait\n/// - Not exceed `MAX_NOTE_PACKED_LEN` when packed\n///\n/// Unlike the `#[note]` macro, there is no requirement for an `owner` field.\n///\n/// # Registration\n///\n/// Registers the note in the global `NOTES` BoundedVec to enable note processing functionality.\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    assert_has_packable(s);\n\n    // We register the note in the global `NOTES` BoundedVec because we need that information inside the #[aztec] macro\n    // to generate note processing functionality.\n    NOTES.push(s.as_type());\n\n    let note_type_id = get_next_note_type_id();\n    let note_properties = generate_note_properties(s);\n    let note_type_impl = generate_note_type_impl(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_type_impl\n    }\n}\n\n/// Asserts that the given note implements the `Packable` trait.\n///\n/// We require that notes have the `Packable` trait implemented because it is used when emitting a note in a log or as\n/// an offchain message.\ncomptime fn assert_has_packable(note: TypeDefinition) {\n    let packable_constraint =\n        quote { crate::protocol_types::traits::Packable }.as_trait_constraint();\n    let note_name = note.name();\n\n    assert(\n        note.as_type().implements(packable_constraint),\n        f\"{note_name} does not implement Packable trait. Either implement it manually or place #[derive(Packable)] on the note struct before #[note] macro invocation.\",\n    );\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    let note_name = note.name();\n\n    assert(\n        has_owner,\n        f\"{note_name} does not have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "111": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/macros/storage.nr",
      "source": "use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract should have this macro (or `storage_no_init`) applied to it, and the\n/// struct has to be called 'Storage'.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    let struct_name = s.name();\n    if struct_name != quote { Storage } {\n        panic(\n            f\"The #[storage] macro can only be applied to a struct with name 'Storage', got '{struct_name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage_no_init\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ, _) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot });\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields = storage_layout_fields.push_back(\n            quote { pub $name: dep::aztec::state_vars::storage::Storable },\n        );\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::state_vars::storage::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract can have this macro (or storage_no_init) applied to it, and the struct\n/// has to be called 'Storage'.\npub comptime fn storage_no_init(s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n\n    // We do need to make sure that the type is called Storage, since we'll do `Storage::init` later on.\n\n    if s.name() != quote { Storage } {\n        let name = s.name();\n        panic(\n            f\"The #[storage_no_init] macro can only be applied to a struct with name 'Storage', got '{name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(typ: Type, slot: Quoted) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    let constructor = if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot });\n\n        quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }\n    } else {\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        quote { $struct_name::new(context, $slot)}\n    };\n\n    (constructor, get_storage_size(typ))\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n"
    },
    "113": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod private_events;\npub mod private_notes;\npub mod process_message;\n\nuse crate::{\n    messages::{\n        discovery::{\n            private_notes::MAX_NOTE_PACKED_LEN, process_message::process_message_ciphertext,\n        },\n        processing::{\n            get_private_logs, pending_tagged_log::PendingTaggedLog,\n            validate_enqueued_notes_and_events,\n        },\n    },\n    utils::array,\n};\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, note nonce, storage slot and note\n/// type ID and attempts to compute its note hash (not hashed by note nonce nor siloed by address) and inner nullifier\n/// (not siloed by address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, note_nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullification = aztec::note::utils::compute_note_hash_for_nullification(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(note_nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullification);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\npub type ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* note nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private logs are downloaded and inspected to find new private\n/// notes, partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Note that the state is synchronized up to the latest block synchronized by PXE. That should be close to the chain\n/// tip as block synchronization is performed before contract function simulation is done.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    // First we process all private logs, which can contain different kinds of messages e.g. private notes, partial\n    // notes, private events, etc.\n    let mut logs = get_private_logs(contract_address);\n    logs.for_each(|i, pending_tagged_log: PendingTaggedLog| {\n        debug_log_format(\n            \"Processing log with tag {0}\",\n            [pending_tagged_log.log.get(0)],\n        );\n\n        // We remove the tag from the pending tagged log and process the message ciphertext contained in it.\n        let message_ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n        process_message_ciphertext(\n            contract_address,\n            compute_note_hash_and_nullifier,\n            message_ciphertext,\n            pending_tagged_log.context,\n        );\n        logs.remove(i);\n    });\n\n    // Then we process all pending partial notes, regardless of whether they were found in the current or previous\n    // executions.\n    partial_notes::fetch_and_process_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    // Finally we validate all notes and events that were found as part of the previous processes, resulting in them\n    // being added to PXE's database and retrievable via oracles (get_notes) and our TS API (PXE::getPrivateEvents).\n    validate_enqueued_notes_and_events(contract_address);\n}\n"
    },
    "114": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub note_nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given note nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    note_nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Found valid nonces for a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullification,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        note_nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullification = compute_note_hash_for_nullification(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(note_nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullification);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        note_nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let note_nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(note_nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash = compute_unique_note_hash(\n            note_nonce,\n            compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash),\n        );\n        let inner_nullifier = note.compute_nullifier_unconstrained(\n            compute_note_hash_for_nullification(retrieved_note, STORAGE_SLOT),\n        );\n\n        NoteAndData { note, note_nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.note_nonce, note_and_data.note_nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == first_note_and_data.note_nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == second_note_and_data.note_nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "115": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::{\n            enqueue_note_for_validation, get_pending_partial_notes_completion_logs,\n            log_retrieval_response::LogRetrievalResponse,\n        },\n    },\n    utils::array,\n};\n\nuse protocol_types::{\n    address::AztecAddress,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for logs that would result in the completion of pending partial notes, ultimately resulting in the notes\n/// being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    // Each of the pending partial notes might get completed by a log containing its public values. For performance\n    // reasons, we fetch all of these logs concurrently and then process them one by one, minimizing the amount of time\n    // waiting for the node roundtrip.\n    let maybe_completion_logs =\n        get_pending_partial_notes_completion_logs(contract_address, pending_partial_notes);\n\n    // Each entry in the maybe completion logs array corresponds to the entry in the pending partial notes array at the\n    // same index. This means we can use the same index as we iterate through the responses to get both the partial note\n    // and the log that might complete it.\n    assert_eq(maybe_completion_logs.len(), pending_partial_notes.len());\n\n    maybe_completion_logs.for_each(|i, maybe_log: Option<LogRetrievalResponse>| {\n        // We clear the completion logs as we read them so that the array is empty by the time we next query it.\n        // TODO(#14943): use volatile arrays to avoid having to manually clear this.\n        maybe_completion_logs.remove(i);\n\n        let pending_partial_note = pending_partial_notes.get(i);\n\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log plaintext to get\n            // the complete packed content.\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                log.log_payload,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            // TODO(#11627): is there anything reasonable we can do if we get a log but it doesn't result in a note\n            // being found?\n            if discovered_notes.len() == 0 {\n                panic(\n                    f\"A partial note's completion log did not result in any notes being found - this should never happen\",\n                );\n            }\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                enqueue_note_for_validation(\n                    contract_address,\n                    pending_partial_note.storage_slot,\n                    discovered_note.note_nonce,\n                    complete_packed_note,\n                    discovered_note.note_hash,\n                    discovered_note.inner_nullifier,\n                    log.tx_hash,\n                    pending_partial_note.recipient,\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
    },
    "116": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/discovery/private_events.nr",
      "source": "use crate::{\n    event::event_selector::EventSelector,\n    messages::{encoding::MAX_MESSAGE_CONTENT_LEN, processing::enqueue_event_for_validation},\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::GENERATOR_INDEX__EVENT_COMMITMENT,\n    hash::poseidon2_hash_with_separator_bounded_vec, traits::FromField,\n};\n\n/// The number of fields in a private event message content that are not the event's serialized representation\n/// (1 field for randomness).\nglobal PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of an event's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, randomness, etc.).\npub global MAX_EVENT_SERIALIZED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN;\n\npub unconstrained fn process_private_event_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n) {\n    // In the case of events, the msg metadata is the event selector.\n    let event_type_id = EventSelector::from_field(msg_metadata as Field);\n\n    assert(\n        msg_content.len() > PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n        f\"Invalid private event message: all private event messages must have at least {PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private event message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN\",\n    );\n\n    let serialized_event_with_randomness = msg_content;\n\n    let event_commitment = poseidon2_hash_with_separator_bounded_vec(\n        serialized_event_with_randomness,\n        GENERATOR_INDEX__EVENT_COMMITMENT,\n    );\n\n    // Randomness was injected into the event payload in `emit_event_in_private` but we have already used it\n    // to compute the event commitment, so we can safely discard it now.\n    let serialized_event = array::subbvec(\n        serialized_event_with_randomness,\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n    );\n\n    enqueue_event_for_validation(\n        contract_address,\n        event_type_id,\n        serialized_event,\n        event_commitment,\n        tx_hash,\n        recipient,\n    );\n}\n"
    },
    "117": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::enqueue_note_for_validation,\n    },\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\n// See the call to `std::static_assert` below to see what's in these fields.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        enqueue_note_for_validation(\n            contract_address,\n            storage_slot,\n            discovered_note.note_nonce,\n            packed_note,\n            discovered_note.note_hash,\n            discovered_note.inner_nullifier,\n            tx_hash,\n            recipient,\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
    },
    "118": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/discovery/process_message.nr",
      "source": "use crate::messages::{\n    discovery::{\n        ComputeNoteHashAndNullifier, partial_notes::process_partial_note_private_msg,\n        private_events::process_private_event_msg, private_notes::process_private_note_msg,\n    },\n    encoding::{decode_message, MESSAGE_CIPHERTEXT_LEN, MESSAGE_PLAINTEXT_LEN},\n    encryption::{aes128::AES128, message_encryption::MessageEncryption},\n    msg_type::{\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n    },\n    processing::message_context::MessageContext,\n};\n\nuse protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\n/// Processes a message that can contain notes, partial notes, or events.\n///\n/// Notes result in nonce discovery being performed prior to delivery, which requires knowledge of the transaction hash\n/// in which the notes would've been created (typically the same transaction in which the log was emitted), along with\n/// the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier` function. Once\n/// discovered, the notes are enqueued for validation.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\n///\n/// Events are processed by computing an event commitment from the serialized event data and its randomness field, then\n/// enqueueing the event data and commitment for validation.\npub unconstrained fn process_message_ciphertext<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_ciphertext: BoundedVec<Field, MESSAGE_CIPHERTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    process_message_plaintext(\n        contract_address,\n        compute_note_hash_and_nullifier,\n        AES128::decrypt(message_ciphertext, message_context.recipient),\n        message_context,\n    );\n}\n\npub unconstrained fn process_message_plaintext<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_plaintext: BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    // The first thing to do after decrypting the message is to determine what type of message we're processing. We\n    // have 3 message types: private notes, partial notes and events.\n\n    // We decode the message to obtain the message type id, metadata and content.\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(message_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            message_context.tx_hash,\n            message_context.unique_note_hashes_in_tx,\n            message_context.first_nullifier_in_tx,\n            message_context.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        process_private_event_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n            message_context.tx_hash,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "119": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::utils::array;\nuse protocol_types::constants::PRIVATE_LOG_CIPHERTEXT_LEN;\n\n// We reassign to the constant here to communicate the distinction between a log and a message. In Aztec.nr, unlike in\n// protocol circuits, we have a concept of a message that can be emitted either as a private log or as an offchain\n// message. Message is a piece of data that is to be eventually delivered to a contract via the `process_message(...)`\n// utility function function that is injected by the #[aztec] macro.\npub global MESSAGE_CIPHERTEXT_LEN: u32 = PRIVATE_LOG_CIPHERTEXT_LEN;\n\n// TODO(#12750): The global variables below should not be here as they are AES128 specific.\n// ciphertext_length (2) + 14 bytes pkcs#7 AES padding.\npub(crate) global HEADER_CIPHERTEXT_SIZE_IN_BYTES: u32 = 16;\n\npub global EPH_PK_X_SIZE_IN_FIELDS: u32 = 1;\npub global EPH_PK_SIGN_BYTE_SIZE_IN_BYTES: u32 = 1;\n\n// (17 - 1) * 31 - 16 - 1 = 479\nglobal MESSAGE_PLAINTEXT_SIZE_IN_BYTES: u32 = (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS)\n    * 31\n    - HEADER_CIPHERTEXT_SIZE_IN_BYTES\n    - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES;\n// Each field of the original note log was serialized to 32 bytes. Below we convert the bytes back to fields.\n// 479 / 32 = 15\npub global MESSAGE_PLAINTEXT_LEN: u32 = MESSAGE_PLAINTEXT_SIZE_IN_BYTES / 32;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MESSAGE_PLAINTEXT_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u16 {\n    fn from(value: u8) -> u16 {\n        value as u16\n    }\n}\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u16> for u32 {\n    fn from(value: u16) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u16> for u64 {\n    fn from(value: u16) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u16> for u128 {\n    fn from(value: u16) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u16> for Field {\n    fn from(value: u16) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i16 {\n    fn from(value: i8) -> i16 {\n        value as i16\n    }\n}\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i16> for i32 {\n    fn from(value: i16) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\n\nimpl From<i16> for i64 {\n    fn from(value: i16) -> i64 {\n        value as i64\n    }\n}\n\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u16 {\n    fn from(value: bool) -> u16 {\n        value as u16\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for u128 {\n    fn from(value: bool) -> u128 {\n        value as u128\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i16 {\n    fn from(value: bool) -> i16 {\n        value as i16\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            let body = if type1 == type2 {\n                quote { self }\n            } else if type1 == quote { bool } {\n                quote { self != 0 }\n            } else {\n                quote { self as $type1 }\n            };\n\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        $body\n                    }\n                }\n            },\n            );\n        }\n    }\n\n    let u_types =\n        [quote { bool }, quote { u8 }, quote { u16 }, quote { u32 }, quote { u64 }, quote { u128 }];\n\n    for type2 in u_types {\n        let body = quote { self as Field };\n\n        impls = impls.push_back(\n            quote {\n                impl AsPrimitive<Field> for $type2 {\n                    fn as_(self) -> Field {\n                        $body\n                    }\n                }\n            },\n        );\n    }\n\n    for type1 in u_types {\n        let body = if type1 == quote { bool } {\n            quote { self != 0 }\n        } else {\n            quote { self as $type1 }\n        };\n\n        impls = impls.push_back(\n            quote {\n                impl AsPrimitive<$type1> for Field {\n                    fn as_(self) -> $type1 {\n                        $body\n                    }\n                }\n            },\n        );\n    }\n\n    impls.join(quote {})\n}\n"
    },
    "120": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encoding::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, MESSAGE_CIPHERTEXT_LEN, MESSAGE_PLAINTEXT_LEN,\n        },\n        encryption::message_encryption::MessageEncryption,\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__message_bytes__from_PT,\n            get_arr_of_size__message_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\n/**\n * Computes N close-to-uniformly-random 256 bits from a given ECDH shared_secret.\n *\n * NEVER re-use the same iv and sym_key.\n * DO NOT call this function more than once with the same shared_secret.\n *\n * This function is only known to be safe if shared_secret is computed by combining a \n * random ephemeral key with an address point. See big comment within the body of the function.\n * See big comment within the body of the function.\n */\nfn extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [[u8; 32]; N] {\n    /*\n     * Unsafe because of https://eprint.iacr.org/2010/264.pdf Page 13, Lemma 2 (and the * two paragraphs below it).\n     *\n     * If you call this function, you need to be careful and aware of how the arg\n     * `shared_secret` has been derived.\n     *\n     * The paper says that the way you derive aes keys and IVs should be fine with poseidon2\n     * (modelled as a RO), as long as you _don't_ use Poseidon2 as a PRG to generate the * two exponents x & y which multiply to the shared secret S:\n     *\n     * S = [x*y]*G.\n     *\n     * (Otherwise, you would have to \"key\" poseidon2, i.e. generate a uniformly string K\n     * which can be public and compute Hash(x) as poseidon(K,x)).\n     * In that lemma, k would be 2*254=508, and m would be the number of points on the * grumpkin curve (which is close to r according to the Hasse bound).\n     *\n     * Our shared secret S is [esk * address_sk] * G, and the question is: * Can we compute hash(S) using poseidon2 instead of sha256?\n     *\n     * Well, esk is random and not generated with poseidon2, so that's good.\n     * What about address_sk?\n     * Well, address_sk = poseidon2(stuff) + ivsk, so there was some\n     * discussion about whether address_sk is independent of poseidon2.\n     * Given that ivsk is random and independent of poseidon2, the address_sk is also\n     * independent of poseidon2.\n     *\n     * Tl;dr: we believe it's safe to hash S = [esk * address_sk] * G using poseidon2,\n     * in order to derive a symmetric key.\n     *\n     * If you're calling this function for a differently-derived `shared_secret`, be\n     * careful.\n     *\n     */\n\n    /* The output of this function needs to be 32 random bytes.\n     * A single field won't give us 32 bytes of entropy.\n     * So we compute two \"random\" fields, by poseidon-hashing with two different\n     * generators.\n     * We then extract the last 16 (big endian) bytes of each \"random\" field.\n     * Note: we use to_be_bytes because it's slightly more efficient. But we have to\n     * be careful not to take bytes from the \"big end\", because the \"big\" byte is\n     * not uniformly random over the byte: it only has < 6 bits of randomness, because\n     * it's the big end of a 254-bit field element.\n     */\n\n    let mut all_bytes: [[u8; 32]; N] = std::mem::zeroed();\n    // We restrict N to be < 2^8, because of how we compute the domain separator\n    // from k below (where k <= N must be 8 bits). In practice, it's extremely\n    // unlikely that an app will want to compute >= 256 ciphertexts.\n    std::static_assert(N < 256, \"N too large\");\n    for k in 0..N {\n        // We augment the domain separator with the loop index, so that we can\n        // generate N lots of randomness.\n        let k_shift = (k as u16 << 8);\n        let separator_1 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY as u16;\n        let separator_2 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY_2 as u16;\n\n        let rand1: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_1);\n        let rand2: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_2);\n\n        let rand1_bytes: [u8; 32] = rand1.to_be_bytes();\n        let rand2_bytes: [u8; 32] = rand2.to_be_bytes();\n\n        let mut bytes: [u8; 32] = [0; 32];\n        for i in 0..16 {\n            // We take bytes from the \"little end\" of the be-bytes arrays:\n            let j = 32 - i - 1;\n            bytes[i] = rand1_bytes[j];\n            bytes[16 + i] = rand2_bytes[j];\n        }\n\n        all_bytes[k] = bytes;\n    }\n\n    all_bytes\n}\n\nfn derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits<let N: u32>(\n    many_random_256_bits: [[u8; 32]; N],\n) -> [([u8; 16], [u8; 16]); N] {\n    // Many (sym_key, iv) pairs:\n    let mut many_pairs: [([u8; 16], [u8; 16]); N] = std::mem::zeroed();\n    for k in 0..N {\n        let random_256_bits = many_random_256_bits[k];\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n        for i in 0..16 {\n            sym_key[i] = random_256_bits[i];\n            iv[i] = random_256_bits[i + 16];\n        }\n        many_pairs[k] = (sym_key, iv);\n    }\n\n    many_pairs\n}\n\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [([u8; 16], [u8; 16]); N] {\n    let many_random_256_bits: [[u8; 32]; N] = extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe(\n        shared_secret,\n    );\n\n    derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits(many_random_256_bits)\n}\n\npub struct AES128 {}\n\nimpl MessageEncryption for AES128 {\n    fn encrypt<let PlaintextLen: u32>(\n        plaintext: [Field; PlaintextLen],\n        recipient: AztecAddress,\n    ) -> [Field; MESSAGE_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the message in `do_process_message`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        // TODO (#17158): Currently we unwrap the Option returned by derive_ecdh_shared_secret_using_aztec_address.\n        // We need to handle the case where the ephemeral public key is invalid to prevent potential DoS vectors.\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient).unwrap();\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        // It is safe to call the `unsafe` function here, because we know the `shared_secret`\n        // was derived using an AztecAddress (the recipient). See the block comment\n        // at the start of this unsafe target function for more info.\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, body_iv, body_sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        std::static_assert(\n            ciphertext_bytes.len() == 16 * (1 + (PlaintextLen * 32) / 16),\n            \"unexpected ciphertext length\",\n        );\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, header_iv, header_sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        std::static_assert(\n            header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES,\n            \"unexpected ciphertext header length\",\n        );\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut message_bytes_padding_to_mult_31 =\n            get_arr_of_size__message_bytes_padding__from_PT::<PlaintextLen * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        message_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut message_bytes = get_arr_of_size__message_bytes__from_PT::<PlaintextLen * 32>();\n\n        std::static_assert(\n            message_bytes.len() % 31 == 0,\n            \"Unexpected error: message_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        message_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            message_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            message_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..message_bytes_padding_to_mult_31.len() {\n            message_bytes[offset + i] = message_bytes_padding_to_mult_31[i];\n        }\n        offset += message_bytes_padding_to_mult_31.len();\n\n        // Ideally we would be able to have a static assert where we check that the offset would be such that we've\n        // written to the entire log_bytes array, but we cannot since Noir does not treat the offset as a comptime\n        // value (despite the values that it goes through being known at each stage). We instead check that the\n        // computation used to obtain the offset computes the expected value (which we _can_ do in a static check), and\n        // then add a cheap runtime check to also validate that the offset matches this.\n        std::static_assert(\n            1\n                + header_ciphertext_bytes.len()\n                + ciphertext_bytes.len()\n                + message_bytes_padding_to_mult_31.len()\n                == message_bytes.len(),\n            \"unexpected message length\",\n        );\n        assert(offset == message_bytes.len(), \"unexpected encrypted message length\");\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make messages produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let message_bytes_as_fields = bytes_to_fields(message_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final message\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; MESSAGE_CIPHERTEXT_LEN] = [0; MESSAGE_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..message_bytes_as_fields.len() {\n            ciphertext[offset + i] = message_bytes_as_fields[i];\n        }\n        offset += message_bytes_as_fields.len();\n\n        for i in offset..MESSAGE_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the message\n            // (all the \"real\" message fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the message to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt(\n        ciphertext: BoundedVec<Field, MESSAGE_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, MESSAGE_PLAINTEXT_LEN> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, MESSAGE_CIPHERTEXT_LEN, MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) != 0;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret\n        // TODO(#17158): handle invalid ephemeral keys when decrypting to prevent DoS vectors\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk.unwrap());\n\n        // Derive symmetric keys:\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with messages with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext =\n            aes128_decrypt_oracle(header_ciphertext_bvec, header_iv, header_sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, body_iv, body_sym_key);\n\n        // Each field of the original note message was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::{\n            encoding::MESSAGE_PLAINTEXT_LEN, encryption::message_encryption::MessageEncryption,\n        },\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{address::AztecAddress, traits::FromField};\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt() {\n        let env = TestEnvironment::new();\n\n        // Message decryption requires oracles that are only available during private execution\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3];\n\n            let recipient = AztecAddress::from_field(\n                0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n            );\n\n            // Mock random values for deterministic test\n            let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(eph_sk).times(1);\n\n            let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(randomness).times(1000000);\n\n            let _ = OracleMock::mock(\"privateGetNextAppTagAsSender\").returns(42);\n\n            // Encrypt the message\n            let encrypted_message = BoundedVec::from_array(AES128::encrypt(plaintext, recipient));\n\n            // Mock shared secret for deterministic test\n            let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n                EmbeddedCurveScalar::from_field(eph_sk),\n                recipient,\n            );\n\n            let _ = OracleMock::mock(\"utilityGetSharedSecret\").returns(shared_secret.unwrap());\n\n            // Decrypt the message\n            let decrypted = AES128::decrypt(encrypted_message, recipient);\n\n            // The decryption function spits out a BoundedVec because it's designed to work with messages with unknown length\n            // at compile time. For this reason we need to convert the original input to a BoundedVec.\n            let plaintext_bvec = BoundedVec::<Field, MESSAGE_PLAINTEXT_LEN>::from_array(plaintext);\n\n            // Verify decryption matches original plaintext\n            assert_eq(\n                decrypted,\n                plaintext_bvec,\n                \"Decrypted bytes should match original plaintext\",\n            );\n\n            // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n            // static methods of the struct).\n            let _ = AES128 {};\n        });\n    }\n}\n"
    },
    "137": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/processing/mod.nr",
      "source": "pub(crate) mod event_validation_request;\npub mod message_context;\npub(crate) mod note_validation_request;\npub(crate) mod log_retrieval_request;\npub(crate) mod log_retrieval_response;\npub(crate) mod pending_tagged_log;\n\nuse crate::{\n    capsules::CapsuleArray,\n    event::event_selector::EventSelector,\n    messages::{\n        discovery::{\n            partial_notes::DeliveredPendingPartialNote, private_events::MAX_EVENT_SERIALIZED_LEN,\n            private_notes::MAX_NOTE_PACKED_LEN,\n        },\n        processing::{\n            log_retrieval_request::LogRetrievalRequest,\n            log_retrieval_response::LogRetrievalResponse,\n            note_validation_request::NoteValidationRequest, pending_tagged_log::PendingTaggedLog,\n        },\n    },\n    oracle,\n};\nuse event_validation_request::EventValidationRequest;\nuse protocol_types::{address::AztecAddress, hash::sha256_to_field};\n\n// Base slot for the pending tagged log array to which the fetch_tagged_logs oracle inserts found private logs.\nglobal PENDING_TAGGED_LOG_ARRAY_BASE_SLOT: Field =\n    sha256_to_field(\"AZTEC_NR::PENDING_TAGGED_LOG_ARRAY_BASE_SLOT\".as_bytes());\n\nglobal NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\n/// Searches for private logs emitted by `contract_address` that might contain messages for one of the local accounts,\n/// and stores them in a `CapsuleArray` which is then returned.\npub(crate) unconstrained fn get_private_logs(\n    contract_address: AztecAddress,\n) -> CapsuleArray<PendingTaggedLog> {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `fetchTaggedLogs`\n    // oracle. This makes PXE synchronize tags, download logs and store the pending tagged logs in a capsule array.\n    oracle::message_processing::fetch_tagged_logs(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    CapsuleArray::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT)\n}\n\n/// Enqueues a note for validation by PXE, so that it becomes aware of a note's existence allowing for later retrieval\n/// via `get_notes` oracle. The note will be scoped to `contract_address`, meaning other contracts will not be able to\n/// access it unless authorized.\n///\n/// In order for the note validation and insertion to occur, `validate_enqueued_notes_and_events` must be later called.\n/// For optimal performance, accumulate as many note validation requests as possible and then validate them all at the\n/// end (which results in PXE minimizing the number of network round-trips).\n///\n/// The `packed_note` is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\npub(crate) unconstrained fn enqueue_note_for_validation(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `NoteValidationRequest`\n    CapsuleArray::at(contract_address, NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        NoteValidationRequest {\n            contract_address,\n            storage_slot,\n            note_nonce,\n            packed_note,\n            note_hash,\n            nullifier,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Enqueues an event for validation by PXE, so that it can be efficiently validated and then inserted into the event\n/// store.\n///\n/// In order for the event validation and insertion to occur, `validate_enqueued_notes_and_events` must be later\n/// called. For optimal performance, accumulate as many event validation requests as possible and then validate them\n/// all at the end (which results in PXE minimizing the number of network round-trips).\npub(crate) unconstrained fn enqueue_event_for_validation(\n    contract_address: AztecAddress,\n    event_type_id: EventSelector,\n    serialized_event: BoundedVec<Field, MAX_EVENT_SERIALIZED_LEN>,\n    event_commitment: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `EventValidationRequest`\n    CapsuleArray::at(contract_address, EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        EventValidationRequest {\n            contract_address,\n            event_type_id,\n            serialized_event,\n            event_commitment,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Validates all note and event validation requests enqueued via `enqueue_note_for_validation` and\n/// `enqueue_event_for_validation`, inserting them into the note database and event store respectively, making them\n/// queryable via `get_notes` oracle and our TS API (PXE::getPrivateEvents).\n///\n/// This automatically clears both validation request queues, so no further work needs to be done by the caller.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(contract_address: AztecAddress) {\n    oracle::message_processing::validate_enqueued_notes_and_events(\n        contract_address,\n        NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n        EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n    );\n}\n\n/// Efficiently queries the node for logs that result in the completion of all `DeliveredPendingPartialNote`s stored in\n/// a `CapsuleArray` by performing all node communication concurrently. Returns a second `CapsuleArray` with Options for\n/// the responses that correspond to the pending partial notes at the same index.\n///\n/// For example, given an array with pending partial notes `[ p1, p2, p3 ]`, where `p1` and `p3` have corresponding\n/// completion logs but `p2` does not, the returned `CapsuleArray` will have contents\n/// `[some(p1_log), none(), some(p3_log)]`.\npub(crate) unconstrained fn get_pending_partial_notes_completion_logs(\n    contract_address: AztecAddress,\n    pending_partial_notes: CapsuleArray<DeliveredPendingPartialNote>,\n) -> CapsuleArray<Option<LogRetrievalResponse>> {\n    let log_retrieval_requests =\n        CapsuleArray::at(contract_address, LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT);\n\n    // We create a LogRetrievalRequest for each PendingPartialNote in the CapsuleArray. Because we need the indices in\n    // the request array to match the indices in the partial note array, we can't use CapsuleArray::for_each, as that\n    // function has arbitrary iteration order. Instead, we manually iterate the array from the beginning and push into\n    // the requests array, which we expect to be empty.\n    let mut i = 0;\n    let pending_partial_notes_count = pending_partial_notes.len();\n    while i < pending_partial_notes_count {\n        let pending_partial_note = pending_partial_notes.get(i);\n        log_retrieval_requests.push(\n            LogRetrievalRequest {\n                contract_address,\n                unsiloed_tag: pending_partial_note.note_completion_log_tag,\n            },\n        );\n        i += 1;\n    }\n\n    oracle::message_processing::bulk_retrieve_logs(\n        contract_address,\n        LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT,\n        LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT,\n    );\n\n    CapsuleArray::at(contract_address, LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT)\n}\n"
    },
    "149": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::{Deserialize, Packable, Serialize};\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, note_nonce: Field },\n//   Settled{ note_nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Deserialize, Eq, Serialize, Packable)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_note_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_note_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_note_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_note_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_note_nonce }\n            }\n        } else if maybe_note_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_note_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_note_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_note_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.note_nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.note_nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    note_nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    note_nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n"
    },
    "152": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().note_nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullification<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullification_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullification`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullification_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let note_nonce = retrieved_note.metadata.to_pending_previous_phase().note_nonce();\n\n        compute_unique_note_hash(note_nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullification =\n        compute_note_hash_for_nullification(retrieved_note, storage_slot);\n    let inner_nullifier =\n        retrieved_note.note.compute_nullifier(context, note_hash_for_nullification);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "156": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(privateCallPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "157": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize,\n{\n    let serialized_option = load_oracle(contract_address, slot, <T as Deserialize>::N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(utilityStoreCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(utilityLoadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(utilityDeleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(utilityCopyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), value);\n        });\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            let new_value = MockStruct::new(7, 8);\n            store(contract_address, SLOT, new_value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n        });\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n            delete(contract_address, SLOT);\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            delete(contract_address, SLOT);\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 5;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 10;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 1;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 2;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n            assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n            assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 2;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 1;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n            assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n            assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n        });\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            copy(contract_address, SLOT, SLOT, 1);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let value = MockStruct::new(5, 6);\n            store(other_contract_address, SLOT, value);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let _: Option<MockStruct> = load(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            delete(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            copy(other_contract_address, SLOT, SLOT, 0);\n        });\n    }\n}\n"
    },
    "158": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(privateNotifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(privateNotifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(privateNotifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "159": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use crate::context::utility_context::UtilityContext;\n\n#[oracle(utilityGetUtilityContext)]\nunconstrained fn get_utility_context_oracle() -> UtilityContext {}\n\n/// Returns a utility context built from the global variables of anchor block and the contract address of the function\n/// being executed.\npub unconstrained fn get_utility_context() -> UtilityContext {\n    get_utility_context_oracle()\n}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars, true)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n    predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        let mut result = if double_predicate {\n            // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n            embedded_curve_add_unsafe(point1, point1)\n        } else {\n            let point1_1 = EmbeddedCurvePoint {\n                x: point1.x + (x_coordinates_match as Field),\n                y: point1.y,\n                is_infinite: false,\n            };\n            let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n            // point1_1 is guaranteed to have a different abscissa than point2:\n            // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n            // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n            // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n            // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n            // therefore we only want to do this if we need the result, otherwise it needs to be eliminated as a dead instruction, lest we want the circuit to fail.\n            embedded_curve_add_unsafe(point1_1, point2_1)\n        };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n    _predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    // Ensure is_infinite is comptime\n    let point1_1 = EmbeddedCurvePoint { x: point1.x, y: point1.y, is_infinite: false };\n    let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n    embedded_curve_add_unsafe(point1_1, point2_1)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2, true)[0]\n}\n"
    },
    "160": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(privateStoreInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(privateLoadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "161": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(utilityGetContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\nstruct GetContractInstanceResult {\n    exists: bool,\n    member: Field,\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n\nunconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_deployer_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_class_id_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_deployer_internal_avm(address)[0] };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_class_id_internal_avm(address)[0] };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address)[0] };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "165": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr",
      "source": "use protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\nuse protocol_types::traits::{Deserialize, Serialize};\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(utilityGetPublicDataWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> PublicDataWitness {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    get_public_data_witness_oracle(block_number, public_data_tree_index)\n}\n"
    },
    "166": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(utilityGetKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "167": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(utilityGetPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] != 0 } },\n        ivpk_m: IvpkM { inner: Point { x: result[3], y: result[4], is_infinite: result[5] != 0 } },\n        ovpk_m: OvpkM { inner: Point { x: result[6], y: result[7], is_infinite: result[8] != 0 } },\n        tpk_m: TpkM { inner: Point { x: result[9], y: result[10], is_infinite: result[11] != 0 } },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "169": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/message_processing.nr",
      "source": "use protocol_types::address::AztecAddress;\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn fetch_tagged_logs(pending_tagged_log_array_base_slot: Field) {\n    fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(utilityFetchTaggedLogs)]\nunconstrained fn fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n// This must be a single oracle and not one for notes and one for events because the entire point is to validate\n// all notes and events in one go, minimizing node round-trips.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {\n    validate_enqueued_notes_and_events_oracle(\n        contract_address,\n        note_validation_requests_array_base_slot,\n        event_validation_requests_array_base_slot,\n    );\n}\n\n#[oracle(utilityValidateEnqueuedNotesAndEvents)]\nunconstrained fn validate_enqueued_notes_and_events_oracle(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {}\n\npub(crate) unconstrained fn bulk_retrieve_logs(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {\n    bulk_retrieve_logs_oracle(\n        contract_address,\n        log_retrieval_requests_array_base_slot,\n        log_retrieval_responses_array_base_slot,\n    );\n}\n\n#[oracle(utilityBulkRetrieveLogs)]\nunconstrained fn bulk_retrieve_logs_oracle(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n\n    #[test]\n    fn check_decompose_edge_cases() {\n        assert_eq(decompose(0), (0, 0));\n        assert_eq(decompose(TWO_POW_128 - 1), (TWO_POW_128 - 1, 0));\n        assert_eq(decompose(TWO_POW_128 + 1), (1, 1));\n        assert_eq(decompose(TWO_POW_128 * 2), (0, 2));\n        assert_eq(decompose(TWO_POW_128 * 2 + 0x1234567890), (0x1234567890, 2));\n    }\n\n    #[test]\n    fn check_decompose_large_values() {\n        let large_field = 0xffffffffffffffff;\n        let (lo, hi) = decompose(large_field);\n        assert_eq(large_field, lo + TWO_POW_128 * hi);\n\n        let large_value = large_field - TWO_POW_128;\n        let (lo2, hi2) = decompose(large_value);\n        assert_eq(large_value, lo2 + TWO_POW_128 * hi2);\n    }\n\n    #[test]\n    fn check_lt_comprehensive() {\n        assert(lt(0, 1));\n        assert(!lt(1, 0));\n        assert(!lt(0, 0));\n        assert(!lt(42, 42));\n\n        assert(lt(TWO_POW_128 - 1, TWO_POW_128));\n        assert(!lt(TWO_POW_128, TWO_POW_128 - 1));\n    }\n}\n"
    },
    "171": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::note::{note_interface::NoteType, retrieved_note::RetrievedNote};\n\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(privateNotifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(privateNotifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(privateNotifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(utilityGetNotes)]\nunconstrained fn get_notes_oracle<Note, let M: u32, let MaxNotes: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; M],\n    _select_by_offsets: [u8; M],\n    _select_by_lengths: [u8; M],\n    _select_values: [Field; M],\n    _select_comparators: [u8; M],\n    _sort_by_indexes: [u8; M],\n    _sort_by_offsets: [u8; M],\n    _sort_by_lengths: [u8; M],\n    _sort_order: [u8; M],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    // This is always set to MAX_NOTES. We need to pass it to TS in order to correctly construct the BoundedVec\n    _max_notes: u32,\n    // This is always set to <RetrievedNote<Note> as Packable>::N. We need to pass it to TS in order to be able to\n    // correctly construct the BoundedVec there.\n    _packed_retrieved_note_length: u32,\n) -> BoundedVec<[Field; <RetrievedNote<Note> as Packable>::N], MaxNotes>\nwhere\n    // TODO(https://github.com/noir-lang/noir/issues/9399): `Note: Packable` should work here.\n    RetrievedNote<Note>: Packable,\n{}\n\npub unconstrained fn get_notes<Note, let M: u32, let MaxNotes: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Option<RetrievedNote<Note>>; MaxNotes]\nwhere\n    Note: NoteType + Packable,\n{\n    let packed_retrieved_notes: BoundedVec<[Field; <RetrievedNote<Note> as Packable>::N], MaxNotes>\n         = get_notes_oracle::<Note, M, MaxNotes>(\n            storage_slot,\n            num_selects,\n            select_by_indexes,\n            select_by_offsets,\n            select_by_lengths,\n            select_values,\n            select_comparators,\n            sort_by_indexes,\n            sort_by_offsets,\n            sort_by_lengths,\n            sort_order,\n            limit,\n            offset,\n            status,\n            MaxNotes,\n            <RetrievedNote<Note> as Packable>::N,\n        );\n\n    let mut notes = BoundedVec::<_, MaxNotes>::new();\n    for i in 0..packed_retrieved_notes.len() {\n        let retrieved_note = RetrievedNote::unpack(packed_retrieved_notes.get(i));\n        notes.push(retrieved_note);\n    }\n\n    // At last we convert the bounded vector to an array of options. We do this because that is what the filter\n    // function needs to have on the output and we've decided to have the same type on the input and output of\n    // the filter and preprocessor functions.\n    //\n    // We have decided to have the same type on the input and output of the filter and preprocessor functions because\n    // it allows us to chain multiple filters and preprocessors together.\n    //\n    // So why do we want the array of options on the output of the filter function?\n    //\n    // Filter returns an array of options rather than a BoundedVec for performance reasons. Using an array of options\n    // allows setting values at known indices in the output array which is much more efficient than pushing to a\n    // BoundedVec where the write position depends on previous iterations. The array can then be efficiently converted\n    // to a BoundedVec using utils/array/collapse.nr::collapse function from Aztec.nr. This avoids expensive dynamic\n    // memory access patterns that would be required when building up a BoundedVec incrementally. For preprocessor\n    // functions we could use BoundedVec return value as there the optimization does not matter since it is applied in\n    // an unconstrained context. We, however, use the same return value type to be able to use the same function as\n    // both a preprocessor and a filter.\n    let mut notes_array = [Option::none(); MaxNotes];\n    for i in 0..notes.len() {\n        if i < notes.len() {\n            notes_array[i] = Option::some(notes.get_unchecked(i));\n        }\n    }\n\n    notes_array\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(utilityCheckNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n// TODO: Oracles below are generic private log oracles and are not specific to notes. Move them somewhere else.\n\n/// Returns the next app tag for a given sender and recipient pair.\n///\n/// This also notifies the simulator that a tag has been used in a note, and to therefore increment the\n/// associated index so that future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub unconstrained fn get_next_app_tag_as_sender(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> Field {\n    get_next_app_tag_as_sender_oracle(sender, recipient)\n}\n\n#[oracle(privateGetNextAppTagAsSender)]\nunconstrained fn get_next_app_tag_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> Field {}\n\n/// Gets the sender for tags.\n///\n/// This unconstrained value is used as the sender when computing an unconstrained shared secret\n/// for a tag in order to emit a log. Constrained tagging should not use this as there is no\n/// guarantee that the recipient knows about the sender, and hence about the shared secret.\n///\n/// The value persists through nested calls, meaning all calls down the stack will use the same\n/// 'senderForTags' value (unless it is replaced).\npub unconstrained fn get_sender_for_tags() -> Option<AztecAddress> {\n    get_sender_for_tags_oracle()\n}\n\n#[oracle(privateGetSenderForTags)]\nunconstrained fn get_sender_for_tags_oracle() -> Option<AztecAddress> {}\n\n/// Sets the sender for tags.\n///\n/// This unconstrained value is used as the sender when computing an unconstrained shared secret\n/// for a tag in order to emit a log. Constrained tagging should not use this as there is no\n/// guarantee that the recipient knows about the sender, and hence about the shared secret.\n///\n/// Account contracts typically set this value before calling other contracts. The value persists\n/// through nested calls, meaning all calls down the stack will use the same 'senderForTags'\n/// value (unless it is replaced by another call to this setter).\npub unconstrained fn set_sender_for_tags(sender_for_tags: AztecAddress) {\n    set_sender_for_tags_oracle(sender_for_tags);\n}\n\n#[oracle(privateSetSenderForTags)]\nunconstrained fn set_sender_for_tags_oracle(_sender_for_tags: AztecAddress) {}\n"
    },
    "174": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(utilityGetSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "175": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(utilityStorageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: u32,\n    length: u32,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(address.to_field(), storage_slot, block_number, N)\n}\n\npub unconstrained fn storage_read<T>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"utilityStorageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"utilityStorageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"
    },
    "176": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/version.nr",
      "source": "/// The ORACLE_VERSION constant is used to check that the oracle interface is in sync between PXE and Aztec.nr. We need\n/// to version the oracle interface to ensure that developers get a reasonable error message if they use incompatible\n/// versions of Aztec.nr and PXE. The TypeScript counterpart is in `oracle_version.ts`.\n///\n/// @dev Whenever a contract function or Noir test is run, the `utilityAssertCompatibleOracleVersion` oracle is called and\n/// if the oracle version is incompatible an error is thrown.\npub global ORACLE_VERSION: Field = 3;\n\n/// Asserts that the version of the oracle is compatible with the version expected by the contract.\npub fn assert_compatible_oracle_version() {\n    // Safety: This oracle call returns nothing: we only call it to check Aztec.nr and Oracle interface versions are\n    // compatible. It is therefore always safe to call.\n    unsafe {\n        assert_compatible_oracle_version_wrapper();\n    }\n}\n\nunconstrained fn assert_compatible_oracle_version_wrapper() {\n    assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n}\n\n#[oracle(utilityAssertCompatibleOracleVersion)]\nunconstrained fn assert_compatible_oracle_version_oracle(version: Field) {}\n\nmod test {\n    use super::{assert_compatible_oracle_version_oracle, ORACLE_VERSION};\n\n    #[test]\n    unconstrained fn compatible_oracle_version() {\n        assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n    }\n\n    #[test(should_fail_with = \"Incompatible oracle version. TXE is using version '3', but got a request for '318183437'.\")]\n    unconstrained fn incompatible_oracle_version() {\n        let arbitrary_incorrect_version = 318183437;\n        assert_compatible_oracle_version_oracle(arbitrary_incorrect_version);\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n"
    },
    "180": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::HasStorageSlot;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\n\n/// Map\n///\n/// A key-value storage container that maps keys to state variables, similar\n/// to Solidity mappings.\n///\n/// `Map` enables you to associate keys (like addresses or other identifiers)\n/// with state variables in your Aztec smart contract. This is conceptually\n/// similar to Solidity's `mapping(K => V)` syntax, where you can store and\n/// retrieve values by their associated keys.\n///\n/// You can declare a state variable contained within a Map in your contract's\n/// #[storage] struct.\n///\n/// For example, you might use\n/// `Map<AztecAddress, PrivateMutable<ValueNote, Context>, Context>` to track\n/// token balances for different users, similar to how you'd use\n/// `mapping(address => uint256)` in Solidity.\n///\n/// > Aside: the verbose `Context` in the declaration is a consequence of\n/// > leveraging Noir's regular syntax for generics to ensure that certain\n/// > state variable methods can only be called in some contexts (private,\n/// > public, utility).\n///\n/// The methods of Map are:\n/// - `at` (access state variable for a given key)\n/// (see the method's own doc comments for more info).\n///\n/// ## Generic Parameters\n/// - `K`: The key type (must implement `ToField` trait for hashing)\n/// - `V`: The value type:\n///   - any Aztec state variable:\n///     - `PublicMutable`\n///     - `PublicImmutable`\n///     - `PrivateMutable`\n///     - `PrivateImmutable`\n///     - `PrivateSet`\n///     - `DelayedPublicMutable`\n///     - `Map`\n/// - `Context`: The execution context (handles private/public function\n///   contexts)\n///\n/// ## Usage\n/// Maps are typically declared in your contract's #[storage] struct and\n/// accessed\n/// using the `at(key)` method to get the state variable for a specific key.\n/// The resulting state variable can then be read from or written to using its\n/// own methods.\n///\n/// ## Advanced\n/// Internally, `Map` uses a single base storage slot to represent the\n/// mapping\n/// itself, similar to Solidity's approach. Individual key-value pairs are\n/// stored at derived storage slots computed by hashing the base storage\n/// slot\n/// with the key using Poseidon2. This ensures:\n/// - No storage slot collisions between different keys\n/// - Uniform distribution of storage slots across the storage space\n/// - Compatibility with Aztec's storage tree structure\n/// - Gas-efficient storage access patterns similar to Solidity mappings\n///\n/// The storage slot derivation uses `derive_storage_slot_in_map(base_slot,\n/// key)` which computes `poseidon2_hash([base_slot, key.to_field()])`,\n/// ensuring cryptographically secure slot separation.\n///\n/// docs:start:map\npub struct Map<K, V, Context> {\n    pub context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n\n// Map reserves a single storage slot regardless of what it stores because\n// nothing is stored at said slot: it is only used to derive the storage slots\n// of nested state variables, which is expected to never result in collisions\n// or slots being close to one another due to these being hashes. This mirrors\n// the strategy adopted by Solidity mappings.\nimpl<K, T, Context> HasStorageSlot<1> for Map<K, T, Context> {\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    /// Initializes a new Map state variable.\n    ///\n    /// This function is usually automatically called within the #[storage]\n    /// macro.\n    /// You typically don't need to call this directly when writing smart contracts.\n    ///\n    /// # Arguments\n    ///\n    /// * `context` - One of `PrivateContext`/`PublicContext`/`UtilityContext`.\n    ///               The Context determines which methods of this struct will\n    ///               be made available to the calling smart contract function.\n    /// * `storage_slot` - A unique identifier for this Map within the contract.\n    ///                    Usually, the #[storage] macro will determine an\n    ///                    appropriate storage_slot automatically. A smart\n    ///                    contract dev shouldn't have to worry about this, as\n    ///                    it's managed behind the scenes.\n    /// * `state_var_constructor` - A function that creates the value type (V)\n    ///                             given a context and storage slot. This is\n    ///                             typically the constructor of the state\n    ///                             variable type being stored in the Map.\n    ///\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n\n    /// Returns the state variable associated with the given key.\n    ///\n    /// This is equivalent to accessing `mapping[key]` in Solidity. It returns\n    /// the state variable instance for the specified key, which can then be\n    /// used to read or write the value at that key.\n    ///\n    /// Unlike Solidity mappings which return the value directly, this returns\n    /// the state variable wrapper (like PrivateMutable, PublicMutable, etc.)\n    /// that you then call methods on to interact with the actual value.\n    ///\n    /// # Arguments\n    ///\n    /// * `key` - The key to look up in the map. Must implement the ToField\n    ///           trait (which most basic Noir & Aztec types do).\n    ///\n    /// # Returns\n    ///\n    /// * `V` - The state variable instance for this key. You can then call\n    ///         methods like `.read()`, `.write()`, `.get_note()`, etc. on this\n    ///         depending on the specific state variable type.\n    ///\n    /// # Example\n    ///\n    /// ```noir\n    /// // Get a user's balance (assuming PrivateMutable<ValueNote>)\n    /// let user_balance = storage.balances.at(user_address);\n    /// let current_note = user_balance.get_note();\n    ///\n    /// // Update the balance\n    /// user_balance.replace(new_note);\n    /// ```\n    ///\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n}\n"
    },
    "188": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr",
      "source": "use crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::storage::HasStorageSlot,\n    utils::with_hash::WithHash,\n};\nuse protocol_types::{\n    constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator,\n    traits::Packable,\n};\n\n/// # PublicImmutable\n///\n/// PublicImmutable is a public state variable type for values that are set once\n/// during initialization and remain permanently unchanged.\n///\n/// You can declare a state variable of type PublicImmutable within your contract's\n/// #[storage] struct:\n///\n/// E.g.:\n/// `your_variable: PublicImmutable<T, Context>`\n///\n/// PublicImmutable stores an immutable value in public state which can be _read_\n/// from public, utility and even _private_ execution contexts.\n///\n/// The methods of PublicImmutable are:\n/// - `initialize`\n/// - `read`\n/// (see the methods' own doc comments for more info).\n///\n/// # Generic Parameters:\n///\n/// * `T` - The type of value stored (must implement Packable).\n/// * `Context` - The execution context (PublicContext, PrivateContext, or UtilityContext).\n///\n/// # Advanced\n///\n/// PublicImmutable leverages `WithHash<T>` to enable efficient private reads of\n/// public storage. The `WithHash` wrapper optimizes reads by hashing values that would\n/// be larger than a single field into a single field, then proving inclusion of only\n/// the hash in public storage.\n///\n/// This optimization is particularly valuable when T packs to multiple fields,\n/// as it maintains \"almost constant\" verification overhead regardless of the\n/// original data size.\n///\n/// ## Optimizing private reads in your contract\n/// Since reading T from public immutable storage in private contexts has \"almost\n/// constant\" constraint costs regardless of T's size, it's recommended to group\n/// multiple values into a single struct when they are to be read together. This is\n/// typically useful for configuration data set during contract initialization. E.g.:\n///\n/// ```noir\n/// use dep::aztec::protocol_types::{address::AztecAddress, traits::Packable};\n/// use std::meta::derive;\n///\n/// #[derive(Eq, Packable)]\n/// pub struct Config \\{\n///     pub address_1: AztecAddress,\n///     pub value_1: u128,\n///     pub value_2: u64,\n///     ...\n/// }\n/// ```\n///\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\n/// `PublicImmutable` stores both the packed value (using M fields) and its hash (1 field), requiring M + 1 total\n/// fields.\nimpl<T, Context, let M: u32> HasStorageSlot<M + 1> for PublicImmutable<T, Context>\nwhere\n    T: Packable<N = M>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    /// Initializes a new PublicImmutable state variable.\n    ///\n    /// This function is usually automatically called within the #[storage] macro.\n    /// You typically don't need to call this directly when writing smart contracts.\n    ///\n    /// # Arguments\n    ///\n    /// * `context` - One of `PublicContext`/`PrivateContext`/`UtilityContext`. The\n    ///               Context determines which methods of this struct will be made\n    ///               available to the calling smart contract function.\n    /// * `storage_slot` - A unique identifier for this state variable within the\n    ///                    contract. Usually, the #[storage] macro will determine an\n    ///                    appropriate storage_slot automatically. A smart contract\n    ///                    dev shouldn't have to worry about this, as it's managed\n    ///                    behind the scenes.\n    ///\n    /// docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n        )\n    }\n}\n\nimpl<T> PublicImmutable<T, &mut PublicContext> {\n    /// Initializes a PublicImmutable state variable instance with a permanent value.\n    ///\n    /// This function sets the immutable value for this state variable. It can only\n    /// be called once per PublicImmutable. Subsequent calls will fail because the\n    /// initialization nullifier will already exist.\n    ///\n    /// # Arguments\n    /// * `value` - The permanent value to store in this PublicImmutable.\n    ///\n    /// # Panics\n    /// Panics if the value is already initialized.\n    ///\n    /// # Advanced\n    ///\n    /// This function performs the following operations:\n    /// - Creates and emits an initialization nullifier to mark this storage slot\n    ///   as initialized. This prevents double-initialization.\n    /// - Wraps the value in `WithHash<T>` for efficient private reads.\n    /// - Stores the wrapped value in Aztec's public data tree.\n    ///\n    /// docs:start:public_immutable_struct_write\n    pub fn initialize(self, value: T)\n    where\n        T: Packable + Eq,\n    {\n        // We emit an initialization nullifier to indicate that the struct is initialized. This also prevents\n        // the value from being initialized again as a nullifier can be included only once.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        self.context.storage_write(self.storage_slot, WithHash::new(value));\n    }\n\n    /// Reads the permanent value stored in this PublicImmutable state variable.\n    ///\n    /// # Returns\n    /// * `T` - The permanent value stored in this PublicImmutable.\n    ///\n    /// # Panics\n    /// Panics if the value is not initialized.\n    ///\n    /// # Advanced\n    ///\n    /// This function performs the following operations:\n    /// - Checks that the state variable has been initialized by verifying the\n    ///   initialization nullifier exists\n    /// - Reads the `WithHash<T>` wrapper from public storage\n    /// - Extracts and returns the original value T\n    ///\n    /// The function will panic if called on an uninitialized PublicImmutable.\n    ///\n    /// docs:start:public_immutable_struct_read\n    pub fn read(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        assert(self.is_initialized(), \"Trying to read from uninitialized PublicImmutable\");\n        WithHash::public_storage_read(*self.context, self.storage_slot)\n    }\n\n    /// Reads the value stored in this PublicImmutable without checking if the value\n    /// is initialized.\n    ///\n    /// This function bypasses the initialization check and directly reads from\n    /// storage.\n    /// If the PublicImmutable has not been initialized, this will return a\n    /// zeroed value.\n    /// However, if the variable is _known_ to be initialized, this is cheaper\n    /// to call than `read`.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The value stored in this PublicImmutable, or empty/default values if\n    ///         uninitialized.\n    ///\n    pub fn read_unsafe(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        WithHash::public_storage_read(*self.context, self.storage_slot)\n    }\n\n    fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.nullifier_exists(nullifier, self.context.this_address())\n    }\n}\n\nimpl<T> PublicImmutable<T, UtilityContext> {\n    /// Reads the permanent value stored in this PublicImmutable state variable.\n    ///\n    /// Notice that this function is executable only within a UtilityContext, which\n    /// is an unconstrained environment on the user's local device.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The permanent value stored in this PublicImmutable.\n    ///\n    pub unconstrained fn read(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        // TODO(#15703): this fn should fail if the variable is not initialized\n        WithHash::utility_public_storage_read(self.context, self.storage_slot)\n    }\n}\n\nimpl<T> PublicImmutable<T, &mut PrivateContext> {\n    /// Reads the permanent value stored in this PublicImmutable from the anchor\n    /// block.\n    ///\n    /// Private functions execute asynchronously and offchain. When a user begins\n    /// private execution, their view of the chain 'branches off' from the current\n    /// public state, since public state continues to advance while they execute\n    /// privately. Therefore, private functions read from a historical snapshot of\n    /// public state rather than the current state.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The permanent value stored in this PublicImmutable at the historical\n    ///         block referenced by the private context.\n    ///\n    /// # Advanced\n    ///\n    /// This function performs a historical read using the block header from the private\n    /// context. The `WithHash` optimization is particularly valuable here because it\n    /// reduces the number of required inclusion proofs by proving membership of\n    /// only the hash instead of the full packed value.\n    ///\n    /// The historical read mechanism:\n    /// - Uses an oracle to obtain the value from the anchor block\n    /// - Proves inclusion of the value's hash in the public data tree\n    /// - Proves that the root of this public data tree is correct, relative to the\n    ///   anchor block header.\n    /// - Verifies that the oracle-provided value matches the stored hash\n    ///\n    pub fn read(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        // TODO(#15703): this fn should fail if the variable is not initialized\n        WithHash::historical_public_storage_read(\n            self.context.get_anchor_block_header(),\n            self.context.this_address(),\n            self.storage_slot,\n        )\n    }\n}\n"
    },
    "19": {
      "path": "std/hash/mod.nr",
      "source": "// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"
    },
    "190": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr",
      "source": "use crate::context::{PublicContext, UtilityContext};\nuse crate::state_vars::storage::HasStorageSlot;\nuse dep::protocol_types::traits::Packable;\n\n/// # PublicMutable\n///\n/// PublicMutable is a public state variable type for values that can be read\n/// and written within #[external(\"public\")] functions of your smart contract.\n///\n/// You can declare a state variable of type PublicMutable within your contract's\n/// #[storage] struct:\n///\n/// E.g.:\n/// `your_variable: PublicMutable<T, Context>`\n/// or:\n/// `your_mapping: Map<Field, PublicMutable<T, Context>>`\n///\n/// The methods of PublicMutable are:\n/// - `read`\n/// - `write`\n/// (see the methods' own doc comments for more info).\n///\n/// ## Example.\n///\n/// A voting contract's proposal count can be represented as a PublicMutable<u64>.\n/// The count can be read by anyone to see how many proposals exist, and incremented\n/// when new proposals are submitted.\n///\n/// # Generic Parameters:\n///\n/// * `T` - The type of value stored (must implement Packable).\n/// * `Context` - The execution context (PublicContext or UtilityContext).\n///\n/// # Advanced\n///\n/// Unlike private state variables which use notes, PublicMutable stores values\n/// directly in Aztec's public data tree. This enables direct read and write\n/// access to the current state during public function execution.\n///\n/// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\nimpl<T, Context, let M: u32> HasStorageSlot<M> for PublicMutable<T, Context>\nwhere\n    T: Packable<N = M>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    /// Initializes a new PublicMutable state variable.\n    ///\n    /// This function is usually automatically called within the #[storage] macro.\n    /// You typically don't need to call this directly when writing smart contracts.\n    ///\n    /// # Arguments\n    ///\n    /// * `context` - One of `PublicContext`/`UtilityContext`. The Context determines\n    ///               which methods of this struct will be made available to the calling\n    ///               smart contract function.\n    /// * `storage_slot` - A unique identifier for this state variable within the\n    ///                    contract. Usually, the #[storage] macro will determine an\n    ///                    appropriate storage_slot automatically. A smart contract\n    ///                    dev shouldn't have to worry about this, as it's managed\n    ///                    behind the scenes.\n    ///\n    /// docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n}\n\nimpl<T> PublicMutable<T, &mut PublicContext> {\n    /// Reads the current value stored in this PublicMutable state variable.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The current value stored in this PublicMutable.\n    ///\n    /// docs:start:public_mutable_struct_read\n    pub fn read(self) -> T\n    where\n        T: Packable,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n\n    /// Writes a new value to this PublicMutable state variable.\n    ///\n    /// # Arguments\n    ///\n    /// * `value` - The new value to store in this PublicMutable.\n    ///\n    /// # Advanced\n    ///\n    /// This function updates the value stored in Aztec's public data tree.\n    /// The new value becomes immediately available to subsequent reads within\n    /// the same transaction.\n    ///\n    /// docs:start:public_mutable_struct_write\n    pub fn write(self, value: T)\n    where\n        T: Packable,\n    {\n        self.context.storage_write(self.storage_slot, value);\n    }\n}\n\nimpl<T> PublicMutable<T, UtilityContext> {\n    /// Reads the current value stored in this PublicMutable state variable.\n    ///\n    /// Notice that this function is executable only within a UtilityContext, which\n    /// is an unconstrained environment on the user's local device.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The current value stored in this PublicMutable.\n    ///\n    pub unconstrained fn read(self) -> T\n    where\n        T: Packable,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"
    },
    "210": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends the elements of the second `BoundedVec` to the end of the first one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let ALen: u32, let BLen: u32, let DstLen: u32>(\n    a: BoundedVec<T, ALen>,\n    b: BoundedVec<T, BLen>,\n) -> BoundedVec<T, DstLen> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "213": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DstLen` elements from a source array, starting at `offset`. `DstLen` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SrcLen: u32, let DstLen: u32>(src: [T; SrcLen], offset: u32) -> [T; DstLen] {\n    assert(offset + DstLen <= SrcLen, \"DstLen too large for offset\");\n\n    let mut dst: [T; DstLen] = std::mem::zeroed();\n    for i in 0..DstLen {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DstLen to be 0, so we always get back an empty array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "214": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DstMaxLen` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DstLen` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DstLen` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SrcMaxLen: u32, let DstMaxLen: u32>(\n    bvec: BoundedVec<T, SrcMaxLen>,\n    offset: u32,\n) -> BoundedVec<T, DstMaxLen> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "216": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "217": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "220": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use protocol_types::{point::Point, utils::field::sqrt};\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\n/// Returns a `Point` in the Grumpkin curve given its x coordinate.\n///\n/// Because not all values in the field are valid x coordinates of points in the curve (i.e. there\n/// is no corresponding y value in the field that satisfies the curve equation), it may not be\n/// possible to reconstruct a `Point`. `Option::none()` is returned in such cases.\npub fn point_from_x_coord(x: Field) -> Option<Point> {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    sqrt(rhs).map(|y| Point { x, y, is_infinite: false })\n}\n\n/// Returns a `Point` in the Grumpkin curve given its x coordinate and sign for the y coordinate.\n///\n/// Because not all values in the field are valid x coordinates of points in the curve (i.e. there\n/// is no corresponding y value in the field that satisfies the curve equation), it may not be\n/// possible to reconstruct a `Point`. `Option::none()` is returned in such cases.\n///\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Option<Point> {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n\n    sqrt(rhs).map(|y| {\n        // If there is a square root, we need to ensure it has the correct \"sign\"\n        let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n        let final_y = if y_is_positive == sign { y } else { -y };\n        Point { x, y: final_y, is_infinite: false }\n    })\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord, point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n    use dep::protocol_types::utils::field::pow;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign).unwrap();\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2).unwrap();\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_valid() {\n        // x = 8 is a known quadratic residue - should give a valid point\n        let result = point_from_x_coord(Field::from(8));\n        assert(result.is_some());\n\n        let point = result.unwrap();\n        assert_eq(point.x, Field::from(8));\n        // Check curve equation y^2 = x^3 - 17\n        assert_eq(pow(point.y, 2), pow(point.x, 3) - 17);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_invalid() {\n        // x = 3 is a non-residue for this curve - should give None\n        let x = Field::from(3);\n        let maybe_point = point_from_x_coord(x);\n        assert(maybe_point.is_none());\n    }\n\n}\n"
    },
    "224": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr",
      "source": "use crate::{\n    context::{PublicContext, UtilityContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    abis::block_header::BlockHeader, address::AztecAddress, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `M` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `M`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let M: u32> {\n    value: T,\n    packed: [Field; M],\n    hash: Field,\n}\n\nimpl<T, let M: u32> WithHash<T, M>\nwhere\n    T: Packable<N = M> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn utility_public_storage_read(\n        context: UtilityContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + M as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\n// Note: I don't derive Packable on `WithHash` because `derive_serialize` function does not support setting \"N = M\"\n// as I do here 3 lines below. This could be worked around by placing the \"where\" clause directly on the `WithHash`\n// struct, but Jake mentioned that the syntax is not expected to be supported at least until Noir 1.0.\n// Relevant discussion on Slack:\n// https://aztecprotocol.slack.com/archives/C04QF64EDNV/p1752593876160699?thread_ts=1752589887.955379&cid=C04QF64EDNV\nimpl<T, let M: u32> Packable for WithHash<T, M>\nwhere\n    T: Packable<N = M>,\n{\n    let N: u32 = M + 1;\n\n    fn pack(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n        for i in 0..M {\n            result[i] = self.packed[i];\n        }\n        result[M] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; Self::N]) -> Self {\n        let mut value_packed = [0; M];\n        for i in 0..M {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[M];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::test::OracleMock;\n\n    global STORAGE_SLOT: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let env = TestEnvironment::new();\n\n        env.private_context(|context| {\n            let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n                context.anchor_block_header,\n                context.this_address(),\n                STORAGE_SLOT,\n            );\n\n            assert_eq(result, std::mem::zeroed());\n        });\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        env.public_context(|context| { context.storage_write(STORAGE_SLOT, value_with_hash); });\n\n        env.private_context(|context| {\n            let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n                context.anchor_block_header,\n                context.this_address(),\n                STORAGE_SLOT,\n            );\n            assert_eq(result, value);\n        });\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn bad_hint_uninitialized_value() {\n        let env = TestEnvironment::new();\n\n        env.private_context(|context| {\n            let block_header = context.anchor_block_header;\n            let address = context.this_address();\n\n            // Mock the oracle to return a non-zero hint/packed value\n            let value_packed = MockStruct { a: 1, b: 1 }.pack();\n            let _ = OracleMock::mock(\"utilityStorageRead\")\n                .with_params((\n                    address.to_field(), STORAGE_SLOT, block_header.global_variables.block_number,\n                    value_packed.len(),\n                ))\n                .returns(value_packed)\n                .times(1);\n\n            // This should fail because the hint value is non-zero and the hash is zero (default value of storage)\n            let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n                block_header,\n                address,\n                STORAGE_SLOT,\n            );\n        });\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn bad_hint_initialized_value() {\n        let env = TestEnvironment::new();\n\n        env.public_context(|context| {\n            // Write the value and hash separately so that the hash is wrong\n            let value = MockStruct { a: 5, b: 3 };\n            context.storage_write(STORAGE_SLOT, value);\n\n            let incorrect_hash = 13;\n            let hash_storage_slot = STORAGE_SLOT + (value.pack().len() as Field);\n            context.storage_write(hash_storage_slot, [incorrect_hash]);\n        });\n\n        env.private_context(|context| {\n            let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n                context.anchor_block_header,\n                context.this_address(),\n                STORAGE_SLOT,\n            );\n        });\n    }\n}\n"
    },
    "231": {
      "path": "/home/jpag/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr",
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "253": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\nuse std::meta::derive;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct FunctionSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    pub inner: u32,\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "294": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\nuse std::meta::derive;\n\n// Aztec address\n#[derive(Deserialize, Eq, Packable, Serialize)]\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    /// Returns an address's `AddressPoint`, which can be used to create shared secrets with the owner\n    /// of the address. If the address is invalid (i.e. it is not a properly derived Aztec address), then this\n    /// returns `Option::none()`, and no shared secrets can be created.\n    pub fn to_address_point(self) -> Option<AddressPoint> {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // An invalid AztecAddress is one for which no y coordinate satisfies the curve equation, which we'll\n        // identify by proving that the square root of y_squared does not exist.\n        let mut y_opt = sqrt(y_squared);\n        if y_opt.is_none() {\n            Option::none()\n        } else {\n            let mut y = y_opt.unwrap();\n\n            // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n            // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n            // note: The field modulus is MAX_FIELD_VALUE + 1\n            if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n                y = (MAX_FIELD_VALUE + 1) - y;\n            }\n\n            Option::some(\n                AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } },\n            )\n        }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    // We use the AZTEC_ADDRESS_LENGTH constant to ensure that there is a match between the derived trait\n    // implementation and the constant.\n    let serialized: [Field; AZTEC_ADDRESS_LENGTH] = address.serialize();\n    let deserialized = AztecAddress::deserialize(serialized);\n    assert_eq(address, deserialized);\n}\n\n#[test]\nfn to_address_point_valid() {\n    // x = 8 where x^3 - 17 = 512 - 17 = 495, which is a residue in this field\n    let address = AztecAddress { inner: 8 };\n    let maybe_point = address.to_address_point();\n    assert(maybe_point.is_some());\n\n    let point = maybe_point.unwrap().inner;\n    // check that x is preserved\n    assert_eq(point.x, Field::from(8));\n\n    // check that the curve equation holds: y^2 == x^3 - 17\n    assert_eq(pow(point.y, 2), pow(point.x, 3) - 17);\n}\n\n#[test]\nunconstrained fn to_address_point_invalid() {\n    // x = 3 where x^3 - 17 = 27 - 17 = 10, which is a non-residue in this field\n    let address = AztecAddress { inner: 3 }; //\n    let maybe_point = address.to_address_point();\n    assert(maybe_point.is_none());\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n"
    },
    "307": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr",
      "source": "use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Deserialize, Empty, Hash, Serialize},\n};\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: Field,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl LeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: Field) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"
    },
    "309": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "// TODO: Expose other wrapped functions than debug (info, warn)\n// ['silent', 'fatal', 'error', 'warn', 'info', 'verbose', 'debug', 'trace']\n\npub global SILENT_LOG_LEVEL: u8 = 0;\npub global FATAL_LOG_LEVEL: u8 = 1;\npub global ERROR_LOG_LEVEL: u8 = 2;\npub global WARN_LOG_LEVEL: u8 = 3;\npub global INFO_LOG_LEVEL: u8 = 4;\npub global VERBOSE_LOG_LEVEL: u8 = 5;\npub global DEBUG_LOG_LEVEL: u8 = 6;\npub global TRACE_LOG_LEVEL: u8 = 7;\n\n/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Same as debug_log, but allows to customize the log level.\n/// Consider changing just to 'log'\npub fn debug_log_with_level<let N: u32>(log_level: u8, msg: str<N>) {\n    debug_log_format_with_level(log_level, msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_array_oracle_wrapper(DEBUG_LOG_LEVEL, msg, args) };\n}\n\n/// Same as debug_log_format, but allows to customize the log level.\n/// Consider changing just to 'log_format'\npub fn debug_log_format_with_level<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field; N],\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_array_oracle_wrapper(log_level, msg, args) };\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` slice.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole slice: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format_slice<let M: u32>(log_level: u8, msg: str<M>, args: [Field]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_slice_oracle_wrapper(log_level, msg, args) };\n}\n\n// We provide two versions of the debug log oracle: one that takes args as a slice and another one that takes args as an array.\n// We do this since conversion from array to slice generates overhead in public functions, since opcodes need to be emitted for the conversion.\n// By exposing the two flavors, we avoid conversions since the AVM is able to handle both arrays an slices in this oracle.\n\nunconstrained fn debug_log_slice_oracle_wrapper<let M: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field],\n) {\n    debug_log_slice_oracle(log_level, msg, args);\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_slice_oracle<let M: u32>(log_level: u8, msg: str<M>, args: [Field]) {}\n\nunconstrained fn debug_log_array_oracle_wrapper<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_array_oracle(log_level, msg, N, args);\n}\n\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_array_oracle<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    length: u32,\n    args: [Field; N],\n) {}\n"
    },
    "319": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "mod poseidon2_chunks;\n\nuse crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_log::{PrivateLog, PrivateLogData},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root_from_sibling_path,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    poseidon2::Poseidon2Sponge,\n    side_effect::{Counted, Scoped},\n    traits::{FromField, Hash, ToField},\n    utils::field::{field_from_bytes, field_from_bytes_32_trunc},\n};\n\npub use poseidon2_chunks::poseidon2_absorb_in_chunks_existing_sponge;\nuse poseidon2_chunks::poseidon2_absorb_in_chunks;\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(note_nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [note_nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_nonce_and_unique_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    let note_nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n    compute_unique_note_hash(note_nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        compute_nonce_and_unique_note_hash(siloed_note_hash, first_nullifier, note_index_in_tx)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: Scoped<Counted<NoteHash>>) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.innermost())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: Scoped<Counted<Nullifier>>) -> Field {\n    let value = nullifier.innermost().value;\n    // Q: shouldn't we be checking whether the _whole_ nullifier is empty?\n    // A: We don't have to. The init and inner circuits add contract address to non-empty nullifiers.\n    // So we know we should silo it if the contract address is not empty.\n    if nullifier.contract_address.is_zero() {\n        value // Return `value` instead of 0 because an already-siloed nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, value)\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<Counted<PrivateLogData>>) -> PrivateLog {\n    let log = private_log.innermost().log;\n    if private_log.contract_address.is_zero() {\n        log\n    } else {\n        let mut fields = log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, log.length)\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn compute_app_secret_key(\n    master_secret_key: EmbeddedCurveScalar,\n    app_address: AztecAddress,\n    app_secret_generator: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [master_secret_key.hi, master_secret_key.lo, app_address.to_field()],\n        app_secret_generator,\n    )\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let contract_address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    let recipient_bytes: [u8; 20] = recipient.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let rollup_version_id_bytes: [u8; 32] = rollup_version_id.to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n\n    let mut bytes: [u8; 148] = std::mem::zeroed();\n    for i in 0..32 {\n        bytes[i] = contract_address_bytes[i];\n        bytes[i + 32] = rollup_version_id_bytes[i];\n        // 64 - 84 are for recipient.\n        bytes[i + 84] = chain_id_bytes[i];\n        bytes[i + 116] = content_bytes[i];\n    }\n\n    for i in 0..20 {\n        bytes[64 + i] = recipient_bytes[i];\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: Scoped<L2ToL1Message>,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.inner.recipient,\n            msg.inner.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n/// Computes sha256 hash of 2 input fields.\n///\n/// @returns A truncated field (i.e., the first byte is always 0).\npub fn accumulate_sha256(v0: Field, v1: Field) -> Field {\n    // Concatenate two fields into 32 x 2 = 64 bytes\n    let v0_as_bytes: [u8; 32] = v0.to_be_bytes();\n    let v1_as_bytes: [u8; 32] = v1.to_be_bytes();\n    let hash_input_flattened = v0_as_bytes.concat(v1_as_bytes);\n\n    sha256_to_field(hash_input_flattened)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = [separator.to_field()].concat(inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n/// Computes a Poseidon2 hash over a dynamic-length subarray of the given input.\n/// Only the first `in_len` fields of `input` are absorbed; any remaining fields are ignored.\n/// The caller is responsible for ensuring that the input is padded with zeros if required.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_in_chunks(input, in_len);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_in_chunks(input, in_len);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n// This function is  unconstrained because it is intended to be used in unconstrained context only as\n// in constrained contexts it would be too inefficient.\npub unconstrained fn poseidon2_hash_with_separator_bounded_vec<let N: u32, T>(\n    inputs: BoundedVec<Field, N>,\n    separator: T,\n) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs.get(i));\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0x3b18c58c739716e76429634a61375c45b3b5cd470c22ab6d3e14cee23dd992);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0xaab2a5828156782b12a1dc6f336e2bc627eb1b9514b02d511f66296990c050);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        L2ToL1Message { recipient: EthAddress::from_field(1), content: 2 }.scope(\n            AztecAddress::from_field(3),\n        ),\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `yarn-project/stdlib/src/hash/hash.test.ts`\n    let hash_from_typescript = 0x0081edf209e087ad31b3fd24263698723d57190bd1d6e9fe056fc0c0a68ee661;\n\n    assert_eq(hash, hash_from_typescript);\n}\n\n#[test]\nunconstrained fn poseidon2_hash_with_separator_bounded_vec_matches_non_bounded_vec_version() {\n    let inputs = BoundedVec::<Field, 4>::from_array([1, 2, 3]);\n    let separator = 42;\n\n    // Hash using bounded vec version\n    let bounded_result = poseidon2_hash_with_separator_bounded_vec(inputs, separator);\n\n    // Hash using regular version\n    let regular_result = poseidon2_hash_with_separator([1, 2, 3], separator);\n\n    // Results should match\n    assert_eq(bounded_result, regular_result);\n}\n"
    },
    "328": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      "source": "use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_tree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n/// These values are precomputed and we run tests to ensure that they are correct.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_tree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_tree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_tree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_tree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_tree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_tree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_tree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_tree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_tree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_tree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_tree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_tree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"
    },
    "332": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use utils::derive_serialization_quotes;\n\npub mod utils;\n\n/// Generates the generic parameter declarations for a struct's trait implementation.\n///\n/// This function takes a struct type definition and generates the generic parameter declarations\n/// that go after the `impl` keyword. For example, given a struct with generics `N: u32` and `T`,\n/// it generates `<let N: u32, T>`.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate generic declarations for\n///\n/// # Returns\n/// A quoted code block containing the generic parameter declarations, or an empty quote if the struct\n/// has no generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// This function generates:\n/// ```\n/// <let N: u32, T>\n/// ```\ncomptime fn get_generics_declarations(s: TypeDefinition) -> Quoted {\n    let generics = s.generics();\n\n    if generics.len() > 0 {\n        let generics_declarations_items = generics\n            .map(|(name, maybe_integer_typ)| {\n                // The second item in the generics tuple is an Option of an integer type that is Some only if\n                // the generic is numeric.\n                if maybe_integer_typ.is_some() {\n                    // The generic is numeric, so we return a quote defined as e.g. \"let N: u32\"\n                    let integer_type = maybe_integer_typ.unwrap();\n                    quote {let $name: $integer_type}\n                } else {\n                    // The generic is not numeric, so we return a quote containing the name of the generic (e.g. \"T\")\n                    quote {$name}\n                }\n            })\n            .join(quote {,});\n        quote {<$generics_declarations_items>}\n    } else {\n        // The struct doesn't have any generics defined, so we just return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates the `where` clause for a trait implementation that constrains non-numeric generic type parameters.\n///\n/// This function takes a struct type definition and a trait name, and generates a `where` clause that\n/// requires all non-numeric generic type parameters to implement the specified trait.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the where clause for\n/// - `trait_name`: The name of the trait that non-numeric generic parameters must implement\n///\n/// # Returns\n/// A quoted code block containing the where clause, or an empty quote if the struct has no non-numeric\n/// generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// And trait name \"Serialize\", this function generates:\n/// ```\n/// where T: Serialize\n/// ```\ncomptime fn get_where_trait_clause(s: TypeDefinition, trait_name: Quoted) -> Quoted {\n    let generics = s.generics();\n\n    // The second item in the generics tuple is an Option of an integer type that is Some only if the generic is\n    // numeric.\n    let non_numeric_generics =\n        generics.filter(|(_, maybe_integer_typ)| maybe_integer_typ.is_none());\n\n    if non_numeric_generics.len() > 0 {\n        let non_numeric_generics_declarations =\n            non_numeric_generics.map(|(name, _)| quote {$name: $trait_name}).join(quote {,});\n        quote {where $non_numeric_generics_declarations}\n    } else {\n        // There are no non-numeric generics, so we return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates a `Serialize` trait implementation for a struct type.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A quoted code block containing the trait implementation\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Log<N> {\n///     fields: [Field; N],\n///     length: u32\n/// }\n/// ```\n///\n/// This function generates code equivalent to:\n/// ```\n/// impl<let N: u32> Serialize for Log<N> {\n///     let N: u32 = <[Field; N] as Serialize>::N + <u32 as Serialize>::N;\n///\n///     #[inline_always]\n///     fn serialize(self) -> [Field; Self::N] {\n///         let mut serialized_params = [0; _];\n///         let mut offset = 0;\n///\n///         let serialized_member = Serialize::serialize(self.fields);\n///         let serialized_member_len = <[Field; N] as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             serialized_params[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         let serialized_member = Serialize::serialize(self.length);\n///         let serialized_member_len = <u32 as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             serialized_params[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         serialized_params\n///     }\n/// }\n/// ```\npub comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n\n    // We care only about the name and type so we drop the last item of the tuple\n    let params = nested_struct.0.fields(nested_struct.1).map(|(name, typ, _)| (name, typ));\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Serialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_serialize_clause = get_where_trait_clause(s, quote {Serialize});\n\n    let (function_body, params_len_quote, serialized_params_name) =\n        derive_serialization_quotes(params, true);\n\n    quote {\n        impl$generics_declarations $crate::traits::Serialize for $typ\n            $where_serialize_clause\n        {\n            let N: u32 = $params_len_quote;\n\n            #[inline_always]\n            fn serialize(self) -> [Field; Self::N] {\n                $function_body\n\n                $serialized_params_name\n            }\n        }\n    }\n}\n\n/// Generates a `Deserialize` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Deserialize` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Deserialize for MyStruct {\n///     let N: u32 = <AztecAddress as Deserialize>::N + <Field as Deserialize>::N;\n///\n///     fn deserialize(serialized: [Field; Self::N]) -> Self {\n///         let mut offset = 0;\n///         let mut member_fields = [0; <AztecAddress as Deserialize>::N];\n///         for i in 0..<AztecAddress as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let x = <AztecAddress as Deserialize>::deserialize(member_fields);\n///         offset += <AztecAddress as Deserialize>::N;\n///\n///         let mut member_fields = [0; <Field as Deserialize>::N];\n///         for i in 0..<Field as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let y = <Field as Deserialize>::deserialize(member_fields);\n///         offset += <Field as Deserialize>::N;\n///\n///         Self { x, y }\n///     }\n/// }\n/// ```\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Deserialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_deserialize_clause = get_where_trait_clause(s, quote {Deserialize});\n\n    // The following will give us <type_of_struct_member_1 as Deserialize>::N + <type_of_struct_member_2 as Deserialize>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Deserialize>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly deserializing the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let function_body = if params.len() > 1 {\n        // This generates deserialization code for each struct member and concatenates them together.\n        let deserialization_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as Deserialize>::N];\n                    for i in 0..<$param_type as Deserialize>::N {\n                        member_fields[i] = serialized[i + offset];\n                    }\n                    let $param_name = <$param_type as Deserialize>::deserialize(member_fields);\n                    offset += <$param_type as Deserialize>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        // This will give us e.g. `a, b, c` for a struct with three fields named `a`, `b`, and `c`.\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n\n            $deserialization_of_struct_members\n\n            Self { $struct_members }\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Deserialize::deserialize(serialized) }\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Deserialize for $typ\n            $where_deserialize_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn deserialize(serialized: [Field; Self::N]) -> Self {\n                $function_body\n            }\n        }\n    }\n}\n\n/// Generates a `Packable` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Packable` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Packable for MyStruct {\n///     let N: u32 = 2;\n///\n///     fn pack(self) -> [Field; 2] {\n///         let mut result: [Field; 2] = [0_Field; 2];\n///         let mut offset: u32 = 0_u32;\n///         let packed_member: [Field; 1] = self.x.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         let packed_member: [Field; 1] = self.y.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         result\n///     }\n///\n///     fn unpack(packed: [Field; 2]) -> Self {\n///         let mut offset: u32 = 0_u32;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<AztecAddress as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let x: AztecAddress = <AztecAddress as Packable>::unpack(member_fields);\n///         offset = offset + <AztecAddress as Packable>::N;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<Field as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let y: Field = <Field as Packable>::unpack(member_fields);\n///         offset = offset + <Field as Packable>::N;\n///         Self { x: x, y: y }\n///     }\n/// }\n/// ```\npub comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Packable` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_packable_clause = get_where_trait_clause(s, quote {Packable});\n\n    // The following will give us <type_of_struct_member_1 as Packable>::N + <type_of_struct_member_2 as Packable>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Packable>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly returning the packed member,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let pack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate packing code that:\n        // 1. Packs each member\n        // 2. Copies the packed fields into the result array at the correct offset\n        // 3. Updates the offset for the next member\n        let packing_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let packed_member = $crate::traits::Packable::pack(self.$param_name);\n                    let packed_member_len = <$param_type as $crate::traits::Packable>::N;\n                    for i in 0..packed_member_len {\n                        result[i + offset] = packed_member[i];\n                    }\n                    offset += packed_member_len;\n                }\n            })\n            .join(quote {});\n\n        quote {\n            let mut result = [0; Self::N];\n            let mut offset = 0;\n\n            $packing_of_struct_members\n\n            result\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            $crate::traits::Packable::pack(self.$param_name)\n        }\n    };\n\n    // For structs containing a single member, we can enhance performance by directly unpacking the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let unpack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate unpacking code that:\n        // 1. Unpacks each member\n        // 2. Copies packed fields into member array at correct offset\n        // 3. Updates offset for next member\n        let unpacking_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as $crate::traits::Packable>::N];\n                    for i in 0..<$param_type as $crate::traits::Packable>::N {\n                        member_fields[i] = packed[i + offset];\n                    }\n                    let $param_name = <$param_type as $crate::traits::Packable>::unpack(member_fields);\n                    offset += <$param_type as $crate::traits::Packable>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n            $unpacking_of_struct_members\n            Self { $struct_members }\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Packable::unpack(packed) }\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Packable for $typ\n            $where_packable_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn pack(self) -> [Field; Self::N] {\n                $pack_function_body\n            }\n\n            #[inline_always]\n            fn unpack(packed: [Field; Self::N]) -> Self {\n                $unpack_function_body\n            }\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Packable, Serialize};\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct Smol {\n        a: Field,\n        b: Field,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct HasArray {\n        a: [Field; 2],\n        b: bool,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct Fancier {\n        a: Smol,\n        b: [Field; 2],\n        c: [u8; 3],\n        d: str<16>,\n    }\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct HasArrayWithGenerics<T, let N: u32> {\n        pub fields: [T; N],\n        pub length: u32,\n    }\n\n    #[test]\n    fn serde_on_smol() {\n        let smol = Smol { a: 1, b: 2 };\n        let serialized = smol.serialize();\n        assert(serialized == [1, 2], serialized);\n        let deserialized = Smol::deserialize(serialized);\n        assert(deserialized == smol);\n\n        // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n        let packed = smol.pack();\n        assert_eq(packed, serialized, \"Packed does not match serialized\");\n    }\n\n    #[test]\n    fn serde_on_has_array() {\n        let has_array = HasArray { a: [1, 2], b: true };\n        let serialized = has_array.serialize();\n        assert(serialized == [1, 2, 1], serialized);\n        let deserialized = HasArray::deserialize(serialized);\n        assert(deserialized == has_array);\n    }\n\n    #[test]\n    fn serde_on_fancier() {\n        let fancier =\n            Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n        let serialized = fancier.serialize();\n        assert(\n            serialized\n                == [\n                    1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                    0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n                ],\n            serialized,\n        );\n        let deserialized = Fancier::deserialize(serialized);\n        assert(deserialized == fancier);\n    }\n\n    #[test]\n    fn serde_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let serialized = struct_with_array_of_generics.serialize();\n        assert(serialized == [1, 2, 3, 3], serialized);\n        let deserialized = HasArrayWithGenerics::deserialize(serialized);\n        assert(deserialized == struct_with_array_of_generics);\n    }\n\n    #[test]\n    fn packable_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let packed = struct_with_array_of_generics.pack();\n        assert(packed == [1, 2, 3, 3], packed);\n\n        let unpacked = HasArrayWithGenerics::unpack(packed);\n        assert(unpacked == struct_with_array_of_generics);\n    }\n\n}\n"
    },
    "333": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/meta/utils.nr",
      "source": "/// Generates serialization code for a list of parameters and the total length of the serialized array\n///\n/// # Parameters\n/// - `params`: A list of (name, type) tuples to serialize\n/// - `use_self_prefix`: If true, parameters are accessed as `self.$param_name` (for struct members).\n///                      If false, parameters are accessed directly as `$param_name` (for function parameters).\n///\n/// # Returns\n/// A tuple containing:\n/// - Quoted code that serializes the parameters into an array named `serialized_params`\n/// - Quoted code that evaluates to the total length of the serialized array\n/// - Quoted code containing the name of the serialized array\npub comptime fn derive_serialization_quotes(\n    params: [(Quoted, Type)],\n    use_self_prefix: bool,\n) -> (Quoted, Quoted, Quoted) {\n    let prefix_quote = if use_self_prefix {\n        quote { self. }\n    } else {\n        quote {}\n    };\n\n    let params_len_quote = get_params_len_quote(params);\n    let serialized_params_name = quote { serialized_params };\n\n    let body = if params.len() == 0 {\n        quote {\n            let $serialized_params_name: [Field; 0] = [];\n        }\n    } else if params.len() == 1 {\n        // When we have only a single parameter on the input, we can enhance performance by directly returning\n        // the serialized member, bypassing the need for loop-based array construction. While this optimization yields\n        // significant benefits in Brillig where the loops are expected to not be optimized, it is not relevant in ACIR\n        // where the loops are expected to be optimized away.\n\n        let param_name = params[0].0;\n        quote {\n            let $serialized_params_name = $crate::traits::Serialize::serialize($prefix_quote$param_name);\n        }\n    } else {\n        // For multiple struct members, generate serialization code that:\n        // 1. Serializes each member\n        // 2. Copies the serialized fields into the serialize array at the correct offset\n        // 3. Updates the offset for the next member\n        let serialization_of_struct_members = params\n            .map(|(param_name, param_type): (Quoted, Type)| {\n                quote {\n                let serialized_member = $crate::traits::Serialize::serialize($prefix_quote$param_name);\n                let serialized_member_len = <$param_type as $crate::traits::Serialize>::N;\n                for i in 0..serialized_member_len {\n                    $serialized_params_name[i + offset] = serialized_member[i];\n                }\n                offset += serialized_member_len;\n            }\n            })\n            .join(quote {});\n\n        quote {\n            let mut $serialized_params_name = [0; $params_len_quote];\n            let mut offset = 0;\n\n            $serialization_of_struct_members\n        }\n    };\n\n    (body, params_len_quote, serialized_params_name)\n}\n\n/// Generates a quoted expression that computes the total serialized length of function parameters.\n///\n/// # Parameters\n/// * `params` - An array of tuples where each tuple contains a quoted parameter name and its Type. The type needs\n///              to implement the Serialize trait.\n///\n/// # Returns\n/// A quoted expression that evaluates to:\n/// * `0` if there are no parameters\n/// * `(<type1 as Serialize>::N + <type2 as Serialize>::N + ...)` for one or more parameters\npub comptime fn get_params_len_quote(params: [(Quoted, Type)]) -> Quoted {\n    if params.len() == 0 {\n        quote { 0 }\n    } else {\n        let params_quote_without_parentheses = params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n                    <$param_type as $crate::traits::Serialize>::N\n                }\n            })\n            .join(quote {+});\n        quote { ($params_quote_without_parentheses) }\n    }\n}\n"
    },
    "334": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl Serialize for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn serialize(self: Self) -> [Field; Self::N] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn deserialize(serialized: [Field; Self::N]) -> Self {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] != 0 }\n    }\n}\n\n// TODO(#11356): use compact representation here.\nimpl Packable for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn pack(self) -> [Field; Self::N] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; Self::N]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "335": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\nuse crate::traits::{Deserialize, Serialize};\nuse std::meta::derive;\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "342": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::{default::Default, meta::derive};\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nmod test {\n    use crate::{\n        point::POINT_LENGTH,\n        public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n        traits::{Deserialize, Serialize},\n    };\n    use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\n    #[test]\n    unconstrained fn compute_public_keys_hash() {\n        let keys = PublicKeys {\n            npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n            ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n            ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n            tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n        };\n\n        let actual = keys.hash();\n        let expected_public_keys_hash =\n            0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n        assert(actual.to_field() == expected_public_keys_hash);\n    }\n\n    #[test]\n    unconstrained fn compute_default_hash() {\n        let keys = PublicKeys::default();\n\n        let actual = keys.hash();\n        let test_data_default_hash =\n            0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n        assert(actual.to_field() == test_data_default_hash);\n    }\n\n    #[test]\n    unconstrained fn serde() {\n        let keys = PublicKeys {\n            npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n            ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n            ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n            tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n        };\n\n        // We use the PUBLIC_KEYS_LENGTH constant to ensure that there is a match between the derived trait\n        let serialized: [Field; POINT_LENGTH * 4] = keys.serialize();\n        let deserialized = PublicKeys::deserialize(serialized);\n\n        assert_eq(keys, deserialized);\n    }\n}\n"
    },
    "347": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "363": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty: Eq {\n    fn empty() -> Self;\n\n    fn is_empty(self) -> bool {\n        self.eq(Self::empty())\n    }\n\n    // Requires this Noir fix: https://github.com/noir-lang/noir/issues/9002\n    // fn assert_not_empty<let U: u32>(self, msg: str<U>) { // This msg version was failing with weird compiler errors.\n    //     // We provide a default impl but it's likely inefficient.\n    //     // The reason we include this function is because there's a lot of\n    //     // opportunity for optimisation on a per-struct basis.\n    //     // You only need to show one element is not empty to know that the whole thing\n    //     // is not empty.\n    //     // If you know an element of your struct which should always be nonempty,\n    //     // you can write an impl that solely checks that that element is nonempty.\n    //     assert(!self.is_empty(), msg);\n    // }\n\n    // This default impl is overwritten by types like arrays, because there's a much\n    // more efficient approach.\n    fn assert_empty<let S: u32>(self, msg: str<S>) {\n        assert(self.is_empty(), msg);\n    }\n}\n\nimpl Empty for Field {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u16 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\n\nimpl<T> Empty for [T]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty()]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\nimpl<A, B> Empty for (A, B)\nwhere\n    A: Empty,\n    B: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        (A::empty(), B::empty())\n    }\n}\n\nimpl<T> Empty for Option<T>\nwhere\n    T: Eq,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\n// pub fn is_empty<T>(item: T) -> bool\n// where\n//     T: Empty,\n// {\n//     item.eq(T::empty())\n// }\n\n// pub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\n// where\n//     T: Empty,\n// {\n//     array.all(|elem| is_empty(elem))\n// }\n\n// pub fn assert_empty<T>(item: T) -> ()\n// where\n//     T: Empty,\n// {\n//     assert(item.eq(T::empty()))\n// }\n\n// pub fn assert_empty_array<T, let N: u32>(array: [T; N]) -> ()\n// where\n//     T: Empty,\n// {\n//     // A cheaper option than `is_empty_array` for if you don't need to gracefully\n//     // handle a bool result.\n//     // Avoids the `&` operator of `is_empty_array`'s `.all()` call.\n//     for i in 0..N {\n//         assert(is_empty(array[i]));\n//     }\n// }\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u16 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value != 0\n    }\n}\nimpl FromField for u1 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u16 {\n    fn from_field(value: Field) -> Self {\n        value as u16\n    }\n}\nimpl FromField for u32 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Associated Constants\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize for str<N> {\n///     let N: u32 = N;\n///\n///     fn serialize(self) -> [Field; Self::N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; Self::N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize {\n    let N: u32;\n\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let M: u32> Serialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; Self::N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n/// Implementation of Deserialize for BoundedVec.\n///\n/// This implementation deserializes a BoundedVec from an array of Fields. The array contains:\n/// 1. The serialized items, each taking up T::N Fields\n/// 2. The length of the BoundedVec as the last Field\n///\n/// # Type Parameters\n/// * `T` - The type of items stored in the BoundedVec, must implement Deserialize\n/// * `M` - The maximum length of the BoundedVec\n///\n/// # Fields Array Layout\n/// [item1_field1, item1_field2, ..., item2_field1, item2_field2, ..., length]\n/// Where:\n/// - itemN_fieldM: The M-th Field of the N-th item (T::N Fields per item)\n/// - length: The number of items in the BoundedVec (1 Field)\n///\n/// Total length N = T::N * M + 1, where:\n/// - T::N is the number of Fields needed to deserialize one item\n/// - M is the maximum length of the BoundedVec\n/// - +1 is for storing the length\n///\n/// # Note\n/// Not deriving this because it's not supported to call derive_deserialize on a \"remote\" struct (and it will never\n/// be supported).\nimpl<T, let M: u32> Deserialize for BoundedVec<T, M>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut new_bounded_vec: BoundedVec<T, M> = BoundedVec::new();\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        let len = fields[<T as Deserialize>::N * M] as u32;\n\n        for i in 0..len {\n            let mut nested_fields = [0; <T as Deserialize>::N];\n            for j in 0..<T as Deserialize>::N {\n                nested_fields[j] = fields[i * <T as Deserialize>::N + j];\n            }\n\n            let item = T::deserialize(nested_fields);\n            new_bounded_vec.push(item);\n        }\n\n        new_bounded_vec\n    }\n}\n\n// This may cause issues if used as program input, because noir disallows empty arrays for program input.\n// I think this is okay because I don't foresee a unit type being used as input. But leaving this comment as a hint\n// if someone does run into this in the future.\nimpl Deserialize for () {\n    let N: u32 = 0;\n\n    fn deserialize(_fields: [Field; Self::N]) -> Self {\n        ()\n    }\n}\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl<T, let M: u32> Serialize for BoundedVec<T, M>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M + 1; // +1 for the length of the BoundedVec\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut fields = [0; Self::N];\n\n        let storage = self.storage();\n\n        for i in 0..M {\n            let serialized_item = storage[i].serialize();\n\n            for j in 0..<T as Serialize>::N {\n                fields[i * <T as Serialize>::N + j] = serialized_item[j];\n            }\n        }\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        fields[<T as Serialize>::N * M] = self.len() as Field;\n\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Associated Constants\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let M: u32> Deserialize for str<M> {\n///     let N: u32 = M;\n///\n///     #[inline_always]\n///     fn deserialize(fields: [Field; Self::N]) -> Self {\n///         str::<Self::N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize {\n    let N: u32;\n\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let M: u32> Deserialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        str::<Self::N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Associated Constants\n/// * `N` - The length of the Field array, known at compile time\n#[derive_via(derive_packable)]\npub trait Packable {\n    let N: u32;\n\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n\n#[test]\nunconstrained fn bounded_vec_serialization() {\n    // Test empty BoundedVec\n    let empty_vec: BoundedVec<Field, 3> = BoundedVec::from_array([]);\n    let serialized = empty_vec.serialize();\n    let deserialized = BoundedVec::<Field, 3>::deserialize(serialized);\n    assert_eq(empty_vec, deserialized);\n    assert_eq(deserialized.len(), 0);\n\n    // Test partially filled BoundedVec\n    let partial_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2]]);\n    let serialized = partial_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(partial_vec, deserialized);\n    assert_eq(deserialized.len(), 1);\n    assert_eq(deserialized.get(0), [1, 2]);\n\n    // Test full BoundedVec\n    let full_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2], [3, 4], [5, 6]]);\n    let serialized = full_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(full_vec, deserialized);\n    assert_eq(deserialized.len(), 3);\n    assert_eq(deserialized.get(0), [1, 2]);\n    assert_eq(deserialized.get(1), [3, 4]);\n    assert_eq(deserialized.get(2), [5, 6]);\n}\n"
    },
    "365": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable for bool {\n    let N: u32 = BOOL_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> bool {\n        (fields[0] as u1) != 0\n    }\n}\n\nimpl Packable for u8 {\n    let N: u32 = U8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable for u16 {\n    let N: u32 = U16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable for u32 {\n    let N: u32 = U32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable for u64 {\n    let N: u32 = U64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable for u128 {\n    let N: u32 = U128_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable for Field {\n    let N: u32 = FIELD_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable for i8 {\n    let N: u32 = I8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Packable for i16 {\n    let N: u32 = I16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Packable for i32 {\n    let N: u32 = I32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Packable for i64 {\n    let N: u32 = I64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Packable for [T; M]\nwhere\n    T: Packable,\n{\n    let N: u32 = M * <T as Packable>::N;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized = self[i].pack();\n            for j in 0..<T as Packable>::N {\n                result[i * <T as Packable>::N + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Packable>::N, M>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "366": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal U1_SERIALIZED_LEN: u32 = 1;\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> bool {\n        fields[0] != 0\n    }\n}\n\nimpl Serialize for u1 {\n    let N: u32 = U1_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u1 {\n    let N: u32 = U1_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u1\n    }\n}\n\nimpl Serialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self]\n    }\n}\n\nimpl Deserialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n}\n\nimpl Deserialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Serialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n}\n\nimpl Deserialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Serialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n}\n\nimpl Deserialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Serialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n}\n\nimpl Deserialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Serialize for [T; M]\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M;\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; _] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized_t = self[i].serialize();\n            let T_N = serialized_t.len();\n            for j in 0..T_N {\n                result[i * T_N + j] = serialized_t[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let M: u32> Deserialize for [T; M]\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Deserialize>::N, M>(Deserialize::deserialize, result)\n    }\n}\n\nimpl<T> Serialize for Option<T>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N + 1;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n\n        result[0] = if self.is_some() { 1 } else { 0 };\n\n        let value_serialized = self.unwrap_unchecked().serialize();\n        for i in 0..<T as Serialize>::N {\n            result[1 + i] = value_serialized[i];\n        }\n\n        result\n    }\n}\n\nimpl<T> Deserialize for Option<T>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        if fields[0] == 1 {\n            let mut value_fields = [0; <T as Deserialize>::N];\n            for i in 0..<T as Deserialize>::N {\n                value_fields[i] = fields[1 + i];\n            }\n\n            Option::some(T::deserialize(value_fields))\n        } else {\n            Option::none()\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Serialize};\n\n    #[test]\n    fn u16_serialization() {\n        let a: u16 = 10;\n        assert_eq(a, u16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i8_serialization() {\n        let a: i8 = -10;\n        assert_eq(a, i8::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i16_serialization() {\n        let a: i16 = -10;\n        assert_eq(a, i16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i32_serialization() {\n        let a: i32 = -10;\n        assert_eq(a, i32::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i64_serialization() {\n        let a: i64 = -10;\n        assert_eq(a, i64::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn option_field_serialization() {\n        let opt_some = Option::some(5);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n\n    #[test]\n    fn array_serialization() {\n        let array = [1, 2, 3, 4];\n\n        let serialized: [Field; 4] = array.serialize();\n        let deserialized: [Field; 4] = Deserialize::deserialize(serialized);\n        assert_eq(deserialized, array);\n    }\n\n    #[test]\n    fn nested_array_serialization() {\n        let nested_array = [[1, 2, 3, 4], [5, 6, 7, 8]];\n\n        let serialized: [Field; 8] = nested_array.serialize();\n        let deserialized: [[Field; 4]; 2] = Deserialize::deserialize(serialized);\n\n        assert_eq(deserialized, nested_array);\n    }\n\n    #[test]\n    fn option_array_serialization() {\n        let opt_some = Option::some([2, 5]);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n}\n"
    },
    "384": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "global KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\npub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO: This currently only exists to aid point compression in compress_to_blob_commitment().\n// Once compression is part of BigCurve it can either be removed or optimized to be used elsewhere.\npub fn byte_to_bits_be(byte: u8) -> [u1; 8] {\n    let mut mut_byte = byte;\n    let mut bits: [u1; 8] = [0; 8];\n    for i in 0..8 {\n        bits[7 - i] = (mut_byte & 1) as u1;\n        mut_byte >>= 1;\n    }\n    bits\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n/// Returns Option::some(sqrt) if there is a square root, and Option::none() if there isn't.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\nunconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n\n#[test]\nunconstrained fn sqrt_valid_test() {\n    let x = 16; // examples: 16, 9, 25, 81\n    let result = sqrt(x);\n    assert(result.is_some());\n    assert_eq(result.unwrap() * result.unwrap(), x);\n}\n\n#[test]\nunconstrained fn sqrt_invalid_test() {\n    let x = KNOWN_NON_RESIDUE; // has no square root in the field\n    let result = sqrt(x);\n    assert(result.is_none());\n}\n"
    },
    "388": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_u64(&mut self) -> u64 {\n        self.read() as u64\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() != 0\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert_eq(self.offset, self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "444": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/uint-note/src/uint_note.nr",
      "source": "use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    history::nullifier_inclusion::ProveNullifierInclusion,\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    messages::logs::note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{\n            GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER,\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT, PRIVATE_LOG_SIZE_IN_FIELDS,\n        },\n        hash::{compute_siloed_nullifier, poseidon2_hash_with_separator},\n        traits::{Deserialize, FromField, Hash, Packable, Serialize, ToField},\n    },\n};\n\n// UintNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the amount).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n/// A private note representing a numeric value associated to an account (e.g. a token balance).\n#[derive(Deserialize, Eq, Serialize, Packable)]\n#[custom_note]\npub struct UintNote {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintPartialNotePrivateContent, and\n    //   b) have the public field at the end\n    // Correct ordering is checked by the tests in this module.\n\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The number stored in the note.\n    value: u128,\n}\n\nimpl NoteHash for UintNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because UintNote has just one variant (where the value is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let private_content =\n            UintPartialNotePrivateContent { owner: self.owner, randomness: self.randomness };\n        let partial_note = PartialUintNote {\n            commitment: private_content.compute_partial_commitment(storage_slot),\n        };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.value)\n    }\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullification: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullification, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(\n        self,\n        note_hash_for_nullification: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullification, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: u128, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness }\n    }\n\n    pub fn get_value(self) -> u128 {\n        self.value\n    }\n\n    pub fn get_owner(self) -> AztecAddress {\n        self.owner\n    }\n\n    /// Creates a partial note that will hide the owner and storage slot but not the value, since the note will be later\n    /// completed in public. This is a powerful technique for scenarios in which the value cannot be known in private\n    /// (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// This function inserts a partial note validity commitment into the nullifier tree to be later on able to verify\n    /// that the partial note and completer are legitimate. See function docs of `compute_validity_commitment` for more\n    /// details.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` so that they can discover the\n    /// note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        completer: AztecAddress,\n    ) -> PartialUintNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = UintPartialNotePrivateContent { owner, randomness }\n            .compute_partial_commitment(storage_slot);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content =\n            UintPartialNotePrivateLogContent { owner, randomness, public_log_tag: commitment };\n\n        let encrypted_log = note::compute_partial_note_private_content_log(\n            private_log_content,\n            storage_slot,\n            recipient,\n        );\n        // Regardless of the original content size, the log is padded with random bytes up to\n        // `PRIVATE_LOG_SIZE_IN_FIELDS` to prevent leaking information about the actual size.\n        let length = encrypted_log.len();\n        context.emit_private_log(encrypted_log, length);\n\n        let partial_note = PartialUintNote { commitment };\n\n        // Now we compute the validity commitment and push it to the nullifier tree. It can be safely pushed to\n        // the nullifier tree since it uses its own separator, making collisions with actual note nullifiers\n        // practically impossible.\n        let validity_commitment = partial_note.compute_validity_commitment(completer);\n        context.push_nullifier(validity_commitment);\n\n        partial_note\n    }\n}\n\n/// The private content of a partial UintNote, i.e. the fields that will remain private. All other note fields will be\n/// made public.\n#[derive(Packable)]\nstruct UintPartialNotePrivateContent {\n    // The ordering of these fields is important given that it must match that of UintNote.\n    // Correct ordering is checked by the tests in this module.\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl UintPartialNotePrivateContent {\n    fn compute_partial_commitment(self, storage_slot: Field) -> Field {\n        // Here we commit to all private values, including the storage slot.\n        poseidon2_hash_with_separator(\n            self.pack().concat([storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\n#[derive(Packable)]\nstruct UintPartialNotePrivateLogContent {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintNote, and\n    //   b) have the public log tag at the beginning\n    // Correct ordering is checked by the tests in this module.\n    public_log_tag: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteType for UintPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        UintNote::get_id()\n    }\n}\n\n/// A partial instance of a UintNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the value field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the value to the public), resulting in a UintNote that can be used like any other one (except\n/// of course that its value is known).\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct PartialUintNote {\n    commitment: Field,\n}\n\nglobal NOTE_COMPLETION_LOG_LENGTH: u32 = 2;\n\nimpl PartialUintNote {\n    /// Completes the partial note, creating a new note that can be used like any other UintNote.\n    pub fn complete(self, context: &mut PublicContext, completer: AztecAddress, value: u128) {\n        // A note with a value of zero is valid, but we cannot currently complete a partial note with such a value\n        // because this will result in the completion log having its last field set to 0. Public logs currently do not\n        // track their length, and so trailing zeros are simply trimmed. This results in the completion log missing its\n        // last field (the value), and note discovery failing.\n        // TODO(#11636): remove this\n        assert(value != 0, \"Cannot complete a PartialUintNote with a value of 0\");\n\n        // We verify that the partial note we're completing is valid (i.e. completer is correct, it uses the correct\n        // state variable's storage slot, and it is internally consistent).\n        let validity_commitment = self.compute_validity_commitment(completer);\n        assert(\n            context.nullifier_exists(validity_commitment, context.this_address()),\n            \"Invalid partial note or completer\",\n        );\n\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the value). The contract will later find it by searching\n        //  for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(value));\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    /// Completes the partial note, creating a new note that can be used like any other UintNote. Same as `complete`\n    /// function but works from private context.\n    pub fn complete_from_private(\n        self,\n        context: &mut PrivateContext,\n        completer: AztecAddress,\n        value: u128,\n    ) {\n        // We verify that the partial note we're completing is valid (i.e. completer is correct, it uses the correct\n        // state variable's storage slot, and it is internally consistent).\n        let validity_commitment = self.compute_validity_commitment(completer);\n        // `prove_nullifier_inclusion` function expects the nullifier to be siloed (hashed with the address of\n        // the contract that emitted the nullifier) as it checks the value directly against the nullifier tree and all\n        // the nullifiers in the tree are siloed by the protocol.\n        let siloed_validity_commitment =\n            compute_siloed_nullifier(context.this_address(), validity_commitment);\n        context.get_anchor_block_header().prove_nullifier_inclusion(siloed_validity_commitment);\n\n        // We need to do two things:\n        //  - emit an unencrypted log containing the public fields (the value) via the private log channel. The\n        //  contract will later find it by searching for the expected tag (which is simply the partial note\n        //  commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_private_log(\n            self.compute_note_completion_log_padded_for_private_log(value),\n            NOTE_COMPLETION_LOG_LENGTH,\n        );\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    /// Computes a validity commitment for this partial note. The commitment cryptographically binds the note's private\n    /// data with the designated completer address. When the note is later completed in public execution, we can load\n    /// this commitment from the nullifier tree and verify that both the partial note (e.g. that the storage slot\n    /// corresponds to the correct owner, and that we're using the correct state variable) and completer are\n    /// legitimate.\n    pub fn compute_validity_commitment(self, completer: AztecAddress) -> Field {\n        poseidon2_hash_with_separator(\n            [self.commitment, completer.to_field()],\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT,\n        )\n    }\n\n    fn compute_note_completion_log(self, value: u128) -> [Field; NOTE_COMPLETION_LOG_LENGTH] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, value.to_field()]\n    }\n\n    fn compute_note_completion_log_padded_for_private_log(\n        self,\n        value: u128,\n    ) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS] {\n        let note_completion_log = self.compute_note_completion_log(value);\n        let padding = [0; PRIVATE_LOG_SIZE_IN_FIELDS - NOTE_COMPLETION_LOG_LENGTH];\n        note_completion_log.concat(padding)\n    }\n\n    fn compute_complete_note_hash(self, value: u128) -> Field {\n        // Here we finalize the note hash by including the (public) value into the partial note commitment. Note that we\n        // use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator(\n            [self.commitment, value.to_field()],\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\nimpl ToField for PartialUintNote {\n    fn to_field(self) -> Field {\n        self.commitment\n    }\n}\n\nimpl FromField for PartialUintNote {\n    fn from_field(field: Field) -> Self {\n        Self { commitment: field }\n    }\n}\n\nmod test {\n    use super::{\n        PartialUintNote, UintNote, UintPartialNotePrivateContent, UintPartialNotePrivateLogContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{address::AztecAddress, traits::{Deserialize, FromField, Packable}},\n        utils::array::subarray,\n    };\n\n    global value: u128 = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a UintNote has the same note hash as a PartialUintNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n\n        let note = UintNote { value, randomness, owner };\n        let note_hash = note.compute_note_hash(storage_slot);\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n\n        let partial_note = PartialUintNote {\n            commitment: partial_note_private_content.compute_partial_commitment(storage_slot),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(value);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular UintNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular UintNote.\n\n        let note = UintNote { value, randomness, owner };\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n        let commitment = partial_note_private_content.compute_partial_commitment(storage_slot);\n\n        let private_log_content =\n            UintPartialNotePrivateLogContent { owner, randomness, public_log_tag: commitment };\n        // The following is a misuse of the `deserialize` function, but this is just a test and it's better than\n        // letting devs manually construct it when they shouldn't be able to.\n        let partial_note = PartialUintNote::deserialize([commitment]);\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(value)[0],\n        );\n\n        // Then we extract all fields except the first of both logs (i.e. the public log tag), and combine them to\n        // produce the note's packed representation. This requires that the members of the intermediate structs are in\n        // the same order as in UintNote.\n        let private_log_without_public_tag: [_; 2] = subarray(private_log_content.pack(), 1);\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(value), 1);\n\n        assert_eq(private_log_without_public_tag.concat(public_log_without_tag), note.pack());\n    }\n}\n"
    },
    "46": {
      "path": "std/slice.nr",
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice with its index, returning a\n    // new slice containing the mapped elements.\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U] {\n        let mut ret = &[];\n        let mut index = 0;\n        for elem in self {\n            ret = ret.push_back(f(index, elem));\n            index += 1;\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for elem in self {\n            f(elem);\n        }\n    }\n\n    // Apply a function to each element of the slice with its index\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        let mut index = 0;\n        for elem in self {\n            f(index, elem);\n            index += 1;\n        }\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq(&[].map(|x| x + 1), &[]);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq(&[].mapi(|i, x| i * x + 1), &[]);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_each(|_x| assert(false));\n        assert(empty_slice == &[]);\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_eachi(|_i, _x| assert(false));\n        assert(empty_slice == &[]);\n    }\n\n    #[test]\n    fn map_example() {\n        let a = &[1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, &[2, 4, 6]);\n        assert_eq(a, &[1, 2, 3]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = &[1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, &[2, 5, 8]);\n        assert_eq(a, &[1, 2, 3]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_each(|a| { *b_ref = b_ref.push_back(a * 2); });\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { *b_ref = b_ref.push_back(i + a * 2); });\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n    #[test]\n    fn len_empty() {\n        let empty: [Field] = &[];\n        assert_eq(empty.len(), 0);\n    }\n\n    #[test]\n    fn len_single() {\n        assert_eq(&[42].len(), 1);\n    }\n\n    #[test]\n    fn len_multiple() {\n        assert_eq(&[1, 2, 3, 4, 5].len(), 5);\n    }\n\n    #[test]\n    fn push_back_empty() {\n        let empty: [Field] = &[];\n        let result = empty.push_back(42);\n        assert_eq(result.len(), 1);\n        assert_eq(result[0], 42);\n    }\n\n    #[test]\n    fn push_back_non_empty() {\n        let slice = &[1, 2, 3];\n        let result = slice.push_back(4);\n        assert_eq(result.len(), 4);\n        assert_eq(result, &[1, 2, 3, 4]);\n    }\n\n    #[test]\n    fn push_front_empty() {\n        let empty = &[];\n        let result = empty.push_front(42);\n        assert_eq(result.len(), 1);\n        assert_eq(result[0], 42);\n    }\n\n    #[test]\n    fn push_front_non_empty() {\n        let slice = &[1, 2, 3];\n        let result = slice.push_front(0);\n        assert_eq(result.len(), 4);\n        assert_eq(result, &[0, 1, 2, 3]);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds\")]\n    fn pop_back_empty() {\n        let slice: [Field] = &[];\n        let (_, _) = slice.pop_back();\n    }\n\n    #[test]\n    fn pop_back_one() {\n        let slice = &[42];\n        let (result, elem) = slice.pop_back();\n        assert_eq(result.len(), 0);\n        assert_eq(elem, 42);\n    }\n\n    #[test]\n    fn pop_back_multiple() {\n        let slice = &[1, 2, 3];\n        let (result, elem) = slice.pop_back();\n        assert_eq(result.len(), 2);\n        assert_eq(result, &[1, 2]);\n        assert_eq(elem, 3);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds\")]\n    fn pop_front_empty() {\n        let slice: [Field] = &[];\n        let (_, _) = slice.pop_front();\n    }\n\n    #[test]\n    fn pop_front_one() {\n        let slice = &[42];\n        let (elem, result) = slice.pop_front();\n        assert_eq(result.len(), 0);\n        assert_eq(elem, 42);\n    }\n\n    #[test]\n    fn pop_front_multiple() {\n        let slice = &[1, 2, 3];\n        let (elem, result) = slice.pop_front();\n        assert_eq(result.len(), 2);\n        assert_eq(result, &[2, 3]);\n        assert_eq(elem, 1);\n    }\n\n    #[test]\n    fn insert_beginning() {\n        let slice = &[1, 2, 3];\n        let result = slice.insert(0, 0);\n        assert_eq(result.len(), 4);\n        assert_eq(result, &[0, 1, 2, 3]);\n    }\n\n    #[test]\n    fn insert_middle() {\n        let slice = &[1, 2, 3];\n        let result = slice.insert(1, 99);\n        assert_eq(result.len(), 4);\n        assert_eq(result, &[1, 99, 2, 3]);\n    }\n\n    #[test]\n    fn insert_end() {\n        let slice = &[1, 2, 3];\n        let result = slice.insert(3, 4);\n        assert_eq(result.len(), 4);\n        assert_eq(result, &[1, 2, 3, 4]);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds\")]\n    fn insert_end_out_of_bounds() {\n        let slice = &[1, 2];\n        let _ = slice.insert(3, 4);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds\")]\n    fn remove_empty() {\n        let slice: [Field] = &[];\n        let (_, _) = slice.remove(0);\n    }\n\n    #[test]\n    fn remove_beginning() {\n        let slice = &[1, 2, 3];\n        let (result, elem) = slice.remove(0);\n        assert_eq(result.len(), 2);\n        assert_eq(result, &[2, 3]);\n        assert_eq(elem, 1);\n    }\n\n    #[test]\n    fn remove_middle() {\n        let slice = &[1, 2, 3];\n        let (result, elem) = slice.remove(1);\n        assert_eq(result.len(), 2);\n        assert_eq(result, &[1, 3]);\n        assert_eq(elem, 2);\n    }\n\n    #[test]\n    fn remove_end() {\n        let slice = &[1, 2, 3];\n        let (result, elem) = slice.remove(2);\n        assert_eq(result.len(), 2);\n        assert_eq(result, &[1, 2]);\n        assert_eq(elem, 3);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds\")]\n    fn remove_end_out_of_bounds() {\n        let slice = &[1, 2];\n        let (_, _) = slice.remove(2);\n    }\n\n    #[test]\n    fn fold_empty() {\n        let empty = &[];\n        let result = empty.fold(10, |acc, x| acc + x);\n        assert_eq(result, 10);\n    }\n\n    #[test]\n    fn fold_single() {\n        let slice = &[5];\n        let result = slice.fold(10, |acc, x| acc + x);\n        assert_eq(result, 15);\n    }\n\n    #[test]\n    fn fold_multiple() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.fold(0, |acc, x| acc + x);\n        assert_eq(result, 10);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds\")]\n    fn reduce_empty() {\n        let empty: [Field] = &[];\n        let _ = empty.reduce(|a, b| a + b);\n    }\n\n    #[test]\n    fn reduce_single() {\n        let slice = &[42];\n        let result = slice.reduce(|a, b| a + b);\n        assert_eq(result, 42);\n    }\n\n    #[test]\n    fn reduce_multiple() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.reduce(|a, b| a + b);\n        assert_eq(result, 10);\n    }\n\n    #[test]\n    fn filter_empty() {\n        let empty = &[];\n        let result = empty.filter(|x| x > 0);\n        assert_eq(result.len(), 0);\n    }\n\n    #[test]\n    fn filter_all_true() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.filter(|x| x > 0);\n        assert_eq(result, slice);\n    }\n\n    #[test]\n    fn filter_all_false() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.filter(|x| x > 10);\n        assert_eq(result.len(), 0);\n    }\n\n    #[test]\n    fn filter_some() {\n        let slice = &[1, 2, 3, 4, 5];\n        let result = slice.filter(|x| x % 2 == 0);\n        assert_eq(result, &[2, 4]);\n    }\n\n    #[test]\n    fn all_empty() {\n        let empty = &[];\n        let result = empty.all(|x| x > 0);\n        assert_eq(result, true);\n    }\n\n    #[test]\n    fn all_true() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.all(|x| x > 0);\n        assert_eq(result, true);\n    }\n\n    #[test]\n    fn all_false() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.all(|x| x > 2);\n        assert_eq(result, false);\n    }\n\n    #[test]\n    fn any_empty() {\n        let empty = &[];\n        let result = empty.any(|x| x > 0);\n        assert_eq(result, false);\n    }\n\n    #[test]\n    fn any_true() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.any(|x| x > 3);\n        assert_eq(result, true);\n    }\n\n    #[test]\n    fn any_false() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.any(|x| x > 10);\n        assert_eq(result, false);\n    }\n\n    // utility method tests\n    #[test]\n    fn append_empty_to_empty() {\n        let empty1: [Field] = &[];\n        let empty2: [Field] = &[];\n        let result = empty1.append(empty2);\n        assert_eq(result.len(), 0);\n    }\n\n    #[test]\n    fn append_empty_to_non_empty() {\n        let slice = &[1, 2, 3];\n        let empty = &[];\n        let result = slice.append(empty);\n        assert_eq(result, slice);\n    }\n\n    #[test]\n    fn append_non_empty_to_empty() {\n        let empty = &[];\n        let slice = &[1, 2, 3];\n        let result = empty.append(slice);\n        assert_eq(result, slice);\n    }\n\n    #[test]\n    fn append_two_non_empty() {\n        let slice1 = &[1, 2];\n        let slice2 = &[3, 4, 5];\n        let result = slice1.append(slice2);\n        assert_eq(result, &[1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    fn as_array_single() {\n        let slice = &[42];\n        let array: [Field; 1] = slice.as_array();\n        assert_eq(array[0], 42);\n    }\n\n    #[test]\n    fn as_array_multiple() {\n        let slice = &[1, 2, 3];\n        let array: [Field; 3] = slice.as_array();\n        assert_eq(array[0], 1);\n        assert_eq(array[1], 2);\n        assert_eq(array[2], 3);\n    }\n\n    // complex scenarios\n    #[test]\n    fn chain_operations() {\n        let slice = &[1, 2, 3, 4, 5];\n        let result = slice.filter(|x| x % 2 == 0).map(|x| x * 2).fold(0, |acc, x| acc + x);\n        assert_eq(result, 12); // (2*2) + (4*2) = 4 + 8 = 12\n    }\n\n    #[test]\n    fn nested_operations() {\n        let slice = &[1, 2, 3, 4];\n        let filtered = slice.filter(|x| x > 1);\n        let mapped = filtered.map(|x| x * x);\n        let sum = mapped.fold(0, |acc, x| acc + x);\n        assert_eq(sum, 29); // 2^2 + 3^2 + 4^2 = 4 + 9 + 16 = 29\n    }\n\n    #[test]\n    fn single_element_operations() {\n        let single = &[42];\n\n        // Test all operations on single element\n        assert_eq(single.len(), 1);\n\n        let pushed_back = single.push_back(99);\n        assert_eq(pushed_back, &[42, 99]);\n\n        let pushed_front = single.push_front(0);\n        assert_eq(pushed_front, &[0, 42]);\n\n        let (popped_back_slice, popped_back_elem) = single.pop_back();\n        assert_eq(popped_back_slice.len(), 0);\n        assert_eq(popped_back_elem, 42);\n\n        let (popped_front_elem, popped_front_slice) = single.pop_front();\n        assert_eq(popped_front_slice.len(), 0);\n        assert_eq(popped_front_elem, 42);\n\n        let inserted = single.insert(0, 0);\n        assert_eq(inserted, &[0, 42]);\n\n        let (removed_slice, removed_elem) = single.remove(0);\n        assert_eq(removed_slice.len(), 0);\n        assert_eq(removed_elem, 42);\n    }\n\n    #[test]\n    fn boundary_conditions() {\n        let slice = &[1, 2, 3];\n\n        // insert at boundaries\n        let at_start = slice.insert(0, 0);\n        assert_eq(at_start, &[0, 1, 2, 3]);\n\n        let at_end = slice.insert(3, 4);\n        assert_eq(at_end, &[1, 2, 3, 4]);\n\n        // remove at boundaries\n        let (removed_start, elem_start) = slice.remove(0);\n        assert_eq(removed_start, &[2, 3]);\n        assert_eq(elem_start, 1);\n\n        let (removed_end, elem_end) = slice.remove(2);\n        assert_eq(removed_end, &[1, 2]);\n        assert_eq(elem_end, 3);\n    }\n\n    #[test]\n    fn complex_predicates() {\n        let slice = &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\n        let even_greater_than_5 = slice.filter(|x| (x % 2 == 0) & (x > 5));\n        assert_eq(even_greater_than_5, &[6, 8, 10]);\n\n        let all_positive_and_less_than_20 = slice.all(|x| (x > 0) & (x < 20));\n        assert_eq(all_positive_and_less_than_20, true);\n\n        let any_divisible_by_7 = slice.any(|x| x % 7 == 0);\n        assert_eq(any_divisible_by_7, true);\n    }\n\n    #[test]\n    fn identity_operations() {\n        let slice = &[1, 2, 3, 4, 5];\n\n        let mapped_identity = slice.map(|x| x);\n        assert_eq(mapped_identity, slice);\n\n        let filtered_all = slice.filter(|_| true);\n        assert_eq(filtered_all, slice);\n\n        let filtered_none = slice.filter(|_| false);\n        assert_eq(filtered_none.len(), 0);\n    }\n\n    #[test(should_fail)]\n    fn as_array_size_mismatch() {\n        let slice = &[1, 2, 3];\n        let _: [Field; 5] = slice.as_array(); // size doesn't match\n    }\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        if result {\n            for i in 0..self.len() {\n                result &= self[i].eq(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let self_len = self.len();\n        let other_len = other.len();\n        let min_len = if self_len < other_len {\n            self_len\n        } else {\n            other_len\n        };\n\n        let mut result = Ordering::equal();\n        for i in 0..min_len {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self_len.cmp(other_len)\n        }\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use super::{Eq, max, min, Ord};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n\n    #[test]\n    fn correctly_handles_unequal_length_slices() {\n        let slice_1 = &[0, 1, 2, 3];\n        let slice_2 = &[0, 1, 2];\n        assert(!slice_1.eq(slice_2));\n    }\n\n    #[test]\n    fn lexicographic_ordering_for_slices() {\n        assert(&[2_u32].cmp(&[1_u32, 1_u32, 1_u32]) == super::Ordering::greater());\n        assert(&[1_u32, 2_u32].cmp(&[1_u32, 2_u32, 3_u32]) == super::Ordering::less());\n    }\n}\n"
    },
    "51": {
      "path": "/home/jpag/Playground/aztec/crosschain/wormhole-demo/packages/aztec/src/message_bridge/src/main.nr",
      "source": "use aztec::macros::aztec;\n\npub mod config;\npub mod utils;\n\n#[aztec]\npub contract MessageBridge {\n    use aztec::{\n        macros::{\n            functions::{initializer, external, internal},\n            storage::storage,\n        },\n        protocol_types::address::AztecAddress,\n        state_vars::{map::Map, public_mutable::PublicMutable, public_immutable::PublicImmutable},\n    };\n    use crate::{\n        config::Config,\n        utils::vaa::{encode_message_payload, decode_vaa},\n    };\n    use wormhole::Wormhole;\n\n    // ============================================================================\n    // STORAGE\n    // ============================================================================\n\n    #[storage]\n    struct Storage<Context> {\n        // Core configuration (immutable after deployment)\n        config: PublicImmutable<Config, Context>,\n\n        // Owner/admin address\n        owner: PublicMutable<AztecAddress, Context>,\n\n        // Registered emitters\n        // chain id => source chain address => is_registered\n        registered_emitters: Map<u16, Map<Field, PublicImmutable<bool, Context>, Context>, Context>,\n\n        // currently stored value\n        current_value: PublicMutable<u128, Context>,\n    }\n\n    // ============================================================================\n    // INITIALIZATION\n    // ============================================================================\n\n    #[external(\"public\")]\n    #[initializer]\n    fn constructor(\n        wormhole_address: AztecAddress,\n        chain_id: u16,\n        owner: AztecAddress,\n        message_fee: u128,\n    ) {\n        storage.config.initialize(Config::new(\n            wormhole_address,\n            chain_id,\n            message_fee,\n        ));\n        storage.owner.write(owner);\n\n        // Initialize last received values to zero\n        storage.current_value.write(0);\n    }\n\n    #[external(\"public\")]\n    fn register_emitter(source_chain_id: u16, emitter_address: [u8; 32]) {\n        // 1. check caller is admin\n        let owner = storage.owner.read();\n        assert(owner == context.msg_sender().unwrap(), \"Caller is not owner\");\n\n        // 2. pack eth address into a field\n        let  mut emitter_address_truncated = [0; 31];\n        for i in 0..31 {\n            emitter_address_truncated[i] = emitter_address[i + 1];\n        }\n        let emitter_address_field = Field::from_be_bytes(emitter_address_truncated);\n\n        // 3. register emitter\n        storage.registered_emitters\n            .at(source_chain_id)\n            .at(emitter_address_field)\n            .initialize(true);\n    }\n\n    // ============================================================================\n    // SEND MESSAGE (Aztec -> EVM)\n    // ============================================================================\n\n    #[external(\"public\")]\n    fn send_value_public(\n        destination_chain_id: u16,\n        value: u128,\n        fee_nonce: Field,\n    ) {\n        // no auth checks\n        let caller = context.msg_sender().unwrap();\n        let config = storage.config.read();\n\n        // 1. Encode the message payload (just destination_chain_id + value)\n        let wormhole_payload = encode_message_payload(value, destination_chain_id);\n\n        // 2. Publish message publicly through Wormhole\n        let _ = Wormhole::at(config.wormhole_address).publish_message_in_public(\n            0, // nonce\n            wormhole_payload,\n            config.message_fee,\n            1, // consistency level (1 = confirmed)\n            caller,\n            fee_nonce,\n        ).call(&mut context);\n    }\n\n    #[external(\"private\")]\n    fn send_value_private(\n        destination_chain_id: u16,\n        value: u128,\n        fee_nonce: Field,\n    ) {\n        // no auth checks\n        let caller = context.msg_sender().unwrap();\n        let config = storage.config.read();\n\n        // 1. Encode the message payload (just destination_chain_id + value)\n        let wormhole_payload = encode_message_payload(value, destination_chain_id);\n\n        // 2. Publish message privately through Wormhole\n        let _ = Wormhole::at(config.wormhole_address).publish_message_in_private(\n            0, // nonce\n            wormhole_payload,\n            config.message_fee,\n            1, // consistency level (1 = confirmed)\n            caller,\n            fee_nonce,\n        ).call(&mut context);\n    }\n\n    // ============================================================================\n    // RECEIVE MESSAGE (EVM -> Aztec)\n    // ============================================================================\n    \n    #[external(\"private\")]\n    fn receive_value(vaa: [u8; 2000], length: u32) {\n        // 1. verify the VAA through Wormhole\n        let config = storage.config.read();\n        Wormhole::at(config.wormhole_address).verify_vaa(vaa, length).call(&mut context);\n\n        // 2. decode the VAA (envelope + payload) and compute vaa nullifier\n        let (vaa_envelope, vaa_payload, vaa_nullifier) = decode_vaa(vaa);\n\n        // 3. validate destination chain is this chain\n        assert(\n            vaa_payload.destination_chain_id == config.chain_id,\n            \"Invalid destination chain ID\"\n        );\n\n        // 4. validate emitter from VAA envelope (not sender from payload)\n        let is_registered_emitter = storage.registered_emitters\n            .at(vaa_envelope.emitter_chain_id)\n            .at(vaa_envelope.emitter_as_field())\n            .read();\n        assert(is_registered_emitter, \"Emitter not registered\");\n\n        // 5. emit the nullifier to prevent replays\n        // note: will fail if nullifier has already been emitted\n        context.push_nullifier(vaa_nullifier);\n\n        // 6. update state with received value\n        MessageBridge::at(context.this_address())\n            ._update_value(vaa_payload.value)\n            .enqueue(&mut context);\n    }\n\n    #[external(\"public\")]\n    #[internal]\n    fn _update_value(value: u128) {\n        storage.current_value.write(value);\n    }\n\n    // ============================================================================\n    // VIEW FUNCTIONS\n    // ============================================================================\n\n    #[external(\"utility\")]\n    unconstrained fn get_config() -> Config {\n        storage.config.read()\n    }\n\n    #[external(\"utility\")]\n    unconstrained fn get_owner() -> AztecAddress {\n        storage.owner.read()\n    }\n\n    #[external(\"utility\")]\n    unconstrained fn is_emitter_registered(chain_id: u16, emitter_address: [u8; 32]) -> bool {\n        // pack eth address into a field (take bytes 1-31 to preserve EVM address suffix)\n        let mut emitter_address_truncated = [0; 31];\n        for i in 0..31 {\n            emitter_address_truncated[i] = emitter_address[i + 1];\n        }\n        let emitter_address_field = Field::from_be_bytes(emitter_address_truncated);\n\n        storage.registered_emitters\n            .at(chain_id)\n            .at(emitter_address_field)\n            .read()\n    }\n\n    #[external(\"utility\")]\n    unconstrained fn get_current_value() -> u128 {\n        storage.current_value.read()\n    }\n}\n"
    },
    "52": {
      "path": "/home/jpag/Playground/aztec/crosschain/wormhole-demo/packages/aztec/src/message_bridge/src/utils/mod.nr",
      "source": "pub mod vaa;\n\n// VAA structure offsets (hardcoded for 1 signature)\npub global VAA_HEADER_SIZE: u32 = 6;        // version(1) + guardian_set(4) + num_sigs(1)\npub global VAA_SIGNATURE_SIZE: u32 = 66;    // guardian_index(1) + signature(64) + recovery(1)\npub global VAA_ENVELOPE_START: u32 = VAA_HEADER_SIZE + VAA_SIGNATURE_SIZE; // = 72\npub global VAA_ENVELOPE_SIZE: u32 = 51;     // timestamp(4) + nonce(4) + emitter_chain(2) + emitter_addr(32) + sequence(8) + consistency(1)\npub global VAA_PAYLOAD_START: u32 = VAA_ENVELOPE_START + VAA_ENVELOPE_SIZE; // = 123\n\npub global VAA_MAX_LENGTH: u32 = 2000;      // max VAA length in Wormhole spec\npub global VAA_BODY_MAX_LENGTH: u32 = 1860; // max body length in Wormhole VAA spec\n\n// Message payload structure (18 bytes): destinationChainId (2) + value (16)\npub global MESSAGE_PAYLOAD_LENGTH: u32 = 18;\npub global MESSAGE_NULLIFIER_LENGTH: u32 = VAA_ENVELOPE_SIZE + MESSAGE_PAYLOAD_LENGTH; // 51 + 18 = 69\npub global MESSAGE_NULLIFIER_PACKED_LENGTH: u32 = 3; // ceil(69 / 31) = 3\n\n/// Decoded VAA envelope (excludes header and signatures)\npub struct DecodedVAAEnvelope {\n    pub timestamp: u32,\n    pub nonce: u32,\n    pub emitter_chain_id: u16,\n    pub emitter_address: [u8; 32],\n    pub sequence: u64,\n    pub consistency_level: u8,\n}\n\nimpl DecodedVAAEnvelope {\n    // Converts the emitter address to a Field\n    // drops the first byte of the emitter address to fit into 254 bit field\n    pub fn emitter_as_field(self) -> Field {\n        let mut addr_bytes = [0; 31];\n        for i in 0..31 {\n            addr_bytes[i] = self.emitter_address[i + 1];\n        }\n        Field::from_be_bytes(addr_bytes)\n    }\n}\n\n/// Decoded message payload (18 bytes)\npub struct DecodedVAAPayload {\n    pub destination_chain_id: u16,\n    pub value: u128,\n}\n\n// probably should just use Field::to_le_bytes but meh\npub fn u16_to_u8(value: u16) -> [u8; 2] {\n    // Safety: constrained below, use unconstrained for bitwise ops\n    let decomposed = unsafe { _u16_to_u8(value) };\n    let asserted = decomposed[0] as u16 * 256 + decomposed[1] as u16;\n    assert(asserted == value, \"u16 to u8 conversion failed\");\n    decomposed\n}\n\nunconstrained fn _u16_to_u8(value: u16) -> [u8; 2] {\n    let high = (value >> 8) as u8;\n    let low = (value & 0xFF) as u8;\n    [high, low]\n}"
    },
    "53": {
      "path": "/home/jpag/Playground/aztec/crosschain/wormhole-demo/packages/aztec/src/message_bridge/src/utils/vaa.nr",
      "source": "use keccak256::keccak256;\nuse poseidon::poseidon2::Poseidon2;\nuse crate::utils::{\n    VAA_MAX_LENGTH,\n    VAA_ENVELOPE_START,\n    VAA_PAYLOAD_START,\n    MESSAGE_NULLIFIER_LENGTH,\n    MESSAGE_NULLIFIER_PACKED_LENGTH,\n    DecodedVAAEnvelope,\n    DecodedVAAPayload,\n    u16_to_u8,\n};\nuse nodash::pack_bytes;\n\npub struct DecodedVAA {\n    pub envelope: DecodedVAAEnvelope,\n    pub payload: DecodedVAAPayload,\n}\n\n/// Parse a raw VAA and extract envelope, payload, and compute nullifier\n///\n/// VAA structure (with 1 signature):\n///   Bytes 0-5:     Header (version, guardian set, num sigs) - skipped\n///   Bytes 6-71:    Signature - skipped\n///   Bytes 72-122:  Envelope (timestamp, nonce, emitter chain, emitter addr, sequence, consistency)\n///   Bytes 123+:    Payload\npub fn decode_vaa(vaa: [u8; VAA_MAX_LENGTH]) -> (\n    DecodedVAAEnvelope,\n    DecodedVAAPayload,\n    Field,\n) {\n    let envelope = decode_vaa_envelope(vaa);\n    let payload = decode_vaa_payload(vaa);\n    let nullifier = compute_vaa_nullifier(vaa);\n    (envelope, payload, nullifier)\n}\n\n/// Parse the VAA envelope (starts at byte 72 for 1 signature)\n///\n/// Envelope structure (51 bytes):\n///   Bytes 0-3:   timestamp (u32, big-endian)\n///   Bytes 4-7:   nonce (u32, big-endian)\n///   Bytes 8-9:   emitter_chain_id (u16, big-endian)\n///   Bytes 10-41: emitter_address (32 bytes)\n///   Bytes 42-49: sequence (u64, big-endian)\n///   Byte 50:     consistency_level (u8)\npub fn decode_vaa_envelope(vaa: [u8; VAA_MAX_LENGTH]) -> DecodedVAAEnvelope {\n    let offset = VAA_ENVELOPE_START;\n\n    // timestamp (4 bytes, big-endian)\n    let mut timestamp_bytes: [u8; 4] = [0; 4];\n    for i in 0..4 {\n        timestamp_bytes[i] = vaa[offset + i];\n    }\n    let timestamp = Field::from_be_bytes(timestamp_bytes) as u32;\n\n    // nonce (4 bytes, big-endian)\n    let mut nonce_bytes: [u8; 4] = [0; 4];\n    for i in 0..4 {\n        nonce_bytes[i] = vaa[offset + 4 + i];\n    }\n    let nonce = Field::from_be_bytes(nonce_bytes) as u32;\n\n    // emitter_chain_id (2 bytes, big-endian)\n    let mut chain_id_bytes: [u8; 2] = [0; 2];\n    for i in 0..2 {\n        chain_id_bytes[i] = vaa[offset + 8 + i];\n    }\n    let emitter_chain_id = Field::from_be_bytes(chain_id_bytes) as u16;\n\n    // emitter_address (32 bytes)\n    let mut emitter_address: [u8; 32] = [0; 32];\n    for i in 0..32 {\n        emitter_address[i] = vaa[offset + 10 + i];\n    }\n\n    // sequence (8 bytes, big-endian)\n    let mut sequence_bytes: [u8; 8] = [0; 8];\n    for i in 0..8 {\n        sequence_bytes[i] = vaa[offset + 42 + i];\n    }\n    let sequence = Field::from_be_bytes(sequence_bytes) as u64;\n\n    // consistency_level (1 byte)\n    let consistency_level = vaa[offset + 50];\n\n    DecodedVAAEnvelope {\n        timestamp,\n        nonce,\n        emitter_chain_id,\n        emitter_address,\n        sequence,\n        consistency_level,\n    }\n}\n\n/// Parse the VAA payload (starts at byte 123 for 1 signature)\n///\n/// Payload structure (18 bytes):\n///   Bytes 0-1:   destination_chain_id (u16, big-endian)\n///   Bytes 2-17:  value (u128, big-endian)\npub fn decode_vaa_payload(vaa: [u8; VAA_MAX_LENGTH]) -> DecodedVAAPayload {\n    let offset = VAA_PAYLOAD_START;\n\n    // destination_chain_id (2 bytes, big-endian)\n    let destination_chain_id = (\n        (vaa[offset] as Field) * 256\n        + (vaa[offset + 1] as Field)\n    ) as u16;\n\n    // value (16 bytes, big-endian) - parse as u128 via Field multiplication\n    let mut value_bytes: [u8; 16] = [0; 16];\n    for i in 0..16 {\n        value_bytes[i] = vaa[offset + 2 + i];\n    }\n    let value = Field::from_be_bytes(value_bytes) as u128;\n\n    DecodedVAAPayload {\n        destination_chain_id,\n        value,\n    }\n}\n\n/// Compute nullifier from VAA bytes (for replay protection)\nfn compute_vaa_nullifier(vaa: [u8; VAA_MAX_LENGTH]) -> Field {\n    // Pack the relevant bytes (envelope + payload) for hashing\n    let mut nullifier_bytes = [0; MESSAGE_NULLIFIER_LENGTH];\n    for i in 0..MESSAGE_NULLIFIER_LENGTH {\n        nullifier_bytes[i] = vaa[VAA_ENVELOPE_START + i];\n    }\n\n    let packed = pack_bytes(nullifier_bytes);\n    Poseidon2::hash(packed, MESSAGE_NULLIFIER_PACKED_LENGTH)\n}\n\n/// Encode a message payload for sending via Wormhole (Aztec -> EVM)\n///\n/// Payload structure (18 bytes):\n///   Bytes 0-1:   destination_chain_id (u16, big-endian)\n///   Bytes 2-17:  value (u128, big-endian)\n///\n/// Returns 8 chunks of 31 bytes for Aztec Field compatibility\npub fn encode_message_payload(\n    value: u128,\n    destination_chain_id: u16,\n) -> [[u8; 31]; 8] {\n    let mut wormhole_payload: [[u8; 31]; 8] = [[0; 31]; 8];\n\n    let destination_chain_bytes = u16_to_u8(destination_chain_id);\n    let value_bytes: [u8; 16] = Field::to_be_bytes(value as Field);\n\n    // Chunk 0: destination_chain_id (2 bytes) + value (16 bytes) = 18 bytes total\n    wormhole_payload[0][0] = destination_chain_bytes[0];\n    wormhole_payload[0][1] = destination_chain_bytes[1];\n    for i in 0..16 {\n        wormhole_payload[0][2 + i] = value_bytes[i];\n    }\n\n    wormhole_payload\n}\n\n// Keccak hash of VAA body (for signature verification)\npub fn compute_vaa_hash(body_bytes: [u8; 1860], body_length: u32) -> [u8; 32] {\n    let mut actual_body = [0; 1860];\n    for i in 0..body_length {\n        actual_body[i] = body_bytes[i];\n    }\n\n    // Double hash as per Wormhole spec\n    let hash: [u8; 32] = keccak256(actual_body, body_length);\n    let double_hash: [u8; 32] = keccak256(hash, 32);\n\n    double_hash\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0, \"cannot pop from an empty vector\");\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            let _ = vec.get(0);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_beyond_length() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            let _ = vec.get(3);\n        }\n\n        #[test]\n        fn get_works_within_bounds() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(2), 3);\n            assert_eq(vec.get(4), 5);\n        }\n\n        #[test]\n        fn get_unchecked_works() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(0), 1);\n            assert_eq(vec.get_unchecked(2), 3);\n        }\n\n        #[test]\n        fn get_unchecked_works_past_len() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(4), 0);\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_setting_beyond_length() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            vec.set(3, 4);\n        }\n\n        #[test]\n        fn set_unchecked_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(0, 10);\n            assert_eq(vec.get(0), 10);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn set_unchecked_operations_past_len() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(3, 40);\n            assert_eq(vec.get(3), 40);\n        }\n\n        #[test]\n        fn set_preserves_other_elements() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            vec.set(2, 30);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 30);\n            assert_eq(vec.get(3), 4);\n            assert_eq(vec.get(4), 5);\n        }\n    }\n\n    mod any {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn returns_false_if_predicate_not_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, false, false]);\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn returns_true_if_predicate_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, true, true]);\n            let result = vec.any(|value| value);\n\n            assert(result);\n        }\n\n        #[test]\n        fn returns_false_on_empty_boundedvec() {\n            let vec: BoundedVec<bool, 0> = BoundedVec::new();\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn any_with_complex_predicates() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            assert(vec.any(|x| x > 3));\n            assert(!vec.any(|x| x > 10));\n            assert(vec.any(|x| x % 2 == 0)); // has a even number\n            assert(vec.any(|x| x == 3)); // has a specific value\n        }\n\n        #[test]\n        fn any_with_partial_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            assert(vec.any(|x| x == 1));\n            assert(vec.any(|x| x == 2));\n            assert(!vec.any(|x| x == 3));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn map_with_conditional_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.map(|x| if x % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([1, 4, 3, 8]);\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn map_preserves_length() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|x| x * 2);\n\n            assert_eq(result.len(), vec.len());\n            assert_eq(result.max_len(), vec.max_len());\n        }\n\n        #[test]\n        fn map_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let result = vec.map(|x| x * 2);\n            assert_eq(result, vec);\n            assert_eq(result.len(), 0);\n            assert_eq(result.max_len(), 5);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn mapi_with_index_branching_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.mapi(|i, x| if i % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([2, 2, 6, 4]);\n            assert_eq(result, expected);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_each_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_each(|_| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_each_with_side_effects() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let mut seen = BoundedVec::<u32, 3>::new();\n            let seen_ref = &mut seen;\n            vec.for_each(|x| seen_ref.push(x));\n            assert_eq(seen, vec);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_eachi_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_eachi(|_, _| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_eachi_with_index_tracking() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([10, 20, 30]);\n            let mut indices = BoundedVec::<u32, 3>::new();\n            let indices_ref = &mut indices;\n            vec.for_eachi(|i, _| indices_ref.push(i));\n\n            let expected = BoundedVec::from_array([0, 1, 2]);\n            assert_eq(indices, expected);\n        }\n\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n\n        #[test]\n        fn from_array_preserves_order() {\n            let array = [5, 3, 1, 4, 2];\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array(array);\n            for i in 0..array.len() {\n                assert_eq(vec.get(i), array[i]);\n            }\n        }\n\n        #[test]\n        fn from_array_with_different_types() {\n            let bool_array = [true, false, true];\n            let bool_vec: BoundedVec<bool, 3> = BoundedVec::from_array(bool_array);\n            assert_eq(bool_vec.len(), 3);\n            assert_eq(bool_vec.get(0), true);\n            assert_eq(bool_vec.get(1), false);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n\n    mod push_pop {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn push_and_pop_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            assert_eq(vec.len(), 0);\n\n            vec.push(1);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 1);\n\n            vec.push(2);\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.get(1), 2);\n\n            let popped = vec.pop();\n            assert_eq(popped, 2);\n            assert_eq(vec.len(), 1);\n\n            let popped2 = vec.pop();\n            assert_eq(popped2, 1);\n            assert_eq(vec.len(), 0);\n        }\n\n        #[test(should_fail_with = \"push out of bounds\")]\n        fn push_to_full_vector() {\n            let mut vec: BoundedVec<u32, 2> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n            vec.push(3); // should panic\n        }\n\n        #[test(should_fail_with = \"cannot pop from an empty vector\")]\n        fn pop_from_empty_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let _ = vec.pop(); // should panic\n        }\n\n        #[test]\n        fn push_pop_cycle() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n\n            // push to full\n            vec.push(1);\n            vec.push(2);\n            vec.push(3);\n            assert_eq(vec.len(), 3);\n\n            // pop all\n            assert_eq(vec.pop(), 3);\n            assert_eq(vec.pop(), 2);\n            assert_eq(vec.pop(), 1);\n            assert_eq(vec.len(), 0);\n\n            // push again\n            vec.push(4);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 4);\n        }\n    }\n\n    mod extend {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn extend_from_array() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_slice() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_bounded_vec() {\n            let mut vec1: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut vec2: BoundedVec<u32, 3> = BoundedVec::new();\n\n            vec1.push(1);\n            vec2.push(2);\n            vec2.push(3);\n\n            vec1.extend_from_bounded_vec(vec2);\n\n            assert_eq(vec1.len(), 3);\n            assert_eq(vec1.get(0), 1);\n            assert_eq(vec1.get(1), 2);\n            assert_eq(vec1.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"extend_from_array out of bounds\")]\n        fn extend_array_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3, 4]); // should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_slice out of bounds\")]\n        fn extend_slice_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3, 4]); // S]should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_bounded_vec out of bounds\")]\n        fn extend_bounded_vec_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            let other: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            vec.extend_from_bounded_vec(other); // should panic\n        }\n\n        #[test]\n        fn extend_with_empty_collections() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let original_len = vec.len();\n\n            vec.extend_from_array([]);\n            assert_eq(vec.len(), original_len);\n\n            vec.extend_from_slice(&[]);\n            assert_eq(vec.len(), original_len);\n\n            let empty: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.extend_from_bounded_vec(empty);\n            assert_eq(vec.len(), original_len);\n        }\n    }\n\n    mod storage {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn storage_consistency() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            // test initial storage state\n            assert_eq(vec.storage(), [0, 0, 0, 0, 0]);\n\n            vec.push(1);\n            vec.push(2);\n\n            // test storage after modifications\n            assert_eq(vec.storage(), [1, 2, 0, 0, 0]);\n\n            // storage doesn't change length\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.max_len(), 5);\n        }\n\n        #[test]\n        fn storage_after_pop() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n\n            let _ = vec.pop();\n            // after pop, the last element should be zeroed\n            assert_eq(vec.storage(), [1, 2, 0]);\n            assert_eq(vec.len(), 2);\n        }\n\n        #[test]\n        fn vector_immutable() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let storage = vec.storage();\n\n            assert_eq(storage, [1, 2, 3]);\n\n            // Verify that the original vector is unchanged\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n    }\n}\n"
    },
    "62": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push(self, value: T)\n    where\n        T: Serialize,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get(self, index: u32) -> T\n    where\n        T: Deserialize,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n\n    global SLOT: Field = 1230;\n\n    #[test]\n    unconstrained fn empty_array() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            let _: Field = array.get(0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            assert_eq(array.len(), 1);\n            assert_eq(array.get(0), 5);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            let _ = array.get(1);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(5);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            assert_eq(array.len(), 3);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 8);\n            assert_eq(array.get(2), 9);\n\n            array.remove(1);\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 9);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            array.remove(1);\n            array.remove(1);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n            // we do not care about the order in which each tuple was passed to the closure.\n            let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n            array.for_each(|index, value| { called_with.push((index, value)); });\n\n            assert_eq(called_with.len(), 3);\n            assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n            assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n            assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| {\n                if index == 1 {\n                    array.remove(index);\n                }\n            });\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 4);\n            assert_eq(array.get(1), 6);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all_no_copy() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We test that the utilityCopyCapsule was never called, which is the expensive operation we want to avoid.\n            let mock = std::test::OracleMock::mock(\"utilityCopyCapsule\");\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(mock.times_called(), 0);\n        });\n    }\n}\n"
    },
    "63": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PrivateCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    /// Makes the call to this private function.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// This enables contracts to interact with each other while maintaining\n    /// privacy. This \"composability\" of private contract functions is a key\n    /// feature of the Aztec network.\n    ///\n    /// If a user's transaction includes multiple private function calls, then\n    /// by the design of Aztec, the following information will remain private[1]:\n    /// - The function selectors and contract addresses of all private function\n    ///   calls will remain private, so an observer of the public mempool will\n    ///   not be able to look at a tx and deduce which private functions have\n    ///   been executed.\n    /// - The arguments and return values of all private function calls will\n    ///   remain private.\n    /// - The person who initiated the tx will remain private.\n    /// - The notes and nullifiers and private logs that are emitted by all\n    ///   private function calls will (if designed well) not leak any user\n    ///   secrets, nor leak which functions have been executed.\n    ///\n    /// [1] Caveats: Some of these privacy guarantees depend on how app\n    /// developers design their smart contracts. Some actions _can_ leak\n    /// information, such as:\n    /// - Calling an internal public function.\n    /// - Calling a public function and not setting msg_sender to Option::none\n    ///   (see https://github.com/AztecProtocol/aztec-packages/pull/16433)\n    /// - Calling any public function will always leak details about the nature\n    ///   of the transaction, so devs should be careful in their contract\n    ///   designs. If it can be done in a private function, then that will give\n    ///   the best privacy.\n    /// - Not padding the side-effects of a tx to some standardised, uniform\n    ///   size. The kernel circuits can take hints to pad side-effects, so a\n    ///   wallet should be able to request for a particular amount of padding.\n    ///   Wallets should ideally agree on some standard.\n    ///   - Padding should include:\n    ///     - Padding the lengths of note & nullifier arrays\n    ///     - Padding private logs with random fields, up to some standardised\n    ///       size.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Advanced\n    /// * The call is added to the private call stack and executed by kernel\n    ///   circuits after this function completes\n    /// * The called function can modify its own contract's private state\n    /// * Side effects from the called function are included in this transaction\n    /// * The call inherits the current transaction's context and gas limits\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub fn call(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n\n        // If T is () (i.e. if the function does not return anything) then `get_preimage` will constrain that the\n        // returns hash is empty as per the protocol rules.\n        returns_hash.get_preimage()\n    }\n\n    /// Makes a _read-only_ call to this private function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// See `call` for more general info on private function calls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub fn view(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        // If T is () (i.e. if the function does not return anything) then `get_preimage` will constrain that the\n        // returns hash is empty as per the protocol rules.\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PrivateCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PrivateStaticCallInterface<M, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    /// Makes a read-only call to this private function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn view(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PrivateStaticCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PublicCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    /// Makes the call to this public function.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[external(\"public\")] function as `context`, through the\n    ///               #[external(\"public\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn call(self, context: &mut PublicContext) -> T {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        // If T is () (i.e. if the function does not return anything) then `as_array` will constrain that `returns` has\n        // a length of 0 (since that is ()'s deserialization length).\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Makes a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[external(\"public\")] function as `context`, through the\n    ///               #[external(\"public\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn view(self, context: &mut PublicContext) -> T {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        // If T is () (i.e. if the function does not return anything) then `as_array` will constrain that `returns` has\n        // a length of 0 (since that is ()'s deserialization length).\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Enqueues a call to this public function, to be executed later.\n    ///\n    /// Unlike private functions which execute immediately on the user's device,\n    /// public function calls are \"enqueued\" and executed some time later by a\n    /// block proposer.\n    ///\n    /// This means a public function cannot return any values back to a private\n    /// function, because by the time the public function is being executed,\n    /// the private function which called it has already completed execution.\n    /// (In fact, the private function has been executed and proven, along with\n    /// all other private function calls of the user's tx. A single proof of the\n    /// tx has been submitted to the Aztec network, and some time later a\n    /// proposer has picked the tx up from the mempool and begun executing all\n    /// of the enqueued public functions).\n    ///\n    /// # Privacy warning\n    /// Enqueueing a public function call is an inherently leaky action.\n    /// Many interesting applications will require some interaction with public\n    /// state, but smart contract developers should try to use public function\n    /// calls sparingly, and carefully.\n    /// _Internal_ public function calls are especially leaky, because they\n    /// completely leak which private contract made the call.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        self.enqueue_impl(context, false, false)\n    }\n\n    /// Enqueues a call to this public function, to be executed later.\n    ///\n    /// As per `enqueue`, but hides this calling contract's address from the\n    /// target public function.\n    /// This means the origin of the call (msg_sender) will not be publicly\n    /// visible to any blockchain observers, nor to the target public function.\n    /// When the target public function reads `context.msg_sender()` it will\n    /// receive an `Option<AztecAddress>::none`.\n    ///\n    /// NOTES:\n    /// - Not all public functions will accept a msg_sender of \"none\". Many\n    ///   public functions will require that msg_sender is \"some\" and will\n    ///   revert otherwise. Therefore, if using `enqueue_incognito`, you must\n    ///   understand whether the function you're calling will accept a\n    ///   msg_sender of \"none\".\n    ///   Lots of public bookkeeping patterns rely on knowing which address made\n    ///   the call, so as to ascribe state against the caller's address.\n    ///   (There are patterns whereby bookkeeping could instead be done in\n    ///   private-land).\n    /// - If you are enqueueing a call to an _internal_ public function (i.e.\n    ///   a public function that will only accept calls from other functions\n    ///   of its own contract), then by definition a call to it cannot possibly\n    ///   be \"incognito\": the msg_sender must be its own address, and indeed the\n    ///   called public function will assert this. Tl;dr this is not usable for\n    ///   enqueued internal public calls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    /// Advanced:\n    /// - The kernel circuits will permit _any_ private function to set the\n    ///   msg_sender field of any enqueued public function call to\n    ///   NULL_MSG_SENDER_CONTRACT_ADDRESS.\n    /// - When the called public function calls `PublicContext::msg_sender()`,\n    ///   aztec-nr will translate NULL_MSG_SENDER_CONTRACT_ADDRESS into\n    ///   `Option<AztecAddress>::none` for familiarity to devs.\n    ///\n    pub fn enqueue_incognito(self, context: &mut PrivateContext) {\n        self.enqueue_impl(context, false, true)\n    }\n\n    /// Enqueues a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        self.enqueue_impl(context, true, false)\n    }\n\n    /// Enqueues a read-only call to this public function.\n    ///\n    /// As per `enqueue_view`, but hides this calling contract's address from\n    /// the target public function.\n    ///\n    /// See `enqueue_incognito` for more details relating to hiding msg_sender.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn enqueue_view_incognito(self, context: &mut PrivateContext) {\n        self.enqueue_impl(context, true, true)\n    }\n\n    fn enqueue_impl(\n        self,\n        context: &mut PrivateContext,\n        is_static_call: bool,\n        hide_msg_sender: bool,\n    ) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            is_static_call,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a call to this public function, and designates it to be the\n    /// teardown function for this tx. Only one teardown function call can be\n    /// made by a tx.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase ensures the fee payer\n    /// has sufficient balance to pay the proposer their fees.\n    /// The teardown phase is primarily intended to: calculate exactly\n    /// how much the user owes, based on gas consumption, and refund the user\n    /// any change.\n    ///\n    /// Note: in some cases, the cost of refunding the user (i.e. DA costs of\n    /// tx side-effects) might exceed the refund amount. For app logic with\n    /// fairly stable and predictable gas consumption, a material refund amount\n    /// is unlikely. For app logic with unpredictable gas consumption, a\n    /// refund might be important to the user (e.g. if a hefty function reverts\n    /// very early). Wallet/FPC/Paymaster developers should be mindful of this.\n    ///\n    /// See `enqueue` for more information about enqueuing public function calls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        self.set_as_teardown_impl(context, false);\n    }\n\n    /// Enqueues a call to this public function, and designates it to be the teardown\n    /// function for this tx. Only one teardown function call can be made by a\n    /// tx.\n    ///\n    /// As per `set_as_teardown`, but hides this calling contract's address from\n    /// the target public function.\n    ///\n    /// See `enqueue_incognito` for more details relating to hiding msg_sender.\n    ///\n    pub fn set_as_teardown_incognito(self, context: &mut PrivateContext) {\n        self.set_as_teardown_impl(context, true);\n    }\n\n    fn set_as_teardown_impl(self, context: &mut PrivateContext, hide_msg_sender: bool) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PublicCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let M: u32, T> PublicStaticCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    /// Makes the read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[external(\"public\")] function as `context`, through the\n    ///               #[external(\"public\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn view(self, context: &mut PublicContext) -> T {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Enqueues a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n            false,\n        )\n    }\n\n    pub fn enqueue_view_incognito(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n            true,\n        )\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PublicStaticCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// UtilityCallInterface\n\npub struct UtilityCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n}\n\nimpl<let M: u32, T> CallInterface<M> for UtilityCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        false\n    }\n}\n\nimpl<let M: u32, T> UtilityCallInterface<M, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n\n    pub fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    pub fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    pub fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    pub fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n}\n"
    },
    "70": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        logs::notify_created_contract_class_log,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        block_header::BlockHeader,\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log_hash::LogHash,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::{PrivateLog, PrivateLogData},\n        public_call_request::PublicCallRequest,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, MAX_CONTRACT_CLASS_LOGS_PER_CALL,\n        MAX_ENQUEUED_CALLS_PER_CALL, MAX_INCLUDE_BY_TIMESTAMP_DURATION,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        NULL_MSG_SENDER_CONTRACT_ADDRESS, PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    hash::poseidon2_hash,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    side_effect::Counted,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::{ClaimedLengthArray, trimmed_array_length_hint},\n};\n\n/// # PrivateContext\n///\n/// The **main interface** between an #[external(\"private\")] function and the Aztec blockchain.\n///\n/// An instance of the PrivateContext is initialized automatically at the outset\n/// of every private function, within the #[external(\"private\")] macro, so you'll never\n/// need to consciously instantiate this yourself.\n///\n/// The instance is always named `context`, and it is always be available within\n/// the body of every #[external(\"private\")] function in your smart contract.\n///\n/// > For those used to \"vanilla\" Noir, it might be jarring to have access to\n/// > `context` without seeing a declaration `let context = PrivateContext::new(...)`\n/// > within the body of your function. This is just a consequence of using\n/// > macros to tidy-up verbose boilerplate. You can use `nargo expand` to\n/// > expand all macros, if you dare.\n///\n/// Typical usage for a smart contract developer will be to call getter\n/// methods of the PrivateContext.\n///\n/// _Pushing_ data and requests to the context is mostly handled within\n/// aztec-nr's own functions, so typically a smart contract developer won't\n/// need to call any setter methods directly.\n///\n/// > Advanced users might occasionally wish to push data to the context\n/// > directly for lower-level control. If you find yourself doing this, please\n/// > open an issue on GitHub to describe your use case: it might be that\n/// > new functionality should be added to aztec-nr.\n///\n/// ## Responsibilities\n/// - Exposes contextual data to a private function:\n///   - Data relating to how this private function was called.\n///     - msg_sender\n///     - this_address - (the contract address of the private function being\n///                      executed)\n///     - See `CallContext` for more data.\n///   - Data relating to the transaction in which this private function is\n///     being executed.\n///     - chain_id\n///     - version\n///     - gas_settings\n/// - Provides state access:\n///   - Access to the \"Anchor block\" header.\n///     Recall, a private function cannot read from the \"current\" block header,\n///     but must read from some historical block header, because as soon as\n///     private function execution begins (asynchronously, on a user's device),\n///     the public state of the chain (the \"current state\") will have progressed\n///     forward. We call this reference the \"Anchor block\".\n///     See `BlockHeader`.\n///   - Enables consumption of L1->L2 messages.\n/// - Enables calls to functions of other smart contracts:\n///   - Private function calls\n///   - Enqueueing of public function call requests\n///     (Since public functions are executed at a later time, by a block\n///     proposer, we say they are \"enqueued\").\n/// - Writes data to the blockchain:\n///   - New notes\n///   - New nullifiers\n///   - Private logs (for sending encrypted note contents or encrypted events)\n///   - New L2->L1 messages.\n/// - Provides args to the private function (handled by the #[external(\"private\")] macro).\n/// - Returns the return values of this private function (handled by the\n///   #[external(\"private\")] macro).\n/// - Makes Key Validation Requests.\n///   - Private functions are not allowed to see master secret keys, because we\n///     do not trust them. They are instead given \"app-siloed\" secret keys with\n///     a claim that they relate to a master public key. They can then request\n///     validation of this claim, by making a \"key validation request\" to the\n///     protocol's kernel circuits (which _are_ allowed to see certain master\n///     secret keys).\n///\n/// ## Advanced Responsibilities\n///\n/// - Ultimately, the PrivateContext is responsible for constructing the\n///   PrivateCircuitPublicInputs of the private function being executed.\n///   All private functions on Aztec must have public inputs which adhere\n///   to the rigid layout of the PrivateCircuitPublicInputs, in order to be\n///   compatible with the protocol's kernel circuits.\n///   A well-known misnomer:\n///   - \"public inputs\" contain both inputs and outputs of this function.\n///     - By \"outputs\" we mean a lot more side-effects than just the\n///       \"return values\" of the function.\n///   - Most of the so-called \"public inputs\" are kept _private_, and never leak\n///     to the outside world, because they are 'swallowed' by the protocol's\n///     kernel circuits before the tx is sent to the network. Only the\n///     following are exposed to the outside world:\n///     - New note_hashes\n///     - New nullifiers\n///     - New private logs\n///     - New L2->L1 messages\n///     - New enqueued public function call requests\n///     All the above-listed arrays of side-effects can be padded by the\n///     user's wallet (through instructions to the kernel circuits, via the\n///     PXE) to obscure their true lengths.\n///\n/// ## Syntax Justification\n///\n/// Both user-defined functions _and_ most functions in aztec-nr need access to\n/// the PrivateContext instance to read/write data. This is why you'll see the\n/// arguably-ugly pervasiveness of the \"context\" throughout your smart contract\n/// and the aztec-nr library.\n/// For example, `&mut context` is prevalent. In some languages, you can access\n/// and mutate a global variable (such as a PrivateContext instance) from a\n/// function without polluting the function's parameters. With Noir, a function\n/// must explicitly pass control of a mutable variable to another function, by\n/// reference. Since many functions in aztec-nr need to be able to push new data\n/// to the PrivateContext, they need to be handed a mutable reference _to_ the\n/// context as a parameter.\n/// For example, `Context` is prevalent as a generic parameter, to give better\n/// type safety at compile time. Many `aztec-nr` functions don't make sense if\n/// they're called in a particular runtime (private, public or utility), and so\n/// are intentionally only implemented over certain\n/// [Private|Public|Utility]Context structs. This gives smart contract\n/// developers a much faster feedback loop if they're making a mistake, as an\n/// error will be thrown by the LSP or when they compile their contract.\n///\n#[derive(Eq)]\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub include_by_timestamp: u64,\n\n    pub note_hash_read_requests: BoundedVec<Counted<Field>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<Counted<Field>, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<Counted<NoteHash>, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Counted<Nullifier>, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<Counted<L2ToL1Message>, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub anchor_block_header: BlockHeader,\n\n    pub private_logs: BoundedVec<Counted<PrivateLogData>, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<Counted<LogHash>, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        let max_allowed_include_by_timestamp = inputs.anchor_block_header.global_variables.timestamp\n            + MAX_INCLUDE_BY_TIMESTAMP_DURATION;\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            include_by_timestamp: max_allowed_include_by_timestamp,\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            anchor_block_header: inputs.anchor_block_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: Since Aztec doesn't have a concept of an EoA (\n    /// Externally-owned Account), the msg_sender is \"null\" for the first\n    /// function call of every transaction.\n    /// The first function call of a tx is likely to be a call to the user's\n    /// account contract, so this quirk will most often be handled by account\n    /// contract developers.\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called\n    ///   this function (be it an app contract or a user's account contract).\n    ///   Returns `Option<AztecAddress>::none` for the first function call of\n    ///   the tx. No other _private_ function calls in the tx will have a `none`\n    ///   msg_sender, but _public_ function calls might (see the PublicContext).\n    ///\n    pub fn msg_sender(self) -> Option<AztecAddress> {\n        let maybe_msg_sender = self.inputs.call_context.msg_sender;\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// \"Unsafe\" versus calling `context.msg_sender()`, because it doesn't\n    /// translate `NULL_MSG_SENDER_CONTRACT_ADDRESS` as\n    /// `Option<AztecAddress>::none`.\n    /// Used by some internal aztecnr functions.\n    pub fn msg_sender_unsafe(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    /// Returns the contract address of the current function being executed.\n    ///\n    /// This is equivalent to `address(this)` in Solidity (hence the name).\n    /// Use this to identify the current contract's address, commonly needed for\n    /// access control or when interacting with other contracts.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The contract address of the current function being\n    ///                    executed.\n    ///\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    /// Returns the chain ID of the current network.\n    ///\n    /// This is similar to `block.chainid` in Solidity. Returns the unique\n    /// identifier for the blockchain network this transaction is executing on.\n    ///\n    /// Helps prevent cross-chain replay attacks. Useful if implementing\n    /// multi-chain contract logic.\n    ///\n    /// # Returns\n    /// * `Field` - The chain ID as a field element\n    ///\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    /// Returns the Aztec protocol version that this transaction is executing\n    /// under. Different versions may have different rules, opcodes, or\n    /// cryptographic primitives.\n    ///\n    /// This is similar to how Ethereum has different EVM versions.\n    ///\n    /// Useful for forward/backward compatibility checks\n    ///\n    /// Not to be confused with contract versions; this is the protocol version.\n    ///\n    /// # Returns\n    /// * `Field` - The protocol version as a field element\n    ///\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    /// Returns the gas settings for the current transaction.\n    ///\n    /// This provides information about gas limits and pricing for the\n    /// transaction, similar to `tx.gasprice` and gas limits in Ethereum.\n    /// However, Aztec has a more sophisticated gas model with separate\n    /// accounting for L2 computation and data availability (DA) costs.\n    ///\n    /// # Returns\n    /// * `GasSettings` - Struct containing gas limits and fee information\n    ///\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    /// Returns the function selector of the currently executing function.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to access this.\n    ///\n    /// This is similar to `msg.sig` in Solidity, which returns the first 4\n    /// bytes of the function signature. In Aztec, the selector uniquely\n    /// identifies which function within the contract is being called.\n    ///\n    /// # Returns\n    /// * `FunctionSelector` - The 4-byte function identifier\n    ///\n    /// # Advanced\n    /// Only #[external(\"private\")] functions have a function selector as a protocol-\n    /// enshrined concept. The function selectors of private functions are\n    /// baked into the preimage of the contract address, and are used by the\n    /// protocol's kernel circuits to identify each private function and ensure\n    /// the correct one is being executed.\n    ///\n    /// Used internally for function dispatch and call verification.\n    ///\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    ///\n    /// Very low-level function: You shouldn't need to call this. The #[external(\"private\")]\n    /// macro calls this, and it makes the arguments neatly available to the\n    /// body of your private function.\n    ///\n    /// # Returns\n    /// * `Field` - Hash of the function arguments\n    ///\n    /// # Advanced\n    /// * Arguments are hashed to reduce proof size and verification time\n    /// * Enables efficient argument passing in recursive function calls\n    /// * The hash can be used to retrieve the original arguments from the PXE.\n    ///\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    /// Pushes a new note_hash to the Aztec blockchain's global Note Hash Tree\n    /// (a state tree).\n    ///\n    /// A note_hash is a commitment to a piece of private state.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new note hashes.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The new note_hash.\n    ///\n    /// # Advanced\n    /// From here, the protocol's kernel circuits will take over and insert the\n    /// note_hash into the protocol's \"note hash tree\" (in the Base Rollup\n    /// circuit).\n    /// Before insertion, the protocol will:\n    /// - \"Silo\" the `note_hash` with the contract address of this function,\n    ///   to yield a `siloed_note_hash`. This prevents state collisions\n    ///   between different smart contracts.\n    /// - Ensure uniqueness of the `siloed_note_hash`, to prevent Faerie-Gold\n    ///   attacks, by hashing the `siloed_note_hash` with a unique value, to\n    ///   yield a `unique_siloed_note_hash` (see the protocol spec for more).\n    ///\n    /// In addition to calling this function, aztec-nr provides the contents\n    /// of the newly-created note to the PXE, via the `notify_created_note`\n    /// oracle.\n    ///\n    /// > Advanced users might occasionally wish to push data to the context\n    /// > directly for lower-level control. If you find yourself doing this,\n    /// > please open an issue on GitHub to describe your use case: it might be\n    /// > that new functionality should be added to aztec-nr.\n    ///\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(Counted::new(note_hash, self.next_counter()));\n    }\n\n    /// Pushes a new nullifier to the Aztec blockchain's global Nullifier Tree\n    /// (a state tree).\n    ///\n    /// See also: `push_nullifier_for_note_hash`.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifiers.\n    ///\n    /// A nullifier can only be emitted once. Duplicate nullifier insertions are\n    /// rejected by the protocol.\n    ///\n    /// Generally, a nullifier is emitted to prevent an action from happening\n    /// more than once, in such a way that the action cannot be linked (by an\n    /// observer of the blockchain) to any earlier transactions.\n    ///\n    /// I.e. a nullifier is a random-looking, but deterministic record of a\n    /// private, one-time action, which does not leak what action has been\n    /// taken, and which preserves the property of \"tx unlinkability\".\n    ///\n    /// Usually, a nullifier will be emitted to \"spend\" a note (a piece of\n    /// private state), without revealing which specific note is being spent.\n    ///\n    /// (Important: in such cases, use the below `push_nullifier_for_note_hash`).\n    ///\n    /// Sometimes, a nullifier might be emitted completely unrelated to any\n    /// notes. Examples include initialization of a new contract; initialization\n    /// of a PrivateMutable, or signalling in Semaphore-like applications.\n    /// This `push_nullifier` function serves such use cases.\n    ///\n    /// # Arguments\n    /// * `nullifier`\n    ///\n    /// # Advanced\n    /// From here, the protocol's kernel circuits will take over and insert the\n    /// nullifier into the protocol's \"nullifier tree\" (in the Base Rollup\n    /// circuit).\n    /// Before insertion, the protocol will:\n    /// - \"Silo\" the `nullifier` with the contract address of this function,\n    ///   to yield a `siloed_nullifier`. This prevents state collisions\n    ///   between different smart contracts.\n    /// - Ensure the `siloed_nullifier` is unique (the nullifier tree is an\n    ///   indexed merkle tree which supports efficient non-membership proofs).\n    ///\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: 0 }.count(self.next_counter()));\n    }\n\n    /// Pushes a nullifier that corresponds to a specific note hash.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifiers.\n    ///\n    /// This is a specialized version of `push_nullifier` that links a nullifier\n    /// to the specific note hash it's nullifying. This is the most common\n    /// usage pattern for nullifiers.\n    /// See `push_nullifier` for more explanation on nullifiers.\n    ///\n    /// # Arguments\n    /// * `nullifier`\n    /// * `nullified_note_hash` - The note hash of the note being nullified\n    ///\n    /// # Advanced\n    /// Important: usage of this function doesn't mean that the world will _see_\n    /// that this nullifier relates to the given nullified_note_hash (as that\n    /// would violate \"tx unlinkability\"); it simply informs the user's PXE\n    /// about the relationship (via `notify_nullified_note`). The PXE can then\n    /// use this information to feed hints to the kernel circuits for\n    /// \"squashing\" purposes: If a note is nullified during the same tx which\n    /// created it, we can \"squash\" (delete) the note and nullifier (and any\n    /// private logs associated with the note), to save on data emission costs.\n    ///\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash }.count(\n            nullifier_counter,\n        ));\n    }\n\n    /// Returns the anchor block header - the historical block header that this\n    /// private function is reading from.\n    ///\n    /// A private function CANNOT read from the \"current\" block header,\n    /// but must read from some older block header, because as soon as\n    /// private function execution begins (asynchronously, on a user's device),\n    /// the public state of the chain (the \"current state\") will have progressed\n    /// forward.\n    ///\n    /// # Returns\n    /// * `BlockHeader` - The anchor block header.\n    ///\n    /// # Advanced\n    /// * All private functions of a tx read from the same anchor block header.\n    /// * The protocol asserts that the `include_by_timestamp` of every tx\n    ///   is at most 24 hours beyond the timestamp of the tx's chosen anchor\n    ///   block header. This enables the network's nodes to safely prune old txs\n    ///   from the mempool. Therefore, the chosen block header _must_ be one\n    ///   from within the last 24 hours.\n    ///\n    pub fn get_anchor_block_header(self) -> BlockHeader {\n        self.anchor_block_header\n    }\n\n    /// Returns the header of any historical block at or before the anchor\n    /// block.\n    ///\n    /// This enables private contracts to access information from even older\n    /// blocks than the anchor block header.\n    ///\n    /// Useful for time-based contract logic that needs to compare against\n    /// multiple historical points.\n    ///\n    /// # Arguments\n    /// * `block_number` - The block number to retrieve (must be <= anchor\n    ///                    block number)\n    ///\n    /// # Returns\n    /// * `BlockHeader` - The header of the requested historical block\n    ///\n    /// # Advanced\n    /// This function uses an oracle to fetch block header data from the user's\n    /// PXE. Depending on how much blockchain data the user's PXE has been set\n    /// up to store, this might require a query from the PXE to another Aztec\n    /// node to get the data.\n    /// > This is generally true of all oracle getters (see `../oracle`).\n    ///\n    /// Each block header gets hashed and stored as a leaf in the protocol's\n    /// Archive Tree. In fact, the i-th block header gets stored at the i-th\n    /// leaf index of the Archive Tree. Behind the scenes, this\n    /// `get_block_header_at` function will add Archive Tree merkle-membership\n    /// constraints (~3k) to your smart contract function's circuit, to prove\n    /// existence of the block header in the Archive Tree.\n    ///\n    /// Note: we don't do any caching, so avoid making duplicate calls for the\n    /// same block header, because each call will add duplicate constraints.\n    ///\n    /// Calling this function is more expensive (constraint-wise) than getting\n    /// the anchor block header (via `get_block_header`). This is because the\n    /// anchor block's merkle membership proof is handled by Aztec's protocol\n    /// circuits, and is only performed once for the entire tx because all\n    /// private functions of a tx share a common anchor block header. Therefore,\n    /// the cost (constraint-wise) of calling `get_block_header` is effectively\n    /// free.\n    ///\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    /// Sets the hash of the return values for this private function.\n    ///\n    /// Very low-level function: this is called by the #[external(\"private\")] macro.\n    ///\n    /// # Arguments\n    /// * `serialized_return_values` - The serialized return values as a field array\n    ///\n    pub fn set_return_hash<let N: u32>(&mut self, serialized_return_values: [Field; N]) {\n        let return_hash = hash_args_array(serialized_return_values);\n        self.return_hash = return_hash;\n        execution_cache::store(serialized_return_values, return_hash);\n    }\n\n    /// Builds the PrivateCircuitPublicInputs for this private function, to\n    /// ensure compatibility with the protocol's kernel circuits.\n    ///\n    /// Very low-level function: This function is automatically called by the\n    /// #[external(\"private\")] macro.\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            include_by_timestamp: self.include_by_timestamp,\n            note_hash_read_requests: ClaimedLengthArray::from_bounded_vec(\n                self.note_hash_read_requests,\n            ),\n            nullifier_read_requests: ClaimedLengthArray::from_bounded_vec(\n                self.nullifier_read_requests,\n            ),\n            key_validation_requests_and_generators: ClaimedLengthArray::from_bounded_vec(\n                self.key_validation_requests_and_generators,\n            ),\n            note_hashes: ClaimedLengthArray::from_bounded_vec(self.note_hashes),\n            nullifiers: ClaimedLengthArray::from_bounded_vec(self.nullifiers),\n            private_call_requests: ClaimedLengthArray::from_bounded_vec(self.private_call_requests),\n            public_call_requests: ClaimedLengthArray::from_bounded_vec(self.public_call_requests),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: ClaimedLengthArray::from_bounded_vec(self.l2_to_l1_msgs),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: ClaimedLengthArray::from_bounded_vec(self.private_logs),\n            contract_class_logs_hashes: ClaimedLengthArray::from_bounded_vec(\n                self.contract_class_logs_hashes,\n            ),\n            anchor_block_header: self.anchor_block_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    /// Designates this contract as the fee payer for the transaction.\n    ///\n    /// Unlike Ethereum, where the transaction sender always pays fees, Aztec\n    /// allows any contract to voluntarily pay transaction fees. This enables\n    /// patterns like sponsored transactions or fee abstraction where users\n    /// don't need to hold fee-juice themselves. (Fee juice is a fee-paying\n    /// asset for Aztec).\n    ///\n    /// Only one contract per transaction can declare itself as the fee payer,\n    /// and it must have sufficient fee-juice balance (>= the gas limits\n    /// specified in the TxContext) by the time we reach the public setup phase\n    /// of the tx.\n    ///\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    /// Declares the end of the \"setup phase\" of this tx.\n    ///\n    /// Only one function per tx can declare the end of the setup phase.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase enables such a payment to\n    /// be made, because the setup phase _cannot revert_: a reverting function\n    /// within the setup phase would result in an invalid block which cannot\n    /// be proven. Any side-effects generated during that phase are guaranteed\n    /// to be inserted into Aztec's state trees (except for squashed notes &\n    /// nullifiers, of course).\n    ///\n    /// Even though the end of the setup phase is declared within a private\n    /// function, you might have noticed that _public_ functions can also\n    /// execute within the setup phase. This is because any public function\n    /// calls which were enqueued _within the setup phase_ by a private\n    /// function are considered part of the setup phase.\n    ///\n    /// # Advanced\n    /// * Sets the minimum revertible side effect counter of this tx to be the\n    /// PrivateContext's _current_ side effect counter.\n    ///\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    /// Sets a deadline (an \"include-by timestamp\") for when this transaction\n    /// must be included in a block.\n    ///\n    /// Other functions in this tx might call this setter with differing\n    /// values for the include-by timestamp. To ensure that all functions'\n    /// deadlines are met, the _minimum_ of all these include-by timestamps will\n    /// be exposed when this tx is submitted to the network.\n    ///\n    /// If the transaction is not included in a block by its include-by\n    /// timestamp, it becomes invalid and it will never be included.\n    ///\n    /// This expiry timestamp is publicly visible. See the \"Advanced\" section\n    /// for privacy concerns.\n    ///\n    /// # Arguments\n    /// * `include_by_timestamp` - Unix timestamp (seconds) deadline for inclusion.\n    ///                            The include-by timestamp of this tx will be\n    ///                            _at most_ the timestamp specified.\n    ///\n    /// # Advanced\n    /// * If multiple functions set differing `include_by_timestamp`s, the\n    ///   kernel circuits will set it to be the _minimum_ of the two. This\n    ///   ensures the tx expiry requirements of all functions in the tx are met.\n    /// * Rollup circuits will reject expired txs.\n    /// * The protocol enforces that all transactions must be included within\n    ///   24 hours of their chosen anchor block's timestamp, to enable safe\n    ///   mempool pruning.\n    /// * The DelayedPublicMutable design makes heavy use of this functionality,\n    ///   to enable private functions to read public state.\n    /// * A sophisticated Wallet should cleverly set an include-by timestamp\n    ///   to improve the privacy of the user and the network as a whole.\n    ///   For example, if a contract interaction sets include-by to some\n    ///   publicly-known value (e.g. the time when a contract upgrades), then\n    ///   the wallet might wish to set an even lower one to avoid revealing that\n    ///   this tx is interacting with said contract.\n    ///   Ideally, all wallets should standardise on an approach in order to\n    ///   provide users with a large anonymity set -- although the exact apprach\n    ///   will need to be discussed. Wallets that deviate from a standard might\n    ///   accidentally reveal which wallet each transaction originates from.\n    ///\n    // docs:start:include-by-timestamp\n    pub fn set_include_by_timestamp(&mut self, include_by_timestamp: u64) {\n        // docs:end:include-by-timestamp\n        self.include_by_timestamp = std::cmp::min(self.include_by_timestamp, include_by_timestamp);\n    }\n\n    /// Makes a request to the protocol's kernel circuit to ensure a note_hash\n    /// actually exists.\n    ///\n    /// \"Read requests\" are used to prove that a note hash exists without\n    /// revealing which specific note was read.\n    ///\n    /// This can be used to prove existence of both settled notes (created in\n    /// prior transactions) and transient notes (created in the current\n    /// transaction).\n    /// If you need to prove existence of a settled note _at a specific block\n    /// number_, use `note_inclusion::prove_note_inclusion`.\n    ///\n    /// Low-level function. Ordinarily, smart contract developers will not need\n    /// to call this directly. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new note_hash read\n    /// requests.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The note hash to read and verify\n    ///\n    /// # Advanced\n    /// In \"traditional\" circuits for non-Aztec privacy applications, the merkle\n    /// membership proofs to check existence of a note are performed _within_\n    /// the application circuit.\n    ///\n    /// All Aztec private functions have access to the following constraint\n    /// optimisation:\n    /// In cases where the note being read was created earlier in the same tx,\n    /// the note wouldn't yet exist in the Note Hash Tree, so a hard-coded\n    /// merkle membership check which then gets ignored would be a waste of\n    /// constraints.\n    /// Instead, we can send read requests for all notes to the protocol's\n    /// kernel circuits, where we can conditionally assess which notes actually\n    /// need merkle membership proofs, and select an appropriately-sized\n    /// kernel circuit.\n    ///\n    /// For \"settled notes\" (which already existed in the Note Hash Tree of the\n    /// anchor block (i.e. before the tx began)), the kernel does a merkle\n    /// membership check.\n    ///\n    /// For \"pending notes\" (which were created earlier in _this_ tx), the\n    /// kernel will check that the note existed _before_ this read request was\n    /// made, by checking the side-effect counters of the note_hash and this\n    /// read request.\n    ///\n    /// This approach improves latency between writes and reads:\n    /// a function can read a note which was created earlier in the tx (rather\n    /// than performing the read in a later tx, after waiting for the earlier tx\n    /// to be included, to ensure the note is included in the tree).\n    ///\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = Counted::new(note_hash, self.next_counter());\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    /// Requests to read a specific nullifier from the nullifier tree.\n    ///\n    /// Nullifier read requests are used to prove that a nullifier exists without\n    /// revealing which specific nullifier preimage was read.\n    ///\n    /// This can be used to prove existence of both settled nullifiers (created in\n    /// prior transactions) and transient nullifiers (created in the current\n    /// transaction).\n    /// If you need to prove existence of a settled nullifier _at a specific block\n    /// number_, use `nullifier_inclusion::prove_nullifier_inclusion`.\n    ///\n    /// Low-level function. Ordinarily, smart contract developers will not need\n    /// to call this directly. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifier read\n    /// requests.\n    ///\n    /// # Arguments\n    /// * `nullifier` - The nullifier to read and verify\n    ///\n    /// # Advanced\n    /// This approach improves latency between writes and reads:\n    /// a function can read a nullifier which was created earlier in the tx\n    /// (rather than performing the read in a later tx, after waiting for the\n    /// earlier tx to be included, to ensure the note is included in the tree).\n    ///\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = Counted::new(nullifier, self.next_counter());\n        self.nullifier_read_requests.push(request);\n    }\n\n    /// Requests the app-siloed nullifier secret key (nsk_app) for the given\n    /// (hashed) master nullifier public key (npk_m), from the user's PXE.\n    ///\n    /// Advanced function: Only needed if you're designing your own notes and/or\n    /// nullifiers.\n    ///\n    /// Contracts are not allowed to compute nullifiers for other contracts, as\n    /// that would let them read parts of their private state. Because of this,\n    /// a contract is only given an \"app-siloed secret key\", which is\n    /// constructed by hashing the user's master nullifier secret key with the\n    /// contract's address.\n    /// However, because contracts cannot be trusted with a user's master\n    /// nullifier secret key (because we don't know which contracts are honest\n    /// or malicious), the PXE refuses to provide any master secret keys to\n    /// any app smart contract function. This means app functions are unable to\n    /// prove that the derivation of an app-siloed nullifier secret key has been\n    /// computed correctly. Instead, an app function can request to the kernel\n    /// (via `request_nsk_app`) that it validates the siloed derivation, since\n    /// the kernel has been vetted to not leak any master secret keys.\n    ///\n    /// A common nullification scheme is to inject a nullifier secret key into\n    /// the preimage of a nullifier, to make the nullifier deterministic but\n    /// random-looking. This function enables that flow.\n    ///\n    /// # Arguments\n    /// * `npk_m_hash` - A hash of the master nullifier public key of the user\n    ///                  whose PXE is executing this function.\n    ///\n    /// # Returns\n    /// * The app-siloed nullifier secret key that corresponds to the given\n    ///   `npk_m_hash`.\n    ///\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    /// Requests the app-siloed nullifier secret key (nsk_app) for the given\n    /// (hashed) master nullifier public key (npk_m), from the user's PXE.\n    ///\n    /// See `request_nsk_app` and `request_sk_app` for more info.\n    ///\n    /// The intention of the \"outgoing\" keypair is to provide a second secret\n    /// key for all of a user's outgoing activity (i.e. for notes that a user\n    /// creates, as opposed to notes that a user receives from others). The\n    /// separation of incoming and outgoing data was a distinction made by\n    /// zcash, with the intention of enabling a user to optionally share with a\n    /// 3rd party a controlled view of only incoming or outgoing notes.\n    /// Similar functionality of sharing select data can be achieved with\n    /// offchain zero-knowledge proofs. It is up to an app developer whether\n    /// they choose to make use of a user's outgoing keypair within their\n    /// application logic, or instead simply use the same keypair (the address\n    /// keypair (which is effectively the same as the \"incooming\" keypair)) for\n    /// all incoming & outgoing messages to a user.\n    ///\n    /// Currently, all of the exposed encryption functions in aztec-nr ignore\n    /// the outgoing viewing keys, and instead encrypt all note logs and event\n    /// logs to a user's address public key.\n    ///\n    /// # Arguments\n    /// * `ovpk_m_hash` - Hash of the outgoing viewing public key master\n    ///\n    /// # Returns\n    /// * The application-specific outgoing viewing secret key\n    ///\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    /// Pushes a Key Validation Request to the kernel.\n    ///\n    /// Private functions are not allowed to see a user's master secret keys,\n    /// because we do not trust them. They are instead given \"app-siloed\" secret\n    /// keys with a claim that they relate to a master public key.\n    /// They can then request validation of this claim, by making a \"key\n    /// validation request\" to the protocol's kernel circuits (which _are_\n    /// allowed to see certain master secret keys).\n    ///\n    /// When a Key Validation Request tuple of (sk_app, Pk_m, app_address) is\n    /// submitted to the kernel, it will perform the following derivations\n    /// to validate the relationship between the claimed sk_app and the user's\n    /// Pk_m:\n    ///\n    ///       (sk_m) ----> * G ----> Pk_m\n    ///         |                     |\n    ///         v                       We use the kernel to prove this\n    ///  h(sk_m, app_address)         | sk_app-Pk_m relationship, because app\n    ///         |                       circuits must not be trusted to see sk_m.\n    ///         v                     |\n    ///      sk_app - -  - - - - - - -\n    ///\n    /// The function is named \"request_\" instead of \"get_\" to remind the user\n    /// that a Key Validation Request will be emitted to the kernel.\n    ///\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    /// Sends an \"L2 -> L1 message\" from this function (Aztec, L2) to a smart\n    /// contract on Ethereum (L1). L1 contracts which are designed to\n    /// send/receive messages to/from Aztec are called \"Portal Contracts\".\n    ///\n    /// Common use cases include withdrawals, cross-chain asset transfers, and\n    /// triggering L1 actions based on L2 state changes.\n    ///\n    /// The message will be inserted into an Aztec \"Outbox\" contract on L1,\n    /// when this transaction's block is proposed to L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target portal contract. The message will need to be manually\n    /// consumed from the Outbox through a separate Ethereum transaction: a user\n    /// will need to call a function of the portal contract -- a function\n    /// specifically designed to make a call to the Outbox to consume the\n    /// message.\n    /// The message will only be available for consumption once the _epoch_\n    /// proof has been submitted. Given that there are multiple Aztec blocks\n    /// within an epoch, it might take some time for this epoch proof to be\n    /// submitted -- especially if the block was near the start of an epoch.\n    ///\n    /// # Arguments\n    /// * `recipient` - Ethereum address that will receive the message\n    /// * `content` - Message content (32 bytes as a Field element).\n    ///               This content has a very specific layout.\n    /// docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        let message = L2ToL1Message { recipient, content };\n        self.l2_to_l1_msgs.push(message.count(self.next_counter()));\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2).\n    ///\n    /// Common use cases include token bridging, cross-chain governance, and\n    /// triggering L2 actions based on L1 events.\n    ///\n    /// Use this function if you only want the message to ever be \"referred to\"\n    /// once. Once consumed using this method, the message cannot be consumed\n    /// again, because a nullifier is emitted.\n    /// If your use case wants for the message to be read unlimited times, then\n    /// you can always read any historic message from the L1-to-L2 messages tree;\n    /// messages never technically get deleted from that tree.\n    ///\n    /// The message will first be inserted into an Aztec \"Inbox\" smart contract\n    /// on L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target L2 contract. The message will need to be manually\n    /// consumed by the target contract through a separate Aztec transaction.\n    /// The message will not be available for consumption immediately. Messages\n    /// get copied over from the L1 Inbox to L2 by the next Proposer in batches.\n    /// So you will need to wait until the messages are copied before you can\n    /// consume them.\n    ///\n    /// # Arguments\n    /// * `content` - The message content that was sent from L1\n    /// * `secret` - Secret value used for message privacy (if needed)\n    /// * `sender` - Ethereum address that sent the message\n    /// * `leaf_index` - Index of the message in the L1-to-L2 message tree\n    ///\n    /// # Advanced\n    /// Validates message existence in the L1-to-L2 message tree and nullifies\n    /// the message to prevent double-consumption.\n    ///\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let nullifier = process_l1_to_l2_message(\n            self.anchor_block_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n\n    /// Emits a private log (an array of Fields) that will be published to an\n    /// Ethereum blob.\n    ///\n    /// Private logs are intended for the broadcasting of ciphertexts: that is,\n    /// encrypted events or encrypted note contents.\n    /// Since the data in the logs is meant to be _encrypted_, private_logs are\n    /// broadcast to publicly-visible Ethereum blobs.\n    /// The intended recipients of such encrypted messages can then discover and\n    /// decrypt these encrypted logs using their viewing secret key.\n    /// (See `../messages/discovery` for more details).\n    ///\n    /// Important note: This function DOES NOT _do_ any encryption of the input\n    /// `log` fields. This function blindly publishes whatever input `log` data\n    /// is fed into it, so the caller of this function should have already\n    /// performed the encryption, and the `log` should be the result of that\n    /// encryption.\n    ///\n    /// The protocol does not dictate what encryption scheme should be used:\n    /// a smart contract developer can choose whatever encryption scheme they\n    /// like.\n    /// Aztec-nr includes some off-the-shelf encryption libraries that\n    /// developers might wish to use, for convenience. These libraries not only\n    /// encrypt a plaintext (to produce a ciphertext); they also prepend the\n    /// ciphertext with a `tag` and `ephemeral public key` for easier message\n    /// discovery. This is a very dense topic, and we will be writing more\n    /// libraries and docs soon.\n    ///\n    /// > Currently, AES128 CBC encryption is the main scheme included in\n    /// > aztec.nr.\n    /// > We are currently making significant changes to the interfaces of the\n    /// > encryption library.\n    ///\n    /// In some niche use cases, an app might be tempted to publish\n    /// _un-encrypted_ data via a private log, because _public logs_ are not\n    /// available to private functions. Be warned that emitting public data via\n    /// private logs is strongly discouraged, and is considered a \"privacy\n    /// anti-pattern\", because it reveals identifiable information about _which_\n    /// function has been executed. A tx which leaks such information does not\n    /// contribute to the privacy set of the network.\n    ///\n    /// * Unlike `emit_raw_note_log`, this log is not tied to any specific note\n    ///\n    /// # Arguments\n    /// * `log` - The log data that will be publicly broadcast (so make sure\n    ///           it's already been encrypted before you call this function).\n    ///   Private logs are bounded in size (PRIVATE_LOG_SIZE_IN_FIELDS), to\n    ///   encourage all logs from all smart contracts look identical.\n    /// * `length` - The actual length of the `log` (measured in number of\n    ///              Fields). Although the input log has a max size of\n    ///   PRIVATE_LOG_SIZE_IN_FIELDS, the latter values of the array might all\n    ///   be 0's for small logs. This `length` should reflect the trimmed length\n    ///   of the array. The protocol's kernel circuits can then append random\n    ///   fields as \"padding\" after the `length`, so that the logs of this\n    ///   smart contract look indistinguishable from (the same length as) the\n    ///   logs of all other applications. It's up to wallets how much padding\n    ///   to apply, so ideally all wallets should agree on standards for this.\n    ///\n    /// # Advanced\n    ///\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS], length: u32) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter: 0 }\n            .count(counter);\n        self.private_logs.push(private_log);\n    }\n\n    // TODO: rename.\n    /// Emits a private log that is explicitly tied to a newly-emitted note_hash,\n    /// to convey to the kernel: \"this log relates to this note\".\n    ///\n    /// This linkage is important in case the note gets squashed (due to being\n    /// read later in this same tx), since we can then squash the log as well.\n    ///\n    /// See `emit_private_log` for more info about private log emission.\n    ///\n    /// # Arguments\n    /// * `log` - The log data as an array of Field elements\n    /// * `length` - The actual length of the `log` (measured in number of\n    ///              Fields).\n    /// * `note_hash_counter` - The side-effect counter that was assigned to the\n    ///                         new note_hash when it was pushed to this\n    //                          `PrivateContext`.\n    ///\n    /// Important: If your application logic requires the log to always be\n    /// emitted regardless of note squashing, consider using `emit_private_log`\n    /// instead, or emitting additional events.\n    ///\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        length: u32,\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter };\n        self.private_logs.push(private_log.count(counter));\n    }\n\n    pub fn emit_contract_class_log<let N: u32>(&mut self, log: [Field; N]) {\n        let contract_address = self.this_address();\n        let counter = self.next_counter();\n\n        let log_to_emit: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS] =\n            log.concat([0; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS - N]);\n        // Note: the length is not always N, it is the number of fields we want to broadcast, omitting trailing zeros to save blob space.\n        // Safety: The below length is constrained in the base rollup, which will make sure that all the fields beyond length are zero.\n        // However, it won't be able to check that we didn't add extra padding (trailing zeroes)\n        let length = unsafe { trimmed_array_length_hint(log_to_emit) };\n        // We hash the entire padded log to ensure a user cannot pass a shorter length and so emit incorrect shorter bytecode.\n        let log_hash = poseidon2_hash(log_to_emit);\n        // Safety: the below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\n        unsafe {\n            notify_created_contract_class_log(contract_address, log_to_emit, length, counter);\n        }\n\n        self.contract_class_logs_hashes.push(LogHash { value: log_hash, length: length }.count(\n            counter,\n        ));\n    }\n\n    /// Calls a private function on another contract (or the same contract).\n    ///\n    /// Very low-level function.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the called function\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    /// This enables contracts to interact with each other while maintaining\n    /// privacy. This \"composability\" of private contract functions is a key\n    /// feature of the Aztec network.\n    ///\n    /// If a user's transaction includes multiple private function calls, then\n    /// by the design of Aztec, the following information will remain private[1]:\n    /// - The function selectors and contract addresses of all private function\n    ///   calls will remain private, so an observer of the public mempool will\n    ///   not be able to look at a tx and deduce which private functions have\n    ///   been executed.\n    /// - The arguments and return values of all private function calls will\n    ///   remain private.\n    /// - The person who initiated the tx will remain private.\n    /// - The notes and nullifiers and private logs that are emitted by all\n    ///   private function calls will (if designed well) not leak any user\n    ///   secrets, nor leak which functions have been executed.\n    ///\n    /// [1] Caveats: Some of these privacy guarantees depend on how app\n    /// developers design their smart contracts. Some actions _can_ leak\n    /// information, such as:\n    /// - Calling an internal public function.\n    /// - Calling a public function and not setting msg_sender to Option::none\n    ///   (feature not built yet - see github).\n    /// - Calling any public function will always leak details about the nature\n    ///   of the transaction, so devs should be careful in their contract\n    ///   designs. If it can be done in a private function, then that will give\n    ///   the best privacy.\n    /// - Not padding the side-effects of a tx to some standardised, uniform\n    ///   size. The kernel circuits can take hints to pad side-effects, so a\n    ///   wallet should be able to request for a particular amount of padding.\n    ///   Wallets should ideally agree on some standard.\n    ///   - Padding should include:\n    ///     - Padding the lengths of note & nullifier arrays\n    ///     - Padding private logs with random fields, up to some standardised\n    ///       size.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Advanced\n    /// * The call is added to the private call stack and executed by kernel\n    ///   circuits after this function completes\n    /// * The called function can modify its own contract's private state\n    /// * Side effects from the called function are included in this transaction\n    /// * The call inherits the current transaction's context and gas limits\n    ///\n    pub fn call_private_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    /// Makes a read-only call to a private function on another contract.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L2 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// See `call_private_function` for more general info on private function\n    /// calls.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the called function\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn static_call_private_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    /// Calls a private function that takes no arguments.\n    ///\n    /// This is a convenience function for calling private functions that don't\n    /// require any input parameters. It's equivalent to `call_private_function`\n    /// but slightly more efficient to use when no arguments are needed.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    /// Makes a read-only call to a private function which takes no arguments.\n    ///\n    /// This combines the optimisation of `call_private_function_no_args` with\n    /// the safety of `static_call_private_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    /// Low-level private function call.\n    ///\n    /// This is the underlying implementation used by all other private function\n    /// call methods. Instead of taking raw arguments, it accepts a\n    /// hash of the arguments.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args_hash` - Pre-computed hash of the function arguments\n    /// * `is_static_call` - Whether this should be a read-only call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values\n    ///\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1; // TODO: call `next_counter` instead, for consistency\n        ReturnsHash::new(returns_hash)\n    }\n\n    /// Enqueues a call to a public function to be executed later.\n    ///\n    /// Unlike private functions which execute immediately on the user's device,\n    /// public function calls are \"enqueued\" and executed some time later by a\n    /// block proposer.\n    ///\n    /// This means a public function cannot return any values back to a private\n    /// function, because by the time the public function is being executed,\n    /// the private function which called it has already completed execution.\n    /// (In fact, the private function has been executed and proven, along with\n    /// all other private function calls of the user's tx. A single proof of the\n    /// tx has been submitted to the Aztec network, and some time later a\n    /// proposer has picked the tx up from the mempool and begun executing all\n    /// of the enqueued public functions).\n    ///\n    /// # Privacy warning\n    /// Enqueueing a public function call is an inherently leaky action.\n    /// Many interesting applications will require some interaction with public\n    /// state, but smart contract developers should try to use public function\n    /// calls sparingly, and carefully.\n    /// _Internal_ public function calls are especially leaky, because they\n    /// completely leak which private contract made the call.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the public function\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn call_public_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n        hide_msg_sender: bool,\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a read-only call to a public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// See also `call_public_function` for more important information about\n    /// making private -> public function calls.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the public function\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn static_call_public_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n        hide_msg_sender: bool,\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            true,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a call to a public function that takes no arguments.\n    ///\n    /// This is an optimisation for calling public functions that don't\n    /// take any input parameters. It's otherwise equivalent to\n    /// `call_public_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        hide_msg_sender: bool,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a read-only call to a public function with no arguments.\n    ///\n    /// This combines the optimisation of `call_public_function_no_args` with\n    /// the safety of `static_call_public_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        hide_msg_sender: bool,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            true,\n            hide_msg_sender,\n        )\n    }\n\n    /// Low-level public function call.\n    ///\n    /// This is the underlying implementation used by all other public function\n    /// call methods. Instead of taking raw arguments, it accepts a\n    /// hash of the arguments.\n    ///\n    /// Advanced function: Most developers should use `call_public_function`\n    /// or `static_call_public_function` instead. This function is exposed for\n    /// performance optimization and advanced use cases.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `calldata_hash` - Hash of the function calldata\n    /// * `is_static_call` - Whether this should be a read-only call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n        hide_msg_sender: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let msg_sender = if hide_msg_sender {\n            NULL_MSG_SENDER_CONTRACT_ADDRESS\n        } else {\n            self.this_address()\n        };\n\n        let call_request =\n            PublicCallRequest { msg_sender, contract_address, is_static_call, calldata_hash };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    /// Enqueues a public function call, and designates it to be the teardown\n    /// function for this tx. Only one teardown function call can be made by a\n    /// tx.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase ensures the fee payer\n    /// has sufficient balance to pay the proposer their fees.\n    /// The teardown phase is primarily intended to: calculate exactly\n    /// how much the user owes, based on gas consumption, and refund the user\n    /// any change.\n    ///\n    /// Note: in some cases, the cost of refunding the user (i.e. DA costs of\n    /// tx side-effects) might exceed the refund amount. For app logic with\n    /// fairly stable and predictable gas consumption, a material refund amount\n    /// is unlikely. For app logic with unpredictable gas consumption, a\n    /// refund might be important to the user (e.g. if a hefty function reverts\n    /// very early). Wallet/FPC/Paymaster developers should be mindful of this.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the teardown\n    ///                        function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - An array of fields to pass to the function.\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    pub fn set_public_teardown_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n        hide_msg_sender: bool,\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n\n    /// Low-level function to set the public teardown function.\n    ///\n    /// This is the underlying implementation for setting the teardown function\n    /// call that will execute at the end of the transaction. Instead of taking\n    /// raw arguments, it accepts a hash of the arguments.\n    ///\n    /// Advanced function: Most developers should use\n    /// `set_public_teardown_function` instead.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the teardown\n    ///                        function\n    /// * `calldata_hash` - Hash of the function calldata\n    /// * `is_static_call` - Whether this should be a read-only call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n        hide_msg_sender: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let msg_sender = if hide_msg_sender {\n            NULL_MSG_SENDER_CONTRACT_ADDRESS\n        } else {\n            self.this_address()\n        };\n\n        self.public_teardown_call_request =\n            PublicCallRequest { msg_sender, contract_address, is_static_call, calldata_hash };\n    }\n\n    /// Increments the side-effect counter.\n    ///\n    /// Very low-level function.\n    ///\n    /// # Advanced\n    ///\n    /// Every side-effect of a private function is given a \"side-effect counter\",\n    /// based on when it is created. This PrivateContext is in charge of\n    /// assigning the counters.\n    ///\n    /// The reason we have side-effect counters is complicated. Consider this\n    /// illustrative pseudocode of inter-contract function calls:\n    /// ```\n    /// contract A {\n    ///    let x = 5; // pseudocode for storage var x.\n    ///    fn a1 {\n    ///        read x; // value: 5, counter: 1.\n    ///        x = x + 1;\n    ///        write x; // value: 6, counter: 2.\n    ///\n    ///        B.b(); // start_counter: 2, end_counter: 4\n    ///\n    ///        read x; // value: 36, counter: 5.\n    ///        x = x + 1;\n    ///        write x; // value: 37, counter: 6.\n    ///    }\n    ///\n    ///    fn a2 {\n    ///        read x; // value: 6, counter: 3.\n    ///        x = x * x;\n    ///        write x; // value: 36, counter: 4.\n    ///    }\n    /// }\n    ///\n    /// contract B {\n    ///     fn b() {\n    ///         A.a2();\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// Suppose a1 is the first function called. The comments show the execution\n    /// counter of each side-effect, and what the new value of `x` is.\n    ///\n    /// These (private) functions are processed by Aztec's kernel circuits in an\n    /// order that is different from execution order:\n    /// All of A.a1 is proven before B.b is proven, before A.a2 is proven.\n    /// So when we're in the 2nd execution frame of A.a1 (after the call to\n    /// B.b), the circuit needs to justify why x went from being `6` to `36`.\n    /// But the circuit doesn't know why, and given the order of proving, the\n    /// kernel hasn't _seen_ a value of 36 get written yet.\n    /// The kernel needs to track big arrays of all side-effects of all\n    /// private functions in a tx. Then, as it recurses and processes B.b(), it\n    /// will eventually see a value of 36 get written.\n    ///\n    /// Suppose side-effect counters weren't exposed:\n    /// The kernel would only see this ordering (in order of proof verification):\n    /// [ A.a1.read, A.a1.write, A.a1.read, A.a1.write, A.a2.read, A.a2.write ]\n    /// [         5,          6,        36,         37,         6,         36 ]\n    /// The kernel wouldn't know _when_ B.b() was called within A.a1(), because\n    /// it can't see what's going on within an app circuit. So the kernel\n    /// wouldn't know that the ordering of reads and writes should actually be:\n    /// [ A.a1.read, A.a1.write, A.a2.read, A.a2.write, A.a1.read, A.a1.write ]\n    /// [         5,          6,        6,         36,         36,         37 ]\n    ///\n    /// And so, we introduced side-effect counters: every private function must\n    /// assign side-effect counters alongside every side-effect that it emits,\n    /// and also expose to the kernel the counters that it started and ended\n    /// with.\n    /// This gives the kernel enough information to arrange all side-effects in\n    /// the correct order.\n    /// It can then catch (for example) if a function tries to read state\n    /// before it has been written (e.g. if A.a2() maliciously tried to read\n    /// a value of x=37) (e.g. if A.a1() maliciously tried to read x=6).\n    ///\n    /// If a malicious app contract _lies_ and does not count correctly:\n    /// - It cannot lie about its start and end counters because the kernel\n    ///   will catch this.\n    /// - It _could_ lie about its intermediate counters:\n    ///   - 1. It could not increment its side-effects correctly\n    ///   - 2. It could label its side-effects with counters outside of its\n    ///        start and end counters' range.\n    ///   The kernel will catch 2.\n    ///   The kernel will not catch 1., but this would only cause corruption\n    ///   to the private state of the malicious contract, and not any other\n    ///   contracts (because a contract can only modify its own state). If\n    ///   a \"good\" contract is given _read access_ to a maliciously-counting\n    ///   contract (via an external getter function, or by reading historic\n    ///   state from the archive tree directly), and they then make state\n    ///   changes to their _own_ state accordingly, that could be dangerous.\n    ///   Developers should be mindful not to trust the claimed innards of\n    ///   external contracts unless they have audited/vetted the contracts\n    ///   including vetting the side-effect counter incrementation.\n    ///   This is a similar paradigm to Ethereum smart contract development:\n    ///   you must vet external contracts that your contract relies upon, and\n    ///   you must not make any presumptions about their claimed behaviour.\n    ///   (Hopefully if a contract imports a version of aztec-nr, we will get\n    ///   contract verification tooling that can validate the authenticity\n    ///   of the imported aztec-nr package, and hence infer that the side-\n    ///   effect counting will be correct, without having to re-audit such logic\n    ///   for every contract).\n    ///\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            include_by_timestamp: 0,\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            anchor_block_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "71": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::{MAX_U32_VALUE, NULL_MSG_SENDER_CONTRACT_ADDRESS};\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\n/// # PublicContext\n///\n/// The **main interface** between an #[external(\"public\")] function and the Aztec blockchain.\n///\n/// An instance of the PublicContext is initialized automatically at the outset\n/// of every public function, within the #[external(\"public\")] macro, so you'll never\n/// need to consciously instantiate this yourself.\n///\n/// The instance is always named `context`, and it will always be available\n/// within the body of every #[external(\"public\")] function in your smart contract.\n///\n/// Typical usage for a smart contract developer will be to call getter\n/// methods of the PublicContext.\n///\n/// _Pushing_ data and requests to the context is mostly handled within\n/// aztec-nr's own functions, so typically a smart contract developer won't\n/// need to call any setter methods directly.\n///\n/// ## Responsibilities\n/// - Exposes contextual data to a public function:\n///   - Data relating to how this public function was called:\n///     - msg_sender, this_address\n///   - Data relating to the current blockchain state:\n///     - timestamp, block_number, chain_id, version\n///   - Gas and fee information\n/// - Provides state access:\n///   - Read/write public storage (key-value mapping)\n///   - Check existence of notes and nullifiers\n///     (Some patterns use notes & nullifiers to store public (not private)\n///     information)\n///   - Enables consumption of L1->L2 messages.\n/// - Enables calls to other public smart contract functions:\n/// - Writes data to the blockchain:\n///   - Updates to public state variables\n///   - New public logs (for events)\n///   - New L2->L1 messages\n///   - New notes & nullifiers\n///     (E.g. pushing public info to notes/nullifiers, or for completing\n///     \"partial notes\")\n///\n/// ## Key Differences from Private Execution\n///\n/// Unlike private functions -- which are executed on the user's device and which\n/// can only reference historic state -- public functions are executed by a block\n/// proposer and are executed \"live\" on the _current_ tip of the chain.\n/// This means public functions can:\n/// - Read and write _current_ public state\n/// - Immediately see the effects of earlier transactions in the same block\n///\n/// Also, public functions are executed within a zkVM (the \"AVM\"), so that they\n/// can _revert_ whilst still ensuring payment to the proposer and prover.\n/// (Private functions cannot revert: they either succeed, or they cannot be\n/// included).\n///\n/// ## Optimising Public Functions\n///\n/// Using the AVM to execute public functions means they compile down to \"AVM\n/// bytecode\" instead of the ACIR that private functions (standalone circuits)\n/// compile to. Therefore the approach to optimising a public function is\n/// fundamentally different from optimising a public function.\n///\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl Eq for PublicContext {\n    fn eq(self, other: Self) -> bool {\n        (self.args_hash == other.args_hash)\n        // Can't compare the function compute_args_hash\n    }\n}\n\nimpl PublicContext {\n    /// Creates a new PublicContext instance.\n    ///\n    /// Low-level function: This is called automatically by the #[external(\"public\")]\n    /// macro, so you shouldn't need to be called directly by smart contract\n    /// developers.\n    ///\n    /// # Arguments\n    /// * `compute_args_hash` - Function to compute the args_hash\n    ///\n    /// # Returns\n    /// * A new PublicContext instance\n    ///\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    /// Emits a _public_ log that will be visible onchain to everyone.\n    ///\n    /// # Arguments\n    /// * `log` - The data to log, must implement Serialize trait\n    ///\n    pub fn emit_public_log<T>(_self: &mut Self, log: T)\n    where\n        T: Serialize,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    /// Checks if a given note hash exists in the note hash tree at a particular\n    /// leaf_index.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The note hash to check for existence\n    /// * `leaf_index` - The index where the note hash should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the note hash exists at the specified index\n    ///\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: u64) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    /// Checks if a specific L1-to-L2 message exists in the L1-to-L2 message\n    /// tree at a particular leaf index.\n    ///\n    /// Common use cases include token bridging, cross-chain governance, and\n    /// triggering L2 actions based on L1 events.\n    ///\n    /// This function should be called before attempting to consume an L1-to-L2\n    /// message.\n    ///\n    /// # Arguments\n    /// * `msg_hash` - Hash of the L1-to-L2 message to check\n    /// * `msg_leaf_index` - The index where the message should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the message exists at the specified index\n    ///\n    /// # Advanced\n    /// * Uses the AVM l1_to_l2_msg_exists opcode for tree lookup\n    /// * Messages are copied from L1 Inbox to L2 by block proposers\n    ///\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        // TODO(alvaro): Make l1l2msg leaf index a u64 upstream\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index as u64) } == 1\n    }\n\n    /// Checks if a specific nullifier has been emitted by a given contract.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. An example is to check\n    /// whether a contract has been published: we emit a nullifier that is\n    /// deterministic, but whose preimage is _not_ private. This is more\n    /// efficient than using mutable storage, and can be done directly\n    /// from a private function.\n    ///\n    /// Nullifiers can be tested for non-existence in public, which is not the\n    /// case in private. Because private functions do not have access to\n    /// the tip of the blockchain (but only the anchor block they are built\n    /// at) they can only prove nullifier non-existence in the past. But between\n    /// an anchor block and the block in which a tx is included, the nullifier\n    /// might have been inserted into the nullifier tree by some other\n    /// transaction.\n    /// Public functions _do_ have access to the tip of the state, and so\n    /// this pattern is safe.\n    ///\n    /// # Arguments\n    /// * `unsiloed_nullifier` - The raw nullifier value (before siloing with\n    ///                          the contract address that emitted it).\n    /// * `address` - The claimed contract address that emitted the nullifier\n    ///\n    /// # Returns\n    /// * `bool` - True if the nullifier has been emitted by the specified contract\n    ///\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2) -- effectively\n    /// marking it as \"read\".\n    ///\n    /// Use this function if you only want the message to ever be \"referred to\"\n    /// once. Once consumed using this method, the message cannot be consumed\n    /// again, because a nullifier is emitted.\n    /// If your use case wants for the message to be read unlimited times, then\n    /// you can always read any historic message from the L1-to-L2 messages tree,\n    /// using the `l1_to_l2_msg_exists` method. Messages never technically get\n    /// deleted from that tree.\n    ///\n    /// The message will first be inserted into an Aztec \"Inbox\" smart contract\n    /// on L1. It will not be available for consumption immediately. Messages\n    /// get copied-over from the L1 Inbox to L2 by the next Proposer in batches.\n    /// So you will need to wait until the messages are copied before you can\n    /// consume them.\n    ///\n    /// # Arguments\n    /// * `content` - The message content that was sent from L1\n    /// * `secret` - Secret value used for message privacy (if needed)\n    /// * `sender` - Ethereum address that sent the message\n    /// * `leaf_index` - Index of the message in the L1-to-L2 message tree\n    ///\n    /// # Advanced\n    /// * Validates message existence in the L1-to-L2 message tree\n    /// * Prevents double-consumption by emitting a nullifier\n    /// * Message hash is computed from all parameters + chain context\n    /// * Will revert if message doesn't exist or was already consumed\n    ///\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    /// Sends an \"L2 -> L1 message\" from this function (Aztec, L2) to a smart\n    /// contract on Ethereum (L1). L1 contracts which are designed to\n    /// send/receive messages to/from Aztec are called \"Portal Contracts\".\n    ///\n    /// Common use cases include withdrawals, cross-chain asset transfers, and\n    /// triggering L1 actions based on L2 state changes.\n    ///\n    /// The message will be inserted into an Aztec \"Outbox\" contract on L1,\n    /// when this transaction's block is proposed to L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target portal contract. The message will need to be manually\n    /// consumed from the Outbox through a separate Ethereum transaction: a user\n    /// will need to call a function of the portal contract -- a function\n    /// specifically designed to make a call to the Outbox to consume the\n    /// message.\n    /// The message will only be available for consumption once the _epoch_\n    /// proof has been submitted. Given that there are multiple Aztec blocks\n    /// within an epoch, it might take some time for this epoch proof to be\n    /// submitted -- especially if the block was near the start of an epoch.\n    ///\n    /// # Arguments\n    /// * `recipient` - Ethereum address that will receive the message\n    /// * `content` - Message content (32 bytes as a Field element)\n    ///\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    /// Calls a public function on another contract.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Arguments to pass to the function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Makes a read-only call to a public function on another contract.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Useful for querying data from other contracts safely.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Array of arguments to pass to the called function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Adds a new note hash to the Aztec blockchain's global Note Hash Tree.\n    ///\n    /// Notes are ordinarily constructed and emitted by _private_ functions, to\n    /// ensure that both the content of the note, and the contract that emitted\n    /// the note, stay private.\n    ///\n    /// There are however some useful patterns whereby a note needs to contain\n    /// _public_ data. The ability to push a new note_hash from a _public_\n    /// function means that notes can be injected with public data immediately\n    /// -- as soon as the public value is known. The slower alternative would\n    /// be to submit a follow-up transaction so that a private function can\n    /// inject the data. Both are possible on Aztec.\n    ///\n    /// Search \"Partial Note\" for a very common pattern which enables a note\n    /// to be \"partially\" populated with some data in a _private_ function, and\n    /// then later \"completed\" with some data in a public function.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The hash of the note to add to the tree\n    ///\n    /// # Advanced\n    /// * The note hash will be siloed with the contract address by the protocol\n    ///\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n\n    /// Adds a new nullifier to the Aztec blockchain's global Nullifier Tree.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. Hence why you're seeing this\n    /// function within the PublicContext.\n    /// An example is to check whether a contract has been published: we emit\n    /// a nullifier that is deterministic, but whose preimage is _not_ private.\n    ///\n    /// # Arguments\n    /// * `nullifier` - A unique field element that represents the consumed\n    ///   state\n    ///\n    /// # Advanced\n    /// * Nullifier is immediately added to the global nullifier tree\n    /// * Emitted nullifiers are immediately visible to all\n    ///   subsequent transactions in the same block\n    /// * Automatically siloed with the contract address by the protocol\n    /// * Used for preventing double-spending and ensuring one-time actions\n    ///\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    /// Returns the address of the current contract being executed.\n    ///\n    /// This is equivalent to `address(this)` in Solidity (hence the name).\n    /// Use this to identify the current contract's address, commonly needed for\n    /// access control or when interacting with other contracts.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The contract address of the current function being\n    ///                    executed.\n    ///\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: If the calling function is a _private_ function, then\n    /// it had the option of hiding its address when enqueuing this public\n    /// function call. In such cases, this `context.msg_sender()` method will\n    /// return `Option<AztecAddress>::none`.\n    /// If the calling function is a _public_ function, it will always return\n    /// an `Option<AztecAddress>::some` (i.e. a non-null value).\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called\n    ///   this function (be it an app contract or a user's account contract).\n    ///\n    /// # Advanced\n    /// * Value is provided by the AVM sender opcode\n    /// * In nested calls, this is the immediate caller, not the original\n    ///   transaction sender\n    ///\n    pub fn msg_sender(_self: Self) -> Option<AztecAddress> {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let maybe_msg_sender = unsafe { sender() };\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// \"Unsafe\" versus calling `context.msg_sender()`, because it doesn't\n    /// translate `NULL_MSG_SENDER_CONTRACT_ADDRESS` as\n    /// `Option<AztecAddress>::none`.\n    /// Used by some internal aztecnr functions.\n    pub fn msg_sender_unsafe(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n\n    /// Returns the function selector of the currently-executing function.\n    ///\n    /// This is similar to `msg.sig` in Solidity, returning the first 4\n    /// bytes of the function signature.\n    ///\n    /// # Returns\n    /// * `FunctionSelector` - The 4-byte function identifier\n    ///\n    /// # Advanced\n    /// * Extracted from the first element of calldata\n    /// * Used internally for function dispatch in the AVM\n    ///\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    ///\n    /// Very low-level function: The #[external(\"public\")] macro uses this internally.\n    /// Smart contract developers typically won't need to access this\n    /// directly as arguments are automatically made available.\n    ///\n    /// # Returns\n    /// * `Field` - Hash of the function arguments\n    ///\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n\n    /// Returns the \"transaction fee\" for the current transaction.\n    /// This is the final tx fee that will be deducted from the fee_payer's\n    /// \"fee-juice\" balance (in the protocol's Base Rollup circuit).\n    ///\n    /// # Returns\n    /// * `Field` - The actual, final cost of the transaction, taking into account:\n    ///             the actual gas used during the setup and app-logic phases,\n    ///             and the fixed amount of gas that's been allocated by the user\n    ///             for the teardown phase.\n    ///             I.e. effectiveL2FeePerGas * l2GasUsed + effectiveDAFeePerGas * daGasUsed\n    ///\n    /// This will return `0` during the \"setup\" and \"app-logic\" phases of\n    /// tx execution (because the final tx fee is not known at that time).\n    /// This will only return a nonzero value during the \"teardown\" phase of\n    /// execution, where the final tx fee can actually be computed.\n    ///\n    /// Regardless of _when_ this function is called during the teardown phase,\n    /// it will always return the same final tx fee value. The teardown phase\n    /// does not consume a variable amount of gas: it always consumes a\n    /// pre-allocated amount of gas, as specified by the user when they generate\n    /// their tx.\n    ///\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    /// Returns the chain ID of the current network.\n    ///\n    /// This is similar to `block.chainid` in Solidity. Returns the unique\n    /// identifier for the blockchain network this transaction is executing on.\n    ///\n    /// Helps prevent cross-chain replay attacks. Useful if implementing\n    /// multi-chain contract logic.\n    ///\n    /// # Returns\n    /// * `Field` - The chain ID as a field element\n    ///\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n\n    /// Returns the Aztec protocol version that this transaction is executing\n    /// under. Different versions may have different rules, opcodes, or\n    /// cryptographic primitives.\n    ///\n    /// This is similar to how Ethereum has different EVM versions.\n    ///\n    /// Useful for forward/backward compatibility checks\n    ///\n    /// Not to be confused with contract versions; this is the protocol version.\n    ///\n    /// # Returns\n    /// * `Field` - The protocol version as a field element\n    ///\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    /// Returns the current block number.\n    ///\n    /// This is similar to `block.number` in Solidity.\n    ///\n    /// Note: the current block number is only available within a public function\n    /// (as opposed to a private function).\n    ///\n    /// Note: the time intervals between blocks should not be relied upon as\n    /// being consistent:\n    /// - Timestamps of blocks fall within a range, rather than at exact regular\n    ///   intervals.\n    /// - Slots can be missed.\n    /// - Protocol upgrades can completely change the intervals between blocks\n    ///   (and indeed the current roadmap plans to reduce the time between\n    ///   blocks, eventually).\n    /// Use `context.timestamp()` for more-reliable time-based logic.\n    ///\n    /// # Returns\n    /// * `u32` - The current block number\n    ///\n    pub fn block_number(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n\n    /// Returns the timestamp of the current block.\n    ///\n    /// This is similar to `block.timestamp` in Solidity.\n    ///\n    /// All functions of all transactions in a block share the exact same\n    /// timestamp (even though technically each transaction is executed\n    /// one-after-the-other).\n    ///\n    /// Important note: Timestamps of Aztec blocks are not at reliably-fixed\n    /// intervals. The proposer of the block has some flexibility to choose a\n    /// timestamp which is in a valid _range_: Obviously the timestamp of this\n    /// block must be strictly greater than that of the previous block, and must\n    /// must be less than the timestamp of whichever ethereum block the aztec\n    /// block is proposed to. Furthermore, if the timestamp is not deemed close\n    /// enough to the actual current time, the committee of validators will not\n    /// attest to the block.\n    ///\n    /// # Returns\n    /// * `u64` - Unix timestamp in seconds\n    ///\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n\n    /// Returns the fee per unit of L2 gas for this transaction (aka the \"L2 gas\n    /// price\"), as chosen by the user.\n    ///\n    /// L2 gas covers the cost of executing public functions and handling\n    /// side-effects within the AVM.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of L2 gas\n    ///\n    /// Wallet developers should be mindful that the choice of gas price (which\n    /// is publicly visible) can leak information about the user, e.g.:\n    /// - which wallet software the user is using;\n    /// - the amount of time which has elapsed from the time the user's wallet\n    ///   chose a gas price (at the going rate), to the time of tx submission.\n    ///   This can give clues about the proving time, and hence the nature of\n    ///   the tx.\n    /// - the urgency of the transaction (which is kind of unavoidable, if the\n    ///   tx is indeed urgent).\n    /// - the wealth of the user.\n    /// - the exact user (if the gas price is explicitly chosen by the user to\n    ///   be some unique number like 0.123456789, or their favourite number).\n    /// Wallet devs might wish to consider fuzzing the choice of gas price.\n    ///\n    pub fn base_fee_per_l2_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_l2_gas()\n        }\n    }\n\n    /// Returns the fee per unit of DA (Data Availability) gas (aka the \"DA gas\n    /// price\").\n    ///\n    /// DA gas covers the cost of making transaction data available on L1.\n    ///\n    /// See the warning in `fee_pre_l2_gas` for how gas prices can be leaky.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of DA gas\n    ///\n    pub fn base_fee_per_da_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_da_gas()\n        }\n    }\n\n    /// Returns the remaining L2 gas available for this transaction.\n    ///\n    /// Different AVM opcodes consume different amounts of gas.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining L2 gas units\n    ///\n    pub fn l2_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n\n    /// Returns the remaining DA (Data Availability) gas available for this\n    /// transaction.\n    ///\n    /// DA gas is consumed when emitting data that needs to be made available\n    /// on L1, such as public logs or state updates.\n    /// All of the side-effects from the private part of the tx also consume\n    /// DA gas before execution of any public functions even begins.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining DA gas units\n    ///\n    pub fn da_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n\n    /// Checks if the current execution is within a staticcall context, where\n    /// no state changes or logs are allowed to be emitted (by this function\n    /// or any nested function calls).\n    ///\n    /// # Returns\n    /// * `bool` - True if in staticcall context, false otherwise\n    ///\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    /// Reads raw field values from public storage.\n    /// Reads N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to read from\n    ///\n    /// # Returns\n    /// * `[Field; N]` - Array of N field values from consecutive storage slots\n    ///\n    /// # Generic Parameters\n    /// * `N` - the number of consecutive slots to return, starting from the\n    ///         `storage_slot`.\n    ///\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    /// Reads a typed value from public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to read from\n    ///\n    /// # Returns\n    /// * `T` - The deserialized value from storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type that the caller expects to read from the `storage_slot`.\n    ///\n    pub fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    /// Writes raw field values to public storage.\n    /// Writes to N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// Public storage writes take effect immediately.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to write to\n    /// * `values` - Array of N Fields to write to storage\n    ///\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    /// Writes a typed value to public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to write to\n    /// * `value` - The typed value to write to storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type to write to storage.\n    ///\n    pub fn storage_write<T>(self, storage_slot: Field, value: T)\n    where\n        T: Packable,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> u32 {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn base_fee_per_l2_gas() -> u128 {\n    base_fee_per_l2_gas_opcode()\n}\nunconstrained fn base_fee_per_da_gas() -> u128 {\n    base_fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> u32 {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> u32 {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> u1 {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: u64) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: u64) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\n\nunconstrained fn call(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\nunconstrained fn call_static(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeBaseFeePerL2Gas)]\nunconstrained fn base_fee_per_l2_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeBaseFeePerDaGas)]\nunconstrained fn base_fee_per_da_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> u1 {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "72": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr",
      "source": "use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\n/// A hash that represents a private contract function call's return value. Call `get_preimage` to get the underlying\n/// value.\n///\n/// The kernels don't process the actual return values but instead their hashes, so it is up to contracts to populate\n/// oracles with the preimages of these hashes on return to make them available to their callers.\n///\n/// Public calls don't utilize this mechanism since the AVM does process the full return values.\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    /// Fetches the underlying return value from an oracle, constraining that it corresponds to the return data hash.\n    pub fn get_preimage<T>(self) -> T\n    where\n        T: Deserialize,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it. If `T`\n        // is `()`, then `preimage` must be an array of length 0 (since that is `()`'s deserialization length).\n        // `hash_args_array` handles empty arrays following the protocol rules (i.e. an empty args array is signaled\n        // with a zero hash), correctly constraining `self.hash`.\n        let preimage = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage), \"Preimage mismatch\");\n\n        Deserialize::deserialize(preimage)\n    }\n}\n\nmod test {\n    use crate::{\n        hash::hash_args_array,\n        oracle::execution_cache,\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use super::ReturnsHash;\n    use protocol_types::traits::Serialize;\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn retrieves_preimage() {\n        let env = TestEnvironment::new();\n        env.private_context(|_| {\n            let value = MockStruct::new(4, 7);\n            let serialized = value.serialize();\n\n            let hash = hash_args_array(serialized);\n            execution_cache::store(serialized, hash);\n\n            assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n        });\n    }\n\n    #[test]\n    unconstrained fn retrieves_empty_preimage() {\n        let env = TestEnvironment::new();\n        env.private_context(|_| {\n            let value = ();\n            let serialized = [];\n\n            let hash = hash_args_array(serialized);\n            execution_cache::store(serialized, hash);\n\n            assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n        });\n    }\n\n    #[test(should_fail_with = \"Preimage mismatch\")]\n    unconstrained fn rejects_bad_preimage() {\n        let value = MockStruct::new(4, 7);\n        let serialized = value.serialize();\n\n        let mut bad_serialized = serialized;\n        bad_serialized[0] += 1;\n\n        let hash = hash_args_array(serialized);\n\n        let _ = OracleMock::mock(\"privateLoadFromExecutionCache\").returns(bad_serialized);\n        assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n    }\n\n    // This test passes due to a Noir bug.\n    // #[test(should_fail_with=\"Preimage mismatch\")]\n    // unconstrained fn rejects_bad_empty_preimage() {\n    //     let value = ();\n    //     let serialized = [];\n\n    //     let hash = hash_args_array(serialized);\n\n    //     let _ = OracleMock::mock(\"privateLoadFromExecutionCache\").returns([1]);\n    //     assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n    // }\n}\n"
    },
    "73": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{execution::get_utility_context, storage::storage_read};\nuse protocol_types::{address::AztecAddress, traits::Packable};\n\n// If you'll modify this struct don't forget to update utility_context.ts as well.\npub struct UtilityContext {\n    block_number: u32,\n    timestamp: u64,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        get_utility_context()\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        // We get a context with default contract address, and then we construct the final context with the provided\n        // contract address.\n        let default_context = get_utility_context();\n\n        Self {\n            block_number: default_context.block_number,\n            timestamp: default_context.timestamp,\n            contract_address,\n            version: default_context.version,\n            chain_id: default_context.chain_id,\n        }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        // We get a context with default contract address and block number, and then we construct the final context\n        // with the provided contract address and block number.\n        let default_context = get_utility_context();\n\n        Self {\n            block_number,\n            timestamp: default_context.timestamp,\n            contract_address,\n            version: default_context.version,\n            chain_id: default_context.chain_id,\n        }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn timestamp(self) -> u64 {\n        self.timestamp\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "76": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/event/event_selector.nr",
      "source": "use dep::protocol_types::{\n    hash::poseidon2_hash_bytes,\n    traits::{Deserialize, Empty, FromField, Serialize, ToField},\n};\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "78": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_BYTECODE, GENERATOR_INDEX__PUBLIC_CALLDATA,\n        GENERATOR_INDEX__SECRET_HASH, MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS,\n    },\n    hash::{\n        poseidon2_hash_subarray, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice,\n        sha256_to_field,\n    },\n    point::Point,\n    traits::ToField,\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n}\n\n/**\n * Computes the public bytecode commitment for a contract class.\n * The commitment is `hash([separator, ...bytecode])` where bytecode omits the length prefix present\n * in `packed_bytecode`.\n *\n * @param packed_bytecode - The packed bytecode of the contract class. 0th word is the length in bytes.\n *    packed_bytecode is mutable so that we can avoid copying the array to construct one starting with\n *    separator instead of length.\n * @returns The public bytecode commitment.\n */\npub fn compute_public_bytecode_commitment(\n    mut packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS],\n) -> Field {\n    // First field element contains the length of the bytecode\n    let bytecode_length_in_bytes: u32 = packed_public_bytecode[0] as u32;\n    let bytecode_length_in_fields: u32 =\n        (bytecode_length_in_bytes / 31) + (bytecode_length_in_bytes % 31 != 0) as u32;\n    // Don't allow empty public bytecode.\n    // AVM doesn't handle execution of contracts that exist with empty bytecode.\n    assert(bytecode_length_in_fields != 0);\n    assert(bytecode_length_in_fields < MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS);\n\n    // Packed_bytecode's 0th entry is the length. Replace it with separator before hashing.\n    let separator = GENERATOR_INDEX__PUBLIC_BYTECODE.to_field();\n    packed_public_bytecode[0] = separator;\n\n    // `fields_to_hash` is the number of fields from the start of `packed_public_bytecode` that should be included in\n    // the hash. Fields after this length are ignored.\n    // +1 to account for the separator.\n    let num_fields_to_hash = bytecode_length_in_fields + 1;\n\n    poseidon2_hash_subarray(packed_public_bytecode, num_fields_to_hash)\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = [0; 100];\n    for i in 0..100 {\n        input[i] = i as Field;\n    }\n    let hash = hash_args_array(input);\n    dep::std::println(hash);\n    // Used in yarn-project/stdlib test snapshots:\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_calldata_hash() {\n    let mut input = [0; 100];\n    for i in 0..input.len() {\n        input[i] = i as Field;\n    }\n    let hash = hash_calldata_array(input);\n    dep::std::println(hash);\n    let hash_check = hash_calldata(input.as_slice());\n    assert(hash == hash_check);\n    // Used in cpp vm2 tests:\n    assert(hash == 0x191383c9f8964afd3ea8879a03b7dda65d6724773966d18dcf80e452736fc1f3);\n}\n\n#[test]\nunconstrained fn public_bytecode_commitment() {\n    let mut input = [0; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS];\n    let len = 99;\n    for i in 1..len + 1 {\n        input[i] = i as Field;\n    }\n    input[0] = (len as Field) * 31;\n    let hash = compute_public_bytecode_commitment(input);\n    dep::std::println(hash);\n    // Used in cpp vm2 tests:\n    assert(hash == 0x16d621c3387156ef53754679e7b2c9be8f0bceeb44aa59a74991df3b0b42a0bf);\n}\n"
    },
    "90": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/history/public_storage.nr",
      "source": "use dep::protocol_types::{\n    abis::block_header::BlockHeader, address::AztecAddress,\n    constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX, hash::poseidon2_hash_with_separator,\n    utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\nuse protocol_types::traits::{Hash, ToField};\n\nmod test;\n\npub trait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        // Safety: The witness is only used as a \"magical value\" that makes the proof below pass. Hence it's safe.\n        let witness = unsafe {\n            get_public_data_witness(self.global_variables.block_number, public_data_tree_index)\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert_eq(\n            self.state.partial.public_data_tree.root,\n            root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path),\n            \"Proving public value inclusion failed\",\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(\n                preimage.slot,\n                public_data_tree_index,\n                \"Public data tree index doesn't match witness\",\n            );\n            preimage.value\n        };\n\n        value\n    }\n}\n"
    },
    "95": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n\nmod test {\n    use super::get_public_keys;\n\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use protocol_types::traits::Serialize;\n    use std::test::OracleMock;\n\n    global KEY_ORACLE_RESPONSE_LENGTH: u32 = 13; // 12 fields for the keys, one field for the partial address\n\n    #[test(should_fail_with = \"Invalid public keys hint for address\")]\n    unconstrained fn get_public_keys_fails_with_bad_hint() {\n        let mut env = TestEnvironment::new();\n        let account = env.create_light_account();\n\n        // Instead of querying for some unknown account, which would result in the oracle erroring out, we mock a bad oracle\n        // response to check that the circuit properly checks the address derivation.\n        let mut random_keys_and_partial_address = [0; KEY_ORACLE_RESPONSE_LENGTH];\n        // We use randomly generated points on the curve, and a random partial address to ensure that\n        // this combination does not derive the address and we should see the assertion fail.\n        // npk_m\n        random_keys_and_partial_address[0] =\n            0x292364b852c6c6f01472951e76a39cbcf074591fd0e063a81965e7b51ad868a5;\n        random_keys_and_partial_address[1] =\n            0x0a687b46cdc9238f1c311f126aaaa4acbd7a737bff2efd7aeabdb8d805843a27;\n        random_keys_and_partial_address[2] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // ivpk_m\n        random_keys_and_partial_address[3] =\n            0x173c5229a00c5425255680dd6edc27e278c48883991f348fe6985de43b4ec25f;\n        random_keys_and_partial_address[4] =\n            0x1698608e23b5f6c2f43c49a559108bb64e2247b8fc2da842296a416817f40b7f;\n        random_keys_and_partial_address[5] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // ovpk_m\n        random_keys_and_partial_address[6] =\n            0x1bad2f7d1ad960a1bd0fe4d2c8d17f5ab4a86ef8b103e0a9e7f67ec0d3b4795e;\n        random_keys_and_partial_address[7] =\n            0x206db87110abbecc9fbaef2c865189d94ef2c106202f734ee4eba9257fd28bf1;\n        random_keys_and_partial_address[8] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // tpk_m\n        random_keys_and_partial_address[9] =\n            0x05e3bd9cfe6b47daa139613619cf7d7fd8bb0112b6f2908caa6d9b536ed948ed;\n        random_keys_and_partial_address[10] =\n            0x051066f877c9df47552d02e7dc32127ff4edefc8498e813bca1cbd3f5d1be429;\n        random_keys_and_partial_address[11] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // partial address\n        random_keys_and_partial_address[12] =\n            0x236703e2cb00a182e024e98e9f759231b556d25ff19f98896cebb69e9e678cc9;\n\n        let _ = OracleMock::mock(\"utilityGetPublicKeysAndPartialAddress\").returns(\n            random_keys_and_partial_address.serialize(),\n        );\n        let _ = get_public_keys(account);\n    }\n}\n"
    },
    "99": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::macros::{\n    dispatch::generate_public_dispatch,\n    functions::{stub_registry, utils::check_each_fn_macroified},\n    notes::NOTES,\n    storage::STORAGE_LAYOUT_NAME,\n    utils::{get_trait_impl_method, module_has_storage},\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_private_state` utility function.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[external(...)], #[contract_library_method], or #[test] are not allowed in contracts.\n    check_each_fn_macroified(m);\n\n    // We generate `_compute_note_hash_and_nullifier`, `sync_private_state` and `process_message`\n    // functions only if they are not already implemented. If they are implemented we just insert empty\n    // quotes.\n    let contract_library_method_compute_note_hash_and_nullifier = if !m.functions().any(|f| {\n        f.name() == quote { _compute_note_hash_and_nullifier }\n    }) {\n        generate_contract_library_method_compute_note_hash_and_nullifier()\n    } else {\n        quote {}\n    };\n    let sync_private_state = if !m.functions().any(|f| f.name() == quote { sync_private_state }) {\n        generate_sync_private_state()\n    } else {\n        quote {}\n    };\n    let process_message = if !m.functions().any(|f| f.name() == quote { process_message }) {\n        generate_process_message()\n    } else {\n        quote {}\n    };\n    let public_dispatch = generate_public_dispatch(m);\n\n    quote {\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_private_state\n        $process_message\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    if NOTES.len() > 0 {\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..NOTES.len() {\n            let typ = NOTES.get(i);\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret its raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = <$typ as $crate::protocol_types::traits::Packable>::N;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided note nonce.\n                        let note_hash_for_nullification = aztec::note::utils::compute_note_hash_for_nullification(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(note_nonce).into()\n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullification);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `note_nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_message` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                note_nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_sync_private_state() -> Quoted {\n    // We obtain the `external` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::external(\"utility\")]` in the returned quote because the latter would result in\n    // the function attribute having the full path in the ABI. This is undesirable because we use the information in\n    // the ABI only to determine whether a function is `external(\"private\")`, `external(\"public\")`, or `external(\"utility\")`.\n    let external = crate::macros::functions::external;\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[external(\"utility\")] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[$external(\"utility\")]\n        unconstrained fn sync_private_state() {\n        }\n    }\n}\n\ncomptime fn generate_process_message() -> Quoted {\n    // We obtain the `external` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::external(\"utility\")]` in the returned quote because the latter would result in\n    // the function attribute having the full path in the ABI. This is undesirable because we use the information in\n    // the ABI only to determine whether a function is `external(\"private\")`, `external(\"public\")`, or `external(\"utility\")`.\n    let external = crate::macros::functions::external;\n\n    quote {\n        #[$external(\"utility\")]\n        unconstrained fn process_message(\n            message_ciphertext: BoundedVec<Field, aztec::messages::encoding::MESSAGE_CIPHERTEXT_LEN>,\n            message_context: aztec::messages::processing::message_context::MessageContext,\n        ) {\n            aztec::messages::discovery::process_message::process_message_ciphertext(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n                message_ciphertext,\n                message_context,\n            );\n        }\n    }\n}\n"
    }
  },
  "functions": [
    {
      "abi": {
        "error_types": {
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17398389091582795409": {
            "error_kind": "string",
            "string": "Function _update_value can only be called internally"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "value",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgIEAScCAwQAHwoAAgADAEQcAEREBi0IRAElAAAARiUAAABsJwIBBEUnAgIEADsOAAIAASwAAEMAMGROcuExoCm4UEW2gYFYXSgz6Eh5uXCRQ+H1k/AAAAAmJQAAAPAeAgACAB4CAAMAMyoAAgADAAQnAgIBASQCAAQAAACVJQAAARYeAgACAQoiAkMDFgoDBBwKBAUABCoFAgQnAgIBAAoqAwIFJAIABQAAAMgnAgYEADwGBgEeAgACAAoqBAIDJAIAAwAAAN8lAAABKBwKAQIAJwIBAAcwCgACAAEmKAAABAR4RQwAAAQDJAAAAwAAARUqAQABBdrF9da0SjJtPAQCASYqAQABBQZhOz0Lnb0zPAQCASYqAQABBfFzfrK70t6RPAQCASY=",
      "custom_attributes": [
        "external",
        "internal",
        "public"
      ],
      "debug_symbols": "tZbbjtowEIbfJddceManMa+yQihAWEWKAsqSShXKu3dma+dQyda2ZW/wbxt/zD8eGz+rS3Ma349tf719VPu3Z3Ua2q5r34/d7Vw/2lvPo89KyQeArvZmxy1Ve88tch8UCw0sQISLwpgkAgtZZGXEiQhROB2nHEXhZYREUBSURgIk4X4LVBwUggjLAlmASoKikAjRiZCRwELLSJimXZUMHh9D04i/lWPOw70emv5R7fux63bVj7obP7/0ca/7z/ZRDzzL7pv+wi0Dr23XiJp2y2qVXwoKFcXlrAPNCFC0gUABgsYnBjq/QtgNAgsIUh4SgxQtVjxsGDrP0GhtiAzW3uYYJSsaTQpDG5O1Yl9gxX2zFSQ9W1H5XaE8wpNPCB+4YDNBhIIR7SwmI9qF/zZi8kYKZU4+JAQRQL7ISyUaEOYyD4h5K8UadXIVxI11BrKQciRGLZEEzEIKZaqNjQjDh3Ym/FtKUeVT6gv15eby8ksIBr8cA83JJDIuH0N4wXFF9YLz+tWEmvxFXEDYYJMVG/yCsH84KRUoUSotHdQqpWH7nyLXZD4b2s8Q1IWUlq5RH+xqW2YEXyh/E4jWSyA2uy1YKFINHmY34F32yGLhJtXWQ9oa1nZ7ZA/cq8/tsHnvTEIb2vrUNbF7Hfvzavbx855m0nvpPtzOzWUcGiGtHk38+cZXhrEHeTlJx+0MHSb56V8=",
      "is_unconstrained": true,
      "name": "_update_value"
    },
    {
      "abi": {
        "error_types": {
          "14415304921900233953": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "9967937311635654895": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          }
        },
        "parameters": [
          {
            "name": "wormhole_address",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "chain_id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 16
            },
            "visibility": "private"
          },
          {
            "name": "owner",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "message_fee",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "initializer",
        "public"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "constructor"
    },
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "14067204867181196045": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "9921926525851912681": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "wormhole_address",
                "type": {
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                }
              },
              {
                "name": "chain_id",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 16
                }
              },
              {
                "name": "message_fee",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              }
            ],
            "kind": "struct",
            "path": "config::Config"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "utility"
      ],
      "debug_symbols": "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S9b3dSv6Xi8O4iQu4iYa0YlBTCLdjG5GN6Ob0c3oZnQzuhndjG5GN6eb083p5nRzujndnG5ON6eb0y3oFnQLugXdgm5Bt6Bb0C3oFnRLuiXdkm5Jt6Rb0i3plnRLuiXdDt0O3Q7dDt0O3Q7dDt0O3Q7dznND3+vFQZzERdxEIzoxiEmk26DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26LbohuzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMksOs+QwSw6z5DBLDrPkMEsOs+QwSw6z5DBLDrPkMEsOs+QwSw6z5DBLDrMEfa9rFybxPESWAAdxEhdxE43oRLpNuk26Lbotui26Lbotui26Lbotui26Lbptum26bbptum26bbptum26bbptuhndjG5GN6Ob0c3oZnQzuhndjG5ON6eb083p5nRzujndnG5ON6db0C3oFnQLugXdgm5Bt6AbssQLz0NkCbDcsnASF3ETjejEICbxPESWAOl26Hboduh26Hboduh26HbabaHv9eIgTuIibqIRnRjEJNJt0G3QbdBt0G3QbdBt0G3QbdBt0G3SbdJt0m3SbdJt0m3SbdJt0m3SbdFt0W3RbdFt0W3RbdFt0W3RbdFt023TbdNt023TbdNt023TbdNt083oZnQzuhndjG5GN6Ob0c3oZnRzujndnG5ON6eb083p5nRzujndgm5Bt6Bb0C3oFnQLugXdgm5Bt6Rb0i3plnRLuiXdkm5Jt6Rb0u3Q7dDt0O3Q7dDt0O3Q7dDt0I1ZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1ky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bqIRnRjEJJ6HQbegW9At6BZ0C7p91bLrWlgNd7uuZNVwt+szcTXcNW7iN0Jd1KrhrjGISTwPv7porHFrA06NUBtwaoSa2Uniaawmul0fxquJrnESF3ETjfi5rV9hED+3r8tuVxPdxSqGi9+431sNdjXG7bqEVmNcY803CmuE7zCrMa5xECexxrXCTTRiuXlhEJNIt0W3RbdFt7WIu/eiGuManRjEJL7drBY4bGE1u2ELq9ntbtYOYhLP2wvjbhp307ibxt007qbZ2zfjblq8zTLupnE3qwqxhVVv2Dfnbla9YQur3rBQzvUNrm9wfavesFnB3QzuZtUbNiu4m8HdDLoF3ZJuSbd8u1ldYPv71ahdXWCNk/hNp27Vqgus0YhODGISz8MqhouD+LnVbV11gTVuohGdGMRyq/lW4QCrcC4OYrmdwkXcxM/NamZVOBeD+LnZKDwPq3AuDuLn9v22za5+r103kdXv1RjEJNa4385Xv9ffGVRY40bhJC7iJpZbHXGV08UgJvFzq8dy1eS1636ymrx23S5Wk9eu269q8tr1AK6avBqdGMQknod1fbtYbrXqVVkXP7e6w6smr0YjOjGISfzcotah6u3iIE5iudV0qt4uGrHcamZVbxeT+LllbXfVW91PVpNX4yQu4iYa8Rs3a7vrqgesq97F+v9+xtV21fi5fd8D72q7alzETTSiE79jq2db1Xa164602q4uVvFeHMRJXMQadxXWCF+ZVivV/v5w+a5WqsZJrBG8cBON6MQgJrHcvn2rVqrGcquFqoK8uIh/49qv1uErPaunY9Ue1VgjWOF8C1Wld3ETjVjj1pJ8pdeYxPM2oK5kF7mbRjejm9HN6FZVCPyqxepmutqYGoNY529ZoFoKUS3AQZzERdzfYLUkYUQnBjGJ52H+iOvD2sLcRCM6MYhJPA/PjziIk0i3Q7dDt0O3Q7dDt/PcqmGpcRAncRE30YhODGIS6TboNug26DboNug26DboNug26DboNuk26TbpNuk26TbpNuk26TbpNum26Lbotui26Lbotui26Lbotui26Lbptum26bbptum26bbptum26bbpZnQzuhndjG5GN6Ob0c3oZnQzujndnG5ON6eb083p5nRzujndnG5Bt6Bb0C3oFnQLugXdgm5Bt6Bb0i3plnRjliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMksSWZKFSTyNBwFihZO4iJtoRCcGMYkvdM/4Eek26DboNug26DboNug26DboNuk26TbpNuk26TbpNuk26TbpNum26Lbotui26Lbotui26Lbotui26Lbptum26bbptum26bbptum26bbpZnQzuhndjG5GN6Ob0c3oZnQzujndnG5ON6eb083p5nRzujndnG5Bt6Bb0C3oxtuOw9uOw9uOw9uOw9uOw9uOw9uOk3RLuiXdkm5Jt6Rb0i3plnQ7dDt0O3Q7dDt0O3Q7dDt0O3Q77Wa/3484iJO4iJtoRCd+bl9jp1WXUuN5WFkyVuEgTuLn9j05tepSajSiE4OYxHLzDytLLg7iJC7iJhrRiUFMIt0W3RbdKktGrU5lycVNNKITg1huWXgeVpZcLLdTOImLuInfuN+zV6vOI5u1LZUPFyfxG2HWtlQ+XDTiN9/vuZxV51FjEs/DyodZB1T5cHESF7HGreWrmv8ej1l1EzUOYh1xWVTNX9xEIzoxiEn83FatTtX8xUGs+dZKVs1f3EQjOjGISTwPq+YvDiLdDt2q5lftUNX8qtO+av5iEJN4GqubqHEQJ3ERN9GI5WaFQUxiuX1nSXUTNQ5iuUXhIm7i57ZrsKr5i0H83L5vdK26iS5WzV/83L5neFbdRI2L+LlZTadq/qITy62mUzV/8Tysmv8ehFl1EzVO4uf2fQlr1U3UaMTPzWu+VfMXk/i5eblVzV8cxM8tduEibuLnFrVmdf9wMYifW9bG1v0DsPLh4ueWtSSVDxcX8XPLmk7lw0Unfm6nplP5cPE8rHz4nq1YdRM1TuKfm/9qUb/7h0Yj+ofl9t0/NCbxfFg7/2VJ4yD+uXmFbr1Fr3ETP7fK9XqLXmMQP7cKvHqL3sUvSxo/t0q5eote4yJ+blXd9Ra9RicGMYnn4ZcljYM4iYtIt0O3Q7dTbrU6J4mnsd6i9/f0uXAQJ/Fzq4Kst+g1GvFzq3Kqt+g1JvFz+56kW/WGNQ7i5/Y9/LZ6i17jJn5uVm5fljQG8XP7nmJbtYxd/LKk8XP7nm1btYw1LuLn5uX2ZUmjEz+3wGBJPA+/LPGowb4saZzEzy1qUb8saTTi55a1JF+WNObDSo2K12oDs1UHX/lw0YlBTOJ5WPlwcRC/+X7Ptq3awBo30YhODGISz8MvH/xrArVqA2ucxHKrlax8uGjEuh7XSVufLy4msdxqsyoJsg6okuDiJhrRiUFM4nlYSXBxEOmWdEu6Jd2Sbkm3pFvS7dDt0O3Q7dDt0O3Q7dDt0O3Q7Ty3avhqHMRJXMRNNKITg5hEug26DboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptum26Gd2MbkY3o5vRzehmdDO6Gd2Mbk43p5vTzenmdHO6Od2cbk43p1vQLejGLFnMksUsWcySxSxZzJLFLFnMkoUsicJBnMRF3EQjOjGISfzcvq+VrNrLGgex3LJwETfRiE4MYhJP40aWAAdxEhdxEz+37wtFq/6zxiB+bnU/Wf1nFytLLv65Rd1PVqfZ/bHKh+97Mquessbz/dvv4lM9ZY2DOImLuIn2YU39y4fGICax3GqS60ccxM9t1NS/fGjcxM+tnsPUe+0ag5jEz60eqNR77aI+H1fbWtStcL3BrtGITqxxo7DGraP4kiDq+UM1s0U9aahmtsZJXMTPbdZ0viRodGIQP7e6267OuKj76uqMi3qmUJ1xUZf86oyLutOtzrhGIzoxiEk8D7/yj/p8XJ1xjeudRsEzKnimBs/U4JlaNX/xPKyavziIk0i3pFvSLemWdMs6oFqzPA/Pj1gHVCv51XzjIm6iEZ0YxCSexmqzaxzESSy3LNxEIzoxiEn83PZ3xNVm1ziIk/i5fR3lVu+qazTi51aPIqolL+rTTLXkNZbbVwHVktdYbjWdyoeLi7iJRnRiEJN4HlY+XKTbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26ab0c3oZnQzuhndjG5GN6Ob0c3o5nRzujndnG5ON6eb060C5GsZs2r1azwPK0Aujr4kVatf4yJuohGdGMQkvqteNfVFfYCu98/hqlfvn4uvFc3q/XONSTwPKx8uDuIkfuNaldPh+p53xNVN2DiIk/itbz2Mq27CRiM68e1mdRM2vt308SMO4iQu4n5zQM0DnRjEfHOomgdWzV+kG2veWfPOmnfWvLPmnTXv8507PrmSiyu5uJJV85jD4kouriRr3lnzzpp31ryz5p0176x539w31DyQK7m5kpv7VjV/kSvJmnfWvLPmnTXvrHlnzTtr3lnzbtw340oaV9K5ks6V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",
      "is_unconstrained": true,
      "name": "get_config"
    },
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "14067204867181196045": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "9921926525851912681": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 128
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "utility"
      ],
      "debug_symbols": "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bdCNWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWVI9gmOMwklcxE00ohODmMTzsLLkIt0O3Q7dKkvGLDSiE4OYxHNxViNh4yBO4iJuohGdGMQk0m3QbdBt0G3QbdBt0G3QbdBt0G3QbdJt0m3SbdJt0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0W3TbdNt023TbdNt023TbdNt023TzehmdDO6VZaMXbiJRiy3KAxiEs/DypKLgziJi7iJRqSb083p5nQLugXdgm5Bt6Bb0C3oFnQLugXdkm5Jt6Rb0i3plnRLuiXdkm5Jt0O3Q7dDt0O3Q7dDt0O3Q7dDt/Pcxu9HHMRJXMRNNKITg5hEug26DboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptum26Gd2MbkY3o5vRzejGLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLFLFnMksUsWcySxSxZzJLFLFnMksUsWcySxSxZzJLFLFnM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",
      "is_unconstrained": true,
      "name": "get_current_value"
    },
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "14067204867181196045": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "9921926525851912681": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "utility"
      ],
      "debug_symbols": "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INJt0G3QbdBt0I1ZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkllSP4BijcBIXcRON6MRDDGI+rCy5SLekW9KtsmTMQiM68RCDmBdnNRI2DuIkLuImGtGJhxhEug26DboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptum26Gd2Mbka3ypKxCzfRiOV2Cg8xiPmwsuTiIE7iIm6iEenmdHO6Od0O3Q7dDt0O3Q7dDt0O3Q7dDt0O3YJuQbegW9At6BZ0C7oF3YJuQbekW9It6ZZ0S7ol3ZJuSbekWz638fsRB3ESF3ETjejEQwwi3QbdBt0G3QbdBt0G3QbdBt0G3QbdJt0m3SbdJt0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0W3TbdNt023TbdNt023TbdNt023TbdjG5GN6Ob0c3oZnRjlgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslilixmyWKWLGbJYpYsZslilixmyWKWLGbJYpYsZslilixm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wSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksQd/r9zd9F/pegZUlFz+3vQoncRE30YhOPMQg5sPKkot0c7ohS07hJhrRiYcYxHyILAEO4iTS7dDt0O3Q7dDt0O3QLegWdAu6Bd2CbkG3oFvQLegWdEu6Jd2Sbkm3pFvSLemWdEu65XND3+vFQZzERdxEIzrxEINIt0G3QbdBt0G3QbdBt8oSm4WHGMTPzb5LDn2vFwexrslduIibaEQnHmIQ82FlycVBpNui26Lbotui26Lbotui26bbptum26bbptum26bbptum26ab0c3oZnQzuhndjG5GN6Ob0c3o5nRzujndnG5ON6eb083p5nRzuh26Hboduh26Hboduh26Hboduh26Bd2CbkG3oFvQLegWdAu6Bd2Cbkm3pFvSLemWdEu6Jd2Sbkm3fG7oe704iJO4iJtoRCceYhDpNug26DbohiwZhZtoRCceYhDzIe5LgIM4iXSbdJt0m3SbdJt0m3RbdFt0W3RbdFt0W3RbdFt0W3RbdNt023TbdNt023TbdNt023TbdNt0M7oZ3YxuRjejm9HN6GZ0M7oZ3ZxuTjenm9PN6eZ0c7o53ZxuTrdDt0O3Q7dDt0O3Q7dDt0O3Q7dDt6Bb0C3oFnQLugXdgm5Bt6Bb0C3plnRLuiXdkm5Jt6Rb0i3pls8Nfa8XB3ESF/Fzsyg0ohM/N8e/DWI+rCzxVTiIk7iIm2hEJx5iEPPhpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26ab0c3oZnQzuhndjG5GN6Ob0c3o5nRzujndnG5ON6eb083p5nRzuh26Hboduh26Hboduh26Hboduh26Bd2CbkG3oFvQLegWdAu6Bd2Cbkm3pFvSLemWdEu6Jd2Sbkm3fG7oe704iJO4iJto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",
      "is_unconstrained": true,
      "name": "get_owner"
    },
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14067204867181196045": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "9921926525851912681": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [
          {
            "name": "chain_id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 16
            },
            "visibility": "private"
          },
          {
            "name": "emitter_address",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "boolean"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "utility"
      ],
      "debug_symbols": "TJ3LkvW6bqTf5Yx7sAgSAOlX6UFHXx2OcNgRfRn55buEJJg58f7S5y8mRQq5tCSU6j/+8T/+53/7f//8X/7l3/7Xv/+ff/zTf/6Pf/y3//0v//qv//LP/+Vf//2//9f/+y///m9//9//+Mfv+z8n/vFP8z/94+Q//in+/rP/8U/77z+n/jN+v/vfcf9r97/z/nfd//r9b9z/5v3vvv+944073rjjjTveuOONO96444073rjjjTveuOPZHc/ueHbHszue3fHsjmd3PLvj2R3P7njzjjfvePOON+94844373jzjjfvePOON+9464637njrjrfueOuOt+5464637njrjrfueH7H8zue3/H8jud3PL/j+R3P73h+x/M7Xtzx4o4Xd7y448UdL+54cceLO17c8eKOl3e8vOPlHS/veHnHy7/xxu+DaMiG3fA35vg7M8f+NYwGa/gbd8QHfwPb91PbG6IhG3bDuXD+Rrb1wWiwhtnwjewfeEM0fHP+DuerGsAB2Fc4c3wwGqxhNqwGb4iGbNgN58LokUePPHrkr4rm/GA1eEM0ZMNuOBe+YgKMBmvoka1Hth7ZemTrka1Hth559sizR5498uyRZ488e+TZI88eefbIX33Nvy2wr8AAo8EaZsNq8IZoyIbd0CN7j+w9svfI3iN7j+w9svfI3iN7j+w9cvTI0SNHjxw9cvTI0SNHjxw9cvTI0SNnj5w9cvbI2SNnj5w9cvbI2SNnj5w98u6Rd4+8e+TdI+8eeffIu0fePfLukXePfHrk0yOfHvn0yKdHPj3y6ZFPj3x65HNHnr9fw2iwhtmwGr6R9wfRkA274VyoGiwYDdYwG1ZDjzx65NEjfzW4xgfnwleDgL+RV3xgDbNhNXhDNGTDbjgXvhoE9MizR5498ryJNKc3REM27IabSHP9GkaDNcyGHnn1yKtH/mpwnQ92w7nw1SBgNFjDbFgN3hANPbL3yN4jR4/81aD/PrCG2bAavCEasmE3nAtfDQJ65OyRs0f+atDzA2+IhmzYDefCV4OA0WANs6FH3j3y7pF3j7x75N0jnx759MinRz498umRT498euTTI58e+dyR1+/XMBqsYTasBm+IhmzYDT3y6JFHjzx65NEjjx559MijRx498uiRR49sPbL1yNYjW49sPbL1yNYjW49sPbL1yLNHnj3y7JFnjzx75Nkjzx559sizR5498uqRV4+8euTVI68eefXIq0dePfLqkVeP7D2y98jeI3uP7D2y98jeI3uP7D2y98jRI0ePHD1y9MjRI0ePHD1y9MjRI0ePnD1y9sjZI2eP3DW4ugZX1+DqGlxdg6trcHUNrq7B1TW4ugZX1+DqGlxdg6trcHUNrq7B1TW4ugZX1+DqGlxdg6trcHUNrq7B1TW4uga9a9C7Br1r0LsGvWvQuwa9a9C7Br1r0LsGvWvQuwa9a9C7Br1r0LsGvWvQuwa9a9C7Br1r0LsGvWvQuwa9a9C7Br1r0LsGvWvQuwa9a9C7Br1r0LsGvWvQuwa9a9C7Br1r0LsGvWvQuwa9a9C7Br1r0LsGvWvQuwa9a9C7Br1r0LsGvWvQuwa9a9C7Br1r0LsGvWvQuwa9a9C7Br1r0LsGvWvQuwa9a9C7Br1r0LsGvWvQuwa9a9C7Br1r0LsGvWvQuwa9a9C7Br1r0LsGvWvQuwa9a9C7Br1r0LsGvWvQuwa9a9C7Br1r0LsGvWvQuwa9a9C7Br1r0LsGo2swugajazC6BqNrMLoGo2swugajazC6BqNrMLoGo2swugajazC6BqNrMLoGo2swugajazC6BqNrMLoGo2swugajazC6BqNrMLoGo2swugajazC6BqNrMLoGo2swugajazC6BqNrMLoGo2swugajazC6BqNrMLoGo2swugajazC6BqNrMLoGo2swugajazC6BqNrMLoGo2swugajazC6BqNrMLoGo2swugajazC6BqNrMLoGo2swugajazC6BqNrMLoGo2swugajazC6BqNrMLoGo2swugajazC6BqNrMLoGo2swugajazC6BqNrMLoGo2swugajazC6BrNrMLsGs2swuwazazC7BrNrMLsGs2swuwazazC7BrNrMLsGs2swuwazazC7BrNrMLsGs2swuwazazC7BrNrMLsGs2swuwazazC7BrNrMLsGs2swuwazazC7BrNrMLsGs2swuwazazC7BrNrMLsGs2swuwazazC7BrNrMLsGs2swuwazazC7BrNrMLsGs2swuwazazC7BrNrMLsGs2swuwazazC7BrNrMLsGs2swuwazazC7BrNrMLsGs2swuwazazC7BrNrMLsGs2swuwazazC7BrNrMLsGs2swuwazazC7BrNrMLsGs2swuwazazC7BrNrMLsGs2swuwZ31+DuGtxdg7trcHcN7q7B3TW4uwZ31+DuGtxdg7trcHcN7q7B3TW4uwZ31+DuGtxdg7trcHcN7q7B3TW4uwZ31+DuGtxdg7trcHcN7q7B3TW4uwZ31+DuGtxdg7trcHcN7q7B3TW4uwZ31+DuGtxdg7trcHcN7q7B3TW4uwZ31+DuGtxdg7trcHcN7q7B3TW4uwZ31+DuGtxdg7trcHcN7q7B3TW4uwZ31+DuGtxdg7trcHcN7q7B3TW4uwZ31+DuGtxdg7trcHcN7q7B3TW4uwZ31+DuGtxdg7trcHcN7q7B3TW4uwZ31+D+ajD+7hHtrwYBo+Fv5FgfzIbV4A3RkA274QDOV4OA0WANs2E1eEM0ZMNu6JFHjzx65NEjjx559MijRx498uiRR488emTrka1Hth7ZemTrka1Hth7ZemTrka1Hnj3y7JFnjzx75Nkjzx559sizR5498uyRV4+8euTVI68eefXIq0dePfLqkVePvHpk75G9R/Ye2Xtk75G9R/Ye2Xtk75G9R44eOXrk6JGjR44eOXrk6JGjR44eOXrk7JGzR84eOXvk7JGzR84eOXvk7JGzR9498u6Rd4+8e+TdI+8eeffIu0fePfLukU+PfHrkrsHTNXi6Bk/X4OkaPF2Dp2vwdA3+PVj/PRqP7NF8tB75o3iUj/aj5zGex3ge43mM5zGex3ge43mM5zGex3ge9jzsedjzsOdhz8Oehz0Pex72POx5zOcxn8d8HvN5zOcxn8d8HvN5zOcxn8d6Hut5rOexnsd6Hut5rOexnsd6Hut5+PPw5+HPw5+HPw9/Hv48/Hn48/DnEc8jnkc8j3ge8TziecTziOcRzyOeRz6PfB75PPJ55PPI55HPI59HPo98Hvt57Oexn8d+Hvt57Oexn8d+Hvt57Odxnsd5Hud5nOdxnsd5Hud5nOdxnser8/HqfLw6H6/Ox6vz8ep8vDofr87Hq/Px6ny8Oh+vzser8/HqfLw6H6/Ox6vz8ep8vDofr87Hq/Px6ny8Oh+vzser8/HqfLw6H6/Ox6vz8ep8vDofr87Hq/Px6ny8Oh+vzser8/HqfLw6H6/Ox6vz8ep8vDofr87Hq/Px6ny8Oh+vzser8/HqfLw6H6/Ox6vz8ep8vDofr87Hq/Px6ny8Oh+vzser8/HqfLw6H6/Ox6vz8ep8vDofr87Hq/Px6ny8Oh+vzser8/HqfLw6H6/Ox6vz8ep8vDofr87Hq/Px6ny8Oh+vzser8/HqfLw6H6/Ox6vz8ep8vDofr87Hq/Px6ny8Oh+vzser8/HqfLw6H6/Ox6tze3Vur87t1bm9OrdX5/bq3F6d26tze3Vur87t1bm9OrdX5/bq3F6d26tze3Vur87t1bm9OrdX5/bq3F6d26tze3Vur87t1bm9OrdX5/bq3F6d26tze3Vur87t1bm9OrdX5/bq3F6d26tze3Vur87t1bm9OrdX5/bq3F6d26tze3Vur87t1bm9OrdX5/bq3F6d26tze3Vur87t1bm9OrdX5/bq3F6d26tze3Vur87t1bm9OrdX5/bq3F6d26tze3Vur87t1bm9OrdX5/bq3F6d26tze3Vur87t1bm9OrdX5/bq3F6d26tze3Vur87t1bm9OrdX5/bq3F6d26tze3Vur87t1bm9Op+vzuer8/nqfL46n6/O56vz+ep8vjqfr87nq/P56ny+Op+vzuer8/nqfL46n6/O56vz+ep8vjqfr87nq/P56ny+Op+vzuer8/nqfL46n6/O56vz+ep8vjqfr87nq/P56ny+Op+vzuer8/nqfL46n6/O56vz+ep8vjqfr87nq/P56ny+Op+vzuer8/nqfL46n6/O56vz+ep8vjqfr87nq/P56ny+Op+vzuer8/nqfL46n6/O56vz+ep8vjqfr87nq/P56ny+Op+vzuer8/nqfL46n6/O56vz+ep8vjqfr87nq/P56ny+Op+vzuer8/nqfL46n6/O56vz+ep8vjqfr87nq/P56ny+Op+vzuer8/nqfL46X6/O16vz9ep8vTpfr86reynQ9B2P8tGfR/6KTtNX55fGI3s0H61H/ige5aPnMZ6HPQ97HvY87HnY87DnYc/Dnoc9D3se83nM5zGfx3we83nM5zGfx3we83nM57Gex3oe63ms57Gex3oe63ms57Gex3oe/jz8efjz8Ofhz8Ofhz8Pfx7+PPx5xPOI5xHPI55HPI94HvE84nnE84jnkc8jn0c+j3we+TzyeeTzyOeRzyOfx34e+3ns57Gfx34e+3ns57Gfx34e+3mc53Gex3ke53mc53Gex3ke53mc53Hao5qjLo1H9mg+Wo/8UTzKR/vR83h17q/O/dV5dUqlFa1H/ige5aP96DRVnYPGI3v0POx52POw52HP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ZslklkxmyWSWTGbJZJZMZslkllQn5vheaWrVinmxsuTiIBpxEhfRiUFMIt023Q7dKktsFBpxEhfRiUFM4iaexurPbBxEI07iIjoxiEncRLoNug26DboNug26DboNug26DboNuhndjG5GN6Ob0c3oZnQzuhndjG6TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26LbotuTjenm9PN6eZ0c7o53ZxuTjenW9At6BZ0C7oF3YJulSU2C5O4ieUWH1aWXBxEI07iIjoxiEncRLptum26bbptum26bbptum26bbptuh26Hboduh26Hboduh26Hbodup3n5r8fcRCNOImL6MQgJnET6TboNug26DboNug26DboNug26DboZnQzuhndjG5GN6Ob0c3oZnQzuk26TbpNuk26TbpNuk26TbpNuk26Lbotui26Lbotui26Lbotui26Lbo53ZxuTjenm9PN6eZ0c7o53ZxuQbegW9At6BZ0C7oF3YJuQTdmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmCfpe7RRO4iI6MYhJ3MTzEFkCHES6Jd2SbpUl9YdC0Pd6MYmbeB7iD80AB9GIk7iIdNt023TbdNt0O3Q7dDt0O3SrLJlW6MQgJnETTyP6Xi8OohEncRGdGMQkbiLdBt0G3QbdBt0G3QbdBt0G3QbdBt2MbkY3o5vRzehmdDO6Gd2Mbka3SbdJt0m3SbdJt0m3SbdJt0m3SbdFt0W3RbdFt0W3RbdFt0W3RbdFN6eb083p5nRzujndnG5ON6eb0y3oFnQLugXdgm5Bt6Bb0C3oFnRLuiXdkm5Jt6Rb0i3plnRLuiXdNt023TbdNt023TbdNt023TbdNt0O3Q7dDt0O3Zglm1mymSWbWbKZJZtZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZgr7XuQoncRGdGMQkbuJ5iCwBDiLdNt023TbdNt023TbdNt0O3Q7dDt0O3Q7dDt0O3Q7dDt1Ou030vV4cRCNO4iI6MYhJ3ES6DboNug26DboNug26DboNug26DboZ3YxuRjejm9HN6GZ0M7oZ3Yxuk26TbpNuyJIoXEQnltsuTOImnofIEuAgGnESF9GJdFt0W3RbdHO6Od2cbk43p5vTzenmdHO6Od2CbkG3oFvQLegWdAu6Bd2CbkG3pFvSLemWdEu6Jd2Sbkm3pFvSbdNt023TbdNt023TbdNt023TbdPt0O3Q7dDt0O3Q7dDt0O3Q7dDtPDf0vV4cRCNO4iI6MYhJ3ES6DboNug26DboNug26DboNug26DboZ3YxuRjejm9HN6GZ0M7oZ3Yxuk26TbpNuk26TbpNuzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMksksmcySySyZzJLJLEHfa/0xYPS9Xkzi57Zm4XlYWXJxEI04iYvoxCAmkW6DbsiSLBxEI07iIjoxiEncxPNw0m3SbdJt0m3SbdJt0m3SbdJt0m3RbdFt0W3RbdFt0W3RbdFt0W3RzenmdHO6Od2cbk43p5vTzenmdAu6Bd2CbkG3oFvQLegWdAu6Bd2Sbkm3pFtliVvhIjrxc/M65SpLLm5inZPfF130vV4cRCNO4iI6MYhJ3ES6Hboduh26Hboduh26Hboduh26neeGvteLg2jESVxEJwYxiZtIt0G3QbdBt0G3QbdBt0G3QbdBt0E3o5vRzehmdDO6Gd2MbkY3o5vRbdJt0m3SbdJt0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0c3p5nRzujndnG5ON6eb083p5nQLugXdgm5Bt6Bb0C3oFnQLugXdkCX4y/GDaMRJXEQnBjGJm3gebrptum26bbptum26bbptum26bboduh26Hboduh26Hboduh26Hbqd54a+14uDaMRJXEQnBjGJm0i3QbdBt0G3QbdBt0G3QbdBt0G3QTejm9HN6GZ0M7oZ3YxuRjejm9Ft0m3SbdJt0m3SbdJt0m3SbdJt0m3RbdFt0W3RbdFt0W3RbdFt0W3RzenmdHO6Od2cbk43p5vTzenmdAu6VZb4LjTiJH5ugX/rxCB+bjELN/E8rCy5OIhGnMRFdGIQ6ZZ0S7ptum26bbptum26bbptum26bbptuh26Hboduh26Hboduh26Hbodup3nhr7Xi4NoxElcRCcGMYmbSLdBt0G3QbdBt0G3QbdBt0G3QbdBN6Ob0c3oZnQzuhndjG5GN6Ob0W3SbdJt0m3SbdJt0m3SbdJt0m3SbdFt0W3RbdFt0W3RbdFt0W3RbdHN6eZ0c7o53ZxuTjenm9PN6eZ0C7oF3YJuQbegW9At6MYsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWoO/1+2shE32vFwfRiJO4iE4MYhI3kW6bbptum26VJRmFi+jEcrPCJG7ieYgsAQ6iESdxEZ1It0O3Q7fz3ND3enEQjTiJi+jEICZxE+k26DboNug26DboNug26DboNug26GZ0M7oZ3YxuRjejm9HN6GZ0M7pNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui26Od2cbk43p5vTzenmdHO6Od2cbkG3oFvQLegWdAu6Bd2CbkG3oFvSLemWdEu6Jd2Sbkm3pFvSLem26bbptum26bbptunGLNnMks0s2cySzSzZzJLNLNnMks0s2cySzSzZzJLNLNnMksMsOcySwyw5zJLDLDnMksMsQd/rnoWbeB5WlnwvdJ/oe71oxM9tn8JFdOLndn6FSdzE87Cy5OIgGnESF9GJdDO6Gd2MbpUlJwoH0Yh/bn+P2AsX0YnxYa3DlyWNm/jnZt+rEmf1vTYOon1Ye/FlSeMifm6jpvNlSWMSN/E89B9xEI04iYtIN6eb083p5nQLugXdgm5Bt6Bb0C3oFnQLugXdkm5Jt6Rb0i3plnRLuiXdkm5Jt023TbdNt023TbdNt023TbdNt023Q7dDt0O3Q7dDt0O3Q7dDt0O3026r+l4bB9GIk7iITgxiEjeRboNug26DboNug26DboNug26DboNuRjejm9HN6GZ0M7oZ3YxuRjej26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26LbopvTzenmdHO6Od2cbk43p5vTzekWdAu6Bd2CbkG3oFvQLegWdAu6Jd2Sbkm3pFvSLemWdEu6Jd2Sbptum26bbptum26b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",
      "is_unconstrained": true,
      "name": "is_emitter_registered"
    },
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "14067204867181196045": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "9921926525851912681": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [
          {
            "name": "message_ciphertext",
            "type": {
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 17,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec"
            },
            "visibility": "private"
          },
          {
            "name": "message_context",
            "type": {
              "fields": [
                {
                  "name": "tx_hash",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "unique_note_hashes_in_tx",
                  "type": {
                    "fields": [
                      {
                        "name": "storage",
                        "type": {
                          "kind": "array",
                          "length": 64,
                          "type": {
                            "kind": "field"
                          }
                        }
                      },
                      {
                        "name": "len",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "std::collections::bounded_vec::BoundedVec"
                  }
                },
                {
                  "name": "first_nullifier_in_tx",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "recipient",
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::messages::processing::message_context::MessageContext"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "utility"
      ],
      "debug_symbols": "TJ3LsjS7bpzf5Yw9aIIEQOpVPHD4qlCEQorwZaSX9yokwcyJ95fW+ZmoYiG7uhrd6z/+8T/+53/7f//8X/7l3/7Xv/+ff/zTf/6Pf/y3//0v//qv//LP/+Vf//2//9f/+y///m9//7//8Y/f9//sv/93/qd/7PGPf4q//9g//mn9/WfiPwv/8X/80/77T+A/if9s/OfUf84P/xn4j+E/E/9Z+A9WOVjlYJWDVQ5WGb/f/e+4/7X733n/u+5//f437n/z/nff/971xl1v3PXGXW/c9cZdb9z1xl1v3PXGXW/c9eyuZ3c9u+vZXc/uenbXs7ue3fXsrmd3vXnXm3e9edebd71515t3vXnXm3e9edebd71111t3vXXXW3e9dddbd71111t3vXXXW3c9v+v5Xc/ven7X87ue3/X8rud3Pb/r+V0v7npx14u/9cbvg9mwGrzhb80xP8iG3XAu5N+6Iz74W9i+f5XWMBtWgzdEw9/Ktj7YDefC1x6Ab2X/wBpmw1fzdzhfowCi4W/lOT7YDefC1zKA0WANs2E1eEM09MqnVz53Zfu6aM4PRoM1zIbV4A3RkA274VwYvfLolUevPHrl0SuPXnn0yqNXHr3y6JWtV7Ze2Xpl65WtV7Ze+euv6R9kw244F74eA4wGa5gNq8EbeuXZK89eefbKq1devfLqlVevvHrl1SuvXnn1yqtXXr2y98reK3uv7L2y98reK3uv7L2y98reK0evHL1y9MrRK0evHL1y9MrRK0evHL1y9srZK2evnL1y9srZK2evnL1y9srZK+9eeffKu1fevfLulXevvHvl3SvvXnn3yqdXPr1y9eD+YDasBm+IhmzYDQcwqwcLRoM1zIbV8LfyGh9EQzb8rbzig3Ph60HAaLCG2bAavCEasqFXHr2y9cp2E2maNcyG1eAN0ZANu+Em0py/hl559sqzV/56cJ0PvCEasmE3nAtfDwJGgzXMhl559cqrV1698teD/vvgXPh6EDAarGE2rAZviIZs6JW9V45e+etBzw+sYTasBm+IhmzYDefC14OAXjl75eyVs1fOXjl75eyVs1fOXnn3yrtX3r3y7pV3r7x75d0r715598q7Vz698umVT698euXTK59e+fTKp1c+vfK5K6/fr2E0WMNsWA3eEA3ZsBt65dErj1559MqjVx698uiVR688euXRK49e2Xpl65WtV7Ze2Xpl65WtV7Ze2Xpl65Vnrzx75dkrz1559sqzV5698uyVZ688e+XVK69eefXKq1devfLqlVevvHrl1SuvXtl7Ze+VvVf2Xtl7Ze+VvVf2Xtl7Ze+Vo1fuHlzdg6t7cHUPru7B1T24ugdX9+DqHlzdg6t7cHUPru7B1T24ugdX9+DqHlzdg6t7cHUPru7B1T24ugdX9+DqHlzdg6t7cHUPru7B1T24ugdX9+DqHlzdg6t7cHUPru7B1T24uge9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwez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qmEjr3dUNWzk9Taqho0ag/itUG8qatio8TysPr44iLVuHVD1Zr3zqQEir3dUNUB0sXrz4iAacRIX0YlBLLc64urNi+dh9Wa93akBokYjTuLnVu9maoCoMYifW72FqQGixvOw+rje7tQAUaMRJ3ERnVhudVKrjy9uYrnVqa4+vjiIRnRirVDbEudhdWy9YaqhoEYjfvV6nZ3q44tODGISN/E8rD6+OIhGpNum26bbptum26bbptuh26Hboduh26Hboduh26HboVv18fd20msoqHEQy20WTuIilpsXBrHcduEmnofV3RcHsdxO4SR+bt/7Qq+hII+qrHr+e2PjNRTUuImfW6wPq+cvDuLn9t3bew0FNS6iE4OYDysJvsfOXoM+HnUU1fNRpVfPXwxiEr96sw6oeh5YPX9xEI34uWUdZvV81lmvns8qp3o+y6J6HljdvetMVh/vWqw6dtdi1bEXN/GrbNd2V8deHEQjTuIiOrHc6vTVK+/F/bBaGpVVS180YlnUqa6WvujEz+Lgf5vETfwO6FQ51dIXP7dTR1wtfXESP7dT10619MUgJnETz8Nq6YuDaMRJpNuh26Hboduh23luNZvTOIhGnMRFdGIQk1huXngeVktfLLcsNOIkltsudGIQk1hup/DPLb43Cl6zOfG9O/CazWk04vxwFi6iE4OYxE08D+ePOIhGpNuk26TbLLdRmMRNPA/XjziIRpzEcquzvpwYxHKLwk08D/1HLLfaITfiJAaxVqht+UIhRm3LFwqNRpzEb4VRO/S9jMeos5M/4iAacRIX8TviUYeZQUziJp6H+0ccRCOWW53fvYhODGK51enbm1hudf2eH3EQPzerU/L1fOMiOjGI2VjTMvHdunvNxcT3YYjXXEx89+teczGNQUziV+93F+81F3Nx/IiDaMTPbVYNXx83OjGISdzEz+278fb6PbjGQTRiuZVx9fFFJ5ZbFn5uqyyqjy9+bqtOVPXxxc9t1TmrPr44iYvoxCAmcRPPw+rji3RbdFt0W3RbdFt0W3RbdFt0c7o53ZxuTjenm9PN6eZ0c7o53YJuQbegW9At6BZ0C7oF3YJuQbekW9It6Vb5sOqqrny46MQglltdO5UPF8/DyoeLg2jESVxEJwaRbptum26Hboduh26Hboduh26n1v1ypwaa/j65KDRirbALF9GJQUziJp6HlQTf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",
      "is_unconstrained": true,
      "name": "process_message"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14415304921900233953": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15546539856497705002": {
            "error_kind": "string",
            "string": "u16 to u8 conversion failed"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16810041750452690220": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 27
          },
          "17398389091582795409": {
            "error_kind": "string",
            "string": "Function _update_value can only be called internally"
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "6788092787179896647": {
            "error_kind": "string",
            "string": "Caller is not owner"
          },
          "8228371833434187583": {
            "error_kind": "string",
            "string": "Trying to read from uninitialized PublicImmutable"
          },
          "9967937311635654895": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          }
        },
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "public"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "public_dispatch"
    },
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14067204867181196045": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15711892660910782274": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16216212843441549037": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "18173155084464344029": {
            "error_kind": "string",
            "string": "Emitter not registered"
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "2014890719615096298": {
            "error_kind": "string",
            "string": "Field failed to decompose into specified 40 limbs"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "3378875131383195299": {
            "error_kind": "string",
            "string": "Invalid destination chain ID"
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "4648451262681811962": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "7555607922535724711": {
            "error_kind": "string",
            "string": "Preimage mismatch"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9589626482238399944": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "9921926525851912681": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "anchor_block_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "sponge_blob_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "vaa",
            "type": {
              "kind": "array",
              "length": 2000,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "length",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "note_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 32,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "log",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "fields",
                                          "type": {
                                            "kind": "array",
                                            "length": 18,
                                            "type": {
                                              "kind": "field"
                                            }
                                          }
                                        },
                                        {
                                          "name": "length",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::log::Log"
                                    }
                                  },
                                  {
                                    "name": "note_hash_counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "anchor_block_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "sponge_blob_hash",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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Q+hyCl0uocstdHmELq/Q5RO6/EJXQOgKCl0hoSssdEWErqjQFRO64kJXQuhKCl0poSstdGWErqzQlRO68kJXQegqCl0loassdFWErqrQVRO66kJXQ+hqCl0toastdHWErq7Q1RO6+kLXQOgaCl0joWssdE2ErqnQNRO65kLXQuhaCl0roWstdG2Erq3QtRO69kLXQeg6Cl0noessdF2ErqvQdRO67kLXQ+h6Cl0voestdH2Erq/Q9RO6/kI3QOgGCt0goRssdEOEbqjQDRO64UI3QuhGCt0ooRstdGOEbqzQjRO68UI3QegmCt0koZssdFOEbqrQTRO66UI3Q+hmCt0soZstdHOEbq7QzRO6+UK3QOgWCt0ioVssdEuEbqnQLRO65UK3QuhWCt0qoVstdGuEbq3QrRO69UK3Qeg2Ct0modssdFuEbqvQbRO67UK3Q+h2Ct0uodstdHuEbq/Q7RO6/UJ3QOgOCt0hoTssdEeE7qjQHRO640J3QuhOCt0poTstdGeE7qzQnRO680J3QeguCt0lobssdFeE7qrQXRO660J3Q+huCt0tobstdHeE7q7Q3RO6+0L3QOgeCt0joXssdE+E7qnQPRO650L3QuheCt0roXstdG+E7q3QvRO690L3Qeg+Ct0nofssdF+E7qvQfRO670L3Q+j8BPx/Oy+h8yt0/oTOv9AFELqAQhdI6AILXRChCyp0wYQuuNCFELqQQhdK6EILXRihCyt04YQuvNBFELqIQhdJ6CILXRShiyp00YQuutB5C52P0MUQuphCF0voYgtdHKGLK3TxhC6+0CUQuoRCl0joEgtdEqFLKnTJhC650KUQupRCl0roUgtdGqFLK3TphC690GUQuoxCl0noMgtdFqHLKnTZhC670OUQupxCl0vocgtdHqHLK3T5hC6/0BUQuoJCV0joCgtdEaErKnTFhK640JUQupJCV0roSgtdGaErK3TlhK680FUQuopCV0noKgtdFaGrKnTVhK660NUQuppCV0voagtdHaGrK3T1hK6+0DUQuoZC10joGgtdE6FrKnTNhK650LUQupZC10roWgtdG6FrK3TthK690HUQuo5C10noOgtdF6HrKnTdhK670PUQup5C10voegtdH6HrK3T9hK6/0A0QuoFCN0joBgvdEKEbKnTDhG640I0QupFCN0roRgvdGKEbK3TjhG680E0QuolCN0noJgvdFKGbKnTThG660M0QuplCN0voZgvdHKGbK3TzhG6+0C0QuoVCt0joFgvdEqFbKnTLhG650K0QupVCt0roVgvdGqFbK3TrhG690G0Quo1Ct0noNgvdFqHbKnTbhG670O0Qup1Ct0vodgvdHqHbK3T7hG6/0B0QuoNCd0joDgvdEaE7KnTHhO640J0QupNCd0roTgvdGaE7K3TnhO680F0QuotCd0noLgvdFaG7KnTXhO660N0QuptCd0vobgvdHaG7K3T3hO6+0D0QuodC90joHgvdE6F7KnTPhO650L0QupdC90roXgvdG6F7K3TvhO690H0Quo9C90noPgvdF6H7KnTfhO670P0QOj+B/t/OS+j8Cp0/ofMvdAGELqDQBRK6wEIXROiCCl0woQsudCGELqTQhRK60EIXRujCCl04oQsvdBGELqLQRRK6yEIXReiiCl00oYsudN5C5yN0MYQuptDFErrYQhdH6OIKXTyhiy90CYQuodAlErrEQpdE6JIKXTKhSy50KYQupdClErrUQpdG6NIKXTqhSy90GYQuo9BlErrMQpdF6LIKXTahyy50OYQup9DlErrcQpdH6PIKXT6hyy90BYSuoNAVErrCQldE6IoKXTGhKy50JYSupNCVErrSQldG6MoKXTmhKy90FYSuotBVErrKQldF6KoKXTWhqy50NYSuptDVErraQldH6OoKXT2hqy90DYSuodA1ErrGQtdE6JoKXTOhay50LYSupdC1ErrWQtdG6NoKXTuhay90HYSuo9B1ErrOQtdF6LoKXTeh6y50PYSup9D1ErreQtdH6PoKXT+h6y90A4RuoNANErrBQjdE6IYK3TChGy50I4RupNCNErrRQjdG6MYK3TihGy90E4RuotBNErrJQjdF6KYK3TShmy50M4RuptDNErrZQjdH6OYK3Tyhmy90C4RuodAtErrFQrdE6JYK3TKhWy50K4RupdCtErrVQrdG6NYK3TqhWy90G4Ruo9BtErrNQrdF6LYK3Tah2y50O4Rup9DtErrdQrdH6PYK3T6h2y90B4TuoNAdErrDQndE6I4K3TGhOy50J4TupNCdErrTQndG6M4K3TmhOy90F4TuotBdErrLQndF6K4K3TWhuy50N4TuptDdErrbQndH6O4K3T2huy90D4TuodA9ErrHQvdE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eEwheEwleEwjeEwneMwgeMwkeMwieMwmeMwheMwleMwjeMwneCwgeCwkeCwieCwmeCwheCwleCwjeCwneKwgeKwkeKwieKwmeKwheKwleKwjeKwneGwgeGwkeGwieGwmeGwheGwleGwjeGwneOwgeOwkeOwieOwmeOwheOwleOwjeOwneBwgeBwkeBwieBwmeBwheBwleBwjeBwneJwgeJwkeJwieJwmeJwheJwleJwjeJwneFwgeFwkeFwieFwmeFwheFwleFwjeFwneNwgeNwkeNwieNwmeNwheNwleNwjeNwneDwgeDwkeDwieDwmeDwheDwleDwjeDwneLwgeLwkeLwieLwmeLwheLwleLwjeLwneHwgeHwkeHwieHwmeHwheHwleHwjeHwnePwgePwkePwieDgCet7Di+ARgOARkOARiOARmOARhOARlOARjOARnOARguARkuARiuARmuARhuARluARjuARnuARgeARkeARieARmeARheARleARjeARneARg+ARk+ARi+ARm+ARh+ARl+DhJHjEI3jEJ3gkIHgkJHgkIngkJngkIXgkJXgkI3gkJ3ikIHikJHikInikJnikIXikJXikI3h4Ezx8CB7pCR4ZCB4ZCR6ZCB6ZCR5ZCB5ZCR7ZCB7ZCR45CB45CR65CB65CR55CB55CR75CB75CR4FCB4FCR6FCB6FCR5FCB5FCR7FCB7FCR4lCB4lCR6lCB6lCR5lCB5lCR7lCB7lCR4VCB4VCR6VCB6VCR5VCB5VCR7VCB7VCR41CB41CR61CB61CR51CB51CR71CB71CR4NCB4NCR6NCB6NCR5NCB5NCR7NCB7NCR4tCB4tCR6tCB6tCR5tCB5tCR7tCB7tCR4dCB4dCR6dCB6dCR5dCB5dCR7dCB7dCR49CB49CR69CB69CR59CB59CR79CB79CR4DCB4DCR6DCB6DCR5DCB5DCR7DCB7DCR4jCB4jCR6jCB6jCR5jCB5jCR7jCB7jCR4TCB4TCR6TCB6TCR5TCB5TCR7TCB7TCR4zCB4zCR6zCB6zCR5zCB5zCR7zCB7zCR4LCB4LCR6LCB6LCR5LCB5LCR7LCB7LCR4rCB4rCR6rCB6rCR5rCB5rCR7rCB7rCR4bCB4bCR6bCB6bCR5bCB5bCR7bCB7bCR47CB47CR67CB67CR57CB57CR77CB77CR4HCB4HCR6HCB6HCR5HCB5HCR7HCB7HCR4nCB4nCR6nCB6nCR5nCB5nCR7nCB7nCR4XCB4XCR6XCB6XCR5XCB5XCR7XCB7XCR43CB43CR63CB63CR53CB53CR73CB73CR4PCB4PCR6PCB6PCR5PCB5PCR7PCB7PCR4vCB4vCR6vCB6vCR5vCB5vCR7vCB7vCR4fCB4fCR6fCB6fCR5fCB5fCR7fCB7fCR4/CB4/CR6/CB6OQJ738CJ4BCB4BCR4BCJ4BCZ4BCF4BCV4BCN4BCd4hCB4hCR4hCJ4hCZ4hCF4hCV4hCN4hCd4RCB4RCR4RCJ4RCZ4RCF4RCV4RCN4RCd4xCB4xCR4xCJ4xCZ4xCF4xCV4OAke8Qge8QkeCQgeCQkeiQgeiQkeSQgeSQkeyQgeyQkeKQgeKQkeqQgeqQkeaQgeaQke6Qge3gQPH4JHeoJHBoJHRoJHJoJHZoJHFoJHVoJHNoJHdoJHDoJHToJHLoJHboJHHoJHXoJHPoJHfoJHAYJHQYJHIYJHYYJHEYJHUYJHMYJHcYJHCYJHSYJHKYJHaYJHGYJHWYJHOYJHeYJHBYJHRYJHJYJHZYJHFYJHVYJHNYJHdYJHDYJHTYJHLYJHbYJHHYJHXYJHPYJHfYJHA4JHQ4JHI4JHY4JHE4JHU4JHM4JHc4JHC4JHS4JHK4JHa4JHG4JHW4JHO4JHe4JHB4JHR4JHJ4JHZ4JHF4JHV4JHN4JHd4JHD4JHT4JHL4JHb4JHH4JHX4JHP4JHf4LHAILHQILHIILHYILHEILHUILHMILHcILHCILHSILHKILHaILHGILHWILHOILHeILHBILHRILHJILHZILHFILHVILHNILHdILHDILHTILHLILHbILHHILHXILHPILHfILHAoLHQoLHIoLHYoLHEoLHUoLHMoLHcoLHCoLHSoLHKoLHaoLHGoLHWoLHOoLHeoLHBoLHRoLHJoLHZoLHFoLHVoLHNoLHdoLHDoLHToLHLoLHboLHHoLHXoLHPoLHfoLHAYLHQYLHIYLHYYLHEYLHUYLHMYLHcYLHCYLHSYLHKYLHaYLHGYLHWYLHOYLHeYLHBYLHRYLHJYLHZYLHFYLHVYLHNYLHdYLHDYLHTYLHLYLHbYLHHYLHXYLHPYLHfYLHA4LHQ4LHI4LHY4LHE4LHU4LHM4LHc4LHC4LHS4LHK4LHa4LHG4LHW4LHO4LHe4LHB4LHR4LHJ4LHZ4LHF4LHV4LHN4LHd4LHD4LHT4LHL4KHI7DnPbwIHgEIHgEJHoEIHoEJHkEIHkEJHsEIHsEJHiEIHiEJHqEIHqEJHmEIHmEJHuEIHuEJHhEIHhEJHpEIHpEJHlEIHlEJHtEIHtEJHjEIHjEJHrEIHrEJHnEIHnEJHk6CRzyCR3yCRwKCR0KCRyKCR2KCRxKCR1KCRzKCR3KCRwqCR0qCRyqCR2qCRxqCR1qCRzqChzfBw4fgkZ7gkYHgkZHgkYngkZngkYXgkZXgkY3gkZ3gkYPgkZPgkYvgkZvgkYfgkZfgkY/gkZ/gUYDgUZDgUYjgUZjgUYTgUZTgUYzgUZzgUYLgUZLgUYrgUZrgUYbgUZbgUY7gUZ7gUYHgUZHgUYngUZngUYXgUZXgUY3gUZ3gUYPgUZPgUYvgUZvgUYfgUZfgUY/gUZ/g0YDg0ZDg0Yjg0Zjg0YTg0ZTg0Yzg0Zzg0YLg0ZLg0Yrg0Zrg0Ybg0Zbg0Y7g0Z7g0YHg0ZHg0Yng0Zng0YXg0ZXg0Y3g0Z3g0YPg0ZPg0Yvg0Zvg0Yfg0Zfg0Y/g0Z/gMYDgMZDgMYjgMZjgMYTgMZTgMYzgMZzgMYLgMZLgMYrgMZrgMYbgMZbgMY7gMZ7gMYHgMZHgMYngMZngMYXgMZXgMY3gMZ3gMYPgMZPgMYvgMZvgMYfgMZfgMY/gMZ/gsYDgsZDgsYjgsZjgsYTgsZTgsYzgsZzgsYLgsZLgsYrgsZrgsYbgsZbgsY7gsZ7gsYHgsZHgsYngsZngsYXgsZXgsY3gsZ3gsYPgsZPgsYvgsZvgsYfgsZfgsY/gsZ/gcYDgcZDgcYjgcZjgcYTgcZTgcYzgcZzgcYLgcZLgcYrgcZrgcYbgcZbgcY7gcZ7gcYHgcZHgcYngcZngcYXgcZXgcY3gcZ3gcYPgcZPgcYvgcZvgcYfgcZfgcY/gcZ/g8YDg8ZDg8Yjg8Zjg8YTg8ZTg8Yzg8Zzg8YLg8ZLg8Yrg8Zrg8Ybg8Zbg8Y7g8Z7g8YHg8ZHg8Yng8Zng8YXg8ZXg8Y3g8Z3g8YPg8ZPg8Yvg4QjieQ8vgkcAgkdAgkcggkdggkcQgkdQgkcwgkdwgkcIgkdIgkcogkdogkcYgkdYgkc4gkd4gkcEgkdEgkckgkdkgkcUgkdUgkc0gkd0gkcMgkdMgkcsgkdsgkccgkdcgoeT4BGP4BGf4JGA4JGQ4JGI4JGY4JGE4JGU4JGM4JGc4JGC4JGS4JGK4JGa4JGG4JGW4JGO4OFN8PAheKQneGQgeGQkeGQieGQmeGQheGQleGQjeGQneOQgeOQkeOQieOQmeOQheOQleOQjeOQneBQgeBQkeBQieBQmeBQheBQleBQjeBQneJQgeJQkeJQieJQmeJQheJQleJQjeJQneFQgeFQkeFQieFQmeFQheFQleFQjeFQneNQgeNQkeNQieNQmeNQheNQleNQjeNQneDQgeDQkeDQieDQmeDQheDQleDQjeDQneLQgeLQkeLQieLQmeLQheLQleLQjeLQneHQgeHQkeHQieHQmeHQheHQleHQjeHQnePQgePQkePQiePQmePQhePQlePQjePQneAwgeAwkeAwieAwmeAwheAwleAwjeAwneIwgeIwkeIwieIwmeIwheIwleIwjeIwneEwgeEwkeEwieEwmeEwheEwleEwjeEwneMwgeMwkeMwieMwmeMwheMwleMwjeMwneCwgeCwkeCwieCwmeCwheCwleCwjeCwneKwgeKwkeKwieKwmeKwheKwleKwjeKwneGwgeGwkeGwieGwmeGwheGwleGwjeGwneOwgeOwkeOwieOwmeOwheOwleOwjeOwneBwgeBwkeBwieBwmeBwheBwleBwjeBwneJwgeJwkeJwieJwmeJwheJwleJwjeJwneFwgeFwkeFwieFwmeFwheFwleFwjeFwneNwgeNwkeNwieNwmeNwheNwleNwjeNwneDwgeDwkeDwieDwmeDwheDwleDwjeDwneLwgeLwkeLwieLwmeLwheLwleLwjeLwneHwgeHwkeHwieHwmeHwheHwleHwjeHwnePwgePwkePwieDiCet7Di+ARgOARkOARiOARmOARhOARlOARjOARnOARguARkuARiuARmuARhuARluARjuARnuARgeARkeARieARmeARheARleARjeARneARg+ARk+ARi+ARm+ARh+ARl+DhJHjEI3jEJ3gkIHgkJHgkIngkJngkIXgkJXgkI3gkJ3ikIHikJHikInikJnikIXikJXikI3h4Ezx8CB7pCR4ZCB4ZCR6ZCB6ZCR5ZCB5ZCR7ZCB7ZCR45CB45CR65CB65CR55CB55CR75CB75CR4FCB4FCR6F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TE88szzxzPbEc6gnnsM88RzuiecITzxHeuI5yhPP0Z545njimeuJZ54nnvmeeBZ44lnoiecYTzyLPPEc64lnsSee4zzxHO+JZ4knnhM88Sz1xLPME89yTzwneuJZ4YlnpSeeVZ54VnviOckTz8meeE7xxHOqJ57TPPGc7onnK554zvDE81VPPGd64qn1xFPniWeNJ561nnjWeeJZ74nnLE88Z3viOccTz7meeM7zxHO+J54LPPFs8MRzoSeeizzxXOyJZ6Mnnks88VzqiWeTJ57LPPFc7onnCk88V3riucoTz9WeeK7xxHOtJ57rPPFc74nnBk88mz3x3OiJ5yZPPDd74rnFE8+tnnhu88RzuyeeOzzxfM0Tz9c98XzDE883PfHc6YnnLk88d3vi+ZYnnns88Xw7IU+u797em8O+9Qc9ncZ4n6e8fyeHvN/sKe/f9WRf93vi+Z4nngc88Tzoief7nnh+4Innh554fuSJ58eeeH7iiechTzwPe+J5xBPPo554fuqJ52eeeH7uiecXnnh+6YnnV554HvPE82tPPI974vmNJ54nPPE86Ynn/zzx/NYTz1OeeH7nief3nnie9sTzjCeeP3jiedYTz3OeeJ73xPOCJ54XPfG85InnZU88r3jiedUTzx898byWw9qWvAp5nuCfPK3rvZ5D3q/3dJ7gn2Pq9Lc3up4iExby2xF/8VQfb+RQH9d5Wmd901Pe/5pL3nf2o9NbOeh0o6f6eNuTX3zHE8+7nnj+5onnPU8873vi+bsnng888XzoiecjTzwfe+L5xBPPPzzx/NMTz6eeeP7lieczTzz/9sTzH088//XEE1T64Ul54mnkiafME0/aE09jTzzlnniaeOKp8MRT6YmnqSeeZp54qjzxNPfE08ITT7UnnpaeeFp54mntiaeNJ562nnjaeeLZwRPPjp542nvi2ckTTwdPPB098XTyxLOzJ55dPPF09sRT44mniyeerp54unni6S54iuV5264J815InXbzpFMuz8F6ONIpG0/PHGzk/AF+dOqVg07nDPDTlnp7arN9PPH09cTTzxPP7p549vDEs6cnnr088fT3xDPAE89ATzyDPPEM9sSztyeeIZ549vHEs68nnqGeeIZ54tnPE8/+nniGe+IZ4YlnpCeeAzzxjPLEM9oTzxhPPGM98YzzxDPeE88ETzwHeuI5yBPPRE88kzzxTPbEM8UTz1RPPNM88RzsiWe6J55DPPHM8MQz0xPPLE88sz3xHOqJ5zBPPId74jnCE8+RnniO8sRztCeeOZ545nrimeeJZ74nngWeeBZ64jnGE88iTzzHeuJZ7InnOE88x3viWeKJ5wRPPEs98SzzxLPcE8+JnnhWeOJZ6YlnlSee1Z54TvLEc7InnlM88Zzqiec0Tzyne+L5iieeMzzxfNUTz5meeGo98dR54lnjiWetJ551nnjWe+I5yxPP2Z54zvHEc64nnvM88ZzviecCTzwbPPFc6InnIk88F3vi2eiJ5xJPPJd64tnkiecyTzyXe+K5whPPlZ54rvLEc7Unnms88Vzriec6TzzXe+K5wRPPZk88N3riuckTz82eeG7xxHOrJ57bPPHc7onnDk88X/PE83VPPN/wxPNNTzx3euK5yxPP3Z54vuWJ5x5PPN/2xHOvJ577PPF8xxPPdz3x3O+J53ueeB7wxPOgJ57ve+L5gSeeH3ri+ZEnnh974vmJJ56HPPE87InnEU88j3ri+angyeUMiVx5fuYpPz/3xPMLTzy/9MTzK088j3ni+bUnnsc98fzGE88Tnnie9MTzf554fuuJ5ylPPL/zxPN7TzxPe+J5xhPPHzzxPOuJ5zlPPM974nnBE8+Lnnhe8sTzsieeVzzxvOqJ54+eeF7zxPMnTzyve+L5syeev3jiecMTz5ueeP7qiectTzxve+J5xxPPu554/uaJ5z1PPO974vm7J54PPPF86InnI088H3vi+cQTzz888fzTE8+nnnj+5YnnM088//bE8x9PPP/1xBM09cOT8sTTyBNPmSeetCeexp54yj3xNPHEU+GJp9ITT1NPPM088VR54mnuiaeFJ55qTzwtPfG08sTT2hNPG088bT3xtPPEs4Mnnh098bT3xLOTJ54Onng6euLp5IlnZ088u3ji6eyJp8YTTxdPPF098XTzxNPdE8+unnh288TTwxNPT088vTzx9PbE08cTT19PPP088ezuiWcPTzx7euLZyxNPf088AzzxDPTEM8gTz2BPPHt74hniiWcfTzz7euIZ6olnmCee/Tzx7O+JZ7gnnhGeeEZ64jnAE88oTzyjPfGM8cQz1hPPOE884z3xTPDEc6AnnoM88Uz0xDPJE89kTzxTPPFM9cQzzRPPwZ54pnviOcQTzwxPPDM98czyxDPbE8+hnngO88RzuCeeIzzxHOmJ5yhPPEd74pnjiWeuJ555nnjme+JZ4IlnoSeeYzzxLPLEc6wnnsWeeI7zxHO8J54lnnhO8MSz1BPPMk88yz3xnOiJZ4UnnpWeeFZ54lntieckTzwne+I5xRPPqZ54TvPEc7onnq944jnDE89XPfGc6Ymn1hNPnSeeNZ541nriWeeJZ70nnrM88ZztieccTzzneuI5zxPP+Z54LvDEs8ETz4WeeC7yxHOxJ56Nnngu8cRzqSeeTZ54LvPEc7knnis88VzpiecqTzxXe+K5xhPPtZ54rvPEc70nnhs88Wz2xHOjJ56bPPHc7InnFk88t3riuc0Tz+2eeO7wxPM1Tzxf98TzDU883/TEc6cnnrs88dztiedbnnju8cTzbU8893riuc8Tz3c88XzXE8/9nni+54nnAU88D3ri+b4nnh944vmhJ54feeL5sSeen3jiecgTz8OeeB7xxPOoJ56feuL5mSeen3vi+YUnnl964vmVJ57HPPH82hPP4554fuOJ5wlPPE964vk/Tzy/9cTzlCee33ni+b0nnqc98TzjiecPnnie9cTznCee5z3xvOCJ50VPPC954nnZE88rnnhe9cTzR088r3ni+ZMnntc98fzZE89fPPG84YnnTU88f/XE85Ynnrc98bzjieddTzx/88Tzniee9z3x/N0TzweeeD70xPORJ56PPfF84onnH554/umJ51NPPP/yxPOZJ55/e+L5jyee/3riCZr54Ul54mnkiafME0/aE09jTzzlnniaeOKp8MRT6YmnqSeeZp54qjzxNPfE08ITT7UnnpaeeFp54mntiaeNJ562nnjaeeLZwRPPjp542nvi2ckTTwdPPB098XTyxLOzJ55dPPF09sRT44mniyeerp54unni6e6JZ1dPPLt54unhiaenJ55ennh6e+Lp44mnryeefp54dvfEs4cnnj098ezliae/J54BnngGeuIZ5IlnsCeevRPyNCKePRdMXvHqXpt7fW/qmO/W1c0+sueAN8af+sDyjaNe/ejS9xDePYiv0xBHOmXj2adZfP0vGuCnnNJBfP339VR3jYP4Og31pFN5EF+nYZ50ahLE12k/TzpVBPF12t+TTpVBfJ2Ge9KpaRBfpxGedGoWxNdppCedqoL4Oh3gSafmQXydRnnSqUUQX6fRnnSqDuLr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",
      "custom_attributes": [
        "external",
        "private"
      ],
      "debug_symbols": "TL3LzjQ7j5x7L2vsQelAiuxb2QNjex+MBhpuwIdRw/fuNxmiIib9PdH/ehXKlBiVlcXK+o9//t//77/8r//6n//1v/3///4//vmX/+s//vkv//1f/+3f/vW//ud/+/f/5//+n//67//t7//7H//8vv8z9j//Ms33//5P/4xPr/znX8Z/+mf/8M/APxP/LPyz8Y/hH8c/B/8E/sEohlEMoxhGMYxiGMUwimEUwyiGUQyjOEZxjOIYxTGKYxTHKI5RHKM4RnGMcjDKwSgHoxyMcjDKwSgHoxyMcjDKwSiBUQKjBEYJjBIYJTBKYJTAKIFRAqMkRkmMkhglMUpilMQoiVESoyRGSYwyfr/777j/zvvvuv/u+6/df/3+e+6/cf+944073rjjjTveuOONO964442/8db377n/xv038e/8G8+/f8f9d95/1/33b7z8/v3Gqz/whtMQDXlh/Rq+WZ4PZsNq2A3fyPGBN5yGb+TvKGrHf1B7vuBv5Lk/mA2rYTdYgzechmjIC18dAHpk65GtR/7qYX5n5asIgDechmjIC19tAEbDbFgNPbL3yN4je4/sPbL3yKdHPj3y6ZFPj3x65NMjnx759MinRz498ldD81uCr4oAs2E17AZr8IbTEA15IXvk7JGzR84eOXvk7JGzR84eOXvkvCPP369hNMyG1bAbrMEbTkM09MijRx498uiRR488euTRI48eefTIo0cePfLskWePPHvk2SPPHnn2yLNHnj3y7JFnj7x65NUjrx559cirR1498uqRV4+8euTVI+8eeffIu0fePfLukXeP/NXgGh+chmjIC18NAkbDbFgNu8EaemTrka1H/mpw/VXu/GoQMBq+kfOD1bAbrMEbTkM05IWvBgGjoUc+PfLpkc9NpHm84TREw02kGb+G0TAbVsNu6JGjR44e+avBPT/IC18NAkbDbFgNu8EavOE09Mh5R16/X8No+EZeH6yG3WAN3nAaoiEvfDUIGA098uiRR4/81aD9PvCG0xANeeGrQcBomA2rYTf0yLNHnj3y7JFnj7x65NUjrx559cirR1498uqRV4+8euTVI+8eeffIu0fePfLukXePvHvk3SPvHnn3yNYjW49sPbL1yNYjW49sPbL1yNYjW4/sPbL3yN4je4/sPbL3yN4je4/sPbL3yKdHPj3y6ZFPj3x65NMjnx759MinRz49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V+fj1fl4dT5enY9X5+PV+Xh1Pl6dj1fn49X5eHU+Xp2PV+fj1fl4dT5enY9X5+PV+Xh1Pl6dj1fn49X5eHU+Xp2PV+fj1fl4dT5enY9X5+PV+Xh1Pl6dj1fn49X5eHU+Xp2PV+fj1fl4dT5enY9X5+PV+Xh1Pl6dj1fn49X5eHU+Xp2PV+fj1fl4dT5enY9X5+PV+Xh1Pl6dj1fn49X5eHU+Xp2PV+fj1fl4dT5enY9X5+PV+Xh1Pl6dj1fn49X5eHU+Xp2PV+fj1fl4dT5enY9X5+PV+Xh1Pl6dj1fn49X5fHU+X53PV+fz1fl8dT5fnc9X5/PV+Xx1Pl+dz1fn89X5fHU+X53PV+fz1fl8dT5fnc9X5/PV+Xx1Pl+dz1fn89X5fHU+X53PV+fz1fl8dT5fnc9X5/PV+Xx1Pl+dz1fn89X5fHU+X53PV+fz1fl8dT5fnc9X5/PV+Xx1Pl+dz1fn89X5fHU+X53PV+fz1fl8dT5fnc9X5/PV+Xx1Pl+dz1fn89X5fHU+X53PV+fz1fl8dT5fnc9X5/PV+Xx1Pl+dz1fn89X5fHU+X53PV+fz1fl8dT5fnc9X5/PV+Xx1Pl+dz1fn89X5fHU+X53PV+fz1fl8dT5fnc9X5/PV+Xx1Pl+dz1fn89X5fHU+X53PV+fz1fl6db5ena9X5+vV+Xp1vl6dr1fn69X5enW+Xp2vV+fr1fl6db5ena9X5+vV+Xp1vl6dr1fn69X5enW+Xp2vV+fr1fl6db5ena9X5+vV+Xp1vl6dr1fn69X5enW+Xp2vV+fr1fl6db5ena9X5+vV+Xp1vl6dr1fn69X5enW+Xp1XC5JXS+9X55fi0Z+HV+PwV+eXxqP5aD3aj+yRPzqP4tHz8Ofhz8Ofhz8Pfx7+PPx5+PPw5+HP4zyP8zzO8zjP4zyP8zzO8zjP4zyP8zziecTziOcRzyOeRzyPeB7xPOJ5xPPI55HPI59HPo98Hvk88nnk88jnke1RjUuXxqP5aD3aj+yRPzqP4tHzGM9jPI/xPMbzGM9jPI/xPMbzGM9jPI/5PObzmM9jPo/5PObzmM9jPo/5PObzWM9jPY/1PNbzWM9jPY/1PNbzWM9jPY/9PPbz2M9jP4/9PPbz2M9jP4/9PF6d71fn+9X5fnW+X51Xu5NbkT3yR+dRPMqmqnPQeDQfrUfPw5+HPw9/Hv48/Hmc53Gex3ke53mc53Gex3ke53mc53GeRzyPeB7xPOJ5xPOI5xHPI55HPI94Hvk88nnk88jnkc8jn0c+j3we+TyyPao56tJ4NB+tR/uRPfJH51E8eh7jeYznMZ7HeB7jeYznMZ7HeB7jeYznMZ/HfB7zecznMZ/HfB7zecznMZ/HfB7reaznsZ7Heh7reaznsZ7Heh7reaznsZ/Hfh77eeznsZ/Hfh77eeznsZ/Hfh72POx52POw5/Hq3F6d26tze3Vur87t1bm9OrdX5/bq3F6d26tze3Vur87t1bm9OrdX5/bq3F6d26tze3Vur87t1bm9OrdX5/bq3F6d26tze3Ve7VYeRevRfmSP/NF5FI+yqeocNB49j3we+TzyeeTzyOeRzyPboxqwLo1H89F6tB/ZI3/053F2UTzKpq/OL41H89F6tB/ZI3/0PL46P1aUTV+dXxqP5qP1aD+yR/7oPHoe83ms57Gex1fn5xStR/uRPfJH51E8yqavzi+NR89jP4/9PPbz2M9jP4/9PPbzsOdhz8Oehz0Pex72POx52POw52HPw5+HPw9/Hv48/Hn48/Dn8dX5qR321fmlbPrq/GTReDQf/XnEKNqP7NGfR9Ru+ur8Ujz688jfR1+dXxqP/jyyRvnq/NJ+9OeRq8gfnUfxKJu+Or80Hs1H69F+9DzyeeTz+Oo86zi+Oi+qJq9Ln8cpmo/Wo/3IHvmj8ygeZdNX55eex3ge43l8dZ5RZI/80XkUj7Lpq/NL49F8tB49j/k85vOYz2M+j/k81vNYz2M9j/U81vNYz2M9j/U81vNYz2M/j/089vPYz2M/j/089vPYz2M/j/087HnY87DnYc/Dnoc9D3se9jzsedjz8Ofhz8Ofhz8Pfx7+PPx5+PPw5+HP4zyP8zzO8zjP4zyP8zzO8zjP4zyP8zziecTziOcRzyOeRzyPeB7xPOJ5xPPI55HPI59HPo98Hvk88nnk88jnke1RjWSXxqP5aD3aj+yRPzqP4tHzGM9jPI/6jvtvFC7iJhrRiYcYxHz41XvjINJt0m3SbdJt0m3SbdJt0m3RbdFt0W3RbdFt0W3RbdFt0W3RbdNt023TbdNt023TbdNt023TbdPN6GZ0M7oZ3YxuRjejm9HN6GZ0c7o53ZxuTjenm9PN6eZ0c7o53Q7dDt0O3Q7dDt0O3Q7dDt0O3Q7dgm5Bt6Bb0C3oFnQLugXdgm5Bt6Rb0i3plnRLuiXdkm5Jt6RbPrdqgmscxElcxE00ohMPMYh0G3QbdGOWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJYks+a7GE1kCHMRJXMRNNKITDzGIdEu6Jd2QJVa4iJtoRCceYhDz4vwhS4CDOImLuIlGdOIhBpFug26DboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptum25GN2TJKZzERfzcxq/QiE48xCDmw8qSi4M4iYtIN6eb083p5nRzuh26Hboduh26Hboduh26Hboduh26Bd2CbkG3oFvQLegWdAu6Bd2Cbkm3pFvSLemWdEu6Jd2Sbkm3fG54RtfFQZzERdxEIzrxEINIt0G3QbdBt0G3QbdBt0G3QbdBt0G3SbdJt0m3SbdJt0m3SbdJt0m3SbdFt0W3RbdFt0W3RbdFt0W3RbdFt023TbdNt023TbdNt023TbdNt003o5vRzehmdGOWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJYpYsZslilixmyWKWLGbJYpYsZslilixmyWKWLGbJYpYsZslilixmyWKWLGbJYpYsZMn6EFkCHMRJXMRNNKITDzGIdFt0W3RDluzCRdxEIzrxEIOYD5ElwEGk26bbptum26bbptum26ab0c3oZnQzuhndjG5GN6Ob0c3o5nRzujndnG5ON6eb083p5nRzuh26Hboduh26Hboduh26Hboduh26Bd2CbkG3oFvQLegWdAu6Bd2Cbkm3pFvSLemWdEu6Jd2Sbkm3fG779yMO4iQu4iYa0Ynl5oVBzIfIkiwcxElcxE00ohMPMYj5cNJt0m3SbdJt0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0W3TbdNt023TbdNt023TbdNt023TzehmdDO6Gd2MbkY3o5vRzehmdHO6Od2cbk43p5vTzenmdHO6Od0O3Q7dDt0O3Q7dDt0O3Q7dDt0O3YJuQbegW9At6BZ0C7oF3YJuQbekW9It6ZZ0S7ol3ZJuSbekWz43+/2IgziJi7iJRnTiIQaRbswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZslhlhxmyWGWVCvq32cfhZtoRCceYhDzYWXJxUGcRLoNug26VZZ8P7cxqzG1MYj5sLLk4iBO4iJuohHpNuk26Tbptui26Lbotui26FZZMq3QiYcYxHxYWXJxECdxETeRbptum26bbptuRjejm9HN6GZ0M7oZ3YxuRjejm9PN6eZ0c7o53ZxuTjenm9PN6Xboduh26Hboduh26Hboduh26HboFnQLugXdgm5Bt6Bb0C3oFnQLuiXdkm5Jt6Rb0i3plnRLuiXd8rlVr2vjIE7iIm6iEZ14iEGk26DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26IbsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWYK+13kKN9GITjzEIOZDZAlwECeRbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptum25GN6Ob0c3oZnQzuhndjG5GN6Ob083p5nRzujndnG5ON6eb083pduh26HboduiGLMlCIzrxc6uf90Lf68V8WFlycRAncRE30YhOpFvQLeiWdEu6Jd2Sbkm3pFvSLemWdMt2W+h7vTiIk7iIm2hEJx5iEOk26DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26Tbptui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26WZ0M7oZ3YxuRjejm9HN6GZ0M7o53ZxuTjenm9PN6eZ0c7o53Zxuh26Hboduh26Hboduh26Hboduh25Bt6Bb0C3oFnQLugXdgm5Bt6Bb0i3plnRLuiXdkm5Jt6Rb0o1ZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1mCvtfvJ3UX+l4vBrHc/ENkCXAQJ3ERN9GITjzEINLN6YYs+RVO4iJuohGdeIhBzIfIEiDdDt0O3Q7dDt0O3Q7dDt0O3YJuQbegW9At6BZ0C7oF3YJuQbekW9It6ZZ0S7ol3ZJuSbekWz439L1eHMRJXMRNNKITDzGIdBt0G3QbdBt0qyzZVmhEJ35u2wuDmA+RJadwECdxETfRiE48xCDmw0W3RbdFt0W3RbdFt0W3RbdFt0W3TbdNt023TbdNt023TbdNt023TTejm9HN6GZ0M7oZ3YxuRjejm9HN6eZ0c7o53ZxuTjenm9PN6eZ0O3Q7dDt0O3Q7dDt0O3Q7dDt0O3QLugXdgm5Bt6Bb0C3oFnQLugXdkm5Jt6Rb0i3plnRLuiXdkm753ND3enEQJ3ERN9GITjzEINJt0A33XnfhJC7iJhrRiYcYxHyIe69Auk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptum26Gd2MbkY3o5vRzehmdDO6Gd2Mbk43p5vTzenmdHO6Od2cbk43p9uh26Hboduh26Hboduh26HboduhW9At6BZ0C7oF3YJuQbegW9At6JZ0S7ol3ZJuSbekW9It6ZZ0y+eGvteLg/i52ShcxE383Az/rRMP8XMzL8yHlSUXB3ESF3ETjejEQ6TboNuk26TbpNuk26TbpNuk26TbpNuk26Lbotui26Lbotui26Lbotui26Lbptum26bbptum26bbptum26bbppvRzehmdDO6Gd2MbkY3o5vRzejmdHO6Od2cbk43p5vTzenmdHO6Hboduh26Hboduh26Hboduh26HboF3YJuQbegW9At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Aa8EvBLwSsArAa8EvBLwSsArAa8EvBLwSsArAa8EvBLwSsArAa8EvBLwSsArAa8EvBLwSsArAa8EvBLwSsArAa8EvBLwSsArAa8EvBLwSsArAa8EvBLwSsArAa8EvBLwSsArAa8EvBLwSsArAa8EvBLwSsArAa8EvBLwSsArAa8EvBLwSsErBa8UvFLwSsErBa8UvFLwSsErBa8UvFLwSsErBa8UvFLwSsErBa8UvFLwSsErBa8UvFLwSsErBa8UvFLwSsErBa8UvFLwSsErBa8UvFLwSsErBa8UvFLwSsErBa8UvFLwSsErBa8UvFLwSsErBa8UvFLwSsErBa8UvFLwSsErBa8UvFLwSsErBa8UvFLwSsErBa8UvFLwSsErBa8UvFLwSsErBa8UvFLwSsErBa8UvFLwSsErBa8UvFLwSsErBa8UvFLwSsErBa8UvFLwSsErBa8UvFLwSsErBa8UvFLwqoBXBbwq4FUBrwp4VcCrAl4V8KqAVwW8KuBVAa8KeFXAqwJeFfCqgFcFvCrgVQGvCnhVwKsCXhXwqoBXBbwq4FUBrwp4VcCrAl4V8KqAVwW8KuBVAa8KeFXAqwJeFfCqgFcFvCrgVQGvCnhVwKsCXhXwqoBXBbwq4FUBrwp4VcCrAl4V8KqAVwW8KuBVAa8KeFXAqwJeFfCqgFcFvCrgVQGvCnhVwKsCXhXwqoBXBbwq4FUBrwp4VcCrAl4V8KqAVwW8KuBVAa8KeFXAqwJeFfCqgFcFvCrgVQGvCnhVwKsCXhXwqoBXBbwq4FUBrwy8MvDKwCsDrwy8MvDKwCsDrwy8MvDKwCsDrwy8MvDKwCsDrwy8MvDKwCsDrwy8MvDKwCsDrwy8MvDKwCsDrwy8MvDKwCsDrwy8MvDKwCsDrwy8MvDKwCsDrwy8MvDKwCsDrwy8MvDKwCsDrwy8MvDKwCsDrwy8MvDKwCsDrwy8MvDKwCsDrwy8MvDKwCsDrwy8MvDKwCsDrwy8MvDKwCsDrwy8MvDKwCsDrwy8MvDKwCsDrwy8MvDKwCsDrwy8MvDKwCsDrwy8MvDKwCsDrwy8MvDKwCsDrwy8MvDKwCsDrxy8cvDKwSsHrxy8cvDKwSsHrxy8cvDKwSsHrxy8cvDKwSsHrxy8cvDKwSsHrxy8cvDKwSsHrxy8cvDKwSsHrxy8cvDKwSsHrxy8cvDKwSsHrxy8cvDKwSsHrxy8cvDKwSsHrxy8cvDKwSsHrxy8cvDKwSsHrxy8cvDKwSsHrxy8cvDKwSsHrxy8cvDKwSsHrxy8cvDKwSsHrxy8cvDKwSsHrxy8cvDKwSsHrxy8cvDKwSsHrxy8cvDKwSsHrxy8cvDKwSsHrxy8cvDKwSsHrxy8cvDKwSsHrxy8cvDKwSsHryp4VcGrCl5V8KqCVxW8quBVBa8qeFXBqwpeVfCqglcVvKrgVQWvKnhVwasKXlXwqoJXFbyq4FUFryp4VcGrCl5V8KqCVxW8quBVBa8qeFXBqwpeVfCqglcVvKrgVQWvKnhVwasKXlXwqoJXFbyq4FUFryp4VcGrCl5V8KqCVxW8quBVBa8qeFXBqwpeVfCqglcVvKrgVQWvKnhVwasKXlXwqoJXFbyq4FUFryp4VcGrCl5V8KqCVxW8quBVBa8qeFXBqwpeVfCqglcVvKrgVQWvKnhVwasKXlXwqoJXFbyq4FUFryp4VcGrCl5V8KqBVw28auBVA68aeNXAqwZeNfCqgVcNvGrgVQOvGnjVwKsGXjXwqoFXDbxq4FUDrxp41cCrBl418KqBVw28auBVA68aeNXAqwZeNfCqgVcNvGrgVQOvGnjVwKsGXjXwqoFXDbxq4FUDrxp41cCrBl418KqBVw28auBVA68aeNXAqwZeNfCqgVcNvGrgVQOvGnjVwKsGXjXwqoFXDbxq4FUDrxp41cCrBl418KqBVw28auBVA68aeNXAqwZeNfCqgVcNvGrgVQOvGnjVwKsGXjXwqoFXDbxq4FUDrxp41cCrBl418KqBVw28auBVu3glx8Wrs53QzmgL2op2QdvQdrQr2qibUDehbkLdhLoJdRPqJtRNqJtQN6FuRt2Muhl1M+pm1M2om1E3o25G3Yy6grqCuoK6grqCuoK6grqCuoK6grqKuoq6irqKuoq6irqKuoq6irqKugV1C+oW1C2oW1C3oG5B3YK6BXUL6hrqGuoa6hrqGuoa6hrqGuoa6hrqOuo66jrqOuo66jrqOuo66jrqOupW1K2oW1G3om5F3Yq6FXUr6lbUrajbULehbkPdhroNdRvqNtRtqNtQF7yC3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr/9Y9VytFEXvILfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHffrZRF7yC3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w28826oJX8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u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8NsNfrvBbz/bqAtewW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPffrZRF7yC327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaD327w2w1+u8FvN/jtBr/d4Lcb/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/9bKMueAW/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3T/99iIf7cGrz3avW7y3e93SelvQ7nXt6O2Cdq9rPf/glY2cva6Nf9uu9uDVZzuhndEWtBXtgrah7Wj3ut63YfBqtAevPtsJ7Yy2oK1oF7QNbUd71O37cPBqtAevPtsJ7Yy2oK1oF7QNbUcbdRV1C+oOXrXU2xltQVvR7nVb/10fvDonhUpvO9q1t/s+/+DVo/3Bq3OyqP+dD17Ndu7t8XcEbf1oSz9/Png1272uWm872r3uOCetXW3vda1vv/e6pr2d0Ra0e13r2+YFbUO717W+D72i3a52HXVrb4+6fXtqRlvQ7nW9953a6/r4t71uHX/H0e51ve+T2uuO49IOtBPaGW1BW9EuaBvajnZF+6rb/fbZTmhntAVtRbugbWg72hVt1E2om1A3oW5C3YS6CXUT6ibUTaibUDejbkbdjLoZdTPqZtTNqJtRN6NuRl1BXRl1S29ntD/qpsN6W9EuaBvajnZFu13tD17NdkI7o426irqKuoq6irqKuoq6BXUL6hbULahbULegbkHdgroFdQvqGuoa6hrqGuoa6hrqGuoa6hrqGuo66jrqOuo66jrqOuo66jrqOuo66lbUrahbUbeibkXdiroVdSvqVtStqNtQt6FuQ92Gug11G+o21G2o21C3zbq1++2zndDOaAvainZB29B2tCvaqJtQN6FuQt2Eugl1E+om1E2om1A3oW5G3Yy6GXUz6mbUzaibUTejbkbdjLqCuoK6grqCuoK6grqCuoK6grqCuoq6irqKuoq6irqKuoq6irqKuoq6BXUL6hbULahbULegbkHdgroFdQvqGuoa6hrqGuoa6hrqGuoa6hrqGuo66jrqOuo66jrqOuo66jrqOuo66lbUrahbUbeibkXdiroVdSvqVtStqNtQt6FuQ92Gug11G+o21G2o21AXvErgVQKvEniVwKsEXiXwKoFXCbxK4FUCrxJ4lcCrBF4l8CqBVwm8SuBVAq8SeJXAqwReJfAqgVcJvErgVQKvEniVwKsEXiXwKoFX6ZNXtbd73SS9LWgr2gXtXjdpbzvavW7y3u51U/toD159thPavW5OvS1o97q55xy8+mwb2r1u7r9l8Oqz3etK+WgPXn22E9q9rvTtHLz6bPe60rdt8Er79gxefbZ7Xe37YfDqs93rat+GwavPdkK719W+zwevPtu9bunbMHj12Ta0e93St23w6rPd61rftsGrz3av+/HMVdPg1Wdb0O51P56zahq8+mz3ut731eCV920YvPpst6s9eOV9ewavPtu9bu05B68+24p2r1v7MR28+mz3uq3v28Grz3a72oNXrW/n4NVnu9dtfdsGr1rfnsGrz/ZH3Xz0fdV59Wh7b/dt6Lx6tNtsd7/9bFtvJ7Q/6uZUelvQVrR73d5Hut8+271u7xfdb5/tXjd/nCfdb5/thHavK0dvC9q9bj/nu98+24a2o93rSv8tnVef7c6r3PtF99sl977Q/fbZFrR73d4vut8+272ujpyOdkW71+39ovvts93r9r7Q/fbZFrR73d4vut8+271u7xfdbz/bfXs6rx7tXtf6fui8erR7Xevb0Hn1aAvavW7vU91vn+1et/eF7rfPdkW716192zqvHu1et/Zt67x6tHvdlntb0S5o97qtn6udV492r9v7Rffbz3bfhs6rRzuh/VFXer/ofvtsa2/3nJ1Xj7ah7b3dj2nn1aP9UVdGX+i8erQT2r3u6BedV492rzv6ReeV9OtF99tnu9fNfV91Xj3avW6/RnS/fbYT2r3u6FOdV492r9uvEd1vn21Du9cdfaTz6tHudUe/6Lx6tHvd0s+TzqtHW9DudUs/pp1Xj3avW/p+7ryS0vdb55WU/ls6r0a7++1n23s7oZ3RFrRH3drbBW1De9Rtvd3rfoyN1+63n+2PfS6dV9L7UffbZ7vX7deO7rfPtqLd69aes/NK6sjpaPe6tfznX//yv/727//yt//z7//8P/7yX/73Gf7f//Nf/+k//uXf/vUz/I//978//sv/+e//8ve//8v/89/++7//2z/98//1P//9n//b3//tnz7+21+Oj//52OT/I9lfc/qv519On39+/skJ6L+mj89O/Ne//kXGn5wnR/r4CMT5J5//7LzK/fXjf/sfpfG3zmmIj//Vj3x5ljj/VP3jj+Tjjz4SnqdFSY9U53Eu/T/rtVHtr7knKfOPzjuh3D7+yOYfif5V+h/5I+85tKx55j2L2Md/rte/aH8dG9ce/+L8XdePmv85XftH0l+lZ0npH+yzHFdOcm1/+ms+/+w///O//uf/Bw==",
      "is_unconstrained": false,
      "name": "receive_value",
      "verification_key": "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"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "6788092787179896647": {
            "error_kind": "string",
            "string": "Caller is not owner"
          }
        },
        "parameters": [
          {
            "name": "source_chain_id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 16
            },
            "visibility": "private"
          },
          {
            "name": "emitter_address",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "public"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "register_emitter"
    },
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "14067204867181196045": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "14401109495927734611": {
            "error_kind": "string",
            "string": "Field failed to decompose into specified 16 limbs"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15546539856497705002": {
            "error_kind": "string",
            "string": "u16 to u8 conversion failed"
          },
          "15711892660910782274": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16216212843441549037": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "2014890719615096298": {
            "error_kind": "string",
            "string": "Field failed to decompose into specified 40 limbs"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "4648451262681811962": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "7555607922535724711": {
            "error_kind": "string",
            "string": "Preimage mismatch"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9589626482238399944": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "9921926525851912681": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "anchor_block_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "sponge_blob_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "destination_chain_id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 16
            },
            "visibility": "private"
          },
          {
            "name": "value",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "fee_nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "note_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 32,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "log",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "fields",
                                          "type": {
                                            "kind": "array",
                                            "length": 18,
                                            "type": {
                                              "kind": "field"
                                            }
                                          }
                                        },
                                        {
                                          "name": "length",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::log::Log"
                                    }
                                  },
                                  {
                                    "name": "note_hash_counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "anchor_block_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "sponge_blob_hash",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "private"
      ],
      "debug_symbols": "TL3LzjQ7j5x7L2vsQelAiuxb2QNjex+MBhpuwIdRw/fuNxmiIib9PdH/ehXKlBiVlcXK+o9//t//77/8r//6n//1v/3///4//vmX/+s//vkv//1f/+3f/vW//ud/+/f/5//+n//67//t7//7H//8vv8z9j//Ms33//5P/4xPr/znX8Z/+mf/8M/APxP/LPyz8Y/hH8c/B/8E/sEohlEMoxhGMYxiGMUwimEUwyiGUQyjOEZxjOIYxTGKYxTHKI5RHKM4RnGMcjDKwSgHoxyMcjDKwSgHoxyMcjDKwSiBUQKjBEYJjBIYJTBKYJTAKIFRAqMkRkmMkhglMUpilMQoiVESoyRGSYwyfr/777j/zvvvuv/u+6/df/3+e+6/cf+944073rjjjTveuOONO964442/8db377n/xv038e/8G8+/f8f9d95/1/33b7z8/v3Gqz/whtMQDXlh/Rq+WZ4PZsNq2A3fyPGBN5yGb+TvKGrHf1B7vuBv5Lk/mA2rYTdYgzechmjIC18dAHpk65GtR/7qYX5n5asIgDechmjIC19tAEbDbFgNPbL3yN4je4/sPbL3yKdHPj3y6ZFPj3x65NMjnx759MinRz498ldD81uCr4oAs2E17AZr8IbTEA15IXvk7JGzR84eOXvk7JGzR84eOXvkvCPP369hNMyG1bAbrMEbTkM09MijRx498uiRR488euTRI48eefTIo0cePfLskWePPHvk2SPPHnn2yLNHnj3y7JFnj7x65NUjrx559cirR1498uqRV4+8euTVI+8eeffIu0fePfLukXeP/NXgGh+chmjIC18NAkbDbFgNu8EaemTrka1H/mpw/VXu/GoQMBq+kfOD1bAbrMEbTkM05IWvBgGjoUc+PfLpkc9NpHm84TREw02kGb+G0TAbVsNu6JGjR44e+avBPT/IC18NAkbDbFgNu8EavOE09Mh5R16/X8No+EZeH6yG3WAN3nAaoiEvfDUIGA098uiRR4/81aD9PvCG0xANeeGrQcBomA2rYTf0yLNHnj3y7JFnj7x65NUjrx559cirR1498uqRV4+8euTVI+8eeffIu0fePfLukXePvHvk3SPvHnn3yNYjW49sPbL1yNYjW49sPbL1yNYjW4/sPbL3yN4je4/sPbL3yN4je4/sPbL3yKdHPj3y6ZFPj3x65NMjnx759MinRz49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V+fj1fl4dT5enY9X5+PV+Xh1Pl6dj1fn49X5eHU+Xp2PV+fj1fl4dT5enY9X5+PV+Xh1Pl6dj1fn49X5eHU+Xp2PV+fj1fl4dT5enY9X5+PV+Xh1Pl6dj1fn49X5eHU+Xp2PV+fj1fl4dT5enY9X5+PV+Xh1Pl6dj1fn49X5eHU+Xp2PV+fj1fl4dT5enY9X5+PV+Xh1Pl6dj1fn49X5eHU+Xp2PV+fj1fl4dT5enY9X5+PV+Xh1Pl6dj1fn49X5eHU+Xp2PV+fj1fl4dT5enY9X5+PV+Xh1Pl6dj1fn49X5fHU+X53PV+fz1fl8dT5fnc9X5/PV+Xx1Pl+dz1fn89X5fHU+X53PV+fz1fl8dT5fnc9X5/PV+Xx1Pl+dz1fn89X5fHU+X53PV+fz1fl8dT5fnc9X5/PV+Xx1Pl+dz1fn89X5fHU+X53PV+fz1fl8dT5fnc9X5/PV+Xx1Pl+dz1fn89X5fHU+X53PV+fz1fl8dT5fnc9X5/PV+Xx1Pl+dz1fn89X5fHU+X53PV+fz1fl8dT5fnc9X5/PV+Xx1Pl+dz1fn89X5fHU+X53PV+fz1fl8dT5fnc9X5/PV+Xx1Pl+dz1fn89X5fHU+X53PV+fz1fl8dT5fnc9X5/PV+Xx1Pl+dz1fn89X5fHU+X53PV+fz1fl6db5ena9X5+vV+Xp1vl6dr1fn69X5enW+Xp2vV+fr1fl6db5ena9X5+vV+Xp1vl6dr1fn69X5enW+Xp2vV+fr1fl6db5ena9X5+vV+Xp1vl6dr1fn69X5enW+Xp2vV+fr1fl6db5ena9X5+vV+Xp1vl6dr1fn69X5enW+Xp1XC5JXS+9X55fi0Z+HV+PwV+eXxqP5aD3aj+yRPzqP4tHz8Ofhz8Ofhz8Pfx7+PPx5+PPw5+HP4zyP8zzO8zjP4zyP8zzO8zjP4zyP8zziecTziOcRzyOeRzyPeB7xPOJ5xPPI55HPI59HPo98Hvk88nnk88jnke1RjUuXxqP5aD3aj+yRPzqP4tHzGM9jPI/xPMbzGM9jPI/xPMbzGM9jPI/5PObzmM9jPo/5PObzmM9jPo/5PObzWM9jPY/1PNbzWM9jPY/1PNbzWM9jPY/9PPbz2M9jP4/9PPbz2M9jP4/9PF6d71fn+9X5fnW+X51Xu5NbkT3yR+dRPMqmqnPQeDQfrUfPw5+HPw9/Hv48/Hmc53Gex3ke53mc53Gex3ke53mc53GeRzyPeB7xPOJ5xPOI5xHPI55HPI94Hvk88nnk88jnkc8jn0c+j3we+TyyPao56tJ4NB+tR/uRPfJH51E8eh7jeYznMZ7HeB7jeYznMZ7HeB7jeYznMZ/HfB7zecznMZ/HfB7zecznMZ/HfB7reaznsZ7Heh7reaznsZ7Heh7reaznsZ/Hfh77eeznsZ/Hfh77eeznsZ/Hfh72POx52POw5/Hq3F6d26tze3Vur87t1bm9OrdX5/bq3F6d26tze3Vur87t1bm9OrdX5/bq3F6d26tze3Vur87t1bm9OrdX5/bq3F6d26tze3Ve7VYeRevRfmSP/NF5FI+yqeocNB49j3we+TzyeeTzyOeRzyPboxqwLo1H89F6tB/ZI3/053F2UTzKpq/OL41H89F6tB/ZI3/0PL46P1aUTV+dXxqP5qP1aD+yR/7oPHoe83ms57Gex1fn5xStR/uRPfJH51E8yqavzi+NR89jP4/9PPbz2M9jP4/9PPbzsOdhz8Oehz0Pex72POx52POw52HPw5+HPw9/Hv48/Hn48/Dn8dX5qR321fmlbPrq/GTReDQf/XnEKNqP7NGfR9Ru+ur8Ujz688jfR1+dXxqP/jyyRvnq/NJ+9OeRq8gfnUfxKJu+Or80Hs1H69F+9DzyeeTz+Oo86zi+Oi+qJq9Ln8cpmo/Wo/3IHvmj8ygeZdNX55eex3ge43l8dZ5RZI/80XkUj7Lpq/NL49F8tB49j/k85vOYz2M+j/k81vNYz2M9j/U81vNYz2M9j/U81vNYz2M/j/089vPYz2M/j/089vPYz2M/j/087HnY87DnYc/Dnoc9D3se9jzsedjz8Ofhz8Ofhz8Pfx7+PPx5+PPw5+HP4zyP8zzO8zjP4zyP8zzO8zjP4zyP8zziecTziOcRzyOeRzyPeB7xPOJ5xPPI55HPI59HPo98Hvk88nnk88jnke1RjWSXxqP5aD3aj+yRPzqP4tHzGM9jPI/6jvtvFC7iJhrRiYcYxHz41XvjINJt0m3SbdJt0m3SbdJt0m3RbdFt0W3RbdFt0W3RbdFt0W3RbdNt023TbdNt023TbdNt023TbdPN6GZ0M7oZ3YxuRjejm9HN6GZ0c7o53ZxuTjenm9PN6eZ0c7o53Q7dDt0O3Q7dDt0O3Q7dDt0O3Q7dgm5Bt6Bb0C3oFnQLugXdgm5Bt6Rb0i3plnRLuiXdkm5Jt6RbPrdqgmscxElcxE00ohMPMYh0G3QbdGOWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJYks+a7GE1kCHMRJXMRNNKITDzGIdEu6Jd2QJVa4iJtoRCceYhDz4vwhS4CDOImLuIlGdOIhBpFug26DboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptum25GN2TJKZzERfzcxq/QiE48xCDmw8qSi4M4iYtIN6eb083p5nRzuh26Hboduh26Hboduh26Hboduh26Bd2CbkG3oFvQLegWdAu6Bd2Cbkm3pFvSLemWdEu6Jd2Sbkm3fG54RtfFQZzERdxEIzrxEINIt0G3QbdBt0G3QbdBt0G3QbdBt0G3SbdJt0m3SbdJt0m3SbdJt0m3SbdFt0W3RbdFt0W3RbdFt0W3RbdFt023TbdNt023TbdNt023TbdNt003o5vRzehmdGOWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJYpYsZslilixmyWKWLGbJYpYsZslilixmyWKWLGbJYpYsZslilixmyWKWLGbJYpYsZMn6EFkCHMRJXMRNNKITDzGIdFt0W3RDluzCRdxEIzrxEIOYD5ElwEGk26bbptum26bbptum26ab0c3oZnQzuhndjG5GN6Ob0c3o5nRzujndnG5ON6eb083p5nRzuh26Hboduh26Hboduh26Hboduh26Bd2CbkG3oFvQLegWdAu6Bd2Cbkm3pFvSLemWdEu6Jd2Sbkm3fG779yMO4iQu4iYa0Ynl5oVBzIfIkiwcxElcxE00ohMPMYj5cNJt0m3SbdJt0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0W3TbdNt023TbdNt023TbdNt023TzehmdDO6Gd2MbkY3o5vRzehmdHO6Od2cbk43p5vTzenmdHO6Od0O3Q7dDt0O3Q7dDt0O3Q7dDt0O3YJuQbegW9At6BZ0C7oF3YJuQbekW9It6ZZ0S7ol3ZJuSbekWz43+/2IgziJi7iJRnTiIQaRbswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZslhlhxmyWGWVCvq32cfhZtoRCceYhDzYWXJxUGcRLoNug26VZZ8P7cxqzG1MYj5sLLk4iBO4iJuohHpNuk26Tbptui26Lbotui26FZZMq3QiYcYxHxYWXJxECdxETeRbptum26bbptuRjejm9HN6GZ0M7oZ3YxuRjejm9PN6eZ0c7o53ZxuTjenm9PN6Xboduh26Hboduh26Hboduh26HboFnQLugXdgm5Bt6Bb0C3oFnQLuiXdkm5Jt6Rb0i3plnRLuiXd8rlVr2vjIE7iIm6iEZ14iEGk26DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26IbsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWYK+13kKN9GITjzEIOZDZAlwECeRbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptum25GN6Ob0c3oZnQzuhndjG5GN6Ob083p5nRzujndnG5ON6eb083pduh26HboduiGLMlCIzrxc6uf90Lf68V8WFlycRAncRE30YhOpFvQLeiWdEu6Jd2Sbkm3pFvSLemWdMt2W+h7vTiIk7iIm2hEJx5iEOk26DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26Tbptui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26WZ0M7oZ3YxuRjejm9HN6GZ0M7o53ZxuTjenm9PN6eZ0c7o53Zxuh26Hboduh26Hboduh26Hboduh25Bt6Bb0C3oFnQLugXdgm5Bt6Bb0i3plnRLuiXdkm5Jt6Rb0o1ZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1mCvtfvJ3UX+l4vBrHc/ENkCXAQJ3ERN9GITjzEINLN6YYs+RVO4iJuohGdeIhBzIfIEiDdDt0O3Q7dDt0O3Q7dDt0O3YJuQbegW9At6BZ0C7oF3YJuQbekW9It6ZZ0S7ol3ZJuSbekWz439L1eHMRJXMRNNKITDzGIdBt0G3QbdBt0qyzZVmhEJ35u2wuDmA+RJadwECdxETfRiE48xCDmw0W3RbdFt0W3RbdFt0W3RbdFt0W3TbdNt023TbdNt023TbdNt023TTejm9HN6GZ0M7oZ3YxuRjejm9HN6eZ0c7o53ZxuTjenm9PN6eZ0O3Q7dDt0O3Q7dDt0O3Q7dDt0O3QLugXdgm5Bt6Bb0C3oFnQLugXdkm5Jt6Rb0i3plnRLuiXdkm753ND3enEQJ3ERN9GITjzEINJt0A33XnfhJC7iJhrRiYcYxHyIe69Auk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptum26Gd2MbkY3o5vRzehmdDO6Gd2Mbk43p5vTzenmdHO6Od2cbk43p9uh26Hboduh26Hboduh26HboduhW9At6BZ0C7oF3YJuQbegW9At6JZ0S7ol3ZJuSbekW9It6ZZ0y+eGvteLg/i52ShcxE383Az/rRMP8XMzL8yHlSUXB3ESF3ETjejEQ6TboNuk26TbpNuk26TbpNuk26TbpNuk26Lbotui26Lbotui26Lbotui26Lbptum26bbptum26bbptum26bbppvRzehmdDO6Gd2MbkY3o5vRzejmdHO6Od2cbk43p5vTzenmdHO6Hboduh26Hboduh26Hboduh26HboF3YJuQbegW9At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",
      "is_unconstrained": false,
      "name": "send_value_private",
      "verification_key": "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"
    },
    {
      "abi": {
        "error_types": {
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15546539856497705002": {
            "error_kind": "string",
            "string": "u16 to u8 conversion failed"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "8228371833434187583": {
            "error_kind": "string",
            "string": "Trying to read from uninitialized PublicImmutable"
          }
        },
        "parameters": [
          {
            "name": "destination_chain_id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 16
            },
            "visibility": "private"
          },
          {
            "name": "value",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "fee_nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "public"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "send_value_public"
    },
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "14067204867181196045": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "9921926525851912681": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "utility"
      ],
      "debug_symbols": "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4iYa0YmHGES6DboNug26MUuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySahEcYxQO4iQu4iYa0YmHGMR8mHRLuiXdKkvGLNxEIzrxEIOYF2d1EjYO4iQu4iYa0YmHGES6DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26bboZ3YxulSVjFy7iJpbbKXTiIQYxH1aWXBzESVzETaSb083p5nRzuh26Hboduh26Hboduh26Hboduh26Bd2CbkG3oFvQLegWdAu6Bd2Cbkm3pFvSLemWdEu6Jd2Sbkm3fG7j9yMO4iQu4iYa0YmHGES6DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26bboZ3YxuRjejm9GNWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWbKYJYtZspgli1mymCWLWbKYJYtZspgli1mymCWL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26DboNug26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptumW2XJ960xu/peG534uc0oDGI+rCz5fqNyV99r4yR+bqvcKksuGvFz+z7h39X32hjEz+37XG9X32vjIH5u2woXcRM/N6sLqiy5eIifm2GwfFhZcvFz81/hJC7i5+Y138qSi0783LzWrLLkYj6sLDk138qSi5P4uZ1as8qSi0b83E6temXJxSDmw8qSi4M4iYu4iUakW9It6ZbPrfpeGwdxEhdxE43oxEMMIt0G3QbdBt0G3QbdBt0G3QbdKku+++pdfa8XK0sufm7fX1Da1ffauIibaEQnHmIQ82FlyUW6Lbotui26VZZ8f4FpV99r4yF+bjkL82FlycXPLesyK0suLuImGtGJhxjEfFhZcpFuRrcvS9av5vtlSaMR/cOa75cljUHMD796q77XxkGcH9Z2+yLuRnRKRtE37Piqv1oi1/eOYFdLZOMibqIRnXiIQcyH3zFrpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptumm9HN6GZ0M7oZ3YxuRjejm9HN6OZ0c7o53ZxudcyGFRrRiYcYxHx4yq0O6hnESVzEz23W+f1esho/t++b5na1RDYGMR9+L1mNgziJn9vchZtoxHLzwkMMYrnVfPNHHMRJXMRN/Ny+r0jY1RLZeIhB/Ny+34Tb1RLZOIif2/4VLuImfm5f2+uulsjG83DUVZzCb9y6hak2x7W9sEbIQiceYhDzYeXDxW/curGpNsfGRdzEz63ucarNsfFzs5pk5cPFfFj5cHEQJ/Fz+zosdrU5NhrRiZ/b98RrV5tj4+fmNcnKh4uDOInlVsaVDxeN6MRDDOLndmo6lQ8XB3ESP7dTk6x8uGjEcrPCQ4yHVfMXa4S6iqruupWrzsS/J+AfVklfHMRJXMRvsKhJVklfdOIhBjEfVknXPUN1JjZO4iKWW823SvqiE8utZlYlfTEfVklHHdoq6awaqpKuu47qTGzcRCM68TRWD+LfvyocxElcxE20h1WF35+d3NUg2FgW33yrFXDXXUe1AjZO4iJuoj1c9f+t+S4jOvEQg5gP9484iJO4iHTbdNt023TbdNt0sxp3FdYIu7BG8MJDDGKN8G13teE1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",
      "is_unconstrained": true,
      "name": "sync_private_state"
    }
  ],
  "name": "MessageBridge",
  "noir_version": "1.0.0-beta.14+82ec52a8c755d30ce655a2005834186a4acfa0c7-aztec",
  "outputs": {
    "globals": {
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "minters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Wormhole"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "state",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "sequences",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "owner",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "receiver_address",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000009"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "token_address",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000d"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_1",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000011"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_2",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000012"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_3",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000013"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_4",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000014"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_5",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000015"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_6",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000016"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_7",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000017"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_8",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000018"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_9",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000019"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_10",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_11",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001b"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_12",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001c"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_13",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001d"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_14",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001e"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_15",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001f"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_16",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000020"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_17",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000021"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_18",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000022"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_19",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000023"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "current_guardian_set_index",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000024"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "MessageBridge"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "config",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "owner",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "registered_emitters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "current_value",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "MessageBridge::_update_value_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::_update_value_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "wormhole_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "chain_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 16
                    }
                  },
                  {
                    "name": "owner",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "message_fee",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "MessageBridge::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "MessageBridge::get_config_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "wormhole_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "chain_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 16
                    }
                  },
                  {
                    "name": "message_fee",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "config::Config"
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::get_config_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "MessageBridge::get_current_value_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::get_current_value_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "MessageBridge::get_owner_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::get_owner_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "chain_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 16
                    }
                  },
                  {
                    "name": "emitter_address",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "MessageBridge::is_emitter_registered_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "boolean"
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::is_emitter_registered_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "message_ciphertext",
                    "type": {
                      "fields": [
                        {
                          "name": "storage",
                          "type": {
                            "kind": "array",
                            "length": 17,
                            "type": {
                              "kind": "field"
                            }
                          }
                        },
                        {
                          "name": "len",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 32
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "std::collections::bounded_vec::BoundedVec"
                    }
                  },
                  {
                    "name": "message_context",
                    "type": {
                      "fields": [
                        {
                          "name": "tx_hash",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "unique_note_hashes_in_tx",
                          "type": {
                            "fields": [
                              {
                                "name": "storage",
                                "type": {
                                  "kind": "array",
                                  "length": 64,
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              },
                              {
                                "name": "len",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "std::collections::bounded_vec::BoundedVec"
                          }
                        },
                        {
                          "name": "first_nullifier_in_tx",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "recipient",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::messages::processing::message_context::MessageContext"
                    }
                  }
                ],
                "kind": "struct",
                "path": "MessageBridge::process_message_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::process_message_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "vaa",
                    "type": {
                      "kind": "array",
                      "length": 2000,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "length",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "MessageBridge::receive_value_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::receive_value_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "source_chain_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 16
                    }
                  },
                  {
                    "name": "emitter_address",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "MessageBridge::register_emitter_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::register_emitter_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "destination_chain_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 16
                    }
                  },
                  {
                    "name": "value",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "fee_nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "MessageBridge::send_value_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::send_value_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "destination_chain_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 16
                    }
                  },
                  {
                    "name": "value",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "fee_nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "MessageBridge::send_value_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::send_value_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "MessageBridge::sync_private_state_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::sync_private_state_abi"
        }
      ]
    }
  },
  "transpiled": true
}
