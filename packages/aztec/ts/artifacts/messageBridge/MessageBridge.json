{"transpiled":true,"noir_version":"1.0.0-beta.14+82ec52a8c755d30ce655a2005834186a4acfa0c7-aztec","name":"MessageBridge","functions":[{"name":"constructor","is_unconstrained":true,"custom_attributes":["external","initializer","public"],"abi":{"parameters":[{"name":"wormhole_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"chain_id","type":{"kind":"integer","sign":"unsigned","width":16},"visibility":"private"},{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"message_fee","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"}],"return_type":null,"error_types":{"9967937311635654895":{"error_kind":"string","string":"Initialization hash does not match"},"14415304921900233953":{"error_kind":"string","string":"Initializer address is not the contract deployer"},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"}}},"bytecode":"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","debug_symbols":"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"},{"name":"get_config","is_unconstrained":true,"custom_attributes":["external","utility"],"abi":{"parameters":[],"return_type":{"abi_type":{"kind":"struct","path":"types::Config","fields":[{"name":"wormhole_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"chain_id","type":{"kind":"integer","sign":"unsigned","width":16}}]},"visibility":"public"},"error_types":{"344423948968719440":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]},"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"992401946138144806":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"3080037330898348111":{"error_kind":"fmtstring","length":132,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"4261968856572588300":{"error_kind":"string","string":"Value does not fit in field"},"4440399188109668273":{"error_kind":"string","string":"Input length must be a multiple of 32"},"7564993426627941149":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"7995966536718645961":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"8992688621799713766":{"error_kind":"string","string":"Invalid public keys hint for address"},"9791669845391776238":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"9885968605480832328":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"9921926525851912681":{"error_kind":"fmtstring","length":98,"item_types":[]},"10791800398362570014":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"11021520179822076911":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"12913276134398371456":{"error_kind":"string","string":"push out of bounds"},"13450089406971132036":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"14067204867181196045":{"error_kind":"fmtstring","length":75,"item_types":[]},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"},"16792019527863081935":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17154023812102399658":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17803644318014042523":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]}}},"bytecode":"H4sIAAAAAAAA/+y9C7xdVXUvvHbOPodsOMkm4Q0BDkRI5P0M4ZmEACGQQEh4CPgK5BBRSHgkKGp9QQBRIBCegngOiCgVUK996Oe9VWtvr239+tXaa2tr7eP2qrW1Wh992fq5ZI1z/ue//2vuudYe+5wdstbvB9lnzTHHGHPMMcYcc8zHqiUvPTtn/64f3vS6qzduuOba9bVf/FXL3taTic+0pPWpiXcTAGvidyvZ+xe99GY6YUhr9P3iv6Ek6qlNJ0rF6r/rtdMZYaH6yS/r10rTf6n9aZ2S7U8Gsn9fDfWRF8O70y/+mwG/52W/BwP1rew1At904LUE36+2+vVy9afNTlrp14G39FkKFYaSqKfP6p6l6v745q9/5Pfv+W9f+uimZ595eNY3Zjy2yxE7v3PLln/a7/tzPvCDLU9b3bOBp1oSTXvA6p+jaJ/xG31XvOGT/75xl2W3vfjmb/zZBZtnzFn7xQPveuaK37n/wO++7g6ru0zV/c77H39n88UHRoYO/8pPBpbd9w+v+9Hy/oXf+Mrb9/nt9/zsuz/YZnXPVXW/esXPvvnp5ra3vuWez7xt4fzd1n5829d/+Pe/+/svNH/018/f+PUTre5yaHM9Kab/6XNeufpj9n9+ufrTrP4KqF/G/6wsV39Xq38BvByyH+/+8Ee/ueSerxzztz/b+e6Va29/y/Hv++PL/vGtez97yN+98fk5H59ldS9Udf9m09L7N+11/YJ/nP6H9xw7ut/+3/rxs5/+9k9vHV74D9/+zq8f9COru0rVbfNY3YtE3b2Pm3fyDY/+f7v/xfyD/3zx5z9+1IP7/PgVp/3Fb547+oN///K/Qt3V2b9F7d7qrylXv271Ly5Xf8w/XAL1C9j4mL5cWq7+GP3LytUfk9+r4OVQuM7YgG51L4+va0+/1b1C1D3stMYPnrn7HVuSv3r2e/f+9LDPLT5y1gFLZh31tcf/934bbrpynx9Y3SuBoQJ9NieNPtIxb0kWc+zyi/9ekRVu3nTtddduunXJzTcP37Rp6cbrb1i76dqrrhu+8Ka1V183fOnwTTdfu3EDI6zR30tz3qd09p5IZ9nwpkte+rV044ZNw2/Z1E94OXriyKqP/q7T34avP6ce12n32Dg9QDwOxVVfZfV3Kld/2OpPL1f/JqvfKFf/Gqu/c7n6G63+LuXqX2/1B8vVv9bqzyhXf4PVn1mu/nqr3yxXf8jq71qu/s1Wf1a5+mut/uxy9ddZ/d3K1b/a6u9erv4tVn+PcvVvHczg94SX5qMM917wvoBf3r9G+JJkop9KCH+DeCkaq9UIn9Hj9pnPtbbvLXhpijL2kXsLOnsLOgrXTo64pjviajji2rlH27iLI65BR1wzHHHNdMTVdMTlKXtPG9q1R3HNcsTlqROesvfUr9mOuDxt21MndnPE5emjd3fE1avjo8VZFjtgrFHL+dfo8Duj0yBctaRc3KPatZegNz1pbVeRnLTR20fQU3GWwe8byV86RphPyObVZw1ftXn9io3rE3p4qnt2Dotzkons7x1gjfHW6D9+z7j7BCw+afNMTFnzzhnedPUbLl67fv3wul808mauwZjOynlvSrmPqGudvi9xOpREPdNilBrxN4iXskqtlAbbh0pjzj+T6oqNa9ctXXvDzZuvG+Y0C04xWCqIFd+pPq0BZ/iuj+DOor9XiHqJwI26tB+UKUkYzplJa5v2y6nHJsvvpgn4fQnXvqKe8d4XqI84sB5rTEirY7TS2pE+zSS//TFT4ZLWs3tZ6+l0KhySdfrwkLBfOXq7hXQUcRo/Jus5osxw7Z/9PZCDy+rWCf6D2b/NpNU/ryIacwS/+M7kk6ZbHyXeUbasJ53IEfEZX/gO8TeSjvSyFuo3bB/ryZxy9GbHyB35MVnvL8oM1wHZ3wM5uKxuneCfy/5tElz6sJ7sL/jFd6gnzxDvKFvWk5JyXBKrJ4a/kXSkl7VQv2H7WE/2L0dvcYzckR+T9QGizHAdmP09kIPL6tYJ/jeyf5sElz6sJwcIfvEd6smnst/Tc/gdSqKe65SsC9R/8/SkVXYF6m+y+geWq/+G6QRfsP7brP5B5eofY/UPLlf/V0z35sJLtvNXwPsiS5uxdm74G8RLWTt/BdHj9nEK/RDBS1OUcQr9EEHnEEFH4ZruiGtnR1y7OeLayRHXrj2Ka9AR1wxHXDMdcTUdcc1xxOWp970qr/0dcXnq6gGOuA50xOUpe882znLE1au6OuSI6yBHXBYb2XiP8UEt+3e6qFd0boj4jE98h/gbxEtBerWQXLB9PKc5tBy9WTWqj/QQp/Fjsp4nygzX/OzvgRxcVrfO8JlAmwSXPjynmSf4xXc4p6lleGcKfjm/U1QfsT7LCOuxPnbSX4jP+MR3iL+RdKT/tZB+KLlY++aVo7drTP8iPybr+aLMcL0y+3sgB5fVrRP8nqSP84En1sf5gl98h/ponTiYtMqW9aSkHM+O1RPD30g60staqN+wfawn88vROytG7siPyfqVosxwHZb9PZCDy+rWCX4u6ckrgSfWk1cKfvEd6skBGd7pOfwOJXEP24jhQNwol/h+qP0wVs8MfyPpqN9rITkqe7P2HVaKXu0HrBtID3EaPybrw0WZ4Toi+3sgB5fVrRP8saRnSIN1w8qQX3yHenYE+SOULetJOTkmZ8bqieFvJJ3o5bieqH5T9mbtO7wcvSUxckd+TNZHiDLDdWT290AOLqtbJ/gzSE+OAJ7YHx0h+MV3qCcnkz9CftNnKIl6akrWBeq3yA5xGO4j4X2Bfvx5rJ4a/kbS2o9l9PRIopfXD9b2owQvTVGGMsYypHOUoFPhqnBVuCpcFa4KV4Vr+8Z1WIXrZYFrR9Cvyoaqfqz8RGWP2yuuSr8qXd0RdbWKJyp5VW2sZL+94qp0tdKJHVFelX5V/bgj4qpsqNKJHVH2lV+tbKiSV4WrHa5qblW1sfLRla5ur7gq/ar4qnBV9jiZbaxwVT6nGoeqNlZtrHxOJa+qHyv92n5xVbmOqo2Vz6n8RIWr0vvKhirZVzZU4eplXa3iiUonKtlXsp9MXNU4VMmrsqEKVztcva4TM7O/8c4w/p6Lup/ryAAdrG9wg6JeLft3uuAvpTOURD3R95YZ/kbS2uYC9Goh+Su5WNuPFrw0RRn389GCztGCToWrc1yH9yiuqo0vD3ntCHxVuF4e9lj5iQpXpauVv59Mvqp+rNpY6Vc1dmyvfFU6Ucmr0q+qHytclQ1VOrFjyr7yq5UNVfKqcLXDVc2tqjZWPrrS1e0VV6VfFV8VrsoeJ7ONFa7K51TjUNXGqo2Vz6nkVfVjpV/bL64q11G1sfI5lZ+ocFV6X9lQJfvKhipcvayrVTxR6UQl+0r2k4mrGocqeVU2VOFqh6vSiQpXhavCVeGqcFW4Klwvd1x2bxneGXYk0Sl6PxrWNzh1N1n631AS9Vw8XbShQP3XWf1jytW/0eofW67+W+zusuPgZS3713AfD+/74nEfWyN8SVYf3yH+BvFSkN7YvW3HEz1un+mFtf0EwUtTlLGOnCDonCDoKFwHOuLayRFX0xHXbo645jjimuWIa9AR1y6OuDx1YrYjrqMdce3qiOsYR1zTHXEd4IjL07aHHHF5+kJPe5zhiMuzHw92xOWpE56y97RtzzZ66sTOjrh61U948rUjxEzVmDZ1sve0x4YjLs82HtujfA054vJso421ai6MfLd5NvNc03Ag7hPhfYF57xk1wpckep5t+BtJazvLzLNPJHp5crW2LxC8NEUZz7MXCDoLBB2F60BHXDs54mr2aBsHHXHNcMR1gCMuT9kPOeKq+rEYroMdcXnqxGxHXDs74vL0X7s64vKUvaeuesq+V/2Xp6566tcujrg8+9FTvzxtyFO/pjvimtWjbezVWM6zjZ7xRK/2Y6/Gcsc64urVOMczxqziiZeHDXn6CU++PPXrGEdcxzvi8pS9ZwxgY63lgY6BerXs3w5zYAfVCJ/xie8QfyNp7UuvHBi2z+Ri7VtQjt5QTD8gPybrk0SZ4VqY/T2Qg8vq1gn+jIGX/m0KGvOIhpUhv/jO5NP/i/9OzvDOFPyyzSm5nyjwNkV9lhHWY30s2V99sfpo+BtJR/pfC+mHkovSD6ur+pXlH9uvIVycF7by9Jku6hWQRz1W/oa/kXTU37WQXJSftLYvFLw0qSx9VgEcl/WJd9MmGRf3V/oMJcHHuqNFFsYb4j0Z3hfol/5YPTD8jaS1X8rowclEL0+m1vZTBC9NKksf7rtTBJ1TBJ3tBRfqEPsoK0+fDvViVlm9KOmPgnqh/Ka175Ry9HatJe37AfkxWZ8qygzXadnfAzm4rG6d4G+geAFpcLxgZcgvvsN44U0ULyC/JxFeJfeTBV41Xhncy43OoKhXy/7tUP+i/a7hbyQd2XMtpO9KLkrfra7SU5Z/rJ5uj7hM/04J0Cnq37H+KRUddzoLOqSzIJLOwg7pLBR0BkU99kOop/F+ofZXsX7I8DeSjvxeLWSHSi7WvtNK0at9i8dmpIc4jR+T9emizHCdkf09kIPL6tYJ/hka55EGj/NWhvziOxznR2icR355XlrU/2F9lhHWY30s119JM1YfDX8j6UT/x/VR6YeSi7Xv9HL0Zsb0L/Jjsj5DlBmuRdnfAzm4rG6d4H+N9PEM4InnK2cIfvEd6uMnMrzTc/gdSqKeC5SsC9T/6+lJq+wK1D/W6i8qV3/E6i8uV/+VVn9Jufq/afXPLFf/bKu/tFz9X7f6Z5Wr/26rf3a5+q+y+ueUq/8aq7+sXP35Vv/ccvWPt/rLy9X/jtU/r1z9c63++eXqf8bqryhX/warv7Jc/fut/gXl6i+1+heWq/8Tq7+qXP1tVv+icvV/YPXXQP0iaypW/5Jy9fuM34vxpeDJ8NtYtxrgazn/Gi4uM1oNwlWQ91qId+SP46WLgR62MQ/XxQVxTRdlZfpkTZLfLsQ/GOBF8XkQ/O60zbMdcZ3miGu6I67THXGd4YhrkSOuxY64ljjiGnDEdaYjrqWOuM7qUVxnO+I6xxHXMkdc5zriWu6I6zxHXHs44jrfEdcKR1wrHXFd4IjLc+y40BHXKkdcFznimteDuNLH4t8O8x3LO8xXnNJhvmJlh/mKNR3mG5Z0mG9Y1mG+4KwO8wUrLNY+F17Wsn9VLqBA3H9BjfAliZ4/Gf4G8VKQ3tj8aTnR4/bxeuN5gpemKGMbOU/QOU/QUbhmOOLa3RHXLEdccxxxDTrimu2Iq+mIaxdHXDs54tq1R3F56upMR1yesl/kiMtTVz3t8YAebaOnPR7viMvThnpV9gc64vL0E55jraef8JS9p7x6Vb88YxPPfvSU/Y7gJ4YccS12xHWmI64lPYprqSOusxxxecr+6B7l62xHXAOOuDx14jRHXOc44vLsR0++PHV1sSMuT3kd5YjLU1c9+9GTr16Vl6euLnPE5amrnv7rYEdcnvFXwxGXZ07BMyb3nCt45h4tvrc89tlQr5b922EOf2aN8Bmf+A7xN4iXgvSCOXxsH++NPq8cvRkx/YD8mKzPF2WGy9ZuB3JwWd06wf9+prRNgksfXt88X/CL73Bv9P/caSLvKFvWk5JynBOrJ4a/kXSkl7VQv2H7eK3nfMFLU5RxTBwrb4VruiOunR1x7eaIaydHXLv2KK5BR1wzHHHNdMTVdMS1whGXpw159uPujrhmOeI6wBGXp2176penDXn61R1B9rs44vL00eYL7VwixjN7EZ2isTfWN7gOz7us7vC8y6Udnle5sMPzJudYXLUKXtayf9VZkgIx3rtrhC9JdExp+BvES0F6YzHlRUSP28cx5RrBS1OU8f4hdR5ijaCjcM1wxLW7I65ZjrjmOOIadMQ12xFX0xHXCkdc0x1xecq+V3X1AEdcOzni8tQvT5+zsyOuHUH2u/RoG3ftUVyetj3TEZen7Bc54vLU1V6NATxxVeN2MVzVuD11+lWN21Mn+2rcnjrb7tVx21Nevaqrxzvi8pSXp8/xlP2Bjrg8bchz3O5VH92r8YRnGz1jX89+9JT9juAnhhxxDTjiOs8Rl2ee/HxHXEsdcR3liOtMR1xHO+I6zRHXSkdcO4LsFzviWuKI6yxHXJ7yusARl6euetpQr+p9r7ZxR/CFnnxVY8fLY+y40BGXZyznKa9ljrjOccS1xBGXp054yqtXx46DHXF5zvkajrg813Q88wCe+QnP/Tl8xgb3htWyfzu883hGjfAZn/gO8TeIl4L0aiG5YPtMLh3e/ztYo/pIT93xa7K+RJQZrkuzvwdycFndOsEfmBlTk+DSh8/YXCL4xXcmn/SMzb6NibyjbFlPSsrxFbF6wvdRl9TL4H3Uyn5Uv1ndpijj/FOsvBWu6Y64dnbEtZsjrp0cce3ao7gGHXHNcMQ10xFX0xHXCkdcsxxxedrjAY64PPXLU15zHHF56penDXn6VU+d8PSrvWrbnvboaUO7O+LytMcdQb92ccTlGQPwGS6Ml/kMV9E7sLF+3vdGrDx9Ovwezf01wmd84jvE30ha21wmZlfyV3Kxtl8qeGmKMs7nXSroXCroKFwzHHHt7ohrliOuOY64Bh1xzXbE1XTEtcIR13RHXJ6y71VdPcAR106OuDz1y9Pn7OyIa0eQ/S492sZdexSXp23PdMTlKftFjrg8dbVXYwBPXL06bnvK3jMG8PTRnvFEr+pqNW5PnV+tYvJiuKqYfOr0q4oLp06/ejUu9JRXr+rq8Y64POXl6XM8ZX+gIy5PG/IcO3rVR/fqmObZRs/Y17MfPWW/I/iJIUdcA464ljriOs8R11GOuDzXhzzltcwR19GOuE5zxLXSEZenTpzpiMtT9p627WmPnjZ0viMuT3vcEfRrsSOuJY64znLE5SmvCxxxefpCTx/dq3rfq23cEcZaT76q2OTlMXZc6IjLM57wlJdnTH6OI64ljrg8dcJTXr06dhzsiMszp9BwxOW5buWZZ/LMf3nuL+QzmLi3tZb9O13US+kMJVHPYI3wGZ/4DvE3iJeC9Gohuah90ta+y8rR26VG9ZEe4jR+TNavEmWG6/Ls74EcXFa3TvAfyhbgmwSXPnwG81WCX3xn8knPYH5g54m8o2xZT0rK8QuxemL4G0lHelkL9ZuyH2vfq8rR+3yM3JEfo3d5OXp91ldXCtzGy6uzvwdyeLG6dYL/FOnDFaJOk8rSh3UQy/rEu2lThOtKgQvlaH2S2sZHM1ko/U//G0qinuPYLxgOxF1SFy6LtS3D30g60vUa+zGjl+djlB5Z3aYoWwq/O+n79PcBPYprJ0dcuzjiWuGIy1Neg464ZjjimumIq9mjbdy5R/nazRGXpz169uNsR1yeNrSrIy7PfvTU1d0dcXnq13RHXHs44vLU+171OZ5tHHLEdZAjroMdcXnKyzM28dSvXo0LPfW+V2O5WY645jji2hFiuV7Ve8/YpBrTiuHq1ViuV32hZyzn6Qs9+9FTXr0af53hiKtX46+GIy5P2/a0IU95eY5DnjbUq7L39F+eeblezQ156pdn7NurMWavjh2XOeKysWOQcFt5+nS43rR/jfAZn/gO8TeS1nZ6rTdh+8quN/F+9l7xh5521Ku5ck8f5omrWm8qhsszN+dpQ5796Lke4Bnr9GoexlO/PPnq1XWdXs1RePaj514FT3/Pd6dibMR3p6o45PIAHaxvcIOiXi37d7rgr0C8tKVG+IxPfIf4G0lrm8vEZ0r+Si5q75rVbYoy3ocf2r+FdBSuGY64dnfENcsR1xxHXIOOuGY74mo64lrhiGu6Iy5P2feqrh7giGsnR1ye+uXJl2c/evLl6Vc9dcKzH3dxxOUp+117FJenn5jpiMtT9osccXnqaq/GE564qhhg6saOKgaYOr6qGGDq+rGKAabOT/RqDOApr17V1eMdcXnKq1f9xIGOuDxtqFfHjl6NfXtVvzzjaM9+9JT9juAnhhxxDTjiOs8Rl2f+/nxHXEsdcR3liOtMR1xH9yhfnv3oyddpjrg8dcKzHxc74lriiOssR1ye8rrAEddKR1y9qquVPU5dG3tVv6pxqNJ7xnWhIy7PGNOzH5c54jrHEdcSR1yeOuEpr161x4MdcXnORRuOuDzXrTzzE555E8/9TJbrsP2HOJdfQHQGBJ2BAB2sb3DTRb2hJOo51fbvHQUva4QX/XFfPO56jfAlWX18h/gbxEtBemN7F08netw+k6m1fZHgpSnKOCezSNBZJOg0RdmqLuCansPnUBL1XKL6u0D9N7E8DQfythjeF+jbvWN1aXH2u5G09l8ZXVpM9PL6xdq+RPDSFGXcR0sEnSWCjsI1wxHX6T3K186OuPZ3xOXZxqYjrl0cce3qiGumIy5PeR3giGsPR1wrHHHt5IjLU/aDjrhm92gbhxxxHeSIy+YvkxWrKjoLO6SzUNAZFPVq2b8dxiJH1Aif8YnvEH8jaW1zAXrBWETJpWgsciH87lSfPMfp4x1xeY7TvepjdnfENcsR1xxHXDvCWNGrcbMnX7s54vKMazxjXU+daDji8tSJ6Y64POXl6b96dZ7h2Y+efPXq2OHZj56y97TtHWnO0mvy6tVx29O2uzHW2nxlMdSrZf9OF/W6MVcz/A3ipSC9Wkgui+Edz9XOErw0RRmvG58l6Jwl6Chcg464dnXEtZsjrp0dce3uiGsnR1zTe5Sv2Y64mo64hhxxHeSI62BHXJ7ymuGIy9MeD3DE5an3nr7Qsx8bjrg8fY6nTuziiMtT9rN6lK8Vjrg8dcIzNvEctz37sVf9l6d+edpjr/poT1ye+jXTEZfJ3tbvlkDZRURniaCzJEAH6y+ZZDpqfpn+N5REPVfx/M1wIG7cB1tgLnl1jfAliZ67Gv5G0tpvZeauy4henp5Y288TvDRF2ZnwG8uQznmCjsJ1rCOuFY64dnLEtZsjrgN6tI2zHXE1HXF56sQsR1yeOnG6I64dQSdmOOLa2RFXr9q2p+w95dXo0TbOccTl2Y+eej/TEZen3h/oiMtTJ4YccXnqRBV/vTx8tOdYe7Qjrh3BFx7siMvT5yxxxHW8Iy5PG/KUl+eYtrMjrl6V15Ajrl6dW3nK3tOGPOXl6aOrsePlMXZ4zq12dsQ13RFXlVOYOhvylL1nG/dwxNWr8yFP2Q864urVfOGQI67KTxTD5RlPVH5i6mTfq37C4i++MyN9hpKop2brp2fiS8Jbcu24v0b4kiRu7fjMcvSCa8fYvrJrx15rVemzqsdx2d4H7PuziY6S87IAHaxvcIOiHusf9kEBfTg1Vv8MfyPpSN9rIfkruVjbzxe8NEXZhfAby5DO+YKOwjXLEdegI645jrh2csQ12xFX0xHXAY64dnbE5dnG3Xq0jbs44lrhiOt4R1ye+uVpj5765ekLPfma4YjLU+93BJ040BGXp37t2qNt9JR9wxGXp95Pd8RV+YmXh5/wbOMejrg844lelf2QI67KhorhOtoRV2VDUyd7z7m75xz54Oz3TNFmvhPwaEHn6AAdrH90gM7CDuksjKTTjfZMF/WGkuBTtx+cFzXciBf7qhs5YcPfIF4K0quFdFHlRK3tKwUvTSpLH869rhR0Vgo62wuudrrLOeGiunt2JJ3K5nunPdMTPQ4NJVHPW5UPKVD/SLZRw4G8XQHvC/iLFbH+yfA3klZ7KeOfriB6efZpbb9S8NIUZZ7fGdnZEdeO8I32Xv1mb69+X9qzjZ58He2Iy1NXpzvi8rRtT9nP6NE2Vv7r5eG/PNvoKfvdHHF56v3xjrg8bbtX7dHTR/fqWOvZj57fQNsRxqEdoY2efHn61V4dt8/vUb485XWsIy7Pb0t6xia9OqZV9jh1bezVcXtHmKd56sQSR1y9qvcrHHH1aq5jd0dc3fDRak3gTKJTdE0A6/fCGsd5HdI5r8faU61BVe1Jf1/UIZ2LIulUetA77Smxb8OeE2xt8Fh4WSO8uB5YYJ1yZo3wJYleFzX8DeKlIL2xddHTiB63j9dFrxC8NEUZ9iOWIZ0rBJ2mKFtV4apwVbhccPXw/jgLqcd8Dfom9rMl959E74/j/Scl/Xpw/wm2j/3slYIXnoekD+tI2TlNr+LawWORaX+422s3D3z4NVcfOW/G2T/ce/aDty360j3vWTTvCB6PDTfiRRkW0Nl6rI0Y/kbSkU3WQjqi/Ju1/dWCl6Yo43sFXi3ovFrQUbiOdsR1ePa7mjNsx3b645u//pHfv+e/femjm5595uFZ35jx2C5H7PzOLVv+ab/vz/nAD7Z8uENbvMzqv7pc/d2s/mvK1Z9t9V9brv4sq/+6cvXPsvqvL1d/idVfW6p+bazvr4K3Q1F1x9t+9Ri2QrwvtvrrytU/0OoPl6v/X1b/mlL1az+w+utL1U/+0+q/AV4O2Y8zfqPvijd88t837rLsthff/I0/u2DzjDlrv3jgXc9c8Tv3H/jd191pda8tR3vQ6r+xXP1drP6bytXfz+pfBy+Hoqom06zu9UB7Wnz96VZ/Q7n6C6z+xnL1T7L6N0D9ArIbsvo3lqs/1v6bStWvfcvq34xMZf++4n9/dqd/ee6++qf+9Acb3/yTw7b93rJ7/sevnvbAV448411r/vbh76+0uptK0U5mWP3NgnYbvsd83S1jb4rlsKz+mwvTTupW9y2q7nfe//g7my8+MDJ0+Fd+MrDsvn943Y+W9y/8xlfevs9vv+dn3/3Bg1b3VlX3q1f87Jufbm5761vu+czbFs7fbe3Ht339h3//u7//QvNHf/38jV8f09W3ZuAF27y71X9bufr9Vv/t5eoPWP1fKVd/J6v/jnL1G1b/neXq72z13wUvh5Kop2l13y3q7nZs8vUDv3XirYfvuWDjhbfc/q2Ln3/H7k+/8tvNvb+/+bRb/u0vNlrd94i6bZ4T+3/xvxuzjSgWg1ocmf7eB36n/9nBv7SexaB7A4zVrRP8zw4Zr7c5ozdIdQxH+kyn+gX7Yp8a4UsSPe8z/I2kte1l5n11osft43lfv+ClKcqG4DeWIZ1+QUfhOtgRV9MR1wpHXDs54prhiGu2I67BHm3jTEdcvapfsxxxTXfEdYAjLk/98pTXHEdcnvrlaUM7O+Ly1AlPv2r7XwdFvVr2r8UBe8L7AuPytBrhMz7xHeJvCD7LxAF7Er08ueySjI8Jmzdde921m25dsXHtuqVrb7h583XDHBlhNMRSQaz4rpZMbD2W9dG7PoI7h/5eIeolAncf0N0LypQkDKdFn9imvXLqoSwS8W6agN+TcO0p6hnvfYH66TMoeJhqjS0ZKQc1FtvHketegpemKEMZ5nkMFSEX5WuXZNybZ5Z01vBVm9ev2Lg+oYdV5+wcFvcmuBU5rNUE3hr9x+/3pnd9SdhUQ5OlGJVJklZnjKLem+hUzrhyxtuHM+4T9VhjZor3vGWyaChzkaCn6FzSIZ1LBJ3pot6Q/Xj3hz/6zSX3fOWYv/3ZznevXHv7W45/3x9f9o9v3fvZQ/7ujc/P+fjstM6fUsoH5c8O2PodUz6qv+oEf+4h4/X+IqO3C5RnFnbm5uvetHp4003XDt8y/AtfjYnmMRElQI7V/QL6+0JRTz0xY3hJxxPt6Ay/1xiuVCtvrIx3dKwQKBXEiu9qSXlHdyH9XcbRtYsa2NGFnBP2yjRB195NS/IdkXJinGsMObL0qYbml57iGrsjD80xGhs7NOdpbN7QzPX6k3wNrxPsv2VDRoeaPSHzxDxWY8BLTzUGbC9jQJ+oxxoT0uoYrUyS1iBUtX960iqPIfvxN5uW3r9pr+sX/OP0P7zn2NH99v/Wj5/99Ld/euvwwn/49nd+/aAfd2hdl3boFS5J6c7IXIP1P2YteHJn66AYBOO6p9WtE/xBs8brzcp+p5aXxcZmeZeuve7adWs3DZ+94cbNw5uH112wcdPwzUs2rDv7luENmwqHxMvo73NFPfV0cUG2L9YdTtWCrHCHazZtvGnt+uHVw2vXsUurU+2Qy8Ml8SSZ2Br8+3T6m/GsFnj4QbzsDpGekgS7w1oOzhipriZcWL9O9eo5dKYlYXeHOLge/h5MtCalz87QpqOoHM06fTj7Z1toBwAfwrBLMPhDMjeQLqUsW/TSb+VmjZ9Bqm/l6WNWeQzxPpREPdFBiuFvEC9lrfIYosftKxekoANnqSBWfKcsbTKDlOOgTEmCrRLbdFxOPdZcfjdNwB9DuI4R9Yz3vkB9xIH1WGPYinBgPUrQZitaAFZ03qJ8ukclrXJgS5om6JnVHUew6WNWdwK1aSiJei6LtTrD3yBeylrdCUSP21fO6lBTkMqlhNVgEBafS4EzhOe/uff6RT1+DE+deL4QwrPFFA5iu15BfCttx3ccPmN9g1N09uuQzn6CjmkybuU7nMrmBsoOgbJXUNmhUMYrSPOAz1VUNj9pbbOVHRHAeaTAmfbd92eN10n/WwxwStPZqy4CmlgX/+4XsBaz1Qn2KtCri0mv0IpZr45rw3dIr45L8uns1yGd/QQd6xPUX9adE0RbrexEKON+Pgl4Yd05WbTLyk4J4DxV4Ez75+9mTYRbDHDs8c+F90Wmq7Ee3/A3iJeyHv9cosft46n88nL0LqlRfaSHOI0fk/UqUWa4bA4xkIPL6tYJfmPWn02CS5LWo7yrBL/4DhOXbyQ9QdnWcv41vPyO7QvbvjiZSAf9zd7Az6Ycn4eRFNa1VAn7qhNhne7N5KuwPved1bdy9W+SxLV/cdLaxplJq2z2hd95+n1ugM6+gfZ0qz/3JTrHibamsr+N+nM5lPWJunYMsk7wB0B/3kH9qWxRyZnHpaJyfoWg02058/iyypEO+g1M+6X/rSFcLGfrJ5PzaihbQ/UuhjKEw1nXGnh/saCt8BuOdjr4yCzdtjwdxJzUhPaADn6gpA7yNR/YB4uTiXwaHygHhH9Nots1kAOf165RmHWuXDQRJ8YUqi/Y/xr8hwHnqkWaT2zXInjHyzJKH9aIdimZXpy0p41yXpFDeyAJ62Kd4H9VyFSNC2uId8T9SuJldRve2b6xvsENinqd+hHFczub/HRBm3x99pt19x9eMV7vN8gmQzqCPPM8oqic9xN0ui1nniNc7EgHbYbHhcsJF8v59dlvk/NlUHY51cMrFxAOx4XL4b26fkThjx0X/tcs3bY8HTRadYL/I9DB3w/Mi0M6eDGVoUwXJxP5bOcPX0/wxvdAEh5v6wT/1cC4oOwV9YbHBYP/k8C4YHSxXaFxQeniZaJdSqaXE65FAhfKmccFJVNs/yJqv8H/ReS4YPVVPuIwKsN8xHIqw3wEx6wnQVkoH8G5EcxHsL87FcpQRzgfsU+gPXOhjPN9mLc7gcowb3cilc2DspOoDPN2J1MZ5u1OobIjoexUaKvl7XjZ/IfZ+w7Xt+Tmn7y8KMPhv0kSNx7sQ3winWMc6SCuc4jOcY50eMUB6Zwo6Fh/nUT1hpKoJ3o90vA3klbbLZMnO4nocfvKrYygt2GpIFZ8V0smth7LJmM98mQoU5LgzDm26eSceiiLRLybJuBPIlwniXrGe1+gPuLAeqwxNXqftx5pOOoEv3OmFulotYZGa0UL5cEjpvGet7OAeTD4mcDDskUaZz2nXSfm4Dxo9rg8Zs3WOBOBU7XrZGoX83AS8WDwe0C7VtJa78mifpLzLv0bI6OTc/hT/cS84iiX1x7uJ4PfL9BPJwge0CZXtOGBYU7O4eFAwYPwbks33nBr5t0SetrtZ2LJ87rtCQJP3mP4Uy00jeT1DPZU6h1rgNVNW26fZxg7PHjd8KbhnLZPE7wpmrxV1J6YMbTkWlP0GMprTZ2OoSpHrMZQa7vKAzZF2WL4jX+3o5P2qX1OB3b05XVp7OBaE2wlSf4gW0smdgXW6eKSY2k1WFyOXuElx2KhFConSwWx4ruQ5Nv1tseJDrUYuljgVMnv5Tn12jm5aQL+XMJ1rqhnvPcF6iMOrLeYcLCF5IVSHHIY/OkwNJ23SLfT/n4D/OatW2qhqcOF7lmxVmX4G0lHVlwL6ZJagCtmVYvhN1LZlbAaDMLisytwhvB5w6I9K0U9fgwPa8lFEJiek/2embRqJx+/RR5Cw4c6fsupEtzUmLf1JX04ZRSzvUWVnSLapdJJvPVlkcCZym3b7IlwiwGulvNv+oRSByZntbUCNZa9n9raYbhWt8EVWtZaTbjWtMHFqVC1hMVpSFUPU6gXRfCA71gHLxI8DIp6ZfusGeA5tF0r1aGraFJ4MZSp0cJuseVlwM/C0sAw2TOmi3kZEHlmWy8q50sEnW7Lme34Mkc6mOLn5Sm1RIRytn4yOavlJauHN3rz0pJawlI3zSv8hqOdDt4yW7ctTweNVp3gPwQ6eGtgTAnp4GVUhjJdnEzkUy3jqD6oEd95Syl5y27vEgmUkL0iXysJp8HfBjh5eUotN6loJaSLl4t2KZleSbhUtIrt4QSKkinazbnUfoO/W8hULU/xUhLGDEWWp2KXoHiZCWMGjl/UEpTadog6YjEDH8h4OHs/PWm1lwIRr1yyMVzqKwm4zIVlSTLen6GvJGD90NcY5ndIZ76gMyjqWbs7lGP0/N/wex3tUvG1kgvHnFhX2REnU+dmf++X5XhS3XyG4lk8BMVy5aW6oSTqWRArV8PfIF7KynUfosftY7nOFbw0RRnnteYKOnMFHYVrZ0dcxzvimuGIa7YjrqYjLs82evajZxt369E27uKIa4UjrjmOuHZyxHWAI65BR1yeOuFpj5425KkTnvKa6YhrV0dcnrJvOOLylP10R1ye8vL0hbMccXnKq1d9oae8PH3OjhAzeeqE57jtKfv9HXF56r2n7A90xOUpe882evoJzxjAU15DjrgOzn5bjgnzEEcTHTXn3ydAB+vvE4FL5Q9CbVR5HMd7141FXibOCwNqAm+N/uP3vIGgT8AibrworovbdY6rEb4k6a3tOkV3bV0Av7EM6SwXdBSunR1x7eKIa4UjrjmOuHZyxHWAI65BR1yeOjHDEVfTEZenTnjKa6YjLk95NRxxecrreEdcnro62xHXjtCP0x1xecrLcxya5YjLU169Og55ysvT33vql6fP8bRHT53wjJk8Zb+/Iy5PvfeU/YGOuDxl79lGTz/Rq/HXkCOug7Pf6nDE0USn6O1UWP/cCFyLBa5QG7ucJjEWjyW4vDCgJvDW6D9+fyy9a5cm4V0578uW6i0tcjThGkriHrUbzHDNJJrpb9zthmVJEpepw/pzA3QO6ZDOIYLOoKhn7e5QjjNQfsgnvkP8jaS1zWXSS0cTvTy5WPsWl6M3WEtaTbVP4DR++IyQcitmPwM5uHhnqME/mel+M2l1KXyyIdZ1pWnIx3abyDvKtpbzr+HldyGXGKOPZemgPvFFj4uhjO14MdHJc8vKjhfn4MIdz9cCzKkEj/2scB4O5Qj/q1l/paHlpdl22nY72Z/frT2vJwpe+XTUu2En+ycynErO1u9KDxZT2VxBV+Fk32hlSRLXd4cIHkK4sL8OJXjri4EceMPHffdZ6DveMY8X2Cj9WZzDA+oP8pCnP/+jhP58frf2vGLdQ4m2wV8N+vPbpD9YP6Q/vJsX9WdxMhEnlvFO66JjK9YPjeHHUZniPTSOHR3gQclI0bm0QzqXCjrdHh8uJTqnOtJRpxjVFOBV8BvLjA6/YzpYP3QJ6fwO6cwXdPoEnSMABy+1GUz6WJyEcUSBOKke0y+Iv0G8FKQ3Fgeq06BqKsiXQWLdpijLuzQc6YQupERccx1xnUS4lN68SuAqKq8uTCsvJbiLc1jrE3hr9B+/v5Te5U0rDbcyybyrIJIkziTVPX+TZfqKzoIO6SyIpLOwQzoLI+mc1SGdsyLpnNkhnTMj6SzrkM6ySDovNz2YrPac1yGd83qsPS+3/pms9qzskM7KSDqT5Xcq+ynXnsp+drz2dPHKp+jUueFvJK1tLjNlUitLSi4dTgnHUuehbyEhP2qKhrJN/yv7fY2l2SWMPKVKkrhLgdT0LE1hnZHhVZcNsd4XXbXE+gan6CzskM7CSDovt/Yc2yGdYyPpTJbcTuuQzmk91p7J0oMrOqRzRSSdyh/0TntC3xlN/frG3TVNXO7AupZm5SXbw/car3cTjRVzof4AtbHo0gTWDy1NHE1l2AZeejtC4KxRGfJ3RIA/rH9ETj3kJ334Gw8Gkz7TqT21pFBsEn2JDW9bOLIcveC2BWwfp6tPFrw0RRnKMI/OgKBTI1zt+HJMCxuLhxNc3uXuNYG3Rv/x+8PpXV5a2P421cduZtVHsYREpVT/yEmmw7jwkn7l+uoEvzL7hlDqvu7N3FfM3VJ84f1QEvUcH2uWhr+RdOQGaiH1V6uj6n4zq6tWGs+B31iGdE4VdBSuQUdcuzri2s0R186OuHZ3xLWTI67pPcrXbEdcTUdcQ464DnLEdbAjLk95zXDE5WmPBzji8tR7T1/o2Y8NR1ye/ejpvzzltcIR1yxHXJ7y8rQhz3jCU15zHHFVfnXq/Kqn7Pd3xOWp956yP9ARl6fsPdvo6SdmOuLq1Xj1DEdcFq9a7gHn6HOJjpoPnxygg/X5861Yr5b9O13wV2De3lcjfMYnvkP8jaS1zWXyBEr+Si7qFJDVbYoyTt8VXbpGXPxxUJWqPVrgqlH9dm10TAUai8cR3Ooc1qYJvDX6j9/z12vzUoGGW2XBT8nhO0nisuBY/4gAnRM7pHNiJJ1DOqRzSCSd+R3SmR9JJ3Twgl2cypAfHeAhtIqCdM7ukM7Zgk6foLMYcPBKSfobV7Pm7DGRp+OgrE/U5cM7Bn/ZHuP1DtxjogxQPnbfmrqKjr+SjSs+PDzgF8O7sbpj+BvES9nhYR7R4/ah64z/mBpbKUoFseK7WtLq2WrAGb6bS3/vQ/VWiHqJwI0edT6UKUnwR7qwTfNz6qEsEvFumoCfR7jmiXrGe1+gPuLAeqwxNXqf94lCw1En+GMzq1Jfe1a0UB6cADHe877gyzwY/InAA39FeB7UUe1ia55Pf6MnOD2H/nngZU7eQ9NPBH1uH44OeV9Snkc8GPzpIAP+MvQRon6S8w5lgHXz/kbYvagt/KEP1kX+ivSRbdrO/W/wZwX6/xDBA172uaINDwyzVw4P5woeOvuKNHs57iXuiUMEnrzHpJFqrGkvS4etg+nY30oDOv2K9NwcmtMS/Qwmmrf0mZ50NFZGj82Gv5FozRtKop4ae0+jx+3jqds8wUtTlOVZaTs6HX5FOm/QVs6C6ydUtybepQ9eUWsDNc4ueTqkZo74LjQdMjhF58QO6ZwYSeeQDukcEklnfod05kfSmdshnbmCDuPKm0Jcnf2uE/y14Nj56344vWec6cMHRlU2Zq5oj8EvFvCnijaqDNniCNooSx4Izy3Ia2iTPtJX92QsL8jr6knmNfQ1wi4ctIgecqbqoEWx6SBqLEsFseK7WjKx9VjGI8sRBLeM/i4zHfT4ZnNIsxLxbpqAX064lot6xntfoD7iwHqsMape+vdbRJ2QBcRocPpwELPKEddqgcssE79TW8BS9oi1TMPfIF7KWqb6frM64mNtV9+JbooyzuNfLOhcLOgoXCc54jrZCVf6rKpwVbgqXBWu7RyXWjtdTWU4fhoONTvgGWrR9XOsf3KAztkd0jlb0Amt0/O/RoffMR3Fs7UHx26WW9GbkbA+f5/8OCjDxbAv7aFp4kwW616b/a4T/BlwNuJ398hvI8rZ2sU8TwcaVlYgrpmZzqYvp5v8MMbpB7x59oMx3Kbst4oljqYy7Gv+1nteH/wR9cHJUKb6wPipE/w86IOvUR9gffYfym4UPdaRgRz4k4k/g/8zsYyg+Ds3hx7KA+X81hx63xTZFaV3RrtDvdtD6R3aK+tdbNwdq6d89gb1dDHhOk7gQj3gjI3VH0h0Hxg+viH1O6LPY/Wc+9XgvxfZr07+RPYryor7dTGUhcahkB4sBhiTSTNp7fMTCNcJAhf2dUy/Hifwc7/+NNCvakMF8sn9avD/FtmvJstu9CvKKqZfEZ77VY3fiwHGZNJMWsfJeYRL+ehQhnVx9vdAovuAfbTB17MxRPWrynKH/LDB7wQ4p8oPo6xi+lWtBMT2K/th7NdFVBbaqzhZPno30ecc87NfyONPya3DxT1ei16ew8buon5CdWv0bvccXIYnfYdpVRa5NTfv4msWucHvK0SuzBT5US7K2tPhUePoRQE+anxcOXrBo8bKpRY9alx0WOyCqqbPshw2aqJ+Qrhq4h2WKVXF9UFTVbUdEkfoOTRTQBWKuQxKRf4GbxFoXnTBF1QZ/BGBUSgUBacPe+vLBDxGxrxNFttwGZVhvXNz6ODoiJ6fR0eDPz5ydDTa3RgdUUY8Ol4OZX0CnuV9pYC/HGA4q3QllLFJo4wvIzrtXAfrv9JTNftW0fiJgfa2m5WxfqFOcBZNzeaULhhcNzIl2B7WhZAtpQ/LJqQ7KJtm0l5P0C5570PIL6VPSBcwu2DZsOmAG+kMJVHPPKOjVp8NN/ZngT67GnmyRw3V9q5BvJQdqvuIHrePh2rWyfRpirKl8BvLkE5d0FG4mo64VjjimuWIa7ojrgMccQ064vKU1xxHXJ76NcMR186OuDx1YidHXDVHXLs64vLUid0ccXnqxC6OuDz9qqdte+pqr/pVT53w9F+eNuSpE57ymumIy1Nesx1xeeqqJ1/VuD118vKMVz19tGcMcLwjLk//1as64eknenUc8pzDeLZxD0dclV99efgvz35c4ojLU1696nN6NS5sOOLytEfPsdazH3s1Xj2/R/ny9KsHOuLy9BO96qM9+fKUfa/6Cc+YfEeY13qO27v3KF+e81rPfvS0R885jGfe1xOXp06wDdWyvxHmcPh9GJQjvH0op8O14nW8Fms4EHd/Sdw1wpckE/lMCP+goGd8NXLKhpLw895P/vbjK/7xy9+tUX3jhd/x/oQBAa/WtE1WqCsFZHWV2sNhtK0MdaSfylAuxkP674ZFE/kbKMlfjPwQf1PA816x2L6YlbTakcnJ9sUgbj4lFfqgItJpivqrAnTmd0hnvqDDuPI+oHV19rtO8CdkfkHdF6L2wMwX/Bl86PQJ8qNkwyeb1Gn4GP+AfKnd0icSnTWOdHCv1WKic7EjHXWKXe2765QO7qvi04yXO9LBPVpzic6VjnRwX+DRROfVjnReDTCnQr3079dBmfoY21rBh/niq+B9AV9cj2kH4m8QLwXpje3vuorocft4f9c6wUtTlF0Hv7EM6awTdBSuIx1xWd/OTFr7mj/m+DpB53UBOgsi6SzskM5CQWdQ1OvURpRsjM5VjnTQZhYSnXWOdFAP9iY6w450hgHmcKKzXPCQxgPX7TX+Pv3vGijro7rpY+NLneDrrxivtzHDaTq4FmgjjxPqw/u1oh1MbxPNWdZDnQL+aMKcMyFc7WR3C8luLZTFyM7gvz13vN6tJDtsF9v2m6DsKiq7HsrWUdkGKEMcWJZAG/Ad6xzWN7hBUY/Hq43wvkB/9cfYBuJvJK1tLjNebSR62Pb04bnbDeXo1Y3eTYKe6oddEy1TpG+4zMaUn11PZegbN1AZ+rPrqQzt+zD4jTjz2sQ3kSF/rN/I32oqw5h+DZVhHM7nITB25rM42GaOb63N/YQnfWweUyfYx+DjxA9lv5W/YT++VuC2smtEWYr/E/tNbAv6FJQjlqVPn3gXGkMNTtE5q0M6Zwk6jKuetM4t04f9rsF/hsYQ9GUFbHa9yf96eMn+rqT/WR/r7/J8L/KlfGFM3qv+u09/4bNv/PGqomNEyHeeJeA79J0y72W0Vd5rA5Vh7sl4UHmvkmPXVTHyQ/xNAb8U4Ir0hcJ1sRMu9rmd4irLl+X2MPbh+Eadn8Nxiceg1QG+1rfBxeMS1mcf9qY2uHisWi/ayHEJw/UL3Ex7MGltG/uykn4yOtdg+BuiDWViNyVbNdawH8e6TVHGOn+9oHO9oKNwXeyIi/OlHnlMpcNnEs9Fb4bD+hdT2RpBh+fM6W+cj31tL80P6j3OtzkusL//BOZjX6f5GNIOxZac01H5b3WOXOV0QnTO65DOeYJOt/PfnNN5kyMd9E3nEZ3rHemgvXFOZ4MjHRwXeS5wseAh1dl/IDvYCGXKLq1v6gR/C9jBPwXsAHnE+hhrqdwU0/sxxeMl40CZ0zFc7WT3U5Idzu2U7NiHGPzlILt/K+BDMLZ8E5WhPK6nspugDHFgWQJtwHesc1jf4AZFPZOv9dfN8L4bOR3D30ha21wmLriZ6GHb04fnJZvL0RvL6dwi6Kl+wJwOyhTpGy7O6aCfHaYy9I03URn6sxuoDO2bczrDbdrE8bTiL5QLn6qYc7gcvWDMie0rG3OeDr+xDOkUjRM9cHF+bipioYUd0lko6LxcYiFe39pRYqEj9h5/j/49djw3+H8/eLze0RnObsZCJ2Q0pjIWWkCyKxsLfRNkdzLJDmmzbaOcOBbCGIVjIZQVrzdaWQJtwHehNVWWG9bj8apkbBIdCxn+RtKRfoyNVypGVONVh7HeWCy0WdBT/YCxEMpUxUWhWIjzC+gbOd5Bf5aXi01/cyx0cZs2hWIh3gOGuYv0b9xfwWtKBvs/wc5WZXam9phdmkwsQx1/HdBdQ7aKcuH8ZdHYAetfT/x4jE1qrZvzVUVz1Fif10SvF3R4TGf/+tq9NT/oXzEeYP9q8J+Gfl9LfYa02U8izxyjFe3PBZF0zuuQznmCTrdjGo7RuhXTcL5qoyMdHC85RrvBkQ6OQxyjrRc8/HIfDdnBTVCm8vWcrzL4S8AObg3YAfKI9TFGe5NoB9N7B8VoJcdEGaMZrnayexfJ7k1QpmTHPsTgF4LsbivgQ3BM3kBlKI+NVIa5DMSBZQm0Ad+xzmF9gxsU9Uy+1l+3wPtuxGiGv5G0trlMjBabP7L23VqO3liMdpugp/oBYzSUKdI3XByjhfIe6Bs3Uxn6s5upDO2bY7Tr27SJYzSl+13c7xGdrzL8jaRVjmV0S8VCahzmsQnrqr7hfJXaC6JyrgrXmxxxcb4K18M5FlL71q4K0FkQSWdhh3QWCjrd3ic9VfmqbsVcHAt1K+aKjYV+ncbzG6AsZjw3+D87aLzeZwLzOF4rugHwJQL+8Bx6/4NioZL5DxkL8RpUnuw+T7K7HspiZGfwnwPZ/XZAdmzbOO5wvio2TuLYVK1R4btQ/M0xJNbj8apkbBIdCxn+RtLa5jLjVWz+qMNYbywWulXQU/2AsZBar0NcHAuhn+V91egbOd5Bf8bremjfHAu9qU2bOBZSe8YYF54tVzknnnf8RWZfqa19g3JWap9yCnfVPhPhqjhsYl3V92+G31iGdGJjp3WOuKo4bJwOvysSh3UrPuI47OWWk8rLzf5HRE4qlJs1+NccNF7vvwKxRExOKhSHGXxf5hsnIyeVJ7v+fSa2RcVhIdkZ/GKQ3fQMZ0wcVuWkxvnEd4i/yknl56RCcVgv5KQUf4wrNg4z+CHyGyXjJuk3+GxSFa9NrMv6kz5LAY7LisZYw464qnhtnA6/q+I1Hzpl4rVFFHOUjdf+emi83pmBmMMrXlvWA/Hacqd47UtD4/VWkOxi7yrgeE3ta1exHI+DRfNmWH9Hy5up8Wp7zZuF1hA5JkN/xnmzULzmkTeLzXExzby47jIqN/j1+4zjHKa8GfK1Hmj/Y5Vfe9nk1/hOBsTN8VrR+60WCJ4VnYUd0lko6HT7niaO19Y70kGbf7mvc+bFHHeQf1PrnKGYw+CHh8brvTcQr3mtc95L8Vo31znzZLfVKV47d2i83raA7Ni2cWxk/1Ktc770VOuc+fFa6P4o9I1e65zr27SJ4zXkL3TXkL0LxWEG/6vkN0rGMdJv8L40dZ9sh/fkRcdrhr9BvJTVf9V36k4JdY6S7zTDOG8pwHFZKC5U88VhR1yhOKqK1ybSCcVrw450sH85XutWXMjxWrfONsTGa79HMUfZsyrfPXC83lcCOSLO52wAfImAPzyH3lfJ7+I40anfNVztzlF+LWcuH3uO0uD/AGT3dZId0mbbRjkNUxmOqRzLee69xfosNzUX6fDca3S8ZvgbSUf6MTZeqfOloXtCS84fxuK12DssMF5Td4MirlC8xuco0TdupDL0Z6HzchyvrWvTJo7XlO6rHBeeqeQclxqXpos2FuijmbE6aPgbSau8y+igupNDjde7/OK/Q7Lfmzdde921m25dNrxp1earrrv26vOHb715yYZ1q9betOnatdctWbfupuGbb0amkdAMeI/l+DCM/V4t3iOO9W0aw8qAnRVzyR7i4gv71CV7huv6Nrj4wj41uPHf/Ukrn3bYd1oEHjS0PL74kL1afAk5eVTOtxEurJ+XcMnD9XbChfV5cRGTRcwnyyuEJ8+BIl+/QnzlHUJP/9vcBteNhCvvcp/0v1va4HoH4VKTcP67P2nlk+UVwpP+d2sbvt5JfOVtvkn/u60NrjcSLrV5x3Dd3gbXtYQL62Nd/Ls/aeWT5RXCk/63pQ1fm4iv26FsC5VhvXOJTtFJGtafrEnauURniyOdLQCzN9RL/74DytRlp+oQkw3+d8L7biRMDH+DeClIb2zwv5Pocfs4YXKX4KUpyjjJcZegc5ego3Ctd8R1B7Un9yKgfSfSLHuZza/BJOzoDKeKPbZQG1Ucoy4jrVG7BgQ84qsT/AkZTzv94r+V2cXVykbW5/DC42nMhcBoX92wEcPvdSHwHUSP28c2cqfgpSnKOGmhbPFOQUfh2uCIiy/ay7ORpU428iTYyDk9aCPnO9gIxlAxNtLJ5ZGIz/jBd4jfy0ZULBuykTsEL01RxhvrlS3eIegoXDc74oq1kSucbOROsJHXdNFGTN6xNmLwVznYCMbNMTbSSTIM8Rk/+A7xe9mIujQtZCM3C16aogznTFiGdEKL44jrVkdcsTZyo5ON3AA2sqkHbeTWgjaieO/G3Evlr46F33kyCn2A51jRHjXHO5bak6cjt+2r+VE6kv62+TsvrL8WdOSOgI70wsLqaR3SOU3QeblshDuN6NzkSAfHFV5YvdmRDvrK2AtqHyc72Axlyg4sX1Qn+J8fMF7vyYAd5OUs6/B+WLSD6T2d0ehw45FcWDVc7WT3jNM48zcgu48W8CEY07OPR3ncRGU4JnPeV+VX8R3rHNY3uEFRz+Rr/YV5y24srBr+RtLa5jKxlsoVq4Of1r4t5eiNLayquYTqB1xYRZkifcMVWlgdpjL0jbdSGfqzW6gM7Tvmsn5sU2gjHMd+aoPNVG0yK7lAG9xkhu3jOP4mwYvqm3fBbyxDOqEPcSCudY64bI2h2mTW+q4XDwXsKLHQnxeIhZKkdTw3+NtgPP/LSYiF/rYHYqG/c4qFrgHZfaeKhULPdhML3V6O3lgstEXQKxILqTXtl0Ms1Cf4Qzi0PZVPSsS7WoAe05gm6r6b+MayK4hG0RzQFYLfLuZ1+2Lta3vJ6/Iaeie52JiYp8MNjNHx+GRsYLwC3jltou0L9cP6AL2Sa3nTjF5obxfSS/3pQNLah+0+hII0sL/ybL7sfsqb2uAK7afkdcCb2+Di/ZR5G5ex7Kjsw/epHz5gv4kwthfwYIAZyn6zTaEcfrmXhOBCHwLq5EM5iC9JtO3xRxE7/RCQ6oe8D/PslIR1BPsob5/pRtGWGJ0NfVhH8VO0T9Wm8hTumADc9QJO0Ur/Vh8W51j8+AxHKudbF01sI9bnvcmrx0mPyQvfhQ5nsM0inQUd0lkQSWdhh3QWCjqDol4t51+jw++YjpJN6BBmWTqoY5wbGHakg3bDuYFu5To4N7BO8JDazHn7jb9nWwuNF3WC3wnmtysznGqPft4HrjA3EDqAZvCrMxqTcbFenuwuJtmpA2gh2Rn83+8/Xu+ygOzYttWH7tWZgWEqw7GB99YVPYCmLoPYUQ6ghS542h4OoKmxTvlGPoCG/owPoKF9x3zIL3QATY3l6eGqzNXA4arzh2+9dO11165bu+najRtWD9+4efjmTXXArEYO9vDsifFqqLynRn9Po7LVVL5KwOETGk07vOIgOvI1/I2ktRfKWI460aWiDL6qB+uqqyreA7+xDOlsEHQUrqsccfEnKqqrPPPphK7yrD7ZnE8H9S020nsfRSt4bDcmWrG/3wfRyr0UreCowTvt1wG+RMBzpGfw2yjSK5l1k5Eer76jr0PZPRQhO/RpebLbALJ7lGSHtNm2UU7sX7C/+TOCKCvenamygWp1XkUEk7BrITrSm4xdC+pqnA6vvhiL9FRkqfoBIz2UqTqJy5Ee+tnVVKausQhdoaN8UEykh22KifRMt5YLOla2FsrWUNk1os2p3X2C7A4/F72M2mFl2A58xzayTPCj6PB1VtbGL5OvK3nN0+mDRMdwIO6rSuKOtcu8uAH5aoiyegQv/7Lb4iP/eeSHj9eovvHC76YBftRlhF8m4Dscc04ZBBoJ0bYyHA+vorJ+KDMe0qzlhkUT+Su5MnRKjPyU7WMZf4qyaKyJuNaUxDUrmahXaDtmf+hHLs9+DyatNs12UtIGo+dbhr+RtMqgzPilfK/yWewjsG5TlPFVvJcJOpcJOgrXckdca7Pfqp95vrVc0FkeoLNA8KzoLOyQzkJBZ1DUq+X8a3T4HdNRspnszPpljnRQD3i+dbkjncsBhudbeXOG79Kc4Sooi5kzGHwT5gz/EIhdkEesj+PLGtEOpvdDikFKji1yvsW7K/Jk9yOS3Rooi5Gdwf/znPF6Pw3Ijm1bXW+l5luXURnGCZxTKjrfwvo72nxLjfHWvpI3eYzNt1Q+ssh8S90UxfMt9LNrqEzNo5U/45gL7ZvnW2vatInnW4q/KhaKi4XSZynAcVnR+OV1jrhCMUoVC02kU8VC5eiUiYVeOWf8Pfr3orHQNhjPj8h+dzMWOjajMZWx0PEku7Kx0C0guwUkO6TNto1y4lhI5XRUnMTz+qKnkrD+JOzQjY6FJmOHrhqvPE4Epv+1u7lTxUJ5uxJ5vVz5Wc49q92Ayp9dRWWhWGh1mzaFYiFed8e8McOugvYi7Eqws5vn5NO6kvhYBWWvprJY+0QcKF/0FQh/NbXB4C/O+E5zjW9fpHFOS7SOYv4+SSbajbVjOtC1sgL6+4WUr8sXjdNBfUkfzJuiviRJOKYy+CsFPOocx4ZXQhnHc0ofMb4wfVTyMh67IS/kIUZeag0sVl5s9yivtYRLxb8ow5C8jMduyAt5iJGX2uMSKy+TgZLXNYSr3RxnBcEb7oFE+wSOHwz+BvAJfCtPyMevErjRN9YIB7bjUNGOQSrDuinejbu/9Huy8jwca6obd9B/4z4IhP8VGDe2kmzUOB1a31I5jtBOUhzHr4/AtSZAW+2duj5AG/niPTK8N0fFG8oPmGw69AP9yg9gvor9gOondeIpJCvVT2rNnffGxeac+GaF2JwTnrTYmjMnwXbk+Wy2B5zP8FxHzRNCuqfiZ7Rj1j2VY1X2z35D7atRtsR+A/uW/UbZnfBP0hy1GzvhWb/ridbvvB3unwbfNprj2/oL4vwwjEerwEaTRK+3d+gL6soXoL2zLwj54PQp6jfZbkP7V9W6OcqUYwKT0YCAR3y8N+/FyJggtLs8lAMPzfvMHlK5fzXjo90eyF8n3UOfpuaKeSfI/gT0+TM0x/PwG5dTmdqjFRpzlJ6p3fv82eTQje0l951H51J433mnN7bHrvN4fHI5/W+joKf6AXMp7U5vmq+abL+Gcorxa2qtSe0hZHtGH8F+QO15VWsxTA99BMbiX83JQWM7YmMWzF+/kuwf7YvtH2089CUbjhtQhhw3bABeVMzDnzg3+L8AH/ZPJBuly6E4Vu1hxX2pfKsN6voNEbiGA7RvEvA3BGgjX3wDFJ84VzapbNFk0435BsYFbIuqn9Q5lZCsVD+pW2BuoLJY2+UTYji+s12jbuNJ1H/KGbexHSrH2+50+q8H1pB6OVfwb2C7g/tPxFnlClr5rHIFE8smM1fA+umVK+A9YlWuYPx3Xq5g36wvejlXcAzsd9w/x7cVzRUMZXiqXMHU5QoOhz6YylzBBRkf7XIFx5Hulc0VXAT6fGL2u8oVyKfKFRC9KlcwNbmCC8j2vXIF36U96NtLruBV4MPeRLKpcgX5NlnlCorZrkeu4E054za2o0yu4Dgau5FvPq+vbErZPJ/XXy9kwf2XlyswvHWC3wy2exfJJvT16PQpaj88Z1L2E8IV2mN0s4C/KUAb+eIb2NmW1Rn6Lo6j0nbRPtl2Qz4zfWJkpfqpSfAoG3UOife94Ti0kcpwHGKbR93GcZf1U+1tih13ca8R398x3AYvyzP0JQs1bqgcSuiMmLJ/9huoo+w3sG/Zb1h/oq4iPOcKDP5hyhWUvHFV5gr4CwF4b4XSb55bGfzHwbc9luPb+gvifCIyV2D92I2YGu2dfUHIB6dPUb/Jdot9w3fGxN7gxnY2kOgYIm/O/GwgV4D+iOMMddOk8kfsx9R9Sqncf49yBWi7mCt4gXRP5fXR53C7Df4roM+fpHjDw29soDL0A3wzpxpzlJ41RX0cQ7me+YEOb0qMzhXwLfad3uQce4u9x03V6X/qi8F5N0crmaqbzEO5gm76tdB6SDu58twd28j2jD6C/QD6CPYf1wfoqfkd+oiQj4ydb2DM8j7KFagcq7Jxtn/Ud44bUIYcN9wMvKiYB8dshP8a+LBvk2yULofiWHWjP97Gz+swoa/9KlyhPIX6Ss4tAdrqKznMS5Lk26SyRZNNN+YbGBewLap+Ul/QCMlK9VOT4FE2RW33ZirD8Z3tGnX7Jmjzt3PGbWyHyleqeADH/Bdo7O72Lc55Y3dens/wcuz7Q7Dd+gETcSr/rG5AZv+B8OrLe6H5eghXaH0spL+KNvKFdZk282n1lO2abLphu57zAyUr1U/NpNWu2QZjb5Rm+0Q74hyguutQ6We7s6yhcRfXlflW99C+i/RheYbyrEr31A3qyv5DuTX2G6ij7Dewb9lv8E3hDM+5AoOfnfVFh1/ykbkC/nod5jOUfvPcyuDnwxcK9sjxbf0Fce6d4WmXK7B+7EZMjfbOviDkg9OnqN9ku8W+idkLpr4uw3Y2kOicJe55Qfi50AecK0B/xHnN2Bvuee+U+spGKvdzMj54LSb9jbmCw0j3VF4ffQ7rnsEvB30+Mvvt6Tc4b6lyRqExR+lZU9THMZTrmR/ocC4dnSvgrz6VzE0Ev/qk5jsd+s2xXIGa46h+wFxBuy+dhXIF3fRrofWQdnLluTu2ke0ZfQT7AfQR7D9C+xhULgx9RMhHxsYsuOZ5HuUK0L5C62Khr7+F5tYcN6gvCqs5V53gV4EPu5pko3Q5FMe2m69z7lPN10O4QnmK2wT8rQHayBfWZdp5Nqls0WTTjfkGxgVsi6EcTfrEyEr1U5PgUTZFbXczleH4znaNuo05sKtzxm1sB47bbLt5+cPDaOwOrSt6fA2a59a3AS+8Ds/jAMJfD7b7LpLN7cn4E6MTWwT87QDDfgp1YksErtCeoDsE/JYAbeQL6zJt5tPqKds12XTDdtHe2HZVPyF8jKxUPzUJHmVjZWqfjbLB26gMx6jQl6lvhTazfqr1/7w7edgecE8Qfx1e+cKQ7rUbs1j31Jil7J/9Bto/+w3UUfYb2LfsN6w/UVcRnnMFBn8v5QpQRwrouswV3EE83g48KP3muZXBfxh82/05vq2/IM4HI3MF1o/diKnR3tkXhHxw+hT1m2y32Dec01F5B5Qp5wpMRgMCHvHVCf5DgVwB+qPbiXf0RxyDqNyx8keYK/gi5QrQdjFX8BHSPfRp7C/Sh3XP4H8H9PljFG94+I2bqQz9AMfWasxReqbWinAM5XrmB8yvoC52I1dg+BtJa5vL5AqU/eH4wLmCkn5zLFdwp6Cn+gFzBShTpG+4QrmCbvo1lFOMX0N4nrtjG9me0UewH0Afwf7jpgA99BEYi3+RbF/5yNiYBefnf57FLMrG2f7Rxtn+Ud85bkAZctxwB/CiYh4csxH+D8CHfYtko3Q5FMfeJeDvBJhbqD2o63dF4Lo1QPu9Av6uAG3kC+sy7TybVLZosunGfAPjArZF1U8IHyMr1U9NgkfZFLXdO6gMx3e2a9TtLdDmb+WM29gOHLfZdm8RvGI8sL3lCr4Ltvszko3yz6FcQdH5OvqwOyJwheZrIf1VtJEvrMu0mU+r10u5AtVPIR+rZKX6qZm02jXb4GTmCn7WpVzBMy/zXEHMmI+6ivCcKzD4nQ986V+LP1FHCui6zBXcSTxiPiNmXm/wQxmPaR/POFDjjM0VGPyuGZ6pzBWgvbMvCPng9CnqN9lusW+mKlewH/RBKFfAeU3vXMEZGR/tcgUHk+6VzRUsAX0+JPvdzVwB+gHOFagxR+mZyhXgGMr1zA90OJeOzhUY/kbS2uYyuQJlf6FcQUm/OZYrUHMc1Q+YK1BzEcTVi7mCdnLlubvKaRadb7D/KJMrOINs3ytX8LhTrgD1neMGlCHHDXcCLyrmwTEb4c8FH3YlyUbpciiO9Zivh3CFcgV3C/j3BmgjX1iXaefZ5GTnCjAuYFsM5WjSJ0ZWqp+aBI+yKWq7d1IZju9s16jbmAO7MmfcxnaUyRVwPKDONiifUCN+ET40P2m3dzS012gzlam9+kwHfQL2yabsN+81uiYypjbaHer7zG7vo2k3H+SzM+i7ec8LyhjPI/HYgGdcbqOxAXNRW4jX0F0PXBf7YCAHnveTGfxmEbOH9Dl0/quoPmMbOtVntI1rqa0G//bJ1ecZU63PrLOoz5wTUvpcS1p9WCf5nBt7UP/fvwPp/7Ye1381lwjpf7scCes/xm9Tof9XFND/OwI0lf5b2/L0H/OJCP90QP+VfEP6326NMKT/d1EZ1luXQwf1H/ud9d/gn4vUf6PdDf1HGbH+h+ZN6VN0rsNrAhi/h/Sf12u99H9pAf0Pxd5K/62tefpv+Dhf/tmA/isbDJ1jLLrWhW24k8qw3rocOnnxPOu/wX8hUv+Ndjf033P+2i7PwPE82kZI/3mdw0v/jyD9xzPunBvaIHCEzrGH7q6wdqgzm+pMH5/Z/GPIDf1fmiOrGAn39HdjzhvCFbLPdndjMG11Nwbzkgg+rV4Xz3/1d/tcq5KV6qcmwaNslG3xGXf0gaFzJXxWRd1dofRTnXGPtV084/61fSbi3dgGb9E7XPkOmg2ifcr+Q3dCsN9Q59iVrrPf4DuQGJ7Xog3+x7QWjTpSQNflWjTfVYPn8JV+89qdwe889NK/aR//S45v6y+I898jx1mnu2rq3b6rpp3fZLtVZ9Nq9DfiUus3bGcDiZ7r8r0sY+fEhl76t91aNN/Hgf6Iz+6vF3SVP8K16PlDL/3mM7rpb1yLHhya2O6ydzEePjRer5n99vQbfB+WuusgNOYoPWuK+jiGcj3zAx2eAY9eizb8jaS1zWXWomPvp+vQb46tRas8oeoHXItWZ2gRV2gtupt+LXSPTzu58towtpHtGX1E6O4d9h/rA/TQR2Asbj4i5CPfJPDydyWwbor397KYRdk423/Rc+xqzxzHDbcALyrmwTEb4Y8bGq939tBEnEqXQ3HsbQIe8+B8f5A6Zx7CFTpff7uAvy1AW53bYV6SJN8mlS2abLox38C4gG2x3ZpsjKxUPzUJHmVT1HZ5fVudY1e2i/l31s92946z7W4UvGI8oO68Co3doTto+E4FtGu+n0atMaCfybuf4sKh8XpXDU3E6X0/Bc+Zit5PEbqLr53fYNrV/RQT4VU/xdxPgbYbukeKcwzq7hR1dxLO6Vg/231TLDTu4t0yWylX4H0PZOi+Wt4rGro/MnZcD93Fwn6D40OG51yBwd8w9NK/Fn+ijhTQdZkr4HEcz9wo/ea5lcHfMfTSv2kf3zykcfYXxHlLhqddrsBpHK93exxv5zfZbrFvYr5VhDLlXIHJaCDReQq+f9ng3z300r/tcgVF4gWVv1P+CHMFHx566Tfnc9PfmCu4a2hiu8vmqZ4dGq/3vuy3p98Ixda8b1WNOUrP1N5AHEO5nvkB8yuoi93IFRj+RtLa5jK5gti5e4d+cyxXoOJw1Q+YK0CZIn08l5w+k+3XQjnQdnLluTu2ke05lE9EH8H+Y0OAHvoIjMXNR4R8ZGzMgvONOyhXELr7OfacLMcNaj7H40benqa8c7IvDI3X+8LQRJxKlzu5U4v34aOub4nAFcqxtzujG7pnqLpTS/dT0Tu1QrbLOQYc39muUbdxf/kXhia2o92aLNuuWmPGeEDlCq5KJpYVzQcom+c4TcW+6rsDHPv+/tB4vb8cmojTO88XM18P4QrN19rl+Zh2leebCK/6KSbPdxWUca4g1j7Z5lG3cdxl/fTKFSynXIHyCSHda7efhnUv9gwJ+42i+QCl6+w3rD9RVxGecwUG/w9DL/1r8SfqSAFdl7mC24lHzGco/c47EzztoJf+Tfv4n4Y0zv6COP85wzNJ+7cLnwUN+eD0Keo32W7VGF+jvxGXOgPGdjaQ6Jxl3nmB/xx66V+VK0B/xHlN9EecA9ko6Cp/hLmCoUy/eK6T/sZcQf2gie1WeX30Oax7Bj8X9Hmn7Len3+A9TipnFBpzlJ6pdV4cQ7me+YEO59LRuQLD30ha21wmV6DsT813OvSbY7kCNcdR/YC5AjUXQVyhXEE3/VpoPaSdXHnujm0MfRs4tIbB/mNjgB76CIzFh8j2lY+MjVlwv8IiyhWgfbH9F80HqLk1xw23Ay8q5sExG+EPAx92OslG6XIojm03Xw/d7xlzp1Yn555C94W0u1NL2WQX75vo7/adu+3u1OL4P3SnVqzt3k5lKh+gbBdzYKfnjNvYDpWvVPEAjvl1Gru3l1zBMrDdK0g2Va6glc8qVzCxbDJzBayfXrmC/ipXUDhX8IasL3o5V/AO8G1vyvFtRXMFGzI8Va5g6nIFt0IfTGWu4ImMj3a5gneR7pXNFXwI9Pm27HeVK5BPlSsgelWuYGpyBU+Q7XvlCv4jczDbW67gI+DDPkOyqXIF+TZZ5QqK2a5HruAzOeM2tqNMruBdNHaHcgXIW2ge0ekZBNyTkXcG4bfBdv83ycb7DEJo/2O3zyCE9l5xbmBHP4PAd4HgmMF2FsoV4DjncQaB9VPlCtSZwsGk1R4wV/D5vSfi9T6DELp3JHQGgf1GKP8w2WcQ/k/WF718BuHfwbd9O8e3FT2D8PcZnuoMwtSdQfgJ9EEoV8B5DpU77+QMwt4Hv/S73RmEn5HulT2DsN/B4/V+nuH09BvVGYTqDMIvkWf/vlzPIKCPYD+APsLjDIL5iJCPjI1Z8AzCr1OuIDZXGFqvm4wzCAeDDzuRZFOdQci3yeoMQjHb5TXNMmcQWD+9ziD8jMZutYY52fsK1PlMjn0Xge2uJtl47yuIma+HcIXuNmy3Psa0q30FE+FVP8XsK8CcGO9H8N5XwPqp7jaMHXfxbsN3Ua5A+YSQ7rXbVxC6kyS0r4D9Ri/tK3h91he9vK/gFvBtV+f4tqL7Cq7J8FT7CqZuX8GN0AecK0B/1O19BQ9SriBvX8FbSPfK7it4BPT5bdlvT79R7Suo9hX8Enn278t1X4G6y6xb+woeJNtXPjI2ZsF9BbcE9hWw/ffSvoInwYd9kmRT7SvIt8lqX0Ex2/XYV/DJnHEb21FmXwHHAxsEXrXXqEb8InzouzTK54T2K6hYSK1zxnxfAdu2JvuX134+FxlTd3Mt3vPbAe3mgyYTFRttpDJ1Z267e29fS2NDDeBWEq+1pJXXmmhbM6e+woX9cjj8PgzKEf6bNJdEeRbo15WDUCcBHIi7pM6sxLbao+JJjJ0UvfRpiLJ6BC+/vfDz5z/1H8fPqFF944XfsV72C/iVAt5kNUC8DyVRz/nKdo22lXHbsQztz3hIbXbDoon89ZfkL0Z+iL8p4FcBXJG+mJVM1AXUd7PXYShbQ2Xom0P3YMbknNm/od/G74Dwmr3B/x+I5f4lYqzE+Jl1M7TfCflR891bInANB2i32+PGtNVclnlJkvwYoIt3xvd3+1sYSlaqn9SaLeeS1kDZMJWF9nWob9+E9qAp/RwW7SjzTasFlDtWsVlI99rFZqx7sbEZ+43Q/blFc0dsZ6irCM+547F58dyX/u1wP4jMHfOeU/x2T5Fc234Zj2kfT5+rcRbN3+2S4ZmkOLdwjqXontN2fpPtNrT3YKPApeZWbGcDiY6xDV+d4PeEPuDcMfojnluq8x3KH3H8jjaDueOTMz74ux7pb8wd70+6p+ZY6HNY9wz+NNDnoey3p9/gvJL6PlJozFF61hT1cQzleuYHOvxuTHTu2PA3ktY2l8kdK/tT88wO/eZY7vg2QU/1A+aO1Vo44grljrvp10Lz93Zy5VyuWktVPoL9QGhv/PUBeugjMBY/mWxf+cjYmGUj4D2C8gNoX2z/sftMY3LOPG4oH8ZjNsIvBR92KclG6XIojm237hlaC7s9AlcoPxTKnyrayBfvK+O9K8omu7iO09/t9WklK9VPTYJH2RS1Xc4Px+accd3n0pxxG9uhvs2l4gEc8/ensXt7yRW8Hmz35px4OkmqXEFC9apcQavtdjtXwPrplSv46V4T8Va5gvHfebmCd28HuYJHwLfd7pQruLPKFYyVTVWu4IEeyRX8WmSu4DGnXMFvgj4/UeUKQk+VKyB6Va5ganIFv9alXME/ZDHL9pYr+C3wYV+tcgUttPNsssoVFLNdj1zBV7uUK+B44GKBd1jgrSWtfsjgQ/vM1D42lIfRUmfkOCbAemty6KgcRJK07jMz+G9GxtRGuxv6jjJifVc+G+FZ3qFvLaNM1D5HPquFMjaaxvOwwJny/jUaG9YC3OuSiWXXQNlVVIZ7nNdRGeoI8oH9hHqwHGAMb53gvw9jQ+0VE3EqHb4G3nEfhPoM+VF6HTOvWRug3a7/mTbyhXWZNvOJ+mC0rMxk0w1bQf/DthLyNekTIyvVT8pWOK57HZStpTI8y8x3J62DMj5jibqNZxNZP9eKdiyHdzw2LBe8/vL8AOWi1gu8Id0Lnb1UuneNaJ+yf/YbaP/sN0LfhMe+Zb+B8/1EwHMuaqz/s76w+Q3qSAFdl7koPl+xAXhQ+s1zd4M/JOMx7ePZOb6tvyDOPTI87cZN68duzNkmc9xku8W+uYZwXSNwqfkb29lAomMkw1cn+CHoA85FoT/iveXoj3jMXyfoKn+EuailGR/qfBLmouaR7qFPU7Ek657BnwP6fFj229NvcEyKfgBx5I05Ss/UPIFjKqxnfsD8CupiN3JRhr+RtLa5TC5K2Z86L9+h3xzLRan5keoHzEWhTNV8KZSL6qZfQznF+DV1LkidcWJ7Rh/BfgB9BPuPdQF66CMwFl9Ktq98ZGzMcg3gvY7mG2hfbP+hu1pR3zluQBly3IB3NamYB8dshF8JPuz1JJupuJcyhKvb91wwL0mSb5OTPTfHuIBtsV1OJkZWqp/UGTBeC4u13dB32dmuUbcx3/v6nHEb21HmjpV5NHafCnBHJxPLzoWyuclEfpYLfhD+RIJflf09kANv+OoEf62It2YSTPr7kBx6yB++4xgB66/KwYX+Btv32hzeN4p43XCuFvwdIvgz+DUCfjXAGD9KNpy3Wy3ag77+WmqPwW+OnH+YTnXoG2Yo34ByY98QklH6sExVHhZlxbkIXJtZRWVHQ9lqKkPbOZd4OFXwcCK8Y7tGvbO6qRw+v9tLv63/FwNcL9r1nZF2fUoOPeQvZNdYv6hdvzGH93sK2vUpgr9esuttkXa9OPtd2XV7u14seIi1a6ubyuH53SbivRLKlM5yHxv8UwGdfXXSyivKkOX7OgH/aoBhnb0Synh+gPV4HRvjrcuIh7VJqxwQnm3X4J8DObw9oOvGV4e6Pqh0fS0AsK5fBWUx+d91Ah5jUZOJikWvJFxXClzY15xDMxkNJLoPDF+d4H8tkENDO11LvF9WkPdYe0ObumX2S79NB9E3LCaalwVoct30v8uzvwdy4A1fneB/S8iLfR3aAfK1knAa/BcD/uDypLVd58I71kEl+8tFu5RMr6Qy7GPTBWWfBteNsQjbz/YZamv6sGyUb0Xdtf5vJq3+kNeN0TYuJzpqzIvVf9Shq2ZPxHs5lBne46Du67PfrLNfC+iXkiGO8UVlaPzMTFpl82oqw3qrqUzJnsc8lAPCX51MlIPB/0XkeGN8dajPS5Q+ow9nfV4LZcrnc1+ExieUicqLsM4qP4N9zeONyWgg0X1g+Dj2+XZgvMFYm8fKiwvyfpzgfTBptRm0qf+VLUKaDqKNLyaaFwdocl30kQM58LzWY/A/DIw3a4B3jhXT33sSToP/ccAfqHF0EbxjHVSyv0y0S8n0cipD3k0XlH0aXIf2eaayT2w/22eorelTdCy2/m8mrf5wDZWhbXD8reZksfqPOvTpWRpv3njzmuw369dAljxT+qXsBvMcLEOlj6gnPN6gfoVinXOpDGXKuQk17iI85xzH9BrkEBpvnPR59lTHTyYTFT+xP1Q6i33N443JaCDRfcD7Gw1+H+gDHm8wT3A58b6qIO9l7O0RGm8wP7SYaK4K0OS66C/yxhvDx/mnuUJeNaKBdoBy4vHG4A8N+AOVowuNN+1ydMaPkinnNJB30wVlnwbXoX3uNtW5Nh5v0B9yHg5tYzXRUXnpWP1HHbqNxpvFhBdxoV6E9HExwJg8WR9PDuhjyM7Sh2Wu9Bf1anH2W+kjz3kWQ1lIHw2uQ328VOkjtp/1MdTW9Clqq9afak4d0kcenxcLOuhDWB9RjxZDWzfNmgiHa4C17F/bO3MovC8g82k1wmc84zvE3yBeCtIb2490KNHj9lnf7fKL/7K0Q7J507XXXbvp1hUb165buvaGmzdfNzwNUSetK1YoFcSK72rJxNZjWR+96yO4c+jvFaJeInD3Ad15UKYkYTjNKrFN83LqoSwS8W6agD+UcB0q6hnvfYH6iAPrscbU6D16zT0F7TrBvwq85nmL8unumbTKYU/6+w2CXhetbtaOYXW7ElaDQVh8dgXOEJ7/5h5dKerxY3jqxPNw1vxf5jez39bze0Fd219rZfsAblwrfoxwzCUe1L/IO77j8cvDU/D6ZPpwTmQe1Lsogod5guemqG9wg6JeWdk0AzwbHfQmuP/5pkOSCW2bD2XKE/H6qcH/HejQ5uy3yRIt1nhUcr4kmchLUTlfIuh0W86XEJ35jnTmA8ze8Dv970jCxXK2fjI5HwFlR1K9o6AM4XCUOxLeHyVoK/yGo50O3nGIblueDhqtOsH/Hujge0kH1WjKo2+ShHWe9XIgB/4Q4s/g7w3M4/cUbUa+eJ3S4O8PzJv2FO1SvjLULtSpPXPa9VAgn6OiEDW2HEZl+0CZ+XAcW+qE44ns/fSktT8KRAnyzFMe3whndOeWoxs9BzH8jaRVhmWioblEj9tXLhpC6bNUECu+qyUTW49l7eYgF9DfZeYgygvsJXCaR1FxPddjK+R30wT8XMKlLIi9s6qPOLAea4yql/7dL+rEWEDJ+Lwv1gIMv5cFtOt301Vr+6GCl6YoQ96xDOkcKugoXPsQrn0ieU6tNtsgZ1a7ZtPGm4Yzs03oaTfpmJvDxjRRP6G6bNoc2O8lmoSmsyKHdt4gbPjqBP8ZMViF6qdPjNpjF3XD8Rt+L7WPVSGexGHd0CBfS1r7cJJUNX0uyGFDjSgJ4aqJd+mjYsmpUuP/FYi5pon6qTf/010n0m4XZ/Ncz+C/Eog51dwgdG7jaAGP8xHjZybxgHVnino8z8R9yvOJh2OSVjkgPO+VNfg/iVxLNr66sVf2GADgtQFcI+kT8NwXJwh4XCcymTQJnvsF/0Zc2NdsByajgUT3geGrE/xfBewA5+nHEO/zC/KubFjNa9Gm7qA5KNLkofSIAE2ls0Ynz2/kzZH/PjAHVbkf5IvnoAb/jwF/EMpTpA/roPIfR4p2KZkeRWWYk8B8kOFmnN3YK4vtZ/sMtTV9yvpKdTZjPpWhbbD+zxd0YvUfdYhzi+8FOMM7TeA1+Luzv03HGcbq1gneQue0P5aRT8Aw7b3UjrH6yfiYb+Hd+4j3oSTqiQ7vDH+DeClIbyy8ex/R4/aVm9ezRqJUECu+qyUTW49l7aK4s+jvMvP690OZkgTP67FN78+px5rL76YJ+PcRrveJesZ7X6A+4sB6rDFsRejV3ytosxXNAivitUWk+96kVQ5sSUcLemZ17yfY9DGru4faNJREPa+KtTrD3yBeylrdPUSP21fO6lBTkMplhNVgEBafy4AzhOe/ufeuFPX4MTx14vmwTItS7dsv+z0zadXYfYlv5CHkv5qivsEpOvt1SGc/Qcc0GeMGXivtF221stugbG8qux14WUVlW0S7rOyOAM47AzjvEmUp7y8eOhEOvVEt59/06RPvWKbvE7xa36EH4NSCsrZ7AnSwvsENinqdtkfxzDEGtjWV74mHJhPadi+UqdHA9vHWCf6wReP1FpK93Qv1jUclZ7bFonLeV9DptpzZpu5zpHMfwPA67P2Ei+XM56u2Qtn9VO8BKEM4jAjuh/cPCNoKv+Fop4PLD9Vty9NBo1Un+Cbo4IqSOngflWEf8HhofKAcEP7ViW7XQA58XrvWQETEuYb3ifqK90OJl/sCvKdPaFXA4Lqt84cSnTz9eTXpz1YoU/pj58nqBP+vZ4zXex3pD0Zo3Wh/yK4xkuNZg7I7lqWqhzb6ygge7hc8N0V9gxsU9TrVDcVzO924nnTjAShTuvH67Hed4P8adOMG0g30n8ajkjPHgEXlvJ+g0205c3y3zZHONoDh8e0hwsVyfn322+T8IJQ9RPUehjKEw/HtIXj/sKCt8MeOb+8+VLctTweNVp3g/yfo4O2BOU1IB7dRGcoUfS/3dagPasT3QA78NmqXwb9PjG8he0W9YV9u8PcCTs4NG11sl5oth3TxQdEuJdOHkva0Uc4rcmgPJLr9ebryUECmVr8/pz0sU4N/NCBTJaOQTJWNPSTaNVO0+WHCpTJtKOcYmWL730/tN/gPBeKw+0R9FTtwDKniMIR/HcErG1OxCdvYM5ExJMc2mFvgvXKYW7iXym6DMp6L3Q5lW6kMcwuc58DcAo9/d0LZA1R2F5Sh7ltuoU5t/VT2vsMcvNzT9z7irQ7wtZx/kyRuPOX1I6TTrbwJ03m/Ix3EZRl5NWebC7+xzOjwO6aD9UNzw/4O6fQLOowLfTLGRGZPdYL/Etj1O8kn3yv464d3KwJtZXtGXNZnZh/o+7qxRmX4G8RLQXq1kM/F9vFKwVbBS1OU5fUp0pkr6BTla5eMfvpkWfyzhq/avH7FxvUJPXX6++wcFvcjuBU5rNUE3hr9x+/3o3d9AhZxT5bpTSWdV3RI5xWCTrdTna8gOnnTnb8smFLmKzMM/tMw3fnrwHQnz+xQ18x9pg/rttHLW+6/LYe//yuW+2tUB9v82gDP9wINppv+PjyHh+9RqFLSFctQhVOhyE+dypBv7BssS5JxWeA71rm7BR3GlTdMmlw5pPvngsNkaKEeebqXynBoYjkoOsq9KzmE6BzSIZ1DBJ3QsF/Wlyie1VQCfcnPyZfcB2UqpFmZ/Vsn+KfAl0zL9iApX4I88t/KL+eNk3m+5J4c/nbKeFK+hENDbKfiGaeATFf5krEpX8aD+RJeChpK4h7lS3hpAvnhLYZFx0KsP1lj4Xyi0+1lP5XuZ/+ilqO2BuioJbV29rjvPE1T2SOPawj/RrDH/QP2WGSprtu+l3HFjkEGfwjYeKdj0D0R/NWTVptKf8+DNufhSsQ7g0e/wvOA+wj23gBsnt9Kf1+V/e62fZ2e/Vb2dQTxV9S+sH6sfZ1Q0L6Gs99sX5eAfZ1E9oXLASxXXgJA2NMJ9gFodyzefqqbPqsI9n7CizrJV4mOje/zxvGfkf0eFLQ61R1M7bPuYIr6SPiNZUaH3zEdrG9wbAusO+fM0zRRd7Au647B3wOyXD4vv42cZvWQs71/EN4zXV6CfIhgMZXPaeIHqa76tx2PTUHnIcL7cIB/XqZ/QNTr9nLrQ0TnIUc6iOsKopOnu1eS7j4MZUp37dNJdYK/CnT3taS7WJ91F30qb6FU6b8U/n8Sz48AnMnpSlHX4B8leMSRPjy3eCz7O29uYXXrBL9ezC2sbQ8Lemnbrs1pG/YHLsM9SrQN/k7oj+uoP1Be1h8zk1bZsA08Brww7Ok5MtgEfNw4L58W24VqY4rjlnn5cKcLOMYxTcjAcCi/YPVmCnpsu48QjYcDNB4S9RQN9scos8eAvunGB9qUPybaloh30wT8IzntTQTtR9vgfVjgUf79USrbJsrYd2F71VYs5RPR710ZsJc8m1B69UiA98eI90cE7w8HeFfyQ/8Rihvs75ixvib+Nv7Wwzv2sWqpH2GsLi/1bwvkY9T2HeRrOAfnw4CTt08onQkdyQv1E/IzM8m3c8U7+hJ+F4plEsED+kKls3lxHMtD8aC23yi/ydtvVBwea5sYT5+zg84xnnOaYyyG+enz2/kcg3PmvTDHuJfwVHOMJPktpznGHqC7Xyw5x+CtVO3mGFZm8p0m6vHxAaP3PYh9v0z4+oEW6k368NXKuNUwEW3idQWD/wqMe++hT0pi/ROIHq7rqLUe1okTBF957VRjGMvtO7QewluHh5KoZ0lI/w33wyVxx9iPsnk1f2iIsnoELxv+Ze3xawfe+mW2K+OF38XEMicIeJMVz5uHkqjn9EGgkRBtK0PdfpjKUFeNh1SnNyyayN8jJfmLkR/ib4qy6+B3kb5QuLY64rq3JK5ZyUQdRTtU/p5zNyrPnPZjI1vAU37oOOK1qB/C+kX8EK/bGOxAxqvpFx+vG0qinhNC8Ynhfqgk7lg/lBcTIF8NURbjh97wsyU3fHH1H+9fS1r9bZ94F7MlXX3uoUM7P0b5IfY16IceojLUVeNB+aGSY8oxMfJD/CqXxH4oti8Urq2OuO4ticv8UGhtAf0Qx3fqiC36IV7P2nX+OMwu8yfiCuWqVfzGMaYqu1/gTOkcCHfyoL8ayP69CMp4PVDN0e1vfIe6jnV4Hd3g9wbZ7EH84Vo2thP5U/2Fe2z2nZ8P90AALhTfq3XwUOwf2y88VhxMY0XJi0zkHh7DlW4/3jP7nW0/Xja8ac0b1t40vG7N8NU3DW/qA0zIHWOyv63VWI8f44R3EdxFf/OOta309/0CTzuaaofJMfCb6cbsMDlG8DyVdE7skM6Jgk63dxGeSHTQk+DM/9j5yYS2qV2EqA+rs3/ZK5952ni9EwIRJMsZrfCkZCIvRXe7Yf17KjrudE7ukM7Jgk63dyOeTO1BG2G5FbVrrH/vJNNpZ9cXztc0Y+3a4H9y6ni91QG7ztu1j20sesCKfVIeLv5AHNbnnZD3BXhWdPBdSM9CdGLaE6Izle0xXGqHH/bBxQG+eJZyfxtcawiXushD6SDzXDQ7gfX7A3S2dkhnaySdyWrP3R3SuTuSzkkd0jlJ0BkU9TodPxTP7fztW8jfqoua0N+uzP7lC43+Fvzt28jf4ozn5S7nbq0a88V7ef15J/WnWs0N9afB/z70590R/alkk7crEumG+lpdnFMTuEI7t1kOCK/GlC5mVKM/U8irNyVXqcYOR4cuv0kfPIS8e/Y7ywIsGb752OMWnvWLFMCtN2zKy67uikSTiSvrCJ/Q31wv5Y1PB/YLGunD+vMAwXG/23vGH8NTO9h25crXPZjTziSJ83VYvz8HF9o8nmax/uFM0xOZnavTLComUxeyhOIBtSKPcH2iDTvn1Lsx0fxZm5En1WaDfzrQ5q1t2szxu4od2TcxXJ9ow/SkVQcQh5LxKclE3ovqE9afrLHzFKKTN6a9SGOaOkGDdW/KfvMJmt+EMe1TNKapWLDb7ef4VV2vfRPA5M1t8k5q8+4Ng/9/fFYfZUaZV1Dqgv+0ff+d+lS1PdSnBv8c9OnnI/o0ZB/qsuaQL7g3AK/miirHFIobrX94h+xQEvPU/ipGRxF/g3gpqA9j8Ya6EA3bVzbeMLzfggYh/+3iDa4XijcYNs/2OAa4n963izcUT3mwncQbD+S0M0nixgesb3CmnyU/MDFkvNwDfKgdzHknf6clrbal4FWMoXZpsC+qJ3oc3hvKEf5rEEtsCeyKOzWHvySJ6wusP1lj1alE525HOurWGZVfXQ2/sczo5PnYpqgfWi94oEM6Dwg6sbp+Q/a7XUz0fwvkyZEu58mvgPHzuzR+qluUQnm40Gl/tq0kCY+7KrebFy+1s1OVXz+XcBVd28D6odP6ive8m3+mZzcgd3jzzyq1O8Tsr8OYb1WMjSN+tevB+GqIsphdYd9tnPZ73/tvj/9hjeobL/wuJnd0roDvLP5KVqpdYbhjJX1QR+6nMtRl40HtCisZr62MkR/ib4oyPA1UpC+aomxFSVy2k0vNsafKJ+XlXqxPOXaYmdl+7E0i6sYi1dZ7qd69gvf0YZ+TPkOJfn5Oj+Ez+e8kaN1H7TbYPaDdd9Gnoe4TvJqP6AvQsIdx5MkmobJpou7N2W+Vz8njTeWDEMfdOXymONQaIutt0dtL7hH8KDpnd0jnbEEnNCbxv0aH34XWI88mOnlx07xXJhPaFlrvSn9vyn7zete5EDcdluGcKerzmqu6yVDtL2DZ590QwP7E4I8Gu+LTrio/vAlw5ulZ7Ckhgz+B4plu5Jm4TfWk1bemz/JEtykvX8wyUHqydwBerTfhuhv77NCl+ta2U44Y5+HUVxZr/3k5OE8+fBznGQVxnp+D88JXjuNcErCNRclEekVvlcT6vAOX95Smz/SkVXcL6GH05caGv5G0trlMPk3lB5Rc1EXtvD6LZTH7NBYJOjXC1Y4vx8uNjcW9CG5FDms1gbdG//H7veidSskh7pSnP8tM09R8C8BcRvi3AI4+8Y7VHOsbnKKzV4d09hJ0QrguE7gM/g4Bv5eAd1QNY3EOwLCXZtYYbzvVYNx5qmFPH9FMf99L9blrmMeZAkc90KY+8Y67ui5oKTqXd0jnckGHo4TNFCUg/QLe8k7+bIThQNwlM9V3xnp+/rwF0jO+1GeZY7Ieh/2PX3nq1LlvuLBG9Y0XfscmqWaRlwv4DrNPt6usB+7+TR+VGVNZD+NBZT3uLclfjPwQv8pSc9ajaAZB3QNaFJdlPfAzKSFbniyf0Q06IVyhu5tNNgOJXilin2Tw74TZ00rKSih5J+LdtKTVH70q+3emwLUgh3dF2/CnT1PUN7gu+sT+oj6xkbS2uUw0rOxDyUWd07O6vEM9fVYBXJ6/DK0I9Dou1M3BpFV/azn/Gh1+x3L2WBH0PF3GZz07waWyZEfBbywzXPyO+wXrb6WyOwQdNQ7dSWUotxVUhuP54dQutEn230X9UF3wp87TYlbumVdqmphtwbq8mmnwXz1svN5HX5nfxpidVAifl+F6fhIyXO1k92IB2aXPxdQWg/81kN2nArLjsV9lwtVOcT5plveJaixLkvAOIpUJjrlfrMOVveixz3tnlcoqKh/T4f1GdaMX+mQr0ts10TJVd52ZjSlfx/4MfR2vQuK4lveZ5PT3YfA7z59hmzgzq/ibLL+p6FzUIZ2LBJ1QnBij64qO4rmdL/sj8mVqNRXrXpv95uz00+DLvka+DOsjj/x3zPzC6MV+G8bg/yywOqPafG2AZ6SRJK12w2OXwf8ljV0l59Ny7OLTvuqUdId0o7Pxhr9BvJT1we1W4zG1OTv7naU2V2xcu27p2htu3nzdMN9cmbfHsUZY8V0tmdh6LOujd7cR3Ln09wpRLxG4MeOpzoSE9iWotXo1K79b0OW1eXXuOrTHwXjvC9RHHHn7Rfpy6qV/3yrqeN4T4Dmj6eIesd1iLdPwN4iXspap9gup6Ejd4BT6gsNt8BvLkE4oOkVcW5xwpc+qCleFq8JV4ZoCXKE9ZTwLS5/V2b9q4ZrPZhVduMb6oQXyszukc7agMyjqlR2TmwGeVbaF5VY0A6nOlrbbP/fKwzTNvP1zPEMz+AdhhnbEYRN5VjM0lAHOgLAfDAfXnQ48WFmB+GJmOku7nL6yg3LlfgjFIelv22un9lPzfh3Uhdg+Oon6SO33C+1xNPhfgT46Jfut9nHF7CNS9NgOB3LgeY+jwS/KeMJVOsXfPTn08rIKr8mhtxTorQJ9sHYmRLtDvdtN6R36GdY7lQlS/izkL9C2WBdRh3llVu3dC+1rtfoDie4Dw1cn+AtEn8fqOferwV8U2a8my270K8qK+1WteiM896vSA7VCrzJ1txOu2wUutY811pYNH9vWqwP9avWxX5FP7leDf11kv5osu9GvKKuYOEftnwzpAY4PJhOVWb+LytAn5p2BRjqoBzF9jv2T57/fJPpcZfD7I/jL23e6W/Y7y8Ct2bTxpuEsBZfQE0qZpX/fm8PGbFE/obo1ejebypT7DG0SMtoDiU5Zsfs0+JuEyEPuN31itlRjd3cjiWv4vbZUt3NrnCoKmVloKjMFqpo+5+awURP1E8JVE++SRG9zVnv1YrybEpXaq4Xwho/Xrd8TGDnUSBi6JUxF7mqNT7Wfb3jEejGnSVCNeEQz+PdGjmhOMx85oqGMuA9VZiF0EletZ6tsaZPgUfZqRMs7HYR0VBSjZlYYVfLMqt2NoDEnj/n0c/qo2T5/TxXrhWbBBteNWTC2h3Uh1Lfpk3e7C8Jjf3PUinsLOPOEtsS3OahZT6wuYLaDMyFqX2JoBqRubMAhnGflBv+s8AGG8742bYuZAapTt2oFj0+QYj3cV2C4E4LrUB9neGZl0qeorbL/QT3jveM4FnAWB/nEtf8/muQ9WDx+q5tD1XhXJ/jPQdboD8lGlI2H+kDtP1I3H85MWv3FQxG47gzQVrdmPhSgjXzlfes0EXzit6+MlpWZbDq0lX5lK+if2VZCvjh9YmSl+qlJ8CibovvB+BuxsfvB8HsvrJ8qXlQ+XNku7rt8kWwX7ZNn20Wz9mo84pj46zBGvDMnJs6z6005OL8RGHfajakxcXbodnH0fRxnq6yk8n3sF5W/Vn6E/aL6ZibC530z8+8y+XV4i7Dcb5X3TeR6omMv3gNs8P8Bvvs7h2mc/QVxfi9yzuLk6+rd9nXtxiTep4p9k7ffEHGpvahsZwOJni8ZPl5t+2kg04b+ln0q+lv2qfcKuqGzBqnc98n+4Hgt/Y0rWP+ZM89C3UOfw7pn8HPgdgNjxNNv8C1D6hu0bD9JEtYztSrI3/JW33fucM939J52/qZjyT30wdtCVc6gQ785tqddxSqqH3ZNtEzV9xLx9gnDazDd9GuhXEw7ufL5IGwj2zP6CPYDMTGZopcXk5mPCPnIMjHZMxSToX2x/aONs/2rm0PVHIDjhoeAFxXz8K0vBj8XfNgCko3S5VCORX2XWX0feGbSquuPROAK5foeFfCPBGgjX1iXaefZZOj2vW7MpzAuYFsMzSXTJ0ZWqp+aBI+yKWq7PA/D8Z3tGnX7QWgz62e7nAvb7lbBK8YDphu43LQmmUhTLe3gOx5nsb7BKTp7dUhnL0EnhGuNwGXwWwR8l69XMRbnAkz6fu8Aa4y3Rv/xe8bdJ2DxUd1Uz+E7SeK6SW1WYFzmwtNnNcDwpcKYhr6YcKku3BLgC+vzUpjx9drM/KYL+gXc27bQ8XDDXfIY/7Ya4UsSHWbmHU1DvtSVAvUIXj770Ytm/PEXF45dBRJ7hM7gVar/YgHf4VUqW9UQxtelqGODRa9SKXkFxNYY+SF+lQ7nq1SKHmfEstUlcdlVKjhUmu1Mlo/hqevVmS1jCm+yebHh+A2Cl5AfQ5/PG7+Rd5bxlkC7ivrLeiSdSzqkc4mg0+1N4ZcQHbRzTKNspnDsDihTqd83Zr950+W8I8brvYXSKFgfeVTjD46R6cP2yptCGeaeHP5+BfSTj9OqNr8xwDOm0JKk1S9wendsGwqNvSV9qkzv8rVi6ph2h3Sjd2JN1XU+xY7T8vZklApixXe1ZGLrsayP3t1GcOfQ32WO06rPTNwpcIauNFejb5FLqhCv2pTAl/OFRnvEoRb1DIeql/79BlHH86KCyTqaa5ZZ8nhr9Gcj+bMKJaPOMcsMbQ5JH267+sSDSmbzrKrsJwPS3w844rrXCVf6rKpwVbgqXD2HS81A76MyHA/48/DqWEONypC/0MwL64cSjxd1SOciQWdQ1Cs79jUDPKuNgyy3ohcaYn2+aAajdpwJfflwTTPvqBjPhAx+b5gJ/cHhE3lWMyGUgTpD0MVjZnKDJMqV+0FtHsV+s6O8oSM6Shdi++jr1Ee48Vr1ER8tHmsP9NE3aLaK9XlTfmiTONJjO4w9tmrw34LZaujY6p059NTsPX1W5tD7W6A3CcdWZym9Qz/DeqcyLsqfhfwF2hbrIuowH4MLHX2sCzqhDd3GQ+yRVoP/J6EPPBaxbuTxp+TmfAzu7hw2dhX1E6pbo3e75uAyPOk7nL7GHINTJ13ZRfxUiDzUZelTHYPb7o7BnZPDRk3UTwhXTbxLkvbH4HhUCYlYiUp5kVCOfgw+40kdg1MeVkVYoUhA5eZDxwBV1HNnDh0c0VBePKIZ/Axo6yQc2JcjGsqI+zA2c2Lw7bZDs6mFjqGomU2sGcYeg+NITelLf6C97Y4dsX7FHjsKRdUvl2NHxnfMsSMcjrYSHRVFxeoCzp6+nLPGhHhRF/LWaNEH4BCedxzhcOEDDOfdbdoW4+9U1jt0lbi6LhjXAw034+xQHweVPmL7Y2Z5oc/GtLNV9j+oZ7yNFMcCDiPb6U1omyeu8W2mGR/S4Y8AFv1sy3LBv6KzV4d09hJ0QriWC1yh/u7yVjFjcT+ASd/vHWCN8dboP37PuPsELD6qm7bk8J0kcd2k1FnRqXdIpx5JZ1WHdFYJOrwVZG3mdjtcbr4tZsGs5MmC22qEL0n0bCrvVAXypU45xGwx+37zkt+57scfea5G9Y0XfhdzGn6VgO/wVMS71NDEJ1JR/7ZRGbph40FtMSt5KuVdMfJD/OqmCN5iVvQkDpatKIlrVjJRr6bCZ/AWs2sghOItZlPhvy7qkM5Fgo4KiWo5/xodfsd0FM/ttmLdeEQyoW1q6ot1Oblt8Avgu9ObAmmIvLABx8rQlw2MXuyXDQz+VtAp3op1j2jztQGe7wMaTDf9fXgOD++gMarkxgu5FYunn8gPh9pqQ4/6UoBa2LonQOfSDulcKuh4boZpBngOjftl6aBPNZtTpzxfBb+xzOjwO6aD9bcG6GzpkM4WQUelhXDKpE4Emsw6jKfqMf2C+BvES0F6wa8dqQV/a/uDghd1upFTISrWelDQUbhuc8QVc1PRqwSuovJynOoZi5cS3MU5rPUJvDX6j99fSu/ypnqGe7Kuyp4s02+3bv7sEZpm3rp53oeY/+vI8XrPUWiBfA1QG4vumMf6oZ35PARiZo2zbupK8BqVIX+hEyVqxaJP0FHud0f80BEP6VhXDdExl2AMCDpF+XJ0c2NJZ4LLu9OtJvC2c3OH07s8N2d/T5bqKzqLO6SzOJLOZLXnng7p3CPohHAtFrgq9Z6AW3VTfw7fSRLXTVh/stVOjSCYlGg3yv8JjfLqM4GhUd7gZ8Eo/6ewU473NCCu9yUTy1CO7yf+cf2eR0CUSzdGQMPfIF7KjoCxO9OKnU3iKQNKBbHiu5Cl8C4Ytsp+qlfmbJJanbtd4FRx3B059VAWiXg3TcBvIVxbRD3jvS9QH3FgPdaYGr1Ha3uvoM17L78H6bA1lA5TtFAe7fYXMgzzMLa/MJCS2wJ1VLvYmvlGAPQEp+fQr4PH+dERmn4i6HP70HsO5PC7hXgw+H8Ru6OUR0Z+1DuUAdbN+xtheaDHv5Uuvpfg72rTdu5/g/+vQP/fJnhA/7OiDQ8MMy2Hh2lHtvIgvObSjTfcmrPXj70a/829xD1xm8CT95g0Uo017WXpsHUwHftbaUDa8t2z32Oh23XDm/L2OfKIUM+hOS3Rz2CieUufqdq6els5esGtq9i+sltX86y0HZ0Ot67mDdrKWXD9hOrWxLskw3ljtuV6KtcvtnRIRyWJGFdeWHx19rtO8PuCg1qVs241TeBMH052hrbPGh6Eb7fFimWptkOGaIfW+e4vyGsox4z0VXJ0W0FeV08yr/cIXru4rhLtOqdqXaXYtIY3G6NUECu+qyUTW49l7CFvI7hl9HeZaU3sHZnq7scHc+qxZvO7aQJ+G+HKu3+6L4ee6lGsxxqj6qV/v0XUCVlAjAanT95KnQeuhwQus0y8M7GApewRa5mGv0G8lLXM2Hsire2PCF6aooxTDuruzkcEHYXrAUdc9zrhSp9VFa4KV4WrwrWd41KHvPhuXhw/+YqKbl+1oOic3SGdswUddWVB2VihGeBZ3XXNclPffHgoQEftiuadqOnvCZf1Halp4kwW6/IOUYP/J0i3vuXI/DainK1dzHM3vhmHMQ7Lud395PzldIwl+LAR9jXeCR7qg/dQH6hrQmK+0fan0AdbqA+wPu7+yrMbRY91JO8zsPcSfwZ/N2Q7VgZ2ft+fQw/lgXJ+aw69e0V2JXS5bYd6t0e372dvp6e8/UXdc2+41C539d2EGtUfSHQf5J3ceUz0eayec78a/BOR/erkT/YoeqWNyqyFDr4rPVDf1msmrX2el4lEXKFPOqt+VVc8cr8+G+hXtUkA+eR+NfjnIvvVZNmNfg0dYlX9GjrEqsZv7FeTSTNpHSdvJ1zt9ufE9Cv2Aftog/+1QL+qLHfIDxv8b/aAH0ZZxfSrWgmI7Vf2w9ivfBUQjnVsy5Plo78k+lztFI85FJy3Z8zxKqBtOWzsLuonVLdG73bPwWV40neYVmWRW3MHEp0CZZEb/O8LkSszVXu11KGyqdrtW/IgbnC3r3KpRXf7Fh0Wu6Cq6bMsh42aqJ8Qrpp4h2XtrpsIXaWBI/Sf0BY8VCGeKSjPpyJ/g7cINC+6MHx1gv9mYBQKRcHpw9663RegQl+bfpTKsN79OXRwdETPz6Ojwf+fyNHRaHdjdEQZ8ej4GJT1CXiW9wcE/GMAw1mlD0AZmzTK+FGi0851sP4rPVWzbxWN9wfa225Wxvqlvm42U9QLZUoMrhuZEmwP60LIltKHZRPSHZRNM2mvJ2iX/FW4kF9Kn5AuYHZhM2VN1JVXNSpDmqGLgbE+f00Y6WzpkM4WQYdxxe5TMfidjsr+TVr3qahV4ND+iNCXb5EfJRu8I4Jp13L+NTr8Lu++Bewrz5XjUEQdWlUuSwf9zANE52FHOnk+i31Dp3TUyrIavzqlg/6Jz6k/5kgHfd19UI/HRHUb6OOCD5sCPAHvC4wF0eetDX+DeClIb2wK8ATR4/bxFOCDgpemKLsOfmMZ0vmgoKNw3emIy/p2ZtLa1wuIjoqlPhCgsyCSzsIO6SwUdAZFvU5tRMnG6DzhSAdtZiHR+aAjHdSDvYnOk450ngSYw4lO3tfPFx01/j7970NQxlmu9OGvnxv8108Zr3dmhtN0EH0F8oj1MR55XLSD6S3LaJj/G4E6BfyRvHdlJPvdTnbLSXaPQ1mM7Az+syC7FSS7EaDNtj0KZU9Q2VNQ9kEqexrKEAeWJdAGfMc6h/UNblDU4/Hqw/C+QH9Ffzne8DeS1jaXGa8+TPSw7enDd6Q9U47e2JfjPyLoqX7YNdEyRfqGi69zRT87QmXoG5+mMvRnT1EZ2vdh8Btx5rWJd8Aif6zfyN82KlM7Z2fS3+nvh6hMfdl7pmgzx7fW5n7Ckz6206ZOsNcdNV7nDdlv5W/Yjz8ucFvZh0RZiv+24ya2ZQTwoxyxLH36xLvQGGpwis5ZHdI5S9BhXHiwEOeI7HcN/v00howC3gI2u97k/xS8ZH9X0v+sj/V3eb4X+VK+MOZ+yfrvPv2Fz77xx6uKjhEh33mWgO/Qd16lcmZGW90v+TSVYa7GeFD3S5Ycu66KkR/ibwr4pQBXpC8UroudcLHP7RTXQyVx2b2XGPuMEi6VM8RxKXQKg/kaaYOLP0eM9UcI12gbXLzzckS0keMShusXuJn2YNLaNvZlJf1kdK7B8DdEG8rEbkq2I/COcw1Kf5qijHX+KUHnKUFH4XrIERfnSz3ymEqHzySei+5cxfp5u44RjufM6e8Jl5MdpflBvcf5NscFBv9RmI89R/MxpB2KLTmnU/SuvgWRdM7rkM55gk6389+c0xl1pIO+6Tyi85QjHbQ3zuk87UgHx0WeCzwkeEh19rfIDj4MZcou12T/1gl+OdjBFwN2gDxifYy1VG6K6f0uxeMl40CZ0zFc7WT3ZZIdzu2U7NiHGPwRILs/KOBDMLYcpTKUx1NU9hEoQxxYlkAb8B3rHNY3uEFRz+Rr/fUsvO9GTsfwN5LWNpeJC54letj29OF5yUfL0RvL6XxM0FP9gDkdlCnSN1yc00E/+ySVjULZR6gM/dkzVIb2zTmdJ9u0ieNpxV8oFz5VMeeT5egFY05sX9mYk78v4BEneuDi/NxUxEILO6SzUNB5ucRCvL61o8RCPy8YC/F4bvBfOXm83rSjX/rdzVhop4zGVMZCjaMntqVsLPQJkN0gyQ5ps22jnEapDGMUjoVQVrzeaGUJtAHfhdZUWW5Yj8erkrFJdCxk+BtJR/oxNl6pGFGNVx3GemOx0EcFPdUPGAuhTFVcFIqFOL8wCmUc76A/y8vFpr85FnqoTZtCsRDvAcPcRfo37q/gNSWDfQzsbG5mZ2qPGX8fA3X8A0D3ULJVlMsI/May9ImJHbD+U8SPx9ik1rrPJJ6L5qixPq+JPiXo8JjO/vXYozU/6F9HgR/2rwZ/J/T7CdRnSJv9JPLMMVrR/lwQSee8DumcJ+h0O6bhGK1bMQ3nqz7sSAfHS47RnnGkg+MQx2gjgodf7qMhO/gIlKl8PeerDH4+2MGKgB0gj1gfY7RR0Q6mdxHFaCXHRBmjGa52sltDshuFMiU79iEGvwvI7tICPgTH5KepDOXxYSrDXAbiwLIE2oDvWOewvsENinomX+uvj8H7bsRohr+RtLa5TIwWmz+y9j1Xjt5YjPargp7qB4zRUKZI33BxjBbKe6Bv/CiVoT97lsrQvjlGe6pNmzhGU7rfxf0e0fkqw99IWuVYRrdULKTGYR6bsK7qG85Xqb0gKueqcI064grtJ+NYSO1beyJAZ0EknYUd0lko6HR7n/RU5au6FXNxLNStmCs2FnovjefPQFnMeG7wH184Xu/9gXkcrxU9A/gSAX94Dr37KRYqmf+QsRCvQY1AGcpuG8nuKSiLkZ3B3weyezggO7ZtHHdGqSw2TuLYVK1R4btQ/M0xJNbj8apkbBIdCxn+RtLa5jLjVWz+qMNYbywWek7QU/2AsZBar0NcHAuhn32KykahjOMd9Ge8rof2zbGQ4cxrE8dCas8Y46rDO5Vz4nnHi5l9pbb2POWsRoCG0U7hTjxmIlwVh02sq/r+zfAby5BObOz0QUdcVRw2ToffFYnDuhUfcRz2cstJjQoeUh/z/0bkpEaBJscSBn8MxBJ/FIglYnJSoTjM4P/3JOak8mT3pxFxWEh2Br8byO7PC8RhVU5qnE98h/irnFR+TioUh/VCTkrxx7hi4zCD/xH5jZJxk/QbhquK1+LitfRZCnBcVjTGetIRVxWvjdPhd1W85kOnTLw2+5jx9+l/ZeO1T580Xm+PDGc347V9MxpTGa/NIdmVjdceAdkdSLJD2qG7CjheU/vaVSzH42DRvBnW39HyZmq82l7zZqNUhr6RYzJ1ziEmXhtt06aYvFlsjotp5sV1l1G5wZ9yzDjOhZQ3U2f3U7jPV/m1l01+bST7re6x4Hit6P1WCwTPis7CDuksFHS6fU8Tx2sjjnRGAOblvs45KnhIfczl5N/UOuco0Mxb51wIMcerA/Ga1zrnWorXurnOmSe7q53itf1AdtcEZMe2jWPjCJVV65wvPdU6Z368Fro/agTKvNY5DWdemzheQ/5GcnDFxmEG/w7yGyXjGOk3eF9a6CulI+XoRsdrI9lvr6+UjhA9bh/Ha08JXniOlz5LAY7LQnGhmi8+6YgrFEdV8dpEOqF4rVv3anK8NuJIZwRgOF57ypGOinPaxRwfpJjjaSiLiTkM/nMLxuuNBHJEnM95GvAlAv7wHHrPkN/FcaJTv4t3i7Gvm3AvTc5cPvYcpcF/CGT3HMkOabNto5yepDIcU0eozHPvLdZnuam5SIfnXqPjNcPfSDrSj7Hx6hmix3bB8VrJ+cNYvBZ7hwXGayhTdaYyFK/xOUr0jXxWcgTKOHeC9s3x2gfbtInjNaX7KseFZyo5x6XGpemijQX6aGasDhr+RtIq7zI6qO7kUON1+tmjQ7Lf2WePlg1vWrX5quuuvfr84VtvXrJh3aq1N226du11S9atu2n45puRaSQ0A95jOT4MY7+3ifeIY6RNY1gZsLNGCNdoG1x8YR/WZwf4VBtcfGGfGtz47/6klU877DstAg8aWh5fa4gvtfgScvKonG8jXFg/L+GSh+vthAvr8+IiJouYT5ZXCE+eA0W+foX4yjuEnv730Ta4biRceZf7pP99rA2udxAuNQnnv/uTVj5ZXiE86X/PteHrncRX3uab9L9fbYPrjYRLbd4xXB9vg+tawoX1sS7+3Z+08snyCuFJ/3u+DV+biK+PQ9nzVIb1LiI6RSdpWH+yJmkXEZ3nHek8DzB7Q7307xegbBRwhA4x2eD/IrzvRsLE8DeIl4L0xgb/F4ket48TJp8QvDRFGSc5PiHofELQUbhGHHG9QO3JvQiIJmFlL7O5CyZh04596beKPZ6nNo4krW1Ul5HWqF0DAh7x1Ql+p4ynnZLWz7o+L+or3DiexlwIjPbVDRsx/F4XAr9A9Lh9bCMvCl6aooyTFsoWXxR0FK6nHXHxRXt5NrLnsRNplrWRG8FG9ulBGznAwUYwhoqxkU4uj0R8xg++Q/xeNqJi2RF4xzbyguClKcp4Y72yxRcEHYXrWUdcsTZypJONXAE2ckwXbcTkHWsjBn+ig41g3BxjI50kwxCf8YPvEL+XjahL00bgHdvIs4KXpijDOROWIZ3Q4jjies4RV6yNnOVkI0vBRpb1oI2sKGgjivduzL1U/upY+J0noxGBqynqj1DZBwWddjpy6bGaH6Uj6W+bv/PC+rGgI5cHdKQXFlZP65DOaYLOy2Uj3GlE5yOOdHBc4YXVZx3poK+MvaB2A9nBR6FM2YHli+oE/9UTx+vdGLCDvJwlLqyGLqg1+FsyGh1uPJILq4arneze4jTO/BrI7m0FfAjG9CNUhvL4CJXhmMx5X5VfxXesc1jf4AZFPZOv9RfmLbuxsGr4G0lrm8vEWrEHP619z5ejN7awquYSqh9wYRVlivQNV2hhlS/rH4Gy56gM/dnHqAztO+ayfmxTaCNckcv6R+B9N+L4key312X9I0SP28dx/EcEL6pv3gW/sQzphD7Egbg+6IjL1hiqTWat73rxUMCOEgu9UCAWSh8ezw3+UhjPPzkJsdCv90As9JtOsdDJILv/p4qFQs92Ewt9vBy9sVhIrWEXiYXUmvbLIRbqE/whHNqeyicl4l0tQI9pTBN13018Y9kVRGME8MbkgK4Q/HYxr9sXa1/bS16X19A7ycXGxDwdbmCMjscnYwPjFfDOaRNtX6gfRgL0Sq7lTTN6ob1dSC/1pwNJax+2+xAK0sD+yrP5svspP9IGV2g/Ja8DPtsGF++nzNu4PKEs+/B96od/eOxEmGcymJ8cOw7zo+w32xTK4Zd7SQjOcBls+nh8KAfxJYm2Pf4oYskN88GPImL7UDd3SsI6gn2EeyOeht/q0qwYnUWeYnS2aJ+qTeW/HM+Py4d7SsApWunf6sPiHIsPZDhSOd+6aGIbsf4o/May9OkT70KHMwxO0VnQIZ0FkXQWdkhnoaAzKOrVcv41OvyO6SjZhA5hlqWDOsa5gW4ddOPcwIgjnRGA4dzABwUPqc3sf9z4+xZbo7rpk3fo/RsnjNcbynCqPfojiaYXewDN4A/JaEzGxXp5sptHshuFshjZGfx/B9kdFpAd2zb6/oeoDOXBh9NwbEAcWJZAG0IH0NRlEDvKAbTQBU/bwwE0NdYp38gH0NSHOZUPivmQX+gAmhrL08NVB2S/xw9XnT9866Vrr7t23dpN127csHr4xs3DN2+qA2amjq1IEu2JTSKIh58a/T2NyrZR+SoBh09oNO3wioPoyNfwN5LWXihjOepEl4oy+KoerKuuqngP/MYypPO0oKNwPeGIy/Smusqz9R3T6YVP4DzlSAdtc6o+2ZwXrbyWohU8thsTrRj8ayFaWUvRCo4ayCPixkjvIdGOOsFfQ5FeyaybjPR49R19HcruDRGyQ5+WJ7slILs3keyQNts2ymmUytS1P2rGjjiwLEnCq/MqIpiEXQvRkd5I9rubuxbU1TgdXn0xFumpyFL1A0Z6I0BTncQNXeW5jcpGoYxXiNQVOsoHxUR62KaYSM90a6ugY2WPQ9mDVPYh0ebU7m4ju8PPRS+jdlgZtgPfsY0sE/woOg9nv+vUxifI15W85un0QaJjOBD3EyVxx9plXtyAfDVEWT2Cl3/ZbfGR/zzyw8drVN944XfTAD/qMsIvE/AdjjmnDAKNhGhbGY6HT1BZP5QZD2nWcsOiifyVXBk6JUZ+yvax7HT4XaQvFK4HS+KalUzUK7Qdsz/0I49kvweTVptmOylpg9HzLcPfSFplUGb8Ur5X+Sz2EVi3Kcr4Kt6HBZ2HBR2Fa6sjLhsDVD/zfGuroLM1QGeB4FnRWdghnYWCzqCoV8v51+jwO6ajZDPZmfWHHemgHvB86xFHOo8ADM+38uYMn6M5A15DHjNnMPi/OX683m8FYhfkEevj+PKgaAfT+xLFICXHFjnf4t0VebL7nyS7B6EsRnYG/zsguy8HZMe2ra63UvOth6kM4wTOKRWdb2H9HW2+pcZ4a99oOXpj8y2Vjywy30L6vHql/OyDVKbm0cqfccyF9s3zrQfbtInnW4q/KhaKi4XSZynAcVnR+OUDjrhCMUoVC02kU8VC5eiUiYV+5hQLXQPj+c8nIRaqZ/SmMhYaOH5iW8rGQstBdo3st8q/sW2jnDgWUjkdFSfxvL7oqSSsPwk7dKNjocnYoavGK48Tgel/o4Je3o5ZJdMR+G24QrEQ557VbkDlz56gslAstK1Nm0KxEK+7Y96YYe+H9iLsENjZOcfn03qU+Lgfyh6jslj7RBwoX/QVCH81tcHg52V8p7nGty/SOKclWkfN/6jcp7VjOtC1sgL6+4WUr8sXjdNBfUkfzJuiviRJOKYy+EcFPOocx4aPQhnHc0ofMb4wfVTyMh67IS/kIUZeag0sVl5s9yivxwmXin9RhiF5GY/dkBfyECMvtcclVl4mAyWvDxGudnOcFQRvuAcS7RN417TBLwWfwLfyhHz8/QI3+sYa4cB21EU7BqkM66Z4nz3ipd+TlefhWHMEeGFdQLx8484qGDeuJtmMJuNPzPqWynGMAgzvJB2BsqcicD0YoP20gH8qQBv54j0yvDdnBH5bPeUHTDYd+oF+5QdGEADw5vUTwsfISvWTWnPnvXGxOacRKovNOeFJi6tz5iTYjjyfzfaA8xme66h5Qkj3Qlf0K91TOVZl/+w31L4aZUvsN7Bv2W+U3Ql/I81RUUc6naPyHq5R4EHpd94O9zvBt23K8W39BXG+GcajVWCjSaLX2zv0BXXlC0YBgH1ByAenT1G/OZL9jtm/qtbNR+AdxwQmowEBj/h4b957ImOCUeI9NgcemveZPaRyfybjo90eyPeS7qnbHEJ7IA3+o6DP76c5noffeITK0A/waWfUqZCeqd37Bhfac9vhvvPoXArvOx8tRy+471yt83h8cjn9T52cUf2AuZR2pzfNV022X0M5xfg1tdak9hCyPaOPYD+g9ryqtRimhz5iBNrwDNm+8pGxMQvmr39GeWi0L7b/EShj+0d957gBZchxw9PAi4p5DC9/wu1F8GFfJNkoXR6Bdzx2PSPgcV8q32qDuv5MBK4nA7TVaflnArSRL74B6hn6W9mkssWR7Hc35hsYF7Atqn5C+BhZqX5St8A8Q2Wxtvs0leH4PkplqNt4EvWLOeM2tkPleNudTn8vjd3bS67gD8B2v1XlClpoM59Wr8oVtNput3MF3+pSroD3iFW5gvHfebmCf9wOcgV9J7z0b9rHP3DKFfyoyhWMlU1VruC/eiRXcFCmX+1yBf0nTGx32VzBK0Cfp2e/q1yBfKpcAdGrcgVTkys4iGzfK1fwue00V3A4+LAzSDZVriDfJqtcQTHb9cgVnJEzbmM7yuQK+mnsRr75vL6yKWXzfF5/JGmVBfdfXq7A8NYJ/lyw3StJNsp+1P6/WPvhOZOynxCu0B4jdSPSRwK0kS++gZ1tWZ2h7+I4Km0X7ZNtN+Qz0ydGVqqf1A24fNOuynupuwP4ligch9jmUbdHkvE2s36qvU2x4y7uNeL7O55sg5flOSLgQ7e2qxxK6IyYsn/2G+rWNqXr7DesP1FXEZ5zBQZ/bdYXHd64KnMF/IWAZ4AHpd88tzL4d4Jvuy7Ht/UXxLkxw9MuV2D92I2YGu2dfUHIB6dPUb/Jdot9w3fGxN7gxnY2kOgYIu+G1rdCH3CuAP0RxxmjUDZCZU8JuqH7lFK5f5ByBeomzxTu3aR7I1Cm4lLWPYMfAX2+neIND7/xNJWhH0AceWOO0jN18x+OoVzP/ECHNyVG5wr4FvtnytErfIu9x03V6X8fFfRUP2CuoN1N5qFcQTf92ggAxPg1hOe5O7aR7Rl9xAiVjUIZ+4+nAvTU/A59RMhHxs43MGZ5LeUKRgCO7R9tnO0f9Z3jBpQhxw3PAi8q5sExG+GfBR/2WZKN0uVQHKtu9Mfb+HkdJvS1X4VrJEBbfSXnYwHa6is5zEuS5NukskWTTTfmGxgXsC2qflJf0AjJSvVTk+BRNkVt91kqw/Gd7Rp1+yPQ5s/mjNvYDpWvVPHACOB9N43dyHc3bnEeSSa2Q8W+6GcML8e+XwLb/TrJRvln9JdF406eM6n5egjXaIB2SH8VbeQL6zJt5tPqKds12XTDdj3nB0pWqp+aSatdsw3G3ijN9hl7ozSOu6yfo6IdsePuKODlW93VWmtI90J5VqV7T4n2KfsP5dbYb6COst9QX9lkO0NdRXjOFRj831GuoOSXfGSugL9eh/kMpd88tzL4/wDf9p0c39ZfEOf3InMF1o/diKnR3tkXhHxw+hT1m2y32Dcxe8FQppwrMBkNJDpniXteEP6ngVwB+iPOa8becM97p0agDHMF+5z40m9ei0l/Y67gP3PWz1D30Oew7hn8HPiiZJL99vQbI1SmckahMSf01Vy1LqD02fxAh3Pp6FwBf/WpZG4i+NUnNd/p0G+O5QrUHEf1A+YK2n3pLJQr6KZfC62HtJMrz92xjWzP6CPYD6CPYP8R2scwAvUwFjcfEfKRsTELrnnuT7kCtK/QuhjbP+p7aG49kkxsh/qisJpz1Ql+LviwBSQbpcuhOLbdfJ1zn2q+HsIVylOoL8c+F6CNfGFdpp1nk8oWTTbdmG9gXMC2GMrRpE+MrFQ/NQkeZVPUdj9KZeqrj8p2MQfG+tluPwXbbl7+8D8Def5ufA2a59a/CrzwOjyPAwi/GGx3Dcnm48n4E6MT6kvIHwcY9lOoE89H4ArtCXpBwD8foI18YV2mzXxaPWW7Jptu2C7aG9uu6ieEj5GV6qcmwaNsrCz2y9S/SmWxX6Z+DtrM+qnW//Pu5GF7wD1B/HV45QtDutduzGLdU2OWsn/2G2j/I1SGOsp+A/uW/QZ/cZzhOVdg8GuzvrD4E3WkgK7LXMELxOPHgQel3zy3Mvg3g29bl+Pb+gviXJ/haZcrsH7sRkyN9s6+IOSD06eo32S7xb7hnI7KO6BMOVdgMhoQ8IivTvA3QR9wrgD90ceJ9xEo4xhE5Y6VP8JcwUOUK0DbxVzBraR76NPYX6QP657BPwr6/HbKFXj4jWepDP0Ax9ZqzFF6ptaKcAzleuYHzK+gLnYjV2D4G0lrm8vkCpT94fjAuYKSfnMsV/CioKf6AXMFKFOkb7hCuYJu+jWUU4xfQ3ieu2Mb2Z7RR7AfGIEy9h8fCdBDH4Gx+ENk+8pHxsYsOD9/IYtZlI2z/aONj1AZ6jvHDShDjhteAF5UzINjNsJ/CHzYp0g2SpdDcewnBPyLAPMxag/q+icicD0XoP1JAf+JAG3kC+sy7TybVLZosunGfAPjArZF1U8IHyMr1U9NgkfZFLXdF6gMx3e2a9Tt56HNn8oZt7EdOG6z7X5M8IrxwPaWK/gc2O4fkmyUfw7lCorO19GHvRCBKzRfC+mvoo18YV2mzXxavV7KFah+CvlYJSvVT82k1a7ZBiczV/CHXcoVvOVlniuIGfNRVxGecwUG/03KFaCOdJoreJF4xHxGzLze4H8Evu2vcnxbbK7A4P+2B3IFaO/sC0I+OH2K+k22W+ybqcoVfD8yV8B5zREo88gVzMo+TtIuV/ATp1zB7gvG6/3rJOQK0A9wrkCNOUrPVK4Ax1CuZ36gw7l0dK7A8DeS1jaXyRUo+wvlCkr6zbFcgZrjqH7AXIGaiyCuXswVtJMrz91VTrPofIP9R5lcgfmIkI8skyvY4JQrQH3nuAFlyHHDi8CLinlwzEb4/cCHHUWyUbocimM95ushXKFcwacE/CcDtJEvrMu082xysnMFGBewLYZyNOkTIyvVT02CR9kUtd0XqQzHd7Zr1G3MgbF+euUKOB4YEXiVT6gRvwgfmp+02zsa2mv0USpTe/WZDvqEEYDZlP3mvUYnZ3JuF1Mb7Q71fWa399G0mw+OZL9VbMR7XlDGeB6Jx4YR4P1SGhswF8V7MkJ3PXBd7IOBHHjeT2bw50Ifr1ykcSIPI/CuU33GNnSqz2gb11JbDf7CydXnGVOtz6yzqM+cE1L6XEtafVgn+ZyzelD/X7cD6f81Pa7/ai4R0v92ORLWf4zfpkL/jyyg/y8EaCr9t7bl6T/mExH+loD+K/mOwLuia4Qh/f8ElWG9D+bQQf3Hfmf9N/hfidR/o90N/UcZsf6H5k3pU3Suw2sCGL+H9J/Xa730f88C+j8SoKn039qap/+Gj/Pl9wT0X9ngKLzrdK0L2/AilWG9D+bQyYvnWf8N/sFI/Tfa3dB/z/lruzzDSPZbrXWH9J/XObz0/+fHvPTb+ngU4EJ3OMacY1dnVfh8oTqzqc708ZnNj0Bu6DM091Yx0tPwrhtz3hCu0QDtdndjMG11Nwbzkgg+rV4Xz3/1d/tcq5KV6qcmwaNslG2NUlnsuZLQXXl4Xoz1c1S0I9Z2RwHvs8dMxPvhNniL3uFqtJT9P0Nlobtf0f5jzrErXWe/get9iYDntWiD/92sL2x9A3WkgK7LtWi+qwbP4Sv95rU7g/8m+Lbfy/Ft/QVxfiVynHW6q6be7btq2vlNtlt1Nq1GfyMutX7DdjaQ6Lmu4eOz3n8q4jrlj/g+DnVfk/JHT1MZ2gyuRf8HrUWj7eJa9LdI99Cnsb9In7y7GP8L9Plvst+efoPvw1J3HYTGHKVnTVEfx1CuZ36gwzPg0WvRhr+RtLa5zFp07P10HfrNsbVolSdU/YBr0eoMLeIKrUV306+hnGL8GsLz2jC2ke0ZfQT7AfQR7D9GAvTQR2As/h9k+8pHjgq8g1SGdVO8H6T5BtpX6D6nmHPsas8cxw0fA15UzINj9gT4k8br7X3SRJxKl0NxbLtz5nx/kDpnHsL1TID2xwX8rwZoq3M7zEuS5NukskWTTTfmGxgXsC22W5ONkZXqpybBo2yK2i6vb49AWeiuPMy/s36G4vz0Ydv9sOAV44GZgn5o7B6hMhUrKbvm+2nUGsMowOTdT3Ew2O6JJBvv+ylGqT1F76cI3cXXzm8w7ep+ionwqp9i7qdQ97Uo++QcA84zeD6ixhyln+2+KRYad/FumaspV+B9DyTrnoqblf2z34gd19lvYN+y3+D4kOE5V2DwS7O+sPgTdaTTXAGP43jmRuk3z60M/nLwbefk+Lb+gjiXZ3ja5QqcxvF6t8fxdn6T7Rb7huePaixFmXKuwGQ0kOg8heHj/PbF0AehXEGReEHl75Q/wlzBmzM+OJ+b/sZcwZWke2XzVG8FfX5t9tvTb4Ria963qsYcpWdqbyCOoVzP/ID5FdTFbuQKDH8jaW1zmVxB7Ny9Q785litQcbjqB8wVoEzV/T2hXEE3/VooB9pOrjx3xzayPYfyiSNQxv7j6QA99BEYi785Yr4xKvCqmAXnG5dTrkDtPyp6TpbjBjWf43Ejb09T3jnZd4MPe5Bko3S5kzu1eB9+0Tu1Qjn2FwR86AxAdafWRHjVT+rMSehOrZDtco4Bx3e2a9Rt3F/+YM64je1QayEqHsAx/0oauzFXwN+9KJoPUDbPcZqKfUcFrxz7Pgm2+8ku5/lGqT1F83yh+Vq7PB/TrvJ8E+FVP8Xk+fC7F5wriLVPtnnUbRx3P9mlXMEcyhUonxDSvXb7aVj3Ys+QsN8omg9Qus5+w/oTdRXhOVdg8L9FuQLUkU5zBR8nHjGfofQ770zwn4Bv+2KOb+sviPN3InMFTvu3C58FDfng9CnqN9lu1Rhfo78RlzoDxnY2kOicZd55gf8vkCtAf8R5TfRHnAP5sKCr/BHmCn5EuQK0XcwVfJ10T+X10eew7hn8T0Gfv0Hxhoff4D1OKmcUGnOUnql1XhxDuZ75gQ7n0tG5AsPfSFrbXCZXoOxPzXc69JtjuYLY+/cwV6DmIogrlCvopl8LrYe0kyvP3dWdL8pHhNYw2H98OEAPfQTG4j8i21c+clTgVTEL7leYTbkCtC+2/6L5ADW35rjh48CLinlwzEb4/wQftuvCiTiVLofi2HbzdV6HUfP1EK5Ozj2F7gtpd6eWssku3jch5xsYF7AtFr1zV8lK9ZM6I8bnZ2Jt9+NUpvIBynYxB8b62W7PJtvus4JXjAe2t1zBvgvH6x1JsqlyBa18VrmCiWWTmStg/fTKFfzp0RPxVrmC8d95uYJTs77o5VzBReDbzsjxbUVzBUsyPFWuYOpyBSugD6YyV7Ax46NdrmBNTsxRNFdwE+jzpdnvKlcgnypXQPSqXMHU5Ao2ku175Qr+3yxm2d5yBbeCD3t/lStooZ1nk1WuoJjteuQK3t+lXMEaGrtDuQLkbZTKPM8gjABM3hmEh8F2P0ay8T6DMELtmcwzCCNEuzqDMBE+dLdf6AxCKFcwCmUeZxA+FpErGIF3bLsjgtcU7zbKFXifQRjJfhc9g8B+I5R/mOwzCL9BuYKSMX1XzyB8BXzbZ3N8W9EzCP89MldQnUFolanXGYT/FZkr4DzHKJR5nEH4HuUK8s4g/CHpXtkzCN8Hff4qxRsefqM6g1CdQfgl8uzfl+sZBPQR7AdGoczjDML3yPaVjxwReFXMgmcQ3ku5gthcIdv/ZJ9B+An4sOknT8RZnUHIt8nqDEIx2/U4g8D66XUG4Q9p7Ea++c6gydpXMCJ45dh39snj9Q4h2XjvKxih9hTdVzAaoN1ufWyEaFf7CibCq36K2VeAObFRKvPeV8D6OSraMQLvQuPuKOBdE7GvIKR77fYVjGS/i+4rYL/RS/sKjs/6opf3FSwH37Ygx7cV3Vdwcoan2lcwdfsKzoI+4FwB+qNu7ytYn/HRbl/B+aR7ZfcVvBH0+YLst6ffqPYVVPsKfok8+/fluq9A3WXWrX0F68n2lY8cEXhVzIL7CpYH9hWw/ffSvoIbwYfdTrKp9hXk22S1r6CY7XrsK7g9Z9zGdpTZV8DxwNMC76jAWyN+EX4E3rH8lc8J7VdQsZBa53wqhw76BGzbmuxfXvu5LzKm7uZavOe3A9rNB00mKjbiez7Vnblqz9nTwPuxNDbUAG4l8VpLWnmtibY1c+orXNgvh8Pvw6Ac4T9Bc0mUZ4F+XTkIdRLAgbhL6sxKbKs9Kp7E2EnRS5+GKKtH8PLbCz9//lP/cfyMGtU3Xvgd62W/gF8p4E1WA8T7UBL1nK9s12hbGbcdy9D+jIfUZjcsmshff0n+YuSH+JsCfhXAFemLWclEXUB9N3vFO3ofpDL0zaNUpnxzKOfM/g39Nn4HhNfsDf43IJb7vYixEuPnbnybJoQr9B3adnvcmLaayzIvSZIfAyj7MNl0Y2wLrcG2i2liZKX6Sa3Zci7pQSjj71GNQhnHh+rbN6E9aEo/vb5p1aDcsYrNQrrXLjZj3YuNzdhvhO7PLZo7YjtDXUV4zh0b/J/SeF8y5yJzx7zn9KPAQ5Fc2/fBt/25U/7uLyc3zi2cYym657Sd32S7De09+LDApeZWbGcDiY6xDV+d4L8byB2jP+K55SiUhfJJHL+jzWDuePCUl34PJq22i7njH+Tkj1D30Oew7o3xesp4vR9R7tjDb3BeCf0ArxOoMUfpWVPUxzGU65kfML9Sct9XdO7Y8DeS1jaXyR0r+1PzzA795ljuODZXjbljtRaOuEK54276tdD8vZ1cOZer1lKVj2A/MApl7D+eCtBDH4GxuPmIkI+MjVk+DHh/ftRLv5WNs/3H7jONyTnzuKF8GI/ZCL8n+LBXkmyULofi2HbrnqG1sI9H4Arlh9rtcWPaao8b85Ik+TbZxXWc/m6vTytZqX5qEjzKpqjtcn44NueM6z6sn6E4P33Ydp8RvGI8sL3lCo4H2z2HZFPlClr5rHIFE8smM1fA+umVK/jyURPxVrmC8d95uYKLs77o5VzBG8G3XZbj24rmCq7I8FS5gqnLFQxDH0xlruCuyFzBdTkxR9FcwftAnzdmv6tcgXyqXAHRq3IFU5MruKtLuYLf2k5zBQ+AD3umyhW00M6zySpXUMx2PXIFz3QpV8DxwEMC75MCby1p9UMx+8yeFvAoD/6uNsqRYwKs92AOHZWDSB/eZ2bwn4iMqY12N/QdZcT6rnw2wrO81fwRY2WeX6s9f0rfjabx/KTAmfL+LI0NjwPcB5KJZR+CMj7LPAJl/K011BHkA/sJ9WArwBjeOsF/AcaGr5GNKB3+ELzjPgj1GfKj9DpmXvN4gHa7/mfayBfWZdrMJ+qD0bIyk003bAX9D9tKyNekT4ysVD8pW+G47gNQ9jiVhe5Owm+tjVAZ6vZoMt5m1s/HRTu2wjseG7YKXn95foByUSMCb0j3RgX8CMCw7n1ItE/ZP/sNtH/2G6ij7Dewb9lv4Hw/EfCcizL4v6FcFOpIAV2XuahniMengQel3zx3N/h/Bd/2dzm+rb8gzu9Ejpsj2e9uzNkmc9xku8W++RDh+pDApeZvbGcDiY6RDF+d4H8UyEWhP3qaeEd/NEplHxR0lT/CXNSep770W51PwlzUv5PuoU9TsSTrnsHvc+p4vf+kXBTSLus3OCZFP4A4WKdCeqbmCRxTYT3zA+ZXUBe7kYsy/I2ktc1lclHK/kbhHeeiSvrNsVyUmh+pfsBcFMpUzZdCuagR4B9hPfwayinGryE854awjWzP6CPYD6CPYP/xwQA99BEYi5uPCPnI2JjlQ4B3Ec030L7Y/kN3taK+c9yAMuS44RngRcU8OGYj/BD4sONJNlNxL2UI12iAdrtzTSNEW+XimZckybfJyZ6bY1zAttguJxMjK9VP6gwYr4XF2i7nt3B8Z7tG3cZ8L+vnqGjHCLyLvWOF44H7BN5+gdfgtwKuPsKR/t6U/a4T/ClZezB2NZz3Cx5C56e2Cfj7Acb4mZm0+rFtVIb17s5+K303uA71fYbSd2wP6/uDUNYn4Fk2KreIOSXD3yR4lJOV3Q1lRnOQ8KC803c3HjGRn3Z9y/r1AOBSfXtL9rtO8CsC+qX05R54xzIMyRz5mUk8YN2Zop7JV+mXwXWoXzOVfmF7WL9C+pI+LJuHBTzqkPHdJHiUk5WhXRpNdV7zfuB93isnwqH/quX8a7zyO54nIK5VxM9WRzrY7sOJzr1QhvO4q2g8QJn0ibo3ZL/rBP8OiIGGs98zRf2tVN/K3gB29r5F+fXZB+MY0U9lKA/0OXntRPhbctq5Afh8eyBXYnx1aHdNZXfo+2L8OsIX9evsu9Em7yVc9wpcah7AMcJAovvA8NUJ/lboA86VoDzuJ97vLsi7Gk+UH7G6Ke3/O/+l3yoOeIBoqjFM9VVT1L8/B9c0wT/aLfd7X6LHQ4Y3ncB8pfLPdYK/A/rq3kUaZ5LDw705PA/kwD9IPBj83UJfQn4A9X8b4TT4ewDnOwvivCkH59ZArKHs9AF4V3Q85XgC5fgwlSHvPC4+BPQZdjPRxzLUc6abBPjlMbUdvzzeWNmzMF49nv2eTvgK+uq+UF+tFvzG9tW9gfYxLqtXT1r1MWQjKI+nTtU4+wvifEaM6SpWOQzwP5sTjyRJazySPuyX0WegHV5FMQnS7yf+bZx4XtijGusNV2djfe2v1Fh/N0DwWK9kg/DsEx4Q8NiPHGPjeDOPypAXjq3uFnRix9K7oa3/ff5EvFsDeNPfryU+2sV412S/2Q9/LuCHlQxDMldzRJQrr6Nif3BOQensZOsjtp/1MdTW9Ck6H2Z9VOOH0keOs0J6kz4hfcS81IsU2yGvPPd4MMBPu5i7TvDm4wdy4NnnG/wfBeKeRwQPoXnCowL+EcHzTOIB6zLtvP1dK6k9Bv/1SH/slPOYpfQf5cb6H5JR+rBMHxPwKCve3/UYlD1MZcjLI1Sm8kghm421Daub0r6TfLV3fo59tcF/u2B+LuSru5WfC/nqbupqr+bnkJfY/NxbImKB/gD/Sh+3Cv5VXon7Hevdl7Tna6vgS81jtgbonNQhnZMEnW7nIE+i9twfaE/RXAjWv5/ac79jexTP7XKqjdOSCW1Tvg3nMDzeGfzc08brDWa/QznVorp7TzKRz1AOKX1WQ/uTpBsxp163ncyYk+NKHC9jcoaoezh2GkxCPHZDXmjPMXNG5TdC8lU5umbSKsv7qAz1bSvR8cq/Xji/Pf/3BdrbTj84F9NDa3RTHgOwLhRdo2N/iXSUv+Q+Rv+K/cJrVgZ/fOZTVeyo9CCkN+3mdMaP0g0+16/y/F30IT2tN9uoTOUdY/UmlCvEMdrG71COrJZMHCdRnxE+b31lK+Gp0fud4T3Wu57azDES495A8NbOgRx4w8exyHlgKysDOTGFcyPxsK0NDw8QDwZ/geAhJP/0CcWE05NWWyxgN/Ua4TN+8B3ibyRaP4aSqKfG8jN6Sg/Sh21Z2ZNaKwn5QGXnClfMunQsLosbVAy7gOgUnRdh/dD8a2GHdBYKOt2efy0gOtsc6aDNLCQ6DzrSQT3Ym+g85EgHxyPeO3Of4CHV7w00z3sYylTMcHH2L+dpf/308Xo30jwPfQXyiPVVzgTbwfRuyWiY/8M8bgF/JM85Ga52snsLyU6t1YRkZ/CPgezeFpAd27aKMWYmrfLgmB7zs7z2qvK/+I51TuXIB0U9Hq8wD1xkrhhjG4i/kbS2ucx4pfLcGBPy+ZEPlKM3dn5EnaFU/bBromWqzn9yflPFG8o3Pkpl6M84T4/2fRj8Rhp5bbLYdmaAPxWHYuym8i2se5MdKz1Qjl4wVlL5oaKxEu+/6tVYCfnkWKlozhXr3x+gs7BDOgsFnW7ndqtYKZ5OmVjpRadY6RQY7z9F4z36iphY6QHRDqb3Gz0QK30mYj0hJDuD3x9k97mA7Ni2q1hpnE98h/irWCk/VlLxRjdjpQfatIljJcWfinfSZyiJe2JiKWxfgb47KFY3Db9XLKXiEhVLWfseKkdvKNW1nbN6GMeuhd9q/xP2l1f/qdzMVPXf1nL0gv2nclae/Ye2VaT/lG0eA7+xDNsTiiux/mTFlccQnbwx/js0xqs1LRzjec+Awf8r7Bn4Ho3xsfsC7gWeuc1O6/x9Rc81hfYup0/Rfbc8RoXWrdWe8lrS2idF163xfOuxOevWNcB7g6jLto3w2wQfBs9naRiGz70Y/H/CGsyynP12eede8tZhk9PHcU72uReUM58jwXqhdViD69AmDlI2ge1hm1B7eFWsaPDt9vCy3mMsu41wsX2lz0qBK8Tr1g545X7EvuL9xgaLeontYb00+NlCL1X/m8y70f+hdXgl09A6fDuZcr4rtBc5tA7fbs8N+8T7BA84Jk7WHJVzBo8BL32CV8NbJ/hXwDz7pNMn4rT5UpLE2ayan+Gci89D49zs8QhcIV/6hIB/PEAb+cK6TJv5tHpdtC25Tw7n2mxbqp8QPkZWqp/UvS58x2TsfPkxKoudLz8KbWb9VHFWrO1iXopzVspXhXQvdqwKnTdR9s9+Q41xypbYb2Dfst/gPAjDc67R4M/O+sLmX6gjBXRd5hqfIB4/ADwo/eYcosFfCb7t3Bzf1l8Q5/mR46z1YzfuaUN7Z18Q8sHpU9Rvst1i38ScDUaZclxvMhoQ8IiPz1ZdCn3AdyqgP/oA8R6bv+PzSmoNIZX7rRkffN4q/Y3z5deQ7qFPY3+RPqx7Bv920OfXZ789/Qbv7UQ/wHGqGnOUnqn4DMdQrmd+wPwK6mI3cuKGv5G0trlM3io2R92h3xzLiX9Q0FP9gDlxlCnSN1yh+ye76ddQTjF+TeXJm0lrG9me0UewH0Afwf7jwQA99BEYi99Ktq98ZGzMguuQL9J8A+2L7R9tnO0f9Z3jBpQhxw1PAC8q5sExG+FvAx/2MMlG6XIojlXfwsN7Bh+h9qCuPxmB69EAbXWP6JMB2up+Y+YlSfJtUtmiyaYb8w2MC9gWVT8hfIysVD81CR5lU9R2n6AyHN/ZrlG38V76h3PGbWwHjttsu48IXjEemKy9f165ghGw3f/W47mCUL69yhWM89POx3rmCmL3IXrkClg/1fpb7Lg74Wx3RK6gk7spyuYK2G/0Uq7gC9tBruDr4Nu+5JQr+N0qVzBWNlW5gq8GcgXoj7qdK/hJZK7gz5xyBf8K+vwXgVxBWb9R5QqqXMEvkWf/vlxzBegjup0r+EmXcgUbArkCtv9eyhX8HHzY7DMm4qxyBfk2WeUKitmuR66A9dMrV8DxAO/pT58r4R3vZeE93nl8GLzpSd5eq7zcwL5Z+3GvldoXtALaNucM3Tb0E2r+wzHeKWeM1zsw+61iHb7XQsU6SdLqlxn29BwZzAM+XnFGPi3TocFAG1McrzwjH+50Acc4pgkZ8Pj2gKin5p58JucRovFwgMZDop6i8SDhRJmpswYfaFP+mGhbIt5NE/CP5LQ3EbQfbYP3YYFH+ZqQj+KY2is2+K3sslxlL3k2ofTqkQDvjxHv7fYCMu9Kfug/1P5IPsvAurVNtLMm/jb+1sM79rHqrneEsbq8P/Uc4TMZZ94+wOEcnMsBJ+9PVTpzJLzjsTjUT8iP2tf4CNVTdwgl4p3qn3sJlnMJpwue8v5+SODJ4yF0vjZ0fs9rT+FzZJvqLkf7+37iHWH5rhQ+m8H6nbefHfUbYVi/Df7KgH6rc4HI13AOztcG9FvJ/Qh4V/T+NJ4bqfvTFO/oe/id6h/Wb/ZHpwue8v5+QODJ40GtO5l+35eDk2myPqQP63e/oJO+O4H0G+nwPe1qr5/ak9cU9fmOJuNhI+gSfxcD+VRtXJmD86aAfnrfxx76htC2QD3sv+mC1pD9+Hn4MXxmCzsl+TrI+9XfCnK6a5Hmpcb8tHm6eI5xqEb4kkTnCLfTc4wHepxj5LNR6W/Mbd9O8z1lY1h3XfabbexumGfdmYMzSTrzTfvOm4i3W3e3KtsNnfvhOzPU926MBxVDIjzfU27wD4Btvr3rd9fXfqhyShgjcjwSOjeVPkXjWP5ej1ofCemXyvWy3uR9D4G/+WPwH4Q+4HUrvJuWz7rcV5D3vDuA2RbRNtiO1blCZXMhu0e+7dsobPcfCYyt3t+X4XV4Fd+p/Tuh86gG1407UCfz3mnDr3IYHEeqe0uV78XzpT8/dCI/6r5l7FvWL8TVJ/h4Tfabv9X3mwH98r7Dn+9mjj3vbLbfxfPOs6f6vLP1bcx5Z/SFfE5efUMx5f0vSb/UOIl1X5/95nHyywVzLSGbazdGGT//f3FXDxpFFITvcpf7TTyiFtEDFSSpFOHgGkUOA5Eo/naKMRFULCRgbAxooVhI8EhsRK1SWogEUcFCOyOIFtFCRK5RJKCiaSLY+MPKjvn8Mju3m7vHbbOX9+Z9b/a9eTPzZjfzrFiLFlNlWdLie8KD9a2B9/t47P9xEPpXIf2FJn3ztiPq+2Dr7Brv4rmwvpHDMSkQPc8L/o1Y1vsX7fykGwo+536qGf5C2G9mw/Cu6V1tveGauuSvN22fzz6rdQ4Ot0XbkwqgD9p/zinjxfosKPY6TJhC/8nQB5pNrUJZ1BztHHvV4pHa/sHKDdAcfz7W1+oc7Ww/rNz+UXO0h5V/lKERkn+051epT8uP5bbYT5D8B+VI/2nIf719+RHC/OcbVRYxw8S+LPmv5yNYPpKVl0f0jUP/vL/V/jnLv+WfR43zhpV/lKFB8re0/MnYdtD/zfmTV0aUL9w3LNcH1WTI0r0cn9F8V57HIDvD+xShXwvjYPlbTTpzY1Wr9Tm/e9P8W0t/WrmFNP2p2UvWnz0wB1Z8hmNLkxF5D7vecE3tInuDe1+2N5NGn9wW13WQvRE8tg1blPGKUx9B8SC2N0JfMvSBprsse1Nvv87xIC3PlraXt/brQtfg+lzt+lyterEytjeoD/m8nKjnaoWVf5Shsi//jY3r2FAceBHshEKZpLvQ7PTnJAv9yz0Zgo93M9/fPNhdGuH/e/EumaNcA/jFxydnK7XPNVf446Vk18ThvQOu8GfTXxZePDt1zRX+x8yB/raH1fWu8G8u7Ctf7t447wr/+tPNA/MHv66rh7/C/52C+gS1Sfv3JNSlFLwk0R/114C3dobJV2lX+vu7XzLo4gF3jWfkR8qyCn1CoZe+cwq91OWhDnUs0uB4IVYW6pH+tP/sMicZaCPtC0r/Gepf4xvL2og+r9DnFXrvOU+QXsNnj/qO27tS1B7LsG95P+1d6dhSfnEehScZ14xCL3UoEywvOShPKFhpaif0YzSP+DzSvqD0j2MRC+Aby3geNfnOKvTe+IxWFnlero658PLs7V9dd+Zc6bD75U1bOw/1XnSF3znzaP/7H2d6XeFf+fD7bfX8mm+u8LdPnRvvKE/fc4V/N/+678lUZsgV/raeie7i89EOV/jtyeKtDdPH9tTD/wMnYFp6txUJAA==","debug_symbols":"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NujGLDnMksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLKkmwTFG4SJuohGdGMQknoeVJRcHkW6HbodulSVjFjoxiEk8F2f1ETYO4iQu4iYa0YlBTCLdBt0G3QbdBt0G3QbdBt0G3QbdBt0m3SbdJt0m3SbdJt0m3SbdJt0m3RbdFt0W3RbdFt0W3RbdFt0W3RbdNt023TbdNt023TbdNt023TbdNt2MbkY3o5vRrbJk7EIjOrHcojCJ52FlycVBnMRF3EQjOpFuTjenW9At6BZ0C7oF3YJuQbegW9At6JZ0S7ol3ZJuSbekW9It6ZZ0S7oduh26Hboduh26Hboduh26Hbqd5zZ+P+IgTuIibqIRnRjEJNJt0G3QbdBt0G3QbdBt0G3QbdBt0G3SbdJt0m3SbdJt0m3SbdJt0m3SbdFt0W3RbdFt0W3RbdFt0W3RbdFt023TbdNt023TbdNt023TbdNt083oZnQzuhndjG5GN6Mbs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMUsWs2QxSxazZDFLFrNkMUsWs2QxSxazZDFLFrNkMUsWs2QxSxazZDFLFrNkMUsWs2QxSxazpDoxx/fVpLNaMRs30YhODGISz8PKkouDSLdFt0W3ypI5Cp0YxCSeh5UlFwdxEhdxE+m26bbptum26WZ0M7oZ3YxuRjejm9HN6GZ0M7o53ZxuTjenm9PN6eZ0c7o53ZxuQbegW9At6BZ0C7oF3YJuQbegW9It6ZZ0S7ol3ZJuSbekW9It6Xboduh26Hboduh26Hboduh26HaeW/V1Ng7iJC7iJhrRiUFMIt0qS+YqHMRJLDcv3EQjOjGISTwPK0suDuIk0m3SbdJt0m3SbdJt0m3RbdFt0W3RbdFt0W3RbdFt0W3RbdNt023TbdNt023TbdNt023TbdPN6GZ0M7oZ3YxuRjejm9HN6GZ0c7o53ZxuTjenm9PN6eZ0c7o53YJuQbegW9At6BZ0C7oF3YJuQbekW9It6ZZ0S7ol3ZJuSbekW9Lt0O3Q7dDt0O3Q7dDt0O3Q7dDtPDf7/YiDOImLuIlGdGIQk0i3QbdBt0E3ZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFkSzJJglgSzJJglwSwJZgn6XucpDGISz0NkCXAQJ3ERN9GIdBt0G3SrLPn+4MdE3+vFQZzERdxEIzoxiEmk26Lbotui26Lbotui26LboltlyZqF52FlycVBnMRF3EQjOjGIdNt0M7oZ3YxuRjejm9HN6GZ0M7oZ3ZxuTjenm9PN6eZ0c7o53ZxuTregW9At6BZ0C7oF3YJuQbegW9At6ZZ0S7ol3ZJuSbekW9It6ZZ0O3Q7dDt0O3Q7dDt0O3Q7dDt0O88Nfa8XB3ESF3ETjejEICaRboNug26DboNug26DboNug26DboNuk26TbpNuk26TbpNuk26TbpNuk26Lbotui26Lbotui26LbotuzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWbJYZYcZslhlhxmyWGWHGbJYZYcZslhlhxmyWGWHGbJYZYcZslhlhxmCfpe1y4MYhLPQ2QJcBAncRE30Yh0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0W3TbdNt023TbdNt023TbdNt023TbdDO6Gd2MbkY3o5vRzehmdDO6Gd2cbk43p5vTzenmdHO6Od2cbk63oFvQLegWdAu6Bd2CbsgSL0zieYgsycJBnMRF3EQjOjGISTwPD90O3Q7dDt0O3Q7dDt0O3Q7dTrst9L1eHMRJXMRNNKITg5hEug26DboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptum26Gd2MbkY3o5vRzehmdDO6Gd2Mbk43p5vTzenmdHO6Od2cbk43p1vQLegWdAu6Bd2CbkG3oFvQLeiWdEu6Jd2Sbkm3pFvSLemWdEu6Hboduh26Hboduh26Hboduh26MUsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsG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"},{"name":"get_last_from_chain","is_unconstrained":true,"custom_attributes":["external","utility"],"abi":{"parameters":[],"return_type":{"abi_type":{"kind":"integer","sign":"unsigned","width":16},"visibility":"public"},"error_types":{"344423948968719440":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]},"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"992401946138144806":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"3080037330898348111":{"error_kind":"fmtstring","length":132,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"4261968856572588300":{"error_kind":"string","string":"Value does not fit in field"},"4440399188109668273":{"error_kind":"string","string":"Input length must be a multiple of 32"},"7564993426627941149":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"7995966536718645961":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"8992688621799713766":{"error_kind":"string","string":"Invalid public keys hint for address"},"9791669845391776238":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"9885968605480832328":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"9921926525851912681":{"error_kind":"fmtstring","length":98,"item_types":[]},"10791800398362570014":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"11021520179822076911":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"12913276134398371456":{"error_kind":"string","string":"push out of bounds"},"13450089406971132036":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"14067204867181196045":{"error_kind":"fmtstring","length":75,"item_types":[]},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"},"16792019527863081935":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17154023812102399658":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17803644318014042523":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"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bdCNWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWVI9gmOMwklcxE00ohODmMTzsLLkIt0O3Q7dKkvGLDSiE4OYxHNxViNh4yBO4iJuohGdGMQk0m3QbdBt0G3QbdBt0G3QbdBt0G3QbdJt0m3SbdJt0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0W3TbdNt023TbdNt023TbdNt023TzehmdDO6VZaMXbiJRiy3KAxiEs/DypKLgziJi7iJRqSb083p5nQLugXdgm5Bt6Bb0C3oFnQLugXdkm5Jt6Rb0i3plnRLuiXdkm5Jt0O3Q7dDt0O3Q7dDt0O3Q7dDt/Pcxu9HHMRJXMRNNKITg5hEug26DboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptum26Gd2MbkY3o5vRzejGLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLFLFnMksUsWcySxSxZzJLFLFnMksUsWcySxSxZzJLFLFnM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"},{"name":"get_last_sender","is_unconstrained":true,"custom_attributes":["external","utility"],"abi":{"parameters":[],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{"344423948968719440":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]},"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"992401946138144806":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"3080037330898348111":{"error_kind":"fmtstring","length":132,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"4261968856572588300":{"error_kind":"string","string":"Value does not fit in field"},"4440399188109668273":{"error_kind":"string","string":"Input length must be a multiple of 32"},"7564993426627941149":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"7995966536718645961":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"8992688621799713766":{"error_kind":"string","string":"Invalid public keys hint for address"},"9791669845391776238":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"9885968605480832328":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"9921926525851912681":{"error_kind":"fmtstring","length":98,"item_types":[]},"10791800398362570014":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"11021520179822076911":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"12913276134398371456":{"error_kind":"string","string":"push out of bounds"},"13450089406971132036":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"14067204867181196045":{"error_kind":"fmtstring","length":75,"item_types":[]},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"},"16792019527863081935":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17154023812102399658":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17803644318014042523":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"TJ3LjjQ9b6Tv5V/PonQgRfpWZjGYo2HAsIE5rHzz08kQFbHx94T/txVKSYzKymJX/8c//sf//G//75//y7/82//69//zj3/6z//xj//2v//lX//1X/75v/zrv//3//p//+Xf/+3v//sf//h9/2flP/5p/ad/7D/hf/8Z//in+PvPxH8W/rPxH8N/HP85+E/gP1n/sR/+g1EMoxhGMYxiGMUwimEUwyiGURyjOEZxjOIYxTGKYxTHKI5RHKM4RjkY5WCUg1EORjkY5WCUg1EORjkY5WCUwCiBUQKjBEYJjBIYJTBKYJTAKIFREqMkRkmMkhglMUpilMQoiVESoyRGGb/f/e+4/533v+v+d9//2v2v3/+e+9+4/73jjTveuOONO96444073rjjjTveuOONv/HG74O8MH8No+FvzLE+WA27wRr+xh3+wd/As34qGvLC+jWMhtnwN/LcH+wGa/CGb2T7IBrywnf0x3c53+EHzIa/kdf4YDdYgzechmjIC185AEbDbOiRrUe2HvkrjfUty1ccgGjIC1+JAEbDbFgNu8EaemTvkb1H9h759MinRz498umRT498euTTI58e+fTIp0eOHjl65K+c1rcFX0EBdoM1eMNpiIa88JUXYDT0yNkjZ4+cPXL2yNkjZ4+cd+T5+zWMhtmwGnaDNXjDaYiGHnn0yKNHHj3y6JFHjzx65NEjjx559MijR5498uyRZ488e+TZI88eefbIs0eePfLskVePvHrk1SOvHnn1yKtHXj3y6pFXj7x65N0j7x5598i7R9498u6Rd4+8e+SqwfggL1QNFoyG2bAadoM1eMNp6JGtR/Ye+avBPT6YDavhb+TtH1iDN5yGaMgLXw0CRsNsWA098umRT498biLNEw03kWb8GkbDbFgNu8EavKFHjh45euSvBnd+MBpmw2rYDdbgDachGhKwfr+G0TAbVsPfyPb7wBq84TREQ174ahAwGmbDauiRR488euSvBu18EA154atBwGiYDathN1iDN/TIs0eePfLqkVePvHrk1SOvHnn1yKtHXj3y6pFXj7x75N0j7x5598i7R9498u6Rd4+8e+TdI1uPbD2y9cjWI1uPbD2y9cjWI1uPbD2y98jeI3uP7D2y98jeI3uP7D2y98jeI58e+fTIp0c+PfLpkU+PfHrk0yOfHvn0yNEjR48cPXL0yNEjR48c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INJt0G3QbdBt0I1ZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkllSP4BijcBIXcRON6MRDDGI+rCy5SLekW9KtsmTMQiM68RCDmBdnNRI2DuIkLuImGtGJhxhEug26DboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptum26Gd2Mbka3ypKxCzfRiOV2Cg8xiPmwsuTiIE7iIm6iEenmdHO6Od0O3Q7dDt0O3Q7dDt0O3Q7dDt0O3YJuQbegW9At6BZ0C7oF3YJuQbekW9It6ZZ0S7ol3ZJuSbekWz638fsRB3ESF3ETjejEQwwi3QbdBt0G3QbdBt0G3QbdBt0G3QbdJt0m3SbdJt0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0W3TbdNt023TbdNt023TbdNt023TbdjG5GN6Ob0c3oZnRjlgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslilixmyWKWLGbJYpYsZslilixmyWKWLGbJYpYsZslilixmyWKWLGbJYpYsZslilixmyWKWVCfm+L6ZdFYrZuMibqIRnXiIQcyHlSUX6bbotuhWWTJHoRGdeIhBzIeVJRcHcRIXkW6bbptum26bbptuRjejm9HN6GZ0M7oZ3YxuRjejm9PN6eZ0c7o53ZxuTjenm9PN6Xboduh26Hboduh26Hboduh26HboFnQLugXdgm5Bt6Bb0C3oFnQLuiXdkm5Jt6Rb0i3plnRLuiXd8rlVY2fjIE7iIm6iEZ14iEEst/VhZcnFQSw3L1zETTSiEw8xiPmwsuTiINJt0m3SbdJt0m3SbdJt0m3RbdFt0W3RbdFt0W3RbdFt0W3RbdNt023TbdNt023TbdNt023TbdPN6GZ0M7oZ3YxuRjejm9HN6GZ0c7o53ZxuTjenm9PN6eZ0c7o53Q7dDt0O3Q7dDt0O3Q7dDt0O3Q7dgm5Bt6Bb0C3oFnQLugXdgm5Bt6Rb0i3plnRLuiXdkm5Jt6RbPjf7/YiDOImLuIlGdOIhBpFug26DbswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklh1lymCWHWXKYJYdZgr7XmYVOPMQg5kNkCXAQJ3ERN5Fug26DbpUl39/7mOh7BVaWXBzESVzETTSiEw+RbpNui26Lbotui26Lbotui26VJWsWBjEfVpZcHMRJXMRNNKIT6bbptulmdDO6Gd2MbkY3o5vRzehmdDO6Od2cbk43p5vTzenmdHO6Od2cboduh26Hboduh26Hboduh26HboduQbegW9At6BZ0C7oF3YJuQbegW9It6ZZ0S7ol3ZJuSbekW9Itnxv6Xi8O4iQu4iYa0YmHGES6DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26MUuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXoe1270ImHGMR8iCwBDuIkLuIm0m3SbdJt0m3SbdFt0W3RbdFt0W3RbdFt0W3RbdFt023TbdNt023TbdNt023TbdNt083oZnQzuhndjG5GN6Ob0c3oZnRzujndnG5ON6eb083p5nRzujndDt0O3Q7dDt0O3Q7dkCVeeIhBLLf4EFkCHMRJXMRNNKITDzGIdEu6Jd2Sbkm3pFvSLemWdEu6Zbst9L1eHMRJXMRNNKITDzGIdBt0G3QbdBt0G3QbdBt0G3QbdBt0m3SbdJt0m3SbdJt0m3SbdJt0m3RbdFt0W3RbdFt0W3RbdFt0W3RbdNt023TbdNt023TbdNt023TbdNt0M7oZ3YxuRjejm9HN6GZ0M7oZ3ZxuTjenm9PN6eZ0c7o53ZxuTrdDt0O3Q7dDt0O3Q7dDt0O3Q7dDt6Bb0C3oFnQLugXdgm5Bt6Bb0C3plnRLuiXdkm5Jt6Rb0i3pxiwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksQd/r9zd9F/pegZUlFz+3vQoncRE30YhOPMQg5sPKkot0c7ohS07hJhrRiYcYxHyILAEO4iTS7dDt0O3Q7dDt0O3QLegWdAu6Bd2CbkG3oFvQLegWdEu6Jd2Sbkm3pFvSLemWdEu65XND3+vFQZzERdxEIzrxEINIt0G3QbdBt0G3QbdBt8oSm4WHGMTPzb4jh77Xi4NYZ3IXLuImGtGJhxjEfFhZcnEQ6bbotui26Lbotui26Lbotum26bbptum26bbptum26bbptulmdDO6Gd2MbkY3o5vRzehmdDO6Od2cbk43p5vTzenmdHO6Od2cboduh26Hboduh26Hboduh26HboduQbegW9At6BZ0C7oF3YJuQbegW9It6ZZ0S7ol3ZJuSbekW9Itnxv6Xi8O4iQu4iYa0YmHGES6DboNug26IUtG4SYa0YmHGMR8iPsS4CBOIt0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0W3TbdNt023TbdNt023TbdNt023TbdjG5GN6Ob0c3oZnQzuhndjG5GN6eb083p5nRzujndnG5ON6eb0+3Q7dDt0O3Q7dDt0O3Q7dDt0O3QLegWdAu6Bd2CbkG3oFvQLegWdEu6Jd2Sbkm3pFvSLemWdEu65XND3+vFQZzERfzcLAqN6MTPzfFvg5gPK0t8FQ7iJC7iJhrRiYcYxHw46TbpNuk26TbpNuk26TbpNuk26bbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptulmdDO6Gd2MbkY3o5vRzehmdDO6Od2cbk43p5vTzenmdHO6Od2cboduh26Hboduh26Hboduh26HboduQbegW9At6BZ0C7oF3YJuQbegW9It6ZZ0S7ol3ZJuSbekW9Itnxv6Xi8O4iQu4iYa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"},{"name":"get_last_value","is_unconstrained":true,"custom_attributes":["external","utility"],"abi":{"parameters":[],"return_type":{"abi_type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},"error_types":{"344423948968719440":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]},"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"992401946138144806":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"3080037330898348111":{"error_kind":"fmtstring","length":132,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"4261968856572588300":{"error_kind":"string","string":"Value does not fit in field"},"4440399188109668273":{"error_kind":"string","string":"Input length must be a multiple of 32"},"7564993426627941149":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"7995966536718645961":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"8992688621799713766":{"error_kind":"string","string":"Invalid public keys hint for address"},"9791669845391776238":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"9885968605480832328":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"9921926525851912681":{"error_kind":"fmtstring","length":98,"item_types":[]},"10791800398362570014":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"11021520179822076911":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"12913276134398371456":{"error_kind":"string","string":"push out of bounds"},"13450089406971132036":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"14067204867181196045":{"error_kind":"fmtstring","length":75,"item_types":[]},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"},"16792019527863081935":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17154023812102399658":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17803644318014042523":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"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bdCNWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWVI9gmOMwklcxE00ohODmMTzsLLkIt0O3Q7dKkvGLDSiE4OYxHNxViNh4yBO4iJuohGdGMQk0m3QbdBt0G3QbdBt0G3QbdBt0G3QbdJt0m3SbdJt0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0W3TbdNt023TbdNt023TbdNt023TzehmdDO6VZaMXbiJRiy3KAxiEs/DypKLgziJi7iJRqSb083p5nQLugXdgm5Bt6Bb0C3oFnQLugXdkm5Jt6Rb0i3plnRLuiXdkm5Jt0O3Q7dDt0O3Q7dDt0O3Q7dDt/Pcxu9HHMRJXMRNNKITg5hEug26DboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptum26Gd2MbkY3o5vRzejGLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLFLFnMksUsWcySxSxZzJLFLFnMksUsWcySxSxZzJLFLFnM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"},{"name":"get_message_fee","is_unconstrained":true,"custom_attributes":["external","utility"],"abi":{"parameters":[],"return_type":{"abi_type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"public"},"error_types":{"344423948968719440":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]},"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"992401946138144806":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"3080037330898348111":{"error_kind":"fmtstring","length":132,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"4261968856572588300":{"error_kind":"string","string":"Value does not fit in field"},"4440399188109668273":{"error_kind":"string","string":"Input length must be a multiple of 32"},"7564993426627941149":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"7995966536718645961":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"8992688621799713766":{"error_kind":"string","string":"Invalid public keys hint for address"},"9791669845391776238":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"9885968605480832328":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"9921926525851912681":{"error_kind":"fmtstring","length":98,"item_types":[]},"10791800398362570014":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"11021520179822076911":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"12913276134398371456":{"error_kind":"string","string":"push out of bounds"},"13450089406971132036":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"14067204867181196045":{"error_kind":"fmtstring","length":75,"item_types":[]},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"},"16792019527863081935":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17154023812102399658":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17803644318014042523":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"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bdCNWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWVI9gmOMwklcxE00ohODmMTzsLLkIt0O3Q7dKkvGLDSiE4OYxHNxViNh4yBO4iJuohGdGMQk0m3QbdBt0G3QbdBt0G3QbdBt0G3QbdJt0m3SbdJt0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0W3TbdNt023TbdNt023TbdNt023TzehmdDO6VZaMXbiJRiy3KAxiEs/DypKLgziJi7iJRqSb083p5nQLugXdgm5Bt6Bb0C3oFnQLugXdkm5Jt6Rb0i3plnRLuiXdkm5Jt0O3Q7dDt0O3Q7dDt0O3Q7dDt/Pcxu9HHMRJXMRNNKITg5hEug26DboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptum26Gd2MbkY3o5vRzejGLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLFLFnMksUsWcySxSxZzJLFLFnMksUsWcySxSxZzJLFLFnM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"},{"name":"get_owner","is_unconstrained":true,"custom_attributes":["external","utility"],"abi":{"parameters":[],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"public"},"error_types":{"344423948968719440":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]},"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"992401946138144806":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"3080037330898348111":{"error_kind":"fmtstring","length":132,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"4261968856572588300":{"error_kind":"string","string":"Value does not fit in field"},"4440399188109668273":{"error_kind":"string","string":"Input length must be a multiple of 32"},"7564993426627941149":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"7995966536718645961":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"8992688621799713766":{"error_kind":"string","string":"Invalid public keys hint for address"},"9791669845391776238":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"9885968605480832328":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"9921926525851912681":{"error_kind":"fmtstring","length":98,"item_types":[]},"10791800398362570014":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"11021520179822076911":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"12913276134398371456":{"error_kind":"string","string":"push out of bounds"},"13450089406971132036":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"14067204867181196045":{"error_kind":"fmtstring","length":75,"item_types":[]},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"},"16792019527863081935":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17154023812102399658":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17803644318014042523":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"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INJt0G3QbdBt0I1ZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkllSP4BijcBIXcRON6MRDDGI+rCy5SLekW9KtsmTMQiM68RCDmBdnNRI2DuIkLuImGtGJhxhEug26DboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptum26Gd2Mbka3ypKxCzfRiOV2Cg8xiPmwsuTiIE7iIm6iEenmdHO6Od0O3Q7dDt0O3Q7dDt0O3Q7dDt0O3YJuQbegW9At6BZ0C7oF3YJuQbekW9It6ZZ0S7ol3ZJuSbekWz638fsRB3ESF3ETjejEQwwi3QbdBt0G3QbdBt0G3QbdBt0G3QbdJt0m3SbdJt0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0W3TbdNt023TbdNt023TbdNt023TbdjG5GN6Ob0c3oZnRjlgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslilixmyWKWLGbJYpYsZslilixmyWKWLGbJYpYsZslilixmyWKWLGbJYpYsZslilixmyWKWVCfm+L6ZdFYrZuMibqIRnXiIQcyHlSUX6bbotuhWWTJHoRGdeIhBzIeVJRcHcRIXkW6bbptum26bbptuRjejm9HN6GZ0M7oZ3YxuRjejm9PN6eZ0c7o53ZxuTjenm9PN6Xboduh26Hboduh26Hboduh26HboFnQLugXdgm5Bt6Bb0C3oFnQLuiXdkm5Jt6Rb0i3plnRLuiXd8rlVY2fjIE7iIm6iEZ14iEEst/VhZcnFQSw3L1zETTSiEw8xiPmwsuTiINJt0m3SbdJt0m3SbdJt0m3RbdFt0W3RbdFt0W3RbdFt0W3RbdNt023TbdNt023TbdNt023TbdPN6GZ0M7oZ3YxuRjejm9HN6GZ0c7o53ZxuTjenm9PN6eZ0c7o53Q7dDt0O3Q7dDt0O3Q7dDt0O3Q7dgm5Bt6Bb0C3oFnQLugXdgm5Bt6Rb0i3plnRLuiXdkm5Jt6RbPjf7/YiDOImLuIlGdOIhBpFug26DbswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklh1lymCWHWXKYJYdZgr7XmYVOPMQg5kNkCXAQJ3ERN5Fug26DbpUl39/7mOh7BVaWXBzESVzETTSiEw+RbpNui26Lbotui26Lbotui26VJWsWBjEfVpZcHMRJXMRNNKIT6bbptulmdDO6Gd2MbkY3o5vRzehmdDO6Od2cbk43p5vTzenmdHO6Od2cboduh26Hboduh26Hboduh26HboduQbegW9At6BZ0C7oF3YJuQbegW9It6ZZ0S7ol3ZJuSbekW9Itnxv6Xi8O4iQu4iYa0YmHGES6DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26MUuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXoe1270ImHGMR8iCwBDuIkLuIm0m3SbdJt0m3SbdFt0W3RbdFt0W3RbdFt0W3RbdFt023TbdNt023TbdNt023TbdNt083oZnQzuhndjG5GN6Ob0c3oZnRzujndnG5ON6eb083p5nRzujndDt0O3Q7dDt0O3Q7dkCVeeIhBLLf4EFkCHMRJXMRNNKITDzGIdEu6Jd2Sbkm3pFvSLemWdEu6Zbst9L1eHMRJXMRNNKITDzGIdBt0G3QbdBt0G3QbdBt0G3QbdBt0m3SbdJt0m3SbdJt0m3SbdJt0m3RbdFt0W3RbdFt0W3RbdFt0W3RbdNt023TbdNt023TbdNt023TbdNt0M7oZ3YxuRjejm9HN6GZ0M7oZ3ZxuTjenm9PN6eZ0c7o53ZxuTrdDt0O3Q7dDt0O3Q7dDt0O3Q7dDt6Bb0C3oFnQLugXdgm5Bt6Bb0C3plnRLuiXdkm5Jt6Rb0i3pxiwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksQd/r9zd9F/pegZUlFz+3vQoncRE30YhOPMQg5sPKkot0c7ohS07hJhrRiYcYxHyILAEO4iTS7dDt0O3Q7dDt0O3QLegWdAu6Bd2CbkG3oFvQLegWdEu6Jd2Sbkm3pFvSLemWdEu65XND3+vFQZzERdxEIzrxEINIt0G3QbdBt0G3QbdBt8oSm4WHGMTPzb5LDn2vFwexrslduIibaEQnHmIQ82FlycVBpNui26Lbotui26Lbotui26bbptum26bbptum26bbptum26ab0c3oZnQzuhndjG5GN6Ob0c3o5nRzujndnG5ON6eb083p5nRzuh26Hboduh26Hboduh26Hboduh26Bd2CbkG3oFvQLegWdAu6Bd2Cbkm3pFvSLemWdEu6Jd2Sbkm3fG7oe704iJO4iJtoRCceYhDpNug26DbohiwZhZtoRCceYhDzIe5LgIM4iXSbdJt0m3SbdJt0m3RbdFt0W3RbdFt0W3RbdFt0W3RbdNt023TbdNt023TbdNt023TbdNt0M7oZ3YxuRjejm9HN6GZ0M7oZ3ZxuTjenm9PN6eZ0c7o53ZxuTrdDt0O3Q7dDt0O3Q7dDt0O3Q7dDt6Bb0C3oFnQLugXdgm5Bt6Bb0C3plnRLuiXdkm5Jt6Rb0i3pls8Nfa8XB3ESF/Fzsyg0ohM/N8e/DWI+rCzxVTiIk7iIm2hEJx5iEPPhpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26ab0c3oZnQzuhndjG5GN6Ob0c3o5nRzujndnG5ON6eb083p5nRzuh26Hboduh26Hboduh26Hboduh26Bd2CbkG3oFvQLegWdAu6Bd2Cbkm3pFvSLemWdEu6Jd2Sbkm3fG7oe704iJO4iJto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"},{"name":"get_registered_emitter","is_unconstrained":true,"custom_attributes":["external","utility"],"abi":{"parameters":[{"name":"chain_id","type":{"kind":"integer","sign":"unsigned","width":16},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"types::RegisteredEmitter","fields":[{"name":"emitter_address","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"enabled","type":{"kind":"boolean"}}]},"visibility":"public"},"error_types":{"344423948968719440":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]},"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"992401946138144806":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"3080037330898348111":{"error_kind":"fmtstring","length":132,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"4261968856572588300":{"error_kind":"string","string":"Value does not fit in field"},"4440399188109668273":{"error_kind":"string","string":"Input length must be a multiple of 32"},"7564993426627941149":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"7995966536718645961":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"8992688621799713766":{"error_kind":"string","string":"Invalid public keys hint for address"},"9791669845391776238":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"9885968605480832328":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"9921926525851912681":{"error_kind":"fmtstring","length":98,"item_types":[]},"10791800398362570014":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"11021520179822076911":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"12913276134398371456":{"error_kind":"string","string":"push out of bounds"},"13450089406971132036":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"13455385521185560676":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"14067204867181196045":{"error_kind":"fmtstring","length":75,"item_types":[]},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"},"16792019527863081935":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17154023812102399658":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17803644318014042523":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"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"},{"name":"is_vaa_processed","is_unconstrained":true,"custom_attributes":["external","utility"],"abi":{"parameters":[{"name":"source_chain_id","type":{"kind":"integer","sign":"unsigned","width":16},"visibility":"private"},{"name":"sender","type":{"kind":"field"},"visibility":"private"},{"name":"value","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"},"error_types":{"344423948968719440":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]},"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"992401946138144806":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"3080037330898348111":{"error_kind":"fmtstring","length":132,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"4261968856572588300":{"error_kind":"string","string":"Value does not fit in field"},"4440399188109668273":{"error_kind":"string","string":"Input length must be a multiple of 32"},"7564993426627941149":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"7995966536718645961":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"8992688621799713766":{"error_kind":"string","string":"Invalid public keys hint for address"},"9791669845391776238":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"9885968605480832328":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"9921926525851912681":{"error_kind":"fmtstring","length":98,"item_types":[]},"10791800398362570014":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"11021520179822076911":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"12913276134398371456":{"error_kind":"string","string":"push out of bounds"},"13450089406971132036":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"13455385521185560676":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"14067204867181196045":{"error_kind":"fmtstring","length":75,"item_types":[]},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"},"16792019527863081935":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17154023812102399658":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17803644318014042523":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"TJ3LkvW6bqTf5Yx7sEASIOFX6UFHXx2OcNgRfRn55buEJJg58f+lzy4mRQopLS2U6j/+8T/+53/7f//8X/7l3/7Xv/+ff/zTf/6Pf/y3//0v//qv//LP/+Vf//2//9f/+y///m9//9//+Mfv+z9r/uOf5n/6x1r/+Kf4+8f/8U/n75/APxv/HPyT9Y//8I/hn4F/Jv5Z+AejOEZxjOIYxTFKYJTAKIFRAqMERgmMEhglMEpglMAoG6NsjLIxysYoG6NsjLIxysYoG6NsjHIwysEoB6McjHIwysEoB6McjHIwysEoiVESoyRGSYySGCUxSmKUxCiJURKj2O93/7X777j/zvvvuv/6/Tfuv/v+e+6/dzy749kdz+54dsezO57d8eyOZ3c8u+PZHW/c8cYdb/yNZ78PZsNq8Ia/MW1+sBtOQ16Yf+NafPA38Ph+ao6G2bAavCEa/kYe64PTkBfWr+Eb2T8YDbPhm/N3OF8BAKLhb+RpH5yGvPCVAsAaRsNsWA3eEA09svfI3iN/5TG/ZfkKBDAaZsNq8IZo2A2nIS/sHnn3yLtH3j3y7pF3j7x75N0j7x5598inRz498umRT498euTTI38lNb8t+IoKcBrywldaAGsYDbNhNXhDj5w9cvbIeUcev1+DNYyG2bAavCEadsNp6JGtR7Ye2Xpk65GtR7Ye2Xpk65GtR7YeefTIo0cePfLokUePPHrk0SOPHnn0yKNHnj3y7JFnjzx75Nkjzx559sizR5498uyRV4+8euTVI68eefXIq0dePfLqkVePvHpk75G9R64aPB/MhtXgDdGwG05DXqgaLLCGHjl65OiRvxpc9kE07Ia/kVd8kBe+GgRYw2iYDavBG6JhN/TIu0c+PfK5iTTOaJgNq8EbomE3nIabSCN/DT1y9sjZI381uPIDb4iG3XAaEjC/GgRYw2iYDavBG6JhN/yN7L8P8sJXgwBrGA2zYTV4QzTshh7ZeuTRI3816PuD0TAbVoM3RMNuOA154atBQI88e+TZI88eefbIs0eePfLskWePvHrk1SOvHnn1yKtHXj3y6pFXj7x65NUje4/sPbL3yN4je4/sPbL3yN4je4/sPXL0yNEjR48cPXL0yNEjR48cPXL0yNEj7x5598i7R9498u6Rd4+8e+TdI+8eeffIp0c+PfLpkU+PfHrk0yOfHvn0yKdHPj1y9sjZI2ePnD1y9sjZI2ePnD1y9sh5R16/X4M1jIbZsBq8IRp2w2noka1Hth7ZemTrka1Hth7ZemTrka1Hth559Mhdg6trcHUNrq7B1TW4ugZX1+DqGlxdg6trcHUNrq7B1TW4ugZX1+DqGlxdg6trcHUNrq7B1TW4ugZX1+DqGlxdg6trcHUNrq7B1TW4ugZX1+DqGlxdg6trcHUNrq7B1TW4ugZX1+DqGlxdg6trcHUNrq7B1TW4ugZX1+DqGlxdg6trcHUNrq7B1TW4ugZX1+DqGlxdg6trcHUNrq7B1TW4ugZX1+DqGlxdg6trcHUNrq7B1TW4ugZX1+DqGlxdg6trcHUNrq7B1TW4ugZX16B3DXrXoHcNetegdw1616B3DXrXoHcNetegdw1616B3DXrXoHcNetegdw1616B3DXrXoHcNetegdw1616B3DXrXoHcNetegdw1616B3DXrXoHcNetegdw1616B3DXrXoHcNetegdw1616B3DXrXoHcNetegdw1616B3DXrXoHcNetegdw1616B3DXrXoHcNetegdw1616B3DXrXoHcNetegdw1616B3DXrXoHcNetegdw1616B3DXrXoHcNetegdw1616B3DXrXoHcNetegdw1616B3DXrXoHcNetegdw1616B3DXrXoHcNetegdw1616B3DXrXoHcNetdgdA1G12B0DUbXYHQNRtdgdA1G12B0DUbXYHQNRtdgdA1G12B0DUbXYHQNRtdgdA1G12B0DUbXYHQNRtdgdA1G12B0DUbXYHQNRtdgdA1G12B0DUbXYHQNRtdgdA1G12B0DUbXYHQNRtdgdA1G12B0DUbXYHQNRtdgdA1G12B0DUbXYHQNRtdgdA1G12B0DUbXYHQNRtdgdA1G12B0DUbXYHQNRtdgdA1G12B0DUbXYHQNRtdgdA1G12B0DUbXYHQNRtdgdA1G12B0DUbXYHQNRtdgdA1G12B0DUbXYHQNRtdgdA1G12B0DUbXYHQNRtdgdA1G12B0DUbX4O4a3F2Du2twdw3ursHdNbi7BnfX4O4a3F2Du2twdw3ursHdNbi7BnfX4O4a3F2Du2twdw3ursHdNbi7BnfX4O4a3F2Du2twdw3ursHdNbi7BnfX4O4a3F2Du2twdw3ursHdNbi7BnfX4O4a3F2Du2twdw3ursHdNbi7BnfX4O4a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MkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZUn2CZlYYxE08xHxYWXLRiIM4iYtIt6Rb0q2yxEZhXhzVRNhoxEGcxEV0YhA38RDpZnQzuhndjG5GN6Ob0c3oZnQzug26DboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26LbotujndnG5ON6eb083p5nSrLLFVeIj5sLLEdqERB3ESF9GJQdzEQ8yHm26bbptum26bbptum26bbptum26Hboduh26Hboduh26Hboduh26Hbkm3pFvSLemWdEu6Jd2Sbkm3fG72+xGNOIiTuIhODOImHiLdjG5GN6Ob0c3oZnQzuhndjG5Gt0G3QbdBt0G3QbdBt0G3QbdBt0G3SbdJt0m3SbdJt0m3SbdJt0m3SbdFt0W3RbdFt0W3RbdFt0W3RbdFN6eb083p5nRzujndnG5ON6eb041ZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazpDox7Xs76ahWzMZNPMR8WFly0YiDOImLSLdJt0m3ypJhhfmwsuSiEQdxEhfRiUHcRLotujndnG5ON6eb083p5nRzujndnG5Bt6Bb0C3oFnQLugXdgm5Bt6Dbptum26bbptum26bbptum26bbptuh26Hboduh26Hboduh26HboduhW9It6ZZ0S7ol3ZJuSbekW9Itn1s1dTYacRAncRGdGMRNPES6Gd2Mbka3ypIxCxfRieUWhZt4iPmwsuSiEQdxEhfRiXQbdBt0G3SbdJt0m3SbdJt0m3SbdJt0m3SbdFt0W3RbdFt0W3RbdFt0W3RbdFt0c7o53ZxuTjenm9PN6eZ0c7o53YJuQbegW9At6BZ0C7oF3YJuQbdNt023TbdNt023TbdNt023TbdNt0O3Q7dDt0O3Q7dDt0O3Q7dDt0O3pFvSLemWdEu6Jd2Sbkm3pFs+N//9iEYcxElcRCcGcRMPkW5GN6Ob0c3oZnQzujFLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5YEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWbJZpZsZslmlmxmyWaWbGbJZpZsZslmlqDvdXzv2kff60UjDuIkLqITg7iJh0i3QbdBt8qS729+DPS9XlxEJwZxEw8xH1aWXDQi3SbdJt0m3SbdJt0m3SbdFt0qS+YoHMRJXEQnBnETDzEfVpZcpJvTzenmdHO6Od2cbk43p1vQLegWdAu6Bd2CbkG3oFvQLei26bbptum26bbptum26bbptum26Xboduh26Hboduh26Hboduh26HbolnRLuiXdkm5Jt6Rb0i3plnTL54a+14tGHMRJXEQnBnETD5FuRjejm9HN6GZ0M7oZ3YxuRjej26DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26TbpNuiG7PkMEsOs+QwSw6z5DBLDrPkMEsOs+QwSw6z5DBLDrPkMEsOs+QwSw6z5DBLDrPkMEsOs+QwSw6z5DBLDrPkMEsOs+QwSw6z5DBLDrPkMEsOs+QwSw6z5DBLDrPkMEsOs+QwSw6z5DBLDrPkMEsOs+QwSw6z5DBLDrPkMEsOs+QwSw6z5DBLDrPkMEsOs+QwSw6zJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmCfpe59fzhL7Xi0YcxElcRCcGcRMPkW6TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26LbotuTjenm9PN6eZ0c7o53ZxuTjenW9At6BZ0C7oF3YJuQbegW9At6Lbptum26bbptum26bbptum26bbphiyJQiMOYrmdwkV0YhA38RDzIbIEaMRBpFvSLemWdEu6Jd2y3Sb6Xi8acRAncRGdGMRNPES6Gd2MbkY3o5vRzehmdDO6Gd2MboNug26DboNug26DboNug26DboNuk26TbpNuk26TbpNuk26TbpNuk26Lbotui26Lbotui26Lbotui26Lbk43p5vTzenmdHO6Od2cbk43p1vQLegWdAu6Bd2CbkG3oFvQLei26bbptum26bbptum26bbptum26Xboduh26Hboduh26Hboduh26HbolnRLuiXdkm5Jt6Rb0i3plnRjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJgl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"},{"name":"process_message","is_unconstrained":true,"custom_attributes":["external","utility"],"abi":{"parameters":[{"name":"message_ciphertext","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":17,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"message_context","type":{"kind":"struct","path":"aztec::messages::processing::message_context::MessageContext","fields":[{"name":"tx_hash","type":{"kind":"field"}},{"name":"unique_note_hashes_in_tx","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":64,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"first_nullifier_in_tx","type":{"kind":"field"}},{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]},"visibility":"private"}],"return_type":null,"error_types":{"344423948968719440":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]},"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"992401946138144806":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"3080037330898348111":{"error_kind":"fmtstring","length":132,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"4261968856572588300":{"error_kind":"string","string":"Value does not fit in field"},"4440399188109668273":{"error_kind":"string","string":"Input length must be a multiple of 32"},"7564993426627941149":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"7995966536718645961":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"8992688621799713766":{"error_kind":"string","string":"Invalid public keys hint for address"},"9791669845391776238":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"9885968605480832328":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"9921926525851912681":{"error_kind":"fmtstring","length":98,"item_types":[]},"10791800398362570014":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"11021520179822076911":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"12913276134398371456":{"error_kind":"string","string":"push out of bounds"},"13450089406971132036":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"14067204867181196045":{"error_kind":"fmtstring","length":75,"item_types":[]},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"},"16792019527863081935":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17154023812102399658":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17803644318014042523":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"TJ3LsjS7bpzf5Yw9aIIEQOpVPHD4qlCEQorwZaSX9yokwcyJ95fW+ZmoYiG7uhrd6z/+8T/+53/7f//8X/7l3/7Xv/+ff/zTf/6Pf/y3//0v//qv//LP/+Vf//2//9f/+y///m9//7//8Y/f9//sv/93/qd/7PGPf4q//9g//mn9/WfiPwv/8X/80/77T+A/if9s/OfUf84P/xn4j+E/E/9Z+A9WOVjlYJWDVQ5WGb/f/e+4/7X733n/u+5//f437n/z/nff/971xl1v3PXGXW/c9cZdb9z1xl1v3PXGXW/c9eyuZ3c9u+vZXc/uenbXs7ue3fXsrmd3vXnXm3e9edebd71515t3vXnXm3e9edebd71111t3vXXXW3e9dddbd71111t3vXXXW3c9v+v5Xc/ven7X87ue3/X8rud3Pb/r+V0v7npx14u/9cbvg9mwGrzhb80xP8iG3XAu5N+6Iz74W9i+f5XWMBtWgzdEw9/Ktj7YDefC1x6Ab2X/wBpmw1fzdzhfowCi4W/lOT7YDefC1zKA0WANs2E1eEM09MqnVz53Zfu6aM4PRoM1zIbV4A3RkA274VwYvfLolUevPHrl0SuPXnn0yqNXHr3y6JWtV7Ze2Xpl65WtV7Ze+euv6R9kw244F74eA4wGa5gNq8EbeuXZK89eefbKq1devfLqlVevvHrl1SuvXnn1yqtXXr2y98reK3uv7L2y98reK3uv7L2y98reK0evHL1y9MrRK0evHL1y9MrRK0evHL1y9srZK2evnL1y9srZK2evnL1y9srZK+9eeffKu1fevfLulXevvHvl3SvvXnn3yqdXPr1y9eD+YDasBm+IhmzYDQcwqwcLRoM1zIbV8LfyGh9EQzb8rbzig3Ph60HAaLCG2bAavCEasqFXHr2y9cp2E2maNcyG1eAN0ZANu+Em0py/hl559sqzV/56cJ0PvCEasmE3nAtfDwJGgzXMhl559cqrV1698teD/vvgXPh6EDAarGE2rAZviIZs6JW9V45e+etBzw+sYTasBm+IhmzYDefC14OAXjl75eyVs1fOXjl75eyVs1fOXnn3yrtX3r3y7pV3r7x75d0r715598q7Vz698umVT698euXTK59e+fTKp1c+vfK5K6/fr2E0WMNsWA3eEA3ZsBt65dErj1559MqjVx698uiVR688euXRK49e2Xpl65WtV7Ze2Xpl65WtV7Ze2Xpl65Vnrzx75dkrz1559sqzV5698uyVZ688e+XVK69eefXKq1devfLqlVevvHrl1SuvXtl7Ze+VvVf2Xtl7Ze+VvVf2Xtl7Ze+Vo1fuHlzdg6t7cHUPru7B1T24ugdX9+DqHlzdg6t7cHUPru7B1T24ugdX9+DqHlzdg6t7cHUPru7B1T24ugdX9+DqHlzdg6t7cHUPru7B1T24ugdX9+DqHlzdg6t7cHUPru7B1T24uge9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwez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qmEjr3dUNWzk9Taqho0ag/itUG8qatio8TysPr44iLVuHVD1Zr3zqQEir3dUNUB0sXrz4iAacRIX0YlBLLc64urNi+dh9Wa93akBokYjTuLnVu9maoCoMYifW72FqQGixvOw+rje7tQAUaMRJ3ERnVhudVKrjy9uYrnVqa4+vjiIRnRirVDbEudhdWy9YaqhoEYjfvV6nZ3q44tODGISN/E8rD6+OIhGpNum26bbptum26bbptuh26Hboduh26Hboduh26HboVv18fd20msoqHEQy20WTuIilpsXBrHcduEmnofV3RcHsdxO4SR+bt/7Qq+hII+qrHr+e2PjNRTUuImfW6wPq+cvDuLn9t3bew0FNS6iE4OYDysJvsfOXoM+HnUU1fNRpVfPXwxiEr96sw6oeh5YPX9xEI34uWUdZvV81lmvns8qp3o+y6J6HljdvetMVh/vWqw6dtdi1bEXN/GrbNd2V8deHEQjTuIiOrHc6vTVK+/F/bBaGpVVS180YlnUqa6WvujEz+Lgf5vETfwO6FQ51dIXP7dTR1wtfXESP7dT10619MUgJnETz8Nq6YuDaMRJpNuh26Hboduh23luNZvTOIhGnMRFdGIQk1huXngeVktfLLcsNOIkltsudGIQk1hup/DPLb43Cl6zOfG9O/CazWk04vxwFi6iE4OYxE08D+ePOIhGpNuk26TbLLdRmMRNPA/XjziIRpzEcquzvpwYxHKLwk08D/1HLLfaITfiJAaxVqht+UIhRm3LFwqNRpzEb4VRO/S9jMeos5M/4iAacRIX8TviUYeZQUziJp6H+0ccRCOWW53fvYhODGK51enbm1hudf2eH3EQPzerU/L1fOMiOjGI2VjTMvHdunvNxcT3YYjXXEx89+teczGNQUziV+93F+81F3Nx/IiDaMTPbVYNXx83OjGISdzEz+278fb6PbjGQTRiuZVx9fFFJ5ZbFn5uqyyqjy9+bqtOVPXxxc9t1TmrPr44iYvoxCAmcRPPw+rji3RbdFt0W3RbdFt0W3RbdFt0c7o53ZxuTjenm9PN6eZ0c7o53YJuQbegW9At6BZ0C7oF3YJuQbekW9It6Vb5sOqqrny46MQglltdO5UPF8/DyoeLg2jESVxEJwaRbptum26Hboduh26Hboduh26n1v1ypwaa/j65KDRirbALF9GJQUziJp6HlQTf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"},{"name":"public_dispatch","is_unconstrained":true,"custom_attributes":["external","public"],"abi":{"parameters":[{"name":"selector","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"459713770342432051":{"error_kind":"string","string":"Not initialized"},"6788092787179896647":{"error_kind":"string","string":"Caller is not owner"},"8228371833434187583":{"error_kind":"string","string":"Trying to read from uninitialized PublicImmutable"},"9967937311635654895":{"error_kind":"string","string":"Initialization hash does not match"},"10748621607991011913":{"error_kind":"string","string":"VAA already processed"},"13455385521185560676":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"14415304921900233953":{"error_kind":"string","string":"Initializer address is not the contract deployer"},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"},"16810041750452690220":{"error_kind":"fmtstring","length":27,"item_types":[{"kind":"field"}]},"18173155084464344029":{"error_kind":"string","string":"Emitter not registered"}}},"bytecode":"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","debug_symbols":"tZ3brmS5jW3/JZ/9sHSX/CuNhlF2VzcKKJSNavsAB4b/vcVJilOZxlKuHTvypWJsVgZ1o26kpPjnl//6+c//+J8//fLbf//1f7/88T/++eXPv//y66+//M+ffv3rX376+y9//W1K//nlkv/EK335Y/jDlxiifbYvf4zzM0b7tL+T/Z2qfuZgn/Z3sb9L0c962We2z4HPJPrz/IzBPqt+Jvs72d/Z/s7ze2V+lmSfXT9rtM+qny3Y50y/zc9+2We2z66fI9pnw2e+on1W/Qzze+ESKAuG/p+Y7VM15WTfTPZNyTE+7e9y2ef8XggCw6BKnUeBbtCS/ttmurvp7qZrmK6hpSvXZZ/ZPrtmtoS0QMtXYrRP1VSSfTPZN5OWrmT7O2sOShF7SALNoM7yhSxQDaTOwxAQI5jlKFLrCsVgLMkwSb2uBWJaU3MV21OoBmIdCsVA8q0gktnSNacF3UDyHLtANZA8KyxJW5K2JF30DIFuIDai0BTaFRZUgzAlKQgMA7EPhaknzfppYiEKzSAvSV6SsiTSYVIRKAtE82yL1vICkUjqkmeFbjCWRPIs0CXPCtUgLInYdo4Cw0Ayr7AkaUnSkkiec50gfV1BOuvMWJd6VigG7VqwJH1JukuGgWReoSsM6ZYKzSCEBZboiNeCssAUDmR1Nu5AfoaAjCOznod0NYVu0JekL8lYEqlMgXBJbRrVRTJWGBUnSacI5cspO/n/LS4rLqsuk4FBqUWntqgHp7poeGrS0YxE8+wzIcgob9QXSa8zqouk3xkVJ9ciJmHkWrJrkTpXElMuVQh13IRQyUpt0QhOxWkYYWYyWlpicFlYWiLy3EHFaSxKyWl+o0q9YO4yqouKy4rLqsvEjIzGIumVRn2RlNJIUpM6SJJ7JalxI/+/0WXRZcllMrcoiTUZFaexSKzJyFOTWcZINIt1YpY0qoukXxplp7FIuoLR0oI502hpwbxpVJxEi7QR5k4jl0nLGLVFaBml4uTfKP4NlBJUXVZdi/QZo7oIpVTyvHTXMvwbY32jXMHJZeFyKk4rfyUmp5WXklxL8m8k/0bOTi5DKTuoL5LVjlFdJCOsUXbyb3TX0l02XAtKOYfF2VWD01gUZC0QQLI6iEJY/Sj1RdKCRi6T8cCoLsJKKIP6Imk3I1mpiJ1WabfWQG2RTBZKMsJ16BvZaRi1Kzu5LLgs9EXS34zaImmjXkB1kfQ3o+zUF8msbdQWVZdV1yJt1DtoahkB1BdJGxm5bLhsLFmX/mZUF8l0aDRraFygsUhay0i0SD13aS2jtkj6m1FxGotkVDFyWXUt0m5DWqbLqGJUF3WXdZcNl8l4bzSMhrSgUV8k472SrF+HWOeQ9pgzqWDBYh1SGbVDgFQaIgRIdYENqTRAkAXfRFmIy1ItYO6PgGYw4gLRmOaEFjH5LyyO2CoYUioZlY3UJf0dIJnIAmLfCs2gL0lfkmGSIMvkAsgLhkFIC6R4Cf9cxp6FWLHjH6RALLrXiEFM2wjZrsDhiA2LIaWV0kppo7RR2hOxO2qFCsbrInoeYqA0ZKLrxSY0yEp4TvX4tx2YiX2VN2KTZUhpq449EAtxOA5oGMC2MF2RWB0164qFKMryhe1zInbHRGmiNFOaKS2UYk+mCGNXlMFmYSYyDx3SAByOKKZhW5hh8oaF6F/LIRMpjYkIZVKT2CoHWY9HzPVzzhSE9RU4EVA2QymxrOzm4kySKPgaTE6xJWJ37JT25igjzkJJrUo9FPg8DLsjPCA1AJtjLI6yBQ2ysonYPS8cjpnSTGmhFGVTRLsZNkfsqGUZELGnNuwXMRO744jEtrBekejKKiy1XcDiGCmFeSrCPGWWntgcZYpfSGmhtFBaKa2UopiG1RFlM+yOg3kYLm1XJLpebMrnlAwsjlo2xUzsjlpMRSiTimo5EKtjobRQWimtlDZKW3FEaxp2RzShoeehX5HoentwvV0LJAbetVlk3OnihJuLBUH0lh6AoldWPLHLvLOQUnQR4MAA3RMwE4cjuohijCsJzNKGmHoMKcXcY1gcC6XoLYbds4PB3JBS2I4iBnPFAQ3iC7yCzuUTqkEMC9aMna50ETNxOGZKi07qCXt1gE3hCXtxwAgLTBKusGBJgk7qCVM4IKYFzSCFBebjxMzdAGXBMChpQTOoccGStLAAhReCMSphPAeNRajKjKQHhF08tjAIGcKTeo1l3J772Iso6mX5OWc9uAgTUFpriDJswBcW/wewAkNIG/zDF7E7wqwNxRIHcgazVhwXUTyGl+hNlzV/uopBuBZ4I+u0rajLKsXumCjNZgc6PQu05cmG50sAni/AkowlGSbJlzV/vqz5c4gLrPlzvBaUBdb82dy5E8zPnXNcUA1KWLAk9VqANTVoLEIVo/F1nkXj2zwb4JkPq8UzrAMIl/RczwqibsXjnbBdjjC0Ei9i9n8gJTFMkKrTfzjKVGMIP6+hdOxQBeHrNRyOshKaa0hEDqypMYkqWFCiDG/QMryZdQI1bI6B0mhtXlM0KNawVcYxhWFQl6QuSVuSvoIZ3Zq6jrCgLLBASLP9wARr6hbSAuvpLYYFNlA08/tPcInZTsNyM4D6IszmEdQWVZetEaW1uMBMqq24S1uBl9ZXOmNJRl8xGmlIiQVMbI4yvUXx9U+sjpFSi2WknsKCFfVZheo5LViJrRGyrxESXusou8OJ1VGX0QVYlt3De6123zFrw9g7tjTAgaElXcDiiC5gSGmkNG7S4SgDzMLumBEnScDmiMibYSEOx5qI3bFR2qisQ1kFIhgzBKXlouwh8oUmM5SvSUXNzUIidkd0b6m+icMxUYruLT7jfGWEdfA16UMLIa2Iz13ETByOjdLWHaVrLZQCFSSMAhmOhfCSz/WvINrNsBCHI8pmSGmiNFGaKRXbi7LWn6N6IErOxG+cQ7uIxbFT2ikdlKJAhn1h1AIpNkesigw9YbjRF3oSMV3ETByOmUlkJlyYRGHClUmwxJEljixxbEyiM+HOJAYTHp4EducLPYkUAtGTSPEiZqInjGl+oSecMpPITLgwicKEK5OoTLgyicaEG5PoTLgzicGEhyeBjfpCTyKHi5iJnjA26gs9YWzUF3rC8MovZMKFSRQmXJhEZcKVSTQm3JhEZ8KdSQwmPDwJBL8XZqInjCD4Qk8YkfCFnjD884YZGmSowJY8yn45Y0sexWueNcytqB1SsTgOSrVDKo6FVTvkAHZH5Fd23BO7Y6QULdT06EAiNkfYpCGlsEnD6gibbDh+AJtUbJSiFzYZlSuKaZiJw3FQinEH2FBMQ2RHRrmGcUe22RkLFcNIKZpFQgEZofOF1RGGaEgpDNGwEJFJacIGQzSkFF1Pts4ZLnlDdD1DStH1DNtCRNgXIuEBHI7oeoaURkojpYnSRCmGV8PuqK0J1NZUZB4apY16G/V26sUIo6jFVPQk4AtYWIiubIRE9EyOGIlUhv5mSGUsMdz7C6msUFnx/I5KZSz8YOFHo7RT2jcpEx4sxVgJF13vGDbHEIjVMV7EQhyO3sYTmYS38UQmUZhwYRKVSVQmAUvtOPaDWU/8J0XXMOKiKXA3LJTsdDm+A5fDQmgoOEEUic0xU5opLZQWSiuleu4GqCdvFIcjDNGQeRiUor/1KkeY0N8knFYQNTDUYipSGimNlCZK0yYdjrA+RS2bYnWszEOltFFvo14UU/wgJeohI8XuOCgdLk1XIlIaKMXoqYhOpoiyGWai5wFHA6LEDAui/9Nbh/Nf+LdiGvA4aK3D56C1nrEwNKQUSRgiiYxDZInYHVF9itWNIMN+FbX6FDepWwli9gspVStBHlB9QHj3DUMgeh4KCmToWVevA/SW5IZYciJSSrMvNPtCsy/VK0rXD4aU9kxkHrQtcMYO446hJ1FDIHrP0tNyhl59emLOcJOOlXDNmUhp8f4G573lAQsiRbSQYmcSbKHKFtLlgaFXny4PDCml9TVaX6P1NVpfo/U1Fqip9UGDWh+wUFoorZRq2YAtEintlGJxqojFqWFZ2DFZGlIaKMVQbOjZ6TESkXATxGRpWB0zlA3gcCyZ2B21CRWbY6NURwJgp15pzeksBQ5HnDE07AvH5VIczUviaS1wcUwvKxDKGrA7pkRsjjggaUhpGY6VyiqljdJGaae0M+HBhMdKoiLEb4gTnVcVjInYHXGuU44dTGyOORCrY6EUJzzFvVYxdxvKfmhhd+wauajqtBAYYcGKXNRwXcRMHI6B0qiRiwofBaBo5GJCNahhwZK0JWlL0tX9WDFdA0ZaoK7riolaoRoEdQtWTNEKwyCmBc3ATlZXHNkD2NnqquGCgIPBl1NWv+Sksahm+0JdybSVTFtK+1Jqp6xrHEsyVi6xdxO/4BxOM1F9ijWZ57Um87zWZJ7XCaYimed1gkssTwj0w+lZEeg3xOxiZ52bowb6C7CZW3JuAaO5JWvqKwBTk3soK6L7KSDXsHYgTvAtpDRQGiiNgVgc00XEwecGHI45EZsjuoNhcdSeobhJqQydJF7A7tgplZZbKJ0P7QRPwcLiGCgNlEZKI6WJUhTTcDiibIoomyHzUCmt1NuoV0shDYvDeDPMBcS/xdH1aziGTEQ9yMBSZfJY2BwTpYnSTGmmtFCqWQdq1hWHo7aFIvPQKe3UO1xvQ4HEj10bRlU5f1Wx5U8YoHAKb2F1lMluYSYOxwJlGdgcpbcspLRR2ijtlHZKYVGGdWG/MrE7hkSEVFqzazEVm6MWU7EQh2Pm1zKVFUoLlaGFUgRCmdgOdv8LKUULGUKv9Cyd04GIYCxEicXOcO5+IaXoLUkvSxTHRGnyhEe+iJSWROyOaDcJL1Rs4xfK1+QOQtU53VDqLIsR4KwesOlEnjMQ0oL7G5B2YHFEKQwpTZSmTToc0UKG3RF9SIbiic0RLWRYiMMR3cmwO3ZKO5XBJgvKhhIDcbpg4XDEUFFwVQXFrLisgmIqJkpRTAlQNBwxWNgd0VjiJW3Y5xuisQwpbZQ2SmWyXVgcx0WU/IqXtOGsgSIiGAubI1rTsDhqMRU3KZVhydlwRUe2eIaZUozghlK/4kmc2w4pUIdU/NipQ4ol59D7PhpYbtECyy1aYLlFDyy36IHlljywPLE5Bkr12EEEdsdEaaI0U5opLZQWSiulldJGaaO0U9opxTklw7YwX5FIaaA0VEccFDEsxOGoh3AUPeHMYmI9YViYRGESOI5lyCQaE25MojFhljizxJklzixxuQLREy7hIhaiJ4ETDws9icKGLYlJ5EhkEoUJFyZRmXBlEpUJs40L27h0JtGZ8GASwxOu10UsRE+ihkz0JCpNuUZPQg9MGDKJHIhMojDhgk6XgMMRg48iBh/D6ojBx5BSDD5AeCQWdsdAaaA0RqIrw/mKhcUxU5o3qWe9sUBwThhWJqyrl0uwrfm54biFYacUE6JdFMxEl+KQhSHW+jKXT2yOkdJYHXVaD8BMHI6ZUl2yAEsiUqorM8Xq2FFRGYiKkjmhawshv5jvhoy8Q1f1ipk4HAOlukoGYjlmSKmukhWrI0JKaIChLdSBw7FSqianuLxkbfRIpHQE4nKjTZfRReyOYXnJJjbHGImUpkCsjpnSXIjDUe1M74h2x0YpJnBF7UOK1XEsp3PXMxWGy+ncgzuzJzbHEB1xefMCyhCfxZPUEWOYs4ognBLiVOoaNxiQ4sqo3ALpOPCgiOWCIe6LGorvQnxRHaccFlIqBr4wE4ejZgeI3TnyoGEBRfi1DSmFX9uwOHZKsWAw7AuxPMjiaupYHhgGSrVAXVALNIBlVR8OMRhqgRQpZVVj0WBYKC3NURsAiCONcjyw4wZBFgdMz+qgBiI74oLpCBYYJkqRB0UZNbIcBOxZBoWF1bHxHzR8TVoTsYCFlMIeDD07BV50Q0rVi65YHDVipIgkCrA7pkSkNEdicyyUlup6K5OoTLhRimCt4XDslGqMDMhiIiyQ5bxjR1ggi9OkV20LRUph64aZOBy1FEA9xqNYHfUYjyKleoxHsTh2SvUYj2JfiIP8OXQgEhZTRiwgizun46iAYaQUBRJ3WcdRgSwnPLue0+/4BziIKZ6zjkMBhpVS3MpS1DPyit2xU9qbI9ZGhnVh9zPyvesZeckO3AILu2OkFAsixRSJlOZALI44UirOo95xqNSQUilQlplsIoopVa2H/iVg3HEnzxAFMnSpnv83LI6BUiz2DLujX9DqeuhfMaPWO7A4FkpLd6yJSCm8z4p6bSsDq+OgVP3jilicyjsAF+78GHbHQCkuNCjiQoMhpXqXTrE4ZtS6vDCAK/1ZlmoDd/qzrGwGDisupBQtJHu9iZBGQQxikvWJfSGm0IXSGcT1MzCFLqyOeBPBMBO7Y+LXEr+G11YMKS1UpqWoQOS3CWKANqS0J2JzxMVGIG7/LRR7GKCxSEzLyGXSaYz6ouQy6TFKqEG5BzJwKjBLnxw49r+wOiIdQ0lITkIMHAVcSCnSkkXTxOaIsd+Q0kJpoRSzqKEUWrwIA3f2FlKKGjTsjqhBIO7dZ/FsDZz0y3JfbuDmvSHqy7A7ovHlrOvA8T5DNL5hIQ5HLAsM+bVKZZXSRmWNyhqVdSrr/Nrg1wa/NvA1aVic9DNEu2VFlE26XNESA7HcMKyOGIUMoUw6YtFSRGB1RLMYFkfNuiISFtvB5buFbSHi9wurIyZqQ0rRafHeCOL3holSLDcUsXAzbI54kcWQGtBp5SD10DsHihh6DJtjD8RC5NcGlQ2XYuO80JW1EIhQVoHDEZ3MkFJ0MsPumL2FML8blouYHWFRMhWNpr0lANtCHNnTf4ALdYaoVIzn2L/mBCnMPuNrMHtFGIwhpY3SRikq1bA44vKPYSaOhYioZ/FxD33+RhEDviGlkdJIKXqAYXFEDzDMxOFYmDCmZEUt8QWsjujohoU4HLFON+yOg8rQLIIzjn2FjQsZo5sxerg4+SejzcXLLzzIWD4sbmTNrXHZePtu376rOVYelAd0axl4hRsZFr+4bDzImn/j7btp05k2ed50wvLlzaXJ6NbyzJHwILdNjmWfxCUma7mMGxlj7uKy8XDWDfVifjeqMRpvcqzLjTGZJGVdSgzl1RWEB7nmjTd52+Rtk/e0cSOPuHF11lXA4tUrhAc55I03edzkcZOntHEj57hxJZew8ZaHem28Oo5wJ2PgXsy+k3rYuJLHtfGmcwznfKWNqTOHSMacpP0OTnbrC/CyO5eN2adySxuzP+a+fbdv39U8G1Ou07/2hXKxT+GovzP7Ds74OZeNt++mTWfa5HnTielA+52uD7R/FR1PjDc5rnqq/ZdeNmafKiNtzL5Tr7Bx2ZjfrWqfxps8sr/jVH/GW0KXzvvG6EeL5d/jtZ8LQfrc0NYN4y3e/rl06m5JeZAxjuHtngu36BdjrWWMsasV5Uoumxz2j5d/Lt2YL97ksJ/FnYxb14uhH+XC9tyZcpy6s/Lqo3fGGIeNMQ4bY37BW0kXnNdWJzr7L27ktslhD8aw88WbfFwb58WS2Bfdvwhj+5HAuq8x7s7BtzMh6Bwk25WgT7otxvIS7xEF3RQuHuS0ydMmz5scfcG4rL2IcCXrfiYqZ+atbXnuLIvOQYuZ53iFjTd5YFl0n7iYeY5bGeNWxriVEfHfxZllUUev8VZG3EJ3LhsP54rVk7wlMhnjQw3KZeNBxgJpMfoj6kH74+LmrK6yxZs8bPKwyeMmRz+taBd1mC2uZCwPF+eNt++W7btYFGt58QBGxqtvoWkZldHWWsamZVQem1zLCNb1OV7Q08euFodNjnEJL9uFDttezPrskWnh4SvnTY52X7zloWxy2LYxbGDxllbddDbV869//eHLemz3T3///eef5a3d7fXd//jnl7/99PvPv/39yx9/+8evv/7hy//76dd/4B/9799++g2ff//p9/l/Z+3+/Nt/zc+p8L9/+fVnoX/9gd++7r86Xfbr23OaD65gjKcaUpXYGzTI/fMXNMhDTqZhOm7qnYZ0yMNs3aViOlmu4jra45qISdzDmos0XqkJebVlaZgBvTsN9V5DH0vB2MqQenusQC6amYJ+q6DfK5CdTDEV2FFQSQpfKRmH5giyGNLWCGUrSC2P89HGatDZx9OnVYTrFRUzCjdWi07v/KdVxHqr4tTDsCcy4x7lzq4kkHSnYrop4zKM6eBzFXMB9LWOg23NEKqb99x/bzry1zraQceMFge2a7/uOmo4VKm8/OIVEqfv7VbJoTTxkrCOlabW29LEU4fP3t3k4S/qqF/nQwaW+xrxAVgmj3sdj/ORbnU8ro+W7usj3+todalojTWa4/NMhGvNJTMeH+4zUU/W0X0qmHPBfYW2Uz66d9rplbjX8TQfBx3P66Pf1ke6fmSj4D6DVUa+7/cSnbq3rnK5ic4Ndrvrsukds/x3clK3nPT0ohIfkkVJvlVyMhAOYo2mPjcUH2iZzJap5b5lDoOpXMQ1HdM3wnaZQbLHOmLY7TSk2zrNBzvtOLgFHXK+43aKyuENFnLMCFwGmpESDxlJxxHZW6Zktm77RsVxMPV1tZwh5MJhrkO+0nGY9ku5VlHKXpT0AQ3NzaP08IqG6hPLxPySBu9spZZ4p+FUly1fXpebkX9bl+U0jnKSnRvccq/jZJ9lVWYObI2YvjbOchp5wvBdyoyG3+s4GGeJXp3bouVDGtw0ayivlSMmliPH13S0UH2/dSjJeei6fJcgQ1d+aS0ZfOiSd4Rvx+Fy2jMVXwemmu7Xo/X6vJnX8Hkzr/GzZl7T58285s+a+VHDIzM/liNyIZmu+JqOh2Z+Xil0OjdCu9+7nXSkxrKM+9VGuz6/2jjmI9Nd9PVeNr+mI99vNFr6kQtrnF1embjfcrVyWvEU72rbBF8+0qqdmcj3tVlOy2Fa+YwAMBdfG2g7LUNL8FVC2XdL37iu2jj5Mr2/yvN0tzr69flVVw+fXa/0NwzkPX1+IO/5swP5uV3rtn4c921ycjw1OsAm19s5uh+29PLSLvfjbXMztw+UppbmLbu1y7+V5mClg17J62JR5oLoa/fqwTyCPNW2lMxgbb510p4yIj855TnZNlz/lpP4eSMb6YcaWQ3BmyXdN8s4DaTy0wjuVEz3nslx2tL3uobj6XM/NO45IykxI+V2DztOLtLpPaMLvoZbf8txWI+XO3znguxuWA/XyXfd3WmcxrUta/s3zusrvKFKwnValc7Ap+dFgpH3Wo7W2tzYJm/D+4dqNm0bhnBfs+UdNVvfUrPtLTXbf3TNJtbsDEfe1mx4h82Gt9hseIvNhh9us6lztRqv+5p9h82Gt9hseIvNhh9us9nLE+dsfluz8R02G99is/EtNht/tM2O7Ou1UXK5D3vGgxKutWob9/ujUyzoedjzFJV6Hvc8Fqf7ii0cgrhxvGFBHk6Bqccr8uPhk8wgyhaT/jY0no7eKmTTLC3cW307Vepq3na123MXBwUt+rZz8wR8QEGNbqXxpRzUsrp+LfklBXV4P3np7EmJ3Cum1858FDxGYCpKfU1F9ZjJHEpvVZzGHTkH331vFUe/H3nywTLlpOHSEuvBa3cKRT0fe04RlOdjz7FAyUPJ09V+cDbltwymuf3wAuG9ZCvQdWqhw3DaenNP4ojjfqI7DqbVt9FJfhDm88XJ7TVnYGekfz/w9O1q5hRfSsl1yO8o3a9myslkr+GDweRyqNjTkvWKrNjZle9XM+UY66/u603y1O5L68Tu82XsLd7X7EMV/X7jeYpUPfN7HzPhTuuZifxSOYYvyuboem9kpyjV9BR5eCdvc2Zo3xhZPY6u7ojbRvmU6wdUsChbhOjfVZTPu+FCrZ/1w52rtLiV17J1uH+v0sMEXJsvLme4a4vNhG9zMk42FnjsMh32Q0+NbNzvy1p4w76sxTf4JsMpXhVyb360d/L90d7vqBnBVyXyWw6vqsEtO1OT+0nNyWhxn0lrZj81NDcGH1HSqWQLUnxMSRmdAfx4UHKslRoiPfvbYuCDlfs0QPAdNS2xqVt9WU1tVFNHOqiJ7/BOHENa7/CMJ/z4s+ko6XZkOEW1Hq9xjlGtx2uc3t+xxunjB69xUvCdtPyc6G3NjtOR6hE5Qo09EvxtRsbR3LilnpzvK+U7efFQ7uRx78Ya+bNR/ofVGrebIf9WrfUHrvtS8LOEKYbwyrovRa+JFNu9E3qMz0/J8RjXejoYxWNg66mrNB4DW+9wlU7HiZcnX7eNE6/8+SEtHuNaT4e0eAxsPR3S4jGw9ZYhLUde38ntvmbHG4a0eAxsPR3SvpeXZ0NaPEa2Pj2k7dVabreAuFv444Y0vDS3MjFeGtLySPQ+x/tytDcMaedrVU+HtDDeMaQdw1lPh7TT/T+8D+Vr4Fd8wV+paC95pJ/ehTyHTcfWvLdWFo9hn+xn9OYufXNIf+Ofj6c4Vss8l5YP55/iKYz19JhejP3Uc5+d04unONazg3rnfDw8qYfj7p9138T06UPX5+YtHgiTd8PvWyblN7jnYypvcM9/x17d6FsJB6NP7dPu+Xi6ZvDYPf+8D4fr0HOO4Wy/mlRPh+Xi6aJV4Ln2GffYzud/c9AtnqINz1d6p/jW85XeMb71dKX3vRLFrUQt32s5BbgqL8cE+ZmpW39JPEW4QvAFUgi53DukTt1w8Or5qLeOjngKbz3eFRzjW49t5Xj/6rGtlPgOW/lOiR7aSjmOtoMBiJBebGR3f+brqi8tYncV212Zb+2ktB+4GM/RNeTY75dJ5bi58aYN+2D/za3ceLqGVaKvxksc+2r8Gx3hFATxBxum+7bf6ThXh58pyanfbyxOsaleVkl6CfeVcdLgE0Uf4yUNw+/RfxXp+4gGXyvKY4svqZDX2VxHfa0gIfhptLBffvqgDu/vYY+dfkhHdhv/ynv9ER1wBKmOfRH/sXz4tkbe8npNR+LzGSm9mI90cTGz3UX9WH3w2Zx01Rfz4eefQtoCYh/T4fGwGaN40U4LbayUF+20+IQQ9ns/H9LR3FsV9jGwfGBKyHQzlXu/d+yna8Y8MTlxj8jFDyjhPnFieE2JPGO7lOSvgnofyUnhaeNSX1US/brenGVOSk6OgOY7kdxGvHWNnJV0PwGae60HJeOH58TvlE4sLyoZPs/k0dpByal10qCdhPpiE2cP2s7lffu0xcq7v7dKnvbhOu778Djef2aNpOv+Ia+jEnkVl6XJkTNn/aZKTlezQmwcGuP+ttm36/6zls7be+kKt/uhdIxi5bhFffYTfx/KSwrurJ18H5xIxyjW7MmRpzBqejUvjUcYw7ju83KMt47gccbpnx+v5qXkLS/hPi/HcyWXH5qdXF9tI/yUjuUlnurleN2l+EM/k9N96Ofcj5ofZ8LLvHf9KJ2CWYH7xbmYZpf+9tzc6WEZBGdto5ZuY54pvOEUYQqfPkV4VvHoFGEKbzhFmMKnTxGeq/ThKcIU3nCKMIUffIrwKyPLt16JdLyY9dCFluI73K3peC/rCpEutBDTq1p4cWc6jK4XtSASsdx5+aDlHU7bdIpqhemx8V1k3d9p+dZpe1ZThr+yMrm/qqZeHB1ruMKranBzaqnJ/VU1Tx3a6RjhasMtr6d7X+dZSffn/+Yeu76qxL2uacTrXsm5VhLPdNT9DcCPthFdU3V/JfLDasKmZrzWRtWLdDwDexwvvYGm9/Sl2wEl+xsbc/64H3JPEa4Z9VvG1vqrOuhMbuPeK/44H2/REdNLVVoTX/Er/T4b9Q1LpWNU69lS6aji2VLpeGXr6VLpGAF6tlQ6VunTpdIpnvV4qXS6svWWpdJuZO3WTtPxvtbTpdLxutbjpVJpb4g2ptLfEG38XokeLnJOka03jO7V5/Cy3z//yFDU/ERVae1+13ZyLT8eimr+9FB0VPFsKKr1DUNRbZ8eio5V+nQoOl3bejwUnR4ZfMtQtBtZvz20m44XVh6eykynyzOPT2Wmdrz18vBUZjo+NviOg+aFtz9Lb/cridbeUbP9LTX7jvOuqV8/vGbdPV1Gup8++ztstr/FZvtbbLb/cJsd1U90jPs9ServsNn+Fpvtb7HZ8Q6bPf38UPLz8zltoeZvf/rn+Aah7234/Zw+5EViy1wn1/h3tPDtv89oebhkHO94beA7AcDKZ6n2w+8fivHu4dnyanj2cWR1vCOyegzPeiNPJa8Gioe/UfdVbOkTOamvKnHLz2O8WrHvaeJnYfx8uq4VUNgVE71etZOHdXI8ulIZ+av1xSNWNdChHF88HrXno714XKz6W+xhf93qY0d5KnX0F8uyHwcqLx6P2s8j7NvPD+kIfDc33rbtd26hc6MzOR/ubZ+1MDT8GS0lbKuB61Utz9YU+Rjoerxa+86DA4x+5NpODw6cQ5nMS+z3/o7HSg5Bi3y6s8HjSfte9GP5qHyyoOb7wpweeBt85G4bob99ZLm/wey/o+SZ1X9HyTOj/46Shzaf3nF9+/hbKOnyxVrazjh/7DdZnv1Yxfm3eug3qeW13wsqvout9e73gk7uHz7OEffI8rfFOKvgj8JsefiQime/YJLz8SbBk58wOat49Bsmx19nffZLPScVlb8cuT//8hEVD38E5ViQyufM22sqHvay6/Od7LRpzr6Yynl/W/LxL9UGvnga9qj+BzIR+Esu8gvIL6lIvJeRxmu5KO4/CGU7vvghFZUHLvp4rSDbBYL4WkHSdpyzvFaQ6vYd9hdYP6Ki8fDkfg76IyoG62LEl1Q0Pwfacn1FwXAP8yiv1cPlZ5zCVe+NO58ew/t8Nx1+2HLE1yrC++ho5ZM1+ZoCPjnXx/05meM4w44RtmXat8vOfHpS8NnPYh9zEXjtKrTXVPAoVdhvgHyoII9+IDy34+nKJ+88n1U82gicVTx6MPuo4tmT2fkUbnz6vsdxvHv4Mk8+x6Ievsxzzsmzd3nyMRL15F2e67PmdX3WuK7PmtZJwaOHzK+XLPM/558//eWX3//061//8tPff/nrb/87v/cvUfX7Lz/9+def7c///sdvf9n+79///9/W//nz77/8+usv//Onv/3+17/8/F//+P1n0ST/78tl//kPLHTnOvP6zz98SfK3HPybgaM2/y74O/X595D/H+QLMwSV/jD/00UQ5F/Ia3Tyq5b/+S/J8v8B"},{"name":"receive_value","is_unconstrained":true,"custom_attributes":["external","public"],"abi":{"parameters":[{"name":"source_chain_id","type":{"kind":"integer","sign":"unsigned","width":16},"visibility":"private"},{"name":"sender","type":{"kind":"field"},"visibility":"private"},{"name":"value","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"private"}],"return_type":null,"error_types":{"459713770342432051":{"error_kind":"string","string":"Not initialized"},"10748621607991011913":{"error_kind":"string","string":"VAA already processed"},"13455385521185560676":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"},"18173155084464344029":{"error_kind":"string","string":"Emitter not registered"}}},"bytecode":"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","debug_symbols":"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"},{"name":"register_emitter","is_unconstrained":true,"custom_attributes":["external","public"],"abi":{"parameters":[{"name":"chain_id","type":{"kind":"integer","sign":"unsigned","width":16},"visibility":"private"},{"name":"emitter_address","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"}],"return_type":null,"error_types":{"459713770342432051":{"error_kind":"string","string":"Not initialized"},"6788092787179896647":{"error_kind":"string","string":"Caller is not owner"},"13455385521185560676":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"}}},"bytecode":"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","debug_symbols":"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"},{"name":"send_value","is_unconstrained":true,"custom_attributes":["external","public"],"abi":{"parameters":[{"name":"destination_chain_id","type":{"kind":"integer","sign":"unsigned","width":16},"visibility":"private"},{"name":"value","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"private"},{"name":"fee_nonce","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"459713770342432051":{"error_kind":"string","string":"Not initialized"},"8228371833434187583":{"error_kind":"string","string":"Trying to read from uninitialized PublicImmutable"},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"}}},"bytecode":"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","debug_symbols":"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"},{"name":"set_message_fee","is_unconstrained":true,"custom_attributes":["external","public"],"abi":{"parameters":[{"name":"fee","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"}],"return_type":null,"error_types":{"459713770342432051":{"error_kind":"string","string":"Not initialized"},"6788092787179896647":{"error_kind":"string","string":"Caller is not owner"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"JwACBAEoAAABBIBFJwAABEUnAgIEAScCAwQAHwoAAgADAEQcAEREBi0IRAElAAAARiUAAABsJwIBBEUnAgIEADsOAAIAASwAAEMAMGROcuExoCm4UEW2gYFYXSgz6Eh5uXCRQ+H1k/AAAAAmJQAAAPYeAgACAB4CAAMAMyoAAgADAAQnAgIBASQCAAQAAACVJQAAARwnAgIABC8KAAIAAx4CAAIBCiICQwQWCgQFHAoFBgAEKgYCBScCAgEACioEAgYkAgAGAAAA0ycCBwQAPAYHAQoqAwUCJAIAAgAAAOUlAAABLhwKAQIAJwIBAAcwCgACAAEmKAAABAR4RQwAAAQDJAAAAwAAARsqAQABBdrF9da0SjJtPAQCASYqAQABBQZhOz0Lnb0zPAQCASYqAQABBV40JmzSP79HPAQCASY=","debug_symbols":"tVbbjuMgDP2XPOcBbMC4vzKqqrRNR5GitMq0K62q/vuaWSDJSqC9TR/CAcKpj30gPJtzf3y8H4bpcv1odm/P5jgP4zi8H8brqbsP10lGn40KD62x2ZlWWt/sSFqQvlYCUAvQAbgIjEmABTgB1kTghExzALbZQXiHVAImThFH4GUEMACOgOMIKEiAItASBpgAXARgEgjLvQCUEdQBcACvV9skpYf73PdB6Eq6JOTWzf10b3bTYxzb5ls3Pj5f+rh102d772aZlTT001laIbwMYx/Qq11Wq/JSrUD5uFww+0yhFW1IdIUEDCUOcLSiMBsKqFB4RTpxeOUXKbTVgmUOBGs5cggmW+KoScFQsp9hoDFFKfY/SHFfLAU8ZimqXBVfpiBPiYIYuBQEV4Sgs5CEoON/FmLKQio2R402RaEtZgr7SxBQU5I3CspvicLzlqPmUMWYSRTbYka1qZHAklLZsrpIUjEpWqcyiXVYrEs1qV7npDIXk0qV0jLofHQwQNkevrZZHLi8WZwpJ6QeiVFLJAwlEqhlxCSXGTkIl4T8TUblXC5lFCo2JZd3LC0RGPj9ECj7Qj5qpRBqDJCzgECqKKLmTu9TLZCVK+41qB6hSJkEsHwMQ80VxHZ1lGcKdOZPAkFcArFFjwNXy6KzGk2u6HGsVcaSzv6Sj8rW43vpdadh3ty+XoFtHrrj2Mfu5TGdVrP377c0k25vt/l66s+PuQ9MqyucPN+Mbo3bh3tc6FBreP8Kf/0D"},{"name":"sync_private_state","is_unconstrained":true,"custom_attributes":["external","utility"],"abi":{"parameters":[],"return_type":null,"error_types":{"344423948968719440":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]},"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"992401946138144806":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"3080037330898348111":{"error_kind":"fmtstring","length":132,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"4261968856572588300":{"error_kind":"string","string":"Value does not fit in field"},"4440399188109668273":{"error_kind":"string","string":"Input length must be a multiple of 32"},"7564993426627941149":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"7995966536718645961":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"8992688621799713766":{"error_kind":"string","string":"Invalid public keys hint for address"},"9791669845391776238":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"9885968605480832328":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"9921926525851912681":{"error_kind":"fmtstring","length":98,"item_types":[]},"10791800398362570014":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"11021520179822076911":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"12913276134398371456":{"error_kind":"string","string":"push out of bounds"},"13450089406971132036":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"14067204867181196045":{"error_kind":"fmtstring","length":75,"item_types":[]},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"},"16792019527863081935":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17154023812102399658":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17803644318014042523":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"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4iYa0YmHGES6DboNug26MUuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySahEcYxQO4iQu4iYa0YmHGMR8mHRLuiXdKkvGLNxEIzrxEIOYF2d1EjYO4iQu4iYa0YmHGES6DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26bboZ3YxulSVjFy7iJpbbKXTiIQYxH1aWXBzESVzETaSb083p5nRzuh26Hboduh26Hboduh26Hboduh26Bd2CbkG3oFvQLegWdAu6Bd2Cbkm3pFvSLemWdEu6Jd2Sbkm3fG7j9yMO4iQu4iYa0YmHGES6DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26bboZ3YxuRjejm9GNWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWbKYJYtZspgli1mymCWLWbKYJYtZspgli1mymCWL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26DboNug26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptumW2XJ960xu/peG534uc0oDGI+rCz5fqNyV99r4yR+bqvcKksuGvFz+z7h39X32hjEz+37XG9X32vjIH5u2woXcRM/N6sLqiy5eIifm2GwfFhZcvFz81/hJC7i5+Y138qSi0783LzWrLLkYj6sLDk138qSi5P4uZ1as8qSi0b83E6temXJxSDmw8qSi4M4iYu4iUakW9It6ZbPrfpeGwdxEhdxE43oxEMMIt0G3QbdBt0G3QbdBt0G3QbdKku+++pdfa8XK0sufm7fX1Da1ffauIibaEQnHmIQ82FlyUW6Lbotui26VZZ8f4FpV99r4yF+bjkL82FlycXPLesyK0suLuImGtGJhxjEfFhZcpFuRrcvS9av5vtlSaMR/cOa75cljUHMD796q77XxkGcH9Z2+yLuRnRKRtE37Piqv1oi1/eOYFdLZOMibqIRnXiIQcyH3zFrpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptumm9HN6GZ0M7oZ3YxuRjejm9HN6OZ0c7o53ZxudcyGFRrRiYcYxHx4yq0O6hnESVzEz23W+f1esho/t++b5na1RDYGMR9+L1mNgziJn9vchZtoxHLzwkMMYrnVfPNHHMRJXMRN/Ny+r0jY1RLZeIhB/Ny+34Tb1RLZOIif2/4VLuImfm5f2+uulsjG83DUVZzCb9y6hak2x7W9sEbIQiceYhDzYeXDxW/curGpNsfGRdzEz63ucarNsfFzs5pk5cPFfFj5cHEQJ/Fz+zosdrU5NhrRiZ/b98RrV5tj4+fmNcnKh4uDOInlVsaVDxeN6MRDDOLndmo6lQ8XB3ESP7dTk6x8uGjEcrPCQ4yHVfMXa4S6iqruupWrzsS/J+AfVklfHMRJXMRvsKhJVklfdOIhBjEfVknXPUN1JjZO4iKWW823SvqiE8utZlYlfTEfVklHHdoq6awaqpKuu47qTGzcRCM68TRWD+LfvyocxElcxE20h1WF35+d3NUg2FgW33yrFXDXXUe1AjZO4iJuoj1c9f+t+S4jOvEQg5gP9484iJO4iHTbdNt023TbdNt0sxp3FdYIu7BG8MJDDGKN8G13teE1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"},{"name":"transfer_ownership","is_unconstrained":true,"custom_attributes":["external","public"],"abi":{"parameters":[{"name":"new_owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"459713770342432051":{"error_kind":"string","string":"Not initialized"},"6788092787179896647":{"error_kind":"string","string":"Caller is not owner"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"JwACBAEoAAABBIBFJwAABEUnAgIEAScCAwQAHwoAAgADAEQtCEQBJQAAAEElAAAAZycCAQRFJwICBAA7DgACAAEsAABDADBkTnLhMaApuFBFtoGBWF0oM+hIeblwkUPh9ZPwAAAAJiUAAADnHgIAAgAeAgADADMqAAIAAwAEJwICAQEkAgAEAAAAkCUAAAENJwICAAQvCgACAAMeAgAEAQoiBEMFFgoFBhwKBgcABCoHBAYnAgQBAAoqBQQHJAIABwAAAM4nAggEADwGCAEKKgMGBCQCAAQAAADgJQAAAR8wCgABAAImKAAABAR4RQwAAAQDJAAAAwAAAQwqAQABBdrF9da0SjJtPAQCASYqAQABBQZhOz0Lnb0zPAQCASYqAQABBV40JmzSP79HPAQCASY=","debug_symbols":"tZbbiuMwDIbfJde9sGT5oL7KUkrapkMgpCWTLCwl777yTOwkAzbsYXrR/I7rr/plyfhV3ZrL9HZu+/vjvTr+eFWXoe269u3cPa712D56efuqVPgC5asjHSoAXR1deMoYlAi0IkCEhih4EUQibBC8CGNEsAgrVAy/sSYKXqYcRSFvUIvwFEV8w+5ToMIoJAyUABEgCl4EhuU8z4cq+jqPQ9MEWxujYv9ZD00/Vsd+6rpD9bPupo8fvT/r/uM51oPMiummv8lTgPe2a4KaD+tqlV8KCpVflotmnxCg3A4CBQiSiwy0boOgHQILCK8cRIZXfrXi9l50nqHRGF4Yop3JMUpWdNigzzA0UdaK+Q9W7DdbQa+TFZXfFZ9HOO8iwrEUbCYILhjR1mA0oi3/sxHKG1GlMBJCk4KEMF+CwBIiNYqWzxqF5z2jVKGKdYIoNtmMApUguKZUWhaykEKRamNVghirs/tSSiphqlHa7MvXpLrC1jJCOjoYMV8evtQsFm1qFkv5hJQjIbVGwpiDYDEjZkGQHIRrQv4qo8bmMoqFMnU2daxbAYR/EIJaQ+BcCEUCp14zgFkTper0PgXBymZ7DYtHqHRpqgptsqWFharQ4CBFAs5mSwtL9WkcQMqIM/vSOsmovrbD7oozB9rQ1peuWYb3qb9uZsdfzzgTr0jP4XFtbtPQBNL2niQ3CTl1SJ/CJUkGRAeypzn89W8="}],"outputs":{"globals":{"storage":[{"fields":[{"name":"contract_name","value":{"kind":"string","value":"Token"}},{"name":"fields","value":{"fields":[{"name":"admin","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"minters","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}},{"name":"balances","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}],"kind":"struct"}},{"name":"total_supply","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}],"kind":"struct"}},{"name":"public_balances","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}],"kind":"struct"}},{"name":"symbol","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000006"}}],"kind":"struct"}},{"name":"name","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000008"}}],"kind":"struct"}},{"name":"decimals","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000000000000a"}}],"kind":"struct"}}],"kind":"struct"}}],"kind":"struct"},{"fields":[{"name":"contract_name","value":{"kind":"string","value":"Wormhole"}},{"name":"fields","value":{"fields":[{"name":"state","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"sequences","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000007"}}],"kind":"struct"}},{"name":"owner","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000008"}}],"kind":"struct"}},{"name":"receiver_address","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000009"}}],"kind":"struct"}},{"name":"token_address","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000000000000d"}}],"kind":"struct"}},{"name":"guardian_1","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000011"}}],"kind":"struct"}},{"name":"guardian_2","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000012"}}],"kind":"struct"}},{"name":"guardian_3","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000013"}}],"kind":"struct"}},{"name":"guardian_4","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000014"}}],"kind":"struct"}},{"name":"guardian_5","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000015"}}],"kind":"struct"}},{"name":"guardian_6","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000016"}}],"kind":"struct"}},{"name":"guardian_7","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000017"}}],"kind":"struct"}},{"name":"guardian_8","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000018"}}],"kind":"struct"}},{"name":"guardian_9","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000019"}}],"kind":"struct"}},{"name":"guardian_10","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000000000001a"}}],"kind":"struct"}},{"name":"guardian_11","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000000000001b"}}],"kind":"struct"}},{"name":"guardian_12","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000000000001c"}}],"kind":"struct"}},{"name":"guardian_13","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000000000001d"}}],"kind":"struct"}},{"name":"guardian_14","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000000000001e"}}],"kind":"struct"}},{"name":"guardian_15","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000000000001f"}}],"kind":"struct"}},{"name":"guardian_16","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000020"}}],"kind":"struct"}},{"name":"guardian_17","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000021"}}],"kind":"struct"}},{"name":"guardian_18","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000022"}}],"kind":"struct"}},{"name":"guardian_19","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000023"}}],"kind":"struct"}},{"name":"current_guardian_set_index","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000024"}}],"kind":"struct"}}],"kind":"struct"}}],"kind":"struct"},{"fields":[{"name":"contract_name","value":{"kind":"string","value":"MessageBridge"}},{"name":"fields","value":{"fields":[{"name":"config","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"owner","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}],"kind":"struct"}},{"name":"registered_emitters","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}],"kind":"struct"}},{"name":"processed_vaas","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000006"}}],"kind":"struct"}},{"name":"message_fee","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000007"}}],"kind":"struct"}},{"name":"last_received_value","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000008"}}],"kind":"struct"}},{"name":"last_received_from_chain","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000009"}}],"kind":"struct"}},{"name":"last_received_sender","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000000000000a"}}],"kind":"struct"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"wormhole_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"chain_id","type":{"kind":"integer","sign":"unsigned","width":16}},{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"message_fee","type":{"kind":"integer","sign":"unsigned","width":128}}],"kind":"struct","path":"MessageBridge::constructor_parameters"}}],"kind":"struct","path":"MessageBridge::constructor_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"MessageBridge::get_config_parameters"}},{"name":"return_type","type":{"fields":[{"name":"wormhole_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"chain_id","type":{"kind":"integer","sign":"unsigned","width":16}}],"kind":"struct","path":"types::Config"}}],"kind":"struct","path":"MessageBridge::get_config_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"MessageBridge::get_last_from_chain_parameters"}},{"name":"return_type","type":{"kind":"integer","sign":"unsigned","width":16}}],"kind":"struct","path":"MessageBridge::get_last_from_chain_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"MessageBridge::get_last_sender_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"MessageBridge::get_last_sender_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"MessageBridge::get_last_value_parameters"}},{"name":"return_type","type":{"kind":"integer","sign":"unsigned","width":8}}],"kind":"struct","path":"MessageBridge::get_last_value_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"MessageBridge::get_message_fee_parameters"}},{"name":"return_type","type":{"kind":"integer","sign":"unsigned","width":128}}],"kind":"struct","path":"MessageBridge::get_message_fee_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"MessageBridge::get_owner_parameters"}},{"name":"return_type","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"MessageBridge::get_owner_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"chain_id","type":{"kind":"integer","sign":"unsigned","width":16}}],"kind":"struct","path":"MessageBridge::get_registered_emitter_parameters"}},{"name":"return_type","type":{"fields":[{"name":"emitter_address","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"enabled","type":{"kind":"boolean"}}],"kind":"struct","path":"types::RegisteredEmitter"}}],"kind":"struct","path":"MessageBridge::get_registered_emitter_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"source_chain_id","type":{"kind":"integer","sign":"unsigned","width":16}},{"name":"sender","type":{"kind":"field"}},{"name":"value","type":{"kind":"field"}}],"kind":"struct","path":"MessageBridge::is_vaa_processed_parameters"}},{"name":"return_type","type":{"kind":"boolean"}}],"kind":"struct","path":"MessageBridge::is_vaa_processed_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"message_ciphertext","type":{"fields":[{"name":"storage","type":{"kind":"array","length":17,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::collections::bounded_vec::BoundedVec"}},{"name":"message_context","type":{"fields":[{"name":"tx_hash","type":{"kind":"field"}},{"name":"unique_note_hashes_in_tx","type":{"fields":[{"name":"storage","type":{"kind":"array","length":64,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::collections::bounded_vec::BoundedVec"}},{"name":"first_nullifier_in_tx","type":{"kind":"field"}},{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"aztec::messages::processing::message_context::MessageContext"}}],"kind":"struct","path":"MessageBridge::process_message_parameters"}}],"kind":"struct","path":"MessageBridge::process_message_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"source_chain_id","type":{"kind":"integer","sign":"unsigned","width":16}},{"name":"sender","type":{"kind":"field"}},{"name":"value","type":{"kind":"integer","sign":"unsigned","width":8}}],"kind":"struct","path":"MessageBridge::receive_value_parameters"}}],"kind":"struct","path":"MessageBridge::receive_value_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"chain_id","type":{"kind":"integer","sign":"unsigned","width":16}},{"name":"emitter_address","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}}],"kind":"struct","path":"MessageBridge::register_emitter_parameters"}}],"kind":"struct","path":"MessageBridge::register_emitter_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"destination_chain_id","type":{"kind":"integer","sign":"unsigned","width":16}},{"name":"value","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"fee_nonce","type":{"kind":"field"}}],"kind":"struct","path":"MessageBridge::send_value_parameters"}}],"kind":"struct","path":"MessageBridge::send_value_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"fee","type":{"kind":"integer","sign":"unsigned","width":128}}],"kind":"struct","path":"MessageBridge::set_message_fee_parameters"}}],"kind":"struct","path":"MessageBridge::set_message_fee_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"MessageBridge::sync_private_state_parameters"}}],"kind":"struct","path":"MessageBridge::sync_private_state_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"new_owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"MessageBridge::transfer_ownership_parameters"}}],"kind":"struct","path":"MessageBridge::transfer_ownership_abi"}]}},"file_map":{"104":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr","source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\n// Used by `create_mark_as_initialized` (you won't find it through searching)\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\n// Used by `create_mark_as_initialized` (you won't find it through searching)\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\n// Used by `create_init_check` (you won't find it through searching)\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\n// Used by `create_init_check` (you won't find it through searching)\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\n// Used by `create_assert_correct_initializer_args` (you won't find it through searching)\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender().unwrap()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n// Used by `create_assert_correct_initializer_args` (you won't find it through searching)\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender().unwrap()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"},"107":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr","source":"use crate::macros::{\n    functions::{\n        auth_registry::AUTHORIZE_ONCE_REGISTRY,\n        call_interface_stubs::{\n            register_private_fn_stub, register_public_fn_stub, register_utility_fn_stub,\n        },\n    },\n    notes::NOTES,\n    utils::{\n        fn_has_authorize_once, fn_has_noinitcheck, is_fn_contract_library_method, is_fn_external,\n        is_fn_initializer, is_fn_internal, is_fn_test, is_fn_view, modify_fn_body,\n        module_has_initializer, module_has_storage,\n    },\n};\nuse dep::protocol_types::meta::utils::derive_serialization_quotes;\nuse std::meta::{ctstring::AsCtString, type_of};\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) {\n    register_private_fn_stub(f);\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    let (args_serialization, _, serialized_args_name) =\n        derive_serialization_quotes(original_params, false);\n\n    let context_creation = quote {\n        $args_serialization\n        let args_hash = dep::aztec::hash::hash_args_array($serialized_args_name);\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, args_hash);\n    };\n\n    let function_name = f.name();\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        let assertion_message = f\"Function {function_name} can only be called internally\";\n        quote { assert(context.msg_sender().unwrap() == context.this_address(), $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        let assertion_message =\n            f\"Function {function_name} can only be called statically\".as_ctstring().as_quoted_str();\n        quote { assert(context.inputs.call_context.is_static_call, $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (\n            quote { aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_private(context); },\n            quote { aztec::macros::functions::initialization_utils::mark_as_initialized_private(&mut context); },\n        )\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        quote { aztec::macros::functions::initialization_utils::assert_is_initialized_private(&mut context); }\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any. Note that the message\n    // discovery call syncs private events as well. We do not sync those here if there are no notes because we don't\n    // have an API that would access events from private functions.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f, true)\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is serialized and hashed before being passed to the context.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n\n        let (return_serialization, _, serialized_return_name) =\n            derive_serialization_quotes([(return_value_var_name, return_value_type)], false);\n\n        body = body_without_return;\n\n        quote {\n            $return_value_assignment\n            $return_serialization\n            context.set_return_hash($serialized_return_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    // A quote to be injected at the beginning of the function body.\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) {\n    register_public_fn_stub(f);\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n\n    let args_len_quote = if original_params.len() == 0 {\n        // If the function has no parameters, we set the args_len to 0.\n        quote { 0 }\n    } else {\n        // The following will give us <type_of_struct_member_1 as Serialize>::N + <type_of_struct_member_2 as Serialize>::N + ...\n        original_params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n            <$param_type as $crate::protocol_types::traits::Serialize>::N\n        }\n            })\n            .join(quote {+})\n    };\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len_quote] = dep::aztec::context::public_context::calldata_copy(1, $args_len_quote);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    let name = f.name();\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        let assertion_message = f\"Function {name} can only be called internally\";\n        quote { assert(context.msg_sender().unwrap() == context.this_address(), $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        let name = f.name();\n        let assertion_message =\n            f\"Function {name} can only be called statically\".as_ctstring().as_quoted_str();\n        quote { assert(context.is_static_call(), $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (\n            quote { aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_public(context); },\n            quote { aztec::macros::functions::initialization_utils::mark_as_initialized_public(&mut context); },\n        )\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        quote { aztec::macros::functions::initialization_utils::assert_is_initialized_public(&mut context); }\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f, false)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    register_utility_fn_stub(f);\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage(f.module()) {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process or they may be used to sync private events from TypeScript\n    // (`sync_private_state` function gets invoked by PXE::getPrivateEvents function).\n    let message_discovery_call = create_message_discovery_call();\n\n    // A quote to be injected at the beginning of the function body.\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Injects an authwit verification check of the form:\n/// ```\n///   if (!from.eq(context.msg_sender().unwrap())) {\n///         assert_current_call_valid_authwit::<N>(&mut context, from);\n///     } else {\n///         assert(authwit_nonce, \"Invalid authwit nonce. When 'from' and 'msg_sender' are the same, authwit_nonce must be zero\");\n///     }\n/// ```\n/// where `from` and `authwit_nonce` are the names of the parameters that are expected to be present in the function definition.\n/// This check is injected by the `#[authorize_once(\"from_arg_name\", \"nonce_arg_name\")]`, which allows the user to define\n/// which parameters to use.\n///\n/// # Arguments\n/// * `f` - The function definition to inject the authwit verification check into. The function must have parameters\n///         matching the names specified in the `#[authorize_once]` attribute.\n/// * `is_private` - Whether the function is a private function (`true`) or a public function (`false`). This determines\n///                  which authwit verification method to use: `assert_current_call_valid_authwit` for private functions\n///                  or `assert_current_call_valid_authwit_public` for public functions.\npub(crate) comptime fn create_authorize_once_check(\n    f: FunctionDefinition,\n    is_private: bool,\n) -> Quoted {\n    let maybe_authorize_once_args = AUTHORIZE_ONCE_REGISTRY.get(f);\n    let authorize_once_args = if maybe_authorize_once_args.is_some() {\n        maybe_authorize_once_args.unwrap()\n    } else {\n        // We need to for authorize_once to have already executed so that we can retrieve its params - this depends on\n        // the order in which the attributes are applied.\n        panic(\n            f\"Functions marked with #[authorize_once] must have the #[external(\\\"private\\\")] or #[external(\\\"public\\\")] attribute placed last\",\n        )\n    };\n\n    let (from_arg_name, nonce_arg_name) = authorize_once_args;\n    let name: Quoted = f.name();\n\n    let from_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{from_arg_name}\".quoted_contents());\n    let (from_arg_name_quoted, from_arg_type) = if from_arg_candidates.len() == 1 {\n        from_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {from_arg_name} parameter. Please specify which one to use in #[authorize_once(\\\"...\\\", \\\"authwit_nonce\\\")]\",\n        )\n    };\n    if from_arg_type\n        != quote { dep::protocol_types::address::aztec_address::AztecAddress }.as_type() {\n        panic(\n            f\"Argument {from_arg_name_quoted} in function {name} must be of type AztecAddress, but is of type {from_arg_type}\",\n        )\n    }\n\n    let nonce_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{nonce_arg_name}\".quoted_contents());\n    let (nonce_arg_name_quoted, nonce_arg_type) = if nonce_arg_candidates.len() == 1 {\n        nonce_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {nonce_arg_name}. Please specify which one to use in #[authorize_once(\\\"from\\\", \\\"...\\\")]\",\n        )\n    };\n    if nonce_arg_type != quote { Field }.as_type() {\n        panic(\n            f\"Argument {nonce_arg_name_quoted} in function {name} must be of type Field, but is of type {nonce_arg_type}\",\n        );\n    }\n\n    let nonce_check_quote = f\"{nonce_arg_name_quoted} == 0\".quoted_contents();\n\n    let fn_call = if is_private {\n        // At this point, the original args of the fn have already been altered by the macro\n        // to include PrivateContextInputs, so we need to adjust the args_len accordingly.\n        let args_len = f.parameters().len() - 1;\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit::<$args_len> }\n    } else {\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit_public }\n    };\n    let invalid_nonce_message = f\"Invalid authwit nonce. When '{from_arg_name}' and 'msg_sender' are the same, '{nonce_arg_name}' must be zero\"\n        .as_ctstring()\n        .as_quoted_str();\n    quote {         \n        if (!$from_arg_name_quoted.eq(context.msg_sender().unwrap())) {\n            $fn_call(&mut context, $from_arg_name_quoted);\n        } else {\n            assert($nonce_check_quote, $invalid_nonce_message);\n        }\n    }\n}\n\n/// Checks if each function in the module is marked with either #[external(...)], #[contract_library_method], or #[test].\n/// Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_external(f) & !is_fn_contract_library_method(f) & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[external(...)], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"},"109":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/macros/notes.nr","source":"use crate::note::note_getter_options::PropertySelector;\nuse std::{collections::bounded_vec::BoundedVec, meta::{ctstring::AsCtString, type_of}};\n\n/// Maximum number of note types within 1 contract.\ncomptime global MAX_NOTE_TYPES: u32 = 128;\n\n/// A BoundedVec containing all the note types within this contract.\npub comptime mut global NOTES: BoundedVec<Type, MAX_NOTE_TYPES> = BoundedVec::new();\n\ncomptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < MAX_NOTE_TYPES,\n        f\"A contract can contain at most {MAX_NOTE_TYPES} different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_type_impl(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n    let typ = s.as_type();\n    let note_type_name: str<_> = f\"{name}\".as_ctstring().as_quoted_str!();\n    let max_note_packed_len = crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                // This static assertion ensures the note's packed length doesn't exceed the maximum allowed size.\n                // While this check would ideally live in the Packable trait implementation, we place it here since\n                // this function is always generated by our macros and the Packable trait implementation is not.\n                // Note: We set the note type name and max packed length as local variables because injecting them\n                // directly into the error message doesn't work.\n                let note_type_name = $note_type_name;\n                let max_note_packed_len: u32 = $max_note_packed_len; // Casting to u32 to avoid the value to be printed in hex.\n                let note_packed_len = <$typ as Packable>::N;\n                std::static_assert(note_packed_len <= $max_note_packed_len, f\"{note_type_name} has a packed length of {note_packed_len} fields, which exceeds the maximum allowed length of {max_note_packed_len} fields\");\n\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullification: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullification: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::traits::Packable::pack(self).concat( [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::context::PrivateContext,\n                note_hash_for_nullification: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullification, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullification: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullification, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _, _)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates the core note functionality for a struct:\n///\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - NoteHash trait implementation: Handles note hash and nullifier computation\n///\n/// # Requirements\n///\n/// The note struct must:\n/// - Have an `owner` field\n/// - Implement the `Packable` trait\n/// - Not exceed `MAX_NOTE_PACKED_LEN` when packed\n///\n/// # Registration\n///\n/// Registers the note in the global `NOTES` BoundedVec to enable note processing functionality.\n///\n/// # Generated Code\n///\n/// For detailed documentation on the generated implementations, see:\n/// - `generate_note_properties()`\n/// - `generate_note_type_impl()`\n/// - `generate_note_hash_trait_impl()`\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n    assert_has_packable(s);\n\n    // We register the note in the global `NOTES` BoundedVec because we need that information inside the #[aztec] macro\n    // to generate note processing functionality.\n    NOTES.push(s.as_type());\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_type_impl = generate_note_type_impl(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n\n    quote {\n        $note_properties\n        $note_type_impl\n        $note_hash_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n///\n/// # Requirements\n///\n/// The note struct must:\n/// - Implement the `Packable` trait\n/// - Not exceed `MAX_NOTE_PACKED_LEN` when packed\n///\n/// Unlike the `#[note]` macro, there is no requirement for an `owner` field.\n///\n/// # Registration\n///\n/// Registers the note in the global `NOTES` BoundedVec to enable note processing functionality.\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    assert_has_packable(s);\n\n    // We register the note in the global `NOTES` BoundedVec because we need that information inside the #[aztec] macro\n    // to generate note processing functionality.\n    NOTES.push(s.as_type());\n\n    let note_type_id = get_next_note_type_id();\n    let note_properties = generate_note_properties(s);\n    let note_type_impl = generate_note_type_impl(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_type_impl\n    }\n}\n\n/// Asserts that the given note implements the `Packable` trait.\n///\n/// We require that notes have the `Packable` trait implemented because it is used when emitting a note in a log or as\n/// an offchain message.\ncomptime fn assert_has_packable(note: TypeDefinition) {\n    let packable_constraint =\n        quote { crate::protocol_types::traits::Packable }.as_trait_constraint();\n    let note_name = note.name();\n\n    assert(\n        note.as_type().implements(packable_constraint),\n        f\"{note_name} does not implement Packable trait. Either implement it manually or place #[derive(Packable)] on the note struct before #[note] macro invocation.\",\n    );\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    let note_name = note.name();\n\n    assert(\n        has_owner,\n        f\"{note_name} does not have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"},"110":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/macros/storage.nr","source":"use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract should have this macro (or `storage_no_init`) applied to it, and the\n/// struct has to be called 'Storage'.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    let struct_name = s.name();\n    if struct_name != quote { Storage } {\n        panic(\n            f\"The #[storage] macro can only be applied to a struct with name 'Storage', got '{struct_name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage_no_init\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ, _) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot });\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields = storage_layout_fields.push_back(\n            quote { pub $name: dep::aztec::state_vars::storage::Storable },\n        );\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::state_vars::storage::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract can have this macro (or storage_no_init) applied to it, and the struct\n/// has to be called 'Storage'.\npub comptime fn storage_no_init(s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n\n    // We do need to make sure that the type is called Storage, since we'll do `Storage::init` later on.\n\n    if s.name() != quote { Storage } {\n        let name = s.name();\n        panic(\n            f\"The #[storage_no_init] macro can only be applied to a struct with name 'Storage', got '{name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(typ: Type, slot: Quoted) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    let constructor = if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot });\n\n        quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }\n    } else {\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        quote { $struct_name::new(context, $slot)}\n    };\n\n    (constructor, get_storage_size(typ))\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n"},"112":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr","source":"use protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod private_events;\npub mod private_notes;\npub mod process_message;\n\nuse crate::{\n    messages::{\n        discovery::{\n            private_notes::MAX_NOTE_PACKED_LEN, process_message::process_message_ciphertext,\n        },\n        processing::{\n            get_private_logs, pending_tagged_log::PendingTaggedLog,\n            validate_enqueued_notes_and_events,\n        },\n    },\n    utils::array,\n};\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, note nonce, storage slot and note\n/// type ID and attempts to compute its note hash (not hashed by note nonce nor siloed by address) and inner nullifier\n/// (not siloed by address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, note_nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullification = aztec::note::utils::compute_note_hash_for_nullification(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(note_nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullification);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\npub type ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* note nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private logs are downloaded and inspected to find new private\n/// notes, partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Note that the state is synchronized up to the latest block synchronized by PXE. That should be close to the chain\n/// tip as block synchronization is performed before contract function simulation is done.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    // First we process all private logs, which can contain different kinds of messages e.g. private notes, partial\n    // notes, private events, etc.\n    let mut logs = get_private_logs(contract_address);\n    logs.for_each(|i, pending_tagged_log: PendingTaggedLog| {\n        debug_log_format(\n            \"Processing log with tag {0}\",\n            [pending_tagged_log.log.get(0)],\n        );\n\n        // We remove the tag from the pending tagged log and process the message ciphertext contained in it.\n        let message_ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n        process_message_ciphertext(\n            contract_address,\n            compute_note_hash_and_nullifier,\n            message_ciphertext,\n            pending_tagged_log.context,\n        );\n        logs.remove(i);\n    });\n\n    // Then we process all pending partial notes, regardless of whether they were found in the current or previous\n    // executions.\n    partial_notes::fetch_and_process_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    // Finally we validate all notes and events that were found as part of the previous processes, resulting in them\n    // being added to PXE's database and retrievable via oracles (get_notes) and our TS API (PXE::getPrivateEvents).\n    validate_enqueued_notes_and_events(contract_address);\n}\n"},"113":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr","source":"use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub note_nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given note nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    note_nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Found valid nonces for a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullification,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        note_nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullification = compute_note_hash_for_nullification(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(note_nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullification);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        note_nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let note_nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(note_nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash = compute_unique_note_hash(\n            note_nonce,\n            compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash),\n        );\n        let inner_nullifier = note.compute_nullifier_unconstrained(\n            compute_note_hash_for_nullification(retrieved_note, STORAGE_SLOT),\n        );\n\n        NoteAndData { note, note_nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.note_nonce, note_and_data.note_nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == first_note_and_data.note_nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == second_note_and_data.note_nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"},"114":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr","source":"use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::{\n            enqueue_note_for_validation, get_pending_partial_notes_completion_logs,\n            log_retrieval_response::LogRetrievalResponse,\n        },\n    },\n    utils::array,\n};\n\nuse protocol_types::{\n    address::AztecAddress,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for logs that would result in the completion of pending partial notes, ultimately resulting in the notes\n/// being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    // Each of the pending partial notes might get completed by a log containing its public values. For performance\n    // reasons, we fetch all of these logs concurrently and then process them one by one, minimizing the amount of time\n    // waiting for the node roundtrip.\n    let maybe_completion_logs =\n        get_pending_partial_notes_completion_logs(contract_address, pending_partial_notes);\n\n    // Each entry in the maybe completion logs array corresponds to the entry in the pending partial notes array at the\n    // same index. This means we can use the same index as we iterate through the responses to get both the partial note\n    // and the log that might complete it.\n    assert_eq(maybe_completion_logs.len(), pending_partial_notes.len());\n\n    maybe_completion_logs.for_each(|i, maybe_log: Option<LogRetrievalResponse>| {\n        // We clear the completion logs as we read them so that the array is empty by the time we next query it.\n        // TODO(#14943): use volatile arrays to avoid having to manually clear this.\n        maybe_completion_logs.remove(i);\n\n        let pending_partial_note = pending_partial_notes.get(i);\n\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log plaintext to get\n            // the complete packed content.\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                log.log_payload,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            // TODO(#11627): is there anything reasonable we can do if we get a log but it doesn't result in a note\n            // being found?\n            if discovered_notes.len() == 0 {\n                panic(\n                    f\"A partial note's completion log did not result in any notes being found - this should never happen\",\n                );\n            }\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                enqueue_note_for_validation(\n                    contract_address,\n                    pending_partial_note.storage_slot,\n                    discovered_note.note_nonce,\n                    complete_packed_note,\n                    discovered_note.note_hash,\n                    discovered_note.inner_nullifier,\n                    log.tx_hash,\n                    pending_partial_note.recipient,\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"},"115":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/discovery/private_events.nr","source":"use crate::{\n    event::event_selector::EventSelector,\n    messages::{encoding::MAX_MESSAGE_CONTENT_LEN, processing::enqueue_event_for_validation},\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::GENERATOR_INDEX__EVENT_COMMITMENT,\n    hash::poseidon2_hash_with_separator_bounded_vec, traits::FromField,\n};\n\n/// The number of fields in a private event message content that are not the event's serialized representation\n/// (1 field for randomness).\nglobal PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of an event's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, randomness, etc.).\npub global MAX_EVENT_SERIALIZED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN;\n\npub unconstrained fn process_private_event_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n) {\n    // In the case of events, the msg metadata is the event selector.\n    let event_type_id = EventSelector::from_field(msg_metadata as Field);\n\n    assert(\n        msg_content.len() > PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n        f\"Invalid private event message: all private event messages must have at least {PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private event message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN\",\n    );\n\n    let serialized_event_with_randomness = msg_content;\n\n    let event_commitment = poseidon2_hash_with_separator_bounded_vec(\n        serialized_event_with_randomness,\n        GENERATOR_INDEX__EVENT_COMMITMENT,\n    );\n\n    // Randomness was injected into the event payload in `emit_event_in_private` but we have already used it\n    // to compute the event commitment, so we can safely discard it now.\n    let serialized_event = array::subbvec(\n        serialized_event_with_randomness,\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n    );\n\n    enqueue_event_for_validation(\n        contract_address,\n        event_type_id,\n        serialized_event,\n        event_commitment,\n        tx_hash,\n        recipient,\n    );\n}\n"},"116":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr","source":"use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::enqueue_note_for_validation,\n    },\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\n// See the call to `std::static_assert` below to see what's in these fields.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        enqueue_note_for_validation(\n            contract_address,\n            storage_slot,\n            discovered_note.note_nonce,\n            packed_note,\n            discovered_note.note_hash,\n            discovered_note.inner_nullifier,\n            tx_hash,\n            recipient,\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"},"117":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/discovery/process_message.nr","source":"use crate::messages::{\n    discovery::{\n        ComputeNoteHashAndNullifier, partial_notes::process_partial_note_private_msg,\n        private_events::process_private_event_msg, private_notes::process_private_note_msg,\n    },\n    encoding::{decode_message, MESSAGE_CIPHERTEXT_LEN, MESSAGE_PLAINTEXT_LEN},\n    encryption::{aes128::AES128, message_encryption::MessageEncryption},\n    msg_type::{\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n    },\n    processing::message_context::MessageContext,\n};\n\nuse protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\n/// Processes a message that can contain notes, partial notes, or events.\n///\n/// Notes result in nonce discovery being performed prior to delivery, which requires knowledge of the transaction hash\n/// in which the notes would've been created (typically the same transaction in which the log was emitted), along with\n/// the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier` function. Once\n/// discovered, the notes are enqueued for validation.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\n///\n/// Events are processed by computing an event commitment from the serialized event data and its randomness field, then\n/// enqueueing the event data and commitment for validation.\npub unconstrained fn process_message_ciphertext<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_ciphertext: BoundedVec<Field, MESSAGE_CIPHERTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    process_message_plaintext(\n        contract_address,\n        compute_note_hash_and_nullifier,\n        AES128::decrypt(message_ciphertext, message_context.recipient),\n        message_context,\n    );\n}\n\npub unconstrained fn process_message_plaintext<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_plaintext: BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    // The first thing to do after decrypting the message is to determine what type of message we're processing. We\n    // have 3 message types: private notes, partial notes and events.\n\n    // We decode the message to obtain the message type id, metadata and content.\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(message_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            message_context.tx_hash,\n            message_context.unique_note_hashes_in_tx,\n            message_context.first_nullifier_in_tx,\n            message_context.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        process_private_event_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n            message_context.tx_hash,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"},"118":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/encoding.nr","source":"// TODO(#12750): don't make these values assume we're using AES.\nuse crate::utils::array;\nuse protocol_types::constants::PRIVATE_LOG_CIPHERTEXT_LEN;\n\n// We reassign to the constant here to communicate the distinction between a log and a message. In Aztec.nr, unlike in\n// protocol circuits, we have a concept of a message that can be emitted either as a private log or as an offchain\n// message. Message is a piece of data that is to be eventually delivered to a contract via the `process_message(...)`\n// utility function function that is injected by the #[aztec] macro.\npub global MESSAGE_CIPHERTEXT_LEN: u32 = PRIVATE_LOG_CIPHERTEXT_LEN;\n\n// TODO(#12750): The global variables below should not be here as they are AES128 specific.\n// ciphertext_length (2) + 14 bytes pkcs#7 AES padding.\npub(crate) global HEADER_CIPHERTEXT_SIZE_IN_BYTES: u32 = 16;\n\npub global EPH_PK_X_SIZE_IN_FIELDS: u32 = 1;\npub global EPH_PK_SIGN_BYTE_SIZE_IN_BYTES: u32 = 1;\n\n// (17 - 1) * 31 - 16 - 1 = 479\nglobal MESSAGE_PLAINTEXT_SIZE_IN_BYTES: u32 = (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS)\n    * 31\n    - HEADER_CIPHERTEXT_SIZE_IN_BYTES\n    - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES;\n// Each field of the original note log was serialized to 32 bytes. Below we convert the bytes back to fields.\n// 479 / 32 = 15\npub global MESSAGE_PLAINTEXT_LEN: u32 = MESSAGE_PLAINTEXT_SIZE_IN_BYTES / 32;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MESSAGE_PLAINTEXT_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"},"119":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr","source":"use dep::protocol_types::{\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encoding::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, MESSAGE_CIPHERTEXT_LEN, MESSAGE_PLAINTEXT_LEN,\n        },\n        encryption::message_encryption::MessageEncryption,\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__message_bytes__from_PT,\n            get_arr_of_size__message_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\n/**\n * Computes N close-to-uniformly-random 256 bits from a given ECDH shared_secret.\n *\n * NEVER re-use the same iv and sym_key.\n * DO NOT call this function more than once with the same shared_secret.\n *\n * This function is only known to be safe if shared_secret is computed by combining a \n * random ephemeral key with an address point. See big comment within the body of the function.\n * See big comment within the body of the function.\n */\nfn extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [[u8; 32]; N] {\n    /*\n     * Unsafe because of https://eprint.iacr.org/2010/264.pdf Page 13, Lemma 2 (and the * two paragraphs below it).\n     *\n     * If you call this function, you need to be careful and aware of how the arg\n     * `shared_secret` has been derived.\n     *\n     * The paper says that the way you derive aes keys and IVs should be fine with poseidon2\n     * (modelled as a RO), as long as you _don't_ use Poseidon2 as a PRG to generate the * two exponents x & y which multiply to the shared secret S:\n     *\n     * S = [x*y]*G.\n     *\n     * (Otherwise, you would have to \"key\" poseidon2, i.e. generate a uniformly string K\n     * which can be public and compute Hash(x) as poseidon(K,x)).\n     * In that lemma, k would be 2*254=508, and m would be the number of points on the * grumpkin curve (which is close to r according to the Hasse bound).\n     *\n     * Our shared secret S is [esk * address_sk] * G, and the question is: * Can we compute hash(S) using poseidon2 instead of sha256?\n     *\n     * Well, esk is random and not generated with poseidon2, so that's good.\n     * What about address_sk?\n     * Well, address_sk = poseidon2(stuff) + ivsk, so there was some\n     * discussion about whether address_sk is independent of poseidon2.\n     * Given that ivsk is random and independent of poseidon2, the address_sk is also\n     * independent of poseidon2.\n     *\n     * Tl;dr: we believe it's safe to hash S = [esk * address_sk] * G using poseidon2,\n     * in order to derive a symmetric key.\n     *\n     * If you're calling this function for a differently-derived `shared_secret`, be\n     * careful.\n     *\n     */\n\n    /* The output of this function needs to be 32 random bytes.\n     * A single field won't give us 32 bytes of entropy.\n     * So we compute two \"random\" fields, by poseidon-hashing with two different\n     * generators.\n     * We then extract the last 16 (big endian) bytes of each \"random\" field.\n     * Note: we use to_be_bytes because it's slightly more efficient. But we have to\n     * be careful not to take bytes from the \"big end\", because the \"big\" byte is\n     * not uniformly random over the byte: it only has < 6 bits of randomness, because\n     * it's the big end of a 254-bit field element.\n     */\n\n    let mut all_bytes: [[u8; 32]; N] = std::mem::zeroed();\n    // We restrict N to be < 2^8, because of how we compute the domain separator\n    // from k below (where k <= N must be 8 bits). In practice, it's extremely\n    // unlikely that an app will want to compute >= 256 ciphertexts.\n    std::static_assert(N < 256, \"N too large\");\n    for k in 0..N {\n        // We augment the domain separator with the loop index, so that we can\n        // generate N lots of randomness.\n        let k_shift = (k as u16 << 8);\n        let separator_1 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY as u16;\n        let separator_2 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY_2 as u16;\n\n        let rand1: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_1);\n        let rand2: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_2);\n\n        let rand1_bytes: [u8; 32] = rand1.to_be_bytes();\n        let rand2_bytes: [u8; 32] = rand2.to_be_bytes();\n\n        let mut bytes: [u8; 32] = [0; 32];\n        for i in 0..16 {\n            // We take bytes from the \"little end\" of the be-bytes arrays:\n            let j = 32 - i - 1;\n            bytes[i] = rand1_bytes[j];\n            bytes[16 + i] = rand2_bytes[j];\n        }\n\n        all_bytes[k] = bytes;\n    }\n\n    all_bytes\n}\n\nfn derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits<let N: u32>(\n    many_random_256_bits: [[u8; 32]; N],\n) -> [([u8; 16], [u8; 16]); N] {\n    // Many (sym_key, iv) pairs:\n    let mut many_pairs: [([u8; 16], [u8; 16]); N] = std::mem::zeroed();\n    for k in 0..N {\n        let random_256_bits = many_random_256_bits[k];\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n        for i in 0..16 {\n            sym_key[i] = random_256_bits[i];\n            iv[i] = random_256_bits[i + 16];\n        }\n        many_pairs[k] = (sym_key, iv);\n    }\n\n    many_pairs\n}\n\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [([u8; 16], [u8; 16]); N] {\n    let many_random_256_bits: [[u8; 32]; N] = extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe(\n        shared_secret,\n    );\n\n    derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits(many_random_256_bits)\n}\n\npub struct AES128 {}\n\nimpl MessageEncryption for AES128 {\n    fn encrypt<let PlaintextLen: u32>(\n        plaintext: [Field; PlaintextLen],\n        recipient: AztecAddress,\n    ) -> [Field; MESSAGE_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the message in `do_process_message`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        // TODO (#17158): Currently we unwrap the Option returned by derive_ecdh_shared_secret_using_aztec_address.\n        // We need to handle the case where the ephemeral public key is invalid to prevent potential DoS vectors.\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient).unwrap();\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        // It is safe to call the `unsafe` function here, because we know the `shared_secret`\n        // was derived using an AztecAddress (the recipient). See the block comment\n        // at the start of this unsafe target function for more info.\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, body_iv, body_sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        std::static_assert(\n            ciphertext_bytes.len() == 16 * (1 + (PlaintextLen * 32) / 16),\n            \"unexpected ciphertext length\",\n        );\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, header_iv, header_sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        std::static_assert(\n            header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES,\n            \"unexpected ciphertext header length\",\n        );\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut message_bytes_padding_to_mult_31 =\n            get_arr_of_size__message_bytes_padding__from_PT::<PlaintextLen * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        message_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut message_bytes = get_arr_of_size__message_bytes__from_PT::<PlaintextLen * 32>();\n\n        std::static_assert(\n            message_bytes.len() % 31 == 0,\n            \"Unexpected error: message_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        message_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            message_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            message_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..message_bytes_padding_to_mult_31.len() {\n            message_bytes[offset + i] = message_bytes_padding_to_mult_31[i];\n        }\n        offset += message_bytes_padding_to_mult_31.len();\n\n        // Ideally we would be able to have a static assert where we check that the offset would be such that we've\n        // written to the entire log_bytes array, but we cannot since Noir does not treat the offset as a comptime\n        // value (despite the values that it goes through being known at each stage). We instead check that the\n        // computation used to obtain the offset computes the expected value (which we _can_ do in a static check), and\n        // then add a cheap runtime check to also validate that the offset matches this.\n        std::static_assert(\n            1\n                + header_ciphertext_bytes.len()\n                + ciphertext_bytes.len()\n                + message_bytes_padding_to_mult_31.len()\n                == message_bytes.len(),\n            \"unexpected message length\",\n        );\n        assert(offset == message_bytes.len(), \"unexpected encrypted message length\");\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make messages produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let message_bytes_as_fields = bytes_to_fields(message_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final message\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; MESSAGE_CIPHERTEXT_LEN] = [0; MESSAGE_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..message_bytes_as_fields.len() {\n            ciphertext[offset + i] = message_bytes_as_fields[i];\n        }\n        offset += message_bytes_as_fields.len();\n\n        for i in offset..MESSAGE_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the message\n            // (all the \"real\" message fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the message to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt(\n        ciphertext: BoundedVec<Field, MESSAGE_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, MESSAGE_PLAINTEXT_LEN> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, MESSAGE_CIPHERTEXT_LEN, MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) != 0;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret\n        // TODO(#17158): handle invalid ephemeral keys when decrypting to prevent DoS vectors\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk.unwrap());\n\n        // Derive symmetric keys:\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with messages with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext =\n            aes128_decrypt_oracle(header_ciphertext_bvec, header_iv, header_sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, body_iv, body_sym_key);\n\n        // Each field of the original note message was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::{\n            encoding::MESSAGE_PLAINTEXT_LEN, encryption::message_encryption::MessageEncryption,\n        },\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{address::AztecAddress, traits::FromField};\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt() {\n        let env = TestEnvironment::new();\n\n        // Message decryption requires oracles that are only available during private execution\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3];\n\n            let recipient = AztecAddress::from_field(\n                0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n            );\n\n            // Mock random values for deterministic test\n            let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(eph_sk).times(1);\n\n            let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(randomness).times(1000000);\n\n            let _ = OracleMock::mock(\"privateGetNextAppTagAsSender\").returns(42);\n\n            // Encrypt the message\n            let encrypted_message = BoundedVec::from_array(AES128::encrypt(plaintext, recipient));\n\n            // Mock shared secret for deterministic test\n            let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n                EmbeddedCurveScalar::from_field(eph_sk),\n                recipient,\n            );\n\n            let _ = OracleMock::mock(\"utilityGetSharedSecret\").returns(shared_secret.unwrap());\n\n            // Decrypt the message\n            let decrypted = AES128::decrypt(encrypted_message, recipient);\n\n            // The decryption function spits out a BoundedVec because it's designed to work with messages with unknown length\n            // at compile time. For this reason we need to convert the original input to a BoundedVec.\n            let plaintext_bvec = BoundedVec::<Field, MESSAGE_PLAINTEXT_LEN>::from_array(plaintext);\n\n            // Verify decryption matches original plaintext\n            assert_eq(\n                decrypted,\n                plaintext_bvec,\n                \"Decrypted bytes should match original plaintext\",\n            );\n\n            // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n            // static methods of the struct).\n            let _ = AES128 {};\n        });\n    }\n}\n"},"12":{"path":"std/convert.nr","source":"// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u16 {\n    fn from(value: u8) -> u16 {\n        value as u16\n    }\n}\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u16> for u32 {\n    fn from(value: u16) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u16> for u64 {\n    fn from(value: u16) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u16> for u128 {\n    fn from(value: u16) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u16> for Field {\n    fn from(value: u16) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i16 {\n    fn from(value: i8) -> i16 {\n        value as i16\n    }\n}\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i16> for i32 {\n    fn from(value: i16) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\n\nimpl From<i16> for i64 {\n    fn from(value: i16) -> i64 {\n        value as i64\n    }\n}\n\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u16 {\n    fn from(value: bool) -> u16 {\n        value as u16\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for u128 {\n    fn from(value: bool) -> u128 {\n        value as u128\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i16 {\n    fn from(value: bool) -> i16 {\n        value as i16\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            let body = if type1 == type2 {\n                quote { self }\n            } else if type1 == quote { bool } {\n                quote { self != 0 }\n            } else {\n                quote { self as $type1 }\n            };\n\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        $body\n                    }\n                }\n            },\n            );\n        }\n    }\n\n    let u_types =\n        [quote { bool }, quote { u8 }, quote { u16 }, quote { u32 }, quote { u64 }, quote { u128 }];\n\n    for type2 in u_types {\n        let body = quote { self as Field };\n\n        impls = impls.push_back(\n            quote {\n                impl AsPrimitive<Field> for $type2 {\n                    fn as_(self) -> Field {\n                        $body\n                    }\n                }\n            },\n        );\n    }\n\n    for type1 in u_types {\n        let body = if type1 == quote { bool } {\n            quote { self != 0 }\n        } else {\n            quote { self as $type1 }\n        };\n\n        impls = impls.push_back(\n            quote {\n                impl AsPrimitive<$type1> for Field {\n                    fn as_(self) -> $type1 {\n                        $body\n                    }\n                }\n            },\n        );\n    }\n\n    impls.join(quote {})\n}\n"},"136":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/processing/mod.nr","source":"pub(crate) mod event_validation_request;\npub mod message_context;\npub(crate) mod note_validation_request;\npub(crate) mod log_retrieval_request;\npub(crate) mod log_retrieval_response;\npub(crate) mod pending_tagged_log;\n\nuse crate::{\n    capsules::CapsuleArray,\n    event::event_selector::EventSelector,\n    messages::{\n        discovery::{\n            partial_notes::DeliveredPendingPartialNote, private_events::MAX_EVENT_SERIALIZED_LEN,\n            private_notes::MAX_NOTE_PACKED_LEN,\n        },\n        processing::{\n            log_retrieval_request::LogRetrievalRequest,\n            log_retrieval_response::LogRetrievalResponse,\n            note_validation_request::NoteValidationRequest, pending_tagged_log::PendingTaggedLog,\n        },\n    },\n    oracle,\n};\nuse event_validation_request::EventValidationRequest;\nuse protocol_types::{address::AztecAddress, hash::sha256_to_field};\n\n// Base slot for the pending tagged log array to which the fetch_tagged_logs oracle inserts found private logs.\nglobal PENDING_TAGGED_LOG_ARRAY_BASE_SLOT: Field =\n    sha256_to_field(\"AZTEC_NR::PENDING_TAGGED_LOG_ARRAY_BASE_SLOT\".as_bytes());\n\nglobal NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\n/// Searches for private logs emitted by `contract_address` that might contain messages for one of the local accounts,\n/// and stores them in a `CapsuleArray` which is then returned.\npub(crate) unconstrained fn get_private_logs(\n    contract_address: AztecAddress,\n) -> CapsuleArray<PendingTaggedLog> {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `fetchTaggedLogs`\n    // oracle. This makes PXE synchronize tags, download logs and store the pending tagged logs in a capsule array.\n    oracle::message_processing::fetch_tagged_logs(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    CapsuleArray::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT)\n}\n\n/// Enqueues a note for validation by PXE, so that it becomes aware of a note's existence allowing for later retrieval\n/// via `get_notes` oracle. The note will be scoped to `contract_address`, meaning other contracts will not be able to\n/// access it unless authorized.\n///\n/// In order for the note validation and insertion to occur, `validate_enqueued_notes_and_events` must be later called.\n/// For optimal performance, accumulate as many note validation requests as possible and then validate them all at the\n/// end (which results in PXE minimizing the number of network round-trips).\n///\n/// The `packed_note` is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\npub(crate) unconstrained fn enqueue_note_for_validation(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `NoteValidationRequest`\n    CapsuleArray::at(contract_address, NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        NoteValidationRequest {\n            contract_address,\n            storage_slot,\n            note_nonce,\n            packed_note,\n            note_hash,\n            nullifier,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Enqueues an event for validation by PXE, so that it can be efficiently validated and then inserted into the event\n/// store.\n///\n/// In order for the event validation and insertion to occur, `validate_enqueued_notes_and_events` must be later\n/// called. For optimal performance, accumulate as many event validation requests as possible and then validate them\n/// all at the end (which results in PXE minimizing the number of network round-trips).\npub(crate) unconstrained fn enqueue_event_for_validation(\n    contract_address: AztecAddress,\n    event_type_id: EventSelector,\n    serialized_event: BoundedVec<Field, MAX_EVENT_SERIALIZED_LEN>,\n    event_commitment: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `EventValidationRequest`\n    CapsuleArray::at(contract_address, EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        EventValidationRequest {\n            contract_address,\n            event_type_id,\n            serialized_event,\n            event_commitment,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Validates all note and event validation requests enqueued via `enqueue_note_for_validation` and\n/// `enqueue_event_for_validation`, inserting them into the note database and event store respectively, making them\n/// queryable via `get_notes` oracle and our TS API (PXE::getPrivateEvents).\n///\n/// This automatically clears both validation request queues, so no further work needs to be done by the caller.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(contract_address: AztecAddress) {\n    oracle::message_processing::validate_enqueued_notes_and_events(\n        contract_address,\n        NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n        EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n    );\n}\n\n/// Efficiently queries the node for logs that result in the completion of all `DeliveredPendingPartialNote`s stored in\n/// a `CapsuleArray` by performing all node communication concurrently. Returns a second `CapsuleArray` with Options for\n/// the responses that correspond to the pending partial notes at the same index.\n///\n/// For example, given an array with pending partial notes `[ p1, p2, p3 ]`, where `p1` and `p3` have corresponding\n/// completion logs but `p2` does not, the returned `CapsuleArray` will have contents\n/// `[some(p1_log), none(), some(p3_log)]`.\npub(crate) unconstrained fn get_pending_partial_notes_completion_logs(\n    contract_address: AztecAddress,\n    pending_partial_notes: CapsuleArray<DeliveredPendingPartialNote>,\n) -> CapsuleArray<Option<LogRetrievalResponse>> {\n    let log_retrieval_requests =\n        CapsuleArray::at(contract_address, LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT);\n\n    // We create a LogRetrievalRequest for each PendingPartialNote in the CapsuleArray. Because we need the indices in\n    // the request array to match the indices in the partial note array, we can't use CapsuleArray::for_each, as that\n    // function has arbitrary iteration order. Instead, we manually iterate the array from the beginning and push into\n    // the requests array, which we expect to be empty.\n    let mut i = 0;\n    let pending_partial_notes_count = pending_partial_notes.len();\n    while i < pending_partial_notes_count {\n        let pending_partial_note = pending_partial_notes.get(i);\n        log_retrieval_requests.push(\n            LogRetrievalRequest {\n                contract_address,\n                unsiloed_tag: pending_partial_note.note_completion_log_tag,\n            },\n        );\n        i += 1;\n    }\n\n    oracle::message_processing::bulk_retrieve_logs(\n        contract_address,\n        LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT,\n        LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT,\n    );\n\n    CapsuleArray::at(contract_address, LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT)\n}\n"},"148":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr","source":"use protocol_types::traits::{Deserialize, Packable, Serialize};\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, note_nonce: Field },\n//   Settled{ note_nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Deserialize, Eq, Serialize, Packable)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_note_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_note_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_note_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_note_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_note_nonce }\n            }\n        } else if maybe_note_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_note_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_note_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_note_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.note_nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.note_nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    note_nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    note_nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n"},"151":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/note/utils.nr","source":"use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().note_nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullification<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullification_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullification`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullification_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let note_nonce = retrieved_note.metadata.to_pending_previous_phase().note_nonce();\n\n        compute_unique_note_hash(note_nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullification =\n        compute_note_hash_for_nullification(retrieved_note, storage_slot);\n    let inner_nullifier =\n        retrieved_note.note.compute_nullifier(context, note_hash_for_nullification);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"},"156":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr","source":"use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize,\n{\n    let serialized_option = load_oracle(contract_address, slot, <T as Deserialize>::N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(utilityStoreCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(utilityLoadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(utilityDeleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(utilityCopyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), value);\n        });\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            let new_value = MockStruct::new(7, 8);\n            store(contract_address, SLOT, new_value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n        });\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n            delete(contract_address, SLOT);\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            delete(contract_address, SLOT);\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 5;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 10;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 1;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 2;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n            assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n            assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 2;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 1;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n            assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n            assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n        });\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            copy(contract_address, SLOT, SLOT, 1);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let value = MockStruct::new(5, 6);\n            store(other_contract_address, SLOT, value);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let _: Option<MockStruct> = load(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            delete(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            copy(other_contract_address, SLOT, SLOT, 0);\n        });\n    }\n}\n"},"158":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/execution.nr","source":"use crate::context::utility_context::UtilityContext;\n\n#[oracle(utilityGetUtilityContext)]\nunconstrained fn get_utility_context_oracle() -> UtilityContext {}\n\n/// Returns a utility context built from the global variables of anchor block and the contract address of the function\n/// being executed.\npub unconstrained fn get_utility_context() -> UtilityContext {\n    get_utility_context_oracle()\n}\n"},"16":{"path":"std/embedded_curve_ops.nr","source":"use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars, true)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n    predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        let mut result = if double_predicate {\n            // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n            embedded_curve_add_unsafe(point1, point1)\n        } else {\n            let point1_1 = EmbeddedCurvePoint {\n                x: point1.x + (x_coordinates_match as Field),\n                y: point1.y,\n                is_infinite: false,\n            };\n            let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n            // point1_1 is guaranteed to have a different abscissa than point2:\n            // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n            // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n            // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n            // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n            // therefore we only want to do this if we need the result, otherwise it needs to be eliminated as a dead instruction, lest we want the circuit to fail.\n            embedded_curve_add_unsafe(point1_1, point2_1)\n        };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n    _predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    // Ensure is_infinite is comptime\n    let point1_1 = EmbeddedCurvePoint { x: point1.x, y: point1.y, is_infinite: false };\n    let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n    embedded_curve_add_unsafe(point1_1, point2_1)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2, true)[0]\n}\n"},"160":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr","source":"use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(utilityGetContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\nstruct GetContractInstanceResult {\n    exists: bool,\n    member: Field,\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n\nunconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_deployer_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_class_id_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_deployer_internal_avm(address)[0] };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_class_id_internal_avm(address)[0] };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address)[0] };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"},"165":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr","source":"use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(utilityGetKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"},"166":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/keys.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(utilityGetPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] != 0 } },\n        ivpk_m: IvpkM { inner: Point { x: result[3], y: result[4], is_infinite: result[5] != 0 } },\n        ovpk_m: OvpkM { inner: Point { x: result[6], y: result[7], is_infinite: result[8] != 0 } },\n        tpk_m: TpkM { inner: Point { x: result[9], y: result[10], is_infinite: result[11] != 0 } },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"},"168":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/message_processing.nr","source":"use protocol_types::address::AztecAddress;\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn fetch_tagged_logs(pending_tagged_log_array_base_slot: Field) {\n    fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(utilityFetchTaggedLogs)]\nunconstrained fn fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n// This must be a single oracle and not one for notes and one for events because the entire point is to validate\n// all notes and events in one go, minimizing node round-trips.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {\n    validate_enqueued_notes_and_events_oracle(\n        contract_address,\n        note_validation_requests_array_base_slot,\n        event_validation_requests_array_base_slot,\n    );\n}\n\n#[oracle(utilityValidateEnqueuedNotesAndEvents)]\nunconstrained fn validate_enqueued_notes_and_events_oracle(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {}\n\npub(crate) unconstrained fn bulk_retrieve_logs(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {\n    bulk_retrieve_logs_oracle(\n        contract_address,\n        log_retrieval_requests_array_base_slot,\n        log_retrieval_responses_array_base_slot,\n    );\n}\n\n#[oracle(utilityBulkRetrieveLogs)]\nunconstrained fn bulk_retrieve_logs_oracle(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {}\n"},"17":{"path":"std/field/bn254.nr","source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n\n    #[test]\n    fn check_decompose_edge_cases() {\n        assert_eq(decompose(0), (0, 0));\n        assert_eq(decompose(TWO_POW_128 - 1), (TWO_POW_128 - 1, 0));\n        assert_eq(decompose(TWO_POW_128 + 1), (1, 1));\n        assert_eq(decompose(TWO_POW_128 * 2), (0, 2));\n        assert_eq(decompose(TWO_POW_128 * 2 + 0x1234567890), (0x1234567890, 2));\n    }\n\n    #[test]\n    fn check_decompose_large_values() {\n        let large_field = 0xffffffffffffffff;\n        let (lo, hi) = decompose(large_field);\n        assert_eq(large_field, lo + TWO_POW_128 * hi);\n\n        let large_value = large_field - TWO_POW_128;\n        let (lo2, hi2) = decompose(large_value);\n        assert_eq(large_value, lo2 + TWO_POW_128 * hi2);\n    }\n\n    #[test]\n    fn check_lt_comprehensive() {\n        assert(lt(0, 1));\n        assert(!lt(1, 0));\n        assert(!lt(0, 0));\n        assert(!lt(42, 42));\n\n        assert(lt(TWO_POW_128 - 1, TWO_POW_128));\n        assert(!lt(TWO_POW_128, TWO_POW_128 - 1));\n    }\n}\n"},"173":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr","source":"use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(utilityGetSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"},"174":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/storage.nr","source":"use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(utilityStorageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: u32,\n    length: u32,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(address.to_field(), storage_slot, block_number, N)\n}\n\npub unconstrained fn storage_read<T>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"utilityStorageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"utilityStorageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"},"175":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/version.nr","source":"/// The ORACLE_VERSION constant is used to check that the oracle interface is in sync between PXE and Aztec.nr. We need\n/// to version the oracle interface to ensure that developers get a reasonable error message if they use incompatible\n/// versions of Aztec.nr and PXE. The TypeScript counterpart is in `oracle_version.ts`.\n///\n/// @dev Whenever a contract function or Noir test is run, the `utilityAssertCompatibleOracleVersion` oracle is called and\n/// if the oracle version is incompatible an error is thrown.\npub global ORACLE_VERSION: Field = 3;\n\n/// Asserts that the version of the oracle is compatible with the version expected by the contract.\npub fn assert_compatible_oracle_version() {\n    // Safety: This oracle call returns nothing: we only call it to check Aztec.nr and Oracle interface versions are\n    // compatible. It is therefore always safe to call.\n    unsafe {\n        assert_compatible_oracle_version_wrapper();\n    }\n}\n\nunconstrained fn assert_compatible_oracle_version_wrapper() {\n    assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n}\n\n#[oracle(utilityAssertCompatibleOracleVersion)]\nunconstrained fn assert_compatible_oracle_version_oracle(version: Field) {}\n\nmod test {\n    use super::{assert_compatible_oracle_version_oracle, ORACLE_VERSION};\n\n    #[test]\n    unconstrained fn compatible_oracle_version() {\n        assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n    }\n\n    #[test(should_fail_with = \"Incompatible oracle version. TXE is using version '3', but got a request for '318183437'.\")]\n    unconstrained fn incompatible_oracle_version() {\n        let arbitrary_incorrect_version = 318183437;\n        assert_compatible_oracle_version_oracle(arbitrary_incorrect_version);\n    }\n}\n"},"179":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/state_vars/map.nr","source":"use crate::state_vars::storage::HasStorageSlot;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\n\n/// Map\n///\n/// A key-value storage container that maps keys to state variables, similar\n/// to Solidity mappings.\n///\n/// `Map` enables you to associate keys (like addresses or other identifiers)\n/// with state variables in your Aztec smart contract. This is conceptually\n/// similar to Solidity's `mapping(K => V)` syntax, where you can store and\n/// retrieve values by their associated keys.\n///\n/// You can declare a state variable contained within a Map in your contract's\n/// #[storage] struct.\n///\n/// For example, you might use\n/// `Map<AztecAddress, PrivateMutable<ValueNote, Context>, Context>` to track\n/// token balances for different users, similar to how you'd use\n/// `mapping(address => uint256)` in Solidity.\n///\n/// > Aside: the verbose `Context` in the declaration is a consequence of\n/// > leveraging Noir's regular syntax for generics to ensure that certain\n/// > state variable methods can only be called in some contexts (private,\n/// > public, utility).\n///\n/// The methods of Map are:\n/// - `at` (access state variable for a given key)\n/// (see the method's own doc comments for more info).\n///\n/// ## Generic Parameters\n/// - `K`: The key type (must implement `ToField` trait for hashing)\n/// - `V`: The value type:\n///   - any Aztec state variable:\n///     - `PublicMutable`\n///     - `PublicImmutable`\n///     - `PrivateMutable`\n///     - `PrivateImmutable`\n///     - `PrivateSet`\n///     - `DelayedPublicMutable`\n///     - `Map`\n/// - `Context`: The execution context (handles private/public function\n///   contexts)\n///\n/// ## Usage\n/// Maps are typically declared in your contract's #[storage] struct and\n/// accessed\n/// using the `at(key)` method to get the state variable for a specific key.\n/// The resulting state variable can then be read from or written to using its\n/// own methods.\n///\n/// ## Advanced\n/// Internally, `Map` uses a single base storage slot to represent the\n/// mapping\n/// itself, similar to Solidity's approach. Individual key-value pairs are\n/// stored at derived storage slots computed by hashing the base storage\n/// slot\n/// with the key using Poseidon2. This ensures:\n/// - No storage slot collisions between different keys\n/// - Uniform distribution of storage slots across the storage space\n/// - Compatibility with Aztec's storage tree structure\n/// - Gas-efficient storage access patterns similar to Solidity mappings\n///\n/// The storage slot derivation uses `derive_storage_slot_in_map(base_slot,\n/// key)` which computes `poseidon2_hash([base_slot, key.to_field()])`,\n/// ensuring cryptographically secure slot separation.\n///\n/// docs:start:map\npub struct Map<K, V, Context> {\n    pub context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n\n// Map reserves a single storage slot regardless of what it stores because\n// nothing is stored at said slot: it is only used to derive the storage slots\n// of nested state variables, which is expected to never result in collisions\n// or slots being close to one another due to these being hashes. This mirrors\n// the strategy adopted by Solidity mappings.\nimpl<K, T, Context> HasStorageSlot<1> for Map<K, T, Context> {\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    /// Initializes a new Map state variable.\n    ///\n    /// This function is usually automatically called within the #[storage]\n    /// macro.\n    /// You typically don't need to call this directly when writing smart contracts.\n    ///\n    /// # Arguments\n    ///\n    /// * `context` - One of `PrivateContext`/`PublicContext`/`UtilityContext`.\n    ///               The Context determines which methods of this struct will\n    ///               be made available to the calling smart contract function.\n    /// * `storage_slot` - A unique identifier for this Map within the contract.\n    ///                    Usually, the #[storage] macro will determine an\n    ///                    appropriate storage_slot automatically. A smart\n    ///                    contract dev shouldn't have to worry about this, as\n    ///                    it's managed behind the scenes.\n    /// * `state_var_constructor` - A function that creates the value type (V)\n    ///                             given a context and storage slot. This is\n    ///                             typically the constructor of the state\n    ///                             variable type being stored in the Map.\n    ///\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n\n    /// Returns the state variable associated with the given key.\n    ///\n    /// This is equivalent to accessing `mapping[key]` in Solidity. It returns\n    /// the state variable instance for the specified key, which can then be\n    /// used to read or write the value at that key.\n    ///\n    /// Unlike Solidity mappings which return the value directly, this returns\n    /// the state variable wrapper (like PrivateMutable, PublicMutable, etc.)\n    /// that you then call methods on to interact with the actual value.\n    ///\n    /// # Arguments\n    ///\n    /// * `key` - The key to look up in the map. Must implement the ToField\n    ///           trait (which most basic Noir & Aztec types do).\n    ///\n    /// # Returns\n    ///\n    /// * `V` - The state variable instance for this key. You can then call\n    ///         methods like `.read()`, `.write()`, `.get_note()`, etc. on this\n    ///         depending on the specific state variable type.\n    ///\n    /// # Example\n    ///\n    /// ```noir\n    /// // Get a user's balance (assuming PrivateMutable<ValueNote>)\n    /// let user_balance = storage.balances.at(user_address);\n    /// let current_note = user_balance.get_note();\n    ///\n    /// // Update the balance\n    /// user_balance.replace(new_note);\n    /// ```\n    ///\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n}\n"},"18":{"path":"std/field/mod.nr","source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n"},"187":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr","source":"use crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::storage::HasStorageSlot,\n    utils::with_hash::WithHash,\n};\nuse protocol_types::{\n    constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator,\n    traits::Packable,\n};\n\n/// # PublicImmutable\n///\n/// PublicImmutable is a public state variable type for values that are set once\n/// during initialization and remain permanently unchanged.\n///\n/// You can declare a state variable of type PublicImmutable within your contract's\n/// #[storage] struct:\n///\n/// E.g.:\n/// `your_variable: PublicImmutable<T, Context>`\n///\n/// PublicImmutable stores an immutable value in public state which can be _read_\n/// from public, utility and even _private_ execution contexts.\n///\n/// The methods of PublicImmutable are:\n/// - `initialize`\n/// - `read`\n/// (see the methods' own doc comments for more info).\n///\n/// # Generic Parameters:\n///\n/// * `T` - The type of value stored (must implement Packable).\n/// * `Context` - The execution context (PublicContext, PrivateContext, or UtilityContext).\n///\n/// # Advanced\n///\n/// PublicImmutable leverages `WithHash<T>` to enable efficient private reads of\n/// public storage. The `WithHash` wrapper optimizes reads by hashing values that would\n/// be larger than a single field into a single field, then proving inclusion of only\n/// the hash in public storage.\n///\n/// This optimization is particularly valuable when T packs to multiple fields,\n/// as it maintains \"almost constant\" verification overhead regardless of the\n/// original data size.\n///\n/// ## Optimizing private reads in your contract\n/// Since reading T from public immutable storage in private contexts has \"almost\n/// constant\" constraint costs regardless of T's size, it's recommended to group\n/// multiple values into a single struct when they are to be read together. This is\n/// typically useful for configuration data set during contract initialization. E.g.:\n///\n/// ```noir\n/// use dep::aztec::protocol_types::{address::AztecAddress, traits::Packable};\n/// use std::meta::derive;\n///\n/// #[derive(Eq, Packable)]\n/// pub struct Config \\{\n///     pub address_1: AztecAddress,\n///     pub value_1: u128,\n///     pub value_2: u64,\n///     ...\n/// }\n/// ```\n///\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\n/// `PublicImmutable` stores both the packed value (using M fields) and its hash (1 field), requiring M + 1 total\n/// fields.\nimpl<T, Context, let M: u32> HasStorageSlot<M + 1> for PublicImmutable<T, Context>\nwhere\n    T: Packable<N = M>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    /// Initializes a new PublicImmutable state variable.\n    ///\n    /// This function is usually automatically called within the #[storage] macro.\n    /// You typically don't need to call this directly when writing smart contracts.\n    ///\n    /// # Arguments\n    ///\n    /// * `context` - One of `PublicContext`/`PrivateContext`/`UtilityContext`. The\n    ///               Context determines which methods of this struct will be made\n    ///               available to the calling smart contract function.\n    /// * `storage_slot` - A unique identifier for this state variable within the\n    ///                    contract. Usually, the #[storage] macro will determine an\n    ///                    appropriate storage_slot automatically. A smart contract\n    ///                    dev shouldn't have to worry about this, as it's managed\n    ///                    behind the scenes.\n    ///\n    /// docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n        )\n    }\n}\n\nimpl<T> PublicImmutable<T, &mut PublicContext> {\n    /// Initializes a PublicImmutable state variable instance with a permanent value.\n    ///\n    /// This function sets the immutable value for this state variable. It can only\n    /// be called once per PublicImmutable. Subsequent calls will fail because the\n    /// initialization nullifier will already exist.\n    ///\n    /// # Arguments\n    /// * `value` - The permanent value to store in this PublicImmutable.\n    ///\n    /// # Panics\n    /// Panics if the value is already initialized.\n    ///\n    /// # Advanced\n    ///\n    /// This function performs the following operations:\n    /// - Creates and emits an initialization nullifier to mark this storage slot\n    ///   as initialized. This prevents double-initialization.\n    /// - Wraps the value in `WithHash<T>` for efficient private reads.\n    /// - Stores the wrapped value in Aztec's public data tree.\n    ///\n    /// docs:start:public_immutable_struct_write\n    pub fn initialize(self, value: T)\n    where\n        T: Packable + Eq,\n    {\n        // We emit an initialization nullifier to indicate that the struct is initialized. This also prevents\n        // the value from being initialized again as a nullifier can be included only once.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        self.context.storage_write(self.storage_slot, WithHash::new(value));\n    }\n\n    /// Reads the permanent value stored in this PublicImmutable state variable.\n    ///\n    /// # Returns\n    /// * `T` - The permanent value stored in this PublicImmutable.\n    ///\n    /// # Panics\n    /// Panics if the value is not initialized.\n    ///\n    /// # Advanced\n    ///\n    /// This function performs the following operations:\n    /// - Checks that the state variable has been initialized by verifying the\n    ///   initialization nullifier exists\n    /// - Reads the `WithHash<T>` wrapper from public storage\n    /// - Extracts and returns the original value T\n    ///\n    /// The function will panic if called on an uninitialized PublicImmutable.\n    ///\n    /// docs:start:public_immutable_struct_read\n    pub fn read(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        assert(self.is_initialized(), \"Trying to read from uninitialized PublicImmutable\");\n        WithHash::public_storage_read(*self.context, self.storage_slot)\n    }\n\n    /// Reads the value stored in this PublicImmutable without checking if the value\n    /// is initialized.\n    ///\n    /// This function bypasses the initialization check and directly reads from\n    /// storage.\n    /// If the PublicImmutable has not been initialized, this will return a\n    /// zeroed value.\n    /// However, if the variable is _known_ to be initialized, this is cheaper\n    /// to call than `read`.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The value stored in this PublicImmutable, or empty/default values if\n    ///         uninitialized.\n    ///\n    pub fn read_unsafe(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        WithHash::public_storage_read(*self.context, self.storage_slot)\n    }\n\n    fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.nullifier_exists(nullifier, self.context.this_address())\n    }\n}\n\nimpl<T> PublicImmutable<T, UtilityContext> {\n    /// Reads the permanent value stored in this PublicImmutable state variable.\n    ///\n    /// Notice that this function is executable only within a UtilityContext, which\n    /// is an unconstrained environment on the user's local device.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The permanent value stored in this PublicImmutable.\n    ///\n    pub unconstrained fn read(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        // TODO(#15703): this fn should fail if the variable is not initialized\n        WithHash::utility_public_storage_read(self.context, self.storage_slot)\n    }\n}\n\nimpl<T> PublicImmutable<T, &mut PrivateContext> {\n    /// Reads the permanent value stored in this PublicImmutable from the anchor\n    /// block.\n    ///\n    /// Private functions execute asynchronously and offchain. When a user begins\n    /// private execution, their view of the chain 'branches off' from the current\n    /// public state, since public state continues to advance while they execute\n    /// privately. Therefore, private functions read from a historical snapshot of\n    /// public state rather than the current state.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The permanent value stored in this PublicImmutable at the historical\n    ///         block referenced by the private context.\n    ///\n    /// # Advanced\n    ///\n    /// This function performs a historical read using the block header from the private\n    /// context. The `WithHash` optimization is particularly valuable here because it\n    /// reduces the number of required inclusion proofs by proving membership of\n    /// only the hash instead of the full packed value.\n    ///\n    /// The historical read mechanism:\n    /// - Uses an oracle to obtain the value from the anchor block\n    /// - Proves inclusion of the value's hash in the public data tree\n    /// - Proves that the root of this public data tree is correct, relative to the\n    ///   anchor block header.\n    /// - Verifies that the oracle-provided value matches the stored hash\n    ///\n    pub fn read(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        // TODO(#15703): this fn should fail if the variable is not initialized\n        WithHash::historical_public_storage_read(\n            self.context.get_anchor_block_header(),\n            self.context.this_address(),\n            self.storage_slot,\n        )\n    }\n}\n"},"189":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr","source":"use crate::context::{PublicContext, UtilityContext};\nuse crate::state_vars::storage::HasStorageSlot;\nuse dep::protocol_types::traits::Packable;\n\n/// # PublicMutable\n///\n/// PublicMutable is a public state variable type for values that can be read\n/// and written within #[external(\"public\")] functions of your smart contract.\n///\n/// You can declare a state variable of type PublicMutable within your contract's\n/// #[storage] struct:\n///\n/// E.g.:\n/// `your_variable: PublicMutable<T, Context>`\n/// or:\n/// `your_mapping: Map<Field, PublicMutable<T, Context>>`\n///\n/// The methods of PublicMutable are:\n/// - `read`\n/// - `write`\n/// (see the methods' own doc comments for more info).\n///\n/// ## Example.\n///\n/// A voting contract's proposal count can be represented as a PublicMutable<u64>.\n/// The count can be read by anyone to see how many proposals exist, and incremented\n/// when new proposals are submitted.\n///\n/// # Generic Parameters:\n///\n/// * `T` - The type of value stored (must implement Packable).\n/// * `Context` - The execution context (PublicContext or UtilityContext).\n///\n/// # Advanced\n///\n/// Unlike private state variables which use notes, PublicMutable stores values\n/// directly in Aztec's public data tree. This enables direct read and write\n/// access to the current state during public function execution.\n///\n/// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\nimpl<T, Context, let M: u32> HasStorageSlot<M> for PublicMutable<T, Context>\nwhere\n    T: Packable<N = M>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    /// Initializes a new PublicMutable state variable.\n    ///\n    /// This function is usually automatically called within the #[storage] macro.\n    /// You typically don't need to call this directly when writing smart contracts.\n    ///\n    /// # Arguments\n    ///\n    /// * `context` - One of `PublicContext`/`UtilityContext`. The Context determines\n    ///               which methods of this struct will be made available to the calling\n    ///               smart contract function.\n    /// * `storage_slot` - A unique identifier for this state variable within the\n    ///                    contract. Usually, the #[storage] macro will determine an\n    ///                    appropriate storage_slot automatically. A smart contract\n    ///                    dev shouldn't have to worry about this, as it's managed\n    ///                    behind the scenes.\n    ///\n    /// docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n}\n\nimpl<T> PublicMutable<T, &mut PublicContext> {\n    /// Reads the current value stored in this PublicMutable state variable.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The current value stored in this PublicMutable.\n    ///\n    /// docs:start:public_mutable_struct_read\n    pub fn read(self) -> T\n    where\n        T: Packable,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n\n    /// Writes a new value to this PublicMutable state variable.\n    ///\n    /// # Arguments\n    ///\n    /// * `value` - The new value to store in this PublicMutable.\n    ///\n    /// # Advanced\n    ///\n    /// This function updates the value stored in Aztec's public data tree.\n    /// The new value becomes immediately available to subsequent reads within\n    /// the same transaction.\n    ///\n    /// docs:start:public_mutable_struct_write\n    pub fn write(self, value: T)\n    where\n        T: Packable,\n    {\n        self.context.storage_write(self.storage_slot, value);\n    }\n}\n\nimpl<T> PublicMutable<T, UtilityContext> {\n    /// Reads the current value stored in this PublicMutable state variable.\n    ///\n    /// Notice that this function is executable only within a UtilityContext, which\n    /// is an unconstrained environment on the user's local device.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The current value stored in this PublicMutable.\n    ///\n    pub unconstrained fn read(self) -> T\n    where\n        T: Packable,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"},"19":{"path":"std/hash/mod.nr","source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"},"209":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/array/append.nr","source":"/// Appends the elements of the second `BoundedVec` to the end of the first one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let ALen: u32, let BLen: u32, let DstLen: u32>(\n    a: BoundedVec<T, ALen>,\n    b: BoundedVec<T, BLen>,\n) -> BoundedVec<T, DstLen> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"},"212":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr","source":"/// Returns `DstLen` elements from a source array, starting at `offset`. `DstLen` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SrcLen: u32, let DstLen: u32>(src: [T; SrcLen], offset: u32) -> [T; DstLen] {\n    assert(offset + DstLen <= SrcLen, \"DstLen too large for offset\");\n\n    let mut dst: [T; DstLen] = std::mem::zeroed();\n    for i in 0..DstLen {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DstLen to be 0, so we always get back an empty array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"},"213":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr","source":"use crate::utils::array;\n\n/// Returns `DstMaxLen` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DstLen` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DstLen` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SrcMaxLen: u32, let DstMaxLen: u32>(\n    bvec: BoundedVec<T, SrcMaxLen>,\n    offset: u32,\n) -> BoundedVec<T, DstMaxLen> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"},"215":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr","source":"use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"},"216":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr","source":"// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"},"219":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/point.nr","source":"use protocol_types::{point::Point, utils::field::sqrt};\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\n/// Returns a `Point` in the Grumpkin curve given its x coordinate.\n///\n/// Because not all values in the field are valid x coordinates of points in the curve (i.e. there\n/// is no corresponding y value in the field that satisfies the curve equation), it may not be\n/// possible to reconstruct a `Point`. `Option::none()` is returned in such cases.\npub fn point_from_x_coord(x: Field) -> Option<Point> {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    sqrt(rhs).map(|y| Point { x, y, is_infinite: false })\n}\n\n/// Returns a `Point` in the Grumpkin curve given its x coordinate and sign for the y coordinate.\n///\n/// Because not all values in the field are valid x coordinates of points in the curve (i.e. there\n/// is no corresponding y value in the field that satisfies the curve equation), it may not be\n/// possible to reconstruct a `Point`. `Option::none()` is returned in such cases.\n///\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Option<Point> {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n\n    sqrt(rhs).map(|y| {\n        // If there is a square root, we need to ensure it has the correct \"sign\"\n        let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n        let final_y = if y_is_positive == sign { y } else { -y };\n        Point { x, y: final_y, is_infinite: false }\n    })\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord, point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n    use dep::protocol_types::utils::field::pow;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign).unwrap();\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2).unwrap();\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_valid() {\n        // x = 8 is a known quadratic residue - should give a valid point\n        let result = point_from_x_coord(Field::from(8));\n        assert(result.is_some());\n\n        let point = result.unwrap();\n        assert_eq(point.x, Field::from(8));\n        // Check curve equation y^2 = x^3 - 17\n        assert_eq(pow(point.y, 2), pow(point.x, 3) - 17);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_invalid() {\n        // x = 3 is a non-residue for this curve - should give None\n        let x = Field::from(3);\n        let maybe_point = point_from_x_coord(x);\n        assert(maybe_point.is_none());\n    }\n\n}\n"},"223":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr","source":"use crate::{\n    context::{PublicContext, UtilityContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    abis::block_header::BlockHeader, address::AztecAddress, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `M` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `M`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let M: u32> {\n    value: T,\n    packed: [Field; M],\n    hash: Field,\n}\n\nimpl<T, let M: u32> WithHash<T, M>\nwhere\n    T: Packable<N = M> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn utility_public_storage_read(\n        context: UtilityContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + M as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\n// Note: I don't derive Packable on `WithHash` because `derive_serialize` function does not support setting \"N = M\"\n// as I do here 3 lines below. This could be worked around by placing the \"where\" clause directly on the `WithHash`\n// struct, but Jake mentioned that the syntax is not expected to be supported at least until Noir 1.0.\n// Relevant discussion on Slack:\n// https://aztecprotocol.slack.com/archives/C04QF64EDNV/p1752593876160699?thread_ts=1752589887.955379&cid=C04QF64EDNV\nimpl<T, let M: u32> Packable for WithHash<T, M>\nwhere\n    T: Packable<N = M>,\n{\n    let N: u32 = M + 1;\n\n    fn pack(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n        for i in 0..M {\n            result[i] = self.packed[i];\n        }\n        result[M] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; Self::N]) -> Self {\n        let mut value_packed = [0; M];\n        for i in 0..M {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[M];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::test::OracleMock;\n\n    global STORAGE_SLOT: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let env = TestEnvironment::new();\n\n        env.private_context(|context| {\n            let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n                context.anchor_block_header,\n                context.this_address(),\n                STORAGE_SLOT,\n            );\n\n            assert_eq(result, std::mem::zeroed());\n        });\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        env.public_context(|context| { context.storage_write(STORAGE_SLOT, value_with_hash); });\n\n        env.private_context(|context| {\n            let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n                context.anchor_block_header,\n                context.this_address(),\n                STORAGE_SLOT,\n            );\n            assert_eq(result, value);\n        });\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn bad_hint_uninitialized_value() {\n        let env = TestEnvironment::new();\n\n        env.private_context(|context| {\n            let block_header = context.anchor_block_header;\n            let address = context.this_address();\n\n            // Mock the oracle to return a non-zero hint/packed value\n            let value_packed = MockStruct { a: 1, b: 1 }.pack();\n            let _ = OracleMock::mock(\"utilityStorageRead\")\n                .with_params((\n                    address.to_field(), STORAGE_SLOT, block_header.global_variables.block_number,\n                    value_packed.len(),\n                ))\n                .returns(value_packed)\n                .times(1);\n\n            // This should fail because the hint value is non-zero and the hash is zero (default value of storage)\n            let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n                block_header,\n                address,\n                STORAGE_SLOT,\n            );\n        });\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn bad_hint_initialized_value() {\n        let env = TestEnvironment::new();\n\n        env.public_context(|context| {\n            // Write the value and hash separately so that the hash is wrong\n            let value = MockStruct { a: 5, b: 3 };\n            context.storage_write(STORAGE_SLOT, value);\n\n            let incorrect_hash = 13;\n            let hash_storage_slot = STORAGE_SLOT + (value.pack().len() as Field);\n            context.storage_write(hash_storage_slot, [incorrect_hash]);\n        });\n\n        env.private_context(|context| {\n            let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n                context.anchor_block_header,\n                context.this_address(),\n                STORAGE_SLOT,\n            );\n        });\n    }\n}\n"},"230":{"path":"/home/jpag/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr","source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"},"252":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr","source":"use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\nuse std::meta::derive;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct FunctionSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    pub inner: u32,\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"},"293":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\nuse std::meta::derive;\n\n// Aztec address\n#[derive(Deserialize, Eq, Packable, Serialize)]\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    /// Returns an address's `AddressPoint`, which can be used to create shared secrets with the owner\n    /// of the address. If the address is invalid (i.e. it is not a properly derived Aztec address), then this\n    /// returns `Option::none()`, and no shared secrets can be created.\n    pub fn to_address_point(self) -> Option<AddressPoint> {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // An invalid AztecAddress is one for which no y coordinate satisfies the curve equation, which we'll\n        // identify by proving that the square root of y_squared does not exist.\n        let mut y_opt = sqrt(y_squared);\n        if y_opt.is_none() {\n            Option::none()\n        } else {\n            let mut y = y_opt.unwrap();\n\n            // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n            // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n            // note: The field modulus is MAX_FIELD_VALUE + 1\n            if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n                y = (MAX_FIELD_VALUE + 1) - y;\n            }\n\n            Option::some(\n                AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } },\n            )\n        }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    // We use the AZTEC_ADDRESS_LENGTH constant to ensure that there is a match between the derived trait\n    // implementation and the constant.\n    let serialized: [Field; AZTEC_ADDRESS_LENGTH] = address.serialize();\n    let deserialized = AztecAddress::deserialize(serialized);\n    assert_eq(address, deserialized);\n}\n\n#[test]\nfn to_address_point_valid() {\n    // x = 8 where x^3 - 17 = 512 - 17 = 495, which is a residue in this field\n    let address = AztecAddress { inner: 8 };\n    let maybe_point = address.to_address_point();\n    assert(maybe_point.is_some());\n\n    let point = maybe_point.unwrap().inner;\n    // check that x is preserved\n    assert_eq(point.x, Field::from(8));\n\n    // check that the curve equation holds: y^2 == x^3 - 17\n    assert_eq(pow(point.y, 2), pow(point.x, 3) - 17);\n}\n\n#[test]\nunconstrained fn to_address_point_invalid() {\n    // x = 3 where x^3 - 17 = 27 - 17 = 10, which is a non-residue in this field\n    let address = AztecAddress { inner: 3 }; //\n    let maybe_point = address.to_address_point();\n    assert(maybe_point.is_none());\n}\n"},"3":{"path":"std/array/mod.nr","source":"use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n"},"308":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr","source":"// TODO: Expose other wrapped functions than debug (info, warn)\n// ['silent', 'fatal', 'error', 'warn', 'info', 'verbose', 'debug', 'trace']\n\npub global SILENT_LOG_LEVEL: u8 = 0;\npub global FATAL_LOG_LEVEL: u8 = 1;\npub global ERROR_LOG_LEVEL: u8 = 2;\npub global WARN_LOG_LEVEL: u8 = 3;\npub global INFO_LOG_LEVEL: u8 = 4;\npub global VERBOSE_LOG_LEVEL: u8 = 5;\npub global DEBUG_LOG_LEVEL: u8 = 6;\npub global TRACE_LOG_LEVEL: u8 = 7;\n\n/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Same as debug_log, but allows to customize the log level.\n/// Consider changing just to 'log'\npub fn debug_log_with_level<let N: u32>(log_level: u8, msg: str<N>) {\n    debug_log_format_with_level(log_level, msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_array_oracle_wrapper(DEBUG_LOG_LEVEL, msg, args) };\n}\n\n/// Same as debug_log_format, but allows to customize the log level.\n/// Consider changing just to 'log_format'\npub fn debug_log_format_with_level<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field; N],\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_array_oracle_wrapper(log_level, msg, args) };\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` slice.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole slice: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format_slice<let M: u32>(log_level: u8, msg: str<M>, args: [Field]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_slice_oracle_wrapper(log_level, msg, args) };\n}\n\n// We provide two versions of the debug log oracle: one that takes args as a slice and another one that takes args as an array.\n// We do this since conversion from array to slice generates overhead in public functions, since opcodes need to be emitted for the conversion.\n// By exposing the two flavors, we avoid conversions since the AVM is able to handle both arrays an slices in this oracle.\n\nunconstrained fn debug_log_slice_oracle_wrapper<let M: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field],\n) {\n    debug_log_slice_oracle(log_level, msg, args);\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_slice_oracle<let M: u32>(log_level: u8, msg: str<M>, args: [Field]) {}\n\nunconstrained fn debug_log_array_oracle_wrapper<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_array_oracle(log_level, msg, N, args);\n}\n\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_array_oracle<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    length: u32,\n    args: [Field; N],\n) {}\n"},"318":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"mod poseidon2_chunks;\n\nuse crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_log::{PrivateLog, PrivateLogData},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root_from_sibling_path,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    poseidon2::Poseidon2Sponge,\n    side_effect::{Counted, Scoped},\n    traits::{FromField, Hash, ToField},\n    utils::field::{field_from_bytes, field_from_bytes_32_trunc},\n};\n\npub use poseidon2_chunks::poseidon2_absorb_in_chunks_existing_sponge;\nuse poseidon2_chunks::poseidon2_absorb_in_chunks;\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(note_nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [note_nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_nonce_and_unique_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    let note_nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n    compute_unique_note_hash(note_nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        compute_nonce_and_unique_note_hash(siloed_note_hash, first_nullifier, note_index_in_tx)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: Scoped<Counted<NoteHash>>) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.innermost())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: Scoped<Counted<Nullifier>>) -> Field {\n    let value = nullifier.innermost().value;\n    // Q: shouldn't we be checking whether the _whole_ nullifier is empty?\n    // A: We don't have to. The init and inner circuits add contract address to non-empty nullifiers.\n    // So we know we should silo it if the contract address is not empty.\n    if nullifier.contract_address.is_zero() {\n        value // Return `value` instead of 0 because an already-siloed nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, value)\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<Counted<PrivateLogData>>) -> PrivateLog {\n    let log = private_log.innermost().log;\n    if private_log.contract_address.is_zero() {\n        log\n    } else {\n        let mut fields = log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, log.length)\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn compute_app_secret_key(\n    master_secret_key: EmbeddedCurveScalar,\n    app_address: AztecAddress,\n    app_secret_generator: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [master_secret_key.hi, master_secret_key.lo, app_address.to_field()],\n        app_secret_generator,\n    )\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let contract_address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    let recipient_bytes: [u8; 20] = recipient.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let rollup_version_id_bytes: [u8; 32] = rollup_version_id.to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n\n    let mut bytes: [u8; 148] = std::mem::zeroed();\n    for i in 0..32 {\n        bytes[i] = contract_address_bytes[i];\n        bytes[i + 32] = rollup_version_id_bytes[i];\n        // 64 - 84 are for recipient.\n        bytes[i + 84] = chain_id_bytes[i];\n        bytes[i + 116] = content_bytes[i];\n    }\n\n    for i in 0..20 {\n        bytes[64 + i] = recipient_bytes[i];\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: Scoped<L2ToL1Message>,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.inner.recipient,\n            msg.inner.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n/// Computes sha256 hash of 2 input fields.\n///\n/// @returns A truncated field (i.e., the first byte is always 0).\npub fn accumulate_sha256(v0: Field, v1: Field) -> Field {\n    // Concatenate two fields into 32 x 2 = 64 bytes\n    let v0_as_bytes: [u8; 32] = v0.to_be_bytes();\n    let v1_as_bytes: [u8; 32] = v1.to_be_bytes();\n    let hash_input_flattened = v0_as_bytes.concat(v1_as_bytes);\n\n    sha256_to_field(hash_input_flattened)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = [separator.to_field()].concat(inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n/// Computes a Poseidon2 hash over a dynamic-length subarray of the given input.\n/// Only the first `in_len` fields of `input` are absorbed; any remaining fields are ignored.\n/// The caller is responsible for ensuring that the input is padded with zeros if required.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_in_chunks(input, in_len);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_in_chunks(input, in_len);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n// This function is  unconstrained because it is intended to be used in unconstrained context only as\n// in constrained contexts it would be too inefficient.\npub unconstrained fn poseidon2_hash_with_separator_bounded_vec<let N: u32, T>(\n    inputs: BoundedVec<Field, N>,\n    separator: T,\n) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs.get(i));\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0x3b18c58c739716e76429634a61375c45b3b5cd470c22ab6d3e14cee23dd992);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0xaab2a5828156782b12a1dc6f336e2bc627eb1b9514b02d511f66296990c050);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        L2ToL1Message { recipient: EthAddress::from_field(1), content: 2 }.scope(\n            AztecAddress::from_field(3),\n        ),\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `yarn-project/stdlib/src/hash/hash.test.ts`\n    let hash_from_typescript = 0x0081edf209e087ad31b3fd24263698723d57190bd1d6e9fe056fc0c0a68ee661;\n\n    assert_eq(hash, hash_from_typescript);\n}\n\n#[test]\nunconstrained fn poseidon2_hash_with_separator_bounded_vec_matches_non_bounded_vec_version() {\n    let inputs = BoundedVec::<Field, 4>::from_array([1, 2, 3]);\n    let separator = 42;\n\n    // Hash using bounded vec version\n    let bounded_result = poseidon2_hash_with_separator_bounded_vec(inputs, separator);\n\n    // Hash using regular version\n    let regular_result = poseidon2_hash_with_separator([1, 2, 3], separator);\n\n    // Results should match\n    assert_eq(bounded_result, regular_result);\n}\n"},"331":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr","source":"use utils::derive_serialization_quotes;\n\npub mod utils;\n\n/// Generates the generic parameter declarations for a struct's trait implementation.\n///\n/// This function takes a struct type definition and generates the generic parameter declarations\n/// that go after the `impl` keyword. For example, given a struct with generics `N: u32` and `T`,\n/// it generates `<let N: u32, T>`.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate generic declarations for\n///\n/// # Returns\n/// A quoted code block containing the generic parameter declarations, or an empty quote if the struct\n/// has no generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// This function generates:\n/// ```\n/// <let N: u32, T>\n/// ```\ncomptime fn get_generics_declarations(s: TypeDefinition) -> Quoted {\n    let generics = s.generics();\n\n    if generics.len() > 0 {\n        let generics_declarations_items = generics\n            .map(|(name, maybe_integer_typ)| {\n                // The second item in the generics tuple is an Option of an integer type that is Some only if\n                // the generic is numeric.\n                if maybe_integer_typ.is_some() {\n                    // The generic is numeric, so we return a quote defined as e.g. \"let N: u32\"\n                    let integer_type = maybe_integer_typ.unwrap();\n                    quote {let $name: $integer_type}\n                } else {\n                    // The generic is not numeric, so we return a quote containing the name of the generic (e.g. \"T\")\n                    quote {$name}\n                }\n            })\n            .join(quote {,});\n        quote {<$generics_declarations_items>}\n    } else {\n        // The struct doesn't have any generics defined, so we just return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates the `where` clause for a trait implementation that constrains non-numeric generic type parameters.\n///\n/// This function takes a struct type definition and a trait name, and generates a `where` clause that\n/// requires all non-numeric generic type parameters to implement the specified trait.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the where clause for\n/// - `trait_name`: The name of the trait that non-numeric generic parameters must implement\n///\n/// # Returns\n/// A quoted code block containing the where clause, or an empty quote if the struct has no non-numeric\n/// generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// And trait name \"Serialize\", this function generates:\n/// ```\n/// where T: Serialize\n/// ```\ncomptime fn get_where_trait_clause(s: TypeDefinition, trait_name: Quoted) -> Quoted {\n    let generics = s.generics();\n\n    // The second item in the generics tuple is an Option of an integer type that is Some only if the generic is\n    // numeric.\n    let non_numeric_generics =\n        generics.filter(|(_, maybe_integer_typ)| maybe_integer_typ.is_none());\n\n    if non_numeric_generics.len() > 0 {\n        let non_numeric_generics_declarations =\n            non_numeric_generics.map(|(name, _)| quote {$name: $trait_name}).join(quote {,});\n        quote {where $non_numeric_generics_declarations}\n    } else {\n        // There are no non-numeric generics, so we return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates a `Serialize` trait implementation for a struct type.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A quoted code block containing the trait implementation\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Log<N> {\n///     fields: [Field; N],\n///     length: u32\n/// }\n/// ```\n///\n/// This function generates code equivalent to:\n/// ```\n/// impl<let N: u32> Serialize for Log<N> {\n///     let N: u32 = <[Field; N] as Serialize>::N + <u32 as Serialize>::N;\n///\n///     #[inline_always]\n///     fn serialize(self) -> [Field; Self::N] {\n///         let mut serialized_params = [0; _];\n///         let mut offset = 0;\n///\n///         let serialized_member = Serialize::serialize(self.fields);\n///         let serialized_member_len = <[Field; N] as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             serialized_params[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         let serialized_member = Serialize::serialize(self.length);\n///         let serialized_member_len = <u32 as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             serialized_params[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         serialized_params\n///     }\n/// }\n/// ```\npub comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n\n    // We care only about the name and type so we drop the last item of the tuple\n    let params = nested_struct.0.fields(nested_struct.1).map(|(name, typ, _)| (name, typ));\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Serialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_serialize_clause = get_where_trait_clause(s, quote {Serialize});\n\n    let (function_body, params_len_quote, serialized_params_name) =\n        derive_serialization_quotes(params, true);\n\n    quote {\n        impl$generics_declarations $crate::traits::Serialize for $typ\n            $where_serialize_clause\n        {\n            let N: u32 = $params_len_quote;\n\n            #[inline_always]\n            fn serialize(self) -> [Field; Self::N] {\n                $function_body\n\n                $serialized_params_name\n            }\n        }\n    }\n}\n\n/// Generates a `Deserialize` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Deserialize` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Deserialize for MyStruct {\n///     let N: u32 = <AztecAddress as Deserialize>::N + <Field as Deserialize>::N;\n///\n///     fn deserialize(serialized: [Field; Self::N]) -> Self {\n///         let mut offset = 0;\n///         let mut member_fields = [0; <AztecAddress as Deserialize>::N];\n///         for i in 0..<AztecAddress as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let x = <AztecAddress as Deserialize>::deserialize(member_fields);\n///         offset += <AztecAddress as Deserialize>::N;\n///\n///         let mut member_fields = [0; <Field as Deserialize>::N];\n///         for i in 0..<Field as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let y = <Field as Deserialize>::deserialize(member_fields);\n///         offset += <Field as Deserialize>::N;\n///\n///         Self { x, y }\n///     }\n/// }\n/// ```\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Deserialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_deserialize_clause = get_where_trait_clause(s, quote {Deserialize});\n\n    // The following will give us <type_of_struct_member_1 as Deserialize>::N + <type_of_struct_member_2 as Deserialize>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Deserialize>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly deserializing the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let function_body = if params.len() > 1 {\n        // This generates deserialization code for each struct member and concatenates them together.\n        let deserialization_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as Deserialize>::N];\n                    for i in 0..<$param_type as Deserialize>::N {\n                        member_fields[i] = serialized[i + offset];\n                    }\n                    let $param_name = <$param_type as Deserialize>::deserialize(member_fields);\n                    offset += <$param_type as Deserialize>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        // This will give us e.g. `a, b, c` for a struct with three fields named `a`, `b`, and `c`.\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n\n            $deserialization_of_struct_members\n\n            Self { $struct_members }\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Deserialize::deserialize(serialized) }\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Deserialize for $typ\n            $where_deserialize_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn deserialize(serialized: [Field; Self::N]) -> Self {\n                $function_body\n            }\n        }\n    }\n}\n\n/// Generates a `Packable` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Packable` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Packable for MyStruct {\n///     let N: u32 = 2;\n///\n///     fn pack(self) -> [Field; 2] {\n///         let mut result: [Field; 2] = [0_Field; 2];\n///         let mut offset: u32 = 0_u32;\n///         let packed_member: [Field; 1] = self.x.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         let packed_member: [Field; 1] = self.y.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         result\n///     }\n///\n///     fn unpack(packed: [Field; 2]) -> Self {\n///         let mut offset: u32 = 0_u32;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<AztecAddress as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let x: AztecAddress = <AztecAddress as Packable>::unpack(member_fields);\n///         offset = offset + <AztecAddress as Packable>::N;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<Field as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let y: Field = <Field as Packable>::unpack(member_fields);\n///         offset = offset + <Field as Packable>::N;\n///         Self { x: x, y: y }\n///     }\n/// }\n/// ```\npub comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Packable` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_packable_clause = get_where_trait_clause(s, quote {Packable});\n\n    // The following will give us <type_of_struct_member_1 as Packable>::N + <type_of_struct_member_2 as Packable>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Packable>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly returning the packed member,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let pack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate packing code that:\n        // 1. Packs each member\n        // 2. Copies the packed fields into the result array at the correct offset\n        // 3. Updates the offset for the next member\n        let packing_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let packed_member = $crate::traits::Packable::pack(self.$param_name);\n                    let packed_member_len = <$param_type as $crate::traits::Packable>::N;\n                    for i in 0..packed_member_len {\n                        result[i + offset] = packed_member[i];\n                    }\n                    offset += packed_member_len;\n                }\n            })\n            .join(quote {});\n\n        quote {\n            let mut result = [0; Self::N];\n            let mut offset = 0;\n\n            $packing_of_struct_members\n\n            result\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            $crate::traits::Packable::pack(self.$param_name)\n        }\n    };\n\n    // For structs containing a single member, we can enhance performance by directly unpacking the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let unpack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate unpacking code that:\n        // 1. Unpacks each member\n        // 2. Copies packed fields into member array at correct offset\n        // 3. Updates offset for next member\n        let unpacking_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as $crate::traits::Packable>::N];\n                    for i in 0..<$param_type as $crate::traits::Packable>::N {\n                        member_fields[i] = packed[i + offset];\n                    }\n                    let $param_name = <$param_type as $crate::traits::Packable>::unpack(member_fields);\n                    offset += <$param_type as $crate::traits::Packable>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n            $unpacking_of_struct_members\n            Self { $struct_members }\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Packable::unpack(packed) }\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Packable for $typ\n            $where_packable_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn pack(self) -> [Field; Self::N] {\n                $pack_function_body\n            }\n\n            #[inline_always]\n            fn unpack(packed: [Field; Self::N]) -> Self {\n                $unpack_function_body\n            }\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Packable, Serialize};\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct Smol {\n        a: Field,\n        b: Field,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct HasArray {\n        a: [Field; 2],\n        b: bool,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct Fancier {\n        a: Smol,\n        b: [Field; 2],\n        c: [u8; 3],\n        d: str<16>,\n    }\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct HasArrayWithGenerics<T, let N: u32> {\n        pub fields: [T; N],\n        pub length: u32,\n    }\n\n    #[test]\n    fn serde_on_smol() {\n        let smol = Smol { a: 1, b: 2 };\n        let serialized = smol.serialize();\n        assert(serialized == [1, 2], serialized);\n        let deserialized = Smol::deserialize(serialized);\n        assert(deserialized == smol);\n\n        // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n        let packed = smol.pack();\n        assert_eq(packed, serialized, \"Packed does not match serialized\");\n    }\n\n    #[test]\n    fn serde_on_has_array() {\n        let has_array = HasArray { a: [1, 2], b: true };\n        let serialized = has_array.serialize();\n        assert(serialized == [1, 2, 1], serialized);\n        let deserialized = HasArray::deserialize(serialized);\n        assert(deserialized == has_array);\n    }\n\n    #[test]\n    fn serde_on_fancier() {\n        let fancier =\n            Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n        let serialized = fancier.serialize();\n        assert(\n            serialized\n                == [\n                    1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                    0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n                ],\n            serialized,\n        );\n        let deserialized = Fancier::deserialize(serialized);\n        assert(deserialized == fancier);\n    }\n\n    #[test]\n    fn serde_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let serialized = struct_with_array_of_generics.serialize();\n        assert(serialized == [1, 2, 3, 3], serialized);\n        let deserialized = HasArrayWithGenerics::deserialize(serialized);\n        assert(deserialized == struct_with_array_of_generics);\n    }\n\n    #[test]\n    fn packable_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let packed = struct_with_array_of_generics.pack();\n        assert(packed == [1, 2, 3, 3], packed);\n\n        let unpacked = HasArrayWithGenerics::unpack(packed);\n        assert(unpacked == struct_with_array_of_generics);\n    }\n\n}\n"},"332":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/meta/utils.nr","source":"/// Generates serialization code for a list of parameters and the total length of the serialized array\n///\n/// # Parameters\n/// - `params`: A list of (name, type) tuples to serialize\n/// - `use_self_prefix`: If true, parameters are accessed as `self.$param_name` (for struct members).\n///                      If false, parameters are accessed directly as `$param_name` (for function parameters).\n///\n/// # Returns\n/// A tuple containing:\n/// - Quoted code that serializes the parameters into an array named `serialized_params`\n/// - Quoted code that evaluates to the total length of the serialized array\n/// - Quoted code containing the name of the serialized array\npub comptime fn derive_serialization_quotes(\n    params: [(Quoted, Type)],\n    use_self_prefix: bool,\n) -> (Quoted, Quoted, Quoted) {\n    let prefix_quote = if use_self_prefix {\n        quote { self. }\n    } else {\n        quote {}\n    };\n\n    let params_len_quote = get_params_len_quote(params);\n    let serialized_params_name = quote { serialized_params };\n\n    let body = if params.len() == 0 {\n        quote {\n            let $serialized_params_name: [Field; 0] = [];\n        }\n    } else if params.len() == 1 {\n        // When we have only a single parameter on the input, we can enhance performance by directly returning\n        // the serialized member, bypassing the need for loop-based array construction. While this optimization yields\n        // significant benefits in Brillig where the loops are expected to not be optimized, it is not relevant in ACIR\n        // where the loops are expected to be optimized away.\n\n        let param_name = params[0].0;\n        quote {\n            let $serialized_params_name = $crate::traits::Serialize::serialize($prefix_quote$param_name);\n        }\n    } else {\n        // For multiple struct members, generate serialization code that:\n        // 1. Serializes each member\n        // 2. Copies the serialized fields into the serialize array at the correct offset\n        // 3. Updates the offset for the next member\n        let serialization_of_struct_members = params\n            .map(|(param_name, param_type): (Quoted, Type)| {\n                quote {\n                let serialized_member = $crate::traits::Serialize::serialize($prefix_quote$param_name);\n                let serialized_member_len = <$param_type as $crate::traits::Serialize>::N;\n                for i in 0..serialized_member_len {\n                    $serialized_params_name[i + offset] = serialized_member[i];\n                }\n                offset += serialized_member_len;\n            }\n            })\n            .join(quote {});\n\n        quote {\n            let mut $serialized_params_name = [0; $params_len_quote];\n            let mut offset = 0;\n\n            $serialization_of_struct_members\n        }\n    };\n\n    (body, params_len_quote, serialized_params_name)\n}\n\n/// Generates a quoted expression that computes the total serialized length of function parameters.\n///\n/// # Parameters\n/// * `params` - An array of tuples where each tuple contains a quoted parameter name and its Type. The type needs\n///              to implement the Serialize trait.\n///\n/// # Returns\n/// A quoted expression that evaluates to:\n/// * `0` if there are no parameters\n/// * `(<type1 as Serialize>::N + <type2 as Serialize>::N + ...)` for one or more parameters\npub comptime fn get_params_len_quote(params: [(Quoted, Type)]) -> Quoted {\n    if params.len() == 0 {\n        quote { 0 }\n    } else {\n        let params_quote_without_parentheses = params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n                    <$param_type as $crate::traits::Serialize>::N\n                }\n            })\n            .join(quote {+});\n        quote { ($params_quote_without_parentheses) }\n    }\n}\n"},"333":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/point.nr","source":"pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl Serialize for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn serialize(self: Self) -> [Field; Self::N] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn deserialize(serialized: [Field; Self::N]) -> Self {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] != 0 }\n    }\n}\n\n// TODO(#11356): use compact representation here.\nimpl Packable for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn pack(self) -> [Field; Self::N] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; Self::N]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"},"334":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr","source":"use crate::constants::TWO_POW_64;\nuse crate::traits::{Deserialize, Serialize};\nuse std::meta::derive;\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"},"341":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr","source":"use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::{default::Default, meta::derive};\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nmod test {\n    use crate::{\n        point::POINT_LENGTH,\n        public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n        traits::{Deserialize, Serialize},\n    };\n    use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\n    #[test]\n    unconstrained fn compute_public_keys_hash() {\n        let keys = PublicKeys {\n            npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n            ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n            ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n            tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n        };\n\n        let actual = keys.hash();\n        let expected_public_keys_hash =\n            0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n        assert(actual.to_field() == expected_public_keys_hash);\n    }\n\n    #[test]\n    unconstrained fn compute_default_hash() {\n        let keys = PublicKeys::default();\n\n        let actual = keys.hash();\n        let test_data_default_hash =\n            0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n        assert(actual.to_field() == test_data_default_hash);\n    }\n\n    #[test]\n    unconstrained fn serde() {\n        let keys = PublicKeys {\n            npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n            ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n            ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n            tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n        };\n\n        // We use the PUBLIC_KEYS_LENGTH constant to ensure that there is a match between the derived trait\n        let serialized: [Field; POINT_LENGTH * 4] = keys.serialize();\n        let deserialized = PublicKeys::deserialize(serialized);\n\n        assert_eq(keys, deserialized);\n    }\n}\n"},"346":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr","source":"use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"},"362":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr","source":"use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty: Eq {\n    fn empty() -> Self;\n\n    fn is_empty(self) -> bool {\n        self.eq(Self::empty())\n    }\n\n    // Requires this Noir fix: https://github.com/noir-lang/noir/issues/9002\n    // fn assert_not_empty<let U: u32>(self, msg: str<U>) { // This msg version was failing with weird compiler errors.\n    //     // We provide a default impl but it's likely inefficient.\n    //     // The reason we include this function is because there's a lot of\n    //     // opportunity for optimisation on a per-struct basis.\n    //     // You only need to show one element is not empty to know that the whole thing\n    //     // is not empty.\n    //     // If you know an element of your struct which should always be nonempty,\n    //     // you can write an impl that solely checks that that element is nonempty.\n    //     assert(!self.is_empty(), msg);\n    // }\n\n    // This default impl is overwritten by types like arrays, because there's a much\n    // more efficient approach.\n    fn assert_empty<let S: u32>(self, msg: str<S>) {\n        assert(self.is_empty(), msg);\n    }\n}\n\nimpl Empty for Field {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u16 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\n\nimpl<T> Empty for [T]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty()]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\nimpl<A, B> Empty for (A, B)\nwhere\n    A: Empty,\n    B: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        (A::empty(), B::empty())\n    }\n}\n\nimpl<T> Empty for Option<T>\nwhere\n    T: Eq,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\n// pub fn is_empty<T>(item: T) -> bool\n// where\n//     T: Empty,\n// {\n//     item.eq(T::empty())\n// }\n\n// pub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\n// where\n//     T: Empty,\n// {\n//     array.all(|elem| is_empty(elem))\n// }\n\n// pub fn assert_empty<T>(item: T) -> ()\n// where\n//     T: Empty,\n// {\n//     assert(item.eq(T::empty()))\n// }\n\n// pub fn assert_empty_array<T, let N: u32>(array: [T; N]) -> ()\n// where\n//     T: Empty,\n// {\n//     // A cheaper option than `is_empty_array` for if you don't need to gracefully\n//     // handle a bool result.\n//     // Avoids the `&` operator of `is_empty_array`'s `.all()` call.\n//     for i in 0..N {\n//         assert(is_empty(array[i]));\n//     }\n// }\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u16 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value != 0\n    }\n}\nimpl FromField for u1 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u16 {\n    fn from_field(value: Field) -> Self {\n        value as u16\n    }\n}\nimpl FromField for u32 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Associated Constants\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize for str<N> {\n///     let N: u32 = N;\n///\n///     fn serialize(self) -> [Field; Self::N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; Self::N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize {\n    let N: u32;\n\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let M: u32> Serialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; Self::N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n/// Implementation of Deserialize for BoundedVec.\n///\n/// This implementation deserializes a BoundedVec from an array of Fields. The array contains:\n/// 1. The serialized items, each taking up T::N Fields\n/// 2. The length of the BoundedVec as the last Field\n///\n/// # Type Parameters\n/// * `T` - The type of items stored in the BoundedVec, must implement Deserialize\n/// * `M` - The maximum length of the BoundedVec\n///\n/// # Fields Array Layout\n/// [item1_field1, item1_field2, ..., item2_field1, item2_field2, ..., length]\n/// Where:\n/// - itemN_fieldM: The M-th Field of the N-th item (T::N Fields per item)\n/// - length: The number of items in the BoundedVec (1 Field)\n///\n/// Total length N = T::N * M + 1, where:\n/// - T::N is the number of Fields needed to deserialize one item\n/// - M is the maximum length of the BoundedVec\n/// - +1 is for storing the length\n///\n/// # Note\n/// Not deriving this because it's not supported to call derive_deserialize on a \"remote\" struct (and it will never\n/// be supported).\nimpl<T, let M: u32> Deserialize for BoundedVec<T, M>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut new_bounded_vec: BoundedVec<T, M> = BoundedVec::new();\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        let len = fields[<T as Deserialize>::N * M] as u32;\n\n        for i in 0..len {\n            let mut nested_fields = [0; <T as Deserialize>::N];\n            for j in 0..<T as Deserialize>::N {\n                nested_fields[j] = fields[i * <T as Deserialize>::N + j];\n            }\n\n            let item = T::deserialize(nested_fields);\n            new_bounded_vec.push(item);\n        }\n\n        new_bounded_vec\n    }\n}\n\n// This may cause issues if used as program input, because noir disallows empty arrays for program input.\n// I think this is okay because I don't foresee a unit type being used as input. But leaving this comment as a hint\n// if someone does run into this in the future.\nimpl Deserialize for () {\n    let N: u32 = 0;\n\n    fn deserialize(_fields: [Field; Self::N]) -> Self {\n        ()\n    }\n}\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl<T, let M: u32> Serialize for BoundedVec<T, M>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M + 1; // +1 for the length of the BoundedVec\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut fields = [0; Self::N];\n\n        let storage = self.storage();\n\n        for i in 0..M {\n            let serialized_item = storage[i].serialize();\n\n            for j in 0..<T as Serialize>::N {\n                fields[i * <T as Serialize>::N + j] = serialized_item[j];\n            }\n        }\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        fields[<T as Serialize>::N * M] = self.len() as Field;\n\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Associated Constants\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let M: u32> Deserialize for str<M> {\n///     let N: u32 = M;\n///\n///     #[inline_always]\n///     fn deserialize(fields: [Field; Self::N]) -> Self {\n///         str::<Self::N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize {\n    let N: u32;\n\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let M: u32> Deserialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        str::<Self::N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Associated Constants\n/// * `N` - The length of the Field array, known at compile time\n#[derive_via(derive_packable)]\npub trait Packable {\n    let N: u32;\n\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n\n#[test]\nunconstrained fn bounded_vec_serialization() {\n    // Test empty BoundedVec\n    let empty_vec: BoundedVec<Field, 3> = BoundedVec::from_array([]);\n    let serialized = empty_vec.serialize();\n    let deserialized = BoundedVec::<Field, 3>::deserialize(serialized);\n    assert_eq(empty_vec, deserialized);\n    assert_eq(deserialized.len(), 0);\n\n    // Test partially filled BoundedVec\n    let partial_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2]]);\n    let serialized = partial_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(partial_vec, deserialized);\n    assert_eq(deserialized.len(), 1);\n    assert_eq(deserialized.get(0), [1, 2]);\n\n    // Test full BoundedVec\n    let full_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2], [3, 4], [5, 6]]);\n    let serialized = full_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(full_vec, deserialized);\n    assert_eq(deserialized.len(), 3);\n    assert_eq(deserialized.get(0), [1, 2]);\n    assert_eq(deserialized.get(1), [3, 4]);\n    assert_eq(deserialized.get(2), [5, 6]);\n}\n"},"364":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr","source":"use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable for bool {\n    let N: u32 = BOOL_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> bool {\n        (fields[0] as u1) != 0\n    }\n}\n\nimpl Packable for u8 {\n    let N: u32 = U8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable for u16 {\n    let N: u32 = U16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable for u32 {\n    let N: u32 = U32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable for u64 {\n    let N: u32 = U64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable for u128 {\n    let N: u32 = U128_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable for Field {\n    let N: u32 = FIELD_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable for i8 {\n    let N: u32 = I8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Packable for i16 {\n    let N: u32 = I16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Packable for i32 {\n    let N: u32 = I32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Packable for i64 {\n    let N: u32 = I64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Packable for [T; M]\nwhere\n    T: Packable,\n{\n    let N: u32 = M * <T as Packable>::N;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized = self[i].pack();\n            for j in 0..<T as Packable>::N {\n                result[i * <T as Packable>::N + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Packable>::N, M>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"},"365":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr","source":"use crate::traits::{Deserialize, Serialize};\n\nglobal U1_SERIALIZED_LEN: u32 = 1;\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> bool {\n        fields[0] != 0\n    }\n}\n\nimpl Serialize for u1 {\n    let N: u32 = U1_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u1 {\n    let N: u32 = U1_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u1\n    }\n}\n\nimpl Serialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self]\n    }\n}\n\nimpl Deserialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n}\n\nimpl Deserialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Serialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n}\n\nimpl Deserialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Serialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n}\n\nimpl Deserialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Serialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n}\n\nimpl Deserialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Serialize for [T; M]\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M;\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; _] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized_t = self[i].serialize();\n            let T_N = serialized_t.len();\n            for j in 0..T_N {\n                result[i * T_N + j] = serialized_t[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let M: u32> Deserialize for [T; M]\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Deserialize>::N, M>(Deserialize::deserialize, result)\n    }\n}\n\nimpl<T> Serialize for Option<T>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N + 1;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n\n        result[0] = if self.is_some() { 1 } else { 0 };\n\n        let value_serialized = self.unwrap_unchecked().serialize();\n        for i in 0..<T as Serialize>::N {\n            result[1 + i] = value_serialized[i];\n        }\n\n        result\n    }\n}\n\nimpl<T> Deserialize for Option<T>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        if fields[0] == 1 {\n            let mut value_fields = [0; <T as Deserialize>::N];\n            for i in 0..<T as Deserialize>::N {\n                value_fields[i] = fields[1 + i];\n            }\n\n            Option::some(T::deserialize(value_fields))\n        } else {\n            Option::none()\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Serialize};\n\n    #[test]\n    fn u16_serialization() {\n        let a: u16 = 10;\n        assert_eq(a, u16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i8_serialization() {\n        let a: i8 = -10;\n        assert_eq(a, i8::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i16_serialization() {\n        let a: i16 = -10;\n        assert_eq(a, i16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i32_serialization() {\n        let a: i32 = -10;\n        assert_eq(a, i32::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i64_serialization() {\n        let a: i64 = -10;\n        assert_eq(a, i64::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn option_field_serialization() {\n        let opt_some = Option::some(5);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n\n    #[test]\n    fn array_serialization() {\n        let array = [1, 2, 3, 4];\n\n        let serialized: [Field; 4] = array.serialize();\n        let deserialized: [Field; 4] = Deserialize::deserialize(serialized);\n        assert_eq(deserialized, array);\n    }\n\n    #[test]\n    fn nested_array_serialization() {\n        let nested_array = [[1, 2, 3, 4], [5, 6, 7, 8]];\n\n        let serialized: [Field; 8] = nested_array.serialize();\n        let deserialized: [[Field; 4]; 2] = Deserialize::deserialize(serialized);\n\n        assert_eq(deserialized, nested_array);\n    }\n\n    #[test]\n    fn option_array_serialization() {\n        let opt_some = Option::some([2, 5]);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n}\n"},"383":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr","source":"global KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\npub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO: This currently only exists to aid point compression in compress_to_blob_commitment().\n// Once compression is part of BigCurve it can either be removed or optimized to be used elsewhere.\npub fn byte_to_bits_be(byte: u8) -> [u1; 8] {\n    let mut mut_byte = byte;\n    let mut bits: [u1; 8] = [0; 8];\n    for i in 0..8 {\n        bits[7 - i] = (mut_byte & 1) as u1;\n        mut_byte >>= 1;\n    }\n    bits\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n/// Returns Option::some(sqrt) if there is a square root, and Option::none() if there isn't.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\nunconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n\n#[test]\nunconstrained fn sqrt_valid_test() {\n    let x = 16; // examples: 16, 9, 25, 81\n    let result = sqrt(x);\n    assert(result.is_some());\n    assert_eq(result.unwrap() * result.unwrap(), x);\n}\n\n#[test]\nunconstrained fn sqrt_invalid_test() {\n    let x = KNOWN_NON_RESIDUE; // has no square root in the field\n    let result = sqrt(x);\n    assert(result.is_none());\n}\n"},"387":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_u64(&mut self) -> u64 {\n        self.read() as u64\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() != 0\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert_eq(self.offset, self.data.len(), \"Reader did not read all data\");\n    }\n}\n"},"42":{"path":"std/option.nr","source":"use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"},"422":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/uint-note/src/uint_note.nr","source":"use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    history::nullifier_inclusion::ProveNullifierInclusion,\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    messages::logs::note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{\n            GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER,\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT, PRIVATE_LOG_SIZE_IN_FIELDS,\n        },\n        hash::{compute_siloed_nullifier, poseidon2_hash_with_separator},\n        traits::{Deserialize, FromField, Hash, Packable, Serialize, ToField},\n    },\n};\n\n// UintNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the amount).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n/// A private note representing a numeric value associated to an account (e.g. a token balance).\n#[derive(Deserialize, Eq, Serialize, Packable)]\n#[custom_note]\npub struct UintNote {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintPartialNotePrivateContent, and\n    //   b) have the public field at the end\n    // Correct ordering is checked by the tests in this module.\n\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The number stored in the note.\n    value: u128,\n}\n\nimpl NoteHash for UintNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because UintNote has just one variant (where the value is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let private_content =\n            UintPartialNotePrivateContent { owner: self.owner, randomness: self.randomness };\n        let partial_note = PartialUintNote {\n            commitment: private_content.compute_partial_commitment(storage_slot),\n        };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.value)\n    }\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullification: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullification, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(\n        self,\n        note_hash_for_nullification: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullification, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: u128, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness }\n    }\n\n    pub fn get_value(self) -> u128 {\n        self.value\n    }\n\n    pub fn get_owner(self) -> AztecAddress {\n        self.owner\n    }\n\n    /// Creates a partial note that will hide the owner and storage slot but not the value, since the note will be later\n    /// completed in public. This is a powerful technique for scenarios in which the value cannot be known in private\n    /// (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// This function inserts a partial note validity commitment into the nullifier tree to be later on able to verify\n    /// that the partial note and completer are legitimate. See function docs of `compute_validity_commitment` for more\n    /// details.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` so that they can discover the\n    /// note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        completer: AztecAddress,\n    ) -> PartialUintNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = UintPartialNotePrivateContent { owner, randomness }\n            .compute_partial_commitment(storage_slot);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content =\n            UintPartialNotePrivateLogContent { owner, randomness, public_log_tag: commitment };\n\n        let encrypted_log = note::compute_partial_note_private_content_log(\n            private_log_content,\n            storage_slot,\n            recipient,\n        );\n        // Regardless of the original content size, the log is padded with random bytes up to\n        // `PRIVATE_LOG_SIZE_IN_FIELDS` to prevent leaking information about the actual size.\n        let length = encrypted_log.len();\n        context.emit_private_log(encrypted_log, length);\n\n        let partial_note = PartialUintNote { commitment };\n\n        // Now we compute the validity commitment and push it to the nullifier tree. It can be safely pushed to\n        // the nullifier tree since it uses its own separator, making collisions with actual note nullifiers\n        // practically impossible.\n        let validity_commitment = partial_note.compute_validity_commitment(completer);\n        context.push_nullifier(validity_commitment);\n\n        partial_note\n    }\n}\n\n/// The private content of a partial UintNote, i.e. the fields that will remain private. All other note fields will be\n/// made public.\n#[derive(Packable)]\nstruct UintPartialNotePrivateContent {\n    // The ordering of these fields is important given that it must match that of UintNote.\n    // Correct ordering is checked by the tests in this module.\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl UintPartialNotePrivateContent {\n    fn compute_partial_commitment(self, storage_slot: Field) -> Field {\n        // Here we commit to all private values, including the storage slot.\n        poseidon2_hash_with_separator(\n            self.pack().concat([storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\n#[derive(Packable)]\nstruct UintPartialNotePrivateLogContent {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintNote, and\n    //   b) have the public log tag at the beginning\n    // Correct ordering is checked by the tests in this module.\n    public_log_tag: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteType for UintPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        UintNote::get_id()\n    }\n}\n\n/// A partial instance of a UintNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the value field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the value to the public), resulting in a UintNote that can be used like any other one (except\n/// of course that its value is known).\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct PartialUintNote {\n    commitment: Field,\n}\n\nglobal NOTE_COMPLETION_LOG_LENGTH: u32 = 2;\n\nimpl PartialUintNote {\n    /// Completes the partial note, creating a new note that can be used like any other UintNote.\n    pub fn complete(self, context: &mut PublicContext, completer: AztecAddress, value: u128) {\n        // A note with a value of zero is valid, but we cannot currently complete a partial note with such a value\n        // because this will result in the completion log having its last field set to 0. Public logs currently do not\n        // track their length, and so trailing zeros are simply trimmed. This results in the completion log missing its\n        // last field (the value), and note discovery failing.\n        // TODO(#11636): remove this\n        assert(value != 0, \"Cannot complete a PartialUintNote with a value of 0\");\n\n        // We verify that the partial note we're completing is valid (i.e. completer is correct, it uses the correct\n        // state variable's storage slot, and it is internally consistent).\n        let validity_commitment = self.compute_validity_commitment(completer);\n        assert(\n            context.nullifier_exists(validity_commitment, context.this_address()),\n            \"Invalid partial note or completer\",\n        );\n\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the value). The contract will later find it by searching\n        //  for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(value));\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    /// Completes the partial note, creating a new note that can be used like any other UintNote. Same as `complete`\n    /// function but works from private context.\n    pub fn complete_from_private(\n        self,\n        context: &mut PrivateContext,\n        completer: AztecAddress,\n        value: u128,\n    ) {\n        // We verify that the partial note we're completing is valid (i.e. completer is correct, it uses the correct\n        // state variable's storage slot, and it is internally consistent).\n        let validity_commitment = self.compute_validity_commitment(completer);\n        // `prove_nullifier_inclusion` function expects the nullifier to be siloed (hashed with the address of\n        // the contract that emitted the nullifier) as it checks the value directly against the nullifier tree and all\n        // the nullifiers in the tree are siloed by the protocol.\n        let siloed_validity_commitment =\n            compute_siloed_nullifier(context.this_address(), validity_commitment);\n        context.get_anchor_block_header().prove_nullifier_inclusion(siloed_validity_commitment);\n\n        // We need to do two things:\n        //  - emit an unencrypted log containing the public fields (the value) via the private log channel. The\n        //  contract will later find it by searching for the expected tag (which is simply the partial note\n        //  commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_private_log(\n            self.compute_note_completion_log_padded_for_private_log(value),\n            NOTE_COMPLETION_LOG_LENGTH,\n        );\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    /// Computes a validity commitment for this partial note. The commitment cryptographically binds the note's private\n    /// data with the designated completer address. When the note is later completed in public execution, we can load\n    /// this commitment from the nullifier tree and verify that both the partial note (e.g. that the storage slot\n    /// corresponds to the correct owner, and that we're using the correct state variable) and completer are\n    /// legitimate.\n    pub fn compute_validity_commitment(self, completer: AztecAddress) -> Field {\n        poseidon2_hash_with_separator(\n            [self.commitment, completer.to_field()],\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT,\n        )\n    }\n\n    fn compute_note_completion_log(self, value: u128) -> [Field; NOTE_COMPLETION_LOG_LENGTH] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, value.to_field()]\n    }\n\n    fn compute_note_completion_log_padded_for_private_log(\n        self,\n        value: u128,\n    ) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS] {\n        let note_completion_log = self.compute_note_completion_log(value);\n        let padding = [0; PRIVATE_LOG_SIZE_IN_FIELDS - NOTE_COMPLETION_LOG_LENGTH];\n        note_completion_log.concat(padding)\n    }\n\n    fn compute_complete_note_hash(self, value: u128) -> Field {\n        // Here we finalize the note hash by including the (public) value into the partial note commitment. Note that we\n        // use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator(\n            [self.commitment, value.to_field()],\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\nimpl ToField for PartialUintNote {\n    fn to_field(self) -> Field {\n        self.commitment\n    }\n}\n\nimpl FromField for PartialUintNote {\n    fn from_field(field: Field) -> Self {\n        Self { commitment: field }\n    }\n}\n\nmod test {\n    use super::{\n        PartialUintNote, UintNote, UintPartialNotePrivateContent, UintPartialNotePrivateLogContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{address::AztecAddress, traits::{Deserialize, FromField, Packable}},\n        utils::array::subarray,\n    };\n\n    global value: u128 = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a UintNote has the same note hash as a PartialUintNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n\n        let note = UintNote { value, randomness, owner };\n        let note_hash = note.compute_note_hash(storage_slot);\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n\n        let partial_note = PartialUintNote {\n            commitment: partial_note_private_content.compute_partial_commitment(storage_slot),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(value);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular UintNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular UintNote.\n\n        let note = UintNote { value, randomness, owner };\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n        let commitment = partial_note_private_content.compute_partial_commitment(storage_slot);\n\n        let private_log_content =\n            UintPartialNotePrivateLogContent { owner, randomness, public_log_tag: commitment };\n        // The following is a misuse of the `deserialize` function, but this is just a test and it's better than\n        // letting devs manually construct it when they shouldn't be able to.\n        let partial_note = PartialUintNote::deserialize([commitment]);\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(value)[0],\n        );\n\n        // Then we extract all fields except the first of both logs (i.e. the public log tag), and combine them to\n        // produce the note's packed representation. This requires that the members of the intermediate structs are in\n        // the same order as in UintNote.\n        let private_log_without_public_tag: [_; 2] = subarray(private_log_content.pack(), 1);\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(value), 1);\n\n        assert_eq(private_log_without_public_tag.concat(public_log_without_tag), note.pack());\n    }\n}\n"},"43":{"path":"std/panic.nr","source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"},"46":{"path":"std/slice.nr","source":"use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice with its index, returning a\n    // new slice containing the mapped elements.\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U] {\n        let mut ret = &[];\n        let mut index = 0;\n        for elem in self {\n            ret = ret.push_back(f(index, elem));\n            index += 1;\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for elem in self {\n            f(elem);\n        }\n    }\n\n    // Apply a function to each element of the slice with its index\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        let mut index = 0;\n        for elem in self {\n            f(index, elem);\n            index += 1;\n        }\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq(&[].map(|x| x + 1), &[]);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq(&[].mapi(|i, x| i * x + 1), &[]);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_each(|_x| assert(false));\n        assert(empty_slice == &[]);\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_eachi(|_i, _x| assert(false));\n        assert(empty_slice == &[]);\n    }\n\n    #[test]\n    fn map_example() {\n        let a = &[1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, &[2, 4, 6]);\n        assert_eq(a, &[1, 2, 3]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = &[1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, &[2, 5, 8]);\n        assert_eq(a, &[1, 2, 3]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_each(|a| { *b_ref = b_ref.push_back(a * 2); });\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { *b_ref = b_ref.push_back(i + a * 2); });\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n    #[test]\n    fn len_empty() {\n        let empty: [Field] = &[];\n        assert_eq(empty.len(), 0);\n    }\n\n    #[test]\n    fn len_single() {\n        assert_eq(&[42].len(), 1);\n    }\n\n    #[test]\n    fn len_multiple() {\n        assert_eq(&[1, 2, 3, 4, 5].len(), 5);\n    }\n\n    #[test]\n    fn push_back_empty() {\n        let empty: [Field] = &[];\n        let result = empty.push_back(42);\n        assert_eq(result.len(), 1);\n        assert_eq(result[0], 42);\n    }\n\n    #[test]\n    fn push_back_non_empty() {\n        let slice = &[1, 2, 3];\n        let result = slice.push_back(4);\n        assert_eq(result.len(), 4);\n        assert_eq(result, &[1, 2, 3, 4]);\n    }\n\n    #[test]\n    fn push_front_empty() {\n        let empty = &[];\n        let result = empty.push_front(42);\n        assert_eq(result.len(), 1);\n        assert_eq(result[0], 42);\n    }\n\n    #[test]\n    fn push_front_non_empty() {\n        let slice = &[1, 2, 3];\n        let result = slice.push_front(0);\n        assert_eq(result.len(), 4);\n        assert_eq(result, &[0, 1, 2, 3]);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds\")]\n    fn pop_back_empty() {\n        let slice: [Field] = &[];\n        let (_, _) = slice.pop_back();\n    }\n\n    #[test]\n    fn pop_back_one() {\n        let slice = &[42];\n        let (result, elem) = slice.pop_back();\n        assert_eq(result.len(), 0);\n        assert_eq(elem, 42);\n    }\n\n    #[test]\n    fn pop_back_multiple() {\n        let slice = &[1, 2, 3];\n        let (result, elem) = slice.pop_back();\n        assert_eq(result.len(), 2);\n        assert_eq(result, &[1, 2]);\n        assert_eq(elem, 3);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds\")]\n    fn pop_front_empty() {\n        let slice: [Field] = &[];\n        let (_, _) = slice.pop_front();\n    }\n\n    #[test]\n    fn pop_front_one() {\n        let slice = &[42];\n        let (elem, result) = slice.pop_front();\n        assert_eq(result.len(), 0);\n        assert_eq(elem, 42);\n    }\n\n    #[test]\n    fn pop_front_multiple() {\n        let slice = &[1, 2, 3];\n        let (elem, result) = slice.pop_front();\n        assert_eq(result.len(), 2);\n        assert_eq(result, &[2, 3]);\n        assert_eq(elem, 1);\n    }\n\n    #[test]\n    fn insert_beginning() {\n        let slice = &[1, 2, 3];\n        let result = slice.insert(0, 0);\n        assert_eq(result.len(), 4);\n        assert_eq(result, &[0, 1, 2, 3]);\n    }\n\n    #[test]\n    fn insert_middle() {\n        let slice = &[1, 2, 3];\n        let result = slice.insert(1, 99);\n        assert_eq(result.len(), 4);\n        assert_eq(result, &[1, 99, 2, 3]);\n    }\n\n    #[test]\n    fn insert_end() {\n        let slice = &[1, 2, 3];\n        let result = slice.insert(3, 4);\n        assert_eq(result.len(), 4);\n        assert_eq(result, &[1, 2, 3, 4]);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds\")]\n    fn insert_end_out_of_bounds() {\n        let slice = &[1, 2];\n        let _ = slice.insert(3, 4);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds\")]\n    fn remove_empty() {\n        let slice: [Field] = &[];\n        let (_, _) = slice.remove(0);\n    }\n\n    #[test]\n    fn remove_beginning() {\n        let slice = &[1, 2, 3];\n        let (result, elem) = slice.remove(0);\n        assert_eq(result.len(), 2);\n        assert_eq(result, &[2, 3]);\n        assert_eq(elem, 1);\n    }\n\n    #[test]\n    fn remove_middle() {\n        let slice = &[1, 2, 3];\n        let (result, elem) = slice.remove(1);\n        assert_eq(result.len(), 2);\n        assert_eq(result, &[1, 3]);\n        assert_eq(elem, 2);\n    }\n\n    #[test]\n    fn remove_end() {\n        let slice = &[1, 2, 3];\n        let (result, elem) = slice.remove(2);\n        assert_eq(result.len(), 2);\n        assert_eq(result, &[1, 2]);\n        assert_eq(elem, 3);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds\")]\n    fn remove_end_out_of_bounds() {\n        let slice = &[1, 2];\n        let (_, _) = slice.remove(2);\n    }\n\n    #[test]\n    fn fold_empty() {\n        let empty = &[];\n        let result = empty.fold(10, |acc, x| acc + x);\n        assert_eq(result, 10);\n    }\n\n    #[test]\n    fn fold_single() {\n        let slice = &[5];\n        let result = slice.fold(10, |acc, x| acc + x);\n        assert_eq(result, 15);\n    }\n\n    #[test]\n    fn fold_multiple() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.fold(0, |acc, x| acc + x);\n        assert_eq(result, 10);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds\")]\n    fn reduce_empty() {\n        let empty: [Field] = &[];\n        let _ = empty.reduce(|a, b| a + b);\n    }\n\n    #[test]\n    fn reduce_single() {\n        let slice = &[42];\n        let result = slice.reduce(|a, b| a + b);\n        assert_eq(result, 42);\n    }\n\n    #[test]\n    fn reduce_multiple() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.reduce(|a, b| a + b);\n        assert_eq(result, 10);\n    }\n\n    #[test]\n    fn filter_empty() {\n        let empty = &[];\n        let result = empty.filter(|x| x > 0);\n        assert_eq(result.len(), 0);\n    }\n\n    #[test]\n    fn filter_all_true() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.filter(|x| x > 0);\n        assert_eq(result, slice);\n    }\n\n    #[test]\n    fn filter_all_false() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.filter(|x| x > 10);\n        assert_eq(result.len(), 0);\n    }\n\n    #[test]\n    fn filter_some() {\n        let slice = &[1, 2, 3, 4, 5];\n        let result = slice.filter(|x| x % 2 == 0);\n        assert_eq(result, &[2, 4]);\n    }\n\n    #[test]\n    fn all_empty() {\n        let empty = &[];\n        let result = empty.all(|x| x > 0);\n        assert_eq(result, true);\n    }\n\n    #[test]\n    fn all_true() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.all(|x| x > 0);\n        assert_eq(result, true);\n    }\n\n    #[test]\n    fn all_false() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.all(|x| x > 2);\n        assert_eq(result, false);\n    }\n\n    #[test]\n    fn any_empty() {\n        let empty = &[];\n        let result = empty.any(|x| x > 0);\n        assert_eq(result, false);\n    }\n\n    #[test]\n    fn any_true() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.any(|x| x > 3);\n        assert_eq(result, true);\n    }\n\n    #[test]\n    fn any_false() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.any(|x| x > 10);\n        assert_eq(result, false);\n    }\n\n    // utility method tests\n    #[test]\n    fn append_empty_to_empty() {\n        let empty1: [Field] = &[];\n        let empty2: [Field] = &[];\n        let result = empty1.append(empty2);\n        assert_eq(result.len(), 0);\n    }\n\n    #[test]\n    fn append_empty_to_non_empty() {\n        let slice = &[1, 2, 3];\n        let empty = &[];\n        let result = slice.append(empty);\n        assert_eq(result, slice);\n    }\n\n    #[test]\n    fn append_non_empty_to_empty() {\n        let empty = &[];\n        let slice = &[1, 2, 3];\n        let result = empty.append(slice);\n        assert_eq(result, slice);\n    }\n\n    #[test]\n    fn append_two_non_empty() {\n        let slice1 = &[1, 2];\n        let slice2 = &[3, 4, 5];\n        let result = slice1.append(slice2);\n        assert_eq(result, &[1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    fn as_array_single() {\n        let slice = &[42];\n        let array: [Field; 1] = slice.as_array();\n        assert_eq(array[0], 42);\n    }\n\n    #[test]\n    fn as_array_multiple() {\n        let slice = &[1, 2, 3];\n        let array: [Field; 3] = slice.as_array();\n        assert_eq(array[0], 1);\n        assert_eq(array[1], 2);\n        assert_eq(array[2], 3);\n    }\n\n    // complex scenarios\n    #[test]\n    fn chain_operations() {\n        let slice = &[1, 2, 3, 4, 5];\n        let result = slice.filter(|x| x % 2 == 0).map(|x| x * 2).fold(0, |acc, x| acc + x);\n        assert_eq(result, 12); // (2*2) + (4*2) = 4 + 8 = 12\n    }\n\n    #[test]\n    fn nested_operations() {\n        let slice = &[1, 2, 3, 4];\n        let filtered = slice.filter(|x| x > 1);\n        let mapped = filtered.map(|x| x * x);\n        let sum = mapped.fold(0, |acc, x| acc + x);\n        assert_eq(sum, 29); // 2^2 + 3^2 + 4^2 = 4 + 9 + 16 = 29\n    }\n\n    #[test]\n    fn single_element_operations() {\n        let single = &[42];\n\n        // Test all operations on single element\n        assert_eq(single.len(), 1);\n\n        let pushed_back = single.push_back(99);\n        assert_eq(pushed_back, &[42, 99]);\n\n        let pushed_front = single.push_front(0);\n        assert_eq(pushed_front, &[0, 42]);\n\n        let (popped_back_slice, popped_back_elem) = single.pop_back();\n        assert_eq(popped_back_slice.len(), 0);\n        assert_eq(popped_back_elem, 42);\n\n        let (popped_front_elem, popped_front_slice) = single.pop_front();\n        assert_eq(popped_front_slice.len(), 0);\n        assert_eq(popped_front_elem, 42);\n\n        let inserted = single.insert(0, 0);\n        assert_eq(inserted, &[0, 42]);\n\n        let (removed_slice, removed_elem) = single.remove(0);\n        assert_eq(removed_slice.len(), 0);\n        assert_eq(removed_elem, 42);\n    }\n\n    #[test]\n    fn boundary_conditions() {\n        let slice = &[1, 2, 3];\n\n        // insert at boundaries\n        let at_start = slice.insert(0, 0);\n        assert_eq(at_start, &[0, 1, 2, 3]);\n\n        let at_end = slice.insert(3, 4);\n        assert_eq(at_end, &[1, 2, 3, 4]);\n\n        // remove at boundaries\n        let (removed_start, elem_start) = slice.remove(0);\n        assert_eq(removed_start, &[2, 3]);\n        assert_eq(elem_start, 1);\n\n        let (removed_end, elem_end) = slice.remove(2);\n        assert_eq(removed_end, &[1, 2]);\n        assert_eq(elem_end, 3);\n    }\n\n    #[test]\n    fn complex_predicates() {\n        let slice = &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\n        let even_greater_than_5 = slice.filter(|x| (x % 2 == 0) & (x > 5));\n        assert_eq(even_greater_than_5, &[6, 8, 10]);\n\n        let all_positive_and_less_than_20 = slice.all(|x| (x > 0) & (x < 20));\n        assert_eq(all_positive_and_less_than_20, true);\n\n        let any_divisible_by_7 = slice.any(|x| x % 7 == 0);\n        assert_eq(any_divisible_by_7, true);\n    }\n\n    #[test]\n    fn identity_operations() {\n        let slice = &[1, 2, 3, 4, 5];\n\n        let mapped_identity = slice.map(|x| x);\n        assert_eq(mapped_identity, slice);\n\n        let filtered_all = slice.filter(|_| true);\n        assert_eq(filtered_all, slice);\n\n        let filtered_none = slice.filter(|_| false);\n        assert_eq(filtered_none.len(), 0);\n    }\n\n    #[test(should_fail)]\n    fn as_array_size_mismatch() {\n        let slice = &[1, 2, 3];\n        let _: [Field; 5] = slice.as_array(); // size doesn't match\n    }\n}\n"},"5":{"path":"std/cmp.nr","source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        if result {\n            for i in 0..self.len() {\n                result &= self[i].eq(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let self_len = self.len();\n        let other_len = other.len();\n        let min_len = if self_len < other_len {\n            self_len\n        } else {\n            other_len\n        };\n\n        let mut result = Ordering::equal();\n        for i in 0..min_len {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self_len.cmp(other_len)\n        }\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use super::{Eq, max, min, Ord};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n\n    #[test]\n    fn correctly_handles_unequal_length_slices() {\n        let slice_1 = &[0, 1, 2, 3];\n        let slice_2 = &[0, 1, 2];\n        assert(!slice_1.eq(slice_2));\n    }\n\n    #[test]\n    fn lexicographic_ordering_for_slices() {\n        assert(&[2_u32].cmp(&[1_u32, 1_u32, 1_u32]) == super::Ordering::greater());\n        assert(&[1_u32, 2_u32].cmp(&[1_u32, 2_u32, 3_u32]) == super::Ordering::less());\n    }\n}\n"},"50":{"path":"/home/jpag/Playground/aztec/crosschain/wormhole-demo/packages/aztec/contracts/message_bridge/src/main.nr","source":"use aztec::macros::aztec;\n\npub mod types;\npub mod utils;\n\n#[aztec]\npub contract MessageBridge {\n    use aztec::{\n        macros::{\n            functions::{initializer, external},\n            storage::storage,\n        },\n        protocol_types::{\n            address::AztecAddress,\n        },\n        state_vars::{map::Map, public_mutable::PublicMutable, public_immutable::PublicImmutable},\n    };\n    use crate::types::{Config, RegisteredEmitter};\n    use crate::utils::{encode_message_payload, address_to_bytes32};\n    use wormhole::Wormhole;\n\n    // ============================================================================\n    // STORAGE\n    // ============================================================================\n\n    #[storage]\n    struct Storage<Context> {\n        // Core configuration (immutable after deployment)\n        config: PublicImmutable<Config, Context>,\n\n        // Owner/admin address\n        owner: PublicMutable<AztecAddress, Context>,\n\n        // Registered emitters: chain_id => RegisteredEmitter\n        // Maps remote chain IDs to their trusted bridge contract addresses\n        registered_emitters: Map<Field, PublicMutable<RegisteredEmitter, Context>, Context>,\n\n        // Processed VAAs for replay protection: vaa_hash => processed\n        processed_vaas: Map<Field, PublicMutable<bool, Context>, Context>,\n\n        // Message fee for Wormhole (in wei)\n        message_fee: PublicMutable<u128, Context>,\n\n        // Last received message data (for testing/verification)\n        last_received_value: PublicMutable<u8, Context>,\n        last_received_from_chain: PublicMutable<u16, Context>,\n        last_received_sender: PublicMutable<Field, Context>,\n    }\n\n    // ============================================================================\n    // INITIALIZATION\n    // ============================================================================\n\n    #[external(\"public\")]\n    #[initializer]\n    fn constructor(\n        wormhole_address: AztecAddress,\n        chain_id: u16,\n        owner: AztecAddress,\n        message_fee: u128,\n    ) {\n        storage.config.initialize(Config::new(\n            wormhole_address,\n            chain_id,\n        ));\n        storage.owner.write(owner);\n        storage.message_fee.write(message_fee);\n\n        // Initialize last received values to zero\n        storage.last_received_value.write(0);\n        storage.last_received_from_chain.write(0);\n        storage.last_received_sender.write(0);\n    }\n\n    // ============================================================================\n    // ADMIN FUNCTIONS\n    // ============================================================================\n\n    #[external(\"public\")]\n    fn register_emitter(\n        chain_id: u16,\n        emitter_address: [u8; 32],\n    ) {\n        let owner = storage.owner.read();\n        assert(owner.eq(context.msg_sender().unwrap()), \"Caller is not owner\");\n\n        let key = chain_id as Field;\n        storage.registered_emitters.at(key).write(RegisteredEmitter::new(emitter_address, true));\n    }\n\n    #[external(\"public\")]\n    fn set_message_fee(fee: u128) {\n        let owner = storage.owner.read();\n        assert(owner.eq(context.msg_sender().unwrap()), \"Caller is not owner\");\n        storage.message_fee.write(fee);\n    }\n\n    #[external(\"public\")]\n    fn transfer_ownership(new_owner: AztecAddress) {\n        let owner = storage.owner.read();\n        assert(owner.eq(context.msg_sender().unwrap()), \"Caller is not owner\");\n        storage.owner.write(new_owner);\n    }\n\n    // ============================================================================\n    // SEND MESSAGE (Aztec -> EVM)\n    // ============================================================================\n\n    #[external(\"public\")]\n    fn send_value(\n        destination_chain_id: u16,\n        value: u8,\n        fee_nonce: Field,\n    ) {\n        let config = storage.config.read();\n        let message_fee = storage.message_fee.read();\n        let sender = context.msg_sender().unwrap();\n\n        // Validate value is in range (1-256, where 0 represents 256)\n        // Note: u8 naturally enforces 0-255, we'll treat 0 as 256\n\n        // Encode the message payload\n        let wormhole_payload = encode_message_payload(\n            address_to_bytes32(sender),\n            value,\n            config.chain_id,\n            destination_chain_id,\n        );\n\n        // Publish message through Wormhole\n        let _ = Wormhole::at(config.wormhole_address).publish_message_in_public(\n            0, // nonce\n            wormhole_payload,\n            message_fee,\n            1, // consistency level (1 = confirmed)\n            sender,\n            fee_nonce,\n        ).call(&mut context);\n    }\n\n    // ============================================================================\n    // RECEIVE MESSAGE (EVM -> Aztec)\n    // ============================================================================\n\n    #[external(\"public\")]\n    fn receive_value(\n        source_chain_id: u16,\n        sender: Field,\n        value: u8,\n    ) {\n        // 1. Verify emitter is registered for source chain\n        let emitter_key = source_chain_id as Field;\n        let registered_emitter = storage.registered_emitters.at(emitter_key).read();\n        assert(registered_emitter.enabled, \"Emitter not registered\");\n\n        // 2. Check replay protection using hash of message parameters\n        // We create a unique hash from the source chain, sender, and value\n        let vaa_hash = _compute_vaa_hash(\n            source_chain_id,\n            sender,\n            value as Field,\n        );\n        let already_processed = storage.processed_vaas.at(vaa_hash).read();\n        assert(!already_processed, \"VAA already processed\");\n        storage.processed_vaas.at(vaa_hash).write(true);\n\n        // 3. Store the received message\n        storage.last_received_value.write(value);\n        storage.last_received_from_chain.write(source_chain_id);\n        storage.last_received_sender.write(sender);\n    }\n\n    // ============================================================================\n    // VIEW FUNCTIONS\n    // ============================================================================\n\n    #[external(\"utility\")]\n    unconstrained fn get_config() -> pub Config {\n        storage.config.read()\n    }\n\n    #[external(\"utility\")]\n    unconstrained fn get_owner() -> pub AztecAddress {\n        storage.owner.read()\n    }\n\n    #[external(\"utility\")]\n    unconstrained fn get_registered_emitter(chain_id: u16) -> pub RegisteredEmitter {\n        let key = chain_id as Field;\n        storage.registered_emitters.at(key).read()\n    }\n\n    #[external(\"utility\")]\n    unconstrained fn get_message_fee() -> pub u128 {\n        storage.message_fee.read()\n    }\n\n    #[external(\"utility\")]\n    unconstrained fn get_last_value() -> pub u8 {\n        storage.last_received_value.read()\n    }\n\n    #[external(\"utility\")]\n    unconstrained fn get_last_from_chain() -> pub u16 {\n        storage.last_received_from_chain.read()\n    }\n\n    #[external(\"utility\")]\n    unconstrained fn get_last_sender() -> pub Field {\n        storage.last_received_sender.read()\n    }\n\n    #[external(\"utility\")]\n    unconstrained fn is_vaa_processed(\n        source_chain_id: u16,\n        sender: Field,\n        value: Field,\n    ) -> pub bool {\n        let vaa_hash = _compute_vaa_hash(source_chain_id, sender, value);\n        storage.processed_vaas.at(vaa_hash).read()\n    }\n\n    // ============================================================================\n    // INTERNAL FUNCTIONS\n    // ============================================================================\n\n    #[contract_library_method]\n    fn _compute_vaa_hash(\n        source_chain_id: u16,\n        sender: Field,\n        value: Field,\n    ) -> Field {\n        let chain_id_field = source_chain_id as Field;\n        let hash = chain_id_field * 1000000000 + sender * 1000 + value;\n        hash\n    }\n}\n"},"52":{"path":"/home/jpag/Playground/aztec/crosschain/wormhole-demo/packages/aztec/contracts/message_bridge/src/utils.nr","source":"use aztec::protocol_types::traits::ToField;\nuse aztec::protocol_types::address::AztecAddress;\n\n/// Payload ID for simple value messages (distinct from token bridge payloads)\npub global PAYLOAD_ID_MESSAGE: u8 = 99;\n\n/// Encode message payload into Wormhole message format\n///\n/// Payload format (38 bytes):\n/// - Byte 0:      Payload ID (99)\n/// - Bytes 1-32:  Sender address (32 bytes)\n/// - Byte 33:     Value (1 byte, 1-256 where 0 = 256)\n/// - Bytes 34-35: Source chain ID (2 bytes, big-endian)\n/// - Bytes 36-37: Destination chain ID (2 bytes, big-endian)\n///\n/// Returns [[u8; 31]; 8] for Wormhole publish_message (248 bytes total)\npub fn encode_message_payload(\n    sender: [u8; 32],\n    value: u8,\n    source_chain_id: u16,\n    destination_chain_id: u16,\n) -> [[u8; 31]; 8] {\n    // Create the 38-byte payload\n    let mut payload: [u8; 38] = [0; 38];\n\n    // Byte 0: payload ID\n    payload[0] = PAYLOAD_ID_MESSAGE;\n\n    // Bytes 1-32: sender address (32 bytes)\n    for i in 0..32 {\n        payload[1 + i] = sender[i];\n    }\n\n    // Byte 33: value\n    payload[33] = value;\n\n    // Bytes 34-35: source chain ID (2 bytes, big-endian)\n    payload[34] = (source_chain_id >> 8) as u8;\n    payload[35] = source_chain_id as u8;\n\n    // Bytes 36-37: destination chain ID (2 bytes, big-endian)\n    payload[36] = (destination_chain_id >> 8) as u8;\n    payload[37] = destination_chain_id as u8;\n\n    // Pack into Wormhole format: [[u8; 31]; 8] = 248 bytes total\n    // Wormhole expects data in chunks of 31 bytes\n    let mut wormhole_payload: [[u8; 31]; 8] = [[0; 31]; 8];\n\n    for slot in 0..8 {\n        for byte_idx in 0..31 {\n            let payload_idx = slot * 31 + byte_idx;\n            if payload_idx < 38 {\n                wormhole_payload[slot][byte_idx] = payload[payload_idx];\n            }\n        }\n    }\n\n    wormhole_payload\n}\n\npub fn address_to_bytes32(addr: AztecAddress) -> [u8; 32] {\n    addr.to_field().to_be_bytes()\n}\n"},"6":{"path":"std/collections/bounded_vec.nr","source":"use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0, \"cannot pop from an empty vector\");\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            let _ = vec.get(0);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_beyond_length() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            let _ = vec.get(3);\n        }\n\n        #[test]\n        fn get_works_within_bounds() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(2), 3);\n            assert_eq(vec.get(4), 5);\n        }\n\n        #[test]\n        fn get_unchecked_works() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(0), 1);\n            assert_eq(vec.get_unchecked(2), 3);\n        }\n\n        #[test]\n        fn get_unchecked_works_past_len() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(4), 0);\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_setting_beyond_length() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            vec.set(3, 4);\n        }\n\n        #[test]\n        fn set_unchecked_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(0, 10);\n            assert_eq(vec.get(0), 10);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn set_unchecked_operations_past_len() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(3, 40);\n            assert_eq(vec.get(3), 40);\n        }\n\n        #[test]\n        fn set_preserves_other_elements() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            vec.set(2, 30);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 30);\n            assert_eq(vec.get(3), 4);\n            assert_eq(vec.get(4), 5);\n        }\n    }\n\n    mod any {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn returns_false_if_predicate_not_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, false, false]);\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn returns_true_if_predicate_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, true, true]);\n            let result = vec.any(|value| value);\n\n            assert(result);\n        }\n\n        #[test]\n        fn returns_false_on_empty_boundedvec() {\n            let vec: BoundedVec<bool, 0> = BoundedVec::new();\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn any_with_complex_predicates() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            assert(vec.any(|x| x > 3));\n            assert(!vec.any(|x| x > 10));\n            assert(vec.any(|x| x % 2 == 0)); // has a even number\n            assert(vec.any(|x| x == 3)); // has a specific value\n        }\n\n        #[test]\n        fn any_with_partial_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            assert(vec.any(|x| x == 1));\n            assert(vec.any(|x| x == 2));\n            assert(!vec.any(|x| x == 3));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn map_with_conditional_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.map(|x| if x % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([1, 4, 3, 8]);\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn map_preserves_length() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|x| x * 2);\n\n            assert_eq(result.len(), vec.len());\n            assert_eq(result.max_len(), vec.max_len());\n        }\n\n        #[test]\n        fn map_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let result = vec.map(|x| x * 2);\n            assert_eq(result, vec);\n            assert_eq(result.len(), 0);\n            assert_eq(result.max_len(), 5);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn mapi_with_index_branching_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.mapi(|i, x| if i % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([2, 2, 6, 4]);\n            assert_eq(result, expected);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_each_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_each(|_| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_each_with_side_effects() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let mut seen = BoundedVec::<u32, 3>::new();\n            let seen_ref = &mut seen;\n            vec.for_each(|x| seen_ref.push(x));\n            assert_eq(seen, vec);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_eachi_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_eachi(|_, _| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_eachi_with_index_tracking() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([10, 20, 30]);\n            let mut indices = BoundedVec::<u32, 3>::new();\n            let indices_ref = &mut indices;\n            vec.for_eachi(|i, _| indices_ref.push(i));\n\n            let expected = BoundedVec::from_array([0, 1, 2]);\n            assert_eq(indices, expected);\n        }\n\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n\n        #[test]\n        fn from_array_preserves_order() {\n            let array = [5, 3, 1, 4, 2];\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array(array);\n            for i in 0..array.len() {\n                assert_eq(vec.get(i), array[i]);\n            }\n        }\n\n        #[test]\n        fn from_array_with_different_types() {\n            let bool_array = [true, false, true];\n            let bool_vec: BoundedVec<bool, 3> = BoundedVec::from_array(bool_array);\n            assert_eq(bool_vec.len(), 3);\n            assert_eq(bool_vec.get(0), true);\n            assert_eq(bool_vec.get(1), false);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n\n    mod push_pop {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn push_and_pop_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            assert_eq(vec.len(), 0);\n\n            vec.push(1);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 1);\n\n            vec.push(2);\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.get(1), 2);\n\n            let popped = vec.pop();\n            assert_eq(popped, 2);\n            assert_eq(vec.len(), 1);\n\n            let popped2 = vec.pop();\n            assert_eq(popped2, 1);\n            assert_eq(vec.len(), 0);\n        }\n\n        #[test(should_fail_with = \"push out of bounds\")]\n        fn push_to_full_vector() {\n            let mut vec: BoundedVec<u32, 2> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n            vec.push(3); // should panic\n        }\n\n        #[test(should_fail_with = \"cannot pop from an empty vector\")]\n        fn pop_from_empty_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let _ = vec.pop(); // should panic\n        }\n\n        #[test]\n        fn push_pop_cycle() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n\n            // push to full\n            vec.push(1);\n            vec.push(2);\n            vec.push(3);\n            assert_eq(vec.len(), 3);\n\n            // pop all\n            assert_eq(vec.pop(), 3);\n            assert_eq(vec.pop(), 2);\n            assert_eq(vec.pop(), 1);\n            assert_eq(vec.len(), 0);\n\n            // push again\n            vec.push(4);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 4);\n        }\n    }\n\n    mod extend {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn extend_from_array() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_slice() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_bounded_vec() {\n            let mut vec1: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut vec2: BoundedVec<u32, 3> = BoundedVec::new();\n\n            vec1.push(1);\n            vec2.push(2);\n            vec2.push(3);\n\n            vec1.extend_from_bounded_vec(vec2);\n\n            assert_eq(vec1.len(), 3);\n            assert_eq(vec1.get(0), 1);\n            assert_eq(vec1.get(1), 2);\n            assert_eq(vec1.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"extend_from_array out of bounds\")]\n        fn extend_array_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3, 4]); // should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_slice out of bounds\")]\n        fn extend_slice_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3, 4]); // S]should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_bounded_vec out of bounds\")]\n        fn extend_bounded_vec_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            let other: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            vec.extend_from_bounded_vec(other); // should panic\n        }\n\n        #[test]\n        fn extend_with_empty_collections() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let original_len = vec.len();\n\n            vec.extend_from_array([]);\n            assert_eq(vec.len(), original_len);\n\n            vec.extend_from_slice(&[]);\n            assert_eq(vec.len(), original_len);\n\n            let empty: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.extend_from_bounded_vec(empty);\n            assert_eq(vec.len(), original_len);\n        }\n    }\n\n    mod storage {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn storage_consistency() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            // test initial storage state\n            assert_eq(vec.storage(), [0, 0, 0, 0, 0]);\n\n            vec.push(1);\n            vec.push(2);\n\n            // test storage after modifications\n            assert_eq(vec.storage(), [1, 2, 0, 0, 0]);\n\n            // storage doesn't change length\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.max_len(), 5);\n        }\n\n        #[test]\n        fn storage_after_pop() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n\n            let _ = vec.pop();\n            // after pop, the last element should be zeroed\n            assert_eq(vec.storage(), [1, 2, 0]);\n            assert_eq(vec.len(), 2);\n        }\n\n        #[test]\n        fn vector_immutable() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let storage = vec.storage();\n\n            assert_eq(storage, [1, 2, 3]);\n\n            // Verify that the original vector is unchanged\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n    }\n}\n"},"61":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/capsules/mod.nr","source":"use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push(self, value: T)\n    where\n        T: Serialize,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get(self, index: u32) -> T\n    where\n        T: Deserialize,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n\n    global SLOT: Field = 1230;\n\n    #[test]\n    unconstrained fn empty_array() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            let _: Field = array.get(0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            assert_eq(array.len(), 1);\n            assert_eq(array.get(0), 5);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            let _ = array.get(1);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(5);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            assert_eq(array.len(), 3);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 8);\n            assert_eq(array.get(2), 9);\n\n            array.remove(1);\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 9);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            array.remove(1);\n            array.remove(1);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n            // we do not care about the order in which each tuple was passed to the closure.\n            let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n            array.for_each(|index, value| { called_with.push((index, value)); });\n\n            assert_eq(called_with.len(), 3);\n            assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n            assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n            assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| {\n                if index == 1 {\n                    array.remove(index);\n                }\n            });\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 4);\n            assert_eq(array.get(1), 6);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all_no_copy() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We test that the utilityCopyCapsule was never called, which is the expensive operation we want to avoid.\n            let mock = std::test::OracleMock::mock(\"utilityCopyCapsule\");\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(mock.times_called(), 0);\n        });\n    }\n}\n"},"62":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr","source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PrivateCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    /// Makes the call to this private function.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// This enables contracts to interact with each other while maintaining\n    /// privacy. This \"composability\" of private contract functions is a key\n    /// feature of the Aztec network.\n    ///\n    /// If a user's transaction includes multiple private function calls, then\n    /// by the design of Aztec, the following information will remain private[1]:\n    /// - The function selectors and contract addresses of all private function\n    ///   calls will remain private, so an observer of the public mempool will\n    ///   not be able to look at a tx and deduce which private functions have\n    ///   been executed.\n    /// - The arguments and return values of all private function calls will\n    ///   remain private.\n    /// - The person who initiated the tx will remain private.\n    /// - The notes and nullifiers and private logs that are emitted by all\n    ///   private function calls will (if designed well) not leak any user\n    ///   secrets, nor leak which functions have been executed.\n    ///\n    /// [1] Caveats: Some of these privacy guarantees depend on how app\n    /// developers design their smart contracts. Some actions _can_ leak\n    /// information, such as:\n    /// - Calling an internal public function.\n    /// - Calling a public function and not setting msg_sender to Option::none\n    ///   (see https://github.com/AztecProtocol/aztec-packages/pull/16433)\n    /// - Calling any public function will always leak details about the nature\n    ///   of the transaction, so devs should be careful in their contract\n    ///   designs. If it can be done in a private function, then that will give\n    ///   the best privacy.\n    /// - Not padding the side-effects of a tx to some standardised, uniform\n    ///   size. The kernel circuits can take hints to pad side-effects, so a\n    ///   wallet should be able to request for a particular amount of padding.\n    ///   Wallets should ideally agree on some standard.\n    ///   - Padding should include:\n    ///     - Padding the lengths of note & nullifier arrays\n    ///     - Padding private logs with random fields, up to some standardised\n    ///       size.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Advanced\n    /// * The call is added to the private call stack and executed by kernel\n    ///   circuits after this function completes\n    /// * The called function can modify its own contract's private state\n    /// * Side effects from the called function are included in this transaction\n    /// * The call inherits the current transaction's context and gas limits\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub fn call(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n\n        // If T is () (i.e. if the function does not return anything) then `get_preimage` will constrain that the\n        // returns hash is empty as per the protocol rules.\n        returns_hash.get_preimage()\n    }\n\n    /// Makes a _read-only_ call to this private function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// See `call` for more general info on private function calls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub fn view(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        // If T is () (i.e. if the function does not return anything) then `get_preimage` will constrain that the\n        // returns hash is empty as per the protocol rules.\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PrivateCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PrivateStaticCallInterface<M, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    /// Makes a read-only call to this private function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn view(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PrivateStaticCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PublicCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    /// Makes the call to this public function.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[external(\"public\")] function as `context`, through the\n    ///               #[external(\"public\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn call(self, context: &mut PublicContext) -> T {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        // If T is () (i.e. if the function does not return anything) then `as_array` will constrain that `returns` has\n        // a length of 0 (since that is ()'s deserialization length).\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Makes a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[external(\"public\")] function as `context`, through the\n    ///               #[external(\"public\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn view(self, context: &mut PublicContext) -> T {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        // If T is () (i.e. if the function does not return anything) then `as_array` will constrain that `returns` has\n        // a length of 0 (since that is ()'s deserialization length).\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Enqueues a call to this public function, to be executed later.\n    ///\n    /// Unlike private functions which execute immediately on the user's device,\n    /// public function calls are \"enqueued\" and executed some time later by a\n    /// block proposer.\n    ///\n    /// This means a public function cannot return any values back to a private\n    /// function, because by the time the public function is being executed,\n    /// the private function which called it has already completed execution.\n    /// (In fact, the private function has been executed and proven, along with\n    /// all other private function calls of the user's tx. A single proof of the\n    /// tx has been submitted to the Aztec network, and some time later a\n    /// proposer has picked the tx up from the mempool and begun executing all\n    /// of the enqueued public functions).\n    ///\n    /// # Privacy warning\n    /// Enqueueing a public function call is an inherently leaky action.\n    /// Many interesting applications will require some interaction with public\n    /// state, but smart contract developers should try to use public function\n    /// calls sparingly, and carefully.\n    /// _Internal_ public function calls are especially leaky, because they\n    /// completely leak which private contract made the call.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        self.enqueue_impl(context, false, false)\n    }\n\n    /// Enqueues a call to this public function, to be executed later.\n    ///\n    /// As per `enqueue`, but hides this calling contract's address from the\n    /// target public function.\n    /// This means the origin of the call (msg_sender) will not be publicly\n    /// visible to any blockchain observers, nor to the target public function.\n    /// When the target public function reads `context.msg_sender()` it will\n    /// receive an `Option<AztecAddress>::none`.\n    ///\n    /// NOTES:\n    /// - Not all public functions will accept a msg_sender of \"none\". Many\n    ///   public functions will require that msg_sender is \"some\" and will\n    ///   revert otherwise. Therefore, if using `enqueue_incognito`, you must\n    ///   understand whether the function you're calling will accept a\n    ///   msg_sender of \"none\".\n    ///   Lots of public bookkeeping patterns rely on knowing which address made\n    ///   the call, so as to ascribe state against the caller's address.\n    ///   (There are patterns whereby bookkeeping could instead be done in\n    ///   private-land).\n    /// - If you are enqueueing a call to an _internal_ public function (i.e.\n    ///   a public function that will only accept calls from other functions\n    ///   of its own contract), then by definition a call to it cannot possibly\n    ///   be \"incognito\": the msg_sender must be its own address, and indeed the\n    ///   called public function will assert this. Tl;dr this is not usable for\n    ///   enqueued internal public calls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    /// Advanced:\n    /// - The kernel circuits will permit _any_ private function to set the\n    ///   msg_sender field of any enqueued public function call to\n    ///   NULL_MSG_SENDER_CONTRACT_ADDRESS.\n    /// - When the called public function calls `PublicContext::msg_sender()`,\n    ///   aztec-nr will translate NULL_MSG_SENDER_CONTRACT_ADDRESS into\n    ///   `Option<AztecAddress>::none` for familiarity to devs.\n    ///\n    pub fn enqueue_incognito(self, context: &mut PrivateContext) {\n        self.enqueue_impl(context, false, true)\n    }\n\n    /// Enqueues a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        self.enqueue_impl(context, true, false)\n    }\n\n    /// Enqueues a read-only call to this public function.\n    ///\n    /// As per `enqueue_view`, but hides this calling contract's address from\n    /// the target public function.\n    ///\n    /// See `enqueue_incognito` for more details relating to hiding msg_sender.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn enqueue_view_incognito(self, context: &mut PrivateContext) {\n        self.enqueue_impl(context, true, true)\n    }\n\n    fn enqueue_impl(\n        self,\n        context: &mut PrivateContext,\n        is_static_call: bool,\n        hide_msg_sender: bool,\n    ) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            is_static_call,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a call to this public function, and designates it to be the\n    /// teardown function for this tx. Only one teardown function call can be\n    /// made by a tx.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase ensures the fee payer\n    /// has sufficient balance to pay the proposer their fees.\n    /// The teardown phase is primarily intended to: calculate exactly\n    /// how much the user owes, based on gas consumption, and refund the user\n    /// any change.\n    ///\n    /// Note: in some cases, the cost of refunding the user (i.e. DA costs of\n    /// tx side-effects) might exceed the refund amount. For app logic with\n    /// fairly stable and predictable gas consumption, a material refund amount\n    /// is unlikely. For app logic with unpredictable gas consumption, a\n    /// refund might be important to the user (e.g. if a hefty function reverts\n    /// very early). Wallet/FPC/Paymaster developers should be mindful of this.\n    ///\n    /// See `enqueue` for more information about enqueuing public function calls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        self.set_as_teardown_impl(context, false);\n    }\n\n    /// Enqueues a call to this public function, and designates it to be the teardown\n    /// function for this tx. Only one teardown function call can be made by a\n    /// tx.\n    ///\n    /// As per `set_as_teardown`, but hides this calling contract's address from\n    /// the target public function.\n    ///\n    /// See `enqueue_incognito` for more details relating to hiding msg_sender.\n    ///\n    pub fn set_as_teardown_incognito(self, context: &mut PrivateContext) {\n        self.set_as_teardown_impl(context, true);\n    }\n\n    fn set_as_teardown_impl(self, context: &mut PrivateContext, hide_msg_sender: bool) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PublicCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let M: u32, T> PublicStaticCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    /// Makes the read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[external(\"public\")] function as `context`, through the\n    ///               #[external(\"public\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn view(self, context: &mut PublicContext) -> T {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Enqueues a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n            false,\n        )\n    }\n\n    pub fn enqueue_view_incognito(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n            true,\n        )\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PublicStaticCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// UtilityCallInterface\n\npub struct UtilityCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n}\n\nimpl<let M: u32, T> CallInterface<M> for UtilityCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        false\n    }\n}\n\nimpl<let M: u32, T> UtilityCallInterface<M, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n\n    pub fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    pub fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    pub fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    pub fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n}\n"},"70":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::{MAX_U32_VALUE, NULL_MSG_SENDER_CONTRACT_ADDRESS};\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\n/// # PublicContext\n///\n/// The **main interface** between an #[external(\"public\")] function and the Aztec blockchain.\n///\n/// An instance of the PublicContext is initialized automatically at the outset\n/// of every public function, within the #[external(\"public\")] macro, so you'll never\n/// need to consciously instantiate this yourself.\n///\n/// The instance is always named `context`, and it will always be available\n/// within the body of every #[external(\"public\")] function in your smart contract.\n///\n/// Typical usage for a smart contract developer will be to call getter\n/// methods of the PublicContext.\n///\n/// _Pushing_ data and requests to the context is mostly handled within\n/// aztec-nr's own functions, so typically a smart contract developer won't\n/// need to call any setter methods directly.\n///\n/// ## Responsibilities\n/// - Exposes contextual data to a public function:\n///   - Data relating to how this public function was called:\n///     - msg_sender, this_address\n///   - Data relating to the current blockchain state:\n///     - timestamp, block_number, chain_id, version\n///   - Gas and fee information\n/// - Provides state access:\n///   - Read/write public storage (key-value mapping)\n///   - Check existence of notes and nullifiers\n///     (Some patterns use notes & nullifiers to store public (not private)\n///     information)\n///   - Enables consumption of L1->L2 messages.\n/// - Enables calls to other public smart contract functions:\n/// - Writes data to the blockchain:\n///   - Updates to public state variables\n///   - New public logs (for events)\n///   - New L2->L1 messages\n///   - New notes & nullifiers\n///     (E.g. pushing public info to notes/nullifiers, or for completing\n///     \"partial notes\")\n///\n/// ## Key Differences from Private Execution\n///\n/// Unlike private functions -- which are executed on the user's device and which\n/// can only reference historic state -- public functions are executed by a block\n/// proposer and are executed \"live\" on the _current_ tip of the chain.\n/// This means public functions can:\n/// - Read and write _current_ public state\n/// - Immediately see the effects of earlier transactions in the same block\n///\n/// Also, public functions are executed within a zkVM (the \"AVM\"), so that they\n/// can _revert_ whilst still ensuring payment to the proposer and prover.\n/// (Private functions cannot revert: they either succeed, or they cannot be\n/// included).\n///\n/// ## Optimising Public Functions\n///\n/// Using the AVM to execute public functions means they compile down to \"AVM\n/// bytecode\" instead of the ACIR that private functions (standalone circuits)\n/// compile to. Therefore the approach to optimising a public function is\n/// fundamentally different from optimising a public function.\n///\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl Eq for PublicContext {\n    fn eq(self, other: Self) -> bool {\n        (self.args_hash == other.args_hash)\n        // Can't compare the function compute_args_hash\n    }\n}\n\nimpl PublicContext {\n    /// Creates a new PublicContext instance.\n    ///\n    /// Low-level function: This is called automatically by the #[external(\"public\")]\n    /// macro, so you shouldn't need to be called directly by smart contract\n    /// developers.\n    ///\n    /// # Arguments\n    /// * `compute_args_hash` - Function to compute the args_hash\n    ///\n    /// # Returns\n    /// * A new PublicContext instance\n    ///\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    /// Emits a _public_ log that will be visible onchain to everyone.\n    ///\n    /// # Arguments\n    /// * `log` - The data to log, must implement Serialize trait\n    ///\n    pub fn emit_public_log<T>(_self: &mut Self, log: T)\n    where\n        T: Serialize,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    /// Checks if a given note hash exists in the note hash tree at a particular\n    /// leaf_index.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The note hash to check for existence\n    /// * `leaf_index` - The index where the note hash should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the note hash exists at the specified index\n    ///\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: u64) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    /// Checks if a specific L1-to-L2 message exists in the L1-to-L2 message\n    /// tree at a particular leaf index.\n    ///\n    /// Common use cases include token bridging, cross-chain governance, and\n    /// triggering L2 actions based on L1 events.\n    ///\n    /// This function should be called before attempting to consume an L1-to-L2\n    /// message.\n    ///\n    /// # Arguments\n    /// * `msg_hash` - Hash of the L1-to-L2 message to check\n    /// * `msg_leaf_index` - The index where the message should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the message exists at the specified index\n    ///\n    /// # Advanced\n    /// * Uses the AVM l1_to_l2_msg_exists opcode for tree lookup\n    /// * Messages are copied from L1 Inbox to L2 by block proposers\n    ///\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        // TODO(alvaro): Make l1l2msg leaf index a u64 upstream\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index as u64) } == 1\n    }\n\n    /// Checks if a specific nullifier has been emitted by a given contract.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. An example is to check\n    /// whether a contract has been published: we emit a nullifier that is\n    /// deterministic, but whose preimage is _not_ private. This is more\n    /// efficient than using mutable storage, and can be done directly\n    /// from a private function.\n    ///\n    /// Nullifiers can be tested for non-existence in public, which is not the\n    /// case in private. Because private functions do not have access to\n    /// the tip of the blockchain (but only the anchor block they are built\n    /// at) they can only prove nullifier non-existence in the past. But between\n    /// an anchor block and the block in which a tx is included, the nullifier\n    /// might have been inserted into the nullifier tree by some other\n    /// transaction.\n    /// Public functions _do_ have access to the tip of the state, and so\n    /// this pattern is safe.\n    ///\n    /// # Arguments\n    /// * `unsiloed_nullifier` - The raw nullifier value (before siloing with\n    ///                          the contract address that emitted it).\n    /// * `address` - The claimed contract address that emitted the nullifier\n    ///\n    /// # Returns\n    /// * `bool` - True if the nullifier has been emitted by the specified contract\n    ///\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2) -- effectively\n    /// marking it as \"read\".\n    ///\n    /// Use this function if you only want the message to ever be \"referred to\"\n    /// once. Once consumed using this method, the message cannot be consumed\n    /// again, because a nullifier is emitted.\n    /// If your use case wants for the message to be read unlimited times, then\n    /// you can always read any historic message from the L1-to-L2 messages tree,\n    /// using the `l1_to_l2_msg_exists` method. Messages never technically get\n    /// deleted from that tree.\n    ///\n    /// The message will first be inserted into an Aztec \"Inbox\" smart contract\n    /// on L1. It will not be available for consumption immediately. Messages\n    /// get copied-over from the L1 Inbox to L2 by the next Proposer in batches.\n    /// So you will need to wait until the messages are copied before you can\n    /// consume them.\n    ///\n    /// # Arguments\n    /// * `content` - The message content that was sent from L1\n    /// * `secret` - Secret value used for message privacy (if needed)\n    /// * `sender` - Ethereum address that sent the message\n    /// * `leaf_index` - Index of the message in the L1-to-L2 message tree\n    ///\n    /// # Advanced\n    /// * Validates message existence in the L1-to-L2 message tree\n    /// * Prevents double-consumption by emitting a nullifier\n    /// * Message hash is computed from all parameters + chain context\n    /// * Will revert if message doesn't exist or was already consumed\n    ///\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    /// Sends an \"L2 -> L1 message\" from this function (Aztec, L2) to a smart\n    /// contract on Ethereum (L1). L1 contracts which are designed to\n    /// send/receive messages to/from Aztec are called \"Portal Contracts\".\n    ///\n    /// Common use cases include withdrawals, cross-chain asset transfers, and\n    /// triggering L1 actions based on L2 state changes.\n    ///\n    /// The message will be inserted into an Aztec \"Outbox\" contract on L1,\n    /// when this transaction's block is proposed to L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target portal contract. The message will need to be manually\n    /// consumed from the Outbox through a separate Ethereum transaction: a user\n    /// will need to call a function of the portal contract -- a function\n    /// specifically designed to make a call to the Outbox to consume the\n    /// message.\n    /// The message will only be available for consumption once the _epoch_\n    /// proof has been submitted. Given that there are multiple Aztec blocks\n    /// within an epoch, it might take some time for this epoch proof to be\n    /// submitted -- especially if the block was near the start of an epoch.\n    ///\n    /// # Arguments\n    /// * `recipient` - Ethereum address that will receive the message\n    /// * `content` - Message content (32 bytes as a Field element)\n    ///\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    /// Calls a public function on another contract.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Arguments to pass to the function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Makes a read-only call to a public function on another contract.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Useful for querying data from other contracts safely.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Array of arguments to pass to the called function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Adds a new note hash to the Aztec blockchain's global Note Hash Tree.\n    ///\n    /// Notes are ordinarily constructed and emitted by _private_ functions, to\n    /// ensure that both the content of the note, and the contract that emitted\n    /// the note, stay private.\n    ///\n    /// There are however some useful patterns whereby a note needs to contain\n    /// _public_ data. The ability to push a new note_hash from a _public_\n    /// function means that notes can be injected with public data immediately\n    /// -- as soon as the public value is known. The slower alternative would\n    /// be to submit a follow-up transaction so that a private function can\n    /// inject the data. Both are possible on Aztec.\n    ///\n    /// Search \"Partial Note\" for a very common pattern which enables a note\n    /// to be \"partially\" populated with some data in a _private_ function, and\n    /// then later \"completed\" with some data in a public function.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The hash of the note to add to the tree\n    ///\n    /// # Advanced\n    /// * The note hash will be siloed with the contract address by the protocol\n    ///\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n\n    /// Adds a new nullifier to the Aztec blockchain's global Nullifier Tree.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. Hence why you're seeing this\n    /// function within the PublicContext.\n    /// An example is to check whether a contract has been published: we emit\n    /// a nullifier that is deterministic, but whose preimage is _not_ private.\n    ///\n    /// # Arguments\n    /// * `nullifier` - A unique field element that represents the consumed\n    ///   state\n    ///\n    /// # Advanced\n    /// * Nullifier is immediately added to the global nullifier tree\n    /// * Emitted nullifiers are immediately visible to all\n    ///   subsequent transactions in the same block\n    /// * Automatically siloed with the contract address by the protocol\n    /// * Used for preventing double-spending and ensuring one-time actions\n    ///\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    /// Returns the address of the current contract being executed.\n    ///\n    /// This is equivalent to `address(this)` in Solidity (hence the name).\n    /// Use this to identify the current contract's address, commonly needed for\n    /// access control or when interacting with other contracts.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The contract address of the current function being\n    ///                    executed.\n    ///\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: If the calling function is a _private_ function, then\n    /// it had the option of hiding its address when enqueuing this public\n    /// function call. In such cases, this `context.msg_sender()` method will\n    /// return `Option<AztecAddress>::none`.\n    /// If the calling function is a _public_ function, it will always return\n    /// an `Option<AztecAddress>::some` (i.e. a non-null value).\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called\n    ///   this function (be it an app contract or a user's account contract).\n    ///\n    /// # Advanced\n    /// * Value is provided by the AVM sender opcode\n    /// * In nested calls, this is the immediate caller, not the original\n    ///   transaction sender\n    ///\n    pub fn msg_sender(_self: Self) -> Option<AztecAddress> {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let maybe_msg_sender = unsafe { sender() };\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// \"Unsafe\" versus calling `context.msg_sender()`, because it doesn't\n    /// translate `NULL_MSG_SENDER_CONTRACT_ADDRESS` as\n    /// `Option<AztecAddress>::none`.\n    /// Used by some internal aztecnr functions.\n    pub fn msg_sender_unsafe(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n\n    /// Returns the function selector of the currently-executing function.\n    ///\n    /// This is similar to `msg.sig` in Solidity, returning the first 4\n    /// bytes of the function signature.\n    ///\n    /// # Returns\n    /// * `FunctionSelector` - The 4-byte function identifier\n    ///\n    /// # Advanced\n    /// * Extracted from the first element of calldata\n    /// * Used internally for function dispatch in the AVM\n    ///\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    ///\n    /// Very low-level function: The #[external(\"public\")] macro uses this internally.\n    /// Smart contract developers typically won't need to access this\n    /// directly as arguments are automatically made available.\n    ///\n    /// # Returns\n    /// * `Field` - Hash of the function arguments\n    ///\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n\n    /// Returns the \"transaction fee\" for the current transaction.\n    /// This is the final tx fee that will be deducted from the fee_payer's\n    /// \"fee-juice\" balance (in the protocol's Base Rollup circuit).\n    ///\n    /// # Returns\n    /// * `Field` - The actual, final cost of the transaction, taking into account:\n    ///             the actual gas used during the setup and app-logic phases,\n    ///             and the fixed amount of gas that's been allocated by the user\n    ///             for the teardown phase.\n    ///             I.e. effectiveL2FeePerGas * l2GasUsed + effectiveDAFeePerGas * daGasUsed\n    ///\n    /// This will return `0` during the \"setup\" and \"app-logic\" phases of\n    /// tx execution (because the final tx fee is not known at that time).\n    /// This will only return a nonzero value during the \"teardown\" phase of\n    /// execution, where the final tx fee can actually be computed.\n    ///\n    /// Regardless of _when_ this function is called during the teardown phase,\n    /// it will always return the same final tx fee value. The teardown phase\n    /// does not consume a variable amount of gas: it always consumes a\n    /// pre-allocated amount of gas, as specified by the user when they generate\n    /// their tx.\n    ///\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    /// Returns the chain ID of the current network.\n    ///\n    /// This is similar to `block.chainid` in Solidity. Returns the unique\n    /// identifier for the blockchain network this transaction is executing on.\n    ///\n    /// Helps prevent cross-chain replay attacks. Useful if implementing\n    /// multi-chain contract logic.\n    ///\n    /// # Returns\n    /// * `Field` - The chain ID as a field element\n    ///\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n\n    /// Returns the Aztec protocol version that this transaction is executing\n    /// under. Different versions may have different rules, opcodes, or\n    /// cryptographic primitives.\n    ///\n    /// This is similar to how Ethereum has different EVM versions.\n    ///\n    /// Useful for forward/backward compatibility checks\n    ///\n    /// Not to be confused with contract versions; this is the protocol version.\n    ///\n    /// # Returns\n    /// * `Field` - The protocol version as a field element\n    ///\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    /// Returns the current block number.\n    ///\n    /// This is similar to `block.number` in Solidity.\n    ///\n    /// Note: the current block number is only available within a public function\n    /// (as opposed to a private function).\n    ///\n    /// Note: the time intervals between blocks should not be relied upon as\n    /// being consistent:\n    /// - Timestamps of blocks fall within a range, rather than at exact regular\n    ///   intervals.\n    /// - Slots can be missed.\n    /// - Protocol upgrades can completely change the intervals between blocks\n    ///   (and indeed the current roadmap plans to reduce the time between\n    ///   blocks, eventually).\n    /// Use `context.timestamp()` for more-reliable time-based logic.\n    ///\n    /// # Returns\n    /// * `u32` - The current block number\n    ///\n    pub fn block_number(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n\n    /// Returns the timestamp of the current block.\n    ///\n    /// This is similar to `block.timestamp` in Solidity.\n    ///\n    /// All functions of all transactions in a block share the exact same\n    /// timestamp (even though technically each transaction is executed\n    /// one-after-the-other).\n    ///\n    /// Important note: Timestamps of Aztec blocks are not at reliably-fixed\n    /// intervals. The proposer of the block has some flexibility to choose a\n    /// timestamp which is in a valid _range_: Obviously the timestamp of this\n    /// block must be strictly greater than that of the previous block, and must\n    /// must be less than the timestamp of whichever ethereum block the aztec\n    /// block is proposed to. Furthermore, if the timestamp is not deemed close\n    /// enough to the actual current time, the committee of validators will not\n    /// attest to the block.\n    ///\n    /// # Returns\n    /// * `u64` - Unix timestamp in seconds\n    ///\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n\n    /// Returns the fee per unit of L2 gas for this transaction (aka the \"L2 gas\n    /// price\"), as chosen by the user.\n    ///\n    /// L2 gas covers the cost of executing public functions and handling\n    /// side-effects within the AVM.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of L2 gas\n    ///\n    /// Wallet developers should be mindful that the choice of gas price (which\n    /// is publicly visible) can leak information about the user, e.g.:\n    /// - which wallet software the user is using;\n    /// - the amount of time which has elapsed from the time the user's wallet\n    ///   chose a gas price (at the going rate), to the time of tx submission.\n    ///   This can give clues about the proving time, and hence the nature of\n    ///   the tx.\n    /// - the urgency of the transaction (which is kind of unavoidable, if the\n    ///   tx is indeed urgent).\n    /// - the wealth of the user.\n    /// - the exact user (if the gas price is explicitly chosen by the user to\n    ///   be some unique number like 0.123456789, or their favourite number).\n    /// Wallet devs might wish to consider fuzzing the choice of gas price.\n    ///\n    pub fn base_fee_per_l2_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_l2_gas()\n        }\n    }\n\n    /// Returns the fee per unit of DA (Data Availability) gas (aka the \"DA gas\n    /// price\").\n    ///\n    /// DA gas covers the cost of making transaction data available on L1.\n    ///\n    /// See the warning in `fee_pre_l2_gas` for how gas prices can be leaky.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of DA gas\n    ///\n    pub fn base_fee_per_da_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_da_gas()\n        }\n    }\n\n    /// Returns the remaining L2 gas available for this transaction.\n    ///\n    /// Different AVM opcodes consume different amounts of gas.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining L2 gas units\n    ///\n    pub fn l2_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n\n    /// Returns the remaining DA (Data Availability) gas available for this\n    /// transaction.\n    ///\n    /// DA gas is consumed when emitting data that needs to be made available\n    /// on L1, such as public logs or state updates.\n    /// All of the side-effects from the private part of the tx also consume\n    /// DA gas before execution of any public functions even begins.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining DA gas units\n    ///\n    pub fn da_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n\n    /// Checks if the current execution is within a staticcall context, where\n    /// no state changes or logs are allowed to be emitted (by this function\n    /// or any nested function calls).\n    ///\n    /// # Returns\n    /// * `bool` - True if in staticcall context, false otherwise\n    ///\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    /// Reads raw field values from public storage.\n    /// Reads N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to read from\n    ///\n    /// # Returns\n    /// * `[Field; N]` - Array of N field values from consecutive storage slots\n    ///\n    /// # Generic Parameters\n    /// * `N` - the number of consecutive slots to return, starting from the\n    ///         `storage_slot`.\n    ///\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    /// Reads a typed value from public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to read from\n    ///\n    /// # Returns\n    /// * `T` - The deserialized value from storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type that the caller expects to read from the `storage_slot`.\n    ///\n    pub fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    /// Writes raw field values to public storage.\n    /// Writes to N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// Public storage writes take effect immediately.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to write to\n    /// * `values` - Array of N Fields to write to storage\n    ///\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    /// Writes a typed value to public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to write to\n    /// * `value` - The typed value to write to storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type to write to storage.\n    ///\n    pub fn storage_write<T>(self, storage_slot: Field, value: T)\n    where\n        T: Packable,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> u32 {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn base_fee_per_l2_gas() -> u128 {\n    base_fee_per_l2_gas_opcode()\n}\nunconstrained fn base_fee_per_da_gas() -> u128 {\n    base_fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> u32 {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> u32 {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> u1 {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: u64) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: u64) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\n\nunconstrained fn call(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\nunconstrained fn call_static(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeBaseFeePerL2Gas)]\nunconstrained fn base_fee_per_l2_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeBaseFeePerDaGas)]\nunconstrained fn base_fee_per_da_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> u1 {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"},"72":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/context/utility_context.nr","source":"use crate::oracle::{execution::get_utility_context, storage::storage_read};\nuse protocol_types::{address::AztecAddress, traits::Packable};\n\n// If you'll modify this struct don't forget to update utility_context.ts as well.\npub struct UtilityContext {\n    block_number: u32,\n    timestamp: u64,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        get_utility_context()\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        // We get a context with default contract address, and then we construct the final context with the provided\n        // contract address.\n        let default_context = get_utility_context();\n\n        Self {\n            block_number: default_context.block_number,\n            timestamp: default_context.timestamp,\n            contract_address,\n            version: default_context.version,\n            chain_id: default_context.chain_id,\n        }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        // We get a context with default contract address and block number, and then we construct the final context\n        // with the provided contract address and block number.\n        let default_context = get_utility_context();\n\n        Self {\n            block_number,\n            timestamp: default_context.timestamp,\n            contract_address,\n            version: default_context.version,\n            chain_id: default_context.chain_id,\n        }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn timestamp(self) -> u64 {\n        self.timestamp\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"},"75":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/event/event_selector.nr","source":"use dep::protocol_types::{\n    hash::poseidon2_hash_bytes,\n    traits::{Deserialize, Empty, FromField, Serialize, ToField},\n};\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"},"77":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_BYTECODE, GENERATOR_INDEX__PUBLIC_CALLDATA,\n        GENERATOR_INDEX__SECRET_HASH, MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS,\n    },\n    hash::{\n        poseidon2_hash_subarray, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice,\n        sha256_to_field,\n    },\n    point::Point,\n    traits::ToField,\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n}\n\n/**\n * Computes the public bytecode commitment for a contract class.\n * The commitment is `hash([separator, ...bytecode])` where bytecode omits the length prefix present\n * in `packed_bytecode`.\n *\n * @param packed_bytecode - The packed bytecode of the contract class. 0th word is the length in bytes.\n *    packed_bytecode is mutable so that we can avoid copying the array to construct one starting with\n *    separator instead of length.\n * @returns The public bytecode commitment.\n */\npub fn compute_public_bytecode_commitment(\n    mut packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS],\n) -> Field {\n    // First field element contains the length of the bytecode\n    let bytecode_length_in_bytes: u32 = packed_public_bytecode[0] as u32;\n    let bytecode_length_in_fields: u32 =\n        (bytecode_length_in_bytes / 31) + (bytecode_length_in_bytes % 31 != 0) as u32;\n    // Don't allow empty public bytecode.\n    // AVM doesn't handle execution of contracts that exist with empty bytecode.\n    assert(bytecode_length_in_fields != 0);\n    assert(bytecode_length_in_fields < MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS);\n\n    // Packed_bytecode's 0th entry is the length. Replace it with separator before hashing.\n    let separator = GENERATOR_INDEX__PUBLIC_BYTECODE.to_field();\n    packed_public_bytecode[0] = separator;\n\n    // `fields_to_hash` is the number of fields from the start of `packed_public_bytecode` that should be included in\n    // the hash. Fields after this length are ignored.\n    // +1 to account for the separator.\n    let num_fields_to_hash = bytecode_length_in_fields + 1;\n\n    poseidon2_hash_subarray(packed_public_bytecode, num_fields_to_hash)\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = [0; 100];\n    for i in 0..100 {\n        input[i] = i as Field;\n    }\n    let hash = hash_args_array(input);\n    dep::std::println(hash);\n    // Used in yarn-project/stdlib test snapshots:\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_calldata_hash() {\n    let mut input = [0; 100];\n    for i in 0..input.len() {\n        input[i] = i as Field;\n    }\n    let hash = hash_calldata_array(input);\n    dep::std::println(hash);\n    let hash_check = hash_calldata(input.as_slice());\n    assert(hash == hash_check);\n    // Used in cpp vm2 tests:\n    assert(hash == 0x191383c9f8964afd3ea8879a03b7dda65d6724773966d18dcf80e452736fc1f3);\n}\n\n#[test]\nunconstrained fn public_bytecode_commitment() {\n    let mut input = [0; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS];\n    let len = 99;\n    for i in 1..len + 1 {\n        input[i] = i as Field;\n    }\n    input[0] = (len as Field) * 31;\n    let hash = compute_public_bytecode_commitment(input);\n    dep::std::println(hash);\n    // Used in cpp vm2 tests:\n    assert(hash == 0x16d621c3387156ef53754679e7b2c9be8f0bceeb44aa59a74991df3b0b42a0bf);\n}\n"},"94":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr","source":"use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n\nmod test {\n    use super::get_public_keys;\n\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use protocol_types::traits::Serialize;\n    use std::test::OracleMock;\n\n    global KEY_ORACLE_RESPONSE_LENGTH: u32 = 13; // 12 fields for the keys, one field for the partial address\n\n    #[test(should_fail_with = \"Invalid public keys hint for address\")]\n    unconstrained fn get_public_keys_fails_with_bad_hint() {\n        let mut env = TestEnvironment::new();\n        let account = env.create_light_account();\n\n        // Instead of querying for some unknown account, which would result in the oracle erroring out, we mock a bad oracle\n        // response to check that the circuit properly checks the address derivation.\n        let mut random_keys_and_partial_address = [0; KEY_ORACLE_RESPONSE_LENGTH];\n        // We use randomly generated points on the curve, and a random partial address to ensure that\n        // this combination does not derive the address and we should see the assertion fail.\n        // npk_m\n        random_keys_and_partial_address[0] =\n            0x292364b852c6c6f01472951e76a39cbcf074591fd0e063a81965e7b51ad868a5;\n        random_keys_and_partial_address[1] =\n            0x0a687b46cdc9238f1c311f126aaaa4acbd7a737bff2efd7aeabdb8d805843a27;\n        random_keys_and_partial_address[2] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // ivpk_m\n        random_keys_and_partial_address[3] =\n            0x173c5229a00c5425255680dd6edc27e278c48883991f348fe6985de43b4ec25f;\n        random_keys_and_partial_address[4] =\n            0x1698608e23b5f6c2f43c49a559108bb64e2247b8fc2da842296a416817f40b7f;\n        random_keys_and_partial_address[5] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // ovpk_m\n        random_keys_and_partial_address[6] =\n            0x1bad2f7d1ad960a1bd0fe4d2c8d17f5ab4a86ef8b103e0a9e7f67ec0d3b4795e;\n        random_keys_and_partial_address[7] =\n            0x206db87110abbecc9fbaef2c865189d94ef2c106202f734ee4eba9257fd28bf1;\n        random_keys_and_partial_address[8] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // tpk_m\n        random_keys_and_partial_address[9] =\n            0x05e3bd9cfe6b47daa139613619cf7d7fd8bb0112b6f2908caa6d9b536ed948ed;\n        random_keys_and_partial_address[10] =\n            0x051066f877c9df47552d02e7dc32127ff4edefc8498e813bca1cbd3f5d1be429;\n        random_keys_and_partial_address[11] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // partial address\n        random_keys_and_partial_address[12] =\n            0x236703e2cb00a182e024e98e9f759231b556d25ff19f98896cebb69e9e678cc9;\n\n        let _ = OracleMock::mock(\"utilityGetPublicKeysAndPartialAddress\").returns(\n            random_keys_and_partial_address.serialize(),\n        );\n        let _ = get_public_keys(account);\n    }\n}\n"},"98":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/macros/aztec.nr","source":"use crate::macros::{\n    dispatch::generate_public_dispatch,\n    functions::{stub_registry, utils::check_each_fn_macroified},\n    notes::NOTES,\n    storage::STORAGE_LAYOUT_NAME,\n    utils::{get_trait_impl_method, module_has_storage},\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_private_state` utility function.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[external(...)], #[contract_library_method], or #[test] are not allowed in contracts.\n    check_each_fn_macroified(m);\n\n    // We generate `_compute_note_hash_and_nullifier`, `sync_private_state` and `process_message`\n    // functions only if they are not already implemented. If they are implemented we just insert empty\n    // quotes.\n    let contract_library_method_compute_note_hash_and_nullifier = if !m.functions().any(|f| {\n        f.name() == quote { _compute_note_hash_and_nullifier }\n    }) {\n        generate_contract_library_method_compute_note_hash_and_nullifier()\n    } else {\n        quote {}\n    };\n    let sync_private_state = if !m.functions().any(|f| f.name() == quote { sync_private_state }) {\n        generate_sync_private_state()\n    } else {\n        quote {}\n    };\n    let process_message = if !m.functions().any(|f| f.name() == quote { process_message }) {\n        generate_process_message()\n    } else {\n        quote {}\n    };\n    let public_dispatch = generate_public_dispatch(m);\n\n    quote {\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_private_state\n        $process_message\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    if NOTES.len() > 0 {\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..NOTES.len() {\n            let typ = NOTES.get(i);\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret its raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = <$typ as $crate::protocol_types::traits::Packable>::N;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided note nonce.\n                        let note_hash_for_nullification = aztec::note::utils::compute_note_hash_for_nullification(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(note_nonce).into()\n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullification);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `note_nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_message` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                note_nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_sync_private_state() -> Quoted {\n    // We obtain the `external` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::external(\"utility\")]` in the returned quote because the latter would result in\n    // the function attribute having the full path in the ABI. This is undesirable because we use the information in\n    // the ABI only to determine whether a function is `external(\"private\")`, `external(\"public\")`, or `external(\"utility\")`.\n    let external = crate::macros::functions::external;\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[external(\"utility\")] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[$external(\"utility\")]\n        unconstrained fn sync_private_state() {\n        }\n    }\n}\n\ncomptime fn generate_process_message() -> Quoted {\n    // We obtain the `external` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::external(\"utility\")]` in the returned quote because the latter would result in\n    // the function attribute having the full path in the ABI. This is undesirable because we use the information in\n    // the ABI only to determine whether a function is `external(\"private\")`, `external(\"public\")`, or `external(\"utility\")`.\n    let external = crate::macros::functions::external;\n\n    quote {\n        #[$external(\"utility\")]\n        unconstrained fn process_message(\n            message_ciphertext: BoundedVec<Field, aztec::messages::encoding::MESSAGE_CIPHERTEXT_LEN>,\n            message_context: aztec::messages::processing::message_context::MessageContext,\n        ) {\n            aztec::messages::discovery::process_message::process_message_ciphertext(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n                message_ciphertext,\n                message_context,\n            );\n        }\n    }\n}\n"},"99":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr","source":"use super::utils::compute_fn_selector;\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::utils::get_params_len_quote;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault, panic};\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let seen_selectors =\n        &mut UHashMap::<Field, Quoted, BuildHasherDefault<Poseidon2Hasher>>::default();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n        let fn_name = function.name();\n\n        // Since function selectors are computed as the first 4 bytes of the hash of the function signature,\n        // it's possible to have collisions. With the following check, we ensure it doesn't happen within\n        // the same contract.\n        if seen_selectors.contains_key(selector) {\n            let existing_fn = seen_selectors.get(selector).unwrap();\n            panic(\n                f\"Public function selector collision detected between functions '{fn_name}' and '{existing_fn}'\",\n            );\n        }\n        seen_selectors.insert(selector, fn_name);\n\n        let params_len_quote = get_params_len_quote(parameters);\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $params_len_quote] = dep::aztec::context::public_context::calldata_copy(1, $params_len_quote);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index: &mut u32 = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[external(\"public\")]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"}}}