{
  "file_map": {
    "101": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n\nmod test {\n    use super::get_public_keys;\n\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use protocol_types::traits::Serialize;\n    use std::test::OracleMock;\n\n    global KEY_ORACLE_RESPONSE_LENGTH: u32 = 13; // 12 fields for the keys, one field for the partial address\n\n    #[test(should_fail_with = \"Invalid public keys hint for address\")]\n    unconstrained fn get_public_keys_fails_with_bad_hint() {\n        let mut env = TestEnvironment::new();\n        let account = env.create_light_account();\n\n        // Instead of querying for some unknown account, which would result in the oracle erroring out, we mock a bad oracle\n        // response to check that the circuit properly checks the address derivation.\n        let mut random_keys_and_partial_address = [0; KEY_ORACLE_RESPONSE_LENGTH];\n        // We use randomly generated points on the curve, and a random partial address to ensure that\n        // this combination does not derive the address and we should see the assertion fail.\n        // npk_m\n        random_keys_and_partial_address[0] =\n            0x292364b852c6c6f01472951e76a39cbcf074591fd0e063a81965e7b51ad868a5;\n        random_keys_and_partial_address[1] =\n            0x0a687b46cdc9238f1c311f126aaaa4acbd7a737bff2efd7aeabdb8d805843a27;\n        random_keys_and_partial_address[2] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // ivpk_m\n        random_keys_and_partial_address[3] =\n            0x173c5229a00c5425255680dd6edc27e278c48883991f348fe6985de43b4ec25f;\n        random_keys_and_partial_address[4] =\n            0x1698608e23b5f6c2f43c49a559108bb64e2247b8fc2da842296a416817f40b7f;\n        random_keys_and_partial_address[5] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // ovpk_m\n        random_keys_and_partial_address[6] =\n            0x1bad2f7d1ad960a1bd0fe4d2c8d17f5ab4a86ef8b103e0a9e7f67ec0d3b4795e;\n        random_keys_and_partial_address[7] =\n            0x206db87110abbecc9fbaef2c865189d94ef2c106202f734ee4eba9257fd28bf1;\n        random_keys_and_partial_address[8] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // tpk_m\n        random_keys_and_partial_address[9] =\n            0x05e3bd9cfe6b47daa139613619cf7d7fd8bb0112b6f2908caa6d9b536ed948ed;\n        random_keys_and_partial_address[10] =\n            0x051066f877c9df47552d02e7dc32127ff4edefc8498e813bca1cbd3f5d1be429;\n        random_keys_and_partial_address[11] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // partial address\n        random_keys_and_partial_address[12] =\n            0x236703e2cb00a182e024e98e9f759231b556d25ff19f98896cebb69e9e678cc9;\n\n        let _ = OracleMock::mock(\"utilityGetPublicKeysAndPartialAddress\").returns(\n            random_keys_and_partial_address.serialize(),\n        );\n        let _ = get_public_keys(account);\n    }\n}\n"
    },
    "105": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::macros::{\n    calls_generation::{\n        external_functions::{\n            generate_external_function_calls, generate_external_function_self_calls_structs,\n        },\n        internal_functions::generate_call_internal_struct,\n    },\n    dispatch::generate_public_dispatch,\n    internals_functions_generation::{create_fn_abi_exports, process_functions},\n    notes::NOTES,\n    storage::STORAGE_LAYOUT_NAME,\n    utils::{\n        get_trait_impl_method, is_fn_contract_library_method, is_fn_external, is_fn_internal,\n        is_fn_test, module_has_storage,\n    },\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_private_state` utility function.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    // Functions that don't have #[external(...)], #[contract_library_method], or #[test] are not allowed in contracts.\n    check_each_fn_macroified(m);\n\n    // We generate new functions prefixed with `__aztec_nr_internals__` and we replace the original functions' bodies\n    // with `static_assert(false, ...)` to prevent them from being called directly from within the contract.\n    let functions = process_functions(m);\n\n    // We generate structs and their implementations necessary for convenient functions calls.\n    let interface = generate_contract_interface(m);\n    let self_call_structs = generate_external_function_self_calls_structs(m);\n    let call_internal_struct = generate_call_internal_struct(m);\n\n    // We generate ABI exports for all the external functions in the contract.\n    let fn_abi_exports = create_fn_abi_exports(m);\n\n    // We generate `_compute_note_hash_and_nullifier`, `sync_private_state` and `process_message`\n    // functions only if they are not already implemented. If they are implemented we just insert empty\n    // quotes.\n    let contract_library_method_compute_note_hash_and_nullifier = if !m.functions().any(|f| {\n        f.name() == quote { _compute_note_hash_and_nullifier }\n    }) {\n        generate_contract_library_method_compute_note_hash_and_nullifier()\n    } else {\n        quote {}\n    };\n    let sync_private_state_fn_and_abi_export = if !m.functions().any(|f| {\n        f.name() == quote { sync_private_state }\n    }) {\n        generate_sync_private_state()\n    } else {\n        quote {}\n    };\n\n    let process_message_fn_and_abi_export = if !m.functions().any(|f| {\n        f.name() == quote { process_message }\n    }) {\n        generate_process_message()\n    } else {\n        quote {}\n    };\n    let public_dispatch = generate_public_dispatch(m);\n\n    quote {\n        $interface\n        $self_call_structs\n        $call_internal_struct\n        $functions\n        $fn_abi_exports\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_private_state_fn_and_abi_export\n        $process_message_fn_and_abi_export\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let calls = generate_external_function_calls(m);\n\n    let module_name = m.name();\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $calls\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    if NOTES.len() > 0 {\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..NOTES.len() {\n            let typ = NOTES.get(i);\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret its raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = <$typ as $crate::protocol_types::traits::Packable>::N;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, owner, storage_slot, randomness);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided note nonce.\n                        let note_hash_for_nullification = aztec::note::utils::compute_note_hash_for_nullification(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note,\n                                contract_address,\n                                owner,\n                                randomness,\n                                storage_slot,\n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(note_nonce).into()\n                            }\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, owner, note_hash_for_nullification);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `note_nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_message` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                owner: aztec::protocol_types::address::AztecAddress,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                randomness: Field,\n                note_nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _owner: aztec::protocol_types::address::AztecAddress,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _randomness: Field,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_sync_private_state() -> Quoted {\n    quote {\n        pub struct sync_private_state_parameters {}\n\n        #[abi(functions)]\n        pub struct sync_private_state_abi {\n            parameters: sync_private_state_parameters,\n        }\n\n        #[aztec::macros::internals_functions_generation::abi_attributes::abi_utility]\n        unconstrained fn sync_private_state() {\n            let address = aztec::context::utility_context::UtilityContext::new().this_address();\n            \n            aztec::messages::discovery::discover_new_messages(address, _compute_note_hash_and_nullifier);\n        }\n    }\n}\n\ncomptime fn generate_process_message() -> Quoted {\n    quote {\n        pub struct process_message_parameters {\n            pub message_ciphertext: BoundedVec<Field, aztec::messages::encoding::MESSAGE_CIPHERTEXT_LEN>,\n            pub message_context: aztec::messages::processing::message_context::MessageContext,\n        }\n\n        #[abi(functions)]\n        pub struct process_message_abi {\n            parameters: process_message_parameters,\n        }\n\n        #[aztec::macros::internals_functions_generation::abi_attributes::abi_utility]\n        unconstrained fn process_message(\n            message_ciphertext: BoundedVec<Field, aztec::messages::encoding::MESSAGE_CIPHERTEXT_LEN>,\n            message_context: aztec::messages::processing::message_context::MessageContext,\n        ) {\n            let address = aztec::context::utility_context::UtilityContext::new().this_address();\n\n            aztec::messages::discovery::discover_new_messages(address, _compute_note_hash_and_nullifier);     \n            aztec::messages::discovery::process_message::process_message_ciphertext(\n                address,\n                _compute_note_hash_and_nullifier,\n                message_ciphertext,\n                message_context,\n            );\n        }\n    }\n}\n\n/// Checks if each function in the module is marked with either #[external(...)], #[contract_library_method], or #[test].\n/// Non-macroified functions are not allowed in contracts.\ncomptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_external(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_internal(f)\n            & !is_fn_test(f) {\n            // We  don't suggest that #[contract_library_method] is allowed because we don't want to introduce another\n            // concept\n            panic(\n                f\"Function {name} must be marked as either #[external(...)], #[internal(...)], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "107": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/macros/calls_generation/external_functions_stubs.nr",
      "source": "//! Stubs are auto-generated wrapper functions that provide an ergonomic interface for cross-contract calls.\n//! Instead of manually serializing arguments and creating call interfaces, stubs allow natural syntax, e.g. for\n//! enqueuing calls to public functions:\n//!\n//!   ExternalContract.at(address).some_method(arg1, arg2).enqueue()\n\nuse crate::macros::utils::{AsStrQuote, compute_fn_selector};\nuse protocol_types::meta::utils::derive_serialization_quotes;\nuse std::meta::unquote;\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, u32, Quoted, u32, Field) {\n    // Dear privacy adventurer,\n    // Chances are, you've command+clicked on the name of an external function\n    // call -- seeking to view that function -- only to end up here.\n    // Here's an explanation:\n    // The external contract that you're calling was likely annotated with the `#[aztec]`\n    // annotation -- as all good aztec contracts are. This triggers a macro which generates\n    // a \"contract interface\" for that contract, which is effectively a pretty interface\n    // that gives natural contract calling semantics:\n    //\n    // `MyImportedContract.at(some_address).my_method(arg1, arg2).enqueue();\n    //\n    // Unfortunately, the usage of macros makes it a bit of a black box.\n    // To actually view the target function, you could instead command+click on\n    // `MyImportedContract`, or you can just manually search it.\n    // If you want to view the noir code that gets generated by this macro, you can\n    // use `nargo expand` on your contract.\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n\n    let (serialized_args_array_construction, serialized_args_array_len_quote, serialized_args_array_name) =\n        derive_serialization_quotes(fn_parameters, false);\n    let serialized_args_array_len: u32 =\n        unquote!(quote { ($serialized_args_array_len_quote) as u32 });\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name,\n        serialized_args_array_len, fn_name_str, fn_name_len, fn_selector,\n    )\n}\n\npub(crate) comptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, serialized_args_array_len, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::calls::PrivateCall<$fn_name_len, $serialized_args_array_len, $fn_return_type> {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::calls::PrivateCall::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            )\n        }\n    }\n}\n\npub(crate) comptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, serialized_args_array_len, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::calls::PrivateStaticCall<$fn_name_len, $serialized_args_array_len, $fn_return_type> {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::calls::PrivateStaticCall::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            )\n        }\n    }\n}\n\npub(crate) comptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, serialized_args_array_len, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::calls::PublicCall<$fn_name_len, $serialized_args_array_len, $fn_return_type> {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::calls::PublicCall::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            )\n        }\n    }\n}\n\npub(crate) comptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, serialized_args_array_len, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::calls::PublicStaticCall<$fn_name_len, $serialized_args_array_len, $fn_return_type> {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::calls::PublicStaticCall::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            )\n        }\n    }\n}\n\npub(crate) comptime fn create_utility_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, serialized_args_array_len, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::calls::UtilityCall<$fn_name_len, $serialized_args_array_len, $fn_return_type> {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::calls::UtilityCall::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            )\n        }\n    }\n}\n\n// Self-call stub generation functions for CallSelf, CallSelfStatic, EnqueueSelf and EnqueueSelfStatic structs\n\n// Note: Unlike for the call registry, the self-call registry stubs directly perform the call instead of returning a\n// call interface struct.\n// TODO(F-131): This ^ is confusing and should be reflected in the naming.\n\n/// Creates a stub for calling a private function (or static private function if `is_static` is true) from private\n/// context (for CallSelf<&mut PrivateContext> and CallSelfStatic<&mut PrivateContext>).\npub comptime fn create_private_self_call_stub(f: FunctionDefinition, is_static: bool) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, _, _, _, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> $fn_return_type {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            let args_hash = aztec::hash::hash_args($serialized_args_array_name);\n            aztec::oracle::execution_cache::store($serialized_args_array_name, args_hash);\n            let returns_hash = self.context.call_private_function_with_args_hash(\n                self.address,\n                selector,\n                args_hash,\n                $is_static\n            );\n            returns_hash.get_preimage()\n        }\n    }\n}\n\n// TODO(F-131): Drop the use of the Call in the following 4 functions - it doesn't make sense to not not\n// perform the call directly using the context. I tried doing this already but it became a lot of pain due to the use of\n// slices and them being illegal to return from unconstrained functions. Makes sense to tackle this when cleaning up the\n// call interface code.\n// Note: Once we get rid of the structs we will be able to merge some of the static and non-static stub functions.\n\n/// Creates a stub for calling a public function from public context (for CallSelf<PublicContext>)\npub comptime fn create_public_self_call_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, _, fn_name_str, _, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> $fn_return_type {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            unsafe {\n                aztec::context::calls::PublicCall::new(\n                    self.address,\n                    selector,\n                    $fn_name_str,\n                    $serialized_args_array_name,\n                ).call(self.context)\n            }\n        }\n    }\n}\n\n/// Creates a static stub for calling a public view function from public context (for CallSelfStatic<PublicContext>)\npub comptime fn create_public_self_call_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, _, fn_name_str, _, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> $fn_return_type {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            unsafe {\n                aztec::context::calls::PublicStaticCall::new(\n                    self.address,\n                    selector,\n                    $fn_name_str,\n                    $serialized_args_array_name,\n                ).view(self.context)\n            }\n        }\n    }\n}\n\n/// Creates a static stub for enqueuing a public view function from private context (for EnqueueSelfStatic<&mut PrivateContext>)\npub comptime fn create_public_self_enqueue_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, serialized_args_array_len, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            let interface: aztec::context::calls::PublicStaticCall<$fn_name_len, $serialized_args_array_len, ()> = aztec::context::calls::PublicStaticCall::new(\n                self.address,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            );\n            interface.enqueue_view(self.context);\n        }\n    }\n}\n\n/// Creates a stub for enqueuing a public function from private context (for EnqueueSelf<&mut PrivateContext>)\npub comptime fn create_public_self_enqueue_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, serialized_args_array_len, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            let interface: aztec::context::calls::PublicCall<$fn_name_len, $serialized_args_array_len, ()> = aztec::context::calls::PublicCall::new(\n                self.address,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            );\n            interface.enqueue(self.context);\n        }\n    }\n}\n"
    },
    "110": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr",
      "source": "use crate::macros::internals_functions_generation::external_functions_registry::get_public_functions;\nuse super::utils::compute_fn_selector;\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::utils::get_params_len_quote;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault, panic};\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = get_public_functions(m);\n\n    let unit = get_type::<()>();\n\n    let seen_selectors =\n        &mut UHashMap::<Field, Quoted, BuildHasherDefault<Poseidon2Hasher>>::default();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n        let fn_name = function.name();\n\n        // Since function selectors are computed as the first 4 bytes of the hash of the function signature,\n        // it's possible to have collisions. With the following check, we ensure it doesn't happen within\n        // the same contract.\n        if seen_selectors.contains_key(selector) {\n            let existing_fn = seen_selectors.get(selector).unwrap();\n            panic(\n                f\"Public function selector collision detected between functions '{fn_name}' and '{existing_fn}'\",\n            );\n        }\n        seen_selectors.insert(selector, fn_name);\n\n        let params_len_quote = get_params_len_quote(parameters);\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $params_len_quote] = dep::aztec::context::public_context::calldata_copy(1, $params_len_quote);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index: &mut u32 = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        // We call a function whose name is prefixed with `__aztec_nr_internals__`. This is necessary because the\n        // original function is intentionally made uncallable, preventing direct invocation within the contract.\n        // Instead, a new function with the same name, but prefixed by `__aztec_nr_internals__`, has been generated to\n        // be called here. For more details see the `process_functions` function.\n        let name = f\"__aztec_nr_internals__{fn_name}\".quoted_contents();\n        let args = args.join(quote { , });\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public functions having this attribute.\n            #[aztec::macros::internals_functions_generation::abi_attributes::abi_public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "113": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\n// Used by `create_mark_as_initialized` (you won't find it through searching)\npub fn mark_as_initialized_public(context: PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\n// Used by `create_mark_as_initialized` (you won't find it through searching)\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\n// Used by `create_init_check` (you won't find it through searching)\npub fn assert_is_initialized_public(context: PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\n// Used by `create_init_check` (you won't find it through searching)\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier, context.this_address());\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\n// Used by `create_assert_correct_initializer_args` (you won't find it through searching)\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender().unwrap()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n// Used by `create_assert_correct_initializer_args` (you won't find it through searching)\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender().unwrap()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "117": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/macros/internals_functions_generation/external/helpers.nr",
      "source": "use crate::macros::{\n    functions::auth_registry::AUTHORIZE_ONCE_REGISTRY,\n    utils::{is_fn_initializer, is_fn_only_self, is_fn_view},\n};\nuse std::meta::ctstring::AsCtString;\n\n/// Gathers all attributes relevant to the function's ABI and returns a quote that can be applied to the newly generated\n/// function. We apply the abi marker attributes instead of the original ones (e.g. abi_view instead of view) to avoid\n/// the relevant attribute's functionality from getting triggered.\npub(crate) comptime fn get_abi_relevant_attributes(f: FunctionDefinition) -> Quoted {\n    let mut attributes = quote {};\n\n    if is_fn_view(f) {\n        attributes = quote { $attributes #[aztec::macros::internals_functions_generation::abi_attributes::abi_view] };\n    }\n\n    if is_fn_only_self(f) {\n        attributes = quote { $attributes #[aztec::macros::internals_functions_generation::abi_attributes::abi_only_self] };\n    }\n\n    if is_fn_initializer(f) {\n        attributes = quote { $attributes #[aztec::macros::internals_functions_generation::abi_attributes::abi_initializer] };\n    }\n\n    attributes\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                self.address,\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Injects an authwit verification check of the form:\n/// ```\n///   if (!from.eq(context.msg_sender().unwrap())) {\n///         assert_current_call_valid_authwit::<N>(&mut context, from);\n///     } else {\n///         assert(authwit_nonce, \"Invalid authwit nonce. When 'from' and 'msg_sender' are the same, authwit_nonce must be zero\");\n///     }\n/// ```\n/// where `from` and `authwit_nonce` are the names of the parameters that are expected to be present in the function definition.\n/// This check is injected by the `#[authorize_once(\"from_arg_name\", \"nonce_arg_name\")]`, which allows the user to define\n/// which parameters to use.\n///\n/// # Arguments\n/// * `f` - The function definition to inject the authwit verification check into. The function must have parameters\n///         matching the names specified in the `#[authorize_once]` attribute.\n/// * `is_private` - Whether the function is a private function (`true`) or a public function (`false`). This determines\n///                  which authwit verification method to use: `assert_current_call_valid_authwit` for private functions\n///                  or `assert_current_call_valid_authwit_public` for public functions.\npub(crate) comptime fn create_authorize_once_check(\n    f: FunctionDefinition,\n    is_private: bool,\n) -> Quoted {\n    let maybe_authorize_once_args = AUTHORIZE_ONCE_REGISTRY.get(f);\n    let authorize_once_args = if maybe_authorize_once_args.is_some() {\n        maybe_authorize_once_args.unwrap()\n    } else {\n        // We need to for authorize_once to have already executed so that we can retrieve its params - this depends on\n        // the order in which the attributes are applied.\n        panic(\n            f\"Functions marked with #[authorize_once] must have the #[external(\\\"private\\\")] or #[external(\\\"public\\\")] attribute placed last\",\n        )\n    };\n\n    let (from_arg_name, nonce_arg_name) = authorize_once_args;\n    let name: Quoted = f.name();\n\n    let from_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{from_arg_name}\".quoted_contents());\n    let (from_arg_name_quoted, from_arg_type) = if from_arg_candidates.len() == 1 {\n        from_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {from_arg_name} parameter. Please specify which one to use in #[authorize_once(\\\"...\\\", \\\"authwit_nonce\\\")]\",\n        )\n    };\n    if from_arg_type\n        != quote { dep::protocol_types::address::aztec_address::AztecAddress }.as_type() {\n        panic(\n            f\"Argument {from_arg_name_quoted} in function {name} must be of type AztecAddress, but is of type {from_arg_type}\",\n        )\n    }\n\n    let nonce_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{nonce_arg_name}\".quoted_contents());\n    let (nonce_arg_name_quoted, nonce_arg_type) = if nonce_arg_candidates.len() == 1 {\n        nonce_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {nonce_arg_name}. Please specify which one to use in #[authorize_once(\\\"from\\\", \\\"...\\\")]\",\n        )\n    };\n    if nonce_arg_type != quote { Field }.as_type() {\n        panic(\n            f\"Argument {nonce_arg_name_quoted} in function {name} must be of type Field, but is of type {nonce_arg_type}\",\n        );\n    }\n\n    let nonce_check_quote = f\"{nonce_arg_name_quoted} == 0\".quoted_contents();\n\n    let fn_call = if is_private {\n        let args_len = f.parameters().len();\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit::<$args_len> }\n    } else {\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit_public }\n    };\n    let invalid_nonce_message = f\"Invalid authwit nonce. When '{from_arg_name}' and 'msg_sender' are the same, '{nonce_arg_name}' must be zero\"\n        .as_ctstring()\n        .as_quoted_str();\n    quote {         \n        if (!$from_arg_name_quoted.eq(self.msg_sender().unwrap())) {\n            $fn_call(self.context, $from_arg_name_quoted);\n        } else {\n            assert($nonce_check_quote, $invalid_nonce_message);\n        }\n    }\n}\n"
    },
    "119": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/macros/internals_functions_generation/external/private.nr",
      "source": "use crate::macros::{\n    internals_functions_generation::external::helpers::{\n        create_authorize_once_check, create_message_discovery_call, get_abi_relevant_attributes,\n    },\n    notes::NOTES,\n    utils::{\n        fn_has_authorize_once, fn_has_noinitcheck, fn_has_nophasecheck, is_fn_initializer,\n        is_fn_only_self, is_fn_view, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::utils::derive_serialization_quotes;\nuse std::meta::{ctstring::AsCtString, type_of};\n\npub(crate) comptime fn generate_private_external(f: FunctionDefinition) -> Quoted {\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n\n    let original_params_quotes = original_params\n        .map(|(param_name, param_type)| quote { $param_name: $param_type })\n        .join(quote {, });\n\n    let params = quote { inputs: aztec::context::inputs::private_context_inputs::PrivateContextInputs, $original_params_quotes };\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    let (args_serialization, _, serialized_args_name) =\n        derive_serialization_quotes(original_params, false);\n\n    let storage_init = if module_has_storage {\n        // Contract has Storage defined so we initialize it.\n        quote {\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        // Contract does not have Storage defined, so we set storage to the unit type `()`. ContractSelf requires a\n        // storage struct in its constructor. Using an Option type would lead to worse developer experience and higher\n        // constraint counts so we use the unit type `()` instead.\n        quote {\n            let storage = ();\n        }\n    };\n\n    let contract_self_creation = quote {\n        #[allow(unused_variables)]\n        let mut self = {\n            $args_serialization\n            let args_hash = aztec::hash::hash_args($serialized_args_name);\n            let mut context = aztec::context::private_context::PrivateContext::new(inputs, args_hash);\n            $storage_init\n            let self_address = context.this_address();\n            let call_self: CallSelf<&mut aztec::context::private_context::PrivateContext> = CallSelf { address: self_address, context: &mut context };\n            let enqueue_self: EnqueueSelf<&mut aztec::context::private_context::PrivateContext> = EnqueueSelf { address: self_address, context: &mut context };\n            let call_self_static: CallSelfStatic<&mut aztec::context::private_context::PrivateContext> = CallSelfStatic { address: self_address, context: &mut context };\n            let enqueue_self_static: EnqueueSelfStatic<&mut aztec::context::private_context::PrivateContext> = EnqueueSelfStatic { address: self_address, context: &mut context };\n            let internal: CallInternal<&mut aztec::context::private_context::PrivateContext> = CallInternal { context: &mut context };\n            aztec::contract_self::ContractSelf::new_private(&mut context, storage, call_self, enqueue_self, call_self_static, enqueue_self_static, internal)\n        };\n    };\n\n    let original_function_name = f.name();\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_only_self(f) {\n        let assertion_message =\n            f\"Function {original_function_name} can only be called by the same contract\";\n        quote { assert(self.msg_sender().unwrap() == self.address, $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        let assertion_message = f\"Function {original_function_name} can only be called statically\"\n            .as_ctstring()\n            .as_quoted_str();\n        quote { assert(self.context.inputs.call_context.is_static_call, $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (\n            quote { aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_private(*self.context); },\n            quote { aztec::macros::functions::initialization_utils::mark_as_initialized_private(self.context); },\n        )\n    } else {\n        (quote {}, quote {})\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        quote { aztec::macros::functions::initialization_utils::assert_is_initialized_private(self.context); }\n    } else {\n        quote {}\n    };\n\n    // Phase checks are skipped in functions that request to manually handle phases\n    let initial_phase_store = if fn_has_nophasecheck(f) {\n        quote {}\n    } else {\n        quote { let within_revertible_phase: bool = self.context.in_revertible_phase(); }\n    };\n\n    let no_phase_change_check = if fn_has_nophasecheck(f) {\n        quote {}\n    } else {\n        quote {   \n            assert_eq(\n                within_revertible_phase,\n                self.context.in_revertible_phase(),\n                f\"Phase change detected on function with phase check. If this is expected, use #[nophasecheck]\",\n            ); \n        }\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any. Note that the message\n    // discovery call syncs private events as well. We do not sync those here if there are no notes because we don't\n    // have an API that would access events from private functions.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f, true)\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is serialized and hashed before being passed to the context.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n\n        let (return_serialization, _, serialized_return_name) =\n            derive_serialization_quotes([(return_value_var_name, return_value_type)], false);\n\n        body = body_without_return;\n\n        quote {\n            $return_value_assignment\n            $return_serialization\n            self.context.set_return_hash($serialized_return_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { self.context.finish() };\n\n    // Preserve all attributes that are relevant to the function's ABI.\n    let abi_relevant_attributes = get_abi_relevant_attributes(f);\n\n    let fn_name = f\"__aztec_nr_internals__{original_function_name}\".quoted_contents();\n\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $contract_self_creation\n        $initial_phase_store\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $message_discovery_call\n        $authorize_once_check\n    };\n\n    let body_quote = body.map(|expr| expr.quoted()).join(quote { });\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $no_phase_change_check\n        $context_finish\n    };\n\n    quote {\n        #[aztec::macros::internals_functions_generation::abi_attributes::abi_private]\n        $abi_relevant_attributes\n        fn $fn_name($params) -> return_data aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs {\n            $to_prepend\n            $body_quote\n            $to_append\n        }\n    }\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u16 {\n    fn from(value: u8) -> u16 {\n        value as u16\n    }\n}\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u16> for u32 {\n    fn from(value: u16) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u16> for u64 {\n    fn from(value: u16) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u16> for u128 {\n    fn from(value: u16) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u16> for Field {\n    fn from(value: u16) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i16 {\n    fn from(value: i8) -> i16 {\n        value as i16\n    }\n}\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i16> for i32 {\n    fn from(value: i16) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\n\nimpl From<i16> for i64 {\n    fn from(value: i16) -> i64 {\n        value as i64\n    }\n}\n\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u16 {\n    fn from(value: bool) -> u16 {\n        value as u16\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for u128 {\n    fn from(value: bool) -> u128 {\n        value as u128\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i16 {\n    fn from(value: bool) -> i16 {\n        value as i16\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            let body = if type1 == type2 {\n                quote { self }\n            } else if type1 == quote { bool } {\n                quote { self != 0 }\n            } else {\n                quote { self as $type1 }\n            };\n\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        $body\n                    }\n                }\n            },\n            );\n        }\n    }\n\n    let u_types =\n        [quote { bool }, quote { u8 }, quote { u16 }, quote { u32 }, quote { u64 }, quote { u128 }];\n\n    for type2 in u_types {\n        let body = quote { self as Field };\n\n        impls = impls.push_back(\n            quote {\n                impl AsPrimitive<Field> for $type2 {\n                    fn as_(self) -> Field {\n                        $body\n                    }\n                }\n            },\n        );\n    }\n\n    for type1 in u_types {\n        let body = if type1 == quote { bool } {\n            quote { self != 0 }\n        } else {\n            quote { self as $type1 }\n        };\n\n        impls = impls.push_back(\n            quote {\n                impl AsPrimitive<$type1> for Field {\n                    fn as_(self) -> $type1 {\n                        $body\n                    }\n                }\n            },\n        );\n    }\n\n    impls.join(quote {})\n}\n"
    },
    "120": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/macros/internals_functions_generation/external/public.nr",
      "source": "use crate::macros::{\n    internals_functions_generation::external::helpers::{\n        create_authorize_once_check, get_abi_relevant_attributes,\n    },\n    utils::{\n        fn_has_authorize_once, fn_has_noinitcheck, is_fn_initializer, is_fn_only_self, is_fn_view,\n        module_has_initializer, module_has_storage,\n    },\n};\nuse std::meta::ctstring::AsCtString;\n\npub(crate) comptime fn generate_public_external(f: FunctionDefinition) -> Quoted {\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n\n    let args_len_quote = if original_params.len() == 0 {\n        // If the function has no parameters, we set the args_len to 0.\n        quote { 0 }\n    } else {\n        // The following will give us <type_of_struct_member_1 as Serialize>::N + <type_of_struct_member_2 as Serialize>::N + ...\n        original_params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n            <$param_type as $crate::protocol_types::traits::Serialize>::N\n        }\n            })\n            .join(quote {+})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            let storage = Storage::init(context);\n        }\n    } else {\n        // Contract does not have Storage defined, so we set storage to the unit type `()`. ContractSelf requires a\n        // storage struct in its constructor. Using an Option type would lead to worse developer experience and higher\n        // constraint counts so we use the unit type `()` instead.\n        quote {\n            let storage = ();\n        }\n    };\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let contract_self_creation = quote {\n        #[allow(unused_variables)]\n        let mut self = {\n            let context = dep::aztec::context::public_context::PublicContext::new(|| {\n            // We start from 1 because we skip the selector for the dispatch function.\n            let serialized_args : [Field; $args_len_quote] = dep::aztec::context::public_context::calldata_copy(1, $args_len_quote);\n            dep::aztec::hash::hash_args(serialized_args)\n            });\n            $storage_init\n            let self_address = context.this_address();\n            let call_self: CallSelf<aztec::context::public_context::PublicContext> = CallSelf { address: self_address, context };\n            let call_self_static: CallSelfStatic<aztec::context::public_context::PublicContext> = CallSelfStatic { address: self_address, context };\n            let internal: CallInternal<aztec::context::public_context::PublicContext> = CallInternal { context };\n            aztec::contract_self::ContractSelf::new_public(context, storage, call_self, call_self_static, internal)\n        };\n    };\n\n    let original_function_name = f.name();\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_only_self(f) {\n        let assertion_message =\n            f\"Function {original_function_name} can only be called by the same contract\";\n        quote { assert(self.msg_sender().unwrap() == self.address, $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        let assertion_message = f\"Function {original_function_name} can only be called statically\"\n            .as_ctstring()\n            .as_quoted_str();\n        quote { assert(self.context.is_static_call(), $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (\n            quote { aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_public(self.context); },\n            quote { aztec::macros::functions::initialization_utils::mark_as_initialized_public(self.context); },\n        )\n    } else {\n        (quote {}, quote {})\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        quote { aztec::macros::functions::initialization_utils::assert_is_initialized_public(self.context); }\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f, false)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $contract_self_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let fn_name = f\"__aztec_nr_internals__{original_function_name}\".quoted_contents();\n    let body = f.body();\n    let return_type = f.return_type();\n\n    // New function parameters are the same as the original function's ones.\n    let params = original_params\n        .map(|(param_name, param_type)| quote { $param_name: $param_type })\n        .join(quote {, });\n\n    // Preserve all attributes that are relevant to the function's ABI.\n    let abi_relevant_attributes = get_abi_relevant_attributes(f);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    quote {\n        #[aztec::macros::internals_functions_generation::abi_attributes::abi_public]\n        $abi_relevant_attributes\n        unconstrained fn $fn_name($params) -> pub $return_type {\n            $to_prepend\n            $body\n            $to_append\n        }\n    }\n}\n"
    },
    "121": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/macros/internals_functions_generation/external/utility.nr",
      "source": "use crate::macros::{\n    internals_functions_generation::external::helpers::create_message_discovery_call,\n    utils::module_has_storage,\n};\n\npub(crate) comptime fn generate_utility_external(f: FunctionDefinition) -> Quoted {\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage(f.module()) {\n        quote {\n            let storage = Storage::init(context);\n        }\n    } else {\n        // Contract does not have Storage defined, so we set storage to the unit type `()`. ContractSelf requires a\n        // storage struct in its constructor. Using an Option type would lead to worse developer experience and higher\n        // constraint counts so we use the unit type `()` instead.\n        quote {\n            let storage = ();\n        }\n    };\n\n    // Create utility context\n    let contract_self_creation = quote {\n        #[allow(unused_variables)]\n        let mut self = {\n            let context = dep::aztec::context::utility_context::UtilityContext::new();\n            $storage_init\n            aztec::contract_self::ContractSelf::new_utility(context, storage)\n        };\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process or they may be used to sync private events from TypeScript\n    // (`sync_private_state` function gets invoked by PXE::getPrivateEvents function).\n    let message_discovery_call = create_message_discovery_call();\n\n    // A quote to be injected at the beginning of the function body.\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $contract_self_creation\n        $message_discovery_call\n    };\n\n    let original_function_name = f.name();\n    let fn_name = f\"__aztec_nr_internals__{original_function_name}\".quoted_contents();\n    let body = f.body();\n    let params = f\n        .parameters()\n        .map(|(param_name, param_type)| quote { $param_name: $param_type })\n        .join(quote {, });\n    let return_type = f.return_type();\n\n    quote {\n        #[aztec::macros::internals_functions_generation::abi_attributes::abi_utility]\n        unconstrained fn $fn_name($params) -> pub $return_type {\n            $to_prepend\n            $body\n        }\n    }\n}\n"
    },
    "127": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/macros/notes.nr",
      "source": "use crate::note::note_getter_options::PropertySelector;\nuse std::{collections::bounded_vec::BoundedVec, meta::{ctstring::AsCtString, type_of}};\n\n/// Maximum number of note types within 1 contract.\ncomptime global MAX_NOTE_TYPES: u32 = 128;\n\n/// A BoundedVec containing all the note types within this contract.\npub comptime mut global NOTES: BoundedVec<Type, MAX_NOTE_TYPES> = BoundedVec::new();\n\ncomptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < MAX_NOTE_TYPES,\n        f\"A contract can contain at most {MAX_NOTE_TYPES} different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_type_impl(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n    let typ = s.as_type();\n    let note_type_name: str<_> = f\"{name}\".as_ctstring().as_quoted_str!();\n    let max_note_packed_len = crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                // This static assertion ensures the note's packed length doesn't exceed the maximum allowed size.\n                // While this check would ideally live in the Packable trait implementation, we place it here since\n                // this function is always generated by our macros and the Packable trait implementation is not.\n                // Note: We set the note type name and max packed length as local variables because injecting them\n                // directly into the error message doesn't work.\n                let note_type_name = $note_type_name;\n                let max_note_packed_len: u32 = $max_note_packed_len; // Casting to u32 to avoid the value to be printed in hex.\n                let note_packed_len = <$typ as Packable>::N;\n                std::static_assert(note_packed_len <= $max_note_packed_len, f\"{note_type_name} has a packed length of {note_packed_len} fields, which exceeds the maximum allowed length of {max_note_packed_len} fields\");\n\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, owner: AztecAddress, storage_slot: Field, randomness: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullification: Field, owner: AztecAddress) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullification: Field, owner: AztecAddress) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, owner: aztec::protocol_types::address::AztecAddress, storage_slot: Field, randomness: Field) -> Field {\n                let inputs = aztec::protocol_types::traits::Packable::pack(self).concat( [aztec::protocol_types::traits::ToField::to_field(owner), storage_slot, randomness]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::context::PrivateContext,\n                owner: aztec::protocol_types::address::AztecAddress,\n                note_hash_for_nullification: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullification, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                owner: aztec::protocol_types::address::AztecAddress,\n                note_hash_for_nullification: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullification, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _, _)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _, _) = note_fields[i];\n        let i = i as u8;\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates the core note functionality for a struct:\n///\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - NoteHash trait implementation: Handles note hash and nullifier computation\n///\n/// # Requirements\n///\n/// The note struct must:\n/// - Implement the `Packable` trait\n/// - Not exceed `MAX_NOTE_PACKED_LEN` when packed\n///\n/// # Registration\n///\n/// Registers the note in the global `NOTES` BoundedVec to enable note processing functionality.\n///\n/// # Generated Code\n///\n/// For detailed documentation on the generated implementations, see:\n/// - `generate_note_properties()`\n/// - `generate_note_type_impl()`\n/// - `generate_note_hash_trait_impl()`\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_packable(s);\n\n    // We register the note in the global `NOTES` BoundedVec because we need that information inside the #[aztec] macro\n    // to generate note processing functionality.\n    NOTES.push(s.as_type());\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_type_impl = generate_note_type_impl(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n\n    quote {\n        $note_properties\n        $note_type_impl\n        $note_hash_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n///\n/// # Requirements\n///\n/// The note struct must:\n/// - Implement the `Packable` trait\n/// - Not exceed `MAX_NOTE_PACKED_LEN` when packed\n///\n/// # Registration\n///\n/// Registers the note in the global `NOTES` BoundedVec to enable note processing functionality.\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    assert_has_packable(s);\n\n    // We register the note in the global `NOTES` BoundedVec because we need that information inside the #[aztec] macro\n    // to generate note processing functionality.\n    NOTES.push(s.as_type());\n\n    let note_type_id = get_next_note_type_id();\n    let note_properties = generate_note_properties(s);\n    let note_type_impl = generate_note_type_impl(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_type_impl\n    }\n}\n\n/// Asserts that the given note implements the `Packable` trait.\n///\n/// We require that notes have the `Packable` trait implemented because it is used when emitting a note in a log or as\n/// an offchain message.\ncomptime fn assert_has_packable(note: TypeDefinition) {\n    let packable_constraint =\n        quote { crate::protocol_types::traits::Packable }.as_trait_constraint();\n    let note_name = note.name();\n\n    assert(\n        note.as_type().implements(packable_constraint),\n        f\"{note_name} does not implement Packable trait. Either implement it manually or place #[derive(Packable)] on the note struct before #[note] macro invocation.\",\n    );\n}\n"
    },
    "130": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod private_events;\npub mod private_notes;\npub mod process_message;\n\nuse crate::{\n    messages::{\n        discovery::{\n            private_notes::MAX_NOTE_PACKED_LEN, process_message::process_message_ciphertext,\n        },\n        processing::{\n            get_private_logs, pending_tagged_log::PendingTaggedLog,\n            validate_enqueued_notes_and_events,\n        },\n    },\n    utils::array,\n};\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, note nonce, storage slot and note\n/// type ID and attempts to compute its note hash (not hashed by note nonce nor siloed by address) and inner nullifier\n/// (not siloed by address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, owner, storage_slot, note_type_id, contract_address, randomness, note_nonce| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(owner, storage_slot, randomness);\n///         let note_hash_for_nullification = aztec::note::utils::compute_note_hash_for_nullification(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(note_nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(owner, note_hash_for_nullification);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\npub type ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* owner */ AztecAddress, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* randomness */ Field, /* note nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private logs are downloaded and inspected to find new private\n/// notes, partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Note that the state is synchronized up to the latest block synchronized by PXE. That should be close to the chain\n/// tip as block synchronization is performed before contract function simulation is done.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    // First we process all private logs, which can contain different kinds of messages e.g. private notes, partial\n    // notes, private events, etc.\n    let mut logs = get_private_logs(contract_address);\n    logs.for_each(|i, pending_tagged_log: PendingTaggedLog| {\n        debug_log_format(\n            \"Processing log with tag {0}\",\n            [pending_tagged_log.log.get(0)],\n        );\n\n        // We remove the tag from the pending tagged log and process the message ciphertext contained in it.\n        let message_ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n        process_message_ciphertext(\n            contract_address,\n            compute_note_hash_and_nullifier,\n            message_ciphertext,\n            pending_tagged_log.context,\n        );\n        logs.remove(i);\n    });\n\n    // Then we process all pending partial notes, regardless of whether they were found in the current or previous\n    // executions.\n    partial_notes::fetch_and_process_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    // Finally we validate all notes and events that were found as part of the previous processes, resulting in them\n    // being added to PXE's database and retrievable via oracles (get_notes) and our TS API (PXE::getPrivateEvents).\n    validate_enqueued_notes_and_events(contract_address);\n}\n"
    },
    "131": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub note_nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    owner: AztecAddress,\n    storage_slot: Field,\n    randomness: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given note nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            owner,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            randomness,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    note_nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Found valid nonces for a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullification,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        owner: AztecAddress,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        randomness: Field,\n        note_nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(owner, storage_slot, randomness);\n\n            let note_hash_for_nullification = compute_note_hash_for_nullification(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    owner,\n                    randomness,\n                    storage_slot,\n                    metadata: SettledNoteMetadata::new(note_nonce).into(),\n                },\n            );\n\n            let inner_nullifier =\n                note.compute_nullifier_unconstrained(owner, note_hash_for_nullification);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global OWNER: AztecAddress = AztecAddress::from_field(14);\n    global STORAGE_SLOT: Field = 99;\n    global RANDOMNESS: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            OWNER,\n            STORAGE_SLOT,\n            RANDOMNESS,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            OWNER,\n            STORAGE_SLOT,\n            RANDOMNESS,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        note_nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let note_nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .owner(OWNER)\n            .randomness(RANDOMNESS)\n            .storage_slot(STORAGE_SLOT)\n            .note_metadata(SettledNoteMetadata::new(note_nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(OWNER, STORAGE_SLOT, RANDOMNESS);\n        let unique_note_hash = compute_unique_note_hash(\n            note_nonce,\n            compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash),\n        );\n        let inner_nullifier = note.compute_nullifier_unconstrained(\n            OWNER,\n            compute_note_hash_for_nullification(retrieved_note),\n        );\n\n        NoteAndData { note, note_nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            OWNER,\n            STORAGE_SLOT,\n            RANDOMNESS,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.note_nonce, note_and_data.note_nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            OWNER,\n            STORAGE_SLOT,\n            RANDOMNESS,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == first_note_and_data.note_nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == second_note_and_data.note_nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "132": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::{\n            enqueue_note_for_validation, get_pending_partial_notes_completion_logs,\n            log_retrieval_response::LogRetrievalResponse,\n        },\n    },\n    utils::array,\n};\n\nuse protocol_types::{\n    address::AztecAddress,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, FromField, Serialize},\n};\n\n/// [ owner, storage slot, randomness, note_completion_log_tag ]\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 4;\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_OWNER_INDEX: u32 = 0;\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_STORAGE_SLOT_INDEX: u32 = 1;\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_RANDOMNESS_INDEX: u32 = 2;\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NOTE_COMPLETION_LOG_TAG_INDEX: u32 = 3;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) owner: AztecAddress,\n    pub(crate) storage_slot: Field,\n    pub(crate) randomness: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = decode_partial_note_private_msg(msg_metadata, msg_content, recipient);\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for logs that would result in the completion of pending partial notes, ultimately resulting in the notes\n/// being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    // Each of the pending partial notes might get completed by a log containing its public values. For performance\n    // reasons, we fetch all of these logs concurrently and then process them one by one, minimizing the amount of time\n    // waiting for the node roundtrip.\n    let maybe_completion_logs =\n        get_pending_partial_notes_completion_logs(contract_address, pending_partial_notes);\n\n    // Each entry in the maybe completion logs array corresponds to the entry in the pending partial notes array at the\n    // same index. This means we can use the same index as we iterate through the responses to get both the partial note\n    // and the log that might complete it.\n    assert_eq(maybe_completion_logs.len(), pending_partial_notes.len());\n\n    maybe_completion_logs.for_each(|i, maybe_log: Option<LogRetrievalResponse>| {\n        // We clear the completion logs as we read them so that the array is empty by the time we next query it.\n        // TODO(#14943): use volatile arrays to avoid having to manually clear this.\n        maybe_completion_logs.remove(i);\n\n        let pending_partial_note = pending_partial_notes.get(i);\n\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log plaintext to get\n            // the complete packed content.\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                log.log_payload,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.owner,\n                pending_partial_note.storage_slot,\n                pending_partial_note.randomness,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            // TODO(#11627): is there anything reasonable we can do if we get a log but it doesn't result in a note\n            // being found?\n            if discovered_notes.len() == 0 {\n                panic(\n                    f\"A partial note's completion log did not result in any notes being found - this should never happen\",\n                );\n            }\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                enqueue_note_for_validation(\n                    contract_address,\n                    pending_partial_note.owner,\n                    pending_partial_note.storage_slot,\n                    pending_partial_note.randomness,\n                    discovered_note.note_nonce,\n                    complete_packed_note,\n                    discovered_note.note_hash,\n                    discovered_note.inner_nullifier,\n                    log.tx_hash,\n                    pending_partial_note.recipient,\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    recipient: AztecAddress,\n) -> DeliveredPendingPartialNote {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    // The following ensures that the message content contains at least the minimum number of fields required for a\n    // valid partial note private message. (Refer to the description of\n    // PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN for more information about these fields.)\n    assert(\n        msg_content.len() >= PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 4,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have four fields that are not the partial note's packed representation,\n    // which are the owner, the storage slot, the randomness, and the note completion log tag.\n    let owner = AztecAddress::from_field(msg_content.get(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_OWNER_INDEX,\n    ));\n    let storage_slot = msg_content.get(PARTIAL_NOTE_PRIVATE_MSG_CONTENT_STORAGE_SLOT_INDEX);\n    let randomness = msg_content.get(PARTIAL_NOTE_PRIVATE_MSG_CONTENT_RANDOMNESS_INDEX);\n    let note_completion_log_tag =\n        msg_content.get(PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NOTE_COMPLETION_LOG_TAG_INDEX);\n\n    let packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN> = array::subbvec(\n        msg_content,\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n    );\n\n    DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        owner,\n        storage_slot,\n        randomness,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    }\n}\n"
    },
    "133": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/messages/discovery/private_events.nr",
      "source": "use crate::{\n    event::event_selector::EventSelector,\n    messages::{encoding::MAX_MESSAGE_CONTENT_LEN, processing::enqueue_event_for_validation},\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::GENERATOR_INDEX__EVENT_COMMITMENT,\n    hash::poseidon2_hash_with_separator_bounded_vec, traits::FromField,\n};\n\n/// The number of fields in a private event message content that are not the event's serialized representation\n/// (1 field for randomness).\nglobal PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of an event's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, randomness, etc.).\npub global MAX_EVENT_SERIALIZED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN;\n\npub unconstrained fn process_private_event_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n) {\n    // In the case of events, the msg metadata is the event selector.\n    let event_type_id = EventSelector::from_field(msg_metadata as Field);\n\n    assert(\n        msg_content.len() > PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n        f\"Invalid private event message: all private event messages must have at least {PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private event message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN\",\n    );\n\n    let serialized_event_with_randomness = msg_content;\n\n    let event_commitment = poseidon2_hash_with_separator_bounded_vec(\n        serialized_event_with_randomness,\n        GENERATOR_INDEX__EVENT_COMMITMENT,\n    );\n\n    // Randomness was injected into the event payload in `emit_event_in_private` but we have already used it\n    // to compute the event commitment, so we can safely discard it now.\n    let serialized_event = array::subbvec(\n        serialized_event_with_randomness,\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n    );\n\n    enqueue_event_for_validation(\n        contract_address,\n        event_type_id,\n        serialized_event,\n        event_commitment,\n        tx_hash,\n        recipient,\n    );\n}\n"
    },
    "134": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::enqueue_note_for_validation,\n    },\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n    traits::FromField,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\n// See the call to `std::static_assert` below to see what's in these fields.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 3;\nglobal PRIVATE_NOTE_MSG_CONTENT_OWNER_INDEX: u32 = 0;\nglobal PRIVATE_NOTE_MSG_CONTENT_STORAGE_SLOT_INDEX: u32 = 1;\nglobal PRIVATE_NOTE_MSG_CONTENT_RANDOMNESS_INDEX: u32 = 2;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, randomness, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, owner, storage_slot, randomness, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        owner,\n        storage_slot,\n        randomness,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    owner: AztecAddress,\n    storage_slot: Field,\n    randomness: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        owner,\n        storage_slot,\n        randomness,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        enqueue_note_for_validation(\n            contract_address,\n            owner,\n            storage_slot,\n            randomness,\n            discovered_note.note_nonce,\n            packed_note,\n            discovered_note.note_hash,\n            discovered_note.inner_nullifier,\n            tx_hash,\n            recipient,\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, AztecAddress, Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 3,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the note's packed representation, which are the owner and the storage slot.\n    let owner = AztecAddress::from_field(msg_content.get(PRIVATE_NOTE_MSG_CONTENT_OWNER_INDEX));\n    let storage_slot = msg_content.get(PRIVATE_NOTE_MSG_CONTENT_STORAGE_SLOT_INDEX);\n    let randomness = msg_content.get(PRIVATE_NOTE_MSG_CONTENT_RANDOMNESS_INDEX);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, owner, storage_slot, randomness, packed_note)\n}\n"
    },
    "135": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/messages/discovery/process_message.nr",
      "source": "use crate::messages::{\n    discovery::{\n        ComputeNoteHashAndNullifier, partial_notes::process_partial_note_private_msg,\n        private_events::process_private_event_msg, private_notes::process_private_note_msg,\n    },\n    encoding::{decode_message, MESSAGE_CIPHERTEXT_LEN, MESSAGE_PLAINTEXT_LEN},\n    encryption::{aes128::AES128, message_encryption::MessageEncryption},\n    msg_type::{\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n    },\n    processing::message_context::MessageContext,\n};\n\nuse protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\n/// Processes a message that can contain notes, partial notes, or events.\n///\n/// Notes result in nonce discovery being performed prior to delivery, which requires knowledge of the transaction hash\n/// in which the notes would've been created (typically the same transaction in which the log was emitted), along with\n/// the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier` function. Once\n/// discovered, the notes are enqueued for validation.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\n///\n/// Events are processed by computing an event commitment from the serialized event data and its randomness field, then\n/// enqueueing the event data and commitment for validation.\npub unconstrained fn process_message_ciphertext<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_ciphertext: BoundedVec<Field, MESSAGE_CIPHERTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    let message_plaintext_option = AES128::decrypt(message_ciphertext, message_context.recipient);\n\n    if message_plaintext_option.is_some() {\n        process_message_plaintext(\n            contract_address,\n            compute_note_hash_and_nullifier,\n            message_plaintext_option.unwrap(),\n            message_context,\n        );\n    } else {\n        debug_log_format(\n            \"Found invalid message from tx {0}, ignoring\",\n            [message_context.tx_hash],\n        );\n    }\n}\n\npub unconstrained fn process_message_plaintext<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_plaintext: BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    // The first thing to do after decrypting the message is to determine what type of message we're processing. We\n    // have 3 message types: private notes, partial notes and events.\n\n    // We decode the message to obtain the message type id, metadata and content.\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(message_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            message_context.tx_hash,\n            message_context.unique_note_hashes_in_tx,\n            message_context.first_nullifier_in_tx,\n            message_context.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        process_private_event_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n            message_context.tx_hash,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "136": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::utils::array;\nuse protocol_types::constants::PRIVATE_LOG_CIPHERTEXT_LEN;\n\n// We reassign to the constant here to communicate the distinction between a log and a message. In Aztec.nr, unlike in\n// protocol circuits, we have a concept of a message that can be emitted either as a private log or as an offchain\n// message. Message is a piece of data that is to be eventually delivered to a contract via the `process_message(...)`\n// utility function function that is injected by the #[aztec] macro.\n// Note: PRIVATE_LOG_CIPHERTEXT_LEN is an amount of fields,\n// so MESSAGE_CIPHERTEXT_LEN is the size of the message in fields.\npub global MESSAGE_CIPHERTEXT_LEN: u32 = PRIVATE_LOG_CIPHERTEXT_LEN;\n\n// TODO(#12750): The global variables below should not be here as they are AES128 specific.\n// ciphertext_length (2) + 14 bytes pkcs#7 AES padding.\npub(crate) global HEADER_CIPHERTEXT_SIZE_IN_BYTES: u32 = 16;\n\npub global EPH_PK_X_SIZE_IN_FIELDS: u32 = 1;\npub global EPH_PK_SIGN_BYTE_SIZE_IN_BYTES: u32 = 1;\n\n// (17 - 1) * 31 - 16 - 1 = 479\n// Note: We multiply by 31 because ciphertext bytes are stored in fields using bytes_to_fields, which packs 31 bytes per\n// field (since a Field is ~254 bits and can safely store 31 whole bytes).\nglobal MESSAGE_PLAINTEXT_SIZE_IN_BYTES: u32 = (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS)\n    * 31\n    - HEADER_CIPHERTEXT_SIZE_IN_BYTES\n    - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES;\n// The plaintext bytes represent Field values that were originally serialized using fields_to_bytes, which converts each\n// Field to 32 bytes. To convert the plaintext bytes back to fields, we divide by 32.\n// 479 / 32 = 14\npub global MESSAGE_PLAINTEXT_LEN: u32 = MESSAGE_PLAINTEXT_SIZE_IN_BYTES / 32;\n\npub global MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MESSAGE_PLAINTEXT_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "137": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n    public_keys::AddressPoint,\n};\n\nuse crate::{\n    keys::{ecdh_shared_secret::derive_ecdh_shared_secret, ephemeral::generate_ephemeral_key_pair},\n    messages::{\n        encoding::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, MESSAGE_CIPHERTEXT_LEN, MESSAGE_PLAINTEXT_LEN,\n        },\n        encryption::message_encryption::MessageEncryption,\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__message_bytes__from_PT,\n            get_arr_of_size__message_bytes_padding__from_PT,\n        },\n    },\n    oracle::{\n        aes128_decrypt::aes128_decrypt_oracle, random::random, shared_secret::get_shared_secret,\n    },\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\n/**\n * Computes N close-to-uniformly-random 256 bits from a given ECDH shared_secret.\n *\n * NEVER re-use the same iv and sym_key.\n * DO NOT call this function more than once with the same shared_secret.\n *\n * This function is only known to be safe if shared_secret is computed by combining a \n * random ephemeral key with an address point. See big comment within the body of the function.\n * See big comment within the body of the function.\n */\nfn extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [[u8; 32]; N] {\n    /*\n     * Unsafe because of https://eprint.iacr.org/2010/264.pdf Page 13, Lemma 2 (and the * two paragraphs below it).\n     *\n     * If you call this function, you need to be careful and aware of how the arg\n     * `shared_secret` has been derived.\n     *\n     * The paper says that the way you derive aes keys and IVs should be fine with poseidon2\n     * (modelled as a RO), as long as you _don't_ use Poseidon2 as a PRG to generate the * two exponents x & y which multiply to the shared secret S:\n     *\n     * S = [x*y]*G.\n     *\n     * (Otherwise, you would have to \"key\" poseidon2, i.e. generate a uniformly string K\n     * which can be public and compute Hash(x) as poseidon(K,x)).\n     * In that lemma, k would be 2*254=508, and m would be the number of points on the * grumpkin curve (which is close to r according to the Hasse bound).\n     *\n     * Our shared secret S is [esk * address_sk] * G, and the question is: * Can we compute hash(S) using poseidon2 instead of sha256?\n     *\n     * Well, esk is random and not generated with poseidon2, so that's good.\n     * What about address_sk?\n     * Well, address_sk = poseidon2(stuff) + ivsk, so there was some\n     * discussion about whether address_sk is independent of poseidon2.\n     * Given that ivsk is random and independent of poseidon2, the address_sk is also\n     * independent of poseidon2.\n     *\n     * Tl;dr: we believe it's safe to hash S = [esk * address_sk] * G using poseidon2,\n     * in order to derive a symmetric key.\n     *\n     * If you're calling this function for a differently-derived `shared_secret`, be\n     * careful.\n     *\n     */\n\n    /* The output of this function needs to be 32 random bytes.\n     * A single field won't give us 32 bytes of entropy.\n     * So we compute two \"random\" fields, by poseidon-hashing with two different\n     * generators.\n     * We then extract the last 16 (big endian) bytes of each \"random\" field.\n     * Note: we use to_be_bytes because it's slightly more efficient. But we have to\n     * be careful not to take bytes from the \"big end\", because the \"big\" byte is\n     * not uniformly random over the byte: it only has < 6 bits of randomness, because\n     * it's the big end of a 254-bit field element.\n     */\n\n    let mut all_bytes: [[u8; 32]; N] = std::mem::zeroed();\n    // We restrict N to be < 2^8, because of how we compute the domain separator\n    // from k below (where k <= N must be 8 bits). In practice, it's extremely\n    // unlikely that an app will want to compute >= 256 ciphertexts.\n    std::static_assert(N < 256, \"N too large\");\n    for k in 0..N {\n        // We augment the domain separator with the loop index, so that we can\n        // generate N lots of randomness.\n        let k_shift = (k as u16 << 8);\n        let separator_1 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY as u16;\n        let separator_2 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY_2 as u16;\n\n        let rand1: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_1);\n        let rand2: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_2);\n\n        let rand1_bytes: [u8; 32] = rand1.to_be_bytes();\n        let rand2_bytes: [u8; 32] = rand2.to_be_bytes();\n\n        let mut bytes: [u8; 32] = [0; 32];\n        for i in 0..16 {\n            // We take bytes from the \"little end\" of the be-bytes arrays:\n            let j = 32 - i - 1;\n            bytes[i] = rand1_bytes[j];\n            bytes[16 + i] = rand2_bytes[j];\n        }\n\n        all_bytes[k] = bytes;\n    }\n\n    all_bytes\n}\n\nfn derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits<let N: u32>(\n    many_random_256_bits: [[u8; 32]; N],\n) -> [([u8; 16], [u8; 16]); N] {\n    // Many (sym_key, iv) pairs:\n    let mut many_pairs: [([u8; 16], [u8; 16]); N] = std::mem::zeroed();\n    for k in 0..N {\n        let random_256_bits = many_random_256_bits[k];\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n        for i in 0..16 {\n            sym_key[i] = random_256_bits[i];\n            iv[i] = random_256_bits[i + 16];\n        }\n        many_pairs[k] = (sym_key, iv);\n    }\n\n    many_pairs\n}\n\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [([u8; 16], [u8; 16]); N] {\n    let many_random_256_bits: [[u8; 32]; N] = extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe(\n        shared_secret,\n    );\n\n    derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits(many_random_256_bits)\n}\n\npub struct AES128 {}\n\nimpl MessageEncryption for AES128 {\n    fn encrypt<let PlaintextLen: u32>(\n        plaintext: [Field; PlaintextLen],\n        recipient: AztecAddress,\n    ) -> [Field; MESSAGE_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the message in `do_process_message`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        // TODO (#17158): Currently we unwrap the Option returned by derive_ecdh_shared_secret.\n        // We need to handle the case where the ephemeral public key is invalid to prevent potential DoS vectors.\n        let ciphertext_shared_secret = derive_ecdh_shared_secret(\n            eph_sk,\n            recipient\n                .to_address_point()\n                .unwrap_or(\n                    // Safety: if the recipient is an invalid address, then it is not possible to encrypt a message for\n                    // them because we cannot establish a shared secret. This is never expected to occur during normal\n                    // operation. However, it is technically possible for us to receive an invalid address, and we must\n                    // therefore handle it.\n                    // We could simply fail, but that'd introduce a potential security issue in which an attacker forces\n                    // a contract to encrypt a message for an invalid address, resulting in an impossible transaction -\n                    // this is sometimes called a 'king of the hill' attack.\n                    // We choose instead to not fail and encrypt the plaintext regardless using the shared secret that\n                    // results from a random valid address. The sender is free to choose this address and hence shared\n                    // secret, but this has no security implications as they already know not only the full plaintext\n                    // but also the ephemeral private key anyway.\n                    unsafe { random_address_point() },\n                )\n                .inner,\n        );\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        // It is safe to call the `unsafe` function here, because we know the `shared_secret`\n        // was derived using an AztecAddress (the recipient). See the block comment\n        // at the start of this unsafe target function for more info.\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, body_iv, body_sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        std::static_assert(\n            ciphertext_bytes.len() == 16 * (1 + (PlaintextLen * 32) / 16),\n            \"unexpected ciphertext length\",\n        );\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, header_iv, header_sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        std::static_assert(\n            header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES,\n            \"unexpected ciphertext header length\",\n        );\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut message_bytes_padding_to_mult_31 =\n            get_arr_of_size__message_bytes_padding__from_PT::<PlaintextLen * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        message_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut message_bytes = get_arr_of_size__message_bytes__from_PT::<PlaintextLen * 32>();\n\n        std::static_assert(\n            message_bytes.len() % 31 == 0,\n            \"Unexpected error: message_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        message_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            message_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            message_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..message_bytes_padding_to_mult_31.len() {\n            message_bytes[offset + i] = message_bytes_padding_to_mult_31[i];\n        }\n        offset += message_bytes_padding_to_mult_31.len();\n\n        // Ideally we would be able to have a static assert where we check that the offset would be such that we've\n        // written to the entire log_bytes array, but we cannot since Noir does not treat the offset as a comptime\n        // value (despite the values that it goes through being known at each stage). We instead check that the\n        // computation used to obtain the offset computes the expected value (which we _can_ do in a static check), and\n        // then add a cheap runtime check to also validate that the offset matches this.\n        std::static_assert(\n            1\n                + header_ciphertext_bytes.len()\n                + ciphertext_bytes.len()\n                + message_bytes_padding_to_mult_31.len()\n                == message_bytes.len(),\n            \"unexpected message length\",\n        );\n        assert(offset == message_bytes.len(), \"unexpected encrypted message length\");\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make messages produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let message_bytes_as_fields = bytes_to_fields(message_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final message\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; MESSAGE_CIPHERTEXT_LEN] = [0; MESSAGE_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..message_bytes_as_fields.len() {\n            ciphertext[offset + i] = message_bytes_as_fields[i];\n        }\n        offset += message_bytes_as_fields.len();\n\n        for i in offset..MESSAGE_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the message\n            // (all the \"real\" message fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the message to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt(\n        ciphertext: BoundedVec<Field, MESSAGE_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> Option<BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, MESSAGE_CIPHERTEXT_LEN, MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) != 0;\n\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point. This may fail\n        // however, as not all x-coordinates are on the curve. In that case, we simply return `Option::none`.\n        point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool).map(|eph_pk| {\n            // Derive shared secret\n            let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n\n            // Derive symmetric keys:\n            let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n                ciphertext_shared_secret,\n            );\n            let (body_sym_key, body_iv) = pairs[0];\n            let (header_sym_key, header_iv) = pairs[1];\n\n            // Extract the header ciphertext\n            let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n            let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n                array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n            // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n            // with messages with unknown length at compile time. This would not be necessary here as the header ciphertext length\n            // is fixed. But we do it anyway to not have to have duplicate oracles.\n            let header_ciphertext_bvec =\n                BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n            // Decrypt header\n            let header_plaintext =\n                aes128_decrypt_oracle(header_ciphertext_bvec, header_iv, header_sym_key);\n\n            // Extract ciphertext length from header (2 bytes, big-endian)\n            let ciphertext_length =\n                ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n            // Extract and decrypt main ciphertext\n            let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n            let ciphertext_with_padding: [u8; (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n                array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n            let ciphertext: BoundedVec<u8, (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n                BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n            // Decrypt main ciphertext and return it\n            let plaintext_bytes = aes128_decrypt_oracle(ciphertext, body_iv, body_sym_key);\n\n            // Each field of the original note message was serialized to 32 bytes so we convert the bytes back to fields.\n            fields_from_bytes(plaintext_bytes)\n        })\n    }\n}\n\n/// Produces a random valid address point, i.e. one that is on the curve. This is equivalent to calling\n/// [AztecAddress::to_address_point] on a random valid address.\nunconstrained fn random_address_point() -> AddressPoint {\n    let mut result = std::mem::zeroed();\n\n    loop {\n        // We simply produce random x coordinates until we find one that is on the curve. About half of the x\n        // coordinates fulfill this condition, so this should only take a few iterations at most.\n        let x_coord = random();\n        let point = point_from_x_coord_and_sign(x_coord, true);\n        if point.is_some() {\n            result = AddressPoint { inner: point.unwrap() };\n            break;\n        }\n    }\n\n    result\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret,\n        messages::{\n            encoding::MESSAGE_PLAINTEXT_LEN, encryption::message_encryption::MessageEncryption,\n        },\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::{AES128, random_address_point};\n    use protocol_types::{address::AztecAddress, traits::FromField};\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_deterministic() {\n        let env = TestEnvironment::new();\n\n        // Message decryption requires oracles that are only available during private execution\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3];\n\n            let recipient = AztecAddress::from_field(\n                0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n            );\n\n            // Mock random values for deterministic test\n            let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(eph_sk).times(1);\n\n            let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(randomness).times(1000000);\n\n            let _ = OracleMock::mock(\"privateGetNextAppTagAsSender\").returns(42);\n\n            // Encrypt the message\n            let encrypted_message = BoundedVec::from_array(AES128::encrypt(plaintext, recipient));\n\n            // Mock shared secret for deterministic test\n            let shared_secret = derive_ecdh_shared_secret(\n                EmbeddedCurveScalar::from_field(eph_sk),\n                recipient.to_address_point().unwrap().inner,\n            );\n\n            let _ = OracleMock::mock(\"utilityGetSharedSecret\").returns(shared_secret);\n\n            // Decrypt the message\n            let decrypted = AES128::decrypt(encrypted_message, recipient).unwrap();\n\n            // The decryption function spits out a BoundedVec because it's designed to work with messages with unknown length\n            // at compile time. For this reason we need to convert the original input to a BoundedVec.\n            let plaintext_bvec = BoundedVec::<Field, MESSAGE_PLAINTEXT_LEN>::from_array(plaintext);\n\n            // Verify decryption matches original plaintext\n            assert_eq(\n                decrypted,\n                plaintext_bvec,\n                \"Decrypted bytes should match original plaintext\",\n            );\n\n            // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n            // static methods of the struct).\n            let _ = AES128 {};\n        });\n    }\n\n    #[test]\n    unconstrained fn encrypt_decrypt_random() {\n        // Same as `encrypt_decrypt_deterministic`, except we don't mock any of the oracles and rely on\n        // `TestEnvironment` instead.\n        let mut env = TestEnvironment::new();\n\n        let recipient = env.create_light_account();\n\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3];\n            let ciphertext = AES128::encrypt(plaintext, recipient);\n\n            assert_eq(\n                AES128::decrypt(BoundedVec::from_array(ciphertext), recipient).unwrap(),\n                BoundedVec::from_array(plaintext),\n            );\n        });\n    }\n\n    #[test]\n    unconstrained fn encrypt_to_invalid_address() {\n        // x = 3 is a non-residue for this curve, resulting in an invalid address\n        let invalid_address = AztecAddress { inner: 3 };\n\n        // We just test that we produced some output and did not crash - the result is gibberish as it is encrypted\n        // using a public key for which we do not know the private key.\n        let _ = AES128::encrypt([1, 2, 3, 4], invalid_address);\n    }\n\n    #[test]\n    unconstrained fn random_address_point_produces_valid_points() {\n        // About half of random addresses are invalid, so testing just a couple gives us high confidence that\n        // `random_address_point` is indeed producing valid addresses.\n        for _ in 0..10 {\n            let random_address = AztecAddress { inner: random_address_point().inner.x };\n            assert(random_address.to_address_point().is_some());\n        }\n    }\n\n    #[test]\n    unconstrained fn decrypt_invalid_ephemeral_public_key() {\n        let mut env = TestEnvironment::new();\n\n        let recipient = env.create_light_account();\n\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3, 4];\n            let ciphertext = AES128::encrypt(plaintext, recipient);\n\n            // The first field of the ciphertext is the x-coordinate of the ephemeral public key. We set it to a known\n            // non-residue (3), causing `decrypt` to fail to produce a decryption shared secret.\n            let mut bad_ciphertext = BoundedVec::from_array(ciphertext);\n            bad_ciphertext.set(0, 3);\n\n            assert(AES128::decrypt(bad_ciphertext, recipient).is_none());\n        });\n    }\n}\n"
    },
    "154": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/messages/processing/mod.nr",
      "source": "pub(crate) mod event_validation_request;\npub mod message_context;\npub(crate) mod note_validation_request;\npub(crate) mod log_retrieval_request;\npub(crate) mod log_retrieval_response;\npub(crate) mod pending_tagged_log;\n\nuse crate::{\n    capsules::CapsuleArray,\n    event::event_selector::EventSelector,\n    messages::{\n        discovery::{\n            partial_notes::DeliveredPendingPartialNote, private_events::MAX_EVENT_SERIALIZED_LEN,\n            private_notes::MAX_NOTE_PACKED_LEN,\n        },\n        processing::{\n            log_retrieval_request::LogRetrievalRequest,\n            log_retrieval_response::LogRetrievalResponse,\n            note_validation_request::NoteValidationRequest, pending_tagged_log::PendingTaggedLog,\n        },\n    },\n    oracle,\n};\nuse event_validation_request::EventValidationRequest;\nuse protocol_types::{address::AztecAddress, hash::sha256_to_field};\n\n// Base slot for the pending tagged log array to which the fetch_tagged_logs oracle inserts found private logs.\nglobal PENDING_TAGGED_LOG_ARRAY_BASE_SLOT: Field =\n    sha256_to_field(\"AZTEC_NR::PENDING_TAGGED_LOG_ARRAY_BASE_SLOT\".as_bytes());\n\nglobal NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\n/// Searches for private logs emitted by `contract_address` that might contain messages for one of the local accounts,\n/// and stores them in a `CapsuleArray` which is then returned.\npub(crate) unconstrained fn get_private_logs(\n    contract_address: AztecAddress,\n) -> CapsuleArray<PendingTaggedLog> {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `fetchTaggedLogs`\n    // oracle. This makes PXE synchronize tags, download logs and store the pending tagged logs in a capsule array.\n    oracle::message_processing::fetch_tagged_logs(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    CapsuleArray::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT)\n}\n\n/// Enqueues a note for validation by PXE, so that it becomes aware of a note's existence allowing for later retrieval\n/// via `get_notes` oracle. The note will be scoped to `contract_address`, meaning other contracts will not be able to\n/// access it unless authorized.\n///\n/// In order for the note validation and insertion to occur, `validate_enqueued_notes_and_events` must be later called.\n/// For optimal performance, accumulate as many note validation requests as possible and then validate them all at the\n/// end (which results in PXE minimizing the number of network round-trips).\n///\n/// The `packed_note` is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `owner` is the address used in note hash and nullifier computation, often requiring knowledge of their\n/// nullifier secret key.\n///\n/// `recipient` is the account to which the note message was delivered (i.e. the address the message was encrypted to).\n/// This determines which PXE account can see the note - other accounts will not be able to access it (e.g. other\n/// accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized. In most\n/// cases `recipient` equals `owner`, but they can differ in scenarios like delegated discovery.\npub(crate) unconstrained fn enqueue_note_for_validation(\n    contract_address: AztecAddress,\n    owner: AztecAddress,\n    storage_slot: Field,\n    randomness: Field,\n    note_nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `NoteValidationRequest`\n    CapsuleArray::at(contract_address, NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        NoteValidationRequest {\n            contract_address,\n            owner,\n            storage_slot,\n            randomness,\n            note_nonce,\n            packed_note,\n            note_hash,\n            nullifier,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Enqueues an event for validation by PXE, so that it can be efficiently validated and then inserted into the event\n/// store.\n///\n/// In order for the event validation and insertion to occur, `validate_enqueued_notes_and_events` must be later\n/// called. For optimal performance, accumulate as many event validation requests as possible and then validate them\n/// all at the end (which results in PXE minimizing the number of network round-trips).\npub(crate) unconstrained fn enqueue_event_for_validation(\n    contract_address: AztecAddress,\n    event_type_id: EventSelector,\n    serialized_event: BoundedVec<Field, MAX_EVENT_SERIALIZED_LEN>,\n    event_commitment: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `EventValidationRequest`\n    CapsuleArray::at(contract_address, EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        EventValidationRequest {\n            contract_address,\n            event_type_id,\n            serialized_event,\n            event_commitment,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Validates all note and event validation requests enqueued via `enqueue_note_for_validation` and\n/// `enqueue_event_for_validation`, inserting them into the note database and event store respectively, making them\n/// queryable via `get_notes` oracle and our TS API (PXE::getPrivateEvents).\n///\n/// This automatically clears both validation request queues, so no further work needs to be done by the caller.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(contract_address: AztecAddress) {\n    oracle::message_processing::validate_enqueued_notes_and_events(\n        contract_address,\n        NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n        EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n    );\n}\n\n/// Efficiently queries the node for logs that result in the completion of all `DeliveredPendingPartialNote`s stored in\n/// a `CapsuleArray` by performing all node communication concurrently. Returns a second `CapsuleArray` with Options for\n/// the responses that correspond to the pending partial notes at the same index.\n///\n/// For example, given an array with pending partial notes `[ p1, p2, p3 ]`, where `p1` and `p3` have corresponding\n/// completion logs but `p2` does not, the returned `CapsuleArray` will have contents\n/// `[some(p1_log), none(), some(p3_log)]`.\npub(crate) unconstrained fn get_pending_partial_notes_completion_logs(\n    contract_address: AztecAddress,\n    pending_partial_notes: CapsuleArray<DeliveredPendingPartialNote>,\n) -> CapsuleArray<Option<LogRetrievalResponse>> {\n    let log_retrieval_requests =\n        CapsuleArray::at(contract_address, LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT);\n\n    // We create a LogRetrievalRequest for each PendingPartialNote in the CapsuleArray. Because we need the indices in\n    // the request array to match the indices in the partial note array, we can't use CapsuleArray::for_each, as that\n    // function has arbitrary iteration order. Instead, we manually iterate the array from the beginning and push into\n    // the requests array, which we expect to be empty.\n    let mut i = 0;\n    let pending_partial_notes_count = pending_partial_notes.len();\n    while i < pending_partial_notes_count {\n        let pending_partial_note = pending_partial_notes.get(i);\n        log_retrieval_requests.push(\n            LogRetrievalRequest {\n                contract_address,\n                unsiloed_tag: pending_partial_note.note_completion_log_tag,\n            },\n        );\n        i += 1;\n    }\n\n    oracle::message_processing::bulk_retrieve_logs(\n        contract_address,\n        LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT,\n        LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT,\n    );\n\n    CapsuleArray::at(contract_address, LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT)\n}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars, true)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n    predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        let mut result = if double_predicate {\n            // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n            embedded_curve_add_unsafe(point1, point1)\n        } else {\n            let point1_1 = EmbeddedCurvePoint {\n                x: point1.x + (x_coordinates_match as Field),\n                y: point1.y,\n                is_infinite: false,\n            };\n            let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n            // point1_1 is guaranteed to have a different abscissa than point2:\n            // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n            // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n            // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n            // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n            // therefore we only want to do this if we need the result, otherwise it needs to be eliminated as a dead instruction, lest we want the circuit to fail.\n            embedded_curve_add_unsafe(point1_1, point2_1)\n        };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n    _predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    // Ensure is_infinite is comptime\n    let point1_1 = EmbeddedCurvePoint { x: point1.x, y: point1.y, is_infinite: false };\n    let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n    embedded_curve_add_unsafe(point1_1, point2_1)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2, true)[0]\n}\n"
    },
    "166": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::{Deserialize, Packable, Serialize};\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, note_nonce: Field },\n//   Settled{ note_nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Deserialize, Eq, Serialize, Packable)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_note_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_note_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_note_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_note_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_note_nonce }\n            }\n        } else if maybe_note_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_note_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_note_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_note_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.note_nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.note_nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    note_nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    note_nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n"
    },
    "169": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::{note_hash_read::NoteHashRead, PrivateContext},\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_read<Note>(retrieved_note: RetrievedNote<Note>) -> NoteHashRead\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(\n        retrieved_note.owner,\n        retrieved_note.storage_slot,\n        retrieved_note.randomness,\n    );\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        NoteHashRead::new_settled(compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().note_nonce(),\n            siloed_note_hash,\n        ))\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        NoteHashRead::new_transient(note_hash, retrieved_note.contract_address)\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullification<Note>(retrieved_note: RetrievedNote<Note>) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullification_from_note_hash_read(\n        retrieved_note,\n        compute_note_hash_read(retrieved_note),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullification`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_read` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullification_from_note_hash_read<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_read: NoteHashRead,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash = compute_siloed_note_hash(\n            note_hash_read.contract_address().unwrap(), // Safe since contract address must be populated for pending note reads.\n            note_hash_read.note_hash(),\n        );\n        let note_nonce = retrieved_note.metadata.to_pending_previous_phase().note_nonce();\n\n        compute_unique_note_hash(note_nonce, siloed_note_hash)\n    } else {\n        note_hash_read.note_hash()\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullification = compute_note_hash_for_nullification(retrieved_note);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(\n        context,\n        retrieved_note.owner,\n        note_hash_for_nullification,\n    );\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\npub(crate) global PLO: Field = 53438638232309528389504892708671455233;\npub(crate) global PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n\n    #[test]\n    fn check_decompose_edge_cases() {\n        assert_eq(decompose(0), (0, 0));\n        assert_eq(decompose(TWO_POW_128 - 1), (TWO_POW_128 - 1, 0));\n        assert_eq(decompose(TWO_POW_128 + 1), (1, 1));\n        assert_eq(decompose(TWO_POW_128 * 2), (0, 2));\n        assert_eq(decompose(TWO_POW_128 * 2 + 0x1234567890), (0x1234567890, 2));\n    }\n\n    #[test]\n    fn check_decompose_large_values() {\n        let large_field = 0xffffffffffffffff;\n        let (lo, hi) = decompose(large_field);\n        assert_eq(large_field, lo + TWO_POW_128 * hi);\n\n        let large_value = large_field - TWO_POW_128;\n        let (lo2, hi2) = decompose(large_value);\n        assert_eq(large_value, lo2 + TWO_POW_128 * hi2);\n    }\n\n    #[test]\n    fn check_lt_comprehensive() {\n        assert(lt(0, 1));\n        assert(!lt(1, 0));\n        assert(!lt(0, 0));\n        assert(!lt(42, 42));\n\n        assert(lt(TWO_POW_128 - 1, TWO_POW_128));\n        assert(!lt(TWO_POW_128, TWO_POW_128 - 1));\n    }\n}\n"
    },
    "173": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(privateCallPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "174": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize,\n{\n    let serialized_option = load_oracle(contract_address, slot, <T as Deserialize>::N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(utilityStoreCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(utilityLoadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(utilityDeleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(utilityCopyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), value);\n        });\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            let new_value = MockStruct::new(7, 8);\n            store(contract_address, SLOT, new_value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n        });\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n            delete(contract_address, SLOT);\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            delete(contract_address, SLOT);\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 5;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 10;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 1;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 2;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n            assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n            assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 2;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 1;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n            assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n            assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n        });\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            copy(contract_address, SLOT, SLOT, 1);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let value = MockStruct::new(5, 6);\n            store(other_contract_address, SLOT, value);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let _: Option<MockStruct> = load(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            delete(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            copy(other_contract_address, SLOT, SLOT, 0);\n        });\n    }\n}\n"
    },
    "175": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(privateNotifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(privateNotifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(privateNotifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n\npub unconstrained fn is_side_effect_counter_revertible_oracle_wrapper(counter: u32) -> bool {\n    is_side_effect_counter_revertible_oracle(counter)\n}\n\n#[oracle(privateIsSideEffectCounterRevertible)]\nunconstrained fn is_side_effect_counter_revertible_oracle(counter: u32) -> bool {}\n"
    },
    "176": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use crate::context::utility_context::UtilityContext;\n\n#[oracle(utilityGetUtilityContext)]\nunconstrained fn get_utility_context_oracle() -> UtilityContext {}\n\n/// Returns a utility context built from the global variables of anchor block and the contract address of the function\n/// being executed.\npub unconstrained fn get_utility_context() -> UtilityContext {\n    get_utility_context_oracle()\n}\n"
    },
    "177": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store<let N: u32>(values: [Field; N], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper<let N: u32>(\n    values: [Field; N],\n    hash: Field,\n) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(privateStoreInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle<let N: u32>(_values: [Field; N], _hash: Field) {}\n\n#[oracle(privateLoadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "178": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(utilityGetContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\nstruct GetContractInstanceResult {\n    exists: bool,\n    member: Field,\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n\nunconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_deployer_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_class_id_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_deployer_internal_avm(address)[0] };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_class_id_internal_avm(address)[0] };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address)[0] };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n"
    },
    "182": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr",
      "source": "use protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\nuse protocol_types::traits::{Deserialize, Serialize};\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(utilityGetPublicDataWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> PublicDataWitness {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    get_public_data_witness_oracle(block_number, public_data_tree_index)\n}\n"
    },
    "183": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(utilityGetKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "184": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(utilityGetPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] != 0 } },\n        ivpk_m: IvpkM { inner: Point { x: result[3], y: result[4], is_infinite: result[5] != 0 } },\n        ovpk_m: OvpkM { inner: Point { x: result[6], y: result[7], is_infinite: result[8] != 0 } },\n        tpk_m: TpkM { inner: Point { x: result[9], y: result[10], is_infinite: result[11] != 0 } },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "186": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/oracle/message_processing.nr",
      "source": "use protocol_types::address::AztecAddress;\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn fetch_tagged_logs(pending_tagged_log_array_base_slot: Field) {\n    fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(utilityFetchTaggedLogs)]\nunconstrained fn fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n// This must be a single oracle and not one for notes and one for events because the entire point is to validate\n// all notes and events in one go, minimizing node round-trips.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {\n    validate_enqueued_notes_and_events_oracle(\n        contract_address,\n        note_validation_requests_array_base_slot,\n        event_validation_requests_array_base_slot,\n    );\n}\n\n#[oracle(utilityValidateEnqueuedNotesAndEvents)]\nunconstrained fn validate_enqueued_notes_and_events_oracle(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {}\n\npub(crate) unconstrained fn bulk_retrieve_logs(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {\n    bulk_retrieve_logs_oracle(\n        contract_address,\n        log_retrieval_requests_array_base_slot,\n        log_retrieval_responses_array_base_slot,\n    );\n}\n\n#[oracle(utilityBulkRetrieveLogs)]\nunconstrained fn bulk_retrieve_logs_oracle(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {}\n"
    },
    "188": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::note::{note_interface::NoteType, retrieved_note::RetrievedNote};\n\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    owner: AztecAddress,\n    storage_slot: Field,\n    randomness: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            owner,\n            storage_slot,\n            randomness,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    owner: AztecAddress,\n    storage_slot: Field,\n    randomness: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(\n        owner,\n        storage_slot,\n        randomness,\n        note_type_id,\n        packed_note,\n        note_hash,\n        counter,\n    );\n}\n\n#[oracle(privateNotifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _owner: AztecAddress,\n    _storage_slot: Field,\n    _randomness: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(privateNotifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(privateNotifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(utilityGetNotes)]\nunconstrained fn get_notes_oracle<Note, let M: u32, let MaxNotes: u32>(\n    _owner: Option<AztecAddress>,\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; M],\n    _select_by_offsets: [u8; M],\n    _select_by_lengths: [u8; M],\n    _select_values: [Field; M],\n    _select_comparators: [u8; M],\n    _sort_by_indexes: [u8; M],\n    _sort_by_offsets: [u8; M],\n    _sort_by_lengths: [u8; M],\n    _sort_order: [u8; M],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    // This is always set to MAX_NOTES. We need to pass it to TS in order to correctly construct the BoundedVec\n    _max_notes: u32,\n    // This is always set to <RetrievedNote<Note> as Packable>::N. We need to pass it to TS in order to be able to\n    // correctly construct the BoundedVec there.\n    _packed_retrieved_note_length: u32,\n) -> BoundedVec<[Field; <RetrievedNote<Note> as Packable>::N], MaxNotes>\nwhere\n    // TODO(https://github.com/noir-lang/noir/issues/9399): `Note: Packable` should work here.\n    RetrievedNote<Note>: Packable,\n{}\n\npub unconstrained fn get_notes<Note, let M: u32, let MaxNotes: u32>(\n    owner: Option<AztecAddress>,\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Option<RetrievedNote<Note>>; MaxNotes]\nwhere\n    Note: NoteType + Packable,\n{\n    let packed_retrieved_notes: BoundedVec<[Field; <RetrievedNote<Note> as Packable>::N], MaxNotes>\n         = get_notes_oracle::<Note, M, MaxNotes>(\n            owner,\n            storage_slot,\n            num_selects,\n            select_by_indexes,\n            select_by_offsets,\n            select_by_lengths,\n            select_values,\n            select_comparators,\n            sort_by_indexes,\n            sort_by_offsets,\n            sort_by_lengths,\n            sort_order,\n            limit,\n            offset,\n            status,\n            MaxNotes,\n            <RetrievedNote<Note> as Packable>::N,\n        );\n\n    let mut notes = BoundedVec::<_, MaxNotes>::new();\n    for i in 0..packed_retrieved_notes.len() {\n        let retrieved_note = RetrievedNote::unpack(packed_retrieved_notes.get(i));\n        notes.push(retrieved_note);\n    }\n\n    // At last we convert the bounded vector to an array of options. We do this because that is what the filter\n    // function needs to have on the output and we've decided to have the same type on the input and output of\n    // the filter and preprocessor functions.\n    //\n    // We have decided to have the same type on the input and output of the filter and preprocessor functions because\n    // it allows us to chain multiple filters and preprocessors together.\n    //\n    // So why do we want the array of options on the output of the filter function?\n    //\n    // Filter returns an array of options rather than a BoundedVec for performance reasons. Using an array of options\n    // allows setting values at known indices in the output array which is much more efficient than pushing to a\n    // BoundedVec where the write position depends on previous iterations. The array can then be efficiently converted\n    // to a BoundedVec using utils/array/collapse.nr::collapse function from Aztec.nr. This avoids expensive dynamic\n    // memory access patterns that would be required when building up a BoundedVec incrementally. For preprocessor\n    // functions we could use BoundedVec return value as there the optimization does not matter since it is applied in\n    // an unconstrained context. We, however, use the same return value type to be able to use the same function as\n    // both a preprocessor and a filter.\n    let mut notes_array = [Option::none(); MaxNotes];\n    for i in 0..notes.len() {\n        if i < notes.len() {\n            notes_array[i] = Option::some(notes.get_unchecked(i));\n        }\n    }\n\n    notes_array\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(utilityCheckNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n// TODO: Oracles below are generic private log oracles and are not specific to notes. Move them somewhere else.\n\n/// Returns the next app tag for a given sender and recipient pair.\n///\n/// This also notifies the simulator that a tag has been used in a note, and to therefore increment the\n/// associated index so that future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub unconstrained fn get_next_app_tag_as_sender(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> Field {\n    get_next_app_tag_as_sender_oracle(sender, recipient)\n}\n\n#[oracle(privateGetNextAppTagAsSender)]\nunconstrained fn get_next_app_tag_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> Field {}\n\n/// Gets the sender for tags.\n///\n/// This unconstrained value is used as the sender when computing an unconstrained shared secret\n/// for a tag in order to emit a log. Constrained tagging should not use this as there is no\n/// guarantee that the recipient knows about the sender, and hence about the shared secret.\n///\n/// The value persists through nested calls, meaning all calls down the stack will use the same\n/// 'senderForTags' value (unless it is replaced).\npub unconstrained fn get_sender_for_tags() -> Option<AztecAddress> {\n    get_sender_for_tags_oracle()\n}\n\n#[oracle(privateGetSenderForTags)]\nunconstrained fn get_sender_for_tags_oracle() -> Option<AztecAddress> {}\n\n/// Sets the sender for tags.\n///\n/// This unconstrained value is used as the sender when computing an unconstrained shared secret\n/// for a tag in order to emit a log. Constrained tagging should not use this as there is no\n/// guarantee that the recipient knows about the sender, and hence about the shared secret.\n///\n/// Account contracts typically set this value before calling other contracts. The value persists\n/// through nested calls, meaning all calls down the stack will use the same 'senderForTags'\n/// value (unless it is replaced by another call to this setter).\npub unconstrained fn set_sender_for_tags(sender_for_tags: AztecAddress) {\n    set_sender_for_tags_oracle(sender_for_tags);\n}\n\n#[oracle(privateSetSenderForTags)]\nunconstrained fn set_sender_for_tags_oracle(_sender_for_tags: AztecAddress) {}\n"
    },
    "19": {
      "path": "std/hash/mod.nr",
      "source": "// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Decompose the input 'bn254 scalar' into two 128 bits limbs.\n// It is called 'unsafe' because it does not assert the limbs are 128 bits\n// Assuming the limbs are 128 bits:\n// Assert the decomposition does not overflow the field size.\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    // Check that the decomposition does not overflow the field size\n    let (a, b) = if xhi == crate::field::bn254::PHI {\n        (xlo, crate::field::bn254::PLO)\n    } else {\n        (xhi, crate::field::bn254::PHI)\n    };\n    crate::field::bn254::assert_lt(a, b);\n\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"
    },
    "191": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(utilityGetSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "192": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(utilityStorageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: u32,\n    length: u32,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(address.to_field(), storage_slot, block_number, N)\n}\n\npub unconstrained fn storage_read<T>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"utilityStorageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"utilityStorageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"
    },
    "193": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/oracle/version.nr",
      "source": "/// The ORACLE_VERSION constant is used to check that the oracle interface is in sync between PXE and Aztec.nr. We need\n/// to version the oracle interface to ensure that developers get a reasonable error message if they use incompatible\n/// versions of Aztec.nr and PXE. The TypeScript counterpart is in `oracle_version.ts`.\n///\n/// @dev Whenever a contract function or Noir test is run, the `utilityAssertCompatibleOracleVersion` oracle is called and\n/// if the oracle version is incompatible an error is thrown.\npub global ORACLE_VERSION: Field = 5;\n\n/// Asserts that the version of the oracle is compatible with the version expected by the contract.\npub fn assert_compatible_oracle_version() {\n    // Safety: This oracle call returns nothing: we only call it to check Aztec.nr and Oracle interface versions are\n    // compatible. It is therefore always safe to call.\n    unsafe {\n        assert_compatible_oracle_version_wrapper();\n    }\n}\n\nunconstrained fn assert_compatible_oracle_version_wrapper() {\n    assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n}\n\n#[oracle(utilityAssertCompatibleOracleVersion)]\nunconstrained fn assert_compatible_oracle_version_oracle(version: Field) {}\n\nmod test {\n    use super::{assert_compatible_oracle_version_oracle, ORACLE_VERSION};\n\n    #[test]\n    unconstrained fn compatible_oracle_version() {\n        assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n    }\n\n    #[test(should_fail_with = \"Incompatible oracle version. TXE is using version\")]\n    unconstrained fn incompatible_oracle_version() {\n        let arbitrary_incorrect_version = 318183437;\n        assert_compatible_oracle_version_oracle(arbitrary_incorrect_version);\n    }\n}\n"
    },
    "197": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::state_variable::StateVariable;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\n\n/// Map\n///\n/// A key-value storage container that maps keys to state variables, similar\n/// to Solidity mappings.\n///\n/// `Map` enables you to associate keys (like addresses or other identifiers)\n/// with state variables in your Aztec smart contract. This is conceptually\n/// similar to Solidity's `mapping(K => V)` syntax, where you can store and\n/// retrieve values by their associated keys.\n///\n/// You can declare a state variable contained within a Map in your contract's\n/// #[storage] struct.\n///\n/// For example, you might use\n/// `Map<AztecAddress, PublicMutable<FieldNote, Context>, Context>` to track\n/// token balances for different users, similar to how you'd use\n/// `mapping(address => uint256)` in Solidity.\n///\n/// > Aside: the verbose `Context` in the declaration is a consequence of\n/// > leveraging Noir's regular syntax for generics to ensure that certain\n/// > state variable methods can only be called in some contexts (private,\n/// > public, utility).\n///\n/// The methods of Map are:\n/// - `at` (access state variable for a given key)\n/// (see the method's own doc comments for more info).\n///\n/// ## Generic Parameters\n/// - `K`: The key type (must implement `ToField` trait for hashing)\n/// - `V`: The value type:\n///   - any Aztec state variable (variable that implements the StateVariable trait):\n///     - `PublicMutable`\n///     - `PublicImmutable`\n///     - `DelayedPublicMutable`\n///     - `Map`\n/// - `Context`: The execution context (handles private/public function\n///   contexts)\n///\n/// ## Usage\n/// Maps are typically declared in your contract's #[storage] struct and\n/// accessed\n/// using the `at(key)` method to get the state variable for a specific key.\n/// The resulting state variable can then be read from or written to using its\n/// own methods.\n///\n/// Note that maps cannot be used with owned state variables (variables that\n/// implement the OwnedStateVariable trait) - those need to be wrapped in an\n/// `Owned` state variable instead.\n///\n/// ## Advanced\n/// Internally, `Map` uses a single base storage slot to represent the\n/// mapping\n/// itself, similar to Solidity's approach. Individual key-value pairs are\n/// stored at derived storage slots computed by hashing the base storage\n/// slot\n/// with the key using Poseidon2. This ensures:\n/// - No storage slot collisions between different keys\n/// - Uniform distribution of storage slots across the storage space\n/// - Compatibility with Aztec's storage tree structure\n/// - Gas-efficient storage access patterns similar to Solidity mappings\n///\n/// The storage slot derivation uses `derive_storage_slot_in_map(base_slot,\n/// key)` which computes `poseidon2_hash([base_slot, key.to_field()])`,\n/// ensuring cryptographically secure slot separation.\n///\n/// docs:start:map\npub struct Map<K, V, Context> {\n    pub context: Context,\n    storage_slot: Field,\n}\n\n// Map reserves a single storage slot regardless of what it stores because\n// nothing is stored at said slot: it is only used to derive the storage slots\n// of nested state variables, which is expected to never result in collisions\n// or slots being close to one another due to these being hashes. This mirrors\n// the strategy adopted by Solidity mappings.\nimpl<K, V, Context> StateVariable<1, Context> for Map<K, V, Context> {\n    fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot }\n    }\n\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    /// Returns the state variable associated with the given key.\n    ///\n    /// This is equivalent to accessing `mapping[key]` in Solidity. It returns\n    /// the state variable instance for the specified key, which can then be\n    /// used to read or write the value at that key.\n    ///\n    /// Unlike Solidity mappings which return the value directly, this returns\n    /// the state variable wrapper (like PublicMutable, nested Map etc.)\n    /// that you then call methods on to interact with the actual value.\n    ///\n    /// # Arguments\n    ///\n    /// * `key` - The key to look up in the map. Must implement the ToField\n    ///           trait (which most basic Noir & Aztec types do).\n    ///\n    /// # Returns\n    ///\n    /// * `V` - The state variable instance for this key. You can then call\n    ///         methods like `.read()`, `.write()`, `.get_note()`, etc. on this\n    ///         depending on the specific state variable type.\n    ///\n    /// # Example\n    ///\n    /// ```noir\n    /// // Get a user's balance (assuming PrivateMutable<FieldNote>)\n    /// let user_balance = self.storage.balances.at(user_address);\n    /// let current_note = user_balance.get_note();\n    ///\n    /// // Update the balance\n    /// user_balance.replace(new_note);\n    /// ```\n    ///\n    pub fn at<let N: u32>(self, key: K) -> V\n    where\n        K: ToField,\n        V: StateVariable<N, Context>,\n    {\n        V::new(\n            self.context,\n            derive_storage_slot_in_map(self.storage_slot, key),\n        )\n    }\n}\n"
    },
    "207": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr",
      "source": "use crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::state_variable::StateVariable,\n    utils::with_hash::WithHash,\n};\nuse protocol_types::{\n    constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator,\n    traits::Packable,\n};\n\n/// # PublicImmutable\n///\n/// PublicImmutable is a public state variable type for values that are set once\n/// during initialization and remain permanently unchanged.\n///\n/// You can declare a state variable of type PublicImmutable within your contract's\n/// #[storage] struct:\n///\n/// E.g.:\n/// `your_variable: PublicImmutable<T, Context>`\n///\n/// PublicImmutable stores an immutable value in public state which can be _read_\n/// from public, utility and even _private_ execution contexts.\n///\n/// The methods of PublicImmutable are:\n/// - `initialize`\n/// - `read`\n/// (see the methods' own doc comments for more info).\n///\n/// # Generic Parameters:\n///\n/// * `T` - The type of value stored (must implement Packable).\n/// * `Context` - The execution context (PublicContext, PrivateContext, or UtilityContext).\n///\n/// # Advanced\n///\n/// PublicImmutable leverages `WithHash<T>` to enable efficient private reads of\n/// public storage. The `WithHash` wrapper optimizes reads by hashing values that would\n/// be larger than a single field into a single field, then proving inclusion of only\n/// the hash in public storage.\n///\n/// This optimization is particularly valuable when T packs to multiple fields,\n/// as it maintains \"almost constant\" verification overhead regardless of the\n/// original data size.\n///\n/// ## Optimizing private reads in your contract\n/// Since reading T from public immutable storage in private contexts has \"almost\n/// constant\" constraint costs regardless of T's size, it's recommended to group\n/// multiple values into a single struct when they are to be read together. This is\n/// typically useful for configuration data set during contract initialization. E.g.:\n///\n/// ```noir\n/// use dep::aztec::protocol_types::{address::AztecAddress, traits::Packable};\n/// use std::meta::derive;\n///\n/// #[derive(Eq, Packable)]\n/// pub struct Config \\{\n///     pub address_1: AztecAddress,\n///     pub value_1: u128,\n///     pub value_2: u64,\n///     ...\n/// }\n/// ```\n///\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\n/// `PublicImmutable` stores both the packed value (using M fields) and its hash (1 field), requiring M + 1 total\n/// fields.\nimpl<T, Context, let M: u32> StateVariable<M + 1, Context> for PublicImmutable<T, Context>\nwhere\n    T: Packable<N = M>,\n{\n    fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n        )\n    }\n}\n\nimpl<T> PublicImmutable<T, PublicContext> {\n    /// Initializes a PublicImmutable state variable instance with a permanent value.\n    ///\n    /// This function sets the immutable value for this state variable. It can only\n    /// be called once per PublicImmutable. Subsequent calls will fail because the\n    /// initialization nullifier will already exist.\n    ///\n    /// # Arguments\n    /// * `value` - The permanent value to store in this PublicImmutable.\n    ///\n    /// # Panics\n    /// Panics if the value is already initialized.\n    ///\n    /// # Advanced\n    ///\n    /// This function performs the following operations:\n    /// - Creates and emits an initialization nullifier to mark this storage slot\n    ///   as initialized. This prevents double-initialization.\n    /// - Wraps the value in `WithHash<T>` for efficient private reads.\n    /// - Stores the wrapped value in Aztec's public data tree.\n    ///\n    /// docs:start:public_immutable_struct_write\n    pub fn initialize(self, value: T)\n    where\n        T: Packable + Eq,\n    {\n        // We emit an initialization nullifier to indicate that the struct is initialized. This also prevents\n        // the value from being initialized again as a nullifier can be included only once.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        self.context.storage_write(self.storage_slot, WithHash::new(value));\n    }\n\n    /// Reads the permanent value stored in this PublicImmutable state variable.\n    ///\n    /// # Returns\n    /// * `T` - The permanent value stored in this PublicImmutable.\n    ///\n    /// # Panics\n    /// Panics if the value is not initialized.\n    ///\n    /// # Advanced\n    ///\n    /// This function performs the following operations:\n    /// - Checks that the state variable has been initialized by verifying the\n    ///   initialization nullifier exists\n    /// - Reads the `WithHash<T>` wrapper from public storage\n    /// - Extracts and returns the original value T\n    ///\n    /// The function will panic if called on an uninitialized PublicImmutable.\n    ///\n    /// docs:start:public_immutable_struct_read\n    pub fn read(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        assert(self.is_initialized(), \"Trying to read from uninitialized PublicImmutable\");\n        WithHash::public_storage_read(self.context, self.storage_slot)\n    }\n\n    /// Reads the value stored in this PublicImmutable without checking if the value\n    /// is initialized.\n    ///\n    /// This function bypasses the initialization check and directly reads from\n    /// storage.\n    /// If the PublicImmutable has not been initialized, this will return a\n    /// zeroed value.\n    /// However, if the variable is _known_ to be initialized, this is cheaper\n    /// to call than `read`.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The value stored in this PublicImmutable, or empty/default values if\n    ///         uninitialized.\n    ///\n    pub fn read_unsafe(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        WithHash::public_storage_read(self.context, self.storage_slot)\n    }\n\n    fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.nullifier_exists(nullifier, self.context.this_address())\n    }\n}\n\nimpl<T> PublicImmutable<T, UtilityContext> {\n    /// Reads the permanent value stored in this PublicImmutable state variable.\n    ///\n    /// Notice that this function is executable only within a UtilityContext, which\n    /// is an unconstrained environment on the user's local device.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The permanent value stored in this PublicImmutable.\n    ///\n    pub unconstrained fn read(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        // TODO(#15703): this fn should fail if the variable is not initialized\n        WithHash::utility_public_storage_read(self.context, self.storage_slot)\n    }\n}\n\nimpl<T> PublicImmutable<T, &mut PrivateContext> {\n    /// Reads the permanent value stored in this PublicImmutable from the anchor\n    /// block.\n    ///\n    /// Private functions execute asynchronously and offchain. When a user begins\n    /// private execution, their view of the chain 'branches off' from the current\n    /// public state, since public state continues to advance while they execute\n    /// privately. Therefore, private functions read from a historical snapshot of\n    /// public state rather than the current state.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The permanent value stored in this PublicImmutable at the historical\n    ///         block referenced by the private context.\n    ///\n    /// # Advanced\n    ///\n    /// This function performs a historical read using the block header from the private\n    /// context. The `WithHash` optimization is particularly valuable here because it\n    /// reduces the number of required inclusion proofs by proving membership of\n    /// only the hash instead of the full packed value.\n    ///\n    /// The historical read mechanism:\n    /// - Uses an oracle to obtain the value from the anchor block\n    /// - Proves inclusion of the value's hash in the public data tree\n    /// - Proves that the root of this public data tree is correct, relative to the\n    ///   anchor block header.\n    /// - Verifies that the oracle-provided value matches the stored hash\n    ///\n    pub fn read(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        // TODO(#15703): this fn should fail if the variable is not initialized\n        WithHash::historical_public_storage_read(\n            self.context.get_anchor_block_header(),\n            self.context.this_address(),\n            self.storage_slot,\n        )\n    }\n}\n"
    },
    "209": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr",
      "source": "use crate::context::{PublicContext, UtilityContext};\nuse crate::state_vars::state_variable::StateVariable;\nuse dep::protocol_types::traits::Packable;\n\n/// # PublicMutable\n///\n/// PublicMutable is a public state variable type for values that can be read\n/// and written within #[external(\"public\")] functions of your smart contract.\n///\n/// You can declare a state variable of type PublicMutable within your contract's\n/// #[storage] struct:\n///\n/// E.g.:\n/// `your_variable: PublicMutable<T, Context>`\n/// or:\n/// `your_mapping: Map<Field, PublicMutable<T, Context>>`\n///\n/// The methods of PublicMutable are:\n/// - `read`\n/// - `write`\n/// (see the methods' own doc comments for more info).\n///\n/// ## Example.\n///\n/// A voting contract's proposal count can be represented as a PublicMutable<u64>.\n/// The count can be read by anyone to see how many proposals exist, and incremented\n/// when new proposals are submitted.\n///\n/// # Generic Parameters:\n///\n/// * `T` - The type of value stored (must implement Packable).\n/// * `Context` - The execution context (PublicContext or UtilityContext).\n///\n/// # Advanced\n///\n/// Unlike private state variables which use notes, PublicMutable stores values\n/// directly in Aztec's public data tree. This enables direct read and write\n/// access to the current state during public function execution.\n///\n/// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\nimpl<T, Context, let M: u32> StateVariable<M, Context> for PublicMutable<T, Context>\nwhere\n    T: Packable<N = M>,\n{\n    fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T> PublicMutable<T, PublicContext> {\n    /// Reads the current value stored in this PublicMutable state variable.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The current value stored in this PublicMutable.\n    ///\n    /// docs:start:public_mutable_struct_read\n    pub fn read(self) -> T\n    where\n        T: Packable,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n\n    /// Writes a new value to this PublicMutable state variable.\n    ///\n    /// # Arguments\n    ///\n    /// * `value` - The new value to store in this PublicMutable.\n    ///\n    /// # Advanced\n    ///\n    /// This function updates the value stored in Aztec's public data tree.\n    /// The new value becomes immediately available to subsequent reads within\n    /// the same transaction.\n    ///\n    /// docs:start:public_mutable_struct_write\n    pub fn write(self, value: T)\n    where\n        T: Packable,\n    {\n        self.context.storage_write(self.storage_slot, value);\n    }\n}\n\nimpl<T> PublicMutable<T, UtilityContext> {\n    /// Reads the current value stored in this PublicMutable state variable.\n    ///\n    /// Notice that this function is executable only within a UtilityContext, which\n    /// is an unconstrained environment on the user's local device.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The current value stored in this PublicMutable.\n    ///\n    pub unconstrained fn read(self) -> T\n    where\n        T: Packable,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"
    },
    "232": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends the elements of the second `BoundedVec` to the end of the first one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let ALen: u32, let BLen: u32, let DstLen: u32>(\n    a: BoundedVec<T, ALen>,\n    b: BoundedVec<T, BLen>,\n) -> BoundedVec<T, DstLen> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "235": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DstLen` elements from a source array, starting at `offset`. `DstLen` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SrcLen: u32, let DstLen: u32>(src: [T; SrcLen], offset: u32) -> [T; DstLen] {\n    assert(offset + DstLen <= SrcLen, \"DstLen too large for offset\");\n\n    let mut dst: [T; DstLen] = std::mem::zeroed();\n    for i in 0..DstLen {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DstLen to be 0, so we always get back an empty array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "236": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DstMaxLen` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DstLen` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DstLen` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SrcMaxLen: u32, let DstMaxLen: u32>(\n    bvec: BoundedVec<T, SrcMaxLen>,\n    offset: u32,\n) -> BoundedVec<T, DstMaxLen> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "238": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "239": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "242": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use protocol_types::{point::Point, utils::field::sqrt};\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\n/// Returns a `Point` in the Grumpkin curve given its x coordinate.\n///\n/// Because not all values in the field are valid x coordinates of points in the curve (i.e. there\n/// is no corresponding y value in the field that satisfies the curve equation), it may not be\n/// possible to reconstruct a `Point`. `Option::none()` is returned in such cases.\npub fn point_from_x_coord(x: Field) -> Option<Point> {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    sqrt(rhs).map(|y| Point { x, y, is_infinite: false })\n}\n\n/// Returns a `Point` in the Grumpkin curve given its x coordinate and sign for the y coordinate.\n///\n/// Because not all values in the field are valid x coordinates of points in the curve (i.e. there\n/// is no corresponding y value in the field that satisfies the curve equation), it may not be\n/// possible to reconstruct a `Point`. `Option::none()` is returned in such cases.\n///\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Option<Point> {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n\n    sqrt(rhs).map(|y| {\n        // If there is a square root, we need to ensure it has the correct \"sign\"\n        let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n        let final_y = if y_is_positive == sign { y } else { -y };\n        Point { x, y: final_y, is_infinite: false }\n    })\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord, point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n    use dep::protocol_types::utils::field::pow;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign).unwrap();\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2).unwrap();\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_valid() {\n        // x = 8 is a known quadratic residue - should give a valid point\n        let result = point_from_x_coord(Field::from(8));\n        assert(result.is_some());\n\n        let point = result.unwrap();\n        assert_eq(point.x, Field::from(8));\n        // Check curve equation y^2 = x^3 - 17\n        assert_eq(pow(point.y, 2), pow(point.x, 3) - 17);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_invalid() {\n        // x = 3 is a non-residue for this curve - should give None\n        let x = Field::from(3);\n        let maybe_point = point_from_x_coord(x);\n        assert(maybe_point.is_none());\n    }\n\n}\n"
    },
    "246": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr",
      "source": "use crate::{\n    context::{PublicContext, UtilityContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    abis::block_header::BlockHeader, address::AztecAddress, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `M` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `M`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let M: u32> {\n    value: T,\n    packed: [Field; M],\n    hash: Field,\n}\n\nimpl<T, let M: u32> WithHash<T, M>\nwhere\n    T: Packable<N = M> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn utility_public_storage_read(\n        context: UtilityContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + M as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\n// Note: I don't derive Packable on `WithHash` because `derive_serialize` function does not support setting \"N = M\"\n// as I do here 3 lines below. This could be worked around by placing the \"where\" clause directly on the `WithHash`\n// struct, but Jake mentioned that the syntax is not expected to be supported at least until Noir 1.0.\n// Relevant discussion on Slack:\n// https://aztecprotocol.slack.com/archives/C04QF64EDNV/p1752593876160699?thread_ts=1752589887.955379&cid=C04QF64EDNV\nimpl<T, let M: u32> Packable for WithHash<T, M>\nwhere\n    T: Packable<N = M>,\n{\n    let N: u32 = M + 1;\n\n    fn pack(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n        for i in 0..M {\n            result[i] = self.packed[i];\n        }\n        result[M] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; Self::N]) -> Self {\n        let mut value_packed = [0; M];\n        for i in 0..M {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[M];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::test::OracleMock;\n\n    global STORAGE_SLOT: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let env = TestEnvironment::new();\n\n        env.private_context(|context| {\n            let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n                context.anchor_block_header,\n                context.this_address(),\n                STORAGE_SLOT,\n            );\n\n            assert_eq(result, std::mem::zeroed());\n        });\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        env.public_context(|context| { context.storage_write(STORAGE_SLOT, value_with_hash); });\n\n        env.private_context(|context| {\n            let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n                context.anchor_block_header,\n                context.this_address(),\n                STORAGE_SLOT,\n            );\n            assert_eq(result, value);\n        });\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn bad_hint_uninitialized_value() {\n        let env = TestEnvironment::new();\n\n        env.private_context(|context| {\n            let block_header = context.anchor_block_header;\n            let address = context.this_address();\n\n            // Mock the oracle to return a non-zero hint/packed value\n            let value_packed = MockStruct { a: 1, b: 1 }.pack();\n            let _ = OracleMock::mock(\"utilityStorageRead\")\n                .with_params((\n                    address.to_field(), STORAGE_SLOT, block_header.global_variables.block_number,\n                    value_packed.len(),\n                ))\n                .returns(value_packed)\n                .times(1);\n\n            // This should fail because the hint value is non-zero and the hash is zero (default value of storage)\n            let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n                block_header,\n                address,\n                STORAGE_SLOT,\n            );\n        });\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn bad_hint_initialized_value() {\n        let env = TestEnvironment::new();\n\n        env.public_context(|context| {\n            // Write the value and hash separately so that the hash is wrong\n            let value = MockStruct { a: 5, b: 3 };\n            context.storage_write(STORAGE_SLOT, value);\n\n            let incorrect_hash = 13;\n            let hash_storage_slot = STORAGE_SLOT + (value.pack().len() as Field);\n            context.storage_write(hash_storage_slot, [incorrect_hash]);\n        });\n\n        env.private_context(|context| {\n            let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n                context.anchor_block_header,\n                context.this_address(),\n                STORAGE_SLOT,\n            );\n        });\n    }\n}\n"
    },
    "253": {
      "path": "/Users/jp4g/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr",
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "273": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\nuse std::meta::derive;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct FunctionSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    pub inner: u32,\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the [`Self::sort_via`] function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n"
    },
    "311": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\nuse std::meta::derive;\n\n// Aztec address\n#[derive(Deserialize, Eq, Packable, Serialize)]\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    /// Returns an address's `AddressPoint`, which can be used to create shared secrets with the owner\n    /// of the address. If the address is invalid (i.e. it is not a properly derived Aztec address), then this\n    /// returns `Option::none()`, and no shared secrets can be created.\n    pub fn to_address_point(self) -> Option<AddressPoint> {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // An invalid AztecAddress is one for which no y coordinate satisfies the curve equation, which we'll\n        // identify by proving that the square root of y_squared does not exist.\n        let mut y_opt = sqrt(y_squared);\n        if y_opt.is_none() {\n            Option::none()\n        } else {\n            let mut y = y_opt.unwrap();\n\n            // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n            // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n            // note: The field modulus is MAX_FIELD_VALUE + 1\n            if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n                y = (MAX_FIELD_VALUE + 1) - y;\n            }\n\n            Option::some(\n                AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } },\n            )\n        }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    // We use the AZTEC_ADDRESS_LENGTH constant to ensure that there is a match between the derived trait\n    // implementation and the constant.\n    let serialized: [Field; AZTEC_ADDRESS_LENGTH] = address.serialize();\n    let deserialized = AztecAddress::deserialize(serialized);\n    assert_eq(address, deserialized);\n}\n\n#[test]\nfn to_address_point_valid() {\n    // x = 8 where x^3 - 17 = 512 - 17 = 495, which is a residue in this field\n    let address = AztecAddress { inner: 8 };\n    let maybe_point = address.to_address_point();\n    assert(maybe_point.is_some());\n\n    let point = maybe_point.unwrap().inner;\n    // check that x is preserved\n    assert_eq(point.x, Field::from(8));\n\n    // check that the curve equation holds: y^2 == x^3 - 17\n    assert_eq(pow(point.y, 2), pow(point.x, 3) - 17);\n}\n\n#[test]\nunconstrained fn to_address_point_invalid() {\n    // x = 3 where x^3 - 17 = 27 - 17 = 10, which is a non-residue in this field\n    let address = AztecAddress { inner: 3 }; //\n    let maybe_point = address.to_address_point();\n    assert(maybe_point.is_none());\n}\n"
    },
    "330": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr",
      "source": "use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Deserialize, Empty, Hash, Serialize},\n};\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: Field,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl LeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: Field) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"
    },
    "332": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "// TODO: Expose other wrapped functions than debug (info, warn)\n// ['silent', 'fatal', 'error', 'warn', 'info', 'verbose', 'debug', 'trace']\n\npub global SILENT_LOG_LEVEL: u8 = 0;\npub global FATAL_LOG_LEVEL: u8 = 1;\npub global ERROR_LOG_LEVEL: u8 = 2;\npub global WARN_LOG_LEVEL: u8 = 3;\npub global INFO_LOG_LEVEL: u8 = 4;\npub global VERBOSE_LOG_LEVEL: u8 = 5;\npub global DEBUG_LOG_LEVEL: u8 = 6;\npub global TRACE_LOG_LEVEL: u8 = 7;\n\n/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Same as debug_log, but allows to customize the log level.\n/// Consider changing just to 'log'\npub fn debug_log_with_level<let N: u32>(log_level: u8, msg: str<N>) {\n    debug_log_format_with_level(log_level, msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_array_oracle_wrapper(DEBUG_LOG_LEVEL, msg, args) };\n}\n\n/// Same as debug_log_format, but allows to customize the log level.\n/// Consider changing just to 'log_format'\npub fn debug_log_format_with_level<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field; N],\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_array_oracle_wrapper(log_level, msg, args) };\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` slice.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole slice: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format_slice<let M: u32>(log_level: u8, msg: str<M>, args: [Field]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_slice_oracle_wrapper(log_level, msg, args) };\n}\n\n// We provide two versions of the debug log oracle: one that takes args as a slice and another one that takes args as an array.\n// We do this since conversion from array to slice generates overhead in public functions, since opcodes need to be emitted for the conversion.\n// By exposing the two flavors, we avoid conversions since the AVM is able to handle both arrays an slices in this oracle.\n\nunconstrained fn debug_log_slice_oracle_wrapper<let M: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field],\n) {\n    debug_log_slice_oracle(log_level, msg, args);\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_slice_oracle<let M: u32>(log_level: u8, msg: str<M>, args: [Field]) {}\n\nunconstrained fn debug_log_array_oracle_wrapper<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_array_oracle(log_level, msg, N, args);\n}\n\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_array_oracle<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    length: u32,\n    args: [Field; N],\n) {}\n"
    },
    "342": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "mod poseidon2_chunks;\n\nuse crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        transaction::tx_request::TxRequest,\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, NULL_MSG_SENDER_CONTRACT_ADDRESS, TWO_POW_64,\n    },\n    merkle_tree::root_from_sibling_path,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    poseidon2::Poseidon2Sponge,\n    side_effect::{Counted, Scoped},\n    traits::{FromField, Hash, ToField},\n    utils::field::{field_from_bytes, field_from_bytes_32_trunc},\n};\n\npub use poseidon2_chunks::poseidon2_absorb_in_chunks_existing_sponge;\nuse poseidon2_chunks::poseidon2_absorb_in_chunks;\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(note_nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [note_nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_nonce_and_unique_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    let note_nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n    compute_unique_note_hash(note_nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        compute_nonce_and_unique_note_hash(siloed_note_hash, first_nullifier, note_index_in_tx)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: Scoped<Counted<NoteHash>>) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.innermost())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: Scoped<Counted<Nullifier>>) -> Field {\n    let value = nullifier.innermost().value;\n    // Q: shouldn't we be checking whether the _whole_ nullifier is empty?\n    // A: We don't have to. The init and inner circuits add contract address to non-empty nullifiers.\n    // So we know we should silo it if the contract address is not empty.\n    if nullifier.contract_address.is_zero() {\n        value // Return `value` instead of 0 because an already-siloed nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, value)\n    }\n}\n\npub fn create_protocol_nullifier(tx_request: TxRequest) -> Scoped<Counted<Nullifier>> {\n    Nullifier { value: tx_request.hash(), note_hash: 0 }.count(1).scope(\n        NULL_MSG_SENDER_CONTRACT_ADDRESS,\n    )\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<Counted<PrivateLogData>>) -> PrivateLog {\n    let log = private_log.innermost().log;\n    if private_log.contract_address.is_zero() {\n        log\n    } else {\n        let mut fields = log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, log.length)\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn compute_app_secret_key(\n    master_secret_key: EmbeddedCurveScalar,\n    app_address: AztecAddress,\n    app_secret_generator: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [master_secret_key.hi, master_secret_key.lo, app_address.to_field()],\n        app_secret_generator,\n    )\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let contract_address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    let recipient_bytes: [u8; 20] = recipient.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let rollup_version_id_bytes: [u8; 32] = rollup_version_id.to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n\n    let mut bytes: [u8; 148] = std::mem::zeroed();\n    for i in 0..32 {\n        bytes[i] = contract_address_bytes[i];\n        bytes[i + 32] = rollup_version_id_bytes[i];\n        // 64 - 84 are for recipient.\n        bytes[i + 84] = chain_id_bytes[i];\n        bytes[i + 116] = content_bytes[i];\n    }\n\n    for i in 0..20 {\n        bytes[64 + i] = recipient_bytes[i];\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: Scoped<L2ToL1Message>,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.inner.recipient,\n            msg.inner.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n/// Computes sha256 hash of 2 input fields.\n///\n/// @returns A truncated field (i.e., the first byte is always 0).\npub fn accumulate_sha256(v0: Field, v1: Field) -> Field {\n    // Concatenate two fields into 32 x 2 = 64 bytes\n    let v0_as_bytes: [u8; 32] = v0.to_be_bytes();\n    let v1_as_bytes: [u8; 32] = v1.to_be_bytes();\n    let hash_input_flattened = v0_as_bytes.concat(v1_as_bytes);\n\n    sha256_to_field(hash_input_flattened)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = [separator.to_field()].concat(inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n/// Computes a Poseidon2 hash over a dynamic-length subarray of the given input.\n/// Only the first `in_len` fields of `input` are absorbed; any remaining fields are ignored.\n/// The caller is responsible for ensuring that the input is padded with zeros if required.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_in_chunks(input, in_len);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_in_chunks(input, in_len);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// This function is  unconstrained because it is intended to be used in unconstrained context only as\n// in constrained contexts it would be too inefficient.\npub unconstrained fn poseidon2_hash_with_separator_bounded_vec<let N: u32, T>(\n    inputs: BoundedVec<Field, N>,\n    separator: T,\n) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs.get(i));\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0x3b18c58c739716e76429634a61375c45b3b5cd470c22ab6d3e14cee23dd992);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0xaab2a5828156782b12a1dc6f336e2bc627eb1b9514b02d511f66296990c050);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        L2ToL1Message { recipient: EthAddress::from_field(1), content: 2 }.scope(\n            AztecAddress::from_field(3),\n        ),\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `yarn-project/stdlib/src/hash/hash.test.ts`\n    let hash_from_typescript = 0x0081edf209e087ad31b3fd24263698723d57190bd1d6e9fe056fc0c0a68ee661;\n\n    assert_eq(hash, hash_from_typescript);\n}\n\n#[test]\nunconstrained fn poseidon2_hash_with_separator_bounded_vec_matches_non_bounded_vec_version() {\n    let inputs = BoundedVec::<Field, 4>::from_array([1, 2, 3]);\n    let separator = 42;\n\n    // Hash using bounded vec version\n    let bounded_result = poseidon2_hash_with_separator_bounded_vec(inputs, separator);\n\n    // Hash using regular version\n    let regular_result = poseidon2_hash_with_separator([1, 2, 3], separator);\n\n    // Results should match\n    assert_eq(bounded_result, regular_result);\n}\n"
    },
    "351": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      "source": "use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_tree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n/// These values are precomputed and we run tests to ensure that they are correct.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_tree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_tree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_tree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_tree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_tree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_tree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_tree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_tree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_tree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_tree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_tree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_tree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"
    },
    "355": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use utils::derive_serialization_quotes;\n\npub mod utils;\n\n/// Generates the generic parameter declarations for a struct's trait implementation.\n///\n/// This function takes a struct type definition and generates the generic parameter declarations\n/// that go after the `impl` keyword. For example, given a struct with generics `N: u32` and `T`,\n/// it generates `<let N: u32, T>`.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate generic declarations for\n///\n/// # Returns\n/// A quoted code block containing the generic parameter declarations, or an empty quote if the struct\n/// has no generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// This function generates:\n/// ```\n/// <let N: u32, T>\n/// ```\ncomptime fn get_generics_declarations(s: TypeDefinition) -> Quoted {\n    let generics = s.generics();\n\n    if generics.len() > 0 {\n        let generics_declarations_items = generics\n            .map(|(name, maybe_integer_typ)| {\n                // The second item in the generics tuple is an Option of an integer type that is Some only if\n                // the generic is numeric.\n                if maybe_integer_typ.is_some() {\n                    // The generic is numeric, so we return a quote defined as e.g. \"let N: u32\"\n                    let integer_type = maybe_integer_typ.unwrap();\n                    quote {let $name: $integer_type}\n                } else {\n                    // The generic is not numeric, so we return a quote containing the name of the generic (e.g. \"T\")\n                    quote {$name}\n                }\n            })\n            .join(quote {,});\n        quote {<$generics_declarations_items>}\n    } else {\n        // The struct doesn't have any generics defined, so we just return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates the `where` clause for a trait implementation that constrains non-numeric generic type parameters.\n///\n/// This function takes a struct type definition and a trait name, and generates a `where` clause that\n/// requires all non-numeric generic type parameters to implement the specified trait.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the where clause for\n/// - `trait_name`: The name of the trait that non-numeric generic parameters must implement\n///\n/// # Returns\n/// A quoted code block containing the where clause, or an empty quote if the struct has no non-numeric\n/// generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// And trait name \"Serialize\", this function generates:\n/// ```\n/// where T: Serialize\n/// ```\ncomptime fn get_where_trait_clause(s: TypeDefinition, trait_name: Quoted) -> Quoted {\n    let generics = s.generics();\n\n    // The second item in the generics tuple is an Option of an integer type that is Some only if the generic is\n    // numeric.\n    let non_numeric_generics =\n        generics.filter(|(_, maybe_integer_typ)| maybe_integer_typ.is_none());\n\n    if non_numeric_generics.len() > 0 {\n        let non_numeric_generics_declarations =\n            non_numeric_generics.map(|(name, _)| quote {$name: $trait_name}).join(quote {,});\n        quote {where $non_numeric_generics_declarations}\n    } else {\n        // There are no non-numeric generics, so we return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates a `Serialize` trait implementation for a struct type.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A quoted code block containing the trait implementation\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Log<N> {\n///     fields: [Field; N],\n///     length: u32\n/// }\n/// ```\n///\n/// This function generates code equivalent to:\n/// ```\n/// impl<let N: u32> Serialize for Log<N> {\n///     let N: u32 = <[Field; N] as Serialize>::N + <u32 as Serialize>::N;\n///\n///     #[inline_always]\n///     fn serialize(self) -> [Field; Self::N] {\n///         let mut serialized_params = [0; _];\n///         let mut offset = 0;\n///\n///         let serialized_member = Serialize::serialize(self.fields);\n///         let serialized_member_len = <[Field; N] as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             serialized_params[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         let serialized_member = Serialize::serialize(self.length);\n///         let serialized_member_len = <u32 as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             serialized_params[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         serialized_params\n///     }\n/// }\n/// ```\npub comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n\n    // We care only about the name and type so we drop the last item of the tuple\n    let params = nested_struct.0.fields(nested_struct.1).map(|(name, typ, _)| (name, typ));\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Serialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_serialize_clause = get_where_trait_clause(s, quote {Serialize});\n\n    let (function_body, params_len_quote, serialized_params_name) =\n        derive_serialization_quotes(params, true);\n\n    quote {\n        impl$generics_declarations $crate::traits::Serialize for $typ\n            $where_serialize_clause\n        {\n            let N: u32 = $params_len_quote;\n\n            #[inline_always]\n            fn serialize(self) -> [Field; Self::N] {\n                $function_body\n\n                $serialized_params_name\n            }\n        }\n    }\n}\n\n/// Generates a `Deserialize` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Deserialize` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Deserialize for MyStruct {\n///     let N: u32 = <AztecAddress as Deserialize>::N + <Field as Deserialize>::N;\n///\n///     fn deserialize(serialized: [Field; Self::N]) -> Self {\n///         let mut offset = 0;\n///         let mut member_fields = [0; <AztecAddress as Deserialize>::N];\n///         for i in 0..<AztecAddress as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let x = <AztecAddress as Deserialize>::deserialize(member_fields);\n///         offset += <AztecAddress as Deserialize>::N;\n///\n///         let mut member_fields = [0; <Field as Deserialize>::N];\n///         for i in 0..<Field as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let y = <Field as Deserialize>::deserialize(member_fields);\n///         offset += <Field as Deserialize>::N;\n///\n///         Self { x, y }\n///     }\n/// }\n/// ```\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Deserialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_deserialize_clause = get_where_trait_clause(s, quote {Deserialize});\n\n    // The following will give us:\n    // <type_of_struct_member_1 as Deserialize>::N + <type_of_struct_member_2 as Deserialize>::N + ...\n    // (or 0 if the struct has no members)\n    let right_hand_side_of_definition_of_n = if params.len() > 0 {\n        params\n            .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n            <$param_type as $crate::traits::Deserialize>::N\n        }\n            })\n            .join(quote {+})\n    } else {\n        quote {0}\n    };\n\n    // For structs containing a single member, we can enhance performance by directly deserializing the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let function_body = if params.len() > 1 {\n        // This generates deserialization code for each struct member and concatenates them together.\n        let deserialization_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as Deserialize>::N];\n                    for i in 0..<$param_type as Deserialize>::N {\n                        member_fields[i] = serialized[i + offset];\n                    }\n                    let $param_name = <$param_type as Deserialize>::deserialize(member_fields);\n                    offset += <$param_type as Deserialize>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        // This will give us e.g. `a, b, c` for a struct with three fields named `a`, `b`, and `c`.\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n\n            $deserialization_of_struct_members\n\n            Self { $struct_members }\n        }\n    } else if params.len() == 1 {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Deserialize::deserialize(serialized) }\n        }\n    } else {\n        quote {\n            Self {}\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Deserialize for $typ\n            $where_deserialize_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn deserialize(serialized: [Field; Self::N]) -> Self {\n                $function_body\n            }\n        }\n    }\n}\n\n/// Generates a `Packable` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Packable` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Packable for MyStruct {\n///     let N: u32 = 2;\n///\n///     fn pack(self) -> [Field; 2] {\n///         let mut result: [Field; 2] = [0_Field; 2];\n///         let mut offset: u32 = 0_u32;\n///         let packed_member: [Field; 1] = self.x.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         let packed_member: [Field; 1] = self.y.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         result\n///     }\n///\n///     fn unpack(packed: [Field; 2]) -> Self {\n///         let mut offset: u32 = 0_u32;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<AztecAddress as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let x: AztecAddress = <AztecAddress as Packable>::unpack(member_fields);\n///         offset = offset + <AztecAddress as Packable>::N;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<Field as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let y: Field = <Field as Packable>::unpack(member_fields);\n///         offset = offset + <Field as Packable>::N;\n///         Self { x: x, y: y }\n///     }\n/// }\n/// ```\npub comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Packable` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_packable_clause = get_where_trait_clause(s, quote {Packable});\n\n    // The following will give us:\n    // <type_of_struct_member_1 as Packable>::N + <type_of_struct_member_2 as Packable>::N + ...\n    // (or 0 if the struct has no members)\n    let right_hand_side_of_definition_of_n = if params.len() > 0 {\n        params\n            .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n            <$param_type as $crate::traits::Packable>::N\n        }\n            })\n            .join(quote {+})\n    } else {\n        quote {0}\n    };\n\n    // For structs containing a single member, we can enhance performance by directly returning the packed member,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let pack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate packing code that:\n        // 1. Packs each member\n        // 2. Copies the packed fields into the result array at the correct offset\n        // 3. Updates the offset for the next member\n        let packing_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let packed_member = $crate::traits::Packable::pack(self.$param_name);\n                    let packed_member_len = <$param_type as $crate::traits::Packable>::N;\n                    for i in 0..packed_member_len {\n                        result[i + offset] = packed_member[i];\n                    }\n                    offset += packed_member_len;\n                }\n            })\n            .join(quote {});\n\n        quote {\n            let mut result = [0; Self::N];\n            let mut offset = 0;\n\n            $packing_of_struct_members\n\n            result\n        }\n    } else if params.len() == 1 {\n        let param_name = params[0].0;\n        quote {\n            $crate::traits::Packable::pack(self.$param_name)\n        }\n    } else {\n        quote {\n            [0; Self::N]\n        }\n    };\n\n    // For structs containing a single member, we can enhance performance by directly unpacking the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let unpack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate unpacking code that:\n        // 1. Unpacks each member\n        // 2. Copies packed fields into member array at correct offset\n        // 3. Updates offset for next member\n        let unpacking_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as $crate::traits::Packable>::N];\n                    for i in 0..<$param_type as $crate::traits::Packable>::N {\n                        member_fields[i] = packed[i + offset];\n                    }\n                    let $param_name = <$param_type as $crate::traits::Packable>::unpack(member_fields);\n                    offset += <$param_type as $crate::traits::Packable>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n            $unpacking_of_struct_members\n            Self { $struct_members }\n        }\n    } else if params.len() == 1 {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Packable::unpack(packed) }\n        }\n    } else {\n        quote {\n            Self {}\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Packable for $typ\n            $where_packable_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn pack(self) -> [Field; Self::N] {\n                $pack_function_body\n            }\n\n            #[inline_always]\n            fn unpack(packed: [Field; Self::N]) -> Self {\n                $unpack_function_body\n            }\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Packable, Serialize};\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct Empty {}\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct Smol {\n        a: Field,\n        b: Field,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct HasArray {\n        a: [Field; 2],\n        b: bool,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct Fancier {\n        a: Smol,\n        b: [Field; 2],\n        c: [u8; 3],\n        d: str<16>,\n    }\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct HasArrayWithGenerics<T, let N: u32> {\n        pub fields: [T; N],\n        pub length: u32,\n    }\n\n    #[test]\n    fn serde_on_empty() {\n        let original = Empty {};\n        let serialized = original.serialize();\n        assert_eq(serialized, [], \"Serialized does not match empty array\");\n        let deserialized = Empty::deserialize(serialized);\n        assert_eq(deserialized, original, \"Deserialized does not match original\");\n    }\n\n    #[test]\n    fn packable_on_empty() {\n        let original = Empty {};\n        let packed = original.pack();\n        assert_eq(packed, [], \"Packed does not match empty array\");\n        let unpacked = Empty::unpack(packed);\n        assert_eq(unpacked, original, \"Unpacked does not match original\");\n    }\n\n    #[test]\n    fn serde_on_smol() {\n        let smol = Smol { a: 1, b: 2 };\n        let serialized = smol.serialize();\n        assert(serialized == [1, 2], serialized);\n        let deserialized = Smol::deserialize(serialized);\n        assert(deserialized == smol);\n\n        // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n        let packed = smol.pack();\n        assert_eq(packed, serialized, \"Packed does not match serialized\");\n    }\n\n    #[test]\n    fn serde_on_has_array() {\n        let has_array = HasArray { a: [1, 2], b: true };\n        let serialized = has_array.serialize();\n        assert(serialized == [1, 2, 1], serialized);\n        let deserialized = HasArray::deserialize(serialized);\n        assert(deserialized == has_array);\n    }\n\n    #[test]\n    fn serde_on_fancier() {\n        let fancier =\n            Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n        let serialized = fancier.serialize();\n        assert(\n            serialized\n                == [\n                    1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                    0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n                ],\n            serialized,\n        );\n        let deserialized = Fancier::deserialize(serialized);\n        assert(deserialized == fancier);\n    }\n\n    #[test]\n    fn serde_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let serialized = struct_with_array_of_generics.serialize();\n        assert(serialized == [1, 2, 3, 3], serialized);\n        let deserialized = HasArrayWithGenerics::deserialize(serialized);\n        assert(deserialized == struct_with_array_of_generics);\n    }\n\n    #[test]\n    fn packable_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let packed = struct_with_array_of_generics.pack();\n        assert(packed == [1, 2, 3, 3], packed);\n\n        let unpacked = HasArrayWithGenerics::unpack(packed);\n        assert(unpacked == struct_with_array_of_generics);\n    }\n\n}\n"
    },
    "356": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/noir-protocol-circuits/crates/types/src/meta/utils.nr",
      "source": "/// Generates serialization code for a list of parameters and the total length of the serialized array\n///\n/// # Parameters\n/// - `params`: A list of (name, type) tuples to serialize\n/// - `use_self_prefix`: If true, parameters are accessed as `self.$param_name` (for struct members).\n///                      If false, parameters are accessed directly as `$param_name` (for function parameters).\n///\n/// # Returns\n/// A tuple containing:\n/// - Quoted code that serializes the parameters into an array named `serialized_params`\n/// - Quoted code that evaluates to the total length of the serialized array\n/// - Quoted code containing the name of the serialized array\npub comptime fn derive_serialization_quotes(\n    params: [(Quoted, Type)],\n    use_self_prefix: bool,\n) -> (Quoted, Quoted, Quoted) {\n    let prefix_quote = if use_self_prefix {\n        quote { self. }\n    } else {\n        quote {}\n    };\n\n    let params_len_quote = get_params_len_quote(params);\n    let serialized_params_name = quote { serialized_params };\n\n    let body = if params.len() == 0 {\n        quote {\n            let $serialized_params_name: [Field; 0] = [];\n        }\n    } else if params.len() == 1 {\n        // When we have only a single parameter on the input, we can enhance performance by directly returning\n        // the serialized member, bypassing the need for loop-based array construction. While this optimization yields\n        // significant benefits in Brillig where the loops are expected to not be optimized, it is not relevant in ACIR\n        // where the loops are expected to be optimized away.\n\n        let param_name = params[0].0;\n        quote {\n            let $serialized_params_name = $crate::traits::Serialize::serialize($prefix_quote$param_name);\n        }\n    } else {\n        // For multiple struct members, generate serialization code that:\n        // 1. Serializes each member\n        // 2. Copies the serialized fields into the serialize array at the correct offset\n        // 3. Updates the offset for the next member\n        let serialization_of_struct_members = params\n            .map(|(param_name, param_type): (Quoted, Type)| {\n                quote {\n                let serialized_member = $crate::traits::Serialize::serialize($prefix_quote$param_name);\n                let serialized_member_len = <$param_type as $crate::traits::Serialize>::N;\n                for i in 0..serialized_member_len {\n                    $serialized_params_name[i + offset] = serialized_member[i];\n                }\n                offset += serialized_member_len;\n            }\n            })\n            .join(quote {});\n\n        quote {\n            let mut $serialized_params_name = [0; $params_len_quote];\n            let mut offset = 0;\n\n            $serialization_of_struct_members\n        }\n    };\n\n    (body, params_len_quote, serialized_params_name)\n}\n\n/// Generates a quoted expression that computes the total serialized length of function parameters.\n///\n/// # Parameters\n/// * `params` - An array of tuples where each tuple contains a quoted parameter name and its Type. The type needs\n///              to implement the Serialize trait.\n///\n/// # Returns\n/// A quoted expression that evaluates to:\n/// * `0` if there are no parameters\n/// * `(<type1 as Serialize>::N + <type2 as Serialize>::N + ...)` for one or more parameters\npub comptime fn get_params_len_quote(params: [(Quoted, Type)]) -> Quoted {\n    if params.len() == 0 {\n        quote { 0 }\n    } else {\n        let params_quote_without_parentheses = params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n                    <$param_type as $crate::traits::Serialize>::N\n                }\n            })\n            .join(quote {+});\n        quote { ($params_quote_without_parentheses) }\n    }\n}\n"
    },
    "357": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl Serialize for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn serialize(self: Self) -> [Field; Self::N] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn deserialize(serialized: [Field; Self::N]) -> Self {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] != 0 }\n    }\n}\n\n// TODO(#11356): use compact representation here.\nimpl Packable for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn pack(self) -> [Field; Self::N] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; Self::N]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "358": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\nuse crate::traits::{Deserialize, Serialize};\nuse std::meta::derive;\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "365": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::{default::Default, meta::derive};\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nmod test {\n    use crate::{\n        point::POINT_LENGTH,\n        public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n        traits::{Deserialize, Serialize},\n    };\n    use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\n    #[test]\n    unconstrained fn compute_public_keys_hash() {\n        let keys = PublicKeys {\n            npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n            ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n            ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n            tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n        };\n\n        let actual = keys.hash();\n        let expected_public_keys_hash =\n            0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n        assert(actual.to_field() == expected_public_keys_hash);\n    }\n\n    #[test]\n    unconstrained fn compute_default_hash() {\n        let keys = PublicKeys::default();\n\n        let actual = keys.hash();\n        let test_data_default_hash =\n            0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n        assert(actual.to_field() == test_data_default_hash);\n    }\n\n    #[test]\n    unconstrained fn serde() {\n        let keys = PublicKeys {\n            npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n            ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n            ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n            tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n        };\n\n        // We use the PUBLIC_KEYS_LENGTH constant to ensure that there is a match between the derived trait\n        let serialized: [Field; POINT_LENGTH * 4] = keys.serialize();\n        let deserialized = PublicKeys::deserialize(serialized);\n\n        assert_eq(keys, deserialized);\n    }\n}\n"
    },
    "370": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "386": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty: Eq {\n    fn empty() -> Self;\n\n    fn is_empty(self) -> bool {\n        self.eq(Self::empty())\n    }\n\n    // Requires this Noir fix: https://github.com/noir-lang/noir/issues/9002\n    // fn assert_not_empty<let U: u32>(self, msg: str<U>) { // This msg version was failing with weird compiler errors.\n    //     // We provide a default impl but it's likely inefficient.\n    //     // The reason we include this function is because there's a lot of\n    //     // opportunity for optimisation on a per-struct basis.\n    //     // You only need to show one element is not empty to know that the whole thing\n    //     // is not empty.\n    //     // If you know an element of your struct which should always be nonempty,\n    //     // you can write an impl that solely checks that that element is nonempty.\n    //     assert(!self.is_empty(), msg);\n    // }\n\n    // This default impl is overwritten by types like arrays, because there's a much\n    // more efficient approach.\n    fn assert_empty<let S: u32>(self, msg: str<S>) {\n        assert(self.is_empty(), msg);\n    }\n}\n\nimpl Empty for Field {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for bool {\n    #[inline_always]\n    fn empty() -> Self {\n        false\n    }\n}\n\nimpl Empty for u1 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u16 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\n\nimpl<T> Empty for [T]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty()]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\nimpl<A, B> Empty for (A, B)\nwhere\n    A: Empty,\n    B: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        (A::empty(), B::empty())\n    }\n}\n\nimpl<T> Empty for Option<T>\nwhere\n    T: Eq,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\n// pub fn is_empty<T>(item: T) -> bool\n// where\n//     T: Empty,\n// {\n//     item.eq(T::empty())\n// }\n\n// pub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\n// where\n//     T: Empty,\n// {\n//     array.all(|elem| is_empty(elem))\n// }\n\n// pub fn assert_empty<T>(item: T) -> ()\n// where\n//     T: Empty,\n// {\n//     assert(item.eq(T::empty()))\n// }\n\n// pub fn assert_empty_array<T, let N: u32>(array: [T; N]) -> ()\n// where\n//     T: Empty,\n// {\n//     // A cheaper option than `is_empty_array` for if you don't need to gracefully\n//     // handle a bool result.\n//     // Avoids the `&` operator of `is_empty_array`'s `.all()` call.\n//     for i in 0..N {\n//         assert(is_empty(array[i]));\n//     }\n// }\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u16 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value != 0\n    }\n}\nimpl FromField for u1 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u16 {\n    fn from_field(value: Field) -> Self {\n        value as u16\n    }\n}\nimpl FromField for u32 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Associated Constants\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize for str<N> {\n///     let N: u32 = N;\n///\n///     fn serialize(self) -> [Field; Self::N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; Self::N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize {\n    let N: u32;\n\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let M: u32> Serialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; Self::N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n/// Implementation of Deserialize for BoundedVec.\n///\n/// This implementation deserializes a BoundedVec from an array of Fields. The array contains:\n/// 1. The serialized items, each taking up T::N Fields\n/// 2. The length of the BoundedVec as the last Field\n///\n/// # Type Parameters\n/// * `T` - The type of items stored in the BoundedVec, must implement Deserialize\n/// * `M` - The maximum length of the BoundedVec\n///\n/// # Fields Array Layout\n/// [item1_field1, item1_field2, ..., item2_field1, item2_field2, ..., length]\n/// Where:\n/// - itemN_fieldM: The M-th Field of the N-th item (T::N Fields per item)\n/// - length: The number of items in the BoundedVec (1 Field)\n///\n/// Total length N = T::N * M + 1, where:\n/// - T::N is the number of Fields needed to deserialize one item\n/// - M is the maximum length of the BoundedVec\n/// - +1 is for storing the length\n///\n/// # Note\n/// Not deriving this because it's not supported to call derive_deserialize on a \"remote\" struct (and it will never\n/// be supported).\nimpl<T, let M: u32> Deserialize for BoundedVec<T, M>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut new_bounded_vec: BoundedVec<T, M> = BoundedVec::new();\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        let len = fields[<T as Deserialize>::N * M] as u32;\n\n        for i in 0..len {\n            let mut nested_fields = [0; <T as Deserialize>::N];\n            for j in 0..<T as Deserialize>::N {\n                nested_fields[j] = fields[i * <T as Deserialize>::N + j];\n            }\n\n            let item = T::deserialize(nested_fields);\n            new_bounded_vec.push(item);\n        }\n\n        new_bounded_vec\n    }\n}\n\n// This may cause issues if used as program input, because noir disallows empty arrays for program input.\n// I think this is okay because I don't foresee a unit type being used as input. But leaving this comment as a hint\n// if someone does run into this in the future.\nimpl Deserialize for () {\n    let N: u32 = 0;\n\n    fn deserialize(_fields: [Field; Self::N]) -> Self {\n        ()\n    }\n}\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl<T, let M: u32> Serialize for BoundedVec<T, M>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M + 1; // +1 for the length of the BoundedVec\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut fields = [0; Self::N];\n\n        let storage = self.storage();\n\n        for i in 0..M {\n            let serialized_item = storage[i].serialize();\n\n            for j in 0..<T as Serialize>::N {\n                fields[i * <T as Serialize>::N + j] = serialized_item[j];\n            }\n        }\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        fields[<T as Serialize>::N * M] = self.len() as Field;\n\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Associated Constants\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let M: u32> Deserialize for str<M> {\n///     let N: u32 = M;\n///\n///     #[inline_always]\n///     fn deserialize(fields: [Field; Self::N]) -> Self {\n///         str::<Self::N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize {\n    let N: u32;\n\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let M: u32> Deserialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        str::<Self::N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Associated Constants\n/// * `N` - The length of the Field array, known at compile time\n#[derive_via(derive_packable)]\npub trait Packable {\n    let N: u32;\n\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n\n#[test]\nunconstrained fn bounded_vec_serialization() {\n    // Test empty BoundedVec\n    let empty_vec: BoundedVec<Field, 3> = BoundedVec::from_array([]);\n    let serialized = empty_vec.serialize();\n    let deserialized = BoundedVec::<Field, 3>::deserialize(serialized);\n    assert_eq(empty_vec, deserialized);\n    assert_eq(deserialized.len(), 0);\n\n    // Test partially filled BoundedVec\n    let partial_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2]]);\n    let serialized = partial_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(partial_vec, deserialized);\n    assert_eq(deserialized.len(), 1);\n    assert_eq(deserialized.get(0), [1, 2]);\n\n    // Test full BoundedVec\n    let full_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2], [3, 4], [5, 6]]);\n    let serialized = full_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(full_vec, deserialized);\n    assert_eq(deserialized.len(), 3);\n    assert_eq(deserialized.get(0), [1, 2]);\n    assert_eq(deserialized.get(1), [3, 4]);\n    assert_eq(deserialized.get(2), [5, 6]);\n}\n"
    },
    "388": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable for bool {\n    let N: u32 = BOOL_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> bool {\n        (fields[0] as u1) != 0\n    }\n}\n\nimpl Packable for u8 {\n    let N: u32 = U8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable for u16 {\n    let N: u32 = U16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable for u32 {\n    let N: u32 = U32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable for u64 {\n    let N: u32 = U64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable for u128 {\n    let N: u32 = U128_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable for Field {\n    let N: u32 = FIELD_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable for i8 {\n    let N: u32 = I8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Packable for i16 {\n    let N: u32 = I16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Packable for i32 {\n    let N: u32 = I32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Packable for i64 {\n    let N: u32 = I64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Packable for [T; M]\nwhere\n    T: Packable,\n{\n    let N: u32 = M * <T as Packable>::N;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized = self[i].pack();\n            for j in 0..<T as Packable>::N {\n                result[i * <T as Packable>::N + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Packable>::N, M>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "389": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal U1_SERIALIZED_LEN: u32 = 1;\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> bool {\n        fields[0] != 0\n    }\n}\n\nimpl Serialize for u1 {\n    let N: u32 = U1_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u1 {\n    let N: u32 = U1_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u1\n    }\n}\n\nimpl Serialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self]\n    }\n}\n\nimpl Deserialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n}\n\nimpl Deserialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Serialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n}\n\nimpl Deserialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Serialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n}\n\nimpl Deserialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Serialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n}\n\nimpl Deserialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Serialize for [T; M]\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M;\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; _] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized_t = self[i].serialize();\n            for j in 0..<T as Serialize>::N {\n                result[i * <T as Serialize>::N + j] = serialized_t[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let M: u32> Deserialize for [T; M]\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Deserialize>::N, M>(Deserialize::deserialize, result)\n    }\n}\n\nimpl<T> Serialize for Option<T>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N + 1;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n\n        result[0] = if self.is_some() { 1 } else { 0 };\n\n        let value_serialized = self.unwrap_unchecked().serialize();\n        for i in 0..<T as Serialize>::N {\n            result[1 + i] = value_serialized[i];\n        }\n\n        result\n    }\n}\n\nimpl<T> Deserialize for Option<T>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        if fields[0] == 1 {\n            let mut value_fields = [0; <T as Deserialize>::N];\n            for i in 0..<T as Deserialize>::N {\n                value_fields[i] = fields[1 + i];\n            }\n\n            Option::some(T::deserialize(value_fields))\n        } else {\n            Option::none()\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Serialize};\n\n    #[test]\n    fn u16_serialization() {\n        let a: u16 = 10;\n        assert_eq(a, u16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i8_serialization() {\n        let a: i8 = -10;\n        assert_eq(a, i8::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i16_serialization() {\n        let a: i16 = -10;\n        assert_eq(a, i16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i32_serialization() {\n        let a: i32 = -10;\n        assert_eq(a, i32::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i64_serialization() {\n        let a: i64 = -10;\n        assert_eq(a, i64::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn option_field_serialization() {\n        let opt_some = Option::some(5);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n\n    #[test]\n    fn array_serialization() {\n        let array = [1, 2, 3, 4];\n\n        let serialized: [Field; 4] = array.serialize();\n        let deserialized: [Field; 4] = Deserialize::deserialize(serialized);\n        assert_eq(deserialized, array);\n    }\n\n    #[test]\n    fn nested_array_serialization() {\n        let nested_array = [[1, 2, 3, 4], [5, 6, 7, 8]];\n\n        let serialized: [Field; 8] = nested_array.serialize();\n        let deserialized: [[Field; 4]; 2] = Deserialize::deserialize(serialized);\n\n        assert_eq(deserialized, nested_array);\n    }\n\n    #[test]\n    fn option_array_serialization() {\n        let opt_some = Option::some([2, 5]);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n}\n"
    },
    "394": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "global KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\npub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n/// Returns Option::some(sqrt) if there is a square root, and Option::none() if there isn't.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\nunconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n\n#[test]\nunconstrained fn sqrt_valid_test() {\n    let x = 16; // examples: 16, 9, 25, 81\n    let result = sqrt(x);\n    assert(result.is_some());\n    assert_eq(result.unwrap() * result.unwrap(), x);\n}\n\n#[test]\nunconstrained fn sqrt_invalid_test() {\n    let x = KNOWN_NON_RESIDUE; // has no square root in the field\n    let result = sqrt(x);\n    assert(result.is_none());\n}\n"
    },
    "398": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_u64(&mut self) -> u64 {\n        self.read() as u64\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() != 0\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert_eq(self.offset, self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "453": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/uint-note/src/uint_note.nr",
      "source": "use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    history::nullifier_inclusion::ProveNullifierInclusion,\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    messages::logs::note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{\n            GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER,\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT, PRIVATE_LOG_SIZE_IN_FIELDS,\n        },\n        hash::{compute_siloed_nullifier, poseidon2_hash_with_separator},\n        traits::{Deserialize, FromField, Hash, Packable, Serialize, ToField},\n    },\n};\n\n// UintNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the amount).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n/// A private note representing a numeric value associated to an account (e.g. a token balance).\n// docs:start:uint_note_def\n#[derive(Deserialize, Eq, Serialize, Packable)]\n#[custom_note]\npub struct UintNote {\n    /// The number stored in the note.\n    pub value: u128,\n}\n// docs:end:uint_note_def\n\nimpl NoteHash for UintNote {\n    // docs:start:compute_note_hash\n    fn compute_note_hash(\n        self,\n        owner: AztecAddress,\n        storage_slot: Field,\n        randomness: Field,\n    ) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because UintNote has just one variant (where the value is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let partial_note = PartialUintNote {\n            commitment: compute_partial_commitment(owner, storage_slot, randomness),\n        };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.value)\n    }\n    // docs:end:compute_note_hash\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        owner: AztecAddress,\n        note_hash_for_nullification: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullification, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(\n        self,\n        owner: AztecAddress,\n        note_hash_for_nullification: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullification, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl UintNote {\n    /// Creates a partial note that will hide the owner and storage slot but not the value, since the note will be later\n    /// completed in public. This is a powerful technique for scenarios in which the value cannot be known in private\n    /// (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// This function inserts a partial note validity commitment into the nullifier tree to be later on able to verify\n    /// that the partial note and completer are legitimate. See function docs of `compute_validity_commitment` for more\n    /// details.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` so that they can discover the\n    /// note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        completer: AztecAddress,\n    ) -> PartialUintNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = compute_partial_commitment(owner, storage_slot, randomness);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content = UintPartialNotePrivateLogContent { public_log_tag: commitment };\n\n        let encrypted_log = note::compute_partial_note_private_content_log(\n            private_log_content,\n            owner,\n            storage_slot,\n            randomness,\n            recipient,\n        );\n        // Regardless of the original content size, the log is padded with random bytes up to\n        // `PRIVATE_LOG_SIZE_IN_FIELDS` to prevent leaking information about the actual size.\n        let length = encrypted_log.len();\n        context.emit_private_log(encrypted_log, length);\n\n        let partial_note = PartialUintNote { commitment };\n\n        // Now we compute the validity commitment and push it to the nullifier tree. It can be safely pushed to\n        // the nullifier tree since it uses its own separator, making collisions with actual note nullifiers\n        // practically impossible.\n        let validity_commitment = partial_note.compute_validity_commitment(completer);\n        context.push_nullifier(validity_commitment);\n\n        partial_note\n    }\n}\n\n/// Computes a commitment to the private content of a partial UintNote, i.e. the fields that will remain private. All\n/// other note fields will be made public.\n// docs:start:compute_partial_commitment\nfn compute_partial_commitment(\n    owner: AztecAddress,\n    storage_slot: Field,\n    randomness: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [owner.to_field(), storage_slot, randomness],\n        GENERATOR_INDEX__NOTE_HASH,\n    )\n}\n// docs:end:compute_partial_commitment\n\n#[derive(Packable)]\nstruct UintPartialNotePrivateLogContent {\n    public_log_tag: Field,\n}\n\nimpl NoteType for UintPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        UintNote::get_id()\n    }\n}\n\n/// A partial instance of a UintNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the value field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the value to the public), resulting in a UintNote that can be used like any other one (except\n/// of course that its value is known).\n// docs:start:partial_uint_note_def\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct PartialUintNote {\n    commitment: Field,\n}\n// docs:end:partial_uint_note_def\n\nglobal NOTE_COMPLETION_LOG_LENGTH: u32 = 2;\n\nimpl PartialUintNote {\n    /// Completes the partial note, creating a new note that can be used like any other UintNote.\n    pub fn complete(self, context: PublicContext, completer: AztecAddress, value: u128) {\n        // A note with a value of zero is valid, but we cannot currently complete a partial note with such a value\n        // because this will result in the completion log having its last field set to 0. Public logs currently do not\n        // track their length, and so trailing zeros are simply trimmed. This results in the completion log missing its\n        // last field (the value), and note discovery failing.\n        // TODO(#11636): remove this\n        assert(value != 0, \"Cannot complete a PartialUintNote with a value of 0\");\n\n        // We verify that the partial note we're completing is valid (i.e. completer is correct, it uses the correct\n        // state variable's storage slot, and it is internally consistent).\n        let validity_commitment = self.compute_validity_commitment(completer);\n        assert(\n            context.nullifier_exists(validity_commitment, context.this_address()),\n            \"Invalid partial note or completer\",\n        );\n\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the value). The contract will later find it by searching\n        //  for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(value));\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    /// Completes the partial note, creating a new note that can be used like any other UintNote. Same as `complete`\n    /// function but works from private context.\n    pub fn complete_from_private(\n        self,\n        context: &mut PrivateContext,\n        completer: AztecAddress,\n        value: u128,\n    ) {\n        // We verify that the partial note we're completing is valid (i.e. completer is correct, it uses the correct\n        // state variable's storage slot, and it is internally consistent).\n        let validity_commitment = self.compute_validity_commitment(completer);\n        // `prove_nullifier_inclusion` function expects the nullifier to be siloed (hashed with the address of\n        // the contract that emitted the nullifier) as it checks the value directly against the nullifier tree and all\n        // the nullifiers in the tree are siloed by the protocol.\n        let siloed_validity_commitment =\n            compute_siloed_nullifier(context.this_address(), validity_commitment);\n        context.get_anchor_block_header().prove_nullifier_inclusion(siloed_validity_commitment);\n\n        // We need to do two things:\n        //  - emit an unencrypted log containing the public fields (the value) via the private log channel. The\n        //  contract will later find it by searching for the expected tag (which is simply the partial note\n        //  commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_private_log(\n            self.compute_note_completion_log_padded_for_private_log(value),\n            NOTE_COMPLETION_LOG_LENGTH,\n        );\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    /// Computes a validity commitment for this partial note. The commitment cryptographically binds the note's private\n    /// data with the designated completer address. When the note is later completed in public execution, we can load\n    /// this commitment from the nullifier tree and verify that both the partial note (e.g. that the storage slot\n    /// corresponds to the correct owner, and that we're using the correct state variable) and completer are\n    /// legitimate.\n    pub fn compute_validity_commitment(self, completer: AztecAddress) -> Field {\n        poseidon2_hash_with_separator(\n            [self.commitment, completer.to_field()],\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT,\n        )\n    }\n\n    fn compute_note_completion_log(self, value: u128) -> [Field; NOTE_COMPLETION_LOG_LENGTH] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, value.to_field()]\n    }\n\n    fn compute_note_completion_log_padded_for_private_log(\n        self,\n        value: u128,\n    ) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS] {\n        let note_completion_log = self.compute_note_completion_log(value);\n        let padding = [0; PRIVATE_LOG_SIZE_IN_FIELDS - NOTE_COMPLETION_LOG_LENGTH];\n        note_completion_log.concat(padding)\n    }\n\n    // docs:start:compute_complete_note_hash\n    fn compute_complete_note_hash(self, value: u128) -> Field {\n        // Here we finalize the note hash by including the (public) value into the partial note commitment. Note that we\n        // use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator(\n            [self.commitment, value.to_field()],\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n    // docs:end:compute_complete_note_hash\n}\n\nimpl ToField for PartialUintNote {\n    fn to_field(self) -> Field {\n        self.commitment\n    }\n}\n\nimpl FromField for PartialUintNote {\n    fn from_field(field: Field) -> Self {\n        Self { commitment: field }\n    }\n}\n\nmod test {\n    use super::{\n        compute_partial_commitment, PartialUintNote, UintNote, UintPartialNotePrivateLogContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{address::AztecAddress, traits::{Deserialize, FromField, Packable}},\n        utils::array::subarray,\n    };\n\n    global value: u128 = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a UintNote has the same note hash as a PartialUintNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n        let note = UintNote { value };\n        let note_hash = note.compute_note_hash(owner, storage_slot, randomness);\n\n        let partial_note = PartialUintNote {\n            commitment: compute_partial_commitment(owner, storage_slot, randomness),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(value);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular UintNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular UintNote.\n        let note = UintNote { value };\n\n        let commitment = compute_partial_commitment(owner, storage_slot, randomness);\n\n        let private_log_content = UintPartialNotePrivateLogContent { public_log_tag: commitment };\n        // The following is a misuse of the `deserialize` function, but this is just a test and it's better than\n        // letting devs manually construct it when they shouldn't be able to.\n        let partial_note = PartialUintNote::deserialize([commitment]);\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(value)[0],\n        );\n\n        // The completion log without the tag should match the note's packed representation.\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(value), 1);\n        assert_eq(public_log_without_tag, note.pack());\n    }\n}\n"
    },
    "47": {
      "path": "std/slice.nr",
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice with its index, returning a\n    // new slice containing the mapped elements.\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U] {\n        let mut ret = &[];\n        let mut index = 0;\n        for elem in self {\n            ret = ret.push_back(f(index, elem));\n            index += 1;\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for elem in self {\n            f(elem);\n        }\n    }\n\n    // Apply a function to each element of the slice with its index\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        let mut index = 0;\n        for elem in self {\n            f(index, elem);\n            index += 1;\n        }\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq(&[].map(|x| x + 1), &[]);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq(&[].mapi(|i, x| i * x + 1), &[]);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_each(|_x| assert(false));\n        assert(empty_slice == &[]);\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_eachi(|_i, _x| assert(false));\n        assert(empty_slice == &[]);\n    }\n\n    #[test]\n    fn map_example() {\n        let a = &[1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, &[2, 4, 6]);\n        assert_eq(a, &[1, 2, 3]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = &[1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, &[2, 5, 8]);\n        assert_eq(a, &[1, 2, 3]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_each(|a| { *b_ref = b_ref.push_back(a * 2); });\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { *b_ref = b_ref.push_back(i + a * 2); });\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n    #[test]\n    fn len_empty() {\n        let empty: [Field] = &[];\n        assert_eq(empty.len(), 0);\n    }\n\n    #[test]\n    fn len_single() {\n        assert_eq(&[42].len(), 1);\n    }\n\n    #[test]\n    fn len_multiple() {\n        assert_eq(&[1, 2, 3, 4, 5].len(), 5);\n    }\n\n    #[test]\n    fn push_back_empty() {\n        let empty: [Field] = &[];\n        let result = empty.push_back(42);\n        assert_eq(result.len(), 1);\n        assert_eq(result[0], 42);\n    }\n\n    #[test]\n    fn push_back_non_empty() {\n        let slice = &[1, 2, 3];\n        let result = slice.push_back(4);\n        assert_eq(result.len(), 4);\n        assert_eq(result, &[1, 2, 3, 4]);\n    }\n\n    #[test]\n    fn push_front_empty() {\n        let empty = &[];\n        let result = empty.push_front(42);\n        assert_eq(result.len(), 1);\n        assert_eq(result[0], 42);\n    }\n\n    #[test]\n    fn push_front_non_empty() {\n        let slice = &[1, 2, 3];\n        let result = slice.push_front(0);\n        assert_eq(result.len(), 4);\n        assert_eq(result, &[0, 1, 2, 3]);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds\")]\n    fn pop_back_empty() {\n        let slice: [Field] = &[];\n        let (_, _) = slice.pop_back();\n    }\n\n    #[test]\n    fn pop_back_one() {\n        let slice = &[42];\n        let (result, elem) = slice.pop_back();\n        assert_eq(result.len(), 0);\n        assert_eq(elem, 42);\n    }\n\n    #[test]\n    fn pop_back_multiple() {\n        let slice = &[1, 2, 3];\n        let (result, elem) = slice.pop_back();\n        assert_eq(result.len(), 2);\n        assert_eq(result, &[1, 2]);\n        assert_eq(elem, 3);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds\")]\n    fn pop_front_empty() {\n        let slice: [Field] = &[];\n        let (_, _) = slice.pop_front();\n    }\n\n    #[test]\n    fn pop_front_one() {\n        let slice = &[42];\n        let (elem, result) = slice.pop_front();\n        assert_eq(result.len(), 0);\n        assert_eq(elem, 42);\n    }\n\n    #[test]\n    fn pop_front_multiple() {\n        let slice = &[1, 2, 3];\n        let (elem, result) = slice.pop_front();\n        assert_eq(result.len(), 2);\n        assert_eq(result, &[2, 3]);\n        assert_eq(elem, 1);\n    }\n\n    #[test]\n    fn insert_beginning() {\n        let slice = &[1, 2, 3];\n        let result = slice.insert(0, 0);\n        assert_eq(result.len(), 4);\n        assert_eq(result, &[0, 1, 2, 3]);\n    }\n\n    #[test]\n    fn insert_middle() {\n        let slice = &[1, 2, 3];\n        let result = slice.insert(1, 99);\n        assert_eq(result.len(), 4);\n        assert_eq(result, &[1, 99, 2, 3]);\n    }\n\n    #[test]\n    fn insert_end() {\n        let slice = &[1, 2, 3];\n        let result = slice.insert(3, 4);\n        assert_eq(result.len(), 4);\n        assert_eq(result, &[1, 2, 3, 4]);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds\")]\n    fn insert_end_out_of_bounds() {\n        let slice = &[1, 2];\n        let _ = slice.insert(3, 4);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds\")]\n    fn remove_empty() {\n        let slice: [Field] = &[];\n        let (_, _) = slice.remove(0);\n    }\n\n    #[test]\n    fn remove_beginning() {\n        let slice = &[1, 2, 3];\n        let (result, elem) = slice.remove(0);\n        assert_eq(result.len(), 2);\n        assert_eq(result, &[2, 3]);\n        assert_eq(elem, 1);\n    }\n\n    #[test]\n    fn remove_middle() {\n        let slice = &[1, 2, 3];\n        let (result, elem) = slice.remove(1);\n        assert_eq(result.len(), 2);\n        assert_eq(result, &[1, 3]);\n        assert_eq(elem, 2);\n    }\n\n    #[test]\n    fn remove_end() {\n        let slice = &[1, 2, 3];\n        let (result, elem) = slice.remove(2);\n        assert_eq(result.len(), 2);\n        assert_eq(result, &[1, 2]);\n        assert_eq(elem, 3);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds\")]\n    fn remove_end_out_of_bounds() {\n        let slice = &[1, 2];\n        let (_, _) = slice.remove(2);\n    }\n\n    #[test]\n    fn fold_empty() {\n        let empty = &[];\n        let result = empty.fold(10, |acc, x| acc + x);\n        assert_eq(result, 10);\n    }\n\n    #[test]\n    fn fold_single() {\n        let slice = &[5];\n        let result = slice.fold(10, |acc, x| acc + x);\n        assert_eq(result, 15);\n    }\n\n    #[test]\n    fn fold_multiple() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.fold(0, |acc, x| acc + x);\n        assert_eq(result, 10);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds\")]\n    fn reduce_empty() {\n        let empty: [Field] = &[];\n        let _ = empty.reduce(|a, b| a + b);\n    }\n\n    #[test]\n    fn reduce_single() {\n        let slice = &[42];\n        let result = slice.reduce(|a, b| a + b);\n        assert_eq(result, 42);\n    }\n\n    #[test]\n    fn reduce_multiple() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.reduce(|a, b| a + b);\n        assert_eq(result, 10);\n    }\n\n    #[test]\n    fn filter_empty() {\n        let empty = &[];\n        let result = empty.filter(|x| x > 0);\n        assert_eq(result.len(), 0);\n    }\n\n    #[test]\n    fn filter_all_true() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.filter(|x| x > 0);\n        assert_eq(result, slice);\n    }\n\n    #[test]\n    fn filter_all_false() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.filter(|x| x > 10);\n        assert_eq(result.len(), 0);\n    }\n\n    #[test]\n    fn filter_some() {\n        let slice = &[1, 2, 3, 4, 5];\n        let result = slice.filter(|x| x % 2 == 0);\n        assert_eq(result, &[2, 4]);\n    }\n\n    #[test]\n    fn all_empty() {\n        let empty = &[];\n        let result = empty.all(|x| x > 0);\n        assert_eq(result, true);\n    }\n\n    #[test]\n    fn all_true() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.all(|x| x > 0);\n        assert_eq(result, true);\n    }\n\n    #[test]\n    fn all_false() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.all(|x| x > 2);\n        assert_eq(result, false);\n    }\n\n    #[test]\n    fn any_empty() {\n        let empty = &[];\n        let result = empty.any(|x| x > 0);\n        assert_eq(result, false);\n    }\n\n    #[test]\n    fn any_true() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.any(|x| x > 3);\n        assert_eq(result, true);\n    }\n\n    #[test]\n    fn any_false() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.any(|x| x > 10);\n        assert_eq(result, false);\n    }\n\n    // utility method tests\n    #[test]\n    fn append_empty_to_empty() {\n        let empty1: [Field] = &[];\n        let empty2: [Field] = &[];\n        let result = empty1.append(empty2);\n        assert_eq(result.len(), 0);\n    }\n\n    #[test]\n    fn append_empty_to_non_empty() {\n        let slice = &[1, 2, 3];\n        let empty = &[];\n        let result = slice.append(empty);\n        assert_eq(result, slice);\n    }\n\n    #[test]\n    fn append_non_empty_to_empty() {\n        let empty = &[];\n        let slice = &[1, 2, 3];\n        let result = empty.append(slice);\n        assert_eq(result, slice);\n    }\n\n    #[test]\n    fn append_two_non_empty() {\n        let slice1 = &[1, 2];\n        let slice2 = &[3, 4, 5];\n        let result = slice1.append(slice2);\n        assert_eq(result, &[1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    fn as_array_single() {\n        let slice = &[42];\n        let array: [Field; 1] = slice.as_array();\n        assert_eq(array[0], 42);\n    }\n\n    #[test]\n    fn as_array_multiple() {\n        let slice = &[1, 2, 3];\n        let array: [Field; 3] = slice.as_array();\n        assert_eq(array[0], 1);\n        assert_eq(array[1], 2);\n        assert_eq(array[2], 3);\n    }\n\n    // complex scenarios\n    #[test]\n    fn chain_operations() {\n        let slice = &[1, 2, 3, 4, 5];\n        let result = slice.filter(|x| x % 2 == 0).map(|x| x * 2).fold(0, |acc, x| acc + x);\n        assert_eq(result, 12); // (2*2) + (4*2) = 4 + 8 = 12\n    }\n\n    #[test]\n    fn nested_operations() {\n        let slice = &[1, 2, 3, 4];\n        let filtered = slice.filter(|x| x > 1);\n        let mapped = filtered.map(|x| x * x);\n        let sum = mapped.fold(0, |acc, x| acc + x);\n        assert_eq(sum, 29); // 2^2 + 3^2 + 4^2 = 4 + 9 + 16 = 29\n    }\n\n    #[test]\n    fn single_element_operations() {\n        let single = &[42];\n\n        // Test all operations on single element\n        assert_eq(single.len(), 1);\n\n        let pushed_back = single.push_back(99);\n        assert_eq(pushed_back, &[42, 99]);\n\n        let pushed_front = single.push_front(0);\n        assert_eq(pushed_front, &[0, 42]);\n\n        let (popped_back_slice, popped_back_elem) = single.pop_back();\n        assert_eq(popped_back_slice.len(), 0);\n        assert_eq(popped_back_elem, 42);\n\n        let (popped_front_elem, popped_front_slice) = single.pop_front();\n        assert_eq(popped_front_slice.len(), 0);\n        assert_eq(popped_front_elem, 42);\n\n        let inserted = single.insert(0, 0);\n        assert_eq(inserted, &[0, 42]);\n\n        let (removed_slice, removed_elem) = single.remove(0);\n        assert_eq(removed_slice.len(), 0);\n        assert_eq(removed_elem, 42);\n    }\n\n    #[test]\n    fn boundary_conditions() {\n        let slice = &[1, 2, 3];\n\n        // insert at boundaries\n        let at_start = slice.insert(0, 0);\n        assert_eq(at_start, &[0, 1, 2, 3]);\n\n        let at_end = slice.insert(3, 4);\n        assert_eq(at_end, &[1, 2, 3, 4]);\n\n        // remove at boundaries\n        let (removed_start, elem_start) = slice.remove(0);\n        assert_eq(removed_start, &[2, 3]);\n        assert_eq(elem_start, 1);\n\n        let (removed_end, elem_end) = slice.remove(2);\n        assert_eq(removed_end, &[1, 2]);\n        assert_eq(elem_end, 3);\n    }\n\n    #[test]\n    fn complex_predicates() {\n        let slice = &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\n        let even_greater_than_5 = slice.filter(|x| (x % 2 == 0) & (x > 5));\n        assert_eq(even_greater_than_5, &[6, 8, 10]);\n\n        let all_positive_and_less_than_20 = slice.all(|x| (x > 0) & (x < 20));\n        assert_eq(all_positive_and_less_than_20, true);\n\n        let any_divisible_by_7 = slice.any(|x| x % 7 == 0);\n        assert_eq(any_divisible_by_7, true);\n    }\n\n    #[test]\n    fn identity_operations() {\n        let slice = &[1, 2, 3, 4, 5];\n\n        let mapped_identity = slice.map(|x| x);\n        assert_eq(mapped_identity, slice);\n\n        let filtered_all = slice.filter(|_| true);\n        assert_eq(filtered_all, slice);\n\n        let filtered_none = slice.filter(|_| false);\n        assert_eq(filtered_none.len(), 0);\n    }\n\n    #[test(should_fail)]\n    fn as_array_size_mismatch() {\n        let slice = &[1, 2, 3];\n        let _: [Field; 5] = slice.as_array(); // size doesn't match\n    }\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        if result {\n            for i in 0..self.len() {\n                result &= self[i].eq(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let self_len = self.len();\n        let other_len = other.len();\n        let min_len = if self_len < other_len {\n            self_len\n        } else {\n            other_len\n        };\n\n        let mut result = Ordering::equal();\n        for i in 0..min_len {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self_len.cmp(other_len)\n        }\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use super::{Eq, max, min, Ord};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n\n    #[test]\n    fn correctly_handles_unequal_length_slices() {\n        let slice_1 = &[0, 1, 2, 3];\n        let slice_2 = &[0, 1, 2];\n        assert(!slice_1.eq(slice_2));\n    }\n\n    #[test]\n    fn lexicographic_ordering_for_slices() {\n        assert(&[2_u32].cmp(&[1_u32, 1_u32, 1_u32]) == super::Ordering::greater());\n        assert(&[1_u32, 2_u32].cmp(&[1_u32, 2_u32, 3_u32]) == super::Ordering::less());\n    }\n}\n"
    },
    "51": {
      "path": "/Users/jp4g/Workground/aztec/fde/crosschain/wormhole-demo/packages/aztec/src/message_bridge/src/main.nr",
      "source": "use aztec::macros::aztec;\n\npub mod types;\npub mod utils;\n\n#[aztec]\npub contract MessageBridge {\n    use aztec::{\n        macros::{\n            functions::{initializer, external, only_self},\n            storage::storage,\n        },\n        protocol_types::address::AztecAddress,\n        state_vars::{map::Map, public_mutable::PublicMutable, public_immutable::PublicImmutable},\n    };\n    use crate::{\n        types::{config::Config, emitter::Emitter},\n        utils::vaa::{encode_message_payload, decode_vaa},\n    };\n    use wormhole::Wormhole;\n\n    // ============================================================================\n    // STORAGE\n    // ============================================================================\n\n    #[storage]\n    struct Storage<Context> {\n        // Core configuration (immutable after deployment)\n        config: PublicImmutable<Config, Context>,\n\n        // Owner/admin address\n        owner: PublicMutable<AztecAddress, Context>,\n\n        // Registered emitters\n        // chain id => emitter address (one emitter per chain)\n        registered_emitters: Map<u16, PublicImmutable<Emitter, Context>, Context>,\n\n        // currently stored value\n        current_value: PublicMutable<u128, Context>,\n    }\n\n    // ============================================================================\n    // INITIALIZATION\n    // ============================================================================\n\n    #[external(\"public\")]\n    #[initializer]\n    fn constructor(\n        wormhole_address: AztecAddress,\n        chain_id: u16,\n        owner: AztecAddress,\n        message_fee: u128,\n        consistency: u8\n    ) {\n        self.storage.config.initialize(Config::new(\n            wormhole_address,\n            chain_id,\n            message_fee,\n            consistency\n        ));\n        self.storage.owner.write(owner);\n\n        // Initialize last received values to zero\n        self.storage.current_value.write(0);\n    }\n\n    /**\n     * Register up to 8 emitter addresses for source chains\n     *\n     * @param source_chain_id The chain ID of the source chain\n     */\n    #[external(\"public\")]\n    fn register_emitter(\n        source_chain_ids: BoundedVec<u16, 8>,\n        emitter_addresses: BoundedVec<[u8; 32], 8>,\n    ) {\n        // 1. check caller is admin\n        let owner = self.storage.owner.read();\n        let caller = self.msg_sender().expect(f\"Caller undefined\");\n        assert(owner == caller, \"Caller is not owner\");\n\n        // 2. check lengths match\n        assert(\n            source_chain_ids.len() == emitter_addresses.len(),\n            \"Source chain IDs and emitter addresses length mismatch\"\n        );\n        // 3. register emitters (store full 32-byte addresses)\n        for i in 0..8 {\n            if i < source_chain_ids.len() {\n                let source_chain_id = source_chain_ids.get_unchecked(i);\n                let emitter_address = emitter_addresses.get_unchecked(i);\n                self.storage.registered_emitters\n                    .at(source_chain_id)\n                    .initialize(Emitter { address: emitter_address });\n            }\n        }\n    }\n\n    // ============================================================================\n    // SEND MESSAGE (Aztec -> EVM)\n    // ============================================================================\n\n    #[external(\"public\")]\n    fn send_value_public(\n        destination_chain_id: u16,\n        value: u128,\n        fee_nonce: Field,\n    ) {\n        // no auth checks\n        let caller = self.msg_sender().expect(f\"Caller undefined\");\n        let config = self.storage.config.read();\n\n        // 1. Encode the message payload (just destination_chain_id + value)\n        let wormhole_payload = encode_message_payload(value, destination_chain_id);\n\n        // 2. Publish message publicly through Wormhole\n        let _ = self.call(Wormhole::at(config.wormhole_address).publish_message_in_public(\n            0, // nonce\n            wormhole_payload,\n            config.message_fee,\n            config.consistency,\n            caller,\n            fee_nonce,\n        ));\n    }\n\n    #[external(\"private\")]\n    fn send_value_private(\n        destination_chain_id: u16,\n        value: u128,\n        fee_nonce: Field,\n    ) {\n        // no auth checks\n        let caller = self.msg_sender().expect(f\"Caller undefiend\");\n        let config = self.storage.config.read();\n\n        // 1. Encode the message payload (just destination_chain_id + value)\n        let wormhole_payload = encode_message_payload(value, destination_chain_id);\n\n        // 2. Publish message privately through Wormhole\n        let _ = self.call(Wormhole::at(config.wormhole_address).publish_message_in_private(\n            0, // nonce\n            wormhole_payload,\n            config.message_fee,\n            config.consistency,\n            caller,\n            fee_nonce,\n        ));\n    }\n\n    // ============================================================================\n    // RECEIVE MESSAGE (EVM -> Aztec)\n    // ============================================================================\n    \n    #[external(\"private\")]\n    fn receive_value(vaa: [u8; 2000], length: u32) {\n        // 1. verify the VAA through Wormhole\n        let config = self.storage.config.read();\n        self.call(Wormhole::at(config.wormhole_address).verify_vaa(vaa, length));\n\n        // 2. decode the VAA (envelope + payload) and compute vaa nullifier\n        let (vaa_envelope, vaa_payload, vaa_nullifier) = decode_vaa(vaa);\n\n        // 3. validate destination chain is this chain\n        assert(\n            vaa_payload.destination_chain_id == config.chain_id,\n            \"Invalid destination chain ID\"\n        );\n\n        // 4. emit the nullifier to prevent replays\n        // note: will fail if nullifier has already been emitted\n        self.context.push_nullifier(vaa_nullifier);\n\n        // 5. validate emitter and update state (done in public to read public storage)\n        self.enqueue(MessageBridge::at(self.address)\n            ._validate_emitter_and_update_value(\n                vaa_envelope.emitter_chain_id,\n                vaa_envelope.emitter_address,\n                vaa_payload.value,\n            ))\n            \n    }\n\n    #[external(\"public\")]\n    #[only_self]\n    fn _validate_emitter_and_update_value(\n        emitter_chain_id: u16,\n        emitter_address: [u8; 32],\n        value: u128,\n    ) {\n        // Validate emitter from VAA envelope (not sender from payload)\n        let registered_emitter = self.storage.registered_emitters\n            .at(emitter_chain_id)\n            .read().address;\n        assert(registered_emitter == emitter_address, \"Emitter not registered\");\n\n        // Update state with received value\n        self.storage.current_value.write(value);\n    }\n\n    // ============================================================================\n    // VIEW FUNCTIONS\n    // ============================================================================\n\n    #[external(\"utility\")]\n    unconstrained fn get_config() -> Config {\n        self.storage.config.read()\n    }\n\n    #[external(\"utility\")]\n    unconstrained fn get_owner() -> AztecAddress {\n        self.storage.owner.read()\n    }\n\n    #[external(\"utility\")]\n    unconstrained fn is_emitter_registered(chain_id: u16, emitter_address: [u8; 32]) -> bool {\n        let registered_emitter = self.storage.registered_emitters\n            .at(chain_id)\n            .read().address;\n        registered_emitter == emitter_address\n    }\n\n    #[external(\"utility\")]\n    unconstrained fn get_registered_emitter(chain_id: u16) -> [u8; 32] {\n        self.storage.registered_emitters\n            .at(chain_id)\n            .read().address\n    }\n\n    #[external(\"utility\")]\n    unconstrained fn get_current_value() -> u128 {\n        self.storage.current_value.read()\n    }\n}\n"
    },
    "53": {
      "path": "/Users/jp4g/Workground/aztec/fde/crosschain/wormhole-demo/packages/aztec/src/message_bridge/src/types/emitter.nr",
      "source": "use aztec::protocol_types::traits::Packable;\n\n/// Emitter address which must be packed\n#[derive(Eq)]\npub struct Emitter {\n    pub address: [u8; 32]\n}\n\nimpl Packable for Emitter {\n\n    let N: u32 = 2;\n\n    fn pack(self) -> [Field; Self::N] {\n        let mut chunk_1_bytes = [0; 31];\n        for i in 0..31 {\n            chunk_1_bytes[i] = self.address[i];\n        }\n        let chunk_1 = Field::from_be_bytes(chunk_1_bytes);\n        let chunk_2 = self.address[31] as Field;\n        [chunk_1, chunk_2]\n    }\n\n    fn unpack(packed: [Field; Self::N]) -> Self {\n        let chunk_1_bytes: [u8; 31] = Field::to_be_bytes(packed[0]);\n        let mut address = [0; 32];\n        for i in 0..31 {\n            address[i] = chunk_1_bytes[i];\n        }\n        address[31] = packed[1] as u8;\n        Self { address }\n    }\n} \n"
    },
    "55": {
      "path": "/Users/jp4g/Workground/aztec/fde/crosschain/wormhole-demo/packages/aztec/src/message_bridge/src/utils/mod.nr",
      "source": "pub mod vaa;\n\n// VAA structure offsets (hardcoded for 1 signature)\npub global VAA_HEADER_SIZE: u32 = 6;        // version(1) + guardian_set(4) + num_sigs(1)\npub global VAA_SIGNATURE_SIZE: u32 = 66;    // guardian_index(1) + signature(64) + recovery(1)\npub global VAA_ENVELOPE_START: u32 = VAA_HEADER_SIZE + VAA_SIGNATURE_SIZE; // = 72\npub global VAA_ENVELOPE_SIZE: u32 = 51;     // timestamp(4) + nonce(4) + emitter_chain(2) + emitter_addr(32) + sequence(8) + consistency(1)\npub global VAA_PAYLOAD_START: u32 = VAA_ENVELOPE_START + VAA_ENVELOPE_SIZE; // = 123\n\npub global VAA_MAX_LENGTH: u32 = 2000;      // max VAA length in Wormhole spec\npub global VAA_BODY_MAX_LENGTH: u32 = 1860; // max body length in Wormhole VAA spec\n\n// Message payload structure (18 bytes): destinationChainId (2) + value (16)\npub global MESSAGE_PAYLOAD_LENGTH: u32 = 18;\npub global MESSAGE_NULLIFIER_LENGTH: u32 = VAA_ENVELOPE_SIZE + MESSAGE_PAYLOAD_LENGTH; // 51 + 18 = 69\npub global MESSAGE_NULLIFIER_PACKED_LENGTH: u32 = 3; // ceil(69 / 31) = 3\n\n/// Decoded VAA envelope (excludes header and signatures)\npub struct DecodedVAAEnvelope {\n    pub timestamp: u32,\n    pub nonce: u32,\n    pub emitter_chain_id: u16,\n    pub emitter_address: [u8; 32],\n    pub sequence: u64,\n    pub consistency_level: u8,\n}\n\n\n/// Decoded message payload (18 bytes)\npub struct DecodedVAAPayload {\n    pub destination_chain_id: u16,\n    pub value: u128,\n}\n\n// probably should just use Field::to_le_bytes but meh\npub fn u16_to_u8(value: u16) -> [u8; 2] {\n    // Safety: constrained below, use unconstrained for bitwise ops\n    let decomposed = unsafe { _u16_to_u8(value) };\n    let asserted = decomposed[0] as u16 * 256 + decomposed[1] as u16;\n    assert(asserted == value, \"u16 to u8 conversion failed\");\n    decomposed\n}\n\nunconstrained fn _u16_to_u8(value: u16) -> [u8; 2] {\n    let high = (value >> 8) as u8;\n    let low = (value & 0xFF) as u8;\n    [high, low]\n}"
    },
    "56": {
      "path": "/Users/jp4g/Workground/aztec/fde/crosschain/wormhole-demo/packages/aztec/src/message_bridge/src/utils/vaa.nr",
      "source": "use keccak256::keccak256;\nuse poseidon::poseidon2::Poseidon2;\nuse crate::utils::{\n    VAA_MAX_LENGTH,\n    VAA_ENVELOPE_START,\n    VAA_PAYLOAD_START,\n    MESSAGE_NULLIFIER_LENGTH,\n    MESSAGE_NULLIFIER_PACKED_LENGTH,\n    DecodedVAAEnvelope,\n    DecodedVAAPayload,\n    u16_to_u8,\n};\nuse nodash::pack_bytes;\n\npub struct DecodedVAA {\n    pub envelope: DecodedVAAEnvelope,\n    pub payload: DecodedVAAPayload,\n}\n\n/// Parse a raw VAA and extract envelope, payload, and compute nullifier\n///\n/// VAA structure (with 1 signature):\n///   Bytes 0-5:     Header (version, guardian set, num sigs) - skipped\n///   Bytes 6-71:    Signature - skipped\n///   Bytes 72-122:  Envelope (timestamp, nonce, emitter chain, emitter addr, sequence, consistency)\n///   Bytes 123+:    Payload\npub fn decode_vaa(vaa: [u8; VAA_MAX_LENGTH]) -> (\n    DecodedVAAEnvelope,\n    DecodedVAAPayload,\n    Field,\n) {\n    let envelope = decode_vaa_envelope(vaa);\n    let payload = decode_vaa_payload(vaa);\n    let nullifier = compute_vaa_nullifier(vaa);\n    (envelope, payload, nullifier)\n}\n\n/// Parse the VAA envelope (starts at byte 72 for 1 signature)\n///\n/// Envelope structure (51 bytes):\n///   Bytes 0-3:   timestamp (u32, big-endian)\n///   Bytes 4-7:   nonce (u32, big-endian)\n///   Bytes 8-9:   emitter_chain_id (u16, big-endian)\n///   Bytes 10-41: emitter_address (32 bytes)\n///   Bytes 42-49: sequence (u64, big-endian)\n///   Byte 50:     consistency_level (u8)\npub fn decode_vaa_envelope(vaa: [u8; VAA_MAX_LENGTH]) -> DecodedVAAEnvelope {\n    let offset = VAA_ENVELOPE_START;\n\n    // timestamp (4 bytes, big-endian)\n    let mut timestamp_bytes: [u8; 4] = [0; 4];\n    for i in 0..4 {\n        timestamp_bytes[i] = vaa[offset + i];\n    }\n    let timestamp = Field::from_be_bytes(timestamp_bytes) as u32;\n\n    // nonce (4 bytes, big-endian)\n    let mut nonce_bytes: [u8; 4] = [0; 4];\n    for i in 0..4 {\n        nonce_bytes[i] = vaa[offset + 4 + i];\n    }\n    let nonce = Field::from_be_bytes(nonce_bytes) as u32;\n\n    // emitter_chain_id (2 bytes, big-endian)\n    let mut chain_id_bytes: [u8; 2] = [0; 2];\n    for i in 0..2 {\n        chain_id_bytes[i] = vaa[offset + 8 + i];\n    }\n    let emitter_chain_id = Field::from_be_bytes(chain_id_bytes) as u16;\n\n    // emitter_address (32 bytes)\n    let mut emitter_address: [u8; 32] = [0; 32];\n    for i in 0..32 {\n        emitter_address[i] = vaa[offset + 10 + i];\n    }\n\n    // sequence (8 bytes, big-endian)\n    let mut sequence_bytes: [u8; 8] = [0; 8];\n    for i in 0..8 {\n        sequence_bytes[i] = vaa[offset + 42 + i];\n    }\n    let sequence = Field::from_be_bytes(sequence_bytes) as u64;\n\n    // consistency_level (1 byte)\n    let consistency_level = vaa[offset + 50];\n\n    DecodedVAAEnvelope {\n        timestamp,\n        nonce,\n        emitter_chain_id,\n        emitter_address,\n        sequence,\n        consistency_level,\n    }\n}\n\n/// Parse the VAA payload (starts at byte 123 for 1 signature)\n///\n/// Payload structure (18 bytes):\n///   Bytes 0-1:   destination_chain_id (u16, big-endian)\n///   Bytes 2-17:  value (u128, big-endian)\npub fn decode_vaa_payload(vaa: [u8; VAA_MAX_LENGTH]) -> DecodedVAAPayload {\n    let offset = VAA_PAYLOAD_START;\n\n    // destination_chain_id (2 bytes, big-endian)\n    let destination_chain_id = (\n        (vaa[offset] as Field) * 256\n        + (vaa[offset + 1] as Field)\n    ) as u16;\n\n    // value (16 bytes, big-endian) - parse as u128 via Field multiplication\n    let mut value_bytes: [u8; 16] = [0; 16];\n    for i in 0..16 {\n        value_bytes[i] = vaa[offset + 2 + i];\n    }\n    let value = Field::from_be_bytes(value_bytes) as u128;\n\n    DecodedVAAPayload {\n        destination_chain_id,\n        value,\n    }\n}\n\n/// Compute nullifier from VAA bytes (for replay protection)\nfn compute_vaa_nullifier(vaa: [u8; VAA_MAX_LENGTH]) -> Field {\n    // Pack the relevant bytes (envelope + payload) for hashing\n    let mut nullifier_bytes = [0; MESSAGE_NULLIFIER_LENGTH];\n    for i in 0..MESSAGE_NULLIFIER_LENGTH {\n        nullifier_bytes[i] = vaa[VAA_ENVELOPE_START + i];\n    }\n\n    let packed = pack_bytes(nullifier_bytes);\n    Poseidon2::hash(packed, MESSAGE_NULLIFIER_PACKED_LENGTH)\n}\n\n/// Encode a message payload for sending via Wormhole (Aztec -> EVM)\n///\n/// Payload structure (18 bytes):\n///   Bytes 0-1:   destination_chain_id (u16, big-endian)\n///   Bytes 2-17:  value (u128, big-endian)\n///\n/// Returns 8 chunks of 31 bytes for Aztec Field compatibility\npub fn encode_message_payload(\n    value: u128,\n    destination_chain_id: u16,\n) -> [[u8; 31]; 8] {\n    let mut wormhole_payload: [[u8; 31]; 8] = [[0; 31]; 8];\n\n    let destination_chain_bytes = u16_to_u8(destination_chain_id);\n    let value_bytes: [u8; 16] = Field::to_be_bytes(value as Field);\n\n    // Chunk 0: destination_chain_id (2 bytes) + value (16 bytes) = 18 bytes total\n    wormhole_payload[0][0] = destination_chain_bytes[0];\n    wormhole_payload[0][1] = destination_chain_bytes[1];\n    for i in 0..16 {\n        wormhole_payload[0][2 + i] = value_bytes[i];\n    }\n\n    wormhole_payload\n}\n\n// Keccak hash of VAA body (for signature verification)\npub fn compute_vaa_hash(body_bytes: [u8; 1860], body_length: u32) -> [u8; 32] {\n    let mut actual_body = [0; 1860];\n    for i in 0..body_length {\n        actual_body[i] = body_bytes[i];\n    }\n\n    // Double hash as per Wormhole spec\n    let hash: [u8; 32] = keccak256(actual_body, body_length);\n    let double_hash: [u8; 32] = keccak256(hash, 32);\n\n    double_hash\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a [`Vec`][crate::collections::vec::Vec]`<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0, \"cannot pop from an empty vector\");\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use [`from_parts_unchecked`][Self::from_parts_unchecked] to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            let _ = vec.get(0);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_beyond_length() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            let _ = vec.get(3);\n        }\n\n        #[test]\n        fn get_works_within_bounds() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(2), 3);\n            assert_eq(vec.get(4), 5);\n        }\n\n        #[test]\n        fn get_unchecked_works() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(0), 1);\n            assert_eq(vec.get_unchecked(2), 3);\n        }\n\n        #[test]\n        fn get_unchecked_works_past_len() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(4), 0);\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_setting_beyond_length() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            vec.set(3, 4);\n        }\n\n        #[test]\n        fn set_unchecked_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(0, 10);\n            assert_eq(vec.get(0), 10);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn set_unchecked_operations_past_len() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(3, 40);\n            assert_eq(vec.get(3), 40);\n        }\n\n        #[test]\n        fn set_preserves_other_elements() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            vec.set(2, 30);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 30);\n            assert_eq(vec.get(3), 4);\n            assert_eq(vec.get(4), 5);\n        }\n    }\n\n    mod any {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn returns_false_if_predicate_not_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, false, false]);\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn returns_true_if_predicate_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, true, true]);\n            let result = vec.any(|value| value);\n\n            assert(result);\n        }\n\n        #[test]\n        fn returns_false_on_empty_boundedvec() {\n            let vec: BoundedVec<bool, 0> = BoundedVec::new();\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn any_with_complex_predicates() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            assert(vec.any(|x| x > 3));\n            assert(!vec.any(|x| x > 10));\n            assert(vec.any(|x| x % 2 == 0)); // has a even number\n            assert(vec.any(|x| x == 3)); // has a specific value\n        }\n\n        #[test]\n        fn any_with_partial_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            assert(vec.any(|x| x == 1));\n            assert(vec.any(|x| x == 2));\n            assert(!vec.any(|x| x == 3));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn map_with_conditional_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.map(|x| if x % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([1, 4, 3, 8]);\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn map_preserves_length() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|x| x * 2);\n\n            assert_eq(result.len(), vec.len());\n            assert_eq(result.max_len(), vec.max_len());\n        }\n\n        #[test]\n        fn map_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let result = vec.map(|x| x * 2);\n            assert_eq(result, vec);\n            assert_eq(result.len(), 0);\n            assert_eq(result.max_len(), 5);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn mapi_with_index_branching_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.mapi(|i, x| if i % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([2, 2, 6, 4]);\n            assert_eq(result, expected);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_each_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_each(|_| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_each_with_side_effects() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let mut seen = BoundedVec::<u32, 3>::new();\n            let seen_ref = &mut seen;\n            vec.for_each(|x| seen_ref.push(x));\n            assert_eq(seen, vec);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_eachi_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_eachi(|_, _| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_eachi_with_index_tracking() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([10, 20, 30]);\n            let mut indices = BoundedVec::<u32, 3>::new();\n            let indices_ref = &mut indices;\n            vec.for_eachi(|i, _| indices_ref.push(i));\n\n            let expected = BoundedVec::from_array([0, 1, 2]);\n            assert_eq(indices, expected);\n        }\n\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n\n        #[test]\n        fn from_array_preserves_order() {\n            let array = [5, 3, 1, 4, 2];\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array(array);\n            for i in 0..array.len() {\n                assert_eq(vec.get(i), array[i]);\n            }\n        }\n\n        #[test]\n        fn from_array_with_different_types() {\n            let bool_array = [true, false, true];\n            let bool_vec: BoundedVec<bool, 3> = BoundedVec::from_array(bool_array);\n            assert_eq(bool_vec.len(), 3);\n            assert_eq(bool_vec.get(0), true);\n            assert_eq(bool_vec.get(1), false);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n\n    mod push_pop {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn push_and_pop_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            assert_eq(vec.len(), 0);\n\n            vec.push(1);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 1);\n\n            vec.push(2);\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.get(1), 2);\n\n            let popped = vec.pop();\n            assert_eq(popped, 2);\n            assert_eq(vec.len(), 1);\n\n            let popped2 = vec.pop();\n            assert_eq(popped2, 1);\n            assert_eq(vec.len(), 0);\n        }\n\n        #[test(should_fail_with = \"push out of bounds\")]\n        fn push_to_full_vector() {\n            let mut vec: BoundedVec<u32, 2> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n            vec.push(3); // should panic\n        }\n\n        #[test(should_fail_with = \"cannot pop from an empty vector\")]\n        fn pop_from_empty_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let _ = vec.pop(); // should panic\n        }\n\n        #[test]\n        fn push_pop_cycle() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n\n            // push to full\n            vec.push(1);\n            vec.push(2);\n            vec.push(3);\n            assert_eq(vec.len(), 3);\n\n            // pop all\n            assert_eq(vec.pop(), 3);\n            assert_eq(vec.pop(), 2);\n            assert_eq(vec.pop(), 1);\n            assert_eq(vec.len(), 0);\n\n            // push again\n            vec.push(4);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 4);\n        }\n    }\n\n    mod extend {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn extend_from_array() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_slice() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_bounded_vec() {\n            let mut vec1: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut vec2: BoundedVec<u32, 3> = BoundedVec::new();\n\n            vec1.push(1);\n            vec2.push(2);\n            vec2.push(3);\n\n            vec1.extend_from_bounded_vec(vec2);\n\n            assert_eq(vec1.len(), 3);\n            assert_eq(vec1.get(0), 1);\n            assert_eq(vec1.get(1), 2);\n            assert_eq(vec1.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"extend_from_array out of bounds\")]\n        fn extend_array_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3, 4]); // should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_slice out of bounds\")]\n        fn extend_slice_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3, 4]); // S]should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_bounded_vec out of bounds\")]\n        fn extend_bounded_vec_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            let other: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            vec.extend_from_bounded_vec(other); // should panic\n        }\n\n        #[test]\n        fn extend_with_empty_collections() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let original_len = vec.len();\n\n            vec.extend_from_array([]);\n            assert_eq(vec.len(), original_len);\n\n            vec.extend_from_slice(&[]);\n            assert_eq(vec.len(), original_len);\n\n            let empty: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.extend_from_bounded_vec(empty);\n            assert_eq(vec.len(), original_len);\n        }\n    }\n\n    mod storage {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn storage_consistency() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            // test initial storage state\n            assert_eq(vec.storage(), [0, 0, 0, 0, 0]);\n\n            vec.push(1);\n            vec.push(2);\n\n            // test storage after modifications\n            assert_eq(vec.storage(), [1, 2, 0, 0, 0]);\n\n            // storage doesn't change length\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.max_len(), 5);\n        }\n\n        #[test]\n        fn storage_after_pop() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n\n            let _ = vec.pop();\n            // after pop, the last element should be zeroed\n            assert_eq(vec.storage(), [1, 2, 0]);\n            assert_eq(vec.len(), 2);\n        }\n\n        #[test]\n        fn vector_immutable() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let storage = vec.storage();\n\n            assert_eq(storage, [1, 2, 3]);\n\n            // Verify that the original vector is unchanged\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n    }\n}\n"
    },
    "65": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push(self, value: T)\n    where\n        T: Serialize,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get(self, index: u32) -> T\n    where\n        T: Deserialize,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n\n    global SLOT: Field = 1230;\n\n    #[test]\n    unconstrained fn empty_array() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            let _: Field = array.get(0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            assert_eq(array.len(), 1);\n            assert_eq(array.get(0), 5);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            let _ = array.get(1);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(5);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            assert_eq(array.len(), 3);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 8);\n            assert_eq(array.get(2), 9);\n\n            array.remove(1);\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 9);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            array.remove(1);\n            array.remove(1);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n            // we do not care about the order in which each tuple was passed to the closure.\n            let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n            array.for_each(|index, value| { called_with.push((index, value)); });\n\n            assert_eq(called_with.len(), 3);\n            assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n            assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n            assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| {\n                if index == 1 {\n                    array.remove(index);\n                }\n            });\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 4);\n            assert_eq(array.get(1), 6);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all_no_copy() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We test that the utilityCopyCapsule was never called, which is the expensive operation we want to avoid.\n            let mock = std::test::OracleMock::mock(\"utilityCopyCapsule\");\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(mock.times_called(), 0);\n        });\n    }\n}\n"
    },
    "66": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/context/calls.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\nuse crate::hash::{hash_args, hash_calldata_array};\nuse crate::oracle::execution_cache;\n\n// PrivateCall\n\n#[must_use = \"Your private call needs to be passed into the `self.call(...)` method to be executed (e.g. `self.call(MyContract::at(address).my_private_function(...args))`\"]\npub struct PrivateCall<let M: u32, let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<M>,\n    args_hash: Field,\n    pub args: [Field; N],\n    return_type: T,\n}\n\nimpl<let M: u32, let N: u32, T> PrivateCall<M, N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field; N],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n}\n\nimpl<let M: u32, let N: u32, T> PrivateCall<M, N, T>\nwhere\n    T: Deserialize,\n{\n    /// **[DEPRECATED]**\n    /// This function is deprecated. Please use the new contract API:\n    /// `self.call(MyContract::at(address).my_private_function(...args))`\n    /// instead of manually constructing and calling `PrivateCall`.\n    pub fn call(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n\n        // If T is () (i.e. if the function does not return anything) then `get_preimage` will constrain that the\n        // returns hash is empty as per the protocol rules.\n        returns_hash.get_preimage()\n    }\n}\n\n// PrivateStaticCall\n\n#[must_use = \"Your private static call needs to be passed into the `self.view(...)` method to be executed (e.g. `self.view(MyContract::at(address).my_private_static_function(...args))`\"]\npub struct PrivateStaticCall<let M: u32, let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<M>,\n    args_hash: Field,\n    pub args: [Field; N],\n    return_type: T,\n}\n\nimpl<let M: u32, let N: u32, T> PrivateStaticCall<M, N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field; N],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n\n    /// **[DEPRECATED]**\n    /// This function is deprecated. Please use the new contract API:\n    /// `self.view(MyContract::at(address).my_private_static_function(...args))`\n    /// instead of manually constructing and calling `PrivateCall`.\n    pub fn view(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\n// PublicCall\n\n#[must_use = \"Your public call needs to be passed into the `self.call(...)`, `self.enqueue(...)` or `self.enqueue_incognito(...)` method to be executed (e.g. `self.call(MyContract::at(address).my_public_function(...args))`\"]\npub struct PublicCall<let M: u32, let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<M>,\n    pub args: [Field; N],\n    gas_opts: GasOpts,\n    return_type: T,\n}\n\nimpl<let M: u32, let N: u32, T> PublicCall<M, N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field; N],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n        }\n    }\n\n    pub fn with_gas(mut self, gas_opts: GasOpts) -> Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    /// **[DEPRECATED]**\n    /// This function is deprecated. Please use the new contract API:\n    /// `self.call(MyContract::at(address).my_public_function(...args))`\n    /// instead of manually constructing and calling `PublicCall`.\n    pub unconstrained fn call(self, context: PublicContext) -> T\n    where\n        T: Deserialize,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        // If T is () (i.e. if the function does not return anything) then `as_array` will constrain that `returns` has\n        // a length of 0 (since that is ()'s deserialization length).\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// **[DEPRECATED]**\n    /// This function is deprecated. Please use the new contract API:\n    /// `self.enqueue(MyContract::at(address).my_public_function(...args))`\n    /// instead of manually constructing and calling `PublicCall`.\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        self.enqueue_impl(context, false, false)\n    }\n\n    /// **[DEPRECATED]**\n    /// This function is deprecated. Please use the new contract API:\n    /// `self.enqueue_incognito(MyContract::at(address).my_public_function(...args))`\n    /// instead of manually constructing and calling `PublicCall`.\n    pub fn enqueue_incognito(self, context: &mut PrivateContext) {\n        self.enqueue_impl(context, false, true)\n    }\n\n    fn enqueue_impl(\n        self,\n        context: &mut PrivateContext,\n        is_static_call: bool,\n        hide_msg_sender: bool,\n    ) {\n        let calldata = [self.selector.to_field()].concat(self.args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            is_static_call,\n            hide_msg_sender,\n        )\n    }\n\n    /// **[DEPRECATED]**\n    /// This function is deprecated. Please use the new contract API:\n    /// `self.set_as_teardown(MyContract::at(address).my_public_function(...args))`\n    /// instead of manually constructing and setting the teardown function `PublicCall`.\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        self.set_as_teardown_impl(context, false);\n    }\n\n    /// **[DEPRECATED]**\n    /// This function is deprecated. Please use the new contract API:\n    /// `self.set_as_teardown_incognito(MyContract::at(address).my_public_function(...args))`\n    /// instead of manually constructing and setting the teardown function `PublicCall`.\n    pub fn set_as_teardown_incognito(self, context: &mut PrivateContext) {\n        self.set_as_teardown_impl(context, true);\n    }\n\n    fn set_as_teardown_impl(self, context: &mut PrivateContext, hide_msg_sender: bool) {\n        let calldata = [self.selector.to_field()].concat(self.args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n}\n\n// PublicStaticCall\n\n#[must_use = \"Your public static call needs to be passed into the `self.view(...)`, `self.enqueue_view(...)` or `self.enqueue_view_incognito(...)` method to be executed (e.g. `self.view(MyContract::at(address).my_public_static_function(...args))`\"]\npub struct PublicStaticCall<let M: u32, let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<M>,\n    pub args: [Field; N],\n    return_type: T,\n    gas_opts: GasOpts,\n}\n\nimpl<let M: u32, let N: u32, T> PublicStaticCall<M, N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field; N],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(mut self, gas_opts: GasOpts) -> Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    /// **[DEPRECATED]**\n    /// This function is deprecated. Please use the new contract API:\n    /// `self.view(MyContract::at(address).my_public_static_function(...args))`\n    /// instead of manually constructing and calling `PublicStaticCall`.\n    pub unconstrained fn view(self, context: PublicContext) -> T\n    where\n        T: Deserialize,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// **[DEPRECATED]**\n    /// This function is deprecated. Please use the new contract API:\n    /// `self.enqueue_view(MyContract::at(address).my_public_static_function(...args))`\n    /// instead of manually constructing and calling `PublicStaticCall`.\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = [self.selector.to_field()].concat(self.args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n            false,\n        )\n    }\n\n    /// **[DEPRECATED]**\n    /// This function is deprecated. Please use the new contract API:\n    /// `self.enqueue_view_incognito(MyContract::at(address).my_public_static_function(...args))`\n    /// instead of manually constructing and calling `PublicStaticCall`.\n    pub fn enqueue_view_incognito(self, context: &mut PrivateContext) {\n        let calldata = [self.selector.to_field()].concat(self.args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n            true,\n        )\n    }\n}\n\n// UtilityCall\n\npub struct UtilityCall<let M: u32, let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<M>,\n    args_hash: Field,\n    pub args: [Field; N],\n    return_type: T,\n}\n\nimpl<let M: u32, let N: u32, T> UtilityCall<M, N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field; N],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n}\n"
    },
    "73": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/context/note_hash_read.nr",
      "source": "use protocol_types::address::aztec_address::AztecAddress;\n\npub struct NoteHashRead {\n    note_hash: Field,\n    contract_address: Option<AztecAddress>,\n}\n\nimpl NoteHashRead {\n    pub fn new_transient(note_hash: Field, contract_address: AztecAddress) -> Self {\n        assert(\n            !contract_address.is_zero(),\n            \"Can't read a transient note with a zero contract address\",\n        );\n        Self { note_hash, contract_address: Option::some(contract_address) }\n    }\n\n    pub fn new_settled(note_hash: Field) -> Self {\n        Self { note_hash, contract_address: Option::none() }\n    }\n\n    pub fn note_hash(self) -> Field {\n        self.note_hash\n    }\n\n    pub fn contract_address(self) -> Option<AztecAddress> {\n        self.contract_address\n    }\n}\n"
    },
    "74": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{\n        inputs::PrivateContextInputs, note_hash_read::NoteHashRead, returns_hash::ReturnsHash,\n    },\n    hash::{hash_args, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            is_side_effect_counter_revertible_oracle_wrapper, notify_enqueued_public_function_call,\n            notify_set_min_revertible_side_effect_counter, notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        logs::notify_created_contract_class_log,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        block_header::BlockHeader,\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log_hash::LogHash,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::{PrivateLog, PrivateLogData},\n        public_call_request::PublicCallRequest,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, MAX_CONTRACT_CLASS_LOGS_PER_CALL,\n        MAX_ENQUEUED_CALLS_PER_CALL, MAX_INCLUDE_BY_TIMESTAMP_DURATION,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        NULL_MSG_SENDER_CONTRACT_ADDRESS, PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    hash::poseidon2_hash,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    side_effect::{Counted, scoped::Scoped},\n    traits::{Empty, Hash, ToField},\n    utils::arrays::{ClaimedLengthArray, find_first_index, trimmed_array_length_hint},\n};\n\n/// # PrivateContext\n///\n/// The **main interface** between an #[external(\"private\")] function and the Aztec blockchain.\n///\n/// An instance of the PrivateContext is initialized automatically at the outset\n/// of every private function, within the #[external(\"private\")] macro, so you'll never\n/// need to consciously instantiate this yourself.\n///\n/// The instance is always named `context`, and it is always be available within\n/// the body of every #[external(\"private\")] function in your smart contract.\n///\n/// > For those used to \"vanilla\" Noir, it might be jarring to have access to\n/// > `context` without seeing a declaration `let context = PrivateContext::new(...)`\n/// > within the body of your function. This is just a consequence of using\n/// > macros to tidy-up verbose boilerplate. You can use `nargo expand` to\n/// > expand all macros, if you dare.\n///\n/// Typical usage for a smart contract developer will be to call getter\n/// methods of the PrivateContext.\n///\n/// _Pushing_ data and requests to the context is mostly handled within\n/// aztec-nr's own functions, so typically a smart contract developer won't\n/// need to call any setter methods directly.\n///\n/// > Advanced users might occasionally wish to push data to the context\n/// > directly for lower-level control. If you find yourself doing this, please\n/// > open an issue on GitHub to describe your use case: it might be that\n/// > new functionality should be added to aztec-nr.\n///\n/// ## Responsibilities\n/// - Exposes contextual data to a private function:\n///   - Data relating to how this private function was called.\n///     - msg_sender\n///     - this_address - (the contract address of the private function being\n///                      executed)\n///     - See `CallContext` for more data.\n///   - Data relating to the transaction in which this private function is\n///     being executed.\n///     - chain_id\n///     - version\n///     - gas_settings\n/// - Provides state access:\n///   - Access to the \"Anchor block\" header.\n///     Recall, a private function cannot read from the \"current\" block header,\n///     but must read from some historical block header, because as soon as\n///     private function execution begins (asynchronously, on a user's device),\n///     the public state of the chain (the \"current state\") will have progressed\n///     forward. We call this reference the \"Anchor block\".\n///     See `BlockHeader`.\n///   - Enables consumption of L1->L2 messages.\n/// - Enables calls to functions of other smart contracts:\n///   - Private function calls\n///   - Enqueueing of public function call requests\n///     (Since public functions are executed at a later time, by a block\n///     proposer, we say they are \"enqueued\").\n/// - Writes data to the blockchain:\n///   - New notes\n///   - New nullifiers\n///   - Private logs (for sending encrypted note contents or encrypted events)\n///   - New L2->L1 messages.\n/// - Provides args to the private function (handled by the #[external(\"private\")] macro).\n/// - Returns the return values of this private function (handled by the\n///   #[external(\"private\")] macro).\n/// - Makes Key Validation Requests.\n///   - Private functions are not allowed to see master secret keys, because we\n///     do not trust them. They are instead given \"app-siloed\" secret keys with\n///     a claim that they relate to a master public key. They can then request\n///     validation of this claim, by making a \"key validation request\" to the\n///     protocol's kernel circuits (which _are_ allowed to see certain master\n///     secret keys).\n///\n/// ## Advanced Responsibilities\n///\n/// - Ultimately, the PrivateContext is responsible for constructing the\n///   PrivateCircuitPublicInputs of the private function being executed.\n///   All private functions on Aztec must have public inputs which adhere\n///   to the rigid layout of the PrivateCircuitPublicInputs, in order to be\n///   compatible with the protocol's kernel circuits.\n///   A well-known misnomer:\n///   - \"public inputs\" contain both inputs and outputs of this function.\n///     - By \"outputs\" we mean a lot more side-effects than just the\n///       \"return values\" of the function.\n///   - Most of the so-called \"public inputs\" are kept _private_, and never leak\n///     to the outside world, because they are 'swallowed' by the protocol's\n///     kernel circuits before the tx is sent to the network. Only the\n///     following are exposed to the outside world:\n///     - New note_hashes\n///     - New nullifiers\n///     - New private logs\n///     - New L2->L1 messages\n///     - New enqueued public function call requests\n///     All the above-listed arrays of side-effects can be padded by the\n///     user's wallet (through instructions to the kernel circuits, via the\n///     PXE) to obscure their true lengths.\n///\n/// ## Syntax Justification\n///\n/// Both user-defined functions _and_ most functions in aztec-nr need access to\n/// the PrivateContext instance to read/write data. This is why you'll see the\n/// arguably-ugly pervasiveness of the \"context\" throughout your smart contract\n/// and the aztec-nr library.\n/// For example, `&mut context` is prevalent. In some languages, you can access\n/// and mutate a global variable (such as a PrivateContext instance) from a\n/// function without polluting the function's parameters. With Noir, a function\n/// must explicitly pass control of a mutable variable to another function, by\n/// reference. Since many functions in aztec-nr need to be able to push new data\n/// to the PrivateContext, they need to be handed a mutable reference _to_ the\n/// context as a parameter.\n/// For example, `Context` is prevalent as a generic parameter, to give better\n/// type safety at compile time. Many `aztec-nr` functions don't make sense if\n/// they're called in a particular runtime (private, public or utility), and so\n/// are intentionally only implemented over certain\n/// [Private|Public|Utility]Context structs. This gives smart contract\n/// developers a much faster feedback loop if they're making a mistake, as an\n/// error will be thrown by the LSP or when they compile their contract.\n///\n#[derive(Eq)]\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub include_by_timestamp: u64,\n\n    pub note_hash_read_requests: BoundedVec<Scoped<Counted<Field>>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<Scoped<Counted<Field>>, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<Counted<NoteHash>, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Counted<Nullifier>, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<Counted<L2ToL1Message>, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub anchor_block_header: BlockHeader,\n\n    pub private_logs: BoundedVec<Counted<PrivateLogData>, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<Counted<LogHash>, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n\n    pub expected_non_revertible_side_effect_counter: u32,\n    pub expected_revertible_side_effect_counter: u32,\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        let max_allowed_include_by_timestamp = inputs.anchor_block_header.global_variables.timestamp\n            + MAX_INCLUDE_BY_TIMESTAMP_DURATION;\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            include_by_timestamp: max_allowed_include_by_timestamp,\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            anchor_block_header: inputs.anchor_block_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n            expected_non_revertible_side_effect_counter: 0,\n            expected_revertible_side_effect_counter: 0,\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: Since Aztec doesn't have a concept of an EoA (\n    /// Externally-owned Account), the msg_sender is \"null\" for the first\n    /// function call of every transaction.\n    /// The first function call of a tx is likely to be a call to the user's\n    /// account contract, so this quirk will most often be handled by account\n    /// contract developers.\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called\n    ///   this function (be it an app contract or a user's account contract).\n    ///   Returns `Option<AztecAddress>::none` for the first function call of\n    ///   the tx. No other _private_ function calls in the tx will have a `none`\n    ///   msg_sender, but _public_ function calls might (see the PublicContext).\n    ///\n    pub fn msg_sender(self) -> Option<AztecAddress> {\n        let maybe_msg_sender = self.inputs.call_context.msg_sender;\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// \"Unsafe\" versus calling `context.msg_sender()`, because it doesn't\n    /// translate `NULL_MSG_SENDER_CONTRACT_ADDRESS` as\n    /// `Option<AztecAddress>::none`.\n    /// Used by some internal aztecnr functions.\n    pub fn msg_sender_unsafe(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    /// Returns the contract address of the current function being executed.\n    ///\n    /// This is equivalent to `address(this)` in Solidity (hence the name).\n    /// Use this to identify the current contract's address, commonly needed for\n    /// access control or when interacting with other contracts.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The contract address of the current function being\n    ///                    executed.\n    ///\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    /// Returns the chain ID of the current network.\n    ///\n    /// This is similar to `block.chainid` in Solidity. Returns the unique\n    /// identifier for the blockchain network this transaction is executing on.\n    ///\n    /// Helps prevent cross-chain replay attacks. Useful if implementing\n    /// multi-chain contract logic.\n    ///\n    /// # Returns\n    /// * `Field` - The chain ID as a field element\n    ///\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    /// Returns the Aztec protocol version that this transaction is executing\n    /// under. Different versions may have different rules, opcodes, or\n    /// cryptographic primitives.\n    ///\n    /// This is similar to how Ethereum has different EVM versions.\n    ///\n    /// Useful for forward/backward compatibility checks\n    ///\n    /// Not to be confused with contract versions; this is the protocol version.\n    ///\n    /// # Returns\n    /// * `Field` - The protocol version as a field element\n    ///\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    /// Returns the gas settings for the current transaction.\n    ///\n    /// This provides information about gas limits and pricing for the\n    /// transaction, similar to `tx.gasprice` and gas limits in Ethereum.\n    /// However, Aztec has a more sophisticated gas model with separate\n    /// accounting for L2 computation and data availability (DA) costs.\n    ///\n    /// # Returns\n    /// * `GasSettings` - Struct containing gas limits and fee information\n    ///\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    /// Returns the function selector of the currently executing function.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to access this.\n    ///\n    /// This is similar to `msg.sig` in Solidity, which returns the first 4\n    /// bytes of the function signature. In Aztec, the selector uniquely\n    /// identifies which function within the contract is being called.\n    ///\n    /// # Returns\n    /// * `FunctionSelector` - The 4-byte function identifier\n    ///\n    /// # Advanced\n    /// Only #[external(\"private\")] functions have a function selector as a protocol-\n    /// enshrined concept. The function selectors of private functions are\n    /// baked into the preimage of the contract address, and are used by the\n    /// protocol's kernel circuits to identify each private function and ensure\n    /// the correct one is being executed.\n    ///\n    /// Used internally for function dispatch and call verification.\n    ///\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    ///\n    /// Very low-level function: You shouldn't need to call this. The #[external(\"private\")]\n    /// macro calls this, and it makes the arguments neatly available to the\n    /// body of your private function.\n    ///\n    /// # Returns\n    /// * `Field` - Hash of the function arguments\n    ///\n    /// # Advanced\n    /// * Arguments are hashed to reduce proof size and verification time\n    /// * Enables efficient argument passing in recursive function calls\n    /// * The hash can be used to retrieve the original arguments from the PXE.\n    ///\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    /// Pushes a new note_hash to the Aztec blockchain's global Note Hash Tree\n    /// (a state tree).\n    ///\n    /// A note_hash is a commitment to a piece of private state.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new note hashes.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The new note_hash.\n    ///\n    /// # Advanced\n    /// From here, the protocol's kernel circuits will take over and insert the\n    /// note_hash into the protocol's \"note hash tree\" (in the Base Rollup\n    /// circuit).\n    /// Before insertion, the protocol will:\n    /// - \"Silo\" the `note_hash` with the contract address of this function,\n    ///   to yield a `siloed_note_hash`. This prevents state collisions\n    ///   between different smart contracts.\n    /// - Ensure uniqueness of the `siloed_note_hash`, to prevent Faerie-Gold\n    ///   attacks, by hashing the `siloed_note_hash` with a unique value, to\n    ///   yield a `unique_siloed_note_hash` (see the protocol spec for more).\n    ///\n    /// In addition to calling this function, aztec-nr provides the contents\n    /// of the newly-created note to the PXE, via the `notify_created_note`\n    /// oracle.\n    ///\n    /// > Advanced users might occasionally wish to push data to the context\n    /// > directly for lower-level control. If you find yourself doing this,\n    /// > please open an issue on GitHub to describe your use case: it might be\n    /// > that new functionality should be added to aztec-nr.\n    ///\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(Counted::new(note_hash, self.next_counter()));\n    }\n\n    /// Pushes a new nullifier to the Aztec blockchain's global Nullifier Tree\n    /// (a state tree).\n    ///\n    /// See also: `push_nullifier_for_note_hash`.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifiers.\n    ///\n    /// A nullifier can only be emitted once. Duplicate nullifier insertions are\n    /// rejected by the protocol.\n    ///\n    /// Generally, a nullifier is emitted to prevent an action from happening\n    /// more than once, in such a way that the action cannot be linked (by an\n    /// observer of the blockchain) to any earlier transactions.\n    ///\n    /// I.e. a nullifier is a random-looking, but deterministic record of a\n    /// private, one-time action, which does not leak what action has been\n    /// taken, and which preserves the property of \"tx unlinkability\".\n    ///\n    /// Usually, a nullifier will be emitted to \"spend\" a note (a piece of\n    /// private state), without revealing which specific note is being spent.\n    ///\n    /// (Important: in such cases, use the below `push_nullifier_for_note_hash`).\n    ///\n    /// Sometimes, a nullifier might be emitted completely unrelated to any\n    /// notes. Examples include initialization of a new contract; initialization\n    /// of a PrivateMutable, or signalling in Semaphore-like applications.\n    /// This `push_nullifier` function serves such use cases.\n    ///\n    /// # Arguments\n    /// * `nullifier`\n    ///\n    /// # Advanced\n    /// From here, the protocol's kernel circuits will take over and insert the\n    /// nullifier into the protocol's \"nullifier tree\" (in the Base Rollup\n    /// circuit).\n    /// Before insertion, the protocol will:\n    /// - \"Silo\" the `nullifier` with the contract address of this function,\n    ///   to yield a `siloed_nullifier`. This prevents state collisions\n    ///   between different smart contracts.\n    /// - Ensure the `siloed_nullifier` is unique (the nullifier tree is an\n    ///   indexed merkle tree which supports efficient non-membership proofs).\n    ///\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: 0 }.count(self.next_counter()));\n    }\n\n    /// Pushes a nullifier that corresponds to a specific note hash.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifiers.\n    ///\n    /// This is a specialized version of `push_nullifier` that links a nullifier\n    /// to the specific note hash it's nullifying. This is the most common\n    /// usage pattern for nullifiers.\n    /// See `push_nullifier` for more explanation on nullifiers.\n    ///\n    /// # Arguments\n    /// * `nullifier`\n    /// * `nullified_note_hash` - The note hash of the note being nullified\n    ///\n    /// # Advanced\n    /// Important: usage of this function doesn't mean that the world will _see_\n    /// that this nullifier relates to the given nullified_note_hash (as that\n    /// would violate \"tx unlinkability\"); it simply informs the user's PXE\n    /// about the relationship (via `notify_nullified_note`). The PXE can then\n    /// use this information to feed hints to the kernel circuits for\n    /// \"squashing\" purposes: If a note is nullified during the same tx which\n    /// created it, we can \"squash\" (delete) the note and nullifier (and any\n    /// private logs associated with the note), to save on data emission costs.\n    ///\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash }.count(\n            nullifier_counter,\n        ));\n    }\n\n    /// Returns the anchor block header - the historical block header that this\n    /// private function is reading from.\n    ///\n    /// A private function CANNOT read from the \"current\" block header,\n    /// but must read from some older block header, because as soon as\n    /// private function execution begins (asynchronously, on a user's device),\n    /// the public state of the chain (the \"current state\") will have progressed\n    /// forward.\n    ///\n    /// # Returns\n    /// * `BlockHeader` - The anchor block header.\n    ///\n    /// # Advanced\n    /// * All private functions of a tx read from the same anchor block header.\n    /// * The protocol asserts that the `include_by_timestamp` of every tx\n    ///   is at most 24 hours beyond the timestamp of the tx's chosen anchor\n    ///   block header. This enables the network's nodes to safely prune old txs\n    ///   from the mempool. Therefore, the chosen block header _must_ be one\n    ///   from within the last 24 hours.\n    ///\n    pub fn get_anchor_block_header(self) -> BlockHeader {\n        self.anchor_block_header\n    }\n\n    /// Returns the header of any historical block at or before the anchor\n    /// block.\n    ///\n    /// This enables private contracts to access information from even older\n    /// blocks than the anchor block header.\n    ///\n    /// Useful for time-based contract logic that needs to compare against\n    /// multiple historical points.\n    ///\n    /// # Arguments\n    /// * `block_number` - The block number to retrieve (must be <= anchor\n    ///                    block number)\n    ///\n    /// # Returns\n    /// * `BlockHeader` - The header of the requested historical block\n    ///\n    /// # Advanced\n    /// This function uses an oracle to fetch block header data from the user's\n    /// PXE. Depending on how much blockchain data the user's PXE has been set\n    /// up to store, this might require a query from the PXE to another Aztec\n    /// node to get the data.\n    /// > This is generally true of all oracle getters (see `../oracle`).\n    ///\n    /// Each block header gets hashed and stored as a leaf in the protocol's\n    /// Archive Tree. In fact, the i-th block header gets stored at the i-th\n    /// leaf index of the Archive Tree. Behind the scenes, this\n    /// `get_block_header_at` function will add Archive Tree merkle-membership\n    /// constraints (~3k) to your smart contract function's circuit, to prove\n    /// existence of the block header in the Archive Tree.\n    ///\n    /// Note: we don't do any caching, so avoid making duplicate calls for the\n    /// same block header, because each call will add duplicate constraints.\n    ///\n    /// Calling this function is more expensive (constraint-wise) than getting\n    /// the anchor block header (via `get_block_header`). This is because the\n    /// anchor block's merkle membership proof is handled by Aztec's protocol\n    /// circuits, and is only performed once for the entire tx because all\n    /// private functions of a tx share a common anchor block header. Therefore,\n    /// the cost (constraint-wise) of calling `get_block_header` is effectively\n    /// free.\n    ///\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    /// Sets the hash of the return values for this private function.\n    ///\n    /// Very low-level function: this is called by the #[external(\"private\")] macro.\n    ///\n    /// # Arguments\n    /// * `serialized_return_values` - The serialized return values as a field array\n    ///\n    pub fn set_return_hash<let N: u32>(&mut self, serialized_return_values: [Field; N]) {\n        let return_hash = hash_args(serialized_return_values);\n        self.return_hash = return_hash;\n        execution_cache::store(serialized_return_values, return_hash);\n    }\n\n    /// Builds the PrivateCircuitPublicInputs for this private function, to\n    /// ensure compatibility with the protocol's kernel circuits.\n    ///\n    /// Very low-level function: This function is automatically called by the\n    /// #[external(\"private\")] macro.\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            include_by_timestamp: self.include_by_timestamp,\n            note_hash_read_requests: ClaimedLengthArray::from_bounded_vec(\n                self.note_hash_read_requests,\n            ),\n            nullifier_read_requests: ClaimedLengthArray::from_bounded_vec(\n                self.nullifier_read_requests,\n            ),\n            key_validation_requests_and_generators: ClaimedLengthArray::from_bounded_vec(\n                self.key_validation_requests_and_generators,\n            ),\n            note_hashes: ClaimedLengthArray::from_bounded_vec(self.note_hashes),\n            nullifiers: ClaimedLengthArray::from_bounded_vec(self.nullifiers),\n            private_call_requests: ClaimedLengthArray::from_bounded_vec(self.private_call_requests),\n            public_call_requests: ClaimedLengthArray::from_bounded_vec(self.public_call_requests),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: ClaimedLengthArray::from_bounded_vec(self.l2_to_l1_msgs),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: ClaimedLengthArray::from_bounded_vec(self.private_logs),\n            contract_class_logs_hashes: ClaimedLengthArray::from_bounded_vec(\n                self.contract_class_logs_hashes,\n            ),\n            anchor_block_header: self.anchor_block_header,\n            tx_context: self.inputs.tx_context,\n            expected_non_revertible_side_effect_counter: self\n                .expected_non_revertible_side_effect_counter,\n            expected_revertible_side_effect_counter: self.expected_revertible_side_effect_counter,\n        }\n    }\n\n    /// Designates this contract as the fee payer for the transaction.\n    ///\n    /// Unlike Ethereum, where the transaction sender always pays fees, Aztec\n    /// allows any contract to voluntarily pay transaction fees. This enables\n    /// patterns like sponsored transactions or fee abstraction where users\n    /// don't need to hold fee-juice themselves. (Fee juice is a fee-paying\n    /// asset for Aztec).\n    ///\n    /// Only one contract per transaction can declare itself as the fee payer,\n    /// and it must have sufficient fee-juice balance (>= the gas limits\n    /// specified in the TxContext) by the time we reach the public setup phase\n    /// of the tx.\n    ///\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn in_revertible_phase(&mut self) -> bool {\n        let current_counter = self.side_effect_counter;\n\n        // Safety: Kernel will validate that the claim is correct by validating the expected counters.\n        let is_revertible =\n            unsafe { is_side_effect_counter_revertible_oracle_wrapper(current_counter) };\n\n        if is_revertible {\n            if (self.expected_revertible_side_effect_counter == 0)\n                | (current_counter < self.expected_revertible_side_effect_counter) {\n                self.expected_revertible_side_effect_counter = current_counter;\n            }\n        } else if current_counter > self.expected_non_revertible_side_effect_counter {\n            self.expected_non_revertible_side_effect_counter = current_counter;\n        }\n\n        is_revertible\n    }\n\n    /// Declares the end of the \"setup phase\" of this tx.\n    ///\n    /// Only one function per tx can declare the end of the setup phase.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase enables such a payment to\n    /// be made, because the setup phase _cannot revert_: a reverting function\n    /// within the setup phase would result in an invalid block which cannot\n    /// be proven. Any side-effects generated during that phase are guaranteed\n    /// to be inserted into Aztec's state trees (except for squashed notes &\n    /// nullifiers, of course).\n    ///\n    /// Even though the end of the setup phase is declared within a private\n    /// function, you might have noticed that _public_ functions can also\n    /// execute within the setup phase. This is because any public function\n    /// calls which were enqueued _within the setup phase_ by a private\n    /// function are considered part of the setup phase.\n    ///\n    /// # Advanced\n    /// * Sets the minimum revertible side effect counter of this tx to be the\n    /// PrivateContext's _current_ side effect counter.\n    ///\n    pub fn end_setup(&mut self) {\n        // Incrementing the side effect counter when ending setup ensures non\n        // ambiguity for the counter where we change phases.\n        self.side_effect_counter += 1;\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.next_counter();\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    /// Sets a deadline (an \"include-by timestamp\") for when this transaction\n    /// must be included in a block.\n    ///\n    /// Other functions in this tx might call this setter with differing\n    /// values for the include-by timestamp. To ensure that all functions'\n    /// deadlines are met, the _minimum_ of all these include-by timestamps will\n    /// be exposed when this tx is submitted to the network.\n    ///\n    /// If the transaction is not included in a block by its include-by\n    /// timestamp, it becomes invalid and it will never be included.\n    ///\n    /// This expiry timestamp is publicly visible. See the \"Advanced\" section\n    /// for privacy concerns.\n    ///\n    /// # Arguments\n    /// * `include_by_timestamp` - Unix timestamp (seconds) deadline for inclusion.\n    ///                            The include-by timestamp of this tx will be\n    ///                            _at most_ the timestamp specified.\n    ///\n    /// # Advanced\n    /// * If multiple functions set differing `include_by_timestamp`s, the\n    ///   kernel circuits will set it to be the _minimum_ of the two. This\n    ///   ensures the tx expiry requirements of all functions in the tx are met.\n    /// * Rollup circuits will reject expired txs.\n    /// * The protocol enforces that all transactions must be included within\n    ///   24 hours of their chosen anchor block's timestamp, to enable safe\n    ///   mempool pruning.\n    /// * The DelayedPublicMutable design makes heavy use of this functionality,\n    ///   to enable private functions to read public state.\n    /// * A sophisticated Wallet should cleverly set an include-by timestamp\n    ///   to improve the privacy of the user and the network as a whole.\n    ///   For example, if a contract interaction sets include-by to some\n    ///   publicly-known value (e.g. the time when a contract upgrades), then\n    ///   the wallet might wish to set an even lower one to avoid revealing that\n    ///   this tx is interacting with said contract.\n    ///   Ideally, all wallets should standardize on an approach in order to\n    ///   provide users with a large anonymity set -- although the exact approach\n    ///   will need to be discussed. Wallets that deviate from a standard might\n    ///   accidentally reveal which wallet each transaction originates from.\n    ///\n    // docs:start:include-by-timestamp\n    pub fn set_include_by_timestamp(&mut self, include_by_timestamp: u64) {\n        // docs:end:include-by-timestamp\n        self.include_by_timestamp = std::cmp::min(self.include_by_timestamp, include_by_timestamp);\n    }\n\n    /// Makes a request to the protocol's kernel circuit to ensure a note_hash\n    /// actually exists.\n    ///\n    /// \"Read requests\" are used to prove that a note hash exists without\n    /// revealing which specific note was read.\n    ///\n    /// This can be used to prove existence of both settled notes (created in\n    /// prior transactions) and transient notes (created in the current\n    /// transaction).\n    /// If you need to prove existence of a settled note _at a specific block\n    /// number_, use `note_inclusion::prove_note_inclusion`.\n    ///\n    /// Low-level function. Ordinarily, smart contract developers will not need\n    /// to call this directly. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new note_hash read\n    /// requests.\n    ///\n    /// # Arguments\n    /// * `note_hash_read` - The note hash to read and verify\n    ///\n    /// # Advanced\n    /// In \"traditional\" circuits for non-Aztec privacy applications, the merkle\n    /// membership proofs to check existence of a note are performed _within_\n    /// the application circuit.\n    ///\n    /// All Aztec private functions have access to the following constraint\n    /// optimisation:\n    /// In cases where the note being read was created earlier in the same tx,\n    /// the note wouldn't yet exist in the Note Hash Tree, so a hard-coded\n    /// merkle membership check which then gets ignored would be a waste of\n    /// constraints.\n    /// Instead, we can send read requests for all notes to the protocol's\n    /// kernel circuits, where we can conditionally assess which notes actually\n    /// need merkle membership proofs, and select an appropriately-sized\n    /// kernel circuit.\n    ///\n    /// For \"settled notes\" (which already existed in the Note Hash Tree of the\n    /// anchor block (i.e. before the tx began)), the kernel does a merkle\n    /// membership check.\n    ///\n    /// For \"pending notes\" (which were created earlier in _this_ tx), the\n    /// kernel will check that the note existed _before_ this read request was\n    /// made, by checking the side-effect counters of the note_hash and this\n    /// read request.\n    ///\n    /// This approach improves latency between writes and reads:\n    /// a function can read a note which was created earlier in the tx (rather\n    /// than performing the read in a later tx, after waiting for the earlier tx\n    /// to be included, to ensure the note is included in the tree).\n    ///\n    pub fn push_note_hash_read_request(&mut self, note_hash_read: NoteHashRead) {\n        let note_hash = note_hash_read.note_hash();\n        let contract_address = note_hash_read.contract_address().unwrap_or(AztecAddress::zero());\n        let side_effect = Scoped::new(\n            Counted::new(note_hash, self.next_counter()),\n            contract_address,\n        );\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    /// Asserts that a NoteHashRead has been requested to the kernel by this context.\n    /// Asserts instead of returning a boolean to save on gates.\n    ///\n    /// # Arguments\n    /// * `note_hash_read` - The note hash read to assert that has been requested.\n    ///\n    pub fn assert_has_been_requested(self, note_hash_read: NoteHashRead) {\n        let note_hash = note_hash_read.note_hash();\n        let contract_address = note_hash_read.contract_address().unwrap_or(AztecAddress::zero());\n\n        // Safety: The index is constrained by the checks below.\n        let hinted_index = unsafe {\n            find_first_index(\n                self.note_hash_read_requests.storage(),\n                |r| (r.contract_address == contract_address) & (r.innermost() == note_hash),\n            )\n        };\n        // This assertion is not necessary, since the .get would fail. But it enables us to have a more explicit error message.\n        assert(\n            hinted_index != self.note_hash_read_requests.max_len(),\n            \"Note hash read has not been requested\",\n        );\n\n        let request = self.note_hash_read_requests.get(hinted_index);\n        assert_eq(request.contract_address, contract_address);\n        assert_eq(request.innermost(), note_hash);\n    }\n\n    /// Requests to read a specific nullifier from the nullifier tree.\n    ///\n    /// Nullifier read requests are used to prove that a nullifier exists without\n    /// revealing which specific nullifier preimage was read.\n    ///\n    /// This can be used to prove existence of both settled nullifiers (created in\n    /// prior transactions) and transient nullifiers (created in the current\n    /// transaction).\n    /// If you need to prove existence of a settled nullifier _at a specific block\n    /// number_, use `nullifier_inclusion::prove_nullifier_inclusion`.\n    ///\n    /// Low-level function. Ordinarily, smart contract developers will not need\n    /// to call this directly. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifier read\n    /// requests.\n    ///\n    /// # Arguments\n    /// * `nullifier` - The nullifier to read and verify\n    /// * `contract_address` - The contract address that emitted the nullifier\n    ///\n    /// # Advanced\n    /// This approach improves latency between writes and reads:\n    /// a function can read a nullifier which was created earlier in the tx\n    /// (rather than performing the read in a later tx, after waiting for the\n    /// earlier tx to be included, to ensure the nullifier is included in the tree).\n    ///\n    pub fn push_nullifier_read_request(\n        &mut self,\n        nullifier: Field,\n        contract_address: AztecAddress,\n    ) {\n        let request = Scoped::new(\n            Counted::new(nullifier, self.next_counter()),\n            contract_address,\n        );\n        self.nullifier_read_requests.push(request);\n    }\n\n    /// Requests the app-siloed nullifier secret key (nsk_app) for the given\n    /// (hashed) master nullifier public key (npk_m), from the user's PXE.\n    ///\n    /// Advanced function: Only needed if you're designing your own notes and/or\n    /// nullifiers.\n    ///\n    /// Contracts are not allowed to compute nullifiers for other contracts, as\n    /// that would let them read parts of their private state. Because of this,\n    /// a contract is only given an \"app-siloed secret key\", which is\n    /// constructed by hashing the user's master nullifier secret key with the\n    /// contract's address.\n    /// However, because contracts cannot be trusted with a user's master\n    /// nullifier secret key (because we don't know which contracts are honest\n    /// or malicious), the PXE refuses to provide any master secret keys to\n    /// any app smart contract function. This means app functions are unable to\n    /// prove that the derivation of an app-siloed nullifier secret key has been\n    /// computed correctly. Instead, an app function can request to the kernel\n    /// (via `request_nsk_app`) that it validates the siloed derivation, since\n    /// the kernel has been vetted to not leak any master secret keys.\n    ///\n    /// A common nullification scheme is to inject a nullifier secret key into\n    /// the preimage of a nullifier, to make the nullifier deterministic but\n    /// random-looking. This function enables that flow.\n    ///\n    /// # Arguments\n    /// * `npk_m_hash` - A hash of the master nullifier public key of the user\n    ///                  whose PXE is executing this function.\n    ///\n    /// # Returns\n    /// * The app-siloed nullifier secret key that corresponds to the given\n    ///   `npk_m_hash`.\n    ///\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    /// Requests the app-siloed nullifier secret key (nsk_app) for the given\n    /// (hashed) master nullifier public key (npk_m), from the user's PXE.\n    ///\n    /// See `request_nsk_app` and `request_sk_app` for more info.\n    ///\n    /// The intention of the \"outgoing\" keypair is to provide a second secret\n    /// key for all of a user's outgoing activity (i.e. for notes that a user\n    /// creates, as opposed to notes that a user receives from others). The\n    /// separation of incoming and outgoing data was a distinction made by\n    /// zcash, with the intention of enabling a user to optionally share with a\n    /// 3rd party a controlled view of only incoming or outgoing notes.\n    /// Similar functionality of sharing select data can be achieved with\n    /// offchain zero-knowledge proofs. It is up to an app developer whether\n    /// they choose to make use of a user's outgoing keypair within their\n    /// application logic, or instead simply use the same keypair (the address\n    /// keypair (which is effectively the same as the \"incoming\" keypair)) for\n    /// all incoming & outgoing messages to a user.\n    ///\n    /// Currently, all of the exposed encryption functions in aztec-nr ignore\n    /// the outgoing viewing keys, and instead encrypt all note logs and event\n    /// logs to a user's address public key.\n    ///\n    /// # Arguments\n    /// * `ovpk_m_hash` - Hash of the outgoing viewing public key master\n    ///\n    /// # Returns\n    /// * The application-specific outgoing viewing secret key\n    ///\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    /// Pushes a Key Validation Request to the kernel.\n    ///\n    /// Private functions are not allowed to see a user's master secret keys,\n    /// because we do not trust them. They are instead given \"app-siloed\" secret\n    /// keys with a claim that they relate to a master public key.\n    /// They can then request validation of this claim, by making a \"key\n    /// validation request\" to the protocol's kernel circuits (which _are_\n    /// allowed to see certain master secret keys).\n    ///\n    /// When a Key Validation Request tuple of (sk_app, Pk_m, app_address) is\n    /// submitted to the kernel, it will perform the following derivations\n    /// to validate the relationship between the claimed sk_app and the user's\n    /// Pk_m:\n    ///\n    ///       (sk_m) ----> * G ----> Pk_m\n    ///         |                     |\n    ///         v                       We use the kernel to prove this\n    ///  h(sk_m, app_address)         | sk_app-Pk_m relationship, because app\n    ///         |                       circuits must not be trusted to see sk_m.\n    ///         v                     |\n    ///      sk_app - -  - - - - - - -\n    ///\n    /// The function is named \"request_\" instead of \"get_\" to remind the user\n    /// that a Key Validation Request will be emitted to the kernel.\n    ///\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    /// Sends an \"L2 -> L1 message\" from this function (Aztec, L2) to a smart\n    /// contract on Ethereum (L1). L1 contracts which are designed to\n    /// send/receive messages to/from Aztec are called \"Portal Contracts\".\n    ///\n    /// Common use cases include withdrawals, cross-chain asset transfers, and\n    /// triggering L1 actions based on L2 state changes.\n    ///\n    /// The message will be inserted into an Aztec \"Outbox\" contract on L1,\n    /// when this transaction's block is proposed to L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target portal contract. The message will need to be manually\n    /// consumed from the Outbox through a separate Ethereum transaction: a user\n    /// will need to call a function of the portal contract -- a function\n    /// specifically designed to make a call to the Outbox to consume the\n    /// message.\n    /// The message will only be available for consumption once the _epoch_\n    /// proof has been submitted. Given that there are multiple Aztec blocks\n    /// within an epoch, it might take some time for this epoch proof to be\n    /// submitted -- especially if the block was near the start of an epoch.\n    ///\n    /// # Arguments\n    /// * `recipient` - Ethereum address that will receive the message\n    /// * `content` - Message content (32 bytes as a Field element).\n    ///               This content has a very specific layout.\n    /// docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        let message = L2ToL1Message { recipient, content };\n        self.l2_to_l1_msgs.push(message.count(self.next_counter()));\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2).\n    ///\n    /// Common use cases include token bridging, cross-chain governance, and\n    /// triggering L2 actions based on L1 events.\n    ///\n    /// Use this function if you only want the message to ever be \"referred to\"\n    /// once. Once consumed using this method, the message cannot be consumed\n    /// again, because a nullifier is emitted.\n    /// If your use case wants for the message to be read unlimited times, then\n    /// you can always read any historic message from the L1-to-L2 messages tree;\n    /// messages never technically get deleted from that tree.\n    ///\n    /// The message will first be inserted into an Aztec \"Inbox\" smart contract\n    /// on L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target L2 contract. The message will need to be manually\n    /// consumed by the target contract through a separate Aztec transaction.\n    /// The message will not be available for consumption immediately. Messages\n    /// get copied over from the L1 Inbox to L2 by the next Proposer in batches.\n    /// So you will need to wait until the messages are copied before you can\n    /// consume them.\n    ///\n    /// # Arguments\n    /// * `content` - The message content that was sent from L1\n    /// * `secret` - Secret value used for message privacy (if needed)\n    /// * `sender` - Ethereum address that sent the message\n    /// * `leaf_index` - Index of the message in the L1-to-L2 message tree\n    ///\n    /// # Advanced\n    /// Validates message existence in the L1-to-L2 message tree and nullifies\n    /// the message to prevent double-consumption.\n    ///\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let nullifier = process_l1_to_l2_message(\n            self.anchor_block_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n\n    /// Emits a private log (an array of Fields) that will be published to an\n    /// Ethereum blob.\n    ///\n    /// Private logs are intended for the broadcasting of ciphertexts: that is,\n    /// encrypted events or encrypted note contents.\n    /// Since the data in the logs is meant to be _encrypted_, private_logs are\n    /// broadcast to publicly-visible Ethereum blobs.\n    /// The intended recipients of such encrypted messages can then discover and\n    /// decrypt these encrypted logs using their viewing secret key.\n    /// (See `../messages/discovery` for more details).\n    ///\n    /// Important note: This function DOES NOT _do_ any encryption of the input\n    /// `log` fields. This function blindly publishes whatever input `log` data\n    /// is fed into it, so the caller of this function should have already\n    /// performed the encryption, and the `log` should be the result of that\n    /// encryption.\n    ///\n    /// The protocol does not dictate what encryption scheme should be used:\n    /// a smart contract developer can choose whatever encryption scheme they\n    /// like.\n    /// Aztec-nr includes some off-the-shelf encryption libraries that\n    /// developers might wish to use, for convenience. These libraries not only\n    /// encrypt a plaintext (to produce a ciphertext); they also prepend the\n    /// ciphertext with a `tag` and `ephemeral public key` for easier message\n    /// discovery. This is a very dense topic, and we will be writing more\n    /// libraries and docs soon.\n    ///\n    /// > Currently, AES128 CBC encryption is the main scheme included in\n    /// > aztec.nr.\n    /// > We are currently making significant changes to the interfaces of the\n    /// > encryption library.\n    ///\n    /// In some niche use cases, an app might be tempted to publish\n    /// _un-encrypted_ data via a private log, because _public logs_ are not\n    /// available to private functions. Be warned that emitting public data via\n    /// private logs is strongly discouraged, and is considered a \"privacy\n    /// anti-pattern\", because it reveals identifiable information about _which_\n    /// function has been executed. A tx which leaks such information does not\n    /// contribute to the privacy set of the network.\n    ///\n    /// * Unlike `emit_raw_note_log`, this log is not tied to any specific note\n    ///\n    /// # Arguments\n    /// * `log` - The log data that will be publicly broadcast (so make sure\n    ///           it's already been encrypted before you call this function).\n    ///   Private logs are bounded in size (PRIVATE_LOG_SIZE_IN_FIELDS), to\n    ///   encourage all logs from all smart contracts look identical.\n    /// * `length` - The actual length of the `log` (measured in number of\n    ///              Fields). Although the input log has a max size of\n    ///   PRIVATE_LOG_SIZE_IN_FIELDS, the latter values of the array might all\n    ///   be 0's for small logs. This `length` should reflect the trimmed length\n    ///   of the array. The protocol's kernel circuits can then append random\n    ///   fields as \"padding\" after the `length`, so that the logs of this\n    ///   smart contract look indistinguishable from (the same length as) the\n    ///   logs of all other applications. It's up to wallets how much padding\n    ///   to apply, so ideally all wallets should agree on standards for this.\n    ///\n    /// # Advanced\n    ///\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS], length: u32) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter: 0 }\n            .count(counter);\n        self.private_logs.push(private_log);\n    }\n\n    // TODO: rename.\n    /// Emits a private log that is explicitly tied to a newly-emitted note_hash,\n    /// to convey to the kernel: \"this log relates to this note\".\n    ///\n    /// This linkage is important in case the note gets squashed (due to being\n    /// read later in this same tx), since we can then squash the log as well.\n    ///\n    /// See `emit_private_log` for more info about private log emission.\n    ///\n    /// # Arguments\n    /// * `log` - The log data as an array of Field elements\n    /// * `length` - The actual length of the `log` (measured in number of\n    ///              Fields).\n    /// * `note_hash_counter` - The side-effect counter that was assigned to the\n    ///                         new note_hash when it was pushed to this\n    //                          `PrivateContext`.\n    ///\n    /// Important: If your application logic requires the log to always be\n    /// emitted regardless of note squashing, consider using `emit_private_log`\n    /// instead, or emitting additional events.\n    ///\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        length: u32,\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter };\n        self.private_logs.push(private_log.count(counter));\n    }\n\n    pub fn emit_contract_class_log<let N: u32>(&mut self, log: [Field; N]) {\n        let contract_address = self.this_address();\n        let counter = self.next_counter();\n\n        let log_to_emit: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS] =\n            log.concat([0; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS - N]);\n        // Note: the length is not always N, it is the number of fields we want to broadcast, omitting trailing zeros to save blob space.\n        // Safety: The below length is constrained in the base rollup, which will make sure that all the fields beyond length are zero.\n        // However, it won't be able to check that we didn't add extra padding (trailing zeroes) or that we cut trailing zeroes from the end.\n        let length = unsafe { trimmed_array_length_hint(log_to_emit) };\n        // We hash the entire padded log to ensure a user cannot pass a shorter length and so emit incorrect shorter bytecode.\n        let log_hash = poseidon2_hash(log_to_emit);\n        // Safety: the below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\n        unsafe {\n            notify_created_contract_class_log(contract_address, log_to_emit, length, counter);\n        }\n\n        self.contract_class_logs_hashes.push(LogHash { value: log_hash, length: length }.count(\n            counter,\n        ));\n    }\n\n    /// Calls a private function on another contract (or the same contract).\n    ///\n    /// Very low-level function.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the called function\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    /// This enables contracts to interact with each other while maintaining\n    /// privacy. This \"composability\" of private contract functions is a key\n    /// feature of the Aztec network.\n    ///\n    /// If a user's transaction includes multiple private function calls, then\n    /// by the design of Aztec, the following information will remain private[1]:\n    /// - The function selectors and contract addresses of all private function\n    ///   calls will remain private, so an observer of the public mempool will\n    ///   not be able to look at a tx and deduce which private functions have\n    ///   been executed.\n    /// - The arguments and return values of all private function calls will\n    ///   remain private.\n    /// - The person who initiated the tx will remain private.\n    /// - The notes and nullifiers and private logs that are emitted by all\n    ///   private function calls will (if designed well) not leak any user\n    ///   secrets, nor leak which functions have been executed.\n    ///\n    /// [1] Caveats: Some of these privacy guarantees depend on how app\n    /// developers design their smart contracts. Some actions _can_ leak\n    /// information, such as:\n    /// - Calling an internal public function.\n    /// - Calling a public function and not setting msg_sender to Option::none\n    ///   (feature not built yet - see github).\n    /// - Calling any public function will always leak details about the nature\n    ///   of the transaction, so devs should be careful in their contract\n    ///   designs. If it can be done in a private function, then that will give\n    ///   the best privacy.\n    /// - Not padding the side-effects of a tx to some standardized, uniform\n    ///   size. The kernel circuits can take hints to pad side-effects, so a\n    ///   wallet should be able to request for a particular amount of padding.\n    ///   Wallets should ideally agree on some standard.\n    ///   - Padding should include:\n    ///     - Padding the lengths of note & nullifier arrays\n    ///     - Padding private logs with random fields, up to some standardized\n    ///       size.\n    /// See also: https://docs.aztec.network/developers/resources/considerations/privacy_considerations\n    ///\n    /// # Advanced\n    /// * The call is added to the private call stack and executed by kernel\n    ///   circuits after this function completes\n    /// * The called function can modify its own contract's private state\n    /// * Side effects from the called function are included in this transaction\n    /// * The call inherits the current transaction's context and gas limits\n    ///\n    pub fn call_private_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) -> ReturnsHash {\n        let args_hash = hash_args(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    /// Makes a read-only call to a private function on another contract.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L2 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// See `call_private_function` for more general info on private function\n    /// calls.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the called function\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn static_call_private_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) -> ReturnsHash {\n        let args_hash = hash_args(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    /// Calls a private function that takes no arguments.\n    ///\n    /// This is a convenience function for calling private functions that don't\n    /// require any input parameters. It's equivalent to `call_private_function`\n    /// but slightly more efficient to use when no arguments are needed.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    /// Makes a read-only call to a private function which takes no arguments.\n    ///\n    /// This combines the optimisation of `call_private_function_no_args` with\n    /// the safety of `static_call_private_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    /// Low-level private function call.\n    ///\n    /// This is the underlying implementation used by all other private function\n    /// call methods. Instead of taking raw arguments, it accepts a\n    /// hash of the arguments.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args_hash` - Pre-computed hash of the function arguments\n    /// * `is_static_call` - Whether this should be a read-only call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values\n    ///\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1; // TODO: call `next_counter` instead, for consistency\n        ReturnsHash::new(returns_hash)\n    }\n\n    /// Enqueues a call to a public function to be executed later.\n    ///\n    /// Unlike private functions which execute immediately on the user's device,\n    /// public function calls are \"enqueued\" and executed some time later by a\n    /// block proposer.\n    ///\n    /// This means a public function cannot return any values back to a private\n    /// function, because by the time the public function is being executed,\n    /// the private function which called it has already completed execution.\n    /// (In fact, the private function has been executed and proven, along with\n    /// all other private function calls of the user's tx. A single proof of the\n    /// tx has been submitted to the Aztec network, and some time later a\n    /// proposer has picked the tx up from the mempool and begun executing all\n    /// of the enqueued public functions).\n    ///\n    /// # Privacy warning\n    /// Enqueueing a public function call is an inherently leaky action.\n    /// Many interesting applications will require some interaction with public\n    /// state, but smart contract developers should try to use public function\n    /// calls sparingly, and carefully.\n    /// _Internal_ public function calls are especially leaky, because they\n    /// completely leak which private contract made the call.\n    /// See also: https://docs.aztec.network/developers/resources/considerations/privacy_considerations\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the public function\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn call_public_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n        hide_msg_sender: bool,\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a read-only call to a public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// See also `call_public_function` for more important information about\n    /// making private -> public function calls.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the public function\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn static_call_public_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n        hide_msg_sender: bool,\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            true,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a call to a public function that takes no arguments.\n    ///\n    /// This is an optimisation for calling public functions that don't\n    /// take any input parameters. It's otherwise equivalent to\n    /// `call_public_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        hide_msg_sender: bool,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a read-only call to a public function with no arguments.\n    ///\n    /// This combines the optimisation of `call_public_function_no_args` with\n    /// the safety of `static_call_public_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        hide_msg_sender: bool,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            true,\n            hide_msg_sender,\n        )\n    }\n\n    /// Low-level public function call.\n    ///\n    /// This is the underlying implementation used by all other public function\n    /// call methods. Instead of taking raw arguments, it accepts a\n    /// hash of the arguments.\n    ///\n    /// Advanced function: Most developers should use `call_public_function`\n    /// or `static_call_public_function` instead. This function is exposed for\n    /// performance optimization and advanced use cases.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `calldata_hash` - Hash of the function calldata\n    /// * `is_static_call` - Whether this should be a read-only call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n        hide_msg_sender: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let msg_sender = if hide_msg_sender {\n            NULL_MSG_SENDER_CONTRACT_ADDRESS\n        } else {\n            self.this_address()\n        };\n\n        let call_request =\n            PublicCallRequest { msg_sender, contract_address, is_static_call, calldata_hash };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    /// Enqueues a public function call, and designates it to be the teardown\n    /// function for this tx. Only one teardown function call can be made by a\n    /// tx.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase ensures the fee payer\n    /// has sufficient balance to pay the proposer their fees.\n    /// The teardown phase is primarily intended to: calculate exactly\n    /// how much the user owes, based on gas consumption, and refund the user\n    /// any change.\n    ///\n    /// Note: in some cases, the cost of refunding the user (i.e. DA costs of\n    /// tx side-effects) might exceed the refund amount. For app logic with\n    /// fairly stable and predictable gas consumption, a material refund amount\n    /// is unlikely. For app logic with unpredictable gas consumption, a\n    /// refund might be important to the user (e.g. if a hefty function reverts\n    /// very early). Wallet/FPC/Paymaster developers should be mindful of this.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the teardown\n    ///                        function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - An array of fields to pass to the function.\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    pub fn set_public_teardown_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n        hide_msg_sender: bool,\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n\n    /// Low-level function to set the public teardown function.\n    ///\n    /// This is the underlying implementation for setting the teardown function\n    /// call that will execute at the end of the transaction. Instead of taking\n    /// raw arguments, it accepts a hash of the arguments.\n    ///\n    /// Advanced function: Most developers should use\n    /// `set_public_teardown_function` instead.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the teardown\n    ///                        function\n    /// * `calldata_hash` - Hash of the function calldata\n    /// * `is_static_call` - Whether this should be a read-only call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n        hide_msg_sender: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let msg_sender = if hide_msg_sender {\n            NULL_MSG_SENDER_CONTRACT_ADDRESS\n        } else {\n            self.this_address()\n        };\n\n        self.public_teardown_call_request =\n            PublicCallRequest { msg_sender, contract_address, is_static_call, calldata_hash };\n    }\n\n    /// Increments the side-effect counter.\n    ///\n    /// Very low-level function.\n    ///\n    /// # Advanced\n    ///\n    /// Every side-effect of a private function is given a \"side-effect counter\",\n    /// based on when it is created. This PrivateContext is in charge of\n    /// assigning the counters.\n    ///\n    /// The reason we have side-effect counters is complicated. Consider this\n    /// illustrative pseudocode of inter-contract function calls:\n    /// ```\n    /// contract A {\n    ///    let x = 5; // pseudocode for storage var x.\n    ///    fn a1 {\n    ///        read x; // value: 5, counter: 1.\n    ///        x = x + 1;\n    ///        write x; // value: 6, counter: 2.\n    ///\n    ///        B.b(); // start_counter: 2, end_counter: 4\n    ///\n    ///        read x; // value: 36, counter: 5.\n    ///        x = x + 1;\n    ///        write x; // value: 37, counter: 6.\n    ///    }\n    ///\n    ///    fn a2 {\n    ///        read x; // value: 6, counter: 3.\n    ///        x = x * x;\n    ///        write x; // value: 36, counter: 4.\n    ///    }\n    /// }\n    ///\n    /// contract B {\n    ///     fn b() {\n    ///         A.a2();\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// Suppose a1 is the first function called. The comments show the execution\n    /// counter of each side-effect, and what the new value of `x` is.\n    ///\n    /// These (private) functions are processed by Aztec's kernel circuits in an\n    /// order that is different from execution order:\n    /// All of A.a1 is proven before B.b is proven, before A.a2 is proven.\n    /// So when we're in the 2nd execution frame of A.a1 (after the call to\n    /// B.b), the circuit needs to justify why x went from being `6` to `36`.\n    /// But the circuit doesn't know why, and given the order of proving, the\n    /// kernel hasn't _seen_ a value of 36 get written yet.\n    /// The kernel needs to track big arrays of all side-effects of all\n    /// private functions in a tx. Then, as it recurses and processes B.b(), it\n    /// will eventually see a value of 36 get written.\n    ///\n    /// Suppose side-effect counters weren't exposed:\n    /// The kernel would only see this ordering (in order of proof verification):\n    /// [ A.a1.read, A.a1.write, A.a1.read, A.a1.write, A.a2.read, A.a2.write ]\n    /// [         5,          6,        36,         37,         6,         36 ]\n    /// The kernel wouldn't know _when_ B.b() was called within A.a1(), because\n    /// it can't see what's going on within an app circuit. So the kernel\n    /// wouldn't know that the ordering of reads and writes should actually be:\n    /// [ A.a1.read, A.a1.write, A.a2.read, A.a2.write, A.a1.read, A.a1.write ]\n    /// [         5,          6,        6,         36,         36,         37 ]\n    ///\n    /// And so, we introduced side-effect counters: every private function must\n    /// assign side-effect counters alongside every side-effect that it emits,\n    /// and also expose to the kernel the counters that it started and ended\n    /// with.\n    /// This gives the kernel enough information to arrange all side-effects in\n    /// the correct order.\n    /// It can then catch (for example) if a function tries to read state\n    /// before it has been written (e.g. if A.a2() maliciously tried to read\n    /// a value of x=37) (e.g. if A.a1() maliciously tried to read x=6).\n    ///\n    /// If a malicious app contract _lies_ and does not count correctly:\n    /// - It cannot lie about its start and end counters because the kernel\n    ///   will catch this.\n    /// - It _could_ lie about its intermediate counters:\n    ///   - 1. It could not increment its side-effects correctly\n    ///   - 2. It could label its side-effects with counters outside of its\n    ///        start and end counters' range.\n    ///   The kernel will catch 2.\n    ///   The kernel will not catch 1., but this would only cause corruption\n    ///   to the private state of the malicious contract, and not any other\n    ///   contracts (because a contract can only modify its own state). If\n    ///   a \"good\" contract is given _read access_ to a maliciously-counting\n    ///   contract (via an external getter function, or by reading historic\n    ///   state from the archive tree directly), and they then make state\n    ///   changes to their _own_ state accordingly, that could be dangerous.\n    ///   Developers should be mindful not to trust the claimed innards of\n    ///   external contracts unless they have audited/vetted the contracts\n    ///   including vetting the side-effect counter incrementation.\n    ///   This is a similar paradigm to Ethereum smart contract development:\n    ///   you must vet external contracts that your contract relies upon, and\n    ///   you must not make any presumptions about their claimed behaviour.\n    ///   (Hopefully if a contract imports a version of aztec-nr, we will get\n    ///   contract verification tooling that can validate the authenticity\n    ///   of the imported aztec-nr package, and hence infer that the side-\n    ///   effect counting will be correct, without having to re-audit such logic\n    ///   for every contract).\n    ///\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            include_by_timestamp: 0,\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            anchor_block_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n            expected_non_revertible_side_effect_counter: 0,\n            expected_revertible_side_effect_counter: 0,\n        }\n    }\n}\n"
    },
    "75": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::{MAX_U32_VALUE, NULL_MSG_SENDER_CONTRACT_ADDRESS};\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\n/// # PublicContext\n///\n/// The **main interface** between an #[external(\"public\")] function and the Aztec blockchain.\n///\n/// An instance of the PublicContext is initialized automatically at the outset\n/// of every public function, within the #[external(\"public\")] macro, so you'll never\n/// need to consciously instantiate this yourself.\n///\n/// The instance is always named `context`, and it will always be available\n/// within the body of every #[external(\"public\")] function in your smart contract.\n///\n/// Typical usage for a smart contract developer will be to call getter\n/// methods of the PublicContext.\n///\n/// _Pushing_ data and requests to the context is mostly handled within\n/// aztec-nr's own functions, so typically a smart contract developer won't\n/// need to call any setter methods directly.\n///\n/// ## Responsibilities\n/// - Exposes contextual data to a public function:\n///   - Data relating to how this public function was called:\n///     - msg_sender, this_address\n///   - Data relating to the current blockchain state:\n///     - timestamp, block_number, chain_id, version\n///   - Gas and fee information\n/// - Provides state access:\n///   - Read/write public storage (key-value mapping)\n///   - Check existence of notes and nullifiers\n///     (Some patterns use notes & nullifiers to store public (not private)\n///     information)\n///   - Enables consumption of L1->L2 messages.\n/// - Enables calls to other public smart contract functions:\n/// - Writes data to the blockchain:\n///   - Updates to public state variables\n///   - New public logs (for events)\n///   - New L2->L1 messages\n///   - New notes & nullifiers\n///     (E.g. pushing public info to notes/nullifiers, or for completing\n///     \"partial notes\")\n///\n/// ## Key Differences from Private Execution\n///\n/// Unlike private functions -- which are executed on the user's device and which\n/// can only reference historic state -- public functions are executed by a block\n/// proposer and are executed \"live\" on the _current_ tip of the chain.\n/// This means public functions can:\n/// - Read and write _current_ public state\n/// - Immediately see the effects of earlier transactions in the same block\n///\n/// Also, public functions are executed within a zkVM (the \"AVM\"), so that they\n/// can _revert_ whilst still ensuring payment to the proposer and prover.\n/// (Private functions cannot revert: they either succeed, or they cannot be\n/// included).\n///\n/// ## Optimising Public Functions\n///\n/// Using the AVM to execute public functions means they compile down to \"AVM\n/// bytecode\" instead of the ACIR that private functions (standalone circuits)\n/// compile to. Therefore the approach to optimising a public function is\n/// fundamentally different from optimising a public function.\n///\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl Eq for PublicContext {\n    fn eq(self, other: Self) -> bool {\n        (self.args_hash == other.args_hash)\n        // Can't compare the function compute_args_hash\n    }\n}\n\nimpl PublicContext {\n    /// Creates a new PublicContext instance.\n    ///\n    /// Low-level function: This is called automatically by the #[external(\"public\")]\n    /// macro, so you shouldn't need to be called directly by smart contract\n    /// developers.\n    ///\n    /// # Arguments\n    /// * `compute_args_hash` - Function to compute the args_hash\n    ///\n    /// # Returns\n    /// * A new PublicContext instance\n    ///\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    /// Emits a _public_ log that will be visible onchain to everyone.\n    ///\n    /// # Arguments\n    /// * `log` - The data to log, must implement Serialize trait\n    ///\n    pub fn emit_public_log<T>(_self: Self, log: T)\n    where\n        T: Serialize,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    /// Checks if a given note hash exists in the note hash tree at a particular\n    /// leaf_index.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The note hash to check for existence\n    /// * `leaf_index` - The index where the note hash should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the note hash exists at the specified index\n    ///\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: u64) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    /// Checks if a specific L1-to-L2 message exists in the L1-to-L2 message\n    /// tree at a particular leaf index.\n    ///\n    /// Common use cases include token bridging, cross-chain governance, and\n    /// triggering L2 actions based on L1 events.\n    ///\n    /// This function should be called before attempting to consume an L1-to-L2\n    /// message.\n    ///\n    /// # Arguments\n    /// * `msg_hash` - Hash of the L1-to-L2 message to check\n    /// * `msg_leaf_index` - The index where the message should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the message exists at the specified index\n    ///\n    /// # Advanced\n    /// * Uses the AVM l1_to_l2_msg_exists opcode for tree lookup\n    /// * Messages are copied from L1 Inbox to L2 by block proposers\n    ///\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        // TODO(alvaro): Make l1l2msg leaf index a u64 upstream\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index as u64) } == 1\n    }\n\n    /// Checks if a specific nullifier has been emitted by a given contract.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. An example is to check\n    /// whether a contract has been published: we emit a nullifier that is\n    /// deterministic, but whose preimage is _not_ private. This is more\n    /// efficient than using mutable storage, and can be done directly\n    /// from a private function.\n    ///\n    /// Nullifiers can be tested for non-existence in public, which is not the\n    /// case in private. Because private functions do not have access to\n    /// the tip of the blockchain (but only the anchor block they are built\n    /// at) they can only prove nullifier non-existence in the past. But between\n    /// an anchor block and the block in which a tx is included, the nullifier\n    /// might have been inserted into the nullifier tree by some other\n    /// transaction.\n    /// Public functions _do_ have access to the tip of the state, and so\n    /// this pattern is safe.\n    ///\n    /// # Arguments\n    /// * `unsiloed_nullifier` - The raw nullifier value (before siloing with\n    ///                          the contract address that emitted it).\n    /// * `address` - The claimed contract address that emitted the nullifier\n    ///\n    /// # Returns\n    /// * `bool` - True if the nullifier has been emitted by the specified contract\n    ///\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2) -- effectively\n    /// marking it as \"read\".\n    ///\n    /// Use this function if you only want the message to ever be \"referred to\"\n    /// once. Once consumed using this method, the message cannot be consumed\n    /// again, because a nullifier is emitted.\n    /// If your use case wants for the message to be read unlimited times, then\n    /// you can always read any historic message from the L1-to-L2 messages tree,\n    /// using the `l1_to_l2_msg_exists` method. Messages never technically get\n    /// deleted from that tree.\n    ///\n    /// The message will first be inserted into an Aztec \"Inbox\" smart contract\n    /// on L1. It will not be available for consumption immediately. Messages\n    /// get copied-over from the L1 Inbox to L2 by the next Proposer in batches.\n    /// So you will need to wait until the messages are copied before you can\n    /// consume them.\n    ///\n    /// # Arguments\n    /// * `content` - The message content that was sent from L1\n    /// * `secret` - Secret value used for message privacy (if needed)\n    /// * `sender` - Ethereum address that sent the message\n    /// * `leaf_index` - Index of the message in the L1-to-L2 message tree\n    ///\n    /// # Advanced\n    /// * Validates message existence in the L1-to-L2 message tree\n    /// * Prevents double-consumption by emitting a nullifier\n    /// * Message hash is computed from all parameters + chain context\n    /// * Will revert if message doesn't exist or was already consumed\n    ///\n    pub fn consume_l1_to_l2_message(\n        self: Self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    /// Sends an \"L2 -> L1 message\" from this function (Aztec, L2) to a smart\n    /// contract on Ethereum (L1). L1 contracts which are designed to\n    /// send/receive messages to/from Aztec are called \"Portal Contracts\".\n    ///\n    /// Common use cases include withdrawals, cross-chain asset transfers, and\n    /// triggering L1 actions based on L2 state changes.\n    ///\n    /// The message will be inserted into an Aztec \"Outbox\" contract on L1,\n    /// when this transaction's block is proposed to L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target portal contract. The message will need to be manually\n    /// consumed from the Outbox through a separate Ethereum transaction: a user\n    /// will need to call a function of the portal contract -- a function\n    /// specifically designed to make a call to the Outbox to consume the\n    /// message.\n    /// The message will only be available for consumption once the _epoch_\n    /// proof has been submitted. Given that there are multiple Aztec blocks\n    /// within an epoch, it might take some time for this epoch proof to be\n    /// submitted -- especially if the block was near the start of an epoch.\n    ///\n    /// # Arguments\n    /// * `recipient` - Ethereum address that will receive the message\n    /// * `content` - Message content (32 bytes as a Field element)\n    ///\n    pub fn message_portal(_self: Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    /// Calls a public function on another contract.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Arguments to pass to the function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn call_public_function<let N: u32>(\n        _self: Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; N],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = [function_selector.to_field()].concat(args);\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Makes a read-only call to a public function on another contract.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Useful for querying data from other contracts safely.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Array of arguments to pass to the called function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn static_call_public_function<let N: u32>(\n        _self: Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; N],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = [function_selector.to_field()].concat(args);\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Adds a new note hash to the Aztec blockchain's global Note Hash Tree.\n    ///\n    /// Notes are ordinarily constructed and emitted by _private_ functions, to\n    /// ensure that both the content of the note, and the contract that emitted\n    /// the note, stay private.\n    ///\n    /// There are however some useful patterns whereby a note needs to contain\n    /// _public_ data. The ability to push a new note_hash from a _public_\n    /// function means that notes can be injected with public data immediately\n    /// -- as soon as the public value is known. The slower alternative would\n    /// be to submit a follow-up transaction so that a private function can\n    /// inject the data. Both are possible on Aztec.\n    ///\n    /// Search \"Partial Note\" for a very common pattern which enables a note\n    /// to be \"partially\" populated with some data in a _private_ function, and\n    /// then later \"completed\" with some data in a public function.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The hash of the note to add to the tree\n    ///\n    /// # Advanced\n    /// * The note hash will be siloed with the contract address by the protocol\n    ///\n    pub fn push_note_hash(_self: Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n\n    /// Adds a new nullifier to the Aztec blockchain's global Nullifier Tree.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. Hence why you're seeing this\n    /// function within the PublicContext.\n    /// An example is to check whether a contract has been published: we emit\n    /// a nullifier that is deterministic, but whose preimage is _not_ private.\n    ///\n    /// # Arguments\n    /// * `nullifier` - A unique field element that represents the consumed\n    ///   state\n    ///\n    /// # Advanced\n    /// * Nullifier is immediately added to the global nullifier tree\n    /// * Emitted nullifiers are immediately visible to all\n    ///   subsequent transactions in the same block\n    /// * Automatically siloed with the contract address by the protocol\n    /// * Used for preventing double-spending and ensuring one-time actions\n    ///\n    pub fn push_nullifier(_self: Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    /// Returns the address of the current contract being executed.\n    ///\n    /// This is equivalent to `address(this)` in Solidity (hence the name).\n    /// Use this to identify the current contract's address, commonly needed for\n    /// access control or when interacting with other contracts.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The contract address of the current function being\n    ///                    executed.\n    ///\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: If the calling function is a _private_ function, then\n    /// it had the option of hiding its address when enqueuing this public\n    /// function call. In such cases, this `context.msg_sender()` method will\n    /// return `Option<AztecAddress>::none`.\n    /// If the calling function is a _public_ function, it will always return\n    /// an `Option<AztecAddress>::some` (i.e. a non-null value).\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called\n    ///   this function (be it an app contract or a user's account contract).\n    ///\n    /// # Advanced\n    /// * Value is provided by the AVM sender opcode\n    /// * In nested calls, this is the immediate caller, not the original\n    ///   transaction sender\n    ///\n    pub fn msg_sender(_self: Self) -> Option<AztecAddress> {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let maybe_msg_sender = unsafe { sender() };\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// \"Unsafe\" versus calling `context.msg_sender()`, because it doesn't\n    /// translate `NULL_MSG_SENDER_CONTRACT_ADDRESS` as\n    /// `Option<AztecAddress>::none`.\n    /// Used by some internal aztecnr functions.\n    pub fn msg_sender_unsafe(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n\n    /// Returns the function selector of the currently-executing function.\n    ///\n    /// This is similar to `msg.sig` in Solidity, returning the first 4\n    /// bytes of the function signature.\n    ///\n    /// # Returns\n    /// * `FunctionSelector` - The 4-byte function identifier\n    ///\n    /// # Advanced\n    /// * Extracted from the first element of calldata\n    /// * Used internally for function dispatch in the AVM\n    ///\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    ///\n    /// Very low-level function: The #[external(\"public\")] macro uses this internally.\n    /// Smart contract developers typically won't need to access this\n    /// directly as arguments are automatically made available.\n    ///\n    /// # Returns\n    /// * `Field` - Hash of the function arguments\n    ///\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n\n    /// Returns the \"transaction fee\" for the current transaction.\n    /// This is the final tx fee that will be deducted from the fee_payer's\n    /// \"fee-juice\" balance (in the protocol's Base Rollup circuit).\n    ///\n    /// # Returns\n    /// * `Field` - The actual, final cost of the transaction, taking into account:\n    ///             the actual gas used during the setup and app-logic phases,\n    ///             and the fixed amount of gas that's been allocated by the user\n    ///             for the teardown phase.\n    ///             I.e. effectiveL2FeePerGas * l2GasUsed + effectiveDAFeePerGas * daGasUsed\n    ///\n    /// This will return `0` during the \"setup\" and \"app-logic\" phases of\n    /// tx execution (because the final tx fee is not known at that time).\n    /// This will only return a nonzero value during the \"teardown\" phase of\n    /// execution, where the final tx fee can actually be computed.\n    ///\n    /// Regardless of _when_ this function is called during the teardown phase,\n    /// it will always return the same final tx fee value. The teardown phase\n    /// does not consume a variable amount of gas: it always consumes a\n    /// pre-allocated amount of gas, as specified by the user when they generate\n    /// their tx.\n    ///\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    /// Returns the chain ID of the current network.\n    ///\n    /// This is similar to `block.chainid` in Solidity. Returns the unique\n    /// identifier for the blockchain network this transaction is executing on.\n    ///\n    /// Helps prevent cross-chain replay attacks. Useful if implementing\n    /// multi-chain contract logic.\n    ///\n    /// # Returns\n    /// * `Field` - The chain ID as a field element\n    ///\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n\n    /// Returns the Aztec protocol version that this transaction is executing\n    /// under. Different versions may have different rules, opcodes, or\n    /// cryptographic primitives.\n    ///\n    /// This is similar to how Ethereum has different EVM versions.\n    ///\n    /// Useful for forward/backward compatibility checks\n    ///\n    /// Not to be confused with contract versions; this is the protocol version.\n    ///\n    /// # Returns\n    /// * `Field` - The protocol version as a field element\n    ///\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    /// Returns the current block number.\n    ///\n    /// This is similar to `block.number` in Solidity.\n    ///\n    /// Note: the current block number is only available within a public function\n    /// (as opposed to a private function).\n    ///\n    /// Note: the time intervals between blocks should not be relied upon as\n    /// being consistent:\n    /// - Timestamps of blocks fall within a range, rather than at exact regular\n    ///   intervals.\n    /// - Slots can be missed.\n    /// - Protocol upgrades can completely change the intervals between blocks\n    ///   (and indeed the current roadmap plans to reduce the time between\n    ///   blocks, eventually).\n    /// Use `context.timestamp()` for more-reliable time-based logic.\n    ///\n    /// # Returns\n    /// * `u32` - The current block number\n    ///\n    pub fn block_number(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n\n    /// Returns the timestamp of the current block.\n    ///\n    /// This is similar to `block.timestamp` in Solidity.\n    ///\n    /// All functions of all transactions in a block share the exact same\n    /// timestamp (even though technically each transaction is executed\n    /// one-after-the-other).\n    ///\n    /// Important note: Timestamps of Aztec blocks are not at reliably-fixed\n    /// intervals. The proposer of the block has some flexibility to choose a\n    /// timestamp which is in a valid _range_: Obviously the timestamp of this\n    /// block must be strictly greater than that of the previous block, and must\n    /// must be less than the timestamp of whichever ethereum block the aztec\n    /// block is proposed to. Furthermore, if the timestamp is not deemed close\n    /// enough to the actual current time, the committee of validators will not\n    /// attest to the block.\n    ///\n    /// # Returns\n    /// * `u64` - Unix timestamp in seconds\n    ///\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n\n    /// Returns the fee per unit of L2 gas for this transaction (aka the \"L2 gas\n    /// price\"), as chosen by the user.\n    ///\n    /// L2 gas covers the cost of executing public functions and handling\n    /// side-effects within the AVM.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of L2 gas\n    ///\n    /// Wallet developers should be mindful that the choice of gas price (which\n    /// is publicly visible) can leak information about the user, e.g.:\n    /// - which wallet software the user is using;\n    /// - the amount of time which has elapsed from the time the user's wallet\n    ///   chose a gas price (at the going rate), to the time of tx submission.\n    ///   This can give clues about the proving time, and hence the nature of\n    ///   the tx.\n    /// - the urgency of the transaction (which is kind of unavoidable, if the\n    ///   tx is indeed urgent).\n    /// - the wealth of the user.\n    /// - the exact user (if the gas price is explicitly chosen by the user to\n    ///   be some unique number like 0.123456789, or their favorite number).\n    /// Wallet devs might wish to consider fuzzing the choice of gas price.\n    ///\n    pub fn base_fee_per_l2_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_l2_gas()\n        }\n    }\n\n    /// Returns the fee per unit of DA (Data Availability) gas (aka the \"DA gas\n    /// price\").\n    ///\n    /// DA gas covers the cost of making transaction data available on L1.\n    ///\n    /// See the warning in `fee_pre_l2_gas` for how gas prices can be leaky.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of DA gas\n    ///\n    pub fn base_fee_per_da_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_da_gas()\n        }\n    }\n\n    /// Returns the remaining L2 gas available for this transaction.\n    ///\n    /// Different AVM opcodes consume different amounts of gas.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining L2 gas units\n    ///\n    pub fn l2_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n\n    /// Returns the remaining DA (Data Availability) gas available for this\n    /// transaction.\n    ///\n    /// DA gas is consumed when emitting data that needs to be made available\n    /// on L1, such as public logs or state updates.\n    /// All of the side-effects from the private part of the tx also consume\n    /// DA gas before execution of any public functions even begins.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining DA gas units\n    ///\n    pub fn da_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n\n    /// Checks if the current execution is within a staticcall context, where\n    /// no state changes or logs are allowed to be emitted (by this function\n    /// or any nested function calls).\n    ///\n    /// # Returns\n    /// * `bool` - True if in staticcall context, false otherwise\n    ///\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    /// Reads raw field values from public storage.\n    /// Reads N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to read from\n    ///\n    /// # Returns\n    /// * `[Field; N]` - Array of N field values from consecutive storage slots\n    ///\n    /// # Generic Parameters\n    /// * `N` - the number of consecutive slots to return, starting from the\n    ///         `storage_slot`.\n    ///\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    /// Reads a typed value from public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to read from\n    ///\n    /// # Returns\n    /// * `T` - The deserialized value from storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type that the caller expects to read from the `storage_slot`.\n    ///\n    pub fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    /// Writes raw field values to public storage.\n    /// Writes to N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// Public storage writes take effect immediately.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to write to\n    /// * `values` - Array of N Fields to write to storage\n    ///\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    /// Writes a typed value to public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to write to\n    /// * `value` - The typed value to write to storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type to write to storage.\n    ///\n    pub fn storage_write<T>(self, storage_slot: Field, value: T)\n    where\n        T: Packable,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> u32 {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn base_fee_per_l2_gas() -> u128 {\n    base_fee_per_l2_gas_opcode()\n}\nunconstrained fn base_fee_per_da_gas() -> u128 {\n    base_fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> u32 {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> u32 {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> u1 {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: u64) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: u64) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\n\nunconstrained fn call<let N: u32>(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field; N],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, N, args)\n}\n\nunconstrained fn call_static<let N: u32>(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field; N],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, N, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeBaseFeePerL2Gas)]\nunconstrained fn base_fee_per_l2_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeBaseFeePerDaGas)]\nunconstrained fn base_fee_per_da_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> u1 {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n// While the length parameter might seem unnecessary given that we have N we keep it around because at the AVM bytecode\n// level, we want to support non-comptime-known lengths for such opcodes, even if Noir code will not generally take that\n// route.\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<let N: u32>(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    length: u32,\n    args: [Field; N],\n) {}\n\n// While the length parameter might seem unnecessary given that we have N we keep it around because at the AVM bytecode\n// level, we want to support non-comptime-known lengths for such opcodes, even if Noir code will not generally take that\n// route.\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<let N: u32>(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    length: u32,\n    args: [Field; N],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "76": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr",
      "source": "use crate::{hash::hash_args, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\n/// A hash that represents a private contract function call's return value. Call `get_preimage` to get the underlying\n/// value.\n///\n/// The kernels don't process the actual return values but instead their hashes, so it is up to contracts to populate\n/// oracles with the preimages of these hashes on return to make them available to their callers.\n///\n/// Public calls don't utilize this mechanism since the AVM does process the full return values.\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    /// Fetches the underlying return value from an oracle, constraining that it corresponds to the return data hash.\n    pub fn get_preimage<T>(self) -> T\n    where\n        T: Deserialize,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it. If `T`\n        // is `()`, then `preimage` must be an array of length 0 (since that is `()`'s deserialization length).\n        // `hash_args` handles empty arrays following the protocol rules (i.e. an empty args array is signaled\n        // with a zero hash), correctly constraining `self.hash`.\n        let preimage = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args(preimage), \"Preimage mismatch\");\n\n        Deserialize::deserialize(preimage)\n    }\n}\n\nmod test {\n    use crate::{\n        hash::hash_args,\n        oracle::execution_cache,\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use super::ReturnsHash;\n    use protocol_types::traits::Serialize;\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn retrieves_preimage() {\n        let env = TestEnvironment::new();\n        env.private_context(|_| {\n            let value = MockStruct::new(4, 7);\n            let serialized = value.serialize();\n\n            let hash = hash_args(serialized);\n            execution_cache::store(serialized, hash);\n\n            assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n        });\n    }\n\n    #[test]\n    unconstrained fn retrieves_empty_preimage() {\n        let env = TestEnvironment::new();\n        env.private_context(|_| {\n            let value = ();\n            let serialized = [];\n\n            let hash = hash_args(serialized);\n            execution_cache::store(serialized, hash);\n\n            assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n        });\n    }\n\n    #[test(should_fail_with = \"Preimage mismatch\")]\n    unconstrained fn rejects_bad_preimage() {\n        let value = MockStruct::new(4, 7);\n        let serialized = value.serialize();\n\n        let mut bad_serialized = serialized;\n        bad_serialized[0] += 1;\n\n        let hash = hash_args(serialized);\n\n        let _ = OracleMock::mock(\"privateLoadFromExecutionCache\").returns(bad_serialized);\n        assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n    }\n\n    // This test passes due to a Noir bug.\n    // #[test(should_fail_with=\"Preimage mismatch\")]\n    // unconstrained fn rejects_bad_empty_preimage() {\n    //     let value = ();\n    //     let serialized = [];\n\n    //     let hash = hash_args(serialized);\n\n    //     let _ = OracleMock::mock(\"privateLoadFromExecutionCache\").returns([1]);\n    //     assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n    // }\n}\n"
    },
    "77": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{execution::get_utility_context, storage::storage_read};\nuse protocol_types::{address::AztecAddress, traits::Packable};\n\n// If you'll modify this struct don't forget to update utility_context.ts as well.\npub struct UtilityContext {\n    block_number: u32,\n    timestamp: u64,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        get_utility_context()\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        // We get a context with default contract address, and then we construct the final context with the provided\n        // contract address.\n        let default_context = get_utility_context();\n\n        Self {\n            block_number: default_context.block_number,\n            timestamp: default_context.timestamp,\n            contract_address,\n            version: default_context.version,\n            chain_id: default_context.chain_id,\n        }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        // We get a context with default contract address and block number, and then we construct the final context\n        // with the provided contract address and block number.\n        let default_context = get_utility_context();\n\n        Self {\n            block_number,\n            timestamp: default_context.timestamp,\n            contract_address,\n            version: default_context.version,\n            chain_id: default_context.chain_id,\n        }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn timestamp(self) -> u64 {\n        self.timestamp\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "78": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/contract_self.nr",
      "source": "use crate::{\n    context::{\n        calls::{PrivateCall, PrivateStaticCall, PublicCall, PublicStaticCall},\n        private_context::PrivateContext,\n        public_context::PublicContext,\n        utility_context::UtilityContext,\n    },\n    event::{\n        event_emission::{emit_event_in_private, emit_event_in_public},\n        event_interface::EventInterface,\n        event_message::EventMessage,\n    },\n};\nuse protocol_types::{\n    address::AztecAddress,\n    constants::NULL_MSG_SENDER_CONTRACT_ADDRESS,\n    traits::{Deserialize, Serialize},\n};\n\n/// `ContractSelf` is the core interface for interacting with an Aztec contract's own state and context.\n///\n/// This struct is automatically injected into every #[external(...)] contract function by the Aztec macro system and is\n/// accessible through the `self` variable.\n///\n/// # Usage in Contract Functions\n///\n/// Once injected, you can use `self` to:\n/// - Access storage: `self.storage.balances.at(owner).read()`\n/// - Call contracts: `self.call(Token::at(address).transfer(recipient, amount))`\n/// - Emit events: `self.emit(event).deliver_to(recipient, delivery_mode)` (private) or `self.emit(event)` (public)\n/// - Get the contract address: `self.address`\n/// - Get the caller: `self.msg_sender()`\n/// - Access low-level Aztec.nr APIs through the context: `self.context`\n///\n/// # Example\n///\n/// ```noir\n/// #[external(\"private\")]\n/// fn withdraw(amount: u128, recipient: AztecAddress) {\n///     // Get the caller of this function\n///     let sender = self.msg_sender().unwrap();\n///\n///     // Access storage\n///     let token = self.storage.donation_token.get_note().get_address();\n///\n///     // Call contracts\n///     self.call(Token::at(token).transfer(recipient, amount));\n/// }\n/// ```\n///\n/// # Type Parameters\n///\n/// - `Context`: The execution context type - either `&mut PrivateContext`, `PublicContext`, or `UtilityContext`\n/// - `Storage`: The contract's storage struct (defined with `#[storage]`), or `()` if the contract has no storage\n/// - `CallSelf`: Macro-generated type for calling contract's own non-view functions\n/// - `EnqueueSelf`: Macro-generated type for enqueuing calls to the contract's own non-view functions\n/// - `CallSelfStatic`: Macro-generated type for calling contract's own view functions\n/// - `EnqueueSelfStatic`: Macro-generated type for enqueuing calls to the contract's own view functions\npub struct ContractSelf<Context, Storage, CallSelf, EnqueueSelf, CallSelfStatic, EnqueueSelfStatic, CallInternal> {\n    /// The address of this contract\n    pub address: AztecAddress,\n    /// The contract's storage instance, representing the struct to which the `#[storage]` macro was applied in your\n    /// contract. If the contract has no storage, the type of this will be `()`.\n    ///\n    /// This storage instance is specialized for the current execution context (private, public, or utility) and\n    /// provides access to the contract's state variables. Each state variable accepts the context as a generic\n    /// parameter, which determines its available functionality. For example, a PublicImmutable variable can be read\n    /// from any context (public, private, or utility) but can only be written to from public contexts.\n    ///\n    /// # Developer Note\n    /// If you've arrived here while trying to access your contract's storage while the `Storage` generic type is set to\n    /// unit type `()`, it means you haven't yet defined a Storage struct using the #[storage] macro in your contract.\n    /// For guidance on setting this up, please refer to our docs:\n    /// https://docs.aztec.network/developers/docs/guides/smart_contracts/storage\n    pub storage: Storage,\n    /// The execution context whose type is determined by the #[external(...)] attribute of the contract function based\n    /// on the external function type (private, public, or utility).\n    pub context: Context,\n\n    /// Provides type-safe methods for calling this contract's own non-view functions.\n    ///\n    /// In private and public contexts this will be a struct with appropriate methods;\n    /// in utility context it will be the unit type `()`.\n    ///\n    /// Example API:\n    /// ```noir\n    /// self.call_self.some_private_function(args)\n    /// ```\n    pub call_self: CallSelf,\n    /// Provides type-safe methods for enqueuing calls to this contract's own non-view functions.\n    ///\n    /// In private context this will be a struct with appropriate methods;\n    /// in public and utility contexts it will be the unit type `()`.\n    ///\n    /// Example API:\n    /// ```noir\n    /// self.enqueue_self.some_public_function(args)\n    /// ```\n    pub enqueue_self: EnqueueSelf,\n    /// Provides type-safe methods for calling this contract's own view functions.\n    ///\n    /// In private and public contexts this will be a struct with appropriate methods;\n    /// in utility context it will be the unit type `()`.\n    ///\n    /// Example API:\n    /// ```noir\n    /// self.call_self_static.some_view_function(args)\n    /// ```\n    pub call_self_static: CallSelfStatic,\n    /// Provides type-safe methods for enqueuing calls to this contract's own view functions.\n    ///\n    /// In private context this will be a struct with appropriate methods;\n    /// in public and utility contexts it will be the unit type `()`.\n    ///\n    /// Example API:\n    /// ```noir\n    /// self.enqueue_self_static.some_public_view_function(args)\n    /// ```\n    pub enqueue_self_static: EnqueueSelfStatic,\n    /// Provides type-safe methods for calling internal functions.\n    ///\n    /// In private and public contexts this will be a struct with appropriate methods;\n    /// in utility context it will be the unit type `()`.\n    ///\n    /// Example API:\n    /// ```noir\n    /// self.internal.some_internal_function(args)\n    /// ```\n    pub internal: CallInternal,\n}\n\n/// Implementation for `ContractSelf` in private execution contexts.\n///\n/// This implementation is used when a contract function is marked with `#[external(\"private\")]`.\n/// Private functions execute client-side and generate zero-knowledge proofs of their execution.\nimpl<Storage, CallSelf, EnqueueSelf, CallSelfStatic, EnqueueSelfStatic, CallInternal> ContractSelf<&mut PrivateContext, Storage, CallSelf, EnqueueSelf, CallSelfStatic, EnqueueSelfStatic, CallInternal> {\n    /// Creates a new `ContractSelf` instance for a private function.\n    ///\n    /// This constructor is called automatically by the macro system and should not be called directly.\n    pub fn new_private(\n        context: &mut PrivateContext,\n        storage: Storage,\n        call_self: CallSelf,\n        enqueue_self: EnqueueSelf,\n        call_self_static: CallSelfStatic,\n        enqueue_self_static: EnqueueSelfStatic,\n        internal: CallInternal,\n    ) -> Self {\n        Self {\n            context,\n            storage,\n            address: context.this_address(),\n            call_self,\n            enqueue_self,\n            call_self_static,\n            enqueue_self_static,\n            internal,\n        }\n    }\n\n    /// Returns the contract address that initiated this function call. This is similar to `msg.sender` in Solidity.\n    ///\n    /// Important Note: Since Aztec doesn't have a concept of an EoA ( Externally-owned Account), the msg_sender is\n    /// \"null\" for the first function call of every transaction. The first function call of a tx is likely to be a call\n    /// to the user's account contract, so this quirk will most often be handled by account contract developers.\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called this function (be it an app contract or\n    ///   a user's account contract). Returns `Option<AztecAddress>::none` for the first function call of the tx. No\n    ///   other _private_ function calls in the tx will have a `none` msg_sender, but _public_ function calls might (see\n    ///   the PublicContext).\n    ///\n    pub fn msg_sender(self) -> Option<AztecAddress> {\n        let maybe_msg_sender = self.context.msg_sender_unsafe();\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// Emits an event privately.\n    ///\n    /// Unlike public events, private events do not reveal their contents publicly. They instead create an\n    /// [EventMessage] containing the private event information, which **MUST** be delivered to a recipient via\n    /// [EventMessage::deliver_to] in order for them to learn about the event. Multiple recipients can have the same\n    /// message be delivered to them.\n    ///\n    /// # Example\n    /// ```noir\n    /// #[event]\n    /// struct Transfer { from: AztecAddress, to: AztecAddress, amount: u128 }\n    ///\n    /// #[external(\"private\")]\n    /// fn transfer(to: AztecAddress, amount: u128) {\n    ///     let from = self.msg_sender().unwrap();\n    ///\n    ///     let message: EventMessage = self.emit(Transfer { from, to, amount });\n    ///     message.deliver_to(from, MessageDelivery.UNCONSTRAINED_OFFCHAIN);\n    ///     message.deliver_to(to, MessageDelivery.CONSTRAINED_ONCHAIN);\n    /// }\n    /// ```\n    ///\n    /// # Cost\n    ///\n    /// Private event emission always results in the creation of a nullifer, which acts as a commitment to the event and\n    /// is used by third parties to verify its authenticity. See [EventMessage::deliver_to] for the costs associated to\n    /// delivery.\n    ///\n    /// # Privacy\n    ///\n    /// The nullifier created when emitting a private event leaks nothing about the content of the event - it's a\n    /// commitment that includes a random value, so even with full knowledge of the event preimage determining if an\n    /// event was emitted or not requires brute-forcing the entire `Field` space.\n    pub fn emit<Event>(&mut self, event: Event) -> EventMessage<Event>\n    where\n        Event: EventInterface + Serialize,\n    {\n        emit_event_in_private(self.context, event)\n    }\n\n    /// Makes a call to the private function defined by the `call` parameter.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the private function to invoke.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.call(Token::at(address).transfer_in_private(recipient, amount));\n    /// ```\n    ///\n    /// This enables contracts to interact with each other while maintaining\n    /// privacy. This \"composability\" of private contract functions is a key\n    /// feature of the Aztec network.\n    ///\n    /// If a user's transaction includes multiple private function calls, then\n    /// by the design of Aztec, the following information will remain private[1]:\n    /// - The function selectors and contract addresses of all private function\n    ///   calls will remain private, so an observer of the public mempool will\n    ///   not be able to look at a tx and deduce which private functions have\n    ///   been executed.\n    /// - The arguments and return values of all private function calls will\n    ///   remain private.\n    /// - The person who initiated the tx will remain private.\n    /// - The notes and nullifiers and private logs that are emitted by all\n    ///   private function calls will (if designed well) not leak any user\n    ///   secrets, nor leak which functions have been executed.\n    ///\n    /// [1] Caveats: Some of these privacy guarantees depend on how app\n    /// developers design their smart contracts. Some actions _can_ leak\n    /// information, such as:\n    /// - Calling an internal public function.\n    /// - Calling a public function and not setting msg_sender to Option::none\n    ///   (see https://github.com/AztecProtocol/aztec-packages/pull/16433)\n    /// - Calling any public function will always leak details about the nature\n    ///   of the transaction, so devs should be careful in their contract\n    ///   designs. If it can be done in a private function, then that will give\n    ///   the best privacy.\n    /// - Not padding the side-effects of a tx to some standardized, uniform\n    ///   size. The kernel circuits can take hints to pad side-effects, so a\n    ///   wallet should be able to request for a particular amount of padding.\n    ///   Wallets should ideally agree on some standard.\n    ///   - Padding should include:\n    ///     - Padding the lengths of note & nullifier arrays\n    ///     - Padding private logs with random fields, up to some standardized\n    ///       size.\n    /// See also: https://docs.aztec.network/developers/resources/considerations/privacy_considerations\n    ///\n    /// # Advanced\n    /// * The call is added to the private call stack and executed by kernel\n    ///   circuits after this function completes\n    /// * The called function can modify its own contract's private state\n    /// * Side effects from the called function are included in this transaction\n    /// * The call inherits the current transaction's context and gas limits\n    ///\n    pub fn call<let M: u32, let N: u32, T>(&mut self, call: PrivateCall<M, N, T>) -> T\n    where\n        T: Deserialize,\n    {\n        call.call(self.context)\n    }\n\n    /// Makes a read-only call to the private function defined by the `call` parameter.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be static calls.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the read-only private function to invoke.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.view(Token::at(address).balance_of_private(recipient));\n    /// ```\n    pub fn view<let M: u32, let N: u32, T>(&mut self, call: PrivateStaticCall<M, N, T>) -> T\n    where\n        T: Deserialize,\n    {\n        call.view(self.context)\n    }\n\n    /// Enqueues a call to the public function defined by the `call` parameter,\n    /// to be executed later.\n    ///\n    /// Unlike private functions which execute immediately on the user's device,\n    /// public function calls are \"enqueued\" and executed some time later by a\n    /// block proposer.\n    ///\n    /// This means a public function cannot return any values back to a private\n    /// function, because by the time the public function is being executed,\n    /// the private function which called it has already completed execution.\n    /// (In fact, the private function has been executed and proven, along with\n    /// all other private function calls of the user's tx. A single proof of the\n    /// tx has been submitted to the Aztec network, and some time later a\n    /// proposer has picked the tx up from the mempool and begun executing all\n    /// of the enqueued public functions).\n    ///\n    /// # Privacy warning\n    /// Enqueueing a public function call is an inherently leaky action.\n    /// Many interesting applications will require some interaction with public\n    /// state, but smart contract developers should try to use public function\n    /// calls sparingly, and carefully.\n    /// _Internal_ public function calls are especially leaky, because they\n    /// completely leak which private contract made the call.\n    /// See also: https://docs.aztec.network/developers/resources/considerations/privacy_considerations\n    ///\n    /// # Arguments\n    /// * `call` - The interface representing the public function to enqueue.\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn enqueue<let M: u32, let N: u32, T>(&mut self, call: PublicCall<M, N, T>)\n    where\n        T: Deserialize,\n    {\n        call.enqueue(self.context)\n    }\n\n    /// Enqueues a read-only call to the public function defined by the `call` parameter.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be static calls.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the read-only public function to enqueue.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.enqueue_view(MyContract::at(address).assert_timestamp_less_than(timestamp));\n    /// ```\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn enqueue_view<let M: u32, let N: u32, T>(&mut self, call: PublicStaticCall<M, N, T>)\n    where\n        T: Deserialize,\n    {\n        call.enqueue_view(self.context)\n    }\n\n    /// Enqueues a call to the public function defined by the `call` parameter,\n    /// to be executed later.\n    ///\n    /// As per `enqueue`, but hides this calling contract's address from the\n    /// target public function.\n    /// This means the origin of the call (msg_sender) will not be publicly\n    /// visible to any blockchain observers, nor to the target public function.\n    /// When the target public function reads `context.msg_sender()` it will\n    /// receive an `Option<AztecAddress>::none`.\n    ///\n    /// NOTES:\n    /// - Not all public functions will accept a msg_sender of \"none\". Many\n    ///   public functions will require that msg_sender is \"some\" and will\n    ///   revert otherwise. Therefore, if using `enqueue_incognito`, you must\n    ///   understand whether the function you're calling will accept a\n    ///   msg_sender of \"none\".\n    ///   Lots of public bookkeeping patterns rely on knowing which address made\n    ///   the call, so as to ascribe state against the caller's address.\n    ///   (There are patterns whereby bookkeeping could instead be done in\n    ///   private-land).\n    /// - If you are enqueueing a call to an _internal_ public function (i.e.\n    ///   a public function that will only accept calls from other functions\n    ///   of its own contract), then by definition a call to it cannot possibly\n    ///   be \"incognito\": the msg_sender must be its own address, and indeed the\n    ///   called public function will assert this. Tl;dr this is not usable for\n    ///   enqueued internal public calls.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the public function to enqueue.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.enqueue_incognito(Token::at(address).increase_total_supply_by(amount));\n    /// ```\n    ///\n    /// Advanced:\n    /// - The kernel circuits will permit _any_ private function to set the\n    ///   msg_sender field of any enqueued public function call to\n    ///   NULL_MSG_SENDER_CONTRACT_ADDRESS.\n    /// - When the called public function calls `PublicContext::msg_sender()`,\n    ///   aztec-nr will translate NULL_MSG_SENDER_CONTRACT_ADDRESS into\n    ///   `Option<AztecAddress>::none` for familiarity to devs.\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn enqueue_incognito<let M: u32, let N: u32, T>(&mut self, call: PublicCall<M, N, T>)\n    where\n        T: Deserialize,\n    {\n        call.enqueue_incognito(self.context)\n    }\n\n    /// Enqueues a read-only call to the public function defined by the `call` parameter.\n    ///\n    /// As per `enqueue_view`, but hides this calling contract's address from\n    /// the target public function.\n    ///\n    /// See `enqueue_incognito` for more details relating to hiding msg_sender.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the read-only public function to enqueue.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.enqueue_view_incognito(MyContract::at(address).assert_timestamp_less_than(timestamp));\n    /// ```\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn enqueue_view_incognito<let M: u32, let N: u32, T>(\n        &mut self,\n        call: PublicStaticCall<M, N, T>,\n    )\n    where\n        T: Deserialize,\n    {\n        call.enqueue_view_incognito(self.context)\n    }\n\n    /// Enqueues a call to the public function defined by the `call` parameter,\n    /// and designates it to be the teardown function for this tx. Only one teardown\n    /// function call can be made by a tx.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase ensures the fee payer\n    /// has sufficient balance to pay the proposer their fees.\n    /// The teardown phase is primarily intended to: calculate exactly\n    /// how much the user owes, based on gas consumption, and refund the user\n    /// any change.\n    ///\n    /// Note: in some cases, the cost of refunding the user (i.e. DA costs of\n    /// tx side-effects) might exceed the refund amount. For app logic with\n    /// fairly stable and predictable gas consumption, a material refund amount\n    /// is unlikely. For app logic with unpredictable gas consumption, a\n    /// refund might be important to the user (e.g. if a hefty function reverts\n    /// very early). Wallet/FPC/Paymaster developers should be mindful of this.\n    ///\n    /// See `enqueue` for more information about enqueuing public function calls.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the public function to designate as teardown.\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn set_as_teardown<let M: u32, let N: u32, T>(&mut self, call: PublicCall<M, N, T>)\n    where\n        T: Deserialize,\n    {\n        call.set_as_teardown(self.context)\n    }\n\n    /// Enqueues a call to the public function defined by the `call` parameter,\n    /// and designates it to be the teardown function for this tx. Only one teardown\n    /// function call can be made by a tx.\n    ///\n    /// As per `set_as_teardown`, but hides this calling contract's address from\n    /// the target public function.\n    ///\n    /// See `enqueue_incognito` for more details relating to hiding msg_sender.\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn set_as_teardown_incognito<let M: u32, let N: u32, T>(\n        &mut self,\n        call: PublicCall<M, N, T>,\n    )\n    where\n        T: Deserialize,\n    {\n        call.set_as_teardown_incognito(self.context)\n    }\n}\n\n/// Implementation for `ContractSelf` in public execution contexts.\n///\n/// This implementation is used when a contract function is marked with `#[external(\"public\")]`.\n/// Public functions are executed by the sequencer in the Aztec Virtual Machine (AVM) and can work only with public\n/// state.\nimpl<Storage, CallSelf, CallSelfStatic, CallInternal> ContractSelf<PublicContext, Storage, CallSelf, (), CallSelfStatic, (), CallInternal> {\n    /// Creates a new `ContractSelf` instance for a public function.\n    ///\n    /// This constructor is called automatically by the macro system and should not be called directly.\n    pub fn new_public(\n        context: PublicContext,\n        storage: Storage,\n        call_self: CallSelf,\n        call_self_static: CallSelfStatic,\n        internal: CallInternal,\n    ) -> Self {\n        Self {\n            context,\n            storage,\n            address: context.this_address(),\n            call_self,\n            enqueue_self: (),\n            call_self_static,\n            enqueue_self_static: (),\n            internal,\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: If the calling function is a _private_ function, then it had the option of hiding its address\n    /// when enqueuing this public function call. In such cases, this `context.msg_sender()` method will return\n    /// `Option<AztecAddress>::none`. If the calling function is a _public_ function, it will always return an\n    /// `Option<AztecAddress>::some` (i.e. a non-null value).\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called this function (be it an app contract or\n    ///   a user's account contract).\n    ///\n    /// # Advanced\n    /// * Value is provided by the AVM sender opcode\n    /// * In nested calls, this is the immediate caller, not the original transaction sender\n    ///\n    pub fn msg_sender(self: Self) -> Option<AztecAddress> {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let maybe_msg_sender = self.context.msg_sender_unsafe();\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// Emits an event publicly.\n    ///\n    /// Public events are emitted as plaintext and are therefore visible to everyone. This is is the same as Solidity\n    /// events on EVM chains.\n    ///\n    /// Unlike private events, they don't require delivery of an event message.\n    ///\n    /// # Example\n    /// ```noir\n    /// #[event]\n    /// struct Update { value: Field }\n    ///\n    /// #[external(\"public\")]\n    /// fn publish_update(value: Field) {\n    ///     self.emit(Update { value });\n    /// }\n    /// ```\n    ///\n    /// # Cost\n    ///\n    /// Public event emission is achieved by emitting public transaction logs. A total of `N+1` fields are emitted,\n    /// where `N` is the serialization length of the event.\n    pub fn emit<Event>(&mut self, event: Event)\n    where\n        Event: EventInterface + Serialize,\n    {\n        emit_event_in_public(self.context, event);\n    }\n\n    /// Makes the call to the public function defined by the `call` parameter.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the public function to invoke.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.call(Token::at(address).transfer_in_public(recipient, amount));\n    /// ```\n    ///\n    pub unconstrained fn call<let M: u32, let N: u32, T>(self, call: PublicCall<M, N, T>) -> T\n    where\n        T: Deserialize,\n    {\n        call.call(self.context)\n    }\n\n    /// Makes the read-only call to the public function defined by the `call` parameter.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be static calls.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the read-only public function to invoke.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.view(Token::at(address).balance_of_public(recipient));\n    /// ```\n    ///\n    pub unconstrained fn view<let M: u32, let N: u32, T>(self, call: PublicStaticCall<M, N, T>) -> T\n    where\n        T: Deserialize,\n    {\n        call.view(self.context)\n    }\n}\n\n/// Implementation for `ContractSelf` in utility execution contexts.\n///\n/// This implementation is used when a contract function is marked with `#[external(\"utility\")]`.\n/// Utility functions are unconstrained functions that can read private state for offchain queries.\n/// They are typically used for view functions that need to access private notes (e.g. a Token's balance_of function).\nimpl<Storage> ContractSelf<UtilityContext, Storage, (), (), (), (), ()> {\n    /// Creates a new `ContractSelf` instance for a utility function.\n    ///\n    /// This constructor is called automatically by the macro system and should not be called directly.\n    pub fn new_utility(context: UtilityContext, storage: Storage) -> Self {\n        Self {\n            context,\n            storage,\n            address: context.this_address(),\n            call_self: (),\n            enqueue_self: (),\n            call_self_static: (),\n            enqueue_self_static: (),\n            internal: (),\n        }\n    }\n}\n"
    },
    "82": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/event/event_selector.nr",
      "source": "use dep::protocol_types::{\n    hash::poseidon2_hash_bytes,\n    traits::{Deserialize, Empty, FromField, Serialize, ToField},\n};\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "84": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_BYTECODE, GENERATOR_INDEX__PUBLIC_CALLDATA,\n        GENERATOR_INDEX__SECRET_HASH, MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS,\n    },\n    hash::{poseidon2_hash_subarray, poseidon2_hash_with_separator, sha256_to_field},\n    point::Point,\n    traits::ToField,\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n}\n\n/**\n * Computes the public bytecode commitment for a contract class.\n * The commitment is `hash([separator, ...bytecode])` where bytecode omits the length prefix present\n * in `packed_bytecode`.\n *\n * @param packed_bytecode - The packed bytecode of the contract class. 0th word is the length in bytes.\n *    packed_bytecode is mutable so that we can avoid copying the array to construct one starting with\n *    separator instead of length.\n * @returns The public bytecode commitment.\n */\npub fn compute_public_bytecode_commitment(\n    mut packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS],\n) -> Field {\n    // First field element contains the length of the bytecode\n    let bytecode_length_in_bytes: u32 = packed_public_bytecode[0] as u32;\n    let bytecode_length_in_fields: u32 =\n        (bytecode_length_in_bytes / 31) + (bytecode_length_in_bytes % 31 != 0) as u32;\n    // Don't allow empty public bytecode.\n    // AVM doesn't handle execution of contracts that exist with empty bytecode.\n    assert(bytecode_length_in_fields != 0);\n    assert(bytecode_length_in_fields < MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS);\n\n    // Packed_bytecode's 0th entry is the length. Replace it with separator before hashing.\n    let separator = GENERATOR_INDEX__PUBLIC_BYTECODE.to_field();\n    packed_public_bytecode[0] = separator;\n\n    // `fields_to_hash` is the number of fields from the start of `packed_public_bytecode` that should be included in\n    // the hash. Fields after this length are ignored.\n    // +1 to account for the separator.\n    let num_fields_to_hash = bytecode_length_in_fields + 1;\n\n    poseidon2_hash_subarray(packed_public_bytecode, num_fields_to_hash)\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = [0; 100];\n    for i in 0..100 {\n        input[i] = i as Field;\n    }\n    let hash = hash_args(input);\n    dep::std::println(hash);\n    // Used in yarn-project/stdlib test snapshots:\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_calldata_hash() {\n    let mut input = [0; 100];\n    for i in 0..input.len() {\n        input[i] = i as Field;\n    }\n    let hash = hash_calldata_array(input);\n    // Used in cpp vm2 tests:\n    assert(hash == 0x191383c9f8964afd3ea8879a03b7dda65d6724773966d18dcf80e452736fc1f3);\n}\n\n#[test]\nunconstrained fn public_bytecode_commitment() {\n    let mut input = [0; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS];\n    let len = 99;\n    for i in 1..len + 1 {\n        input[i] = i as Field;\n    }\n    input[0] = (len as Field) * 31;\n    let hash = compute_public_bytecode_commitment(input);\n    dep::std::println(hash);\n    // Used in cpp vm2 tests:\n    assert(hash == 0x16d621c3387156ef53754679e7b2c9be8f0bceeb44aa59a74991df3b0b42a0bf);\n}\n"
    },
    "96": {
      "path": "/Users/jp4g/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/history/public_storage.nr",
      "source": "use dep::protocol_types::{\n    abis::block_header::BlockHeader, address::AztecAddress,\n    constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX, hash::poseidon2_hash_with_separator,\n    utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\nuse protocol_types::traits::{Hash, ToField};\n\nmod test;\n\npub trait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        // Safety: The witness is only used as a \"magical value\" that makes the proof below pass. Hence it's safe.\n        let witness = unsafe {\n            get_public_data_witness(self.global_variables.block_number, public_data_tree_index)\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert_eq(\n            self.state.partial.public_data_tree.root,\n            root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path),\n            \"Proving public value inclusion failed\",\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(\n                preimage.slot,\n                public_data_tree_index,\n                \"Public data tree index doesn't match witness\",\n            );\n            preimage.value\n        };\n\n        value\n    }\n}\n"
    }
  },
  "functions": [
    {
      "abi": {
        "error_types": {
          "12256088423018033107": {
            "error_kind": "string",
            "string": "Function _validate_emitter_and_update_value can only be called by the same contract"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18173155084464344029": {
            "error_kind": "string",
            "string": "Emitter not registered"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "8228371833434187583": {
            "error_kind": "string",
            "string": "Trying to read from uninitialized PublicImmutable"
          }
        },
        "parameters": [
          {
            "name": "emitter_chain_id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 16
            },
            "visibility": "private"
          },
          {
            "name": "emitter_address",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "value",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_only_self"
      ],
      "debug_symbols": "tZvdblS7DoDfpddcJM6PY15lawsVKFuVqoK64UhHiHc/tpftrBatnNWZcsN845nlsR0ndhL68+bz3ccf/3y4f/zy9d+b93/9vPn4dP/wcP/Ph4evn26/3399ZOnPmyT/FIKb9+Udv+LNe3x3UxO/r/Lat9ec7dXeAz+Ws0BjEEkRiTxaBsNgqMWgZQd+GoChswTkqd4NMNlH2AyGSLpAMyCX0NigpeLAdgP/estgIBZuwI8XNrWJhUW+XJoDGdTq4JLmkuaSXhzQAMGhG4zsID/Bv94lgAo5OfhH4BJwSXFJqQ7DQIK5ARo0cPCfkKhuIAqbABlgdRgGAxzQgLKDPY4pOYTEFGIuDqYQq3yHBMhAY6jgku6S7hIsDmighil0AzVMgX+iJgHaYEgCbIAGEszK+TMkYrUIoIHk4QbNgQzEsA3YncruDBncDdBguGS4hFxCJqEEDqKHM4EkITdAA3AJdIOSHcQwFCAD9UIBDWS4K88m6smhOsiPcqBIoqogCblB3yAnsawoZQhCJwgZdKeSg2wAmMipliB06jYIOQ0bBSZ0ohzUgmwkMqsJsrHIOUMQOkHIIGQlZCVkNWTVxiTnBkHo1EPWuxPmIBsZJnIaJQidiJ9tvNpkkMnTQKk5yawxGk4S3VaFZOI0sRRaCUInmd1GzUlWTSOOWkOl4ST2GYWMQkYuK6kEhSyLvqI0nCTiRt1Jlqw2lFoQ+9ElD4qsq0YhE482koh3UupOEnGjkI2QjZBJLTCqQWRUxSOj4SQ5hEmpO0EOClkJWQlZTUE1iJxktIyGU49fk3Kxkfo2lJqTVDmjGjScZLSM0KilHNSdcgqqQeRUxSNQak4tBYWsh6xPGTnJmmI0nGRJNEInmd1YlFoQGXUZmY009pK7XfIFZZZplTNCJ1m1jZqTWrqRjMdQGk5q6UYhGyEbIaOQkctQVh8kpeEks9YoZDIXjNBJMmckpRZETuLbRrL6jKzUncQjI7ZggBI5SQ3aSCK+EfnIaBE08pEZOWTZR2YABHUbhSHz16gGDSexT8doyPqiER8aUyUd/Y26E6WgFkQWXUolyCNOOWQ5ZBAyCFkJmeaLRFyro5GPDLWQNR8Z6hDUbRRI1k6jGjScJJ+HrMok+TyaUt+Il/YaRE4S3YFCslqMoVSDhpOO/kbdSdZ2I44aJSVyEvuMQjZCNkJGISOXZak9oyuRk0TcCJ1kNlJW6k6SG1SVxCrxLUvESSzNMi+N+AnuCAQl0FzBFTEQIb4gEebCLig9sqFkjWOdSI6Q6sQpzVOap7Tor5EiBsoi6NgD25S2Ke1T2qcUpxRb4EgTRyBNGyhsKAkmht6SQ28B8SLLwBVZALNssaBIxjhOaZ9SNTKDoBpp2ALVSMOdlAI16obDUXeBWXZ3oBtBQ7V3Q9DHJP1r1e92Rf2uDHdtdSIFylaK2yJF+TVQ6WavKpM8z6A/IYnuOKWkGvS7aq+ibgcdJVCy/wPdEm6WtYyBkAMlu7lHEpSp67iTUmDTnyBFDNSxMJxSHQvDHjimVMfCkBy1ROpC0sWJjSTmRi1IHikSxS55rutHrxAUMk1y2QKD7hUN+5TKosNNnSD62qVbRiNyGiEbvp5pFTVyGSYI8jUOcwpyLQj+LIoHUmm4kc1BLYicNP5F8gXRGgOm7jRCprEtkiyoq4vhTqrhE6UjWXGDrYAq5RIUMoAgdCohK27FqCkoNNfQ0uJZdFcHtiB3dWjLshG605SsqgLlFDRl5O6RTk3DKS3FnabiBlGFIDeNWsiau0U9B4UMwwrvEIAwNI/QQvZsSbobqkrkpPuijdBJJ2jRR4ptjIoWVKOQbSmBiiOwT6lOyTIEpRJtT0nObDRyUMgoBdlmq+SUgmrQcMoQ5FoyxLO6XQYh3S5vhE56MLGR5icJou2ci9bMjUbINCVks12y1hrDkIJsE3iro9jtKZCcMWpOEDKoQeRUQlbcCtAd9UahuYWWFs+iuwrorsLIQS2I3OmS7JCglAxBIdOUUPd0B2pYplRXcnW6VDdIN6FGblppIWvuVuklKGQYVqC7qsXUKLSQPvvr17sbP1z98P3p7k7OVnenrXwG++326e7x+837xx8PD+9u/nP78EO/9O+320d9/X77xJ+yM3ePn/mVFX65f7gT+vVuPp2OH5Wybk9z1aZQwPX2mYp8rIL3EbJxVB3MiKEE2zMdcKyD80AyX3UUKYVHOlaujOxm8CKWD12pCxWVt8kRDt7UTTPGMx3tDcLR/2w4+IwCTUXlRvAwHGPhCsiCunnCrcpUkcszFfQG0cjpDcKx8qVIM7nZwTP/0JcMb+FM+cPOgGzMbWDoeGDyIk/5wNx9QS7/h66s0rT06jqY6VpXWMehK8v0qBgB7XC8hi3ylLv27LnOXPvRzIeFIVxQZ34Q95mHK2FeedMBpjvlOMnW7vQc7rRcDt1ZZWr1POXT0OlLu2hc8HhBhlWWdp+1+3BWuMiGcVzfFip4Q+Q1gc8Ux4xDfu7FIsl5++ij0XgnNq0gfK5juZLGWkzTiILP/SiritCHJ1blW7upY/TzVrSYJQmOrVgsojjnCO+/dla8GNSyyswWjuSZFbw1f65hVekzxfyAXd/zm462GlVvnfiy+DIN5MnZd5F4lR8w+7eyG5HfdKyW4Aae4Hzmjxfq6BQ6Bl2mo6TQwZP1UEddrJ5YPTOw9os0UKx61C6zQa5F3Q8+oT3WsRjXOnIsvqPtahq9IpzyAxbOduGwlshQxnGRjrdwRQ+uNjP4wuuymYKzwONivrb0Z3XIdZT7wjdOl+lAjGaWm7djHeXambLScG6mrDScnSmtX51ey3DSXHgIjsO5LPF84RglHuGwxLdV14YpdrAIu3AkvKhZoXrUrPTF8tUquBXcCOOhFX1R5LltjcpWcz3WsSryqXqJLnzneqxjMen5stPDwXs3PGw2eru+Yen92oZFNuzXNix9XNuwLDWcaliWfpxsWDBf37CsdZxrWJY6TjYsWK9dhlcazi3DKw1nl2HEq5fhdTjPNSxrHecalpWOt3DlZMOynCknm41R/qyOsw3LUsfJhmX0a2fKSsO5mbLScHamDLo6vZbhPNmwLEt07bNE74fkRXmltzgQpbc4EF17Az28acetE11/IkpvcSJ6vgFbND4rHS2Ou1vDRTxWZz2zVEulmzpqf3F0vzqAS1R8VZfr0XZ8AbA6FE0w45r42vtYy+qWqfVpS+sdL7UlzlbFln6sZR0X2MVlf9X0UsvyAMlnTt8l7ItVgFeqVU84Uuxb9lcJ44WORaXqGKtix121+01HW21cSuxbFp6sNAwflT7KRRowxnV/2PwqDXHajPuT4tNXGb1DONGPz5rz8oKpYS2R5TiOr3byssSMaMZov5E8r0L+u2McFhd6/QUCJ1NsZnG3p/4tGssuijwYfEG8X0zphZKxKlGl9yhR5fhiJ68uZbjzabNY7s7wx3iVKbGLY26HFSYvL5n4bjscytiOV0KAP51pkPJMk8N7pv+jItptxnGZir0VR8maYdUcQo69B+ya7Ves5xj3RAh42SpI0cOkwxVo2SQnd4Lgwja7ezUgbNc26gsNy03xKS+WGk55cXJjvtCwPGE95cVSwykvTp7yLjQsb1ROebHUcMqLk7c6LzX8zW9vP90/PftD11+i6un+9uPDnb398uPx0+7T7//95p/4H8p+e/r66e7zj6c70TT/Wpb/+Qv5wAoL/f3upvA7PgPuwlk/4jNfzEXeZnnLKyrW9vcvMex/",
      "is_unconstrained": true,
      "name": "_validate_emitter_and_update_value"
    },
    {
      "abi": {
        "error_types": {
          "14415304921900233953": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "9967937311635654895": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          }
        },
        "parameters": [
          {
            "name": "wormhole_address",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "chain_id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 16
            },
            "visibility": "private"
          },
          {
            "name": "owner",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "message_fee",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "consistency",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JwACBAEoAAABBIBLJwAABEsnAgYEBScCBwQAHwoABgAHAEYcAEdHAxwASUkGHABKSgItCEYBLQhHAi0ISAMtCEkELQhKBSUAAABgJQAAAJAnAgEESycCAgQAOw4AAgABLAAAQwAwZE5y4TGgKbhQRbaBgVhdKDPoSHm5cJFD4fWT8AAAACcARAQGJwBFBAMmJQAAFDAeAgAHAB4CAAgALQgBCQAAAQIBJwIKAAEtDgoJLQgBCgAAAQIBJwILAAYtDgsKLQgBDAAAAQIBJwINAAgtDg0MHgIADQAtCAEOJwIPBAMACAEPAScDDgQBACIOAg82DgANAA8AJwIPBAEAKg4PES0LERAnAhEEAgAqDhETLQsTEhwKEA4ABCoOEhMnAg4BASQCABAAAAE1JwISBAA8BhIBLQgBECcCEgQDAAgBEgEnAxAEAQAiEAISNg4ADQASAgAqEA8SLQsSDQAqEBEULQsUEhwKDRAABCoQEhQkAgANAAABgScCEAQAPAYQAScCDQQALQgBECcCEgQCAAgBEgEnAxAEAQAiEAISHzoADwANABIAKhAPFS0LFRIcChIVBBwKFRAALQgBEgAAAQIBJwIVAAItDhUSLQgBFQAAAQIBJwIWAAMtDhYVJwIWBAUtCAEXJwIYBAYACAEYAScDFwQBACIXAhgfOgAWAA8AGC0IARgAAAECAScCGQAAJwIaACwtCAEbJwIcBAcACAEcAScDGwQBACIbAhwtChwdLQ4aHQAiHQIdLQ4ZHQAiHQIdLQ4ZHQAiHQIdLQ4ZHQAiHQIdLQ4ZHQAiHQIdLQ4ZHS0OGxgtCg0GIwAAAm8MKgYWByQCAAcAABPaIwAAAoEtCxgHLQgBCCcCFwQEAAgBFwEnAwgEAQAiCAIXLQoXGC0OGRgAIhgCGC0OGRgAIhgCGC0OGRgrAgAXAAAAAAAAAAAGAAAAAAAAAAAtCAEYJwIaBAUACAEaAScDGAQBACIYAhotChobLQ4ZGwAiGwIbLQ4ZGwAiGwIbLQ4ZGwAiGwIbLQ4XGy0IARcAAAECAS0OCBctCAEIAAABAgEtDhgILQgBGAAAAQIBLQ4NGC0IARoAAAECAScCGwEALQ4bGi0KDQYjAAADSQwiBkQcJAIAHAAAEhYjAAADWy0LGgcKKgcbHCQCABwAAAN1JwIdBAA8Bh0BLQoNBiMAAAN+DCIGRQckAgAHAAARkCMAAAOQLQsXBy0LCBwtCxgdLQscHgAiHgIeLQ4eHC0IAR4nAh8EBQAIAR8BJwMeBAEAIhwCHycCIAQEACIeAiE/DwAfACEtDgcXLQ4eCC0OHRgtDg4aACoeDwgtCwgHLQsSCC0LFRctDggSLQ4XFScCCAANLQgBEicCFQQEAAgBFQEnAxIEAQAiEgIVLQoVFy0OCBcAIhcCFy0OEBcAIhcCFy0OBxctCAEHJwIIBAQACAEIAScDBwQBACIHAggtCggQLQ4ZEAAiEAIQLQ4ZEAAiEAIQLQ4ZECsCAAgAAAAAAAAAAAMAAAAAAAAAAC0IARAnAhUEBQAIARUBJwMQBAEAIhACFS0KFRctDhkXACIXAhctDhkXACIXAhctDhkXACIXAhctDggXLQgBCAAAAQIBLQ4HCC0IAQcAAAECAS0OEActCAEQAAABAgEtDg0QLQgBFQAAAQIBLQ4bFS0KDQYjAAAE8AwiBkUXJAIAFwAAD8wjAAAFAi0LFRIKKhIbFyQCABcAAAUcJwIYBAA8BhgBLQoNBiMAAAUlDCIGRRIkAgASAAAPRiMAAAU3LQsIBi0LBxItCxAXLQsSGAAiGAIYLQ4YEi0IARgnAhoEBQAIARoBJwMYBAEAIhICGicCHAQEACIYAh0/DwAaAB0tDgYILQ4YBy0OFxAtDg4VACoYDwctCwcGCioUBgckAgAHAAAFoyUAABRWCioTGQYeAgAHAQoiB0MIFgoIEBwKEBIABCoSBxAKKggbByQCAAcAAAXWJwISBAA8BhIBCioTEAcSKgYHCCQCAAgAAAXtJQAAFGgtCwkGLQgBBycCCAQEAAgBCAEnAwcEAQAiBwIILQoICS0OGQkAIgkCCS0OGQkAIgkCCS0OGQkrAgAIAAAAAAAAAAACAAAAAAAAAAAtCAEJJwIQBAUACAEQAScDCQQBACIJAhAtChASLQ4ZEgAiEgISLQ4ZEgAiEgISLQ4ZEgAiEgISLQ4IEi0IAQgAAAECAS0OBwgtCAEHAAABAgEtDgkHLQgBEAAAAQIBLQ4NEC0IARIAAAECAS0OGxIkAgAbAAAG+yMAAAa0LQgBEycCFAQEAAgBFAEnAxMEAQAiEwIULQoUFS0OCxUAIhUCFS0OGRUAIhUCFS0OGRUtDhMILQ4JBy0ODxAtDhsSIwAAB4ctCg0JIwAABwQMIglFEyQCABMAAA7AIwAABxYtCwgJLQsHEy0LEhQtCxMVACIVAhUtDhUTLQgBFScCFwQFAAgBFwEnAxUEAQAiEwIXJwIYBAQAIhUCGj8PABcAGi0CCQMnAAQEBCUAABR6LQgFEwAqEw8XLQ4LFy0OEwgtDhUHLQ4PEC0OFBIjAAAHhy0LCAktCwcLLQsSEwoqExsUJAIAFAAAB6knAhUEADwGFQEkAgAbAAAH5iMAAAe2LQIJAycABAQEJQAAFHotCAUTACoTERQtDgYULQ4TCC0OCwctDhEQLQ4bEiMAAAhyLQoNCSMAAAfvDCIJRQskAgALAAAOOiMAAAgBLQsICS0LBwstCxIRLQsLEwAiEwITLQ4TCy0IARMnAhQEBQAIARQBJwMTBAEAIgsCFCcCFQQEACITAhc/DwAUABctAgkDJwAEBAQlAAAUei0IBQsAKgsPFC0OBhQtDgsILQ4TBy0ODxAtDhESIwAACHItCxILCioLGxEkAgARAAAIjCcCEwQAPAYTAS0KDQkjAAAIlQwiCUULJAIACwAADbQjAAAIpy0LCAstCwcRLQsQEy0LERQAIhQCFC0OFBEtCAEUJwIVBAUACAEVAScDFAQBACIRAhUnAhcEBAAiFAIYPw8AFQAYLQ4LCC0OFActDhMQLQ4OEgAqFA8ILQsIBzQCAAccCgIHABwKBAIAHAoFBAAtCAEFJwIIBAUACAEIAScDBQQBACIFAggtCggLLQ4BCwAiCwILLQ4HCwAiCwILLQ4CCwAiCwILLQ4ECy0LBQgAIggCCC0OCAUtCAEIJwILBAQACAELAScDCAQBACIIAgstCgsQLQ4ZEAAiEAIQLQ4ZEAAiEAIQLQ4ZECsCAAsAAAAAAAAAAAQAAAAAAAAAAC0IARAnAhEEBQAIAREBJwMQBAEAIhACES0KERItDhkSACISAhItDhkSACISAhItDhkSACISAhItDgsSLQgBCwAAAQIBLQ4ICy0IAQgAAAECAS0OEAgtCAEQAAABAgEtDg0QLQgBEQAAAQIBLQ4bEScCEgQELQoNCSMAAAogDCoJEhMkAgATAAAL8CMAAAoyLQsRCQoqCRsSJAIAEgAACkwnAhMEADwGEwEtCg0FIwAAClUMIgVFCSQCAAkAAAtqIwAACmctCwsJLQsIEi0LEBMtCxIUACIUAhQtDhQSLQgBFCcCFQQFAAgBFQEnAxQEAQAiEgIVJwIXBAQAIhQCGD8PABUAGC0OCQstDhQILQ4TEC0ODhEAKhQPCS0LCQgtCAEJJwILBAYACAELAScDCQQBACIJAgstCgsOLQ4BDgAiDgIOLQ4HDgAiDgIOLQ4CDgAiDgIOLQ4EDgAiDgIOLQ4IDi0KDQUjAAALDgwqBRYBJAIAAQAACz4jAAALIC0LCgEwCgADAAEtCwwBMAoAGQABHgIAAQA0AgABJhwKBQEAACoGAQIAIgkCBAAqBAUHLQsHATAKAAEAAgAqBQ8BLQoBBSMAAAsOLQsLCS0LCBItCxATLQsRFAwqBRMVJAIAFQAAC4wjAAAL4gAiEgIXACoXBRgtCxgVACIJAhgAKhgFGi0LGhcAKhUXGC0CEgMnAAQEBSUAABR6LQgFFQAiFQIXACoXBRotDhgaLQ4JCy0OFQgtDhMQLQ4UESMAAAviACoFDwktCgkFIwAAClUAIgUCFAAqFAkVLQsVEy0LCxQtCwgVLQsQFy0LERgKKhgbGiQCABoAAAwkJwIcBAA8BhwBCiIXRRgkAgAYAAAMlCMAAAw2DCIXRRgkAgAYAAAMSCUAABTZLQIUAycABAQEJQAAFHotCAUYACIYAhoAKhoXHC0OExwAKhcPEw4qFxMUJAIAFAAADH8lAAAU6y0OGAstDhUILQ4TEC0OGxEjAAANIC0KDRQjAAAMnQwiFEUVJAIAFQAADS4jAAAMry0LCxQtCwgVLQsRFy0LFRgAIhgCGC0OGBUtCAEYJwIaBAUACAEaAScDGAQBACIVAhonAhwEBAAiGAIdPw8AGgAdLQIUAycABAQEJQAAFHotCAUVACoVDxotDhMaLQ4VCy0OGAgtDg8QLQ4XESMAAA0gACoJDxMtChMJIwAACiAtCwsVLQsIFy0LEBgtCxEaDCoUGBwkAgAcAAANUCMAAA2mACIXAh0AKh0UHi0LHhwAIhUCHgAqHhQfLQsfHQAqHB0eLQIXAycABAQFJQAAFHotCAUcACIcAh0AKh0UHy0OHh8tDhULLQ4cCC0OGBAtDhoRIwAADaYAKhQPFS0KFRQjAAAMnS0LCAstCwcRLQsQEy0LEhQMKgkTFSQCABUAAA3WIwAADiwAIhECFwAqFwkYLQsYFQAiCwIYACoYCRotCxoXACoVFxgtAhEDJwAEBAUlAAAUei0IBRUAIhUCFwAqFwkaLQ4YGi0OCwgtDhUHLQ4TEC0OFBIjAAAOLAAqCQ8LLQoLCSMAAAiVLQsICy0LBxEtCxATLQsSFAwqCRMVJAIAFQAADlwjAAAOsgAiEQIXACoXCRgtCxgVACILAhgAKhgJGi0LGhcAKhUXGC0CEQMnAAQEBSUAABR6LQgFFQAiFQIXACoXCRotDhgaLQ4LCC0OFQctDhMQLQ4UEiMAAA6yACoJDwstCgsJIwAAB+8tCwgTLQsHFC0LEBUtCxIXDCoJFRgkAgAYAAAO4iMAAA84ACIUAhoAKhoJHC0LHBgAIhMCHAAqHAkdLQsdGgAqGBocLQIUAycABAQFJQAAFHotCAUYACIYAhoAKhoJHS0OHB0tDhMILQ4YBy0OFRAtDhcSIwAADzgAKgkPEy0KEwkjAAAHBC0LCBItCwcXLQsQGC0LFRoMKgYYHCQCABwAAA9oIwAAD74AIhcCHQAqHQYeLQseHAAiEgIeACoeBh8tCx8dACocHR4tAhcDJwAEBAUlAAAUei0IBRwAIhwCHQAqHQYfLQ4eHy0OEggtDhwHLQ4YEC0OGhUjAAAPvgAqBg8SLQoSBiMAAAUlACISAhgAKhgGGi0LGhctCwgYLQsHGi0LEBwtCxUdCiodGx4kAgAeAAAQACcCHwQAPAYfAQoiHEUdJAIAHQAAEHAjAAAQEgwiHEUdJAIAHQAAECQlAAAU2S0CGAMnAAQEBCUAABR6LQgFHQAiHQIeACoeHB8tDhcfACocDxcOKhwXGCQCABgAABBbJQAAFOstDh0ILQ4aBy0OFxAtDhsVIwAAEPwtCg0YIwAAEHkMIhhFGiQCABoAABEKIwAAEIstCwgYLQsHGi0LFRwtCxodACIdAh0tDh0aLQgBHScCHgQFAAgBHgEnAx0EAQAiGgIeJwIfBAQAIh0CID8PAB4AIC0CGAMnAAQEBCUAABR6LQgFGgAqGg8eLQ4XHi0OGggtDh0HLQ4PEC0OHBUjAAAQ/AAqBg8XLQoXBiMAAATwLQsIGi0LBxwtCxAdLQsVHgwqGB0fJAIAHwAAESwjAAARggAiHAIgACogGCEtCyEfACIaAiEAKiEYIi0LIiAAKh8gIS0CHAMnAAQEBSUAABR6LQgFHwAiHwIgACogGCItDiEiLQ4aCC0OHwctDh0QLQ4eFSMAABGCACoYDxotChoYIwAAEHktCxcHLQsIHC0LGB0tCxoeDCoGHR8kAgAfAAARsiMAABIIACIcAiAAKiAGIS0LIR8AIgcCIQAqIQYiLQsiIAAqHyAhLQIcAycABAQFJQAAFHotCAUfACIfAiAAKiAGIi0OISItDgcXLQ4fCC0OHRgtDh4aIwAAEggAKgYPBy0KBwYjAAADfgAiBwIdACodBh4tCx4cLQsXHS0LCB4tCxgfLQsaIAoqIBshJAIAIQAAEkonAiIEADwGIgEKIh9FICQCACAAABK6IwAAElwMIh9FICQCACAAABJuJQAAFNktAh0DJwAEBAQlAAAUei0IBSAAIiACIQAqIR8iLQ4cIgAqHw8cDiofHB0kAgAdAAASpSUAABTrLQ4gFy0OHggtDhwYLQ4bGiMAABNGLQoNHSMAABLDDCIdRR4kAgAeAAATVCMAABLVLQsXHS0LCB4tCxofLQseIAAiIAIgLQ4gHi0IASAnAiEEBQAIASEBJwMgBAEAIh4CIScCIgQEACIgAiM/DwAhACMtAh0DJwAEBAQlAAAUei0IBR4AKh4PIS0OHCEtDh4XLQ4gCC0ODxgtDh8aIwAAE0YAKgYPHC0KHAYjAAADSS0LFx4tCwgfLQsYIC0LGiEMKh0gIiQCACIAABN2IwAAE8wAIh8CIwAqIx0kLQskIgAiHgIkACokHSUtCyUjACoiIyQtAh8DJwAEBAUlAAAUei0IBSIAIiICIwAqIx0lLQ4kJS0OHhctDiIILQ4gGC0OIRojAAATzAAqHQ8eLQoeHSMAABLDACoGDwcAIhcCGgAqGgYbLQsbCC0LGBoMIgdEGyQCABsAABQDJQAAFNktAhoDJwAEBAclAAAUei0IBRsAIhsCHAAqHAcdLQ4IHS0OGxgtCgcGIwAAAm8oAAAEBHhLDAAABAMkAAADAAAUVSoBAAEF2sX11rRKMm08BAIBJioBAAEFilU6LCtnyO88BAIBJioBAAEFyA1zc27NtOE8BAIBJi0BAwYKAAYCByQAAAcAABSQIwAAFJktAAMFIwAAFNgtAAEFAAABBAEAAAMECS0AAwotAAULCgAKCQwkAAAMAAAU0y0BCggtBAgLAAAKAgoAAAsCCyMAABSvJwEFBAEmKgEAAQXkCFBFArWMHzwEAgEmKgEAAQXQB+v0y8ZnkDwEAgEm",
      "custom_attributes": [
        "abi_public",
        "abi_initializer"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "constructor"
    },
    {
      "abi": {
        "error_types": {
          "10522114655416116165": {
            "error_kind": "string",
            "string": "Can't read a transient note with a zero contract address"
          },
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13060541637244024094": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8556029555939094797": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "wormhole_address",
                "type": {
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                }
              },
              {
                "name": "chain_id",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 16
                }
              },
              {
                "name": "message_fee",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "consistency",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 8
                }
              }
            ],
            "kind": "struct",
            "path": "types::config::Config"
          },
          "visibility": "public"
        }
      },
      "bytecode": "H4sIAAAAAAAA/+y9CbxdVXk2vk/uYA65ycnEPB0QBAIBwgxhuDFgDCQQQwhEhBhIhAACkoTJVuOAMoqAzIOXMsuogkNn21pb+9n5X7/61dr2az+1ra11qB2s/t1mv/c+9znPXnvtfd5zcyBn/3755dy91nretd71vu9617uGXUu2PM3s/9Wr11y/cd2Fqy+/avX6yzeuu+ryNZdtWL36onUbV194xeXvWH9R38/y1LK8/cn4h/9OIO+k7P8+kWdcwVqWuU+ANCMr+RfDW/JNJuK1DLeZRD21yUS/XPnNb5/MgKXKJz8vX0uq0t/SfuNnlfKD2f9vg/JYF8N93c/+NeD3AdnvoUB5SztP4Fna+VRvTFsNaSY/1t4BKtdMop63WfnBauX7Zwr6g1C39FkIBZpJ1DNgZU9WZX+w4atP/sFtn/6dpzc+9cQ9M7429f4pB2333htu+Ndd/2W3B757w2NW9hSoUy2Jpj1o5d+kaJ/42b63XvzJ/7piyqIPvHjN1/7y9E1Td1vzW3ve+MRbv3jHnt9e/SEru0iV/datD7638eKdI80Dv/LDwUW3//Pq7y8eOOZrX/mFnX/7/T/+9nfvsrJvVmX/9K0//vrLjbuuv/a2z7/7mP1nrXnurq/+2z9+6Q9eaHz/b59/11ePtLKLoc1V9P7UauWnW/nToHx/Uk5v02dJtfKj9V9arfwkK386vGzaj/c9/vTXF9z2lUP/74+3u3npmg9ee/gtf3b2d67f6al9/+GS53d7boaVPUOV/buNC+/YuOM7j/rO5D+6bd6ju+7+jR889fI3//26dcf88ze/9Zm9vm9ll6myBY+VfYsou9Nh+x175X1/PPuv9t/7/wz/5nMHf2znH+xz/F997s2Pfve/fv8/oOzy7P+S/T3KrzOrle+38iuqle+z8mdB+RI6PiovK6uVH6V/drXyo/w7B142w2VsGBntu1WQUHaMTJ+3Ctpzjq9/94mb33ND8jdP/dNH/n3Orw7PnbHHghkH//mDf7Hr5Vedu/N3rey51Wjvtl2yZbz84PCWF1N+9m+fLHHTxvWXrd943YING9ZdtXHhFe+8cs3G9Rdctu6Mq9ZceNm6leuu2rD+issZsEZ/L8x5n9LZaTydRes2nrXl18IrfuZSXbtxgHBr9Pck+pv9NfbpDG8gpxyXKXqGkvHjq2Go/xOiY4+1oZG0jvs1olNzpMP+HNJ5nQMd82PQ/2wmUU+tQfVAHMOtQ1oJPV9m5berVn6dlZ9SrfxVVn6oWvl3WPmp1cpfYeWnVSv/TivfqFZ+vZWfXq385VZ+RrXyF1n5mdXKN638rGrlN1j52dXKr7Hy21crv9bK71Ct/IVWfsdq5a+28jtVK3+d2aid4aXZH8PeBd6XGAt3j7FxiF+nupSkV6sRntHj9uGcNE3bVdSlIdLYRu4q6Owq6Cis7RyxpjhiDTliTe3SNk5zxGo4Yk13xJrhiDXTEcuT9546NKtLsWY7YnnKhCfvPeVre0csT932lIkdHLE8bfSOjljdOj6an2W+A/oatZz/jQ6/Mzp1wqol1fwe1a5dBL1Q/p0D+XeLxE/5bbqTxSJOXnfBpouWXHFRQg+HB07JqeJulG9VoGqMW6N/SaCssZ7z4pM2z1Qwa96b1m288OIVay66aN3anzVyA5dgpJNz3rNDinkmU21LCsmkGKFE/HrSKvxVhFIJjVK2lKs2EGRcXXLFmrUL11y5YdNl6zg0hVME5gqi4jvVpzWoGb7ro3wn09+LRblEYKMs7Q5pihOGOS1pbdPuOeVYZfndJJF/N8LaTZSzuvcFyiMGlmOJCUl1jFRaO9JHmWSjHTOVrag9s6tqT7tT2RCv04fDg7tXozcrJKOIafUxXu8h0gxrz+zvwRwsK9tP+Z/O/m9QvvRZRjT2EPXFd8afNET9GNWd7X76ePAR8axe+A7x60lbclkL9Ru2j+Vkj2r0ZsbwHetjvN5TpBlWM/t7MAfLyvZT/ley/xuUL31YTvYU9cV3KCcvUd2RtywnFfm4IFZODL+etCWXtVC/YftYTvasRm84hu9YH+N1U6QZ1l7Z34M5WFa2n/L/VvZ/g/KlD8tJU9QX36Gc/Fr2e3JOfbFc4LlM8bpE+WsmJ628K1F+o5Xfq1r5i6383tXKv9vKv75a+UOt/D7Vyv+iyd6+8JL1/A3wvsxycKyeG36d6lJVz99A9Lh9HALfT9SlIdI4BL6foLOfoKOwpjhiTXXE2sERaztHrFlditVwxJruiDXDEWumI9Yejliect+t/NrTEctTVpuOWHs5YnnyvumINdsRq1tldW9HrNc7YplvZOM9+ge17P/JolzZuSHiWT3xHeLXqS4l6dVCfMH28Zxm/2r0ZtSoPNJDTKuP8foAkWZYc7K/B3OwrGw/5Z+RMbRB+dKH5zQHiPriO5zTDGW400R9Ob5TVh6xPPMIy7E8ttNfiGf1xHeIX0/akv9aSD4UX6x9B1SjNz2mf7E+xus5Is2wDsz+HszBsrL9lH8vksc5UCeWxzmivvgO5dEmUENJK29ZTiry8ZRYOTH8etKWXNZC/YbtYzmZU43eyTF8x/oYrw8UaYZ1UPb3YA6Wle2n/AeTnBwIdWI5OVDUF9+hnByQ4U7OqW8ziXtYRwwDsZEv8f1Q+7dYOTP8etJWv9dCfFT6Zu07qBK92ndZNpAeYlp9jNdzRZphHZz9PZiDZWX7Kf/xJGdIg2XD0rC++A7l7GiyR8hblpNqfEzeGCsnhl9P2pHLMTlR/ab0zdo3txq9BTF8x/oYrw8WaYZ1SPb3YA6Wle2n/ItJTg6GOrE9OljUF9+hnJxM9gjrmz7NJOqpKV6XKN/CO8Qw7EPgfYl+/GmsnBp+PWntxypyegjRy+sHa/uhoi4NkYY8xjSkc6ig08PqYfWwelg9rB5WD+vVjXVQD+s1gbUtyFdPh3r92LMTPX18tWL15Ksnq9uirPb8iR6/em3s8f7VitWT1Z5MbIv86slXrx+3RayeDvVkYlvkfc+u9nSox68eVhFWb27Va2PPRvdk9dWK1ZOvXr16WD19nMg29rB6Nqc3DvXa2Gtjz+b0+NXrx558vXqxerGOXht7NqdnJ3pYPbnv6VCP9z0d6mF1s6z2/ImeTPR43+P9RGL1xqEev3o61MMqwup2mbB7YQ+BNP6eyyGCziEBOlje8g2JcrXs/8mifimdZhL1RN9bZvj1pLXNJejVQvxXfLG2zxN1aYg07ud5gs48QaeH1T7W3C7F6rXxtcGvbaFePazXhj727EQPqyerPXs/kfXq9WOvjT356o0dr9Z69WSix6+efPX6sYfV06GeTGybvO/Z1Z4O9fjVwyrC6s2tem3s2eierL5asXry1atXD6unjxPZxh5Wz+b0xqFeG3tt7NmcHr96/diTr1cvVi/W0Wtjz+b07EQPqyf3PR3q8b6nQz2sbpbVnj/Rk4ke73u8n0is3jjU41dPh3pYRVg9mehh9bB6WD2sHlYPq4f1Wseye8vwzrBDiE7Z+9GwvOVTd5Ol/5pJ1LNismhDifKrrfxh1cq/y8ofXq38tUNZ/iPgZS3737CPhPd98djzaoSXZOXxHeLXqS4l6Y3e23Yk0eP2mVxY248SdWmINJaRowSdowQdhbWXI9Z2jlgzHbF2cMTawxFrtiNWwxFrmiOWp0xs74g1zxFrliPWYY5YUxyxmo5Ynrq9tyPWXo5Ynvo43RGr6Yi1jyOWp0x48t5Ttz3b6CkTUx2xmo5YnvxqOmLt5YjVrT5Tb0zberz31MchRyzPNh7epfXy9Cc822hjrZoLoywXPJt4rmkYiH00vC8x7z2xRnhJoufZhl9PWttZZZ59NNHL46u1/RhRl4ZI43n2MYLOMYKOwtrLEWs7R6yZXdrGhiPWdEespiOWJ+/3dsTq9WM5rH0csTxlYntHrKmOWJ72a5YjlifvPWXVk/dNR6xulVVP+ZrmiOXZj57y5alDTUesKY5Ys7u0jd3qyzUdsfZyxOrWfuxWX+5wR6xu9XM8fcyeP/Ha0CFPO+FZL0/5OswR60hHLE/ee/oANtZaHOgwKFfL/m8zBrZXjfCsnvgO8etJa196xcCwfcYXa98x1eg1Y/oB62O8PlakGdZx2d+DOVhWtp/yLx7c8n9D0DiAaFga1hffGX8Gfvbv5Ax3mqgv65zi+9ECtyHKM4+wHMtjxf7qi5VHw68nbcl/LSQfii9KPqys6lfmf2y/hrA4Lmzp6TNZlCvBj0Ys/w2/nrTV37UQX5SdtPYdV43eNNZhpIeYVh/j9XyRZljHZ38P5mBZ2X7KfwHZg/lQp2VEY76oL75De3De4Pi6I29ZTirysT9WTgy/nrQll7VQvyn9Uf1mZT35PVFY3F/p00yCT5/9YF5Y3RD3eHjfl0T3y0CsHBh+PWntlxL0aqxzRi+Pp9b2E0RdGpSWPtx3Jwg6Jwg6rxYslKGhpFWmnORiRlW5qGiPgnKB7eNx5IRq9KbH9APWx3h9okgzrJOyvwdzsKxsP+W/kcYRpMF+paVhffEdjiMfIL8S63sc4Sq+Hy9wG6K85Xut0RkS5Vi/KspftN01/HrSlj7XQvKu+KLk3coqOWX+x8rpqxHL5O+EAJ2y9h3LnzDBdJQsp/+aSdSz2MqfWK38cVb+pGrll1r54WrlT7HyC6qVP9PKv7Fa+QVWfmG18ous/MnVyp9j5U+pVv50K/+mauVPtvKLqpVfYrbqzfCS7fRieF/Cbp4ea6cNv051qWqnFxM9bh/b6VNFXRoijXX8VEHnVEFHYU13xNrREWu2I9YejlgNR6ztHbFmOmJNc8TazhFrVpdiecrqDEcsT96f6IjlKaue+th0xOpWfTzSEctTh5qOWJ6838sRy9NOeI61nnbCk/ee/Go6Ynm20dM38exHT95vC3Zib0eskxyxhh2xFnQp1hsdsRY6Yg07Ys3r0nqd7IhVd8TylIlTHLHe5Ig13KX18pTVbrWFhzpiecqqZz961qtb+eUpq4scsYYdsTzt1z6OWJ7+15AjlmdMYTtHLM+5gmfs0fx7i2Nj3LuW/T9ZlCsRU59WIzyrJ75D/DrVpSS9Wogv2D7ey3BaNXpTa1Qe6SGm1cd4vUSkGdbS7O/BHCwr20/5z33dlv8blC99eA/MElFffId7GVZmuJNz6ttMop43KV6XKH8Q884wsG5L4X2JfjwoVk4Nv5609mMVOV1K9PL6wdp+uqhLQ6RxH50u6Jwu6CisqY5YRzpiTXfE2t4Ra6YjVsMRy5NfOzpizXbE2sMRy5P33Spf0xyxtnPEmtWlWJ6yOsMRy5P3nvI15Ig1xRHLc0zz1CFP3jcdsQ7v0jbu7Yj1ekesfRyxTnPE6lbfxNMWevo5nnbC0351q19o/TgtaZVd3j8bmjMrOlje8rU5p7zS5lU4D6sRNravxBxvtxrhJYmeUxp+nepSkl4t1H/YPp5TniHq0hBpvM5zhqBzhqCjsKY4Yk11xNrBEWs7R6xZXYrVcMSa7og1wxFrpiPWaY5Ynjrk2Y87OmLNdsRqOmJ56ranfHnqkKddbTpidSvvpzliedpo9snQn9mF6JT1/bC85VN+E8pAwbN8smhDifIrrfyyauXPsPJvqVZ+oflVy+FlLfvfsM+E9yV8vPfVCC9JtE9p+HWqS0l6oz7lmUSP28c+5QpRl4ZI4zMxKwSdFYKOwpruiLWjI9ZsR6w9HLEajljbO2LNdMQ6zRFriiOWJ++7VVabjljbOWJ5ypenzZnqiNV0xOpW3k/r0jbO6lIsT92e4YjlyfsTHbE8ZbVbfQBPrN64XQ6rN25vPfnqjdtbj/e9cXvr6Xa3jtue/OpWWT3SEcuTX01HLE/e7+WI5alDnuN2t9robvUnPNvo6ft69qMn77cFO7G3I1bdEet0RyzPOPkZjlhvdMQ61BFr2BFrniPWKY5YyxyxtgXen+SItcARa6Ejlie/3uKI5SmrnjrUrXLfrW3cFmyhZ716Y8drY+w41RHL05cbdsRa5Ij1JkesBY5YnjLhya9hRyxPO7GPI5bnnG/IEctzTcczDuAZn/Dcn8P3RuDesFr2/2RRLqXTTKKeKTXCs3riO8SvU11K0quF+ILtM75Y288SdWlQWvrweHuWoHOWoNPD6mFtLSzbL4w6zGe4ytoRLG/5hkQ5tiOoZyX0ep9YO2L49aQtu1UL8V/xxdq+UtSlIdI4PrlS0Fkp6CisKY5YUx2xdnDE2s4Ra1aXYjUcsaY7Ys1wxJrpiHWaI9ZsRyxPfWw6YnnKlye/9nDE8pQvTx3ytKtNRyxPu9qtuu2pj546tKMjlqc+Nh2xulW+pjliefoAfMYP/WU+41d2boDlLd+QKFfL/p8s6lfCh76jRnhWT3yH+PWktc1VfHbFf8UXa/vZoi4Nkcbx3rMFnbMFHYU13RFrR0es2Y5YezhiNRyxtnfEmumIdZoj1hRHLE/ed6usNh2xtnPE8pQvT5sz1RGr6YjVrbyf1qVtnNWlWJ66PcMRy5P3Jzpiecpqt/oAnljdOm578t7TB2g6Ynn6E90qq71xe+vZ1Z5PXg5rR0esnk9eDqvnF249+epWv9CTX90qq0c6Ynnyq+mI5cn7vRyxPHVoR0esbrXR3TqmebbR0/f17EdP3m8LdmJvR6y6I9YbHbFOd8Q61BHLc33Ik1+LHLHmOWKd4oi1zBHLUyaGHbE8ee+p25766KlDZzhieerjtiBfJzliLXDEWuiI5cmvtzhiedpCTxvdrXLfrW3cFsZaz3r1fJPXxthxqiOWpz8x7Ijl6ZO/yRFrgSOWp0x48mvYEcvTTuzjiOUZUxhyxPJct/KMM3nGvzz3F/IZXdzbWsv+nyzKpXSaSdSzXY3wrJ74DvHrVJeS9Gohvqh90tb2c0RdGpSWPjzeniPonCPo9LB6WGWwbI8+6t2xRKes7mP5swN05rdJZ76gMyTKsY1BHSyh81+ItTGGX0/asmm1UD8rvlj7VlWj95s1Ko/0EPMcovfWavT6rK/eJrCtLudlfw/m1MXK9lP+38oGVqNxrijToLT0YR3DtD7xbtJWwnqbwEI+Wp8M/Ozf5zJeKPlP/zWTqGeekq8S5Q8boroZBtYN+6mELJ0dq5uGX0/akt1aqE+xfTz+v03UpSHS3gi/i/ob6SisZpdibeeINc0R6zRHrKYjVsMRa7oj1gxHrJld2sapXVqvHRyxPPXRsx+3d8Ty1KFZjlie/egpqzs6YnnK1xRHrJ0csTzlvlttjmcb93bEer0j1j6OWJ788vRNPOWr6YjlaSc85b7piOU5Ds12xNrDEWtb8OWajliecu/pm/TGtHJY3erLdast9PTlPG2hZz82HbG61f86xxGrW/2vIUcsT9321CFPfnmOQ01HrG7lvaf98ozLdWtsyFO+PH3fbvUxu3XsWOWIZWPHEGFbevq0ud60e43wrJ74DvHrSWs7vdabsH1V15v4LEW32ENPPerWWLmnDfPE6q03lcPyjM156pBnP3quB3j6Ok1HrG71dTzr1a3rOt0ao/DsR8+9Cp72nu/tRd+I7+0tu5cJy1u+IVGulv0/WdSvhL90Q43wrJ74DvHrSWubq/hniv+KL9b280RdGiKNz4CcJ+icJ+gorOmOWDs6Ys12xNrDEavhiLW9I9ZMR6zTHLGmOGJ58r5bZbXpiLWdI5anfHnWy7MfPevlaVebjlie/TjNEcuT97O6FMvTTsxwxPLk/YmOWJ6y2q3+hCdWzwfYemNHzwfYevXq+QBbrx97PsDWsxPd6gN48qtbZfVIRyxPfjUdsTx5v5cjlqcOdevY0a2+b9MRy7ONnn60Zz968n5bsBN7O2LVHbFOd8Q6wRHrDEesNzpiHeqINeyINa9L6+XZj8OOWKc4YnnKhGc/nuSItcARa6Ejlie/3uKItcwRq1tlddgRa1vQR882dqt89cahntwz1qmOWCc4Yg07Yi1yxHqTI9YCRyxPmfDk17Ajlqc+7uOI5TkXHXLE8ly38oxPeMZNPPczWazD9h+izeY7CQ8VdA4N0MHylm+yKNdMop75tn/vBHhZI1xcF++Lx+6vEV6Slcd3iF+nupSkN7p38USix+0znlrbTxJ1aYg0HntPEnROEnQaIm1ZB7Am59SzmUQ9Z6n+LlH+UuanYWDdFsD7En27U6wsGX49ae2/KrK0gOjl9Yu1faGoS0OkcR8tFHQWCjoKa7oj1oldWq+pjlh7OmJ5tnGmI9Y0R6xZjlgzHLE8+dV0xNrJEes0R6ztHLE8ed9wxNq+S9u4tyPW6x2x+Iwx+pC17P/2xu7a39QIz+qJ7xC/TnUpRy88divf2tq3sBK92jdi+gHrY7xeJNIMy9bsBnOwrGw/5Z+VDZQNQeMAomFpWF98Z/xJ716eluFOE/XlOY3i+wKBq+Y0lk/Rmd8mnfmCzpAox3JfTS6Sg2Ll3vDrSTt6Nib3Sg4VX5QcWlklPxzji5UfhTXVEetIR6zpjljbO2LNdMTa0RFrtiPWHo5YDUesbu1HT1n11EfPeu3giLWdI9YsRyxPmRhyxPKUiSmOWJ788rRfnvVqOmJ59mPTEatbxw7PfvTkvadue7Zxb0es1zti7eOItS2M201HrE6MtRxjt/T0mSzKdWKuZvh1qktJerUQX1Tsxtp+uqhLQ6Tx/oLTBZ3TBR2F1XDEmuWItYMj1lRHrB0dsbZzxJrSpfXa3hFrpiPW3o5Yr3fE2scRy5Nf0x2xPPWx6YjlKfeettCzH4ccsTxtjqdMTHPE8uT97C6t12mOWJ4y4embeI7bnv3YdMTytF+e8uWpj91qoz2xPOVrhiOW8X5a9jfOxw4jOmXnhFh+UYDOMW3SOUbQUfNL1M2C52+t/OnVyo9Y+TOqlT/Ayi+rVv5z6h7LEuU/Y+XPq1b+fVb+/Grlz7Pyq6uV39/Kv71a+cOt/Jpq5b9l5S+oVv7NVv7CauU/b+XXVit/h5VfV638D638O6qVv8vKX1St/Het/HooXyLe07Tyl1Yr32f1vQRfijoZvsWLLob8tZz/DYvTjFadsErWvRaqO9aP7fAlQA/bmId1SUmsySKtSp+sT/LbhfhDgbqoenLMoJ02b++IdYoj1hRHrEWOWOc4Yp3uiHWGI9YyR6y6I9awI9bbHLHO61Kskx2xznfEWu2I9XZHrDWOWBc4Yu3kiHWhI9ZpjlhrHbHe4ojlOXasc8R6hyPWRY5YB3QhVvqclf1vcQEcl84kOnVBpx6gg+Ut35AoV8v+N/8S7XMJ/3JqjfCsnvgO8etJa5ur+OknE708vrS55j5Uo/JIDzGtPmoNnMc+848Gc7CsbD/lX5AFIDmmlT7sJ8XGx9J988dnuJNz6ttMop4LeK+2YSA28qVEP1wYK2eGX0/a6vdaiI8qLmdtP0PUpSHShuE3piGdMwQdhXW4I9ZpjljbOWLt4IjVdMTybOP2jlgzHbE8ZWK2I5anTJzoiLUtyMR0R6ypjlhNRyzPfvTkvSe/hrq0jXs4Ynn2o6fcz3DEajpi7eWI5SkTeztiecpEz/96bdhoz7F2niPWtmAL93HE8rQ5JztiHemI1XTE8uSX55jWrX5ht45p3Tq3ajpieeqQJ788bXRv7HhtjB2ecytPWzjFEasXU9h6OuTJ+6Yj1k6OWN06H/LkfcMRq1vjhZ5+Ts9OlMPy9Ceajljbgp3w5H3DEcvTTvD9fHi3cS3739Z/h+F9ifXYgRrhWT3xHeLXqS4l6Y2u/w4TPW4fr/+eLurSEGmT4TemIZ2Y8yzpU3Xtf6KwjDfDkMZyUXFfwFCsXPC+gOFq9IL7AobhHe8/OaMavSkx+on1MV4vE2mGZftNB3OwrGw/5d83M0ANypckrXKzTNQX3+H+k2ZjfN2RtywnFfk4P1ZODL+etCWXtVC/Kf1R/WZlGyLtVPhdht8Ka7YjVsMRaw9HrO0csbZ3xJrpiNV0xJrapW3coUvbOM0R6zRHrCMdsZqOWJ766ClfnrbQs17THbE85b7piNWtMrGXI5anfM3q0jZ68n7IEctT7qc4YvXsxGvDTjQdsXZyxPL0J7qV93s7YvV0qBzWvC5t47agQ56895y7e86RLb48TbSZv+sxT9CZF6CD5ecF6Mxvk878SDqdaM9kUa6ZBJ9++8HnmgwbcbGvOhHTN/w61aUkvVpIFtVah7X9baIuDUpLkvF84LQ+8W7SqwyrSHYXE52ysrs4kk5P57unPZMTPQ41k6jn+jbv/JrLOmoYWDe8x6KEvVgSa58Mv5606ksV+6S+66v009p+vqhLQ6TxnTjnCzrnCzoKa6ojVtMRaztHrJmOWHs5Ys12xJrliOXJL882etZrniOWp6xOccTy1G1P3k93xOrZr5796mQbPXm/gyOWp9wf6YjlqdtNR6xutdHdOtZ69uP2jljbwji0LbTRs16edrVbx+1lXVovT34d7ojVcMTy9E2ajlievO/p49ZrY7eO29vCPM1TJk52xOpWuT/NEatbYx07OmJ1wkarNYETiU7ZNQEs3w1rHGe0SeeMLmtPbw2q1570d71NOvVIOj056J72VNi3Yc8RtjZ4OLysES6uB5ZYp5xWI7wk0euihl+nupSkN7ouegrR4/bxuuh5oi4NkcZrOmr99TxBpyHSlvWwelg9LBesLt4fZ9OGUVuDtontbMX9J9H743j/SUW7Htx/gu1jO3u+qAvPQ9LHKxbZrVjbuC8y6Y9mnb9p8PHzLpy739RT/m2nmR/7wEm/c9v7T9rvIB6PDRtxkYclZLY/VkcMv560pZO1kIwo+2ZtXy3q0hBpfC/EakFntaCjsOY5Ys3NfvfmDK9iPf3Bhq8++Qe3ffp3nt741BP3zPja1PunHLTde2+44V93/ZfdHvjuDY+3qYtnq++Xlig/S32/tET5mer7pSXKz1DfLy1R/mT1/dIS5Reo75fGl68l/P3SJCnf9ndUop0Mq2+Xlii/Z5vfLv1Je9/JrH23zW+f/o+VvwxeNu3HiZ/te+vFn/yvK6Ys+sCL13ztL0/fNHW3Nb+1541PvPWLd+z57dUftrLvrEZ7wMpfXq38dlb+imrl61b+ymrld7Xy74KXzaiiySQrexXQnhRffrKV31Ct/FFWfmO18kdb+U3wspn9v89f/PLrfvSJ2/s/9b+/e8U1P5xz15cX3fbrzx5/51fmnrj5zP97z78stbJXA+0SfJ9q5a+pVn6alb+2WvnR7w1fV638aN9dX6l87RtW/t2VyidDVv4X4GUzqmjSZ2V/sXzZfiv7HlX2W7c++N7Gi3eONA/8yg8HF93+z6u/v3jgmK995Rd2/u33//jb3/2YlX2vKht8xsaXzarsn771x19/uXHX9dfe9vl3H7P/rDXP3fXVf/vHL/3BC43v/+3z7/rqqJ68bxStFK+nWPn3Vys/28p/oFr5QSv/wWrlX2flb4CXzaiiScPKfkiUnTUv+eqe3zjyugN3OOqKM67+4DdWPP+e2Y8d8M3GTv+y6fir//OvrrCyHxZlC54j07u5BmZs+cP8V/NB09+7wu/0nx0aTMvZHGwV5LGy/ZT/X98wVq6e0RuiMoaRPpOpfMm+2LlGeEmi54yGX09a215lzthP9Lh9PGccEHVpiLS94TemIZ0BQUdh7eOINdMR6zRHrO0csaY7Ym3viNXo0jbOcMTqVvma7Yg1xRGr6YjlKV+e/NrDEctTvjx1aKojVtMRy9Ou2t7ZIVGulv1vfsDO8L7EuDypRnhWT3yH+HVRzyp+wM5EL48vqe6bDG7auP6y9RuvW3LFmrUL11y5YdNl69gzQm+IuYKo+K6WjG89pvXRuz7K9yb6e7EolwjsPqC7C6QpThimeZ/Ypl1yyiEvEvFuksi/M2HtLMpZ3fsC5dNnSNRha0tsRU85KLHYPvZcdxF1aYg05GGexVAectl6TUnGRqxMk05ed8Gmi5ZccVFCD4vOKTlV3InyLc6pWk3g1ugfv9+J3vUlYVUNTZZiRCZJWo0xYq0iOj1j3DPGrw5j3CfKscRME+/PhN95hinkypwp6Ck6K9uks1LQmSzKNe3H+x5/+usLbvvKof/3x9vdvHTNB689/JY/O/s71+/01L7/cMnzuz03My1zGYV8kP9sgK3fB5Jwf/VT/vkQ8rkyo5dqmG2hzzTsjZsuu3T5uo1XrV939bqf2eoNCT1FanE6/X2GKKeemDG8ouGJNnSG7zWGK9HKGyvjDR0LBHIFUfFdLalu6M6gv6sYuiKvgQ1dyDhhr0wSdO3dpCTfECkjxrHGkCFLn97QvOUpL7Hb8tAcI7GxQ3OexOYNzVxuIMmX8H7Ke1s2ZLQp2eOikVzH3hiw5emNAa+WMaBPlGOJCUl1jFQmSasTqto/OWnlR9N+/N3GhXds3PGdR31n8h/dNu/RXXf/xg+eevmb/37dumP++Zvf+sxeP2hTu1a2aRXOSuk+Sk4wRi14cmfroOYEpw+ue1rZfsr/3zPGyj0BTvC+WXqmeSvXXLZ+7ZqN6065/F2b1m1at/b0Kzau27Dg8rWnXL3u8o2lXeJF9PebRTn1TCO89PcgpTFjMA2F63XZ7xinZZDa0kyinujN84bv5bQMEj1uX8DEnrnxiqvWXLRu+bo1a9lMGipyGNPx6af/LZ+KQOHfLAFnChx+WCLQxDC++j9J4kyMGhSHktZ6t0sHsTjq1QFHIFpKt5YjYG0fFHVpJK0Sz0cplDYMCjqvRqyQ9aoqfypupqK7Jptp/i/NGCuD5TAmg2VRrzH/38Jw9GUa/pQs2vs+aiPrPrtS7NaouudhLScsLN9P5QZy6ExK4l0phW8YIV3COq+gOofcv8EcegM57VJynBfrHEjC8o91PpPqrGiqOivZYPkJjZCcN/03JN6zfVIyxeOD0inFq+2SOI9mUNC0fObhYL9hu1kHLf//y/Qu/fvm4fGYk6F8yGZb/rrIj8eL2Ht7HaTxdQOKNrZncQ7twUTLyWRqv+X/DrT/tuEtv5UPwNvh+gR2SN+GoC2MiXVLktJj7EBa948Oj9FhXrGsF/G2bL/ymIJ9+TpKU3odssU4jlifKx3EMYjHp0Mhn+HuInAtvx1lMlniPDy9svw/BVl6fDgZ127s20OpHXh0ymTO/LzDqO7NJOqJDvgYfp3qUpLeqJ93GNHj9lUL+OBkmLmCqPgONZjTJiLgcwSkKU6wl4JtOiKnHEsuv5sk8h9GWIeJclb3vkB5xMByLDGsRTgiHSposxZNz8Qi1aKnhvPpHpokLXxgTZok6JnWHUF508e07ihqUzOJes6O1TrDr1NdqmrdUUSP21dN61BSkMpKQrU8mBeflVAzzM9/c+8NiHL8GE4/1fmArJkpxi7Zb6Vpb6B6K2nHdzzWYXnLp+js3iad3QUdk2Q8FjGX0vYNpO0HaW+gtP2hLhyXOADSeG46J2lts6UdHMA8RGCmffd7M8fw0n8LIZ+SdLaqJ0F9sCz+PSDysr9oeY8HuTqY5Aq1mOXqiIJ6h+TqiCSfzu5t0tld0LE+Qfll2TlKtNXSjgZ63M/HQBrLznGiXZZ2fADzBIGZ9s9vzByfj/s/fczivxnelwn9x1p8w69TXapa/DcTPW4fL4ssrkbvrBqVR3qIafUxXi8RaYa1NPt7MAfLyvZT/sVZfzYoX/pwvG2JqC++w0Xgk0lOkLe1nP8Nl9+xfmHbrX+MzklQDuNrp+fYPPSk0FbZshPbqv1hz9NbyFZhee47pSdV279QtHFa0sqb3eB3nny/OUBnt0B7OtWfuxEdtLPYn+dRfy6GNLbR6e+3Z7/7Kf8M6M+3U38qXVR85nGpLJ/fIOh0ms88vixxpINYuISa/ltOWMznt2e/jc9LIW05lVsBaZgPZ13L4f0KQVvhG0aRDL5rpm5bngwarX7K/+/7jpXbWFEGl1AajhU4LmI9kA+Y/+2JbtdgTv68dr0bZp0WB+SxBHmFfcH21/K/BzA5tqpkC8cDjsEpeVgu2qV4uiIppo18XpxDezAJy2I/5b9B8JTHBSyv9OhAqsvSgrqzfmN5yzckyrVrR1Sdi3TyIyV18sLsN8vuN0An7yCdDMkI1pnnEWX5vLug02k+8xxhhSMdxOJxYRVhMZ+tn4zPZ0HaKip3LqRhPhwXkP65grbCjx0XfmmmblueDBqtfsr/OyCDTwTmxSEZ5HVL5CmPC0X28ELKb/UeTMLjbT/lfy4wLih9RVvL44LlfzEwLhhdbFdoXFCyeJZol+Ipy/VJAgv5zOOC4im2/yRqv+X/TOS4YOVVPOIgSsN4BK8THQ1p7LMeA2lLKA3jERwbOR7S2N6dAGkoIxyP2DXQHozbcbwP43ZHUdr+kHY0pR0AacdQGsbtjqO0gyHteEo7BNJOgLZa3I63IP5B9r7N9S25kTovLsr58P8kiRsPdqV6Ip3DHOkg1puIzhGOdHjFAekcLehYfx1D5ZpJ1BO9Hmn49aRVd6vEyY4hety+aisjaG2YK4iK72rJ+NZjWmhlJH081iOPgzTFCY6cY5uOyymHvEjEu0ki/zGEdYwoZ3XvC5RHDCzHElOj93nrkYbRT/n/HkarTwyP5c+jhfzgEdPqnrezgOtg+b8FdXh8WGP257Tr6BzM/4aVjH+aqTETganadRy1i+twDNXB8v+r8AT6KA/XR71L/0bP6Lic+ql+4rriKJfXHu4ny//DQD8dJeqAOrm4oA6c57icOvynqIOwbguvuPK6zLol9PC+Y7ZOzHletz1K4OQ9hp9KoUmkirUdLcrxOIUSYGXTltt1P6MXMVy2buO6nLZPEnVTNPnYjT0xY+gSwm8mUU/0GGr4XmOoWktRYyjP97Gsmr+zxC+OpJP2qV3XAycZ8ro0dnCtiWolSf4gW0vGdwWWGUpam7S1xaDiEmBQDLB91VwpFE7mCqLiuxDni3rb43SsCo4tFpgqGLs0p1yRkZsk8i8hrCWinNU9tNCKGFiOJYY1JM+VYpfD8u+YaS1u7eIy9vdl8Ju3bqkFINMqXlxpJlHPjFitMvx60pYW10KypBaqy2kVm1ajMp1QLQ/mxWc61Azz5w2L9pwqyvFjOCwlczMpSaWrmf2elrRKJ19lgnUIDR/qKhMOleCmxrytL+nDW1hitreotOMDaScE0nAZfyWlLYRyvGXmzQIz5femWePzqfErRlPSh0OVatkJJZ2tZt5yZ/pvRQEWLympUK9hnVWAxSFULH8WYa0qwOJjLnmh+/TfuQGs9Pc7CUstE5isLw6UwyWIMyPqgO9C1xBZviFRrqosNQJ1Dm0/S2X7jbPGyqT/zoc0Nfpdnv3up/zPw1LHKWSf8EsmVkfFZ7ZdZfm8UtDpNJ/Zvqx2pINYrAdrCYv5bP1kfL4A0tZSuXWQhvnQQ1oL79cJ2grfMIpkcOUs3bY8GTRa/ZT/TpDBVYExMiSDqykNecr+g/qSk+qDGtV7MCf/amqX5X87eIi83Kb0Fet1KmFa/gsBk5fbLkha26W8r5AsXiDapXi6lrCU943t4T5QPMUvH/G2Sct/ieCpGhd4+Qt9oIMoDYNZvPyFAd3llIaBOBtH1ZLaWZSGS2rsy6APxH7cQkhjO4lbklC2zAfigynXZu8nJ616VsLzl0tXhqW+2oXLfZiWJGNyEPpqF5YPfR1sTpt05gg6Q6KctbtNPkbHQQzf64ibmmcovrAPjWWV/nFQ2ZaA/wfmQx8m/xwPgzFfecmymUQ9R8Xy1fDrVJeqfN2V6HH7mK/7iro0RNqp8BvTkM6+go7CmuqIdaQj1nRHrO0dsWZ2aRs9+9GzjTs4Ynm2cZoj1mmOWHs4Ym3niNV0xGo4YnnKhKc+euqQp0x48muGI9YsRyxP3g85Ynnyfoojlie/PG3hbEcsT341HbE8baEnvzxtzrbgMzUdsTzHbU/e7+mI5Sn3TUesvRyxPHnfdMTytBOePoAnv/Z2xNon+20xJoxDzCM6as6/a4AOlt81AkvFD0JtzLuqyOlbPlbFIynf4pyq1QRujf7x+yPpXZ/Ii9gDydjlwx3ctnRYjfCSpLu2LZXdvfYW+I1pSCd0Yg6xpjpiTXPEOs0Raw9HrO0csZqOWA1HLE+ZmO6INdMRy1MmPPk1wxHLk19Djlie/DrSEctTVrd3xNoW+nGKI5YnvzzHodmOWJ78ajpieY5DnvzytPee8uVpczz1semI5ekzefJ+T0csT7lvOmLt5YjlyfumI5annehW/2tvRywOk+C8msMksbfZqTDJkggsNR8OtbHDYRKr4jzKl3eqoSZwa/SP3/OOpKIwCe/KeWcm75OTVpaXCFPI3WC8SwvDQbjbDdOSJC5Sh+X3DdDZr006+wk6Q6KctbtNPk5B/mE98R3i15PWNlcJL6ldcoovajeYleXdYOnDF1qGLuBEOj2sHtbWwgrt9ozRT0UH7UGMHalKB7H4olLUWba/ZfmG5fMOQA8AFu6sX0j5cce3wpwL6Zj//mzsSneEPz+85XfRyYUHZxfX9WhRVz7dt3HfsXKPZJiKz2wb54k2ct8hXYXJY1rZvttP1CGEhf21P+W3vhjMyW943HdPQ9/dNjwe08rnyc/inDqg/GAd8uTnuQry88Ls4rqi/OxPtC3/SpCfT5L8YPmQ/PAubJQfPoWIabxDvqxPhOVDvhdf+K7qXqM0rENol77ikaJzdpt0zhZ0Oj0+nE10FjrSQSweH3CK9Vb4jWlGh98xHSwfuih3Tpt05gg6fYLOwYDBS6SWJ33Mf+eLiZtJ1NMf0y+IX6e6lKQ36r8XXYbL/vsKUZeGSONptzqxvELQUVj7OmLx1UhKbt4qsMryqwPhgJWUL+9e4z6BW6N//H4lvcsLBxi2Usm8q0ySJE4lsfxEq76ic2ybdI6NpDO/TTrzI+ksapPOokg6J7ZJ58RIOqe3Sef0SDqvNTmYqPac0SadM7qsPa+1/pmo9rytTTpvi6QzUXanpz/V2tPTn1570t/1NunUI+n05KC723N4m3QOj6QzUXw7pU06p3RZeyZKDs5rk855kXR69qB72jOU/a2+s5qGts/cXtPEcDkuKViYjkP1jZ3Gyq3cfnwbMay0IBlPr2xoG8uHQtsccsY2LKS0gwVmjdKwfgcH6oflD84px/1hfXQIvKtl/7e5XSH68hrernBINXrB7QrYPg53niDq0hBpyMM8OgsEnRphFdXLMaxoVTyQ8i3OqVpN4NboH78/kN4V7TIy0cduZtFHtoRYpUT/kAmmw1j4kQJl+vop/7wdt/yfmq+rMvNlohm6Uwr7rISaHB6rlobvdaeUEv/QnVILRV0aIu1N8BvTkM5CQUdhNRyxZjli7eCINdURa0dHrO0csaZ0ab22d8Sa6Yi1tyPW6x2x9nHE8uTXdEcsT31sOmJ5yr2nLfTsxyFHLM9+9LRfnvw6zRFrtiOWJ7+ajlie/oQnv/ZwxOrZ1a1nVz15v6cjlqfcNx2x9nLE8uR90xHL007McMTqVn/1HEcsPvCGc3SOPaj58AkBOlje8g2JcrXs/8mifimdZhL19NUIz+qJ7xC/nrS2uQS9Woj/ii/W9iWiLg2RxuG7siFuxOKPo6pQrYpt1Kh8URsdQ4FWxcMo3/Kcqk0SuDX6x+/5K8F9Ii9iqyj4STn1TpK4KDiWPzhA5+g26RwdSWe/NunsF0lnTpt05kTSCW3cZxNXdkN9aBUF6Qy3SWdY0OkTdPDAi1opwdUsi9FZnY6AtD4qm/7mwx+Wf/4OUC77rVaZ7J41dQUdfyUcw9A8PBwA70uY6+jVHcOvU12qDg8HED1uH5rO+I/JsZYiVxAV39WSVstWg5rhOz7GtyuVq/KJxjmQpjjBx3ywTXNyyiEvEvFuksh/AGEdIMpZ3fsC5REDy7HE1Og9atihgnY/5d8+0yr1tWtFC/nBC2dW97wvGHMdLP/OUAf+ivIBUEa1i7V5Dv2NlmByDv2DwcrsvoOmnwj63D4cHfK+JH0A1cHy7wU8uG14PL2DRfkk5x3yAMvm/Y15d6G28Ac+WBb5K9qHFLSd+9/y7x/o//1EHfCSz8UFdeA8u+TU4SBRh/a+os1WjnuJe2I/gZP3GDdSiTXpZe6wdjAd+1tJQLtf0d43h+akRD9Dia5b+kxO2horo8dmw68nWvKaSdRTY+tp9Lh9PHU7QNSlIdLytLSITptf0c4btJWx4PIJla2Jd+mDV9PaQI2zS54OqZkjvgtNhyyfonN0m3SOjqSzX5t09oukM6dNOnMi6ezbJp19BR3GyptCvCP73U/5l4Jh568B4vSeMdOHDxwuFO1Rm+Qsf9EdAcxLjBYtjqCNvMw76x9bV3Xtk4omqXsWlpas6/IJrmvo64VIm4ecimeNo4ccw+/ub4ujxDJXEBXf1ZLxrcc0HlkOpnyL6O8q00GPb0+HJCsR7yaJ/EsJa6koZ3XvC5RHDCzHEqPKpX+/R5QJaUCMBKcPOzHLHbFWCCzTTPyOdglN2T5WMw2/TnWpqpnqm+PqBL+1fZWoS0OkcRxffY98laCjsI5xxDrOEet4R6wTnLDSZ1kPq4fVw+phRWKptdMVlIae8Tuz32p2wDPUsuvnWP6EAJ3hNukMCzqhdXr+3+jwO6aj6mztwbGb+Vb2Zh0sz98zPwLK4WLY0ztomjiTPQJwL89+91P+veFsxLM75LcR+Wzt4jpjKNzSSvg1Q+ls+qPDY3TQT7E6Gm6e/qAP977stxqzQ8eQ+LvxeX3wCvXBCZCm+sDq00/5p0AffI76AMvzDFfpjaLHMjKYk/8Eqp/l/zWxjKDqtySHHvID+fz+HHpfENEVJXdGu025217JHeory12s3x0rp3z2BuWUIzBHCCyUg7wbJQcT3QeGxzds/i/R57Fyzv1q+f8osl+d7InsV+QV96uKrKlxKCQHyH/jSSNp7fO8SCRiYV/H9OsRAp/79WuBflUbKrCe3K+W/+uR/Wq87ES/Iq9i+hXzc7+q8Rv5bzxpJK3j5AGEpWx0KMKq+hX7gG205f9WoF9VlDtkhy3/P3WBHUZexfSrWgmI7Ve2w9ivb6a00F7FibLRPxJ9rnz+IyLqp/jW5uIer0UvzanGbFE+obI1ejc7B8tw0ncL4R2z3Jqbd3Eys9zy/ySwo+IoUT59lImy9rR51Dh6UYCPGh9RjV7wqLEyqWWPGpcdFjsgqumzKKcaNVE+IayaeIdpSlRxfdBElbdD8gid0EwBRYhnCsryKc/f8psHmuddGF4/5Z+ezWTUKBTygtOHrfW5Ij96xrxNFttwLqVhuSU5dHB0RMvPo6Pl3xHaGhodjXYnRkfkEY+O50Nan8jP/F4t8p8PeTiqtBrSWKWRx+cSnSLTwfKv5FTNvpU3fnSgvUWzMpYvlAm+u1vN5pQsWL5OREqwPSwLIV1KH+ZNSHaQN42kWE5QL1cRnZBdSp+QLGB0waJhkwEb6TSTqGc/o6NWnw0b+7NEn12IdbJHDdX2rk51qTpU9xE9bh8P1SyT6dMQaW+E35iGdPoFHYU10xHrNEes2Y5YUxyxmo5YDUcsT37t4YjlKV/THbGmOmI1HbG2c8SqOWLNcsTylIkdHLE8ZWKaI5anXfXUbU9ZbTpiedpVT5nwtF+eOuQpE578muGI5cmv7R2xPGXVs169cXvr8cvTX/W00Z4+wJGOWJ72q+mI5SkTnnaiW8chzzmMZxt3csTq2dXXhv3y7MeTHbE8+dWtNqdb/cIhRyxPffQcaz37sVv91WVdWq+mI9ZejliedqJbbbRnvTx53612wtMn3xbmtZ7j9o5dWi/Pea1nP+7liOU5h/GM+3piecoE61At+xvzzIXfB0E65rcP5bS5VryW12INA7EHKmLXCC9JxtczIfwhQc/qVc9Jaybh55Xh8y796+YP96hReasLv+P9CYMiv1rTNl69DsqX4NUFag+H0bY0lJEBSkO+WB3S/18aHl+/wYr1i+Ef4jdEfvYzY/tiRtKqR8YndQKeT0mpU+jqG+ANUX5pgM6cNunMEXQYK+8DWnxfiOXfKbML6r4QdavAHFE/y6/2zOB+P6uP4g2fLvM4Wa92HB9NdFY40sF9WLw/6CxHOrin6xiis8qRjjrhrvb3tUsH92/xqcnzHengXrB9ic5qRzq4//B4onOBI50LIM88orPWkc5ayLMQyqV/r4M09XG5i0Q9bGy5GN6XGFv6Y9qB+HWqS0l6o/vVLiZ63D7er7Ze1KUh0t4FvzEN6awXdBTWIY5Y1rfTkta+PpborBN01gXoHBtJZ36bdOYLOkOiXLs6onhjdC52pIM6M5/orHekg1iriM4ljnQugTxzic4SUYeff+hzp7Ey6b9LIa1PlOUzAZb/R/uMlVuVYZoMoq3AOmJ59C8vEu1geufTHOxKKFPCHo2L7yeEVcS7txPvLoK0GN5Z/q8B7y4k3mG7WLevgrSLKW0DpK2ntI2QhhiYlkAb8B3LHJa3fEOiHI9Xm+B9if4aiNENxK8nrW2uMl5tInrY9vThueg11ej1G71rBT3VD9MTzVOkb1imY8rOXklpaBs3UhqOaxsoDfX7IPiNmHlt4pvVsH4s31i/5ZSGc5QVlIbzirMoDecCfPYD/Xc+d4T8OJ/SkB/sF9vfA0QjfWy+3k95b4CPNL8v+62+4MH2/yKBbWmXirQU/7HdxrcFbRHyH9PSp0+8C429lk/RWdQmnUWCDmP1J61z7PRZDOmY/wkae9AGltD1i4z/G+Al28mKduuiWDuZZ7OxXsqGxsT/+r/02Bd++ZIfLCs7toRs7iKRv02bK+N/RlvF/zZSGsbgrA4q/ldxzLsghn+I3xBpvwC/y/RFI8m30+1isa1uF2tVRSyLcaLPxH6ROkeI4xmPXctFvbgc50O/EduCdEIxva0VC1hejV4wFoDt41iAGocaIg3HekxDOqGxA7HOcsS6hNrjEc9UftGJVGfF54sDdcbyzOezBB0V/8P50q/upOuDco9leb5k+X8P5ku/QfMlbH/Iv+OYizpXrM6tq5hLiM4ZbdI5Q9DpdBycYy6dilGcQXSudKSDWBxzucqRDo4T7HPn6cGfkx5sgDSlB2dm//dT/vWgB18N6AGPZRsALxH55+bQ+yvyeyv6pjLmwn5oHu/+2smGLAHe/W0JG4I+wiWUhvzgOQ36foiBaQm0Ad+xzGF59FO5HPsFFf3j6JiL4deT1jZX8QuuIXrY9vRh///aavRGYy7XC3qqHzDmouIsiMUxF7SzPKaibWRfHv0HjsegfsfEXLBN7Leq+oVi75NF3Tvhcxp+PWnV0SqydQnR4/aFfE4rq/pmMvzGNKSzNXzO0F0mE+ULzW+TznxB57XiC/H607biC83eeawM2vfY8dzyf+f1Y+V2zDA76QvtltHYmr7QHsS7qr7QHwPv9iLe4f4L1m3kE/tC6KOwL4S84jhy2fiPWqfYVtaf1Hj1alp/Qju7mtLQNrK/g+Marz+FfKHVBW0K+UJFaze4/yFv7ebzoGfHZHqmdHxlMj4NZXwd0J1Puop84bhqWd8By/N6uMfYpNawOV51lajzVYE6Y/mrKO1KQUeN6Whf37Szrg/aVyzL9tXyPwX9vpj6DOU8tA7GPlrZ/jw2ks4ZbdI5Q9DppE+Dbeu0T8Pxqg2OdBCLfbSNjnRwHGIfbbmoQyqz55MebII0Fa/neJXlfzPowZqAHmAdsTz6aGqvE9N7B/loFcdE6aMZVhHvLibeXQJpindsQyz/gcC7S0vYEByTr6I05McGSsNYBmJgWgJtwHcsc1je8g2JcsZf66/r4X0nfDTDryetba7io8XGj6x9761Gb9RH2yzoqX5AHw15ivQNi320UNwDbeO1lIb+/zWUhvrNPtqVBW1iH03Jfmi8aXPPRnS8yvDrSSsfq8iW8oXUOMxjE5ZVfcPxqg2Cjoq5KqxLHLFC+6/YFyr7ha1jI+nMb5POfEGn02dLtla8qhM+V/ow3zrhc6W/Y32hR2g83whpMeO55f9fe4+VezQwj+O1oo2Al4j8c3PoPUm+UMX4h/SFeA0qj3dPE++uhLQY3ln+F4F3zxLvsF2s2+jvcLwKx372k3DMRAxMS6AN+I5lDstbviFRjserir5CtC9k+PWktc1Vxqv3Ej1se/qwL7S5Gr1RX+hGQU/1A/pCyv9BLPaF0M7y+hzaxuspLdZPYl/okoI2sS+E9bskBwvPsquYE887vpzpV6prv7XzWH7MYzEwPOeyjOhfBfiqjmy3LP/vZjTT/ZS/MrzlN9sZNb6iTTyI0tD/XA9tWL7L+HxqTDPZwX7rhP/Ie28r+quj+qh8MRVL430EWFbN534RfmMa0gntZUCs9Y5YPf9xjA6/K+M/duIcHLZtomNpmxzpoLyx/5gXU/42+UDXQFpMTNnyLwMf6J/JB0JbwbGbawAvEfnn5tD7N/IfK8ZKpP/IMaE83n3fKR5/OPDu3wO8C/mPfKYO+cGxtJ7/GE1vm/EfOSaDtpH9R/Q12H9E/Wb/cX1Bm0L+4/ocrFj/cVQ/Mp+qzbibtBuGFRqrtla8b301esF4n7proGy8j88BtROju9gRq+evjdHhd2X8tU6tfW6r/trcXcbK4BhU1l/7873Gyh2aYao1jBh/LTRvtvxHkt3tpL+m7rdI23k08U6tfWLZvLXPzwLvjiPeoZ1l3UY+VV375DhK2bVPLL+trX2iXrwa1z6VP9Tu2mdZfy209qnqVzY2xnYQ95rgXQDLd9F1zfMHz6Z0y3/2LmOYZ1G8DduzHGj/zS7jsaz+byUbV/EMgrRxfEZTraO1efdMtG9p+PWkrXaO6qpaY1e6yj4FllV6wLHAsvv31F0yHlih+0HYt1T3NC4P0Dk2ks78NunMF3TUelst53+jw+9C+z7Zt+zU/r3X+lpynn90HdlUtZYc8o8s/zl7jZX7hYBvGbOWHPItLf/7yO52ci05j3cfcPIt5wPvPhTgHet27FnPkN/JNk6dd1QxL7WPivcjYjkeryr6etG+peHXk9Y2VxmvYs8itOk7j/qWsbFH9C3V2U/EYt8S7WzoPCH7jyq2X3UtGdsUur+k7Foy+36W/xGyGxX9pqg7+9QdtFvrrOrqavSCZ1WxfVXPqnIssJ3zpe3eB6bOrvT8tdZ3Zfy1ibortRN7DNMnb97qQSc0B87zOX6NfA61/hjyOSz/XzXHyv1mIJ7F99WpPTTrRTuY3hfJ7lbcuyLtrmEVnVX9Uk78IPasquX/jeZYuS8T79DOsm6r+6PVmm/oHCuviZVd71D3ZnbwDsBof83w60lb8jE6XqkzvGrtqs35w6i/FntPCPpr6t48xAr5a3xWFW1j6D7U0JnEmLOq2KaQv2ZlY+NqMT5Txfs2psXKIN8p167PpO49UT5T+p2ofbPfmzauv2z9xusWrdu4bNMFl62/8LR1121YcPnaZWuu2rh+zWUL1q69at2GDVhpJIQfR8N0fDiP/V4h3iPG+oLGsDBgZ7HRKnImQ4aTJwJXFmDx5bvqsA7/PZC01tMC0ZMicFDR8up1JtULFfEqwtoQwEp/v5OwsHxewCUP6wOEheX5ECgGi7iezK8QTp4BxXp9kOqVd9A//XdtAdZ1hJV3gVL67/oCrCsIS03C+e+BpLWezK8QTvrvvQX1upzqlbfwlP7bXID1PsLK23SU/ruxAOvdhIXlsSz+PZC01pP5FcJJ/91UUK+rqV43QtpNlIbl6kRndYCO1Td9GqI8D5qd+ohNnejc5EgHsVZBuTTtZiiPtjVmgesWeN+JgInhey1w3UL0uH0cMLlV1KUh0jjIcaugc6ugo7DWO2LdTO3JO4C1567jaaoLg0IHsCz/082xcntnmMr3uInaqPyYiwW9GrVrUORHvH7Kv19Wp/TQyG3DW343RJ3W59SFx9OYDYaoX53QEcP32mB4M9Hj9rGO3CLq0hBpHLRQuniLoKOwrnLE4ssM83TkKCcduaM5Vu7YLtSREx10BH2oGB1p54JOxLP64DvE99IR5cuGdORmUZeGSONNfkoXbxZ0FNY1jlixOrLUSUeub46VW9ZBHTF+x+qI5T/LQUc2Q71idKSdYBjiWX3wHeJ76Yg6pBfSkWtEXUKHW2qUhnRCi+OI9V5HrFgdWeukIxc2x8pd1IU6cllJHVF178TcS8WvDoffeTwKfdDxcNEeNcc7nNqTJyNX76rro2Qk/W3zd14UeUtzrNx1ARmxOqq5NC+slp1LHxtJ55Q26Zwi6HR6zj5Rh2JPITqdOPyQPryweo0jHbSVsZeqfIT04FpIU3pg8aJ+yv+9PcfK3RHQg7yYZewlwJb/noxGmxuP5MIqH+7M4919TuPM/we8e7CEDUGfnm088mMTpeGYzHFfFV/FdyxzWN7yDYlyxt82D41GL6xuzn7Xk9Y2V/G1NhM9bHv68MLqTdXojS6sqrmE6gdcWN0MNJG+YfHCKtpZ/iAC2sb3Uhr6yXxgFvWbF1YvLmjT4uz/aYH6xXwQoaJfHe3HG349adXRKrJV5C+GLghhXwjTboDfmIZ0Yi/1WO2IdWP2e2v6QvPbpDNf0Hmt+EK8yWxb8YX+sIQvlD48nlv+q2E8/5MJ8IX+ogt8of/t5AutAt79n54vFHpeNb7QjdXojfpCag27jC+k1rRfC75Qn6gf5kPdU/GkRLyrBegxjUmi7Ieo3ph2HtEoGwM6T9S3g3Hdvlj9erXEdXkNvZ1YbIzP0+YGxsofxe3EBsbz4J3TJtq+UD+ENu1WXMubZPRCe7uQXmpPB5PWPiz62AzSwP7K0/mq+yk3FWCF9lPmXfaRh8X7KfM2LmPaXrtt+T+1wzN2G5/H9gJuD3lmZb9Zp5APP99LQvlCH1tq52NEiJckWvf4w5PtfmxJ9UPex49el4RlBPsob5+pujAiRmZDHy9S9Snbp2pTeZrv9YF8V4p8ilb6N65BGQb74m/IMFI+//rw+DaGDimWPbAVOuzbO4CWTyd0AG2FIx2UFY4NXOxIB7E4NtCpWEfsxxJP2G2sDOtaaLzgi1P+a4+xcsMZptqjz2PdlYCXiPxzc+idktGw8QBtX7uxAb4EMI93i4h36sKAEO8s/9eBd6cGeMe6jbafx3HkBx9OUx9SrFFaAm0IHUBTHxbYVg6gqcPHr9YDaHyoG20jH0BDPyB06SjHBlYUtCl0AM3KpoerMnWBw1Wnrbtu5ZrL1q9ds3H9FZcvX/euTes2bOwHZDVysIVnS4xXEuQ9Nfp7EqUtp/RlIh8+odF0a10NtbwaveDVUMrLKHs11IfhN6YhndjrnFY5YvFx3961o/l0uuEzQ524AiB9mG+duIIq/R3r6b2HvJUVkBbjrdjf7wFv5X3kreCowTvtVwNeIvKzp2f5P0SeXsWom/T0Ynde3hjBu9AqkP29Bnh3C/EO7SzrNvKJ7QvOvPnaKOQV785U0UC1Oq88ggnYtRDt6U3ErgX0HdjTa+ezLek/5VmqfkBPT137gFiha0eXUxraRl4hQl+DryhA/Y7x9LBNMZ6eydYSQcfSLoK0syjtUtHmVO8eC9is0yPaoWShIcrzjAzpnJv97qc2/irZOvxceAnZOiE0Vk+mOpTFjtVLwx8S9KxedZHWH1GXH80anvu9kX97sEblrS78bhLgoyxj/tNF/jbHnOOGgEZCtC0Nx8NzKW0A0qwOadTypeHx9au4MnRcDP+U7mPaZPhdpi8U1oqKWDOSVjtnumP6h3bk/Ox3KKrYpg5Gz7cMv5608qDK+HUW0cuzWeoqFyurxg2+irfsnAKxljhi2Rig+pnnW0sEnSUBOseKOis689ukM1/QGRLlajn/Gx1+x3QUb4zOWY50UGd4vtWJ+WOStM63znWkgzYqdtfdX9Gc4XxIi5kzWP5JMGf4RsB3wTpi+dj5luX/e/JBKo4tcr7FuyvyePf/nOZb/7D7WLlvB3jHun0+pPE4gvzgeRr6CYiBaUkSN9/C8tvafOt8eMe+WDtXrab/VDyyzHxL3RTF8y20sysoDW0jz7dwXAv5XO3Ot1T9er5QvC/E19y247+sc8QK+Sg9X2g8nZ4vlFSiU8UX2m33sTJo38v6Qh+C8XzP7HcnfaF9Mhpb0xd6A/Guqi+0Hnh3APEO42+s28gn9oXQR2FfCHnF8/qyp5Kw/ATs0I32hSZih24o9tzOicD0X+w18OgL5e1K5PVyZWc59oy2kf0dHNfOp7SQL7S8oE0hX4jX3TFuzHmXQnsx7zDo2Tt2z6d1AdVjKaStpbRY/UQM5C/aCsz/DmqD5V+U1TuNNX5hWGNOSrSMoj+ZJOP1xtoxGehaWgn5/UJar48Oj9FBeUkfjJuivCRJ2Kfi8QLzo8yxb4h2kP05JY/oX5g8Kn5ZHTvBL6xDDL8wf1l+sd4jvy4iLOX/Ig9D/LI6doJfWIcYfqk9LrH8Mh4ofl1KWEVznMWU37AHE20TDK+f8l8INoFv5QnZ+KUCG21jjTCwHfuLdgxRGpZNcc/cfsvviYrzsK9ZdOMO7oPA/FfCuPEB4o0ap1WMxPKHPseH9Yn5RITCWhGgrfZOhT7Foq6z57okSb6/oeyA8aZNOzCg7ADGq9gOqH5SJ55CvFL9pNbceW9cbMyJb1aIjTnhSYsP5MxJsB15Npv1AeczPNdR84SQ7Cn/GfWYZU/FWJX+s91A/We7gTIa+nww242qO+HvoDlqJ3bCs3z3J1q+83a4PwW27WM5tq3sZ/buhfHo5uEtv0Pr7W3agn5lC1Df2RbEfhI11m6y3mLf8FqD8i+Qp+wTGI8GRX7E4715vxTpE/Du8tgYeGjeZ/qQ8v2LWT2K9kA+Q7KnbnMI7YG0/L8H8vwczfE87Ma5lKb2aIXGHCVnavf+BHySODqWMhGfJFbrPG3azdFYijo5o/oBYylFpzfNVk20XUM+xdg1tdak9hCyPqONYDuANoLtx6oAPbQR6It/MScGje2I9Vkwfr0b6T/qF+s/6jjrP8o7+w3IQ/YbroK6KJ+HP61p+f8IbNjfEW+ULIf82I0iP+5L5VttUNY3RmBdHKCtTstvDNDGevENUHziXOmk0kXjTSfmG+gXsC6qflLnVEK8Uv2kboHZSGmxussnxHB8Z71G2caTqH+XM25jO1SMl/0BHvOfCawhdXOs4J9Bd3/aixW00OZ69mIF49MmMlbw0w7FCniPWC9WMPY7L1YwNdtL2M2xgtfDfsfpe2jMsrGCWRlOL1aw9WIFe0AfbM1YwYKsHkWxgn1J9qrGCk4Ged4/+92LFcinFysger1YwdaJFSwg3feKFfwV7UF/tcQKTgMbdj7xphcryNfJXqygnO56xArOzxm3sR1VYgX70tiNsYLQ3kc+r3+xqLfSefanN0BdVKzAcPsp/8Wgu+8m3oS+Hp0+ZfWH50xKf0JYofmauhFpU4A21otvYGddVmfoOziOSt1F/WTdDdnM9InhleondQMu37SLOsixAhyH+JYoHIdY51G2cdxl+fSKFfD9HRcX4DI/1Rkl1GMeN1aI9in9Z7uhYlahW9uUrLPdsP5EWcX8HCuw/DdRrKDijasyVsBfCMB7K5R889zK8n8cbNutObZtoCTm7ZGxAuvHTvjUqO9sC0I2OH3K2k3WW+wb3rcfe4Mb69lgon2IvDnzA4FYAdoj9jPUTZPKHrEdU/cppXz/NYoVoN3AWMGjJHsqro9lud2W/zdBnh8nf8PDblxFaWgHECNvzFFypm7+wzGUy5kdMLtS8abE6FgB32K/sRq90rfYt2k3R2MF6ovBqh8wVlB0k3koVtBJuxZaDyniK8/dsY2sz2gj2A6gjWD7cWWAnprfoY0I2cjY+Qb6LO+hWEForQB1nPUf5Z39BuQh+w3XQF2Uz4NjNub/EtiwrxFvlCyH/Fh1oz/exs/rMKGv/SqsUJzivSL/9QHa6is5XJckyddJpYvGm07MN9AvYF1U/aS+oBHileqnBuVH3pTV3WsoDcd31muU7U3Q5q/ljNvYDhWvZH+Ax/xHaezu9C3OeWN3XpzPcNn3/XvQ3R8Rb5R9Vjcgs/3A/OrLe6H5eggrtD4Wkl9FG+uFZZk219PKKd013nRCdz3nB4pXqp8aSatesw7i/Dt0ozTrJ+oRxwDVXYdKPovOsobGXVxX5lvdQ/su0of5GYqzKtlTN6gr/Q/F1thuoIyy3VBf2WQ9Q1nF/BwrGPUR9tzyv/mfFb/kI2MF/PU6jGco+ea5leXfFb7AN3lPjTlQEnNKhlMUK7B+7IRPjfrOtiBkg9OnrN1kvcW+idkLhjzlWIHxaDDRMUvc84L5d4A+4FgB2iOOa6I9Ct1wz3un1Fc2Ur4fm9VDrcVgrGB3kj0V18eyLHuW/3iQ52b229NucNxSxYxCY07oq7lqXUDJs9mBNufS0bEC/upTxdhE8KtPar7Tpt0cjRWoOY7qB4wVFH3pLBQr6KRdC62HFPGV5+7YRtZntBFsB9BGsP0I7WNQsTC0ESEbGeuz4JrnCRQrQP0KrYux/qO8h+bW7DeoLwqrORd/4Xch2LCVxBslyyE/tmi+zrFPNV8PYYXiFJtF/vcGaGO9sCzTztNJpYvGm07MN9AvYF0MxWjSJ4ZXqp8alB95U1Z3r6U0HN9Zr1G2MQa2MmfcxnbguM26mxc/3J3G7tC6osfXoHluvRnqovYV4DiA+d8OuruBeHNjMvbEyMRNIv+NkIdt2GZIuykCK7Qn6GaR/6YAbawXlmXaXE8rp3TXeNMJ3d2MGQA3r58wfwyvVD81KD/yxtLUPhulg5spLfbL1O+FNrN8Fq3/h/YV4J4g/jq8soUh2Ssas1j21Jil9J/tBuo/243NkMZ2A/uW7Yb1J8oq5udYgeV/H8UKUEbajRXcTHW8Eeqg5JvnVpb/XrBtH8yxbQMlMT8cGSuwfuyET436zrYgZIPTp6zd3Jz9VraAYzoq7rAZ3nGswHg0KPIjXj/lvzMQK0B7dCPVHe0R+yAqdqzsEcYKXqFYAdoNjBXcT7KHNq1PlGXZs/yfA3l+iPwND7txDaWhHWDfWo05Ss7UWhGOoVzO7IDZFZTFTsQKDL+etLa5SqxA6R+ODxwrqGg3R2MFtwh6qh8wVoA8RfqGFYoVdNKuIZ9i7Brm57k7tpH1GW0E2wG0EWw/NgXooY3YDG14hXRf2chYnwXn53+Y+SxKx1n/N0Ma6z/KO/sNyEP2G26GuiifB8dszP8bYMP+lHijZHkzvOOx61aR/xbIcz21B2X91gis9wZo3yby3xqgjfXCskw7TyeVLm7OfndivoF+Aeui6ifMH8Mr1U8Nyo+8Kau7N1Maju+s1yjbN0Gb/zRn3MZ24LjNunu9qCv6A6+2WMFfge7+K/FG2edQrKDsfH0zpN0cgRWar4XkV9HGemFZps31tHLdFCtQ/YT5Y3il+qmRtOo16+BExgr+tUOxgvte47GCmDEfZRXzc6zA8v8PxQpQRtqNFdxCdcR4Rsy83vLPam75/+f60tSYsbECy9+X4WzNWAHqO9uCkA1On7J2c3P2W9mCrRUrmNbc8n9RrIDjmt6xgnnNLb+LYgXbN8fKs00rEys4ojlWbqfsdydjBWgHOFagxhwlZypWgGMolzM70OZcOjpWYPj1pLXNVWIFSv9CsYKKdnM0VqDmOKofMFag5iKI1Y2xgiK+8txdxTTLzjfYflSJFZiNCNnIKrGCjzjFClDe2W9AHrLfcAvURfk8OGZj/vnNsXKnN8djKlneDO86MV8PYYViBR8R+W8L0MZ6YVmmnaeTEx0rQL+AdTEUo0mfGF6pfmpQfuRNWd29hdJwfGe9RtnGGBjLp1esgP0BdbZB2YQa1Rfzh+YnRXtHeX6ifCG112h1Dh11B1j6++rsN+81WtXc8n+RT22025T3aZ3eR1M0H+SzM2i7ec8L8hjPI/HYgGdcrqaxAWNRN1Fd1f5QNU9m2RvMyc/7ySz/xc0t/6PPHpLn0PmvsvKMbWhXnlE33k1ttfxXNMfaOgHyPHVryzPLLMozx4SUPNeSVhvWTjxnbRfK/3ubW/7fFuT/Q82xtnaj/Ku5REj+i2IkLP/ov20N+V9aQv5vDtBU8m9ty5N/jCdi/nuaW/5X8q/4G5L/ojXCkPzfSmlYbnUOHZR/7HeWf8v/cHOsrSH5N9qdkH/kEct/aN6UPmXnOrwmgP57SP55vdZL/o8qIf8h31vJv7U1T/4Nj+Plzze3/K/kX+ngJfCu3bUubMMtlIblVufQyfPnWf4t/8vNsbaG5N9od0L+PeevRXEG9udRN0Lyz+scXvK/J8k/9hnLxlUCo+rdFdYOdWYT2433omL+322OlfvL5nhM5SOF7kj0OGcewgqNT0V3YzBtdTcG1yUR9bRyHTz/NdDpc62KV6qfGpQfeaPOnLBOhs6VxN6Vh+fFWD7VOLIa3oXOi+Hc/Uu7jMfdUIBb9g5Xjv+qO1zLnlULnWNnu6HO+7GeoayqtTeeb3yzueV/W99AGSkh63Itmu+qwXP4Sr557c7y/09zy/9pH/9jU2MOlMT8ToZTNM463VXT3+m7aorsJuutOptWo78RS63fsJ4NJnquy/eyWP7/aG75v+iMO9/Hoe5rUvaIz9yhzuBa9K57bfmtzujiWvRPm8m4dle9i3GPvcbKTcp+e9oNvg9L3XUQGnOUnDVEeRxDuZzZgTbPgEevRRt+PWltc5W16Nj76dq0m6Nr0SpOqPoB16LVGVrECq1Fd9Kuhe7xKeIrrw1jG1mf0UaE7t5h+3FJgB7aCPTFzUaEbOR6gct3BGLZn9+zl/ksSsdDa0uhc+zsN4TuM7ke6qJ8HhyzMf++YMOOId4oWQ75sZtFfoyD8/1B6px5CCt0vv5GkX9zgLY6t8N1SZJ8nVS6aLzpxHwD/QLWxaI12RheqX5qUH7kTVnd5fXt2LvyMP7O8ll07zjrrrpHHf2BmPvwyt5XqfSa76cpWjPOu5/ijaC7ZxFvvO+n4DlT2fspQrG8zSJ/aL9e736K8flD6+qbIS10PwXfh6d0MHRfpbo7Ced0LJ9F3xcMjbt4H94HKFag1jJDsld0DyTLnvKblf6z3VBzfqVLobtY2G6wf8j5OVZg+S/M+sL8z81Qpt1YwWaqI565UfLNcyvLfx3Ytnfk2LaBkpjrM5yiWIHTON7f6XF8s8iPdpP1djOkxXyrCHnKsQLj0WCi4xR8/7Ll3wh9EIoVsL+A9oj9BRW/U/YIYwX3ZvVQ8VyMFbybZK9qnOoBkOf3ZL897UbIt+Z9q2rMUXKm9gbiGMrlzA6YXUFZ7ESswPDrSWubq8QKYufubdrN0ViB8sNVP2CsAHm6GX7jueT0mWi7FoqBFvGV5+7YRtbnUDwRbQTbj6sC9NBGoC9+L+m+spGxPgvON66jWEFo35Ka8ysdZ79Bzed43Mjb05R3TvZRsGEvE2+879TiffibIe2mCKxQjL3ojG7onqHenVq6n2Lu1IrV3c2UhuM76zXKNu4vfzln3MZ2qLUQ9gewLPoDKlbA371AvQ7d7xgau7Ee3EYVK+Dzgpb/10F3/4R4szkZe2L0pyjWxnMmFWsLYYXma0V2I3S2j3WV435qbO3gns2Bsue/NkNan8gfw6vNkIdjBWgD+S6J0LcuUT85xqDG1tD5dyWfXrGCoylW4L2nJbTOz2ehsBzbjbLjeuj8O+sZyirm51iB5f9G1hdt3lslYwU8jm+GOij55rmV5f8h2La/y7FtAyUx/yHDKYoVOI3j/Z0ex4vsJutt6L4ENZaqc6isZ4OJjlPw2pTl/y70AccK0B5tprrH+gvsg6hvSaR8n7X3lt8qnouxgh+R7FWNU+2w91i5/8owPe1GyLfmvT6WliRhOVP7USyfkmezA2ZXUBY7ESsw/HrS2uYqsYLYuXubdnM0VqD88M2CHsYKkKdIn+87mWi7FoqBFvGV5+7YRtZntBF58QBlP0J39aONQF/cbETIRqr9CkOUhmVT3LkUK0D9Yv1HHWf93wxp7Deo+RyPG8qG8ZiN+XcHG3Yo8Sb2fgjLX7TXn89zqXutQlihGHton7yire7i47okSb5OKl003nRivuF5j47iVegOCjw/wGfVY3WXYww4vm+mNHVXnpLPojVZ1l21xoz+gNpnHIoVhNba240VoJ3JixUcB7q7lHizORl7PGIFPGcqGysInX8o8nmZ9mZI68UKdD+VjRXwXj+cm3vEClg+1X6+2HEX9/N9f+fxuCpWEJK9rRErCMXdJiJWcG7WF90cK3gX2Lbzc2xb2VjBmgynFyvYerGCy6APysQK0B55xApuj4wVbMjxOcrGCu4Eeb46++1pN3qxgl6s4Ofg2f/bYqwAbcRmSqsSK7i9Q7GCb2c+S9lYQWjNbCJiBfeDDXuuFytooZ2nk71YQTnd9YgVPNehWMEGGrtxPwTrLu7d5HmE5xmE0J1Olv8zoLu/H8Gbds4gxNwhHsK6MkB7s8j/3gDt3hmE8flVP8WcQUDd5W/fqlhVO2cQWD7V921j7xrB79s+TbECdQYhJHtFZxBCZ5BCZxBCMcbQ2cKJOIPwVYoVbIYy7cYKNlMdq55B+A7Ytq85zde+Hhkr6J1ByB9LWc/KnkH4VmSsoMyZxSpnEKa8fsvvojMI/5ozXyh7BmHa68fKfY/8DQ+70TuD0DuD8HPw7P/X6hkEtBF5dxIo+1HlDILZiJCNjPVZ8AzCIxQrQP1i/Q+tW0z0GYTtwYbtT7zpnUHI18neGYRyuruZ0qqcQWD59DqD8K80dmO9272TQOk8+2nK91VnO9j3PQx09xTijfddIzHz9RBW6AxC0Z4Gpt27a2R8ftVPMXeNYEwsdAahzDoeyjaOuyyf6gxC7LiLZxAuplhBUex/or5j0e6dBErW2W5szv5GWcX8HCuw/GdmfdHm+p+MFfAeI4xnKPnO+y7ZerBtK3Ns20BJzFUZzgTdId/f6T1GRXaT9Ta01qRibGrtj/VsMNExy7xvFqyFPuBYAdojjmuiPeIYyAZBV9kjjBV8mGIFaDcwVnApyZ6K62NZlj3LfzPI8+XZb0+7wfesqphRaMxRcqbumsMxlMuZHWhzLh0dK9ic/a4nrW2uEivYTPSw7enDsYKKdnM0VqDmOKofMFawGWiqPQahWEEn7VpoPWQzpIXikCqmyfoce49S3l5IRQ9tBPriHybdD33XBXGVz4J3Jp5PsQLPOwnU3Jr9Blx/VT4PjtmY/w6wYY8Tb5Qsh/zYovk6r8Oo+XoIq51vr4S+WVr0XW+lkx385qWcb6BfwLoYitGkT9nverP/H/qud6zu8v5nFQ9Qurs5GWvz4znjNrZDxSvZH+Axn/2B2P3RNaov5kcbwvxXNie0X0H5QqG7FpkO2gRs25nZ/7z282KkT93JtXjPbwcUzQd5/71arwndmVu0T/5NNDbUIN/bqK61pLWuNdG2Rk55hYX9Mhd+HwTpmP+PaS6J/CzRr0uHoEwCGIhdUWaWYlvtUf4k+k6KXvrURVp/RF2u/rU9b330PfOm1qi81YXfsVwOiPxvE/mNV4NU92YS9ZymdNdoWxq3HdNQ/6wOqc6+NDy+fgMV6xfDP8RviPzLIF+ZvpiRjJcFlHfT14sh7SxKK/vtm1DMme0b2u3VkIfX7C3/V8GX+8eIsRL95058myaEdXGAdtEeN6at5rJclyTJ9wE6eGf8QKe/haF4pfpJrdlyLOksSLuY0mLvouZ1YLUHTcnnxaIdq+Ed+3KrRV1T3D0odqx8s5DsFflmLHuxvhnbjbLfvgnFjljPUFYxP8eOLf9/0HhfMeYiY8e85xTP05aJtU3bZ8v/aR//t1P87icT6+f2d3rPaZHdZL0N7T1Q35NScyvWs8FE+9j8LTfLX8/6VcWO0R7x3BLtUSiexP476gzGjg/K6qG+64Gx4+n7jG+3mmNhWZY9y38IyPOs7Len3QjdpcfrBGrMUXKm9v3jGMrlzA6YXam47ys6dmz49aS1zVVix0r/1DyzTbs5GjveLOipfsDYsVoLR6xQ7LiTdi00fy/iK8dy1VqqshGh7/Wx/bgyQA9tBPriB5HuF31zL+SzbADc2RQfQP1i/S/77ZtQzJnHDWXDeMzG/EeBDVtMvNmcjD0xfmzRumdoLSzmDoxQfKhojxvT3gxpvTswdD/F3IERq7scH46NOeO6z+KccRvbob7Nxf4Aj/nTaex+tcQKzgTdfQfxphcraK1nL1YwPm0iYwUsn16xgr/eaTxuL1Yw9jsvVrAx64tujhXcDLbtmhzbVjZWcD3MU3uxgvFYExUruKFLYgVPR8YKbnWKFTwL8nx7L1YQenqxAqLXixVsnVjB0x2KFfx55rO82mIFnwIb9sVerKCFdp5O9mIF5XTXI1bwxQ7FCm6tOI+pJa12KGafmdrHhvzg+Ynav6Tu2jkrhw7aBGwb7zOz/H8c6VMb7U7IO/KI5V3Z7NB9pqFvLSNP1D5HPquFPDaaRfPZX6Wx4SLIty4Zn3apwFB9vZ7SrhJ1Zn6hHCyBPIbbT/n/FsaGH5COKJ5eCu/KzsmXUHvUnDyEdVGAdtEdNUxb3VHDdUlEPa2c0hXjTSd0BfWBdSUk++kTwyvVT+puC7b/6yDtIkrDeCz7g3jvWeheJbRvLJ8XiXYsgXc8NiwRdU1x306xKGXrQ7JXZOtZ9i4V7VP6z3YD9Z/tBsoo2w1l61jPUFbVGS+eF0/ad8v/Nr9BGWk3FsV3sWAcXck3z90t/05ZHdM+HthXYw6UxJyc4UzQuCnnbKjvbAuK/KWydpP1FvvmUsK6VGCpc0KsZ4OJHrMNr5/yz4I+4FgU2iP2cdEehe59v5TSUGcwFnVUVo+hpNVuYCxqF5I95bNhWZY9y38syPPu2W9PuxFaF+O5qBpzlJyF7p9S8mx2wOwKymInYlGGX09a21wlFqX0T/mtbdrN0ViUigmqfsBYlLq3A7FCsahO2rXQfKCIr6G7jVmf0UawHUAbwfZjfYAe2gj0xY8i3Vc2MtZnuRRwV9J8A/WL9V/Ng5SOs9+gYtg8bigbxmM25h8GG3Ym8cZ77Ztja2XXvkPzzaI1nNB6YG/tW/dTzNp3rO7yGhqO76zXao1KyWfIz08f1t0rRV3RHzDZWAj55iXj01D/903G12epqA/mP5ryW7xqMCe/4fVT/rcJf2sa5Ul/75dDD+unYmYNUX55DhbaG2zfmpy6XyD8dcNcIeq3n6if5T9L5F8Beaw+ijcct1sh2rMU8lxO7bH8F0fOP0ym2rQNU5RtQL6xbQjxKH2Yp6tEfuSV8UTdj8Z3M82DtBWUhrqzhOqwUNThaHjHeo1yZ2VTPrwwe8tv63+c73SjXl8fqdcn5dDD+oX0GsuX1esrcuq+uaRenyTq1016/aFIvTaZ6ul1sV4vFnWI1WtLS/nw4OzxuGshTcks97Hlvzsgs+uS1rqeD++Yvyr2ib4Ry+xaSLuI0rDcuZSG6xirqQ4XCz5gftZdy/8w8OELw1t+K1m3erUp69spWcc1MpZ1nOepNTXuC3X3HvqbHBdHf3MtYa0VWNjXHEMzHg0mug8Mr5/yPx2IoZ0L5XndbHXJusfqG+rUyllbfpsMng/5uP2rAzS5bPrvguzvwZz8htdP+T8l+FUjGmofePqcSpiW/5WAPbggaW0XxglYBhXvLxDtUjxdS2nYxyYLSj8tXyfGImw/62eorenDvFG2FWXX+l/NMc+nNNSNC4jO+YJOrPyjDL1x1nhcjCUb7hFQ9sLsdz/l/1JAvs5NWusa2s+g2oa8sPpMozpg2Wmi3FJKQ7lcQXVYLfiA+d+RjOeD5f+jyPHG6tWmPC9Q8oz2gOVZ6TrmL6vrLLMo66sIS/lp2Ndsb41Hg4nuA8Prp/xfC4w36B/zOYgVJet+hKj7UNKqM6hTvzRzy2/l3y8kmisCNLls+s983sGc/LzWY/n/PjDeqDkT8mlnwrT83wzYA+Xfh+ZMRf691UfxlO/vx7qbLCj9tHxt6ucblX5i+1k/Q21NH+aNsq0ou9b/akzhuQ/qBs811Tw8Vv5Rhj4yU+PmjTdvz36zfP1nyTk5zs/Kzsl5vFFzciVfb6Y05CnPH9W4i/nXJOP5MNrHb0hG+RAab5zkeaaSZ5RZlueQfKZP2bHfeNJIWseDvHgPYmFf83hjPBpMdB8YHsdThqAPeLx5M5RfRXVfUrLuVfTtXTTeYJt5vFkSoMll0V7kjTeG10/5dxD8qhGNvL2FPN5Y/p0Bk+2BinGGxhvF+6WiXYqnyykN626yoPTT8rWpn7OUfmL7WT9DbU0f5o2yrSi7PN6gPeR1bNSNpURHxdNi5R9l6Dwabzj+jlgoFyF5RL0xfrI8HhSQx5CepQ/zvChGb/VR8shzHqx7SB6d1nRWKnnE9rM8htqaPmV11fqzkbTKakgeY9Zt0IawPKIc4brN6TPH58M1wFr2v+2d2R/el+D5pBrhWZ3xHeLXqS4l6Y3uR9qf6HH7rO+m/OxfxoZk08b1l63feN2SK9asXbjmyg2bLls3CaGT1hUr5Aqi4rtaMr71mNZH7/oo35vo78WiXCKw+4DuAZCmOGGYppXYpgNyyiEvEvFuksi/P2HtL8pZ3fsC5REDy7HE1Og9Ws2dBe1+yn8aWM2nhvPp7pwkLXzYmf6+TNDroNbN2Da0bjqhWh7Mi890qBnm57+5R08V5fgxnH6q8zmZFKXSd1b223p+Fyhr+2stbVfAtntmf36eizD2pTqo/7Hu+I7HLw9LodYn30nlDoC0MyPqcICoc0OUt3xDolxV3jQCdTY6KC84d173hrEy6b85kKYsEa+fWv7/DTJ0cfbbeIkaa3VUfF6ZjK9LWT6vFHQ6zeeVRGeOIx3E4vjqIYTFfLZ+Mj4fDGmHULlDIQ3z4Sh3CLw/VNBW+IZRJIPXvUG3LU8GjVY/5f81kMFfIBlUoymPvkkSlnmWy8Gc/PtR/Sz/+wLz+J1Fm7FevE5p+T8YmDftLNqlbGWoXShTO+e068ZAPEd5IWpsOYjSdoU0s+E4tvQTxu3Z+8lJa3+U8BLkmae8emM+o7tvNbrRcxDDryetPKziDe1L9Lh91bwh5D5zBVHxXS0Z33pMK5qDnE5/V5mDKCuwi8A0i6L8ei7HWsjvJon8+xKW0iC2zqo8YmA5lhhVLv17QJSJ0YCK/nlfrAYYvpcGFPW7yaq1fX9Rl4ZIw7pjGtLZX9BRWLsS1q6RdU61NtuwYFp75sYrrlqXqW1CT9GkY9+cakwS5RMqy6rNjv0uokmoOotzaOcNwobXT/mfE4NVqHz6xIg9dlEnDL/he4l9rAjxJA7Lhgb5WtLahxMkqulzek411IiSEFZNvEsf5UtuLTH+lYDPNUmUT635ZTPG0y7ys3muZ/l/M+BzqrlB6NzGPJEf5yNWn2lUByw7TZTjeSbuU55DdTgsaeUD5ue9spb/9yLXkq1endgrexhk4LUBXCPpE/m5L44S+XGdyHjSoPzcL/g3YmFfsx4YjwYT3QeG10/5/yygBzhPP4zqPqdk3ZUO87yWdeo6moMiTR5KDw7QVDJrdPLsRt4c+euBOaiK/WC9eA5q+f8mYA9CcYr0YRlU9uMQ0S7F00MpDWMSGA8ybMbsxF5ZbD/rZ6it6VPVVqqzGXMoDXWD5X+OoBMr/yhDHFv8COQz3EkC1/Lfnv1tMs55rGw/5f8+yOPjw8m4dqOb9hFqx+1QFxvzzb37KNW9mUQ90e6d4depLiXpjbp3HyV63L5q83qWSOQKouK7WjK+9ZhW5MWdTH9XmdffAWmKEzyvxzbdkVOOJZffTRL5P0pYHxXlrO59gfKIgeVYYliL0Kp/RNBmLerPzLRaW0S6H0mSFj6wJs0T9Ezr7qC86WNadye1qZlEPefEap3h16kuVbXuTqLH7aumdSgpSOVsQrU8mBefs6FmmJ//5t47X5Tjx3D6qc67Z1KUSt+07Pe0pFVid6N6Yx1C9qshyls+RWf3NunsLuiYJKPfwGulA6KtlnYj0FtFaTdB2jJKu1m0y9JuCWDeGsC8TaT9fB/+fuPzoTWq5fyfPn3iHfP0o6Ku1ndoATi0oLTtzgAdLG/5hkS5dtuj6qx8DFwD23+/sTLpv7sgTY0GfBbO8r9zeKzcgaRvd0F5q6PiM+tiWT7vJuh0ms+sUx9zpINYvA57D2Exn/ls392Qdg+VuxfSMB96BPfA+3sFbYVvGEUyePx+um15Mmi0+in/8uGxcidVlMGPUdrHII3HQ6sH8gHz89loq+dgTv68dr0JPCKONXxUlFd135/q8rFA3dMntCpg+Top80izSH7OIPm5G9KU/FyQ/e6n/POHx8otJ/lBD60T7Q/pNXpyPGtQeqfsB5dDHT0wog73iDo3RHnLNyTKtSsbqs5FsvF2ko17IU3JxoXZ737Kv8/wWLkLSTbQflodFZ/ZByzL590FnU7zmf27+xzpIBaPbw8QFvPZ+sn4fD+kPUDlHoQ0zIfj2wPw/kFBW+HHjm8b99Nty5NBo9VP+evDY+WuCcxpQjJ4H6UhT9H2cv+E+qBG9R7MyX8ftcvyv0eMbyF9vQ8w2ZZb/vcBJseGjS62S82WQ7J4v2iX4ukDSTFt5PPiHNqDiW5/nqzcGOCplR/IaQ/z1PLfEuCp4lGIp0rHHhDtmiba/CBhqUgb8jmGp9j+O6j9lv/OgB/2MVFe+Q7sQyo/DPPzfRJKx5Rvwjp2X6QPyb4NxhZ4rxzGFu6iNPwGC8/FboK0uykNYwsc57gF0nj8uxXS7qW02yANZd9iC/3U1iey923G4OWevo9S3fohfy3n/ySJG095/QjpdCJuoujc4UgHsSwir+ZsvKZZNm6A5UNzw4E26QwIOoxlNjl90Ccyfeqn/J8Fvf6d4fGYdyWt9RuAd4sDbWV9RizrM9MPtH2dWKMy/DrVpSS9WsjmYvt4peBuUZeGSMvrU6Szr6BTtl5TMvrpk0XxT153waaLllxxUUJPP/19Sk4Vd6V8i3OqVhO4NfrH73eld30iL2JPlOptTTpvaJPOGwSdToc630B08qY7f1IypLwm+80h5R+dNFbuzwPTnTy1Q1nDpQ6WbaOXt9x/Y079/hJMry3316gMtnlNoM53AQ2mm/6em1OHvyZXpaIplq4Kh0KxPv2UhvXGvsG0JBnjBb5jmbtd0GGsvGHS+Mou3T+UHCZDC/VYp7soDYcm5oOio8y74kOIzn5t0tlP0AkN+1VtiaozTyXSB23J98iWfAzSlEvDW8Us/z+ALflhwJZgHflvZZfzxsk8W3JnTv3+K2BLlGt4aqDOOAVkusqWWP6fki3hpaBmEvcoW8JLE1gf3mJYdizE8hM1Fs4hOp1e9lPhfrYvajnq7gAdtaRWpI9T99c0lT7yuIb5nwd9nL7/+DaqsT1mqa7TtpexYscgy79T1k6PMejOiPr1J606lf4+ANqch5WId5Yf7QrPAz5Gee8K5M2zW+nvddnvTi8x2tZbpV8HU/3K6heWj9Wv/Urq1/rsN+vXfaBfc0i/cDmA+cpLAJh3MuW9F9odiztAZdNnGeW9h3BRJhcm49truHfvP4Y/L/s9JGi1KzsY2mfZwRD1IfAb04wOv2M6WN7yKV1A2Tl2f00TZQf7l2XH8m8GXh6/f34bOczqwWd7fz+8Z7q8BPkA5cVQPoeJ76ey6v+iOjYEnQcI98FA/XmZ/l5RrpPLrVjfoUTXX/0fSwex3kp08mT3dJLdByFNya59Rqmf8p8FsvsWkl0sz7KLNpW3UKrwX5r/81TnhyCf8elcUdbyP0z5ESN9eG7xSPZ33tzCyvZT/reC32FzC2vbg4Je2ra35bQN+wOX4R4m2pb/euiP1dQfyC/rj2lJK29YBx6BunDeyYnmwUVQj7X759NivVBtTDHW75+fb7LIxxiTBA8MQ9kFKzdN0GPdfYhoPBig8YAop2iwPUaePQL0TTY+XpD+iGhbIt5NEvkfymlvImg/XID7oMBR9v1hSrtPpLHtwvaqrVhsE9nunR7QlzydUHL1UKDuj1DdHxJ1fzBQd8U/tB8hv8H+jhnra+Jvqx9+cphtrFrqxzz8OWHL/yFhMxkzb0vK+hzMmwCTt08omTkE3vFSUaifsD7Tknw9V3VHW8LvQr5MIuqAtlDJbJ4fx/xQdVDbb5Td5O03yg+P1U30p4/dRucYDzvNMT4A89ORV/kcg2Pm3TDHuItwenOMJPmU0xzjHJDdVyrOMQ6itKI5hqUZfyeJcnx8wOj9Nfi+v0p4A0AL5SZ9lkE+lMV+UT79zesKlv83Ydz70vCW39NE+aOIHsbI1FoPy8RRol557VRjGPPt/2T1npy06mKJ9ZAFIfk37AcrYsfoj9J5NX+oi7T+iLpc/qM1h68ZvP73Wa+sLvwuxpc5SuQ3XvG8uZlEPSeoKxiMtqWhbD9IaSirVodUpl8aHl+/hyrWL4Z/iN8Qae+C32X6QmHd7Yh1V0WsGcl4GUU9VD4ax25UnDntxx+T3ca+PYLqWtYOYfkydojXbSzvf5Id4uN1zSTqOSLknxj2AxWxY+1Qnk+A9aqLtBg7dPGPF1z5W8v/bPda0mpv+8S7mC3p6nMPber5ocoOsa1BO/QApaGsWh2UHao4phwawz/EV7EktkOxfaGw7nbEuqsiltmh0NoC2iH279QRW7RDvJ7Vd8BYnp/QXDMUq1b+G/uYKu0egZnSmQn3V6O9Gsz+fwuk8XqgmqPb3/gOZR3L8Dq65Z8CvJlM9cO1bGwn1k/1F+6xmXpAfr57A/lC/r1aBw/5/rH9oo4c8d4HdVwb34X2Plg+HpP2gD7YkeqCfDiG6lJ2LMXyli/m2os7RR2K5offof7sVEzH+Jtu494h+51t4160buOZF6+5at3aM9ddeNW6jX1Ug9vpb9aq+6lG6rFa8m6M2+hv3vl3N/2Ns6aix2iqnTqHwW+mG7NTB8vf1QV0jm6TztGCTqd3Yx5NdPJ2pxx6wFgZHsmUNi/P/ufdKTecMFbucLIesbtej0vG16Usn4/r0ekonePbpHO8oNNpPTie2oMjM/Ot7G4wLH/3BNMp0uvTnfT6GNDrt0TodaiNod2Pd4k2GtY9BVj84Ud1gYbaKXdXBJ3Q5Q13RdKJaU+IztZsj2GplSjsgxWBevGK7/0FWGcSljocH7okoSYwFZ3QJRm3B+jc1yad+yLpTFR7eKcOztjYdqm+uz9QByzPUb5OraodR3TybOQmspFqF0DoJIrlfwPYyGsDNpJl97XG506tBvKlg3n9+UHqT7UaGOpPyz8N+vPDEf2peHN7oD140ifGHsZcXnJfIL+KgqpxwPjLu6/Sp82VmuhPNBp+nepSkt7owXC1Uw3bhwewZ2e/s5n7gnUb5h12zMk/m7Zfd+VG5qnhTkeiyfjdaJg/ob+5XFo3Phl5v6CRPiw/D1A+7nd7z/gxdSrKW5Su9OYhylt2XMPyt+dgmc6nD57k4V2tlv/+TM/VSR7lR6ldvaExnPWO8/WJNmyXU+66RNcP27w40GbLPxJo830FbWafW/l7ajcar3RxGyYnrTKAGDH+C0bm8FJ7TMP6hSKnhwo6nY4mHkp08sa752m8Uzu3MHJ7ffabo+//ffxYuZcC491Etb9Ip7EtLFPYrrwT7LyrxfJ/Pmt7m7tD5GlZ9skGRP3Td79CfaraHupTy/8d6NNfj+jTkH6EfBFlJ+4O5Fe+TuiiFv8dNrW/iZFRxFer11V8EbUrRq1MlvVFDPcb0CCsf5EvwuWUL3JvDo083WP/gH2ZIl9E1Skvbzu+CO8mLuuLYHnLZ/JZ8VKjptXlbqiH2jWUF++ZlLTqosqv/A/E577F3SyKN6sgHfP/KfgZXx7e8lv1xTE59UuSuL7A8pZP3WxTy/nf6PC70Goqr0R2Io6dPqFbAy6G35hmdPJsckOUD8WxH2iTTmgHSJGsX5v9LvKJ/p7GT3Xx+ICoB/vGD8P4+c3AangorsZrHKGLF9WNVWq3AvoD3wnUi28jKrtKr+rDN/DYlRlp+veoLtjWJVSXsrcHYXneaaEuW5yctPKjhP2NvsTO8OtJa5ur+AeqjxRf1IWcVrYh0m6C33l0lgg6NcIqqpfjJXZWxQMp3+KcqtUEbo3+8fsD6Z1yMRA7rdPQwWN0kA19mSqY6PHQ2kziHjV1YBOTdwlQFdXC8nkXc+FwH7rIBtv8ZsIqO5Rj+bzpYH9O3Xl6Z/mb1EcV3bNlavMdm56KG3qXxZqevLvisV51kRaz6fbb9eO//E+ffvCPeAi1uvA7NhdqCvlmkd94xQdAm0nUs1RtusUQRfqgXNxDaTg8WB3Uptt7K9Yvhn+Ir5bt8LBlmb5oiLTFFbFso6yaSmwtm5QX3uW7si3/GzLdV6FOZZvUhXChixFVyBLbyDYnfZqJfn5Kj+EZ/18naOVdyjUX2v2V4fF1VRtY7XdfgEYi3tWSfN4wDXWR1KZkfN3ujqib2jKCGP059Uzfq+kNy23Z6c2doj6KzuI26SwWdEJjEv9vdPhdaNsJH6LOm36dNGesDNqTvOnX1dlvnn7dAtOvN2aYaprD00h1Uaw6DM68z7uAhe2J5V8EesWXCagLLa8GzDw56xd0099zc+qwhPyZij6H9Dk59IN8aJkG/uw5LdFtQju9AvIwD9QS1qpAfhV2Rplkm62+WcJYectnTPuBAtq8NJb3nRn8G2kvD9B+qIA2b8NShwz5YMqFc8fqsIr092Yoo/p9CWFa/rMPGsN8W0nMpTmY74Rww2qyCag7JyXj6ZX1P7B8L9xQPtzAPoGic5KgUyOsonp1INywI+XzDDfsSO/KhBtMzPFTKvx5rZsBo0+8YzHH8pZP0dmlTTq7CDohrFUCy/LfIvLvIvI7ioZVcTfKtypQNcYtEo3d6F2eaNjTRzTT3xxx4q7hOk4TGAOBNvWJd9zVA4KWonNum3TOFXR4Mf8u8o6Qfglr+WH+GpFhIHbFaN+HYy1/3mIW1qsu0mKiPXN+/Rd/af7rLz6jRuWtLvyOVVIdAjlX5G/zcwYfVNEeXGBJHzX7VNEeq4OK9lSMCn4whn+IrxYTOdpTNmqKaYsrYlm0B7++FdLlibIZnaATwgp9EsB4MyjyK5tk+R+GWeNtw+PpKX4n4t2kpNUenZP9P01gHZtTd0Xb8NOnIcpbvg7axIGyNrGetLa5ijes9EPxRR3/5s3eoSuXyh6a63YslM2hpFV+azn/Gx1+x3z22LjhuTlDHTmviqWigyfAb0wzLH7H/YLl76a0WwQdNQ7dSmnIt8WUpiJVyg6x/S5rhwZE/dSsHKORvz1H08TInFq5YLv93QPHyv3unPw28lWlKrKH+fMie38wAZG9It59pQTv0mcFtcXy/xnw7o8DvOOxX30WJXToUUX6ODpcdvM3lo/Z/Nzmimb02Gf49aS1zVXGvthNvG1ujO43eqEvgSO96YnmqYqomiwqW8f2TG2AVuMaX+uvrgMK2TNsE0ekVf0mym4qOvU26dQFnZCfGCPrio6qc5Et+1eyZWpTPdrod2e/eQfJF8CWfS+wKoV15L9j5hdGL/aTY5b/R4FVKdXmdwfqjDSSpFVveOyy/D/22WUjxy7eUKk+BdYm3ehovOHXqS5VbbDyv9Un0tLQ5szsdxbaXHLFmrUL11y5YdNl6/hCZN47hVxBVHxXS8a3HtP66N2NlO/N9PdiUS4R2BjxVN/MDe3HwDZ9LKcc8iIR7yaJ/HcRlprxWd37AuURA8uxxKhy6d+bRZmQBsRIcPp0YkbTwb1xs2I10/DrVJeqmqn2SSnviD1DLNsQabiYhGlIJ+SdItbNTljps6yH1cPqYfWwtgJWaC8dz8LSh/faoB3kmVPZhWssH1ogX9wmncWCzpAoV3VMbgTqrKItzLeyEUi1P69ohrboQE0zdoZm+T8FM7RTDxxfZzVDSxI9G8Z+MAwuix8ms7QS/sW0dJb20eExOsxX7oeQH5L+tj2Gah8579dBWYjto7OojwYgTfUR7+20/A9CH52T/Vb7uDiaGtqvhPRYDwdz8vOxNst/XlYnXKWL2ed+s+AH9uHbc+itAXr2ESkld0a7TbmbpeQO7UxMxEnZs5C9UBEtFWXllVm1d0/t86xR+cFE9wGeacL8l4k+j5XztxOm5b8isl+Nl53oV+RVzAq6OhIakgPsL47AYp/zEcSbBBb2dd6YmqfLhse6dX2gX/ksCdfz7YRp+X8xsl+Nl53oV+RVjJ+j9k+G5ADHB+OJiqzfRmmhszvKfqMcxPQ59k+e/b5J9LmK4A9E1C9v3+ms7HcWgTtz4xVXrctCcAk9oZBZ+nfedtmZonxCZWv0bialKfOJYbDFObQHEx2yYvNp+T8qWB4yv+kTs6Uau7sTQVzD99pSXWTWOFQUUrPQVGYriGr6vDmnGjVRPiGsmniXJHqbs9qrF2PdFKvUXi3Mj6cRMP9IYORQI2Ho0iPluePoaPVR7ecLf7Fc0SkaFqO3U1st/1ORI5rTzEeOaMgj7kMVWQidQFbr2Spa2qD8yHs1ovGpqCI15FNzSk7VzErJS8gzC/FHyZfa16D2VoRmwXhhX5L4zoKxPSwLob5Nn5gLx7C/2WvFvQUceUJd4ovTQidQ0yckCxjt4EjI7ZG4lv8uwFJDOM/KLf8XhQ0wTLUiF5JHxQt1iU3o8nf1+U3cV2DYCeVrUx6nekZl0qeqrqpVHt47jmNBXhQH+Y17ISZqDxaP3+qSSnVLA5/n+BpEjb5DOqJ0PNQHav8R6j3bS/UJ3BDWrQHa6jLmBwK0sV55n9BORD3xwkmjZWnGmzZ1ZUDpCtpn1pWQLU6fGF6pfmpQfuRN2f1g/Onx2P1g+Bkxlk/lL8aODbjv8iuku52O2rNP/EMYI/gWjaK9tVfnYP5HYNxRbQiNO0URctYttH3sZ6uopLJ9bBeVvVZ2hO2i+hQz5s/7FHPfQVv+b/Nzn3K/Fds6vFhX+V68B9jy7wynwQcP0pgDJTHrGU7RnMXJ1vV32tYVjUm8TxX7Jm+/IWKpvaisZ4OJni8ZHq+2zYY+4Egb2lu2qWhv2abeJeiGzhqkfD86q4fy13AFa1eSPTVfxrIse5b/OJDnPbLfnnbjY5SWd4E6y1RIztSqoOVT8mx2oM0939F72vlTwRX30NdC+qdiBm3azdE97cpXUf2Ae9rzbgYxLLx9wnAtTyftWigWU8RXPh+EbWR9RhvBdiDGJ1P08nyyo0n3vXyy3yafDPWL9V9dcq90nP0G5CH7DeqjRWiDcMzG/AvAhq0g3ihZDsVY1K006rPz05JWWX8oAisU63tY5H8oQBvrhWWZdp5OKl003nRiPoV+AetiaC6ZPjG8Uv3UoPzIm7K6y/MwHN9Zr1G274c2r8gZt7EdOG6z7qoP6KE/YLKBy014WxWmIU18x+Mslrd8is4ubdLZRdAJYa0QWJZfra10+HoVq+LrKV/odhvGrdE/fv96etcn8uKjumkgp95JEtdNWD6vm9CE48b+M6leGIY+i7DKbj7E8nm38/Tn1J2npJb/F2lKWvHqlbtCx8faPOZzV43wkkS7pXnfqcV61UVazNUrv/z0W6b+2W8dM3p1SOwRfMuvwvJnifzGq4rfUvtoKNxuaSgjfC0Lyr7VQV29UvFqmI/G8A/x1VDEV6+0c7XCmRWxYq5e6bRN4qnu+2GKbyG/ia6LuQkf7oK6mDtzaxfUxdyaO0RdQuMBhlB5bMG6hza9T9Tm+pVt0lkp6HR6c/1KopO3ofoRcmtvgTQVQr8i+82bV5fBBZ6Pkkur+FwTf4f8Dq4fHkvGPHfm1O9JkE8+lqzafEWgzhiKTAgj/c0+ieV/lnySisd1ZZicD2WG/JWKdKN3tBm+17VIdxI9bl+1Y8m8zRu5gqj4rpaMbz2m9dE73rj2Jvp7sSiXCGycKahR/FaBaZoXOkqsRvhEvJsk8t9JWOriMat7X6A8YqjFUcNQ5dK/LxNlQhoQI8HpM9GXNplmVjwmHP1lY/4sR0Vvd1QzQ5ts0ofbrj4RohYFeHZa9ZMT6e97HbHud8R60BHrdies9FnWw+phbcNYamNbaNb+zuz3RM28FJ0z26RzpqAzJMpVHfsagTqrT3cx39QG1NsDdLD87dSevJnQ9w7SNGNnQpZ/AcyEfnjQ+DqrmVCS6Fkn9oNhcNk2F3umqMUe5Cv3g4r2Yb9dnv0OHXVSshDbRza1qhFmXh9Zffis0Bzoo77stzpeG/MZAUWP9TD2+K/ln5zVqej476059NTx3/Q5NYfeENCbgOO/M5TcoZ2JiewoexayFypypBYL+Thh6Ahp2aPB6jhh6Giw5d9JyIMai/oj6qf45nycMO/ra9NF+YTK1ujd9Bwsw0nf4fQ15jihOjHMJmJPwfJQl6VP7zjhq+444ZtyqlET5RPCqol3SVJ8nJBHlRCLFauqHkQ/RIh0yMIqDyvkCWD3ho4T8tZCLHdrDh11QD59eESz/EdFjmhOnpQc0ZBHMVvjVeTE8hdtK2dVC128omY2sWoYe5yQPTXv41ssXziCh45vhbxqp+NbU7r5+NbtlIbDEV9VHXvsr+i41/dy1pjycHk2q4514BB+dfab11tWCBtgmCqSHpJHJb/q8wOhK9nVtcuh462Wr0153E7JI7Y/ZpYX2gMSq6uNpFXOeDsujgU8ThbJTUgecY3vEVqfRDpLiWbZPRhLRf0VnV3apLOLoBPCWiqwQv3d4S13VsVdKd+qQNUYt0b/+P2u9K5P5MVHddPNOfVOkrhuUuKs6Ay0SWcgks7yNuksF3R4K8jNmdltc3vcB2IWzCpuJ/tAjfCSRM+mDH9I0LN61UVazNa7f2mc9cXLfvDkJ2pU3urC72J2Ui8X+Y1Xj0D5ErzarIYmo6223j1EaSibVge19e7hivWL4R/iN0Qab72L7YuGSFtREcu23uHQOdE2g7fe3Q4uFG8xm6i62Na7j3VBXWzr3f1bsS6Kzplt0jlT0PHc/NAI1Lko6P94zlQyNuhv+a+F77k/RUH/UHiGx6/0f9yIwvpu9HCLmvruONfvOZAp3qJ2p2jz5YE647fSmW76e25OHT5JY3fFDSlyixpPy7E+rCdqg5D6EoXSkzsDdM5uk87Zgs6QKNeunqg6h/yhqnQQy3ROnSJ+K/zGNKPD75gOlr87QOfmNumoO4VVuAynkrw5yfKkT5tf0+qP6RfEr1NdStILfk1LbYTgE35YVp3y5xCRujFAnf5TWDc6YvHGLCU3bxVYZfnlOAW2Kq6kfCtyqtYncGv0j9+vpHd5U2DDnqhLXSZK9Ytci6/N1TTzXAv+qK7ln3fIWLmvk2uB9VqQjKdX9iQBlg+dWOAhECOOHI28VWDWKA3rd2ugfmolp0/QUeYXo81sfid6x/rt1egFd6yr1TQe0rGs2kMTc8nKAkGnbL0czZxV8UDKtzinajWBW2TmDqR3eWbO/p4o0Vd0FrZJZ2EknYlqz+1t0rld0AlhLRRYPfEeh701P+E5USMIBiWKRvnJB4+vU9HOTh7lLf/JB4+VmwK/ea8HYn00GZ+GfLyD6q922toIyOfkmknUEz0CGn6d6lJ1BIzdsVfuzBZPGZAriIrvQprCu4NYKweoXJUzW2rVUn1yQPlxt+SUQ14k4t0kkf9mwrpZlLO69wXKIwaWY4mp0XvUto8I2rwndY9Mq9Jw2CeGx/Ln0UJ+FO275DxcB8u/N9SBQ3J4M4VqF2vzLfQ3WoLJOfSPBivzhoM1/UTQ5/ah9RzMqW/eJfRzgAe8EVJZ/iTnHfIAy+b9jXl5oMe/lSx+hPLfVtB27n/LPy/Q/zeKOqD9WVxQB84zKacOR4o6CKu58Iorr8vZA8lWjf/mXuKeuFHg5D3GjZ9fd5bVnLnD2sF07G8lAWnLZ2e/R123y9ZtzNv/ySNCfw7NSYl+hhJdt/TZWlt6b6xGL7ilF9tXdUtvnpYW0WlzS2/eoK2MBZdPqGxNvEsyzIFsUWNrrl/c3CYdFSRirDy3+B3Z737KvxQMFG+zuxPqwZjpk7d2hu0p+503FUwJ3fIfoq2++W357ylZ11CMGemr4Oh9Jeu6fILreqeoawfXVaJN59ZaVyk3rcn7PkGNUPFdLRnfekxjC8lThUX0d5VpjVqtUXewhr5fEJKsRLybJPLfR1h595v35dBTPYrlWGJUufTv94gyIQ2IkeD0yVup88B6SGC1uRtr+1jNNHy1e66KZobuYE0fbvsjoi4NkcYhh0cEnUcEHYV1ryPW/Y5YDzpi3eWElT7Lelg9rB5WDysSSx1+4zujcdcIX92xNXZuDrdJZ1jQ6fTOzWFqD47dzLeyO6nVRa1qiwAu8Dx9sKaJM1l1TUU/5d/7kLFyzx6c30a+XLZP1LnNQ1tD6tAW+jjMZ6U/6MO9L/utxmw+hIV9jTv9Q33wCvVB0TcArT79lH8K9MHnqA+wPH8XSOmNoscykveZYd75bfl/TYTDVf3uyaGH/EA+vz+H3hdEdEXJndFuU+62V3KH+spyF+t3x8opf18Q5TTmgKr6LkeNyg8mug8Mj7d3/S/R57Fyzv1q+f8osl+d7Mn2ZQ+Bqsha6BCokgP17cZG0trneZFIxMK+junX2wU+9+vXAv2qNglgPblfLf/XI/vVeNmJfkVexfRr6KIHNX5jv/J2NRwn+bocZaNDEVbVr+pKU+7XbwX6VUW5Q3bY8v9TF9hh5FVMv6qVgNh+ZTuM/cpXJOFYx7o8UTb6R6LPlc9/e0T9FN+cr0i6L6cas0X5hMrW6N3sHCzDSd9hWDVvb9pgokOgzHLL/5PAzoA7Rfn0idntW/HAcPSigOF77fYNuZ4/r1j2v9rty2qmFq+4n4roOF+RtCinGjVRPiGsmniHaUpUq1wxMplmCihCPFNQlk95/pbfPNA878Lw+in/9Gwmo0ahkBecPmytPy7yo2ds9VHt/zilYbl7cujg6IiWn0dHy78jtDU0OhrtToyOyCMeHUcgrU/kZ34/KvKPQB6OKj0KaazSyOOPE50i08Hyr+RUzb6VNx663qZoVsbyhTLxCKWp2VzoDoFOREqwPSwLIV1KH+bNiMiP/cgzmxFIYzlBvXyE6ITsUvqEZAGjC0+TLVRXgdUoDWmGLkzG8vy1aqRzc5t0bhZ0GCt2n8roF3OFjTJMtQoc2h+hVr/RpePrybANVnZI0K7l/G90+B3zDeswQHQ8Vo6VR81R54cc6aCduZfoPOxIB23W/UTnEUc6asxW41e7dNA+3Uh0RhzpjECeB4nOo450HoU8fO7+lxzp/BLk+RiUS/9+DNLUra+Pi3rYlOYJeF9ibIs+P274dapLSXqjU5oniB63j6c0T4q6NETau+A3piGdJwUdhXWrI5b17bSkta+PJTqPCTqPBegcG0lnfpt05gs6Q6JcuzqieGN0nnCkgzozn+g86UgHsVYRnacc6TwFeeYSnbtFHdLx+9pDxsqk/56GtD5R1vbT9lP+neHum3dnmCaDaCuwjlge/avHRTuY3uaMhtm/Z6BMCXsk75ExrCLevZ949zikxfDO8v94/li5G4h32C7W7U9A2hOU9iykPUlpz0EaYmBaAm3AdyxzWN7yDYlyPF49D+9L9NdAjG4gfj1pbXOV8ep5oodtTx/ji7XvhWr0+o3ei4Ke6ofpieYp0jcsviYV7ewzlIa28TlKw3HtWUpD/T4IfiNmXpt4Ry/Wj+Ub63cfpamdwNPo7/T3Q5Sm7vJTMQeORyA/OBaG/BhJxh78e4BopI/tOOqnvE/B7oXHst9sp5T9f1xgW9rTIi3F/+Lh49uCtgj5j2np0yfehcZey6foLGqTziJBh7HwgCXOlRdDOub/Eo09aANL6PpFxv9n4SXbyYp266JYO5lns7FeyobG3D/a/6XHvvDLl/xgWdmxJWRzF4n8bdrcC1Ts0GhbGvonz1EaxqysDur+0Ypj3gUx/EP8hkj7Bfhdpi8aSb6dbheLbXW7WA9XxLJ7UdFnYr9IxbtxPAudRnk4pxznQ78R24J0QjG9rRULqHjGKhgLwPZxLECNQw2RxutyZccOxHrIEespao9HPFP5RSdSnRWfnwjUGcsznx8SdFT8D+dLf32Irg/KPZbl+ZLl/0eYL/0tzZew/SH/jmMuZXcRHxtJ54w26Zwh6HQ6Ds4xl07FKM4gOs840kEsjrngvK1dOjhOsM89AuVQD/6d9OBZSFN6cGb2fz/lvwX04D8DesBj2bOAl4j8c3Po/YT83oq+qYy5sB86AvnHfaDx0PFtqWpDLgfe9WWYMTYEfYSnKA35wXMa9P0QA9MSaAO+Y5nD8uincjn2Cyr6x9ExF8OvJ61truIXvED0sO3pw/7/i9XojcZcXhL0VD9gzEXFWRCLYy5oZ3lMRdvIvjz6DxyPQf0+CH4jjbw2sd+q6heKvU8Wde+Ez2n49aRVR6vI1lNEj9sX8jmtrOob/s5Dt/icHM/aGr7Q/DbpzBd0Xiu+EK8/bSu+0FE0nhf5Qjyej8afYTw/NjCee/lCJ2Y0tqYvNOzkC33vuLFyC4l3I1Av1m3kE/tC6KOwL4S84jhy2fiPWqfYVtaf1Hj1alp/Qjs7QmloG9nfwXGN159CvtBIEm5TyBfCsvi3rd08Bul5azf/B/TsrZmeKR23S/XZ70I6KcZ5pKvIF46rlvUdsDyvh3uMTWoNm+NVnxB1/kSgzlj+E5T2jKCjxnS0rxcfquuD9hXLsn21/L8P/X4p9RnKeWgdjH20sv15bCSdM9qkc4ag00mfBtvWaZ+G41XPOtJBLPbRnnOkg+MQ+2j3iTqkMruZ9OB5SFPxeo5XWf5LQA8+ENADrCOWRx9N7XViejeSj1ZxTJQ+mmEV8e5m4t1TkKZ4xzbE8i8F3t1WwobgmPwJSkN+PEtpGMtADExLoA34jmUOy1u+IVHO+Gv99RK874SPZvj1pLXNVXy02PiRte+T1eiN+mifEvRUP6CPhjxF+obFPloo7oG28UVKQ///BUpD/WYf7ZmCNrGPpmQ/NN60uWcjOl5l+PWklY9VZEv5Qmoc5rEJy6q+4XjVs4KOirkqrKccsUL7r9gXUmvzDwfoHBtJZ36bdOYLOp0+W7K14lWd8LnSh32hTvhc6e9YX+g3aTx/DtJixnPL/y/HjpX77cA8jteKngO8ROSfm0Pv98gXqhj/kL4Qr0Hl8e7LxLtnIC2Gd5b/T4B3XyHeYbtYt9Hf4XgVjv3sJ+GYiRiYlkAb8B3LHJa3fEOiHI9XFX2FaF/I8OtJa5urjFefJHrY9vRhX+hT1eiN+kKfFvRUP6AvpPwfxGJfCO0sr8+hbXyJ0mL9JPaFnipoE/tCWL+ncrD64d0IYK2kdMv/z5l+pbr294eO5cc8FgPDcy58++InAF/Vke2W5f9WRjPdT/krw1t+s51R4yvaxIMoDf3PJ6ENG+eNz6fGNJMd7LdO+I+897aivzqqj8oXU7E03keAZdV87hfhN6YhndBeBsR60hGr5z+O0eF3ZfzHTpyDw7ZNdCzteUc6KG/sP+bFlKfMGyuDY2JsTNnyXwU+0LQMU8XUOXbzAuAlIv/cHHqzMhpt7rWR/iPHhPJ4tz3xrmo8/izg3U4B3oX8Rz5Th/zgWFrPf4ymt834jxyTQdvI/iP6Guw/on6z//hkQZtC/uOTOVix/qPlP5TsRkU/RtoNwwqNVVsr3vdkNXrBeJ+6a6BsvI/PAbUTo3vCEavnr43R4Xdl/LVOrX1uq/7aGU7+2r8fM1ZuOfkcat8v04udN1v+syfQX1P3W6TtXEW8U2ufWDZv7fMvgXdvI96hnWXdRj5VXfvkOErZtU8sv62tfaJevBrXPpU/1O7aZ1l/LbT2qepXNjbGdhD3muBdABvn6brm+YNnU7rlv27eGOY1FG/D9twHtCcdNh7L6v8LZOMqnkGQNo7PaKp1tDbvnon2LQ2/nrTVzlFdVWvsSlfZp8CySg84Flh2/566S8YDK3Q/CPuW6p7G+wJ0jo2kM79NOvMFHbXeVsv53+jwu9C+T/YtO7V/77W+lpznHz1INlWtJYf8I8t/PfhHjwR8y5i15JBvafkfI7vbybXkPN494eRbnge8ezrAO9bt2LOeIb+TbZw676hiXmofFe9HxHI8XlX09aJ9S8OvJ61trjJexZ5FaNN3HvUtY2OP6Fuqs5+Ixb4l2tnQeUL2H1Vsv+paMrYpdH9J2bVk9v0s/2+S3ajoN0Xd2TcC+Vn+J/qs6kg1esGzqiPwrupZVY4FtnO+9AlHrJ6/NkaH35Xx155wpIP9y/5aJ/YYpg/7a53yP2P9tW9ErD+GfA7L/5Ojx8r9XSCehXXE8uivPSnawfS+SXa34t4VaXcNq+is6rdz4gexZ1Ut/98C7/6ZeDcC9WLdVvdHqzXf0DlWXhMru96h7s0MzUXaPFsc7a8Zfj1pSz5Gxyt1hletXbU5fxj112LvCUF/DXmqzq2G/LURSkPbGLoPNXQmMeasKrYp5K9Z2di4WozPVPG+jWmxMmj4Xj6TuvdkBN6ZTEz52b99s9/Zp6wWrdu4bNMFl62/8LR1121YcPnaZWuu2rh+zWUL1q69at2GDVhpJDQV3mM6PpzHfj8g3iPGkwWNYWHAzmKjVeRMLicsLM8TgWcKsFYQljqsw38PJK31tED0pAgcVLS8ep1J9UJFzLsgQmGlv99JWFg+L+CSh/UBwsLyfAgUg0VcT+ZXCCfPgI5Ang9SvfIO+qf/XizAuo6w8i5QSv+9VIB1BWGpSTj/PZC01pP5FcJJ/32yoF6XU73yFp7Sf58qwHofYeVtOkr/fboA692EpTYt8d8DSWs9mV8hnPTfywX1uprq9WlIe5nSsFyd6IwE6Fh906chylu+0GDI/xsdfsd0RkSdh5JW3rRLB7FWQbk07RUoj7Y1ZoHrM/C+EwETw/da4PoM0eP2ccDks6IuDZHGQY7PCjqfFXQU1pOOWK9Qe/IOYC04bDxNdWFQ6ACW5f8yTMJOzjCV7/EytVH5MU8IejVq16DIj3j9lH9xVqfXJa2f6n1ZlFfYOJ7GbDBE/eqEjhi+1wbDV4get4915DOiLg2RxkELpYufEXQU1iccsZ6g9uTpyDlOOvJp0JFzu1BH3u6gI+hDxehIxYWnaB3hhad2dUT5siEdeUXUpSHSeJOf0sVXBB2F9YIjVqyOXOGkIw+BjlzVQR0xfsfqiOW/xkFH0G+O0ZF2gmGIZ/XBd4jvpSPqkF5IR14QdQkdbqlRGtIJLY4j1icdsWJ15ENOOnID6MhNXagjHympI6ruI9lvz7mXil8dDr/zeBT6oOPhoj1qjnc4tSdPRu47TNdHyUj62+bvvCiyAWTkwYCMjCTj07DOvLBqaUkSN5c+NpLOKW3SOUXQ6fScfaIOxZ5CdDpx+CF9eGH1BUc6aCtjL1V5ifTgRUhTemDxon7KPxv04NMBPciLWcZeAmz5P5fRaHPjkVxY5cOdebz7Zadx5kdHjZX7tRI2BH16tvHIj+cpDcdkjvuq+Cq+Y5nD8pZvSJQz/rZ5aDR6YdXw60lrm6v4WrGHHqx9L1ejN7qwquYSqh9wYRV5ivQNixdWRyDPE5SGtvGTlIZ+Mh+YRf3mhdUnCtrEa2kjon6hDTaTRd074ccbvtcHEYr8xdAFIewLYdoN8BvTkE7spR4jjli2xrA1faH5bdKZL+i8Vnwh3mS2rfhC3y3hC6UPj+eW/z4Yz78/Ab7Qf3SBL/RfTr7Qu4F3/9PzhULPq8YX+nQ1eqO+kFrDLuMLqTXt14Iv1Cfqh/lQ91Q8KRHvagF6TGOSKPshqjemnUc0ysaAzhP17WBcty9Wv14tcV2UAUxDOrGx2BGqwwiUY/5X9I8rfxR3pBq94AbG8+Cd0ybavlA/hDbtVlzLm2T0Qnu7kF5qTweT1j4s+tgM0sD+ytP5EXhXZj/l8wVYof2UeZd95GHxfsq8jcuYtjALRqd2+PDDx+exvYBHQ54js9+sU8iHNN8Cysf7CtPH42NEiJckWvcM3+tjS6of1IHDVDZfl4RlBPsob5+pujAiRmaxTjEyW7ZP1abyNN8pgXzPiHyKVvo37ns2DPbF35xhpHz+9eHxbQwdUix7YCt02Ld3AC2fTugA2gOOdFBWODbwhCMdxOLYQKdiHbEfS1x9+FgZ1rXQeMEXp+wG89sLMky1R5/HumcALxH55+bQuyijMRGXAI5AfuTdeuKdujAAy+ZdGPDTI8fKXRbgHes22v4HKA358QSlqQ8p1igtgTaEDqCpDwtsKwfQ1OHjV+sBND7UjbaRD6ChHxC6dJRjAw8UtCl0AM3Kpoer9sh+jx2uOm3ddSvXXLZ+7ZqN66+4fPm6d21at2FjPyCrkYMtPFtivJIg76nR35Mo7T5KXyby4RMaTbfW1VD3VaMXvBpKeRllr4b6MPzGNKQTe53Tw45YfNy3d+1oPp1u+MxQJ64ASJ9u+yz2CHkrD0BajLdi+UfAW3mMvBUcNXin/QjgJSI/e3qW/2ny9CpG3aSnx6vveatAn4jgXWgVyPJ/AHj3PPFOXa+o+Mr2ZQTS+Noo5BViYFqShFfnlUcwAbsWoj29idi1gL4De3rtfLYl/ac8S9UP6Ompax8QK3Tt6H2UhraRV4jQ1xihtNBnsR8oaFOMp2eydbegY2mPQ9pDlPa0aHOqd18M2KzTI9qhZKEhyvOMDOk8kv3upzb+Ndk6/Fx4Cdk6ITRWT6Y6lMWO1UvDHxL0rF51kdYfUZcfzRqe+72Rf3uwRuWtLvxuEuCjLGP+00X+Nsec44aARkK0LQ3Hw0cobQDSrA5p1PKl4fH1G6lYvxj+Kd3HNP7cZ2xfKKwHKmLNSFrtnOmO6R/akY9nv0NRxTZ1MHq+Zfj1pJUHVcavh4hens1SV7lYWTVu8FW8ZecUiHW3I5aNAaqfeb51t6Bzd4DOsaLOis78NunMF3SGRLlazv9Gh98xHcUbo/OQIx3UGZ5vdWL+mD4833rEkQ7aqNhddz+hOcPHIS1mzmD594E5Q+2ILb9DPgXTi51vWf7BjEabY4ucb41kv4t4N/mI8W2pOt96HfBuSoB3rNsfhzQeR0Ygjedp6CcgBqYlSdx8C8tva/Otj8M79sXauWo1/afikWXmW+qmKJ5voZ19gNLQNvJ8C8e1EUpD/W53vqXq1/OF4n0hvua2Hf/lMUeskI/S84XG0+n5QkklOlV8oRNpPK/qCz19xFi5BRPgC72pC3yhNzv5QrcA704j3mH8jXUb+cS+EPoo7AuNQBrP6y0tSfTaQyj2bPk6uEM32heaiB26odhzOycC03+x18CjL5S3K5HXy5Wd5dgz2sYRSsNx7eOUFvKF7itoU8gX4nV3jBtz3nuSsfZi3gtAz248Ip/Wo1SPeyDtlygtVj8RA/mLtgLzv4PaYPnXZ/VOY41fGNaYkxIto2Z/VOzT2jEZ6FpaCfn9Qlqvjw6P0UF5SR+Mm6K8JEnYp+LxAvOjzLFviHaQ/Tklj+hfmDwqflkdO8EvrEMMvzB/WX6x3iO/Hics5f8iD0P8sjp2gl9Yhxh+qT0usfwyHih+PU1YRXOcxZTfsAcTbRMMr5/y3wA2gW/lCdn4ewQ22sYaYWA7+kU7higNy6a4X8ucuYmK87CvWXTjjuHyjTt3wrjxBPFGjdMqRmL5Q5/jw/qoEyTPRGA9EKCt9k6FPsWirrPnuiRJvr+h7IDxpk07MKDsAMar2A6oflInnkK8Uv2k1tx5b1xszIlvVoiNOeFJiydy5iTYjjybzfqA8xme64wI3JDsKf95BPKw7KkYq9J/thuo/2w3Yj8fzHaj6k74T9MctRM74Vm++xMt33k73H8fbNtncmzbQEnMz8N4dPPwlt+h9fY2bUG/sgWo72wLQjY4fcrazdDngnmtQfkXyFP2CUayvwdFfsTjvXm/E+kT8O7y2Bh4aN5n+pDy/ZtZPYr2QP4ByR7aNDVXzLvN4R9Bnv+Q5ngjUMeqduMRSlN7tEJjjpIztXt/Aj5JHB1LmYhPEqt1njbt5mgsRZ2cUf2AsZSi05tmqybariGfYuyaWmtSewhZn9FGsB1AG8H24+EAPbQR6It/MycGje2I9Vkwfn0i6T/qF+s/6jjrP8o7+w3IQ/Yb1CfjRiAPf1rT8v8b2LD+I8djKlkO+bHPify4L3WE2hP6LHfsfljLr07LPxegjfXiG6D4xLnSSaWLxptOzDfQL2BdVP2kzqmEeKX6Sd0C8xylxeounxDD8Z31GmUbT6KyfIb8/PRh3R0RdUV/4NUWK5gG+1r2It70YgWt9ezFCsanTWSsgOXTK1YwuRcrKB0rOCTri26OFZwCtu2wHNtWNlZwZIbTixVsvVjBMPTB1owVXJjVoyhWsCjH5ygbK3gHyPOp2e9erEA+vVgB0evFCrZOrOBC0n2vWMFP6OzhqyVW8E6wYZt7sYIW2nk62YsVlNNdj1jB5g7FChbR2I2xgtDeRz6v/4Sot9L5vK9G58UKDLef8t8Muvsw8Ubpzwi8K6s/PGdS+hPCCs3XXhD5nw/QxnrxDeysy+oMfQfHUam7qJ+suyGbmT4xvFL9pG7A5Zt2UQc5VoDjEN8SheMQ6zzKNo67D3coVsD3dzxRgMv8DH3JQo0bD4j2Kf1nu6FiVqFb25Sss92w/kRZxfwcK7D8z1KsoOKNqzJW8ALVEe+tUPLNcyvL/wWwbS/k2LaBkpifjIwVWD92wqdGfWdbELLB6VPWbrLeYt/wvv3YG9xYzwYT7UMYHs+ZfzUQK0B7xH6GumlS2SO2Y+o+pZTv36BYAdoNjBX8NsmeiutjWZY9y/93IM+/S/6Gh934BKWhHeCbOdWYo+RM3fyHYyiXMzvQ5k2J0bECvsX+uWr0St9i73FTdfrvRUFP9QPGCopuMg/FCjpp10LrIUV85bk7tpH1GW0E2wG0EWw/ngnQU/M7tBEhGzkicNV8A32WEYoVhNYKUMdZ/1He2W9AHrLf8ALURfk8OGZj/m+DDfsx8UbJcsiPVTf6vwh5eB0GZf2lCKxQnEJ9JeelAG2sF38V5yX6W+mk0kXjTSfmG+gXsC6qfsL8MbxS/dSg/Mibsrr7AqXh+M56jbL9PLT5xznjNrZDxSvZH+Ax/7dp7O70Lc55Y3denM9w2fcdhFu8dz5qPKayz+oGZLYfmF99eS80Xw9hhdbHQvKraGO9sCzT5npaOaW7xptO6K7n/EDxSvVTI2nVa9bB2BulWT9Rj0I3SuO4y/JZdJY1NO7iujLf6h7ad5E+zM9QnFXJnrpBXel/KLbGdgNllO2G+som6xnKKubnWIHl3y/riza/5CNjBS9SHTGeoeSb51aW/wSwbXNybNtAScy5GU5RrMD6sRM+Neo724KQDU6fsnaT9Rb7JmYvGPKUYwXGo8FExyxxzwvmPwb6gGMFaI84rhl7wz3vnVJf2Uj5fm5WD7UWg7GCk0j2VFwfy7LsWf7zQZ7fmP32tBsct1Qxo9CYE/pqrloXUPJsdqDNuXR0rMDw60lrm6vECpT+qflOm3ZzNFag5jiqHzBWoOYiiBWKFXTSroXWQ4r4ynN3bCPrM9oItgNoI9h+hPYxqFgY2oiQjRwRuMpnwTXP1RQrQP0KrYux/qO8h+bW7De8CHVRPg+O2Zh/Hdiwa4k3SpZDfmzRfJ1jn2q+HsIKxSnUl2M/GaCN9cKyTDtPJ5UuGm86Md9Av4B1MRSjSZ8YXql+alB+5E1Z3X2R0nB8Z71G2cYY2LU54za2A8dt1t28+OFJNHaH1hVRFqp+DZrn1p+Cuqh9BTgOYP73g+7eTbyxLxMnSZxMvCzy49eN2YahTLwcgRXaE/SKyP9ygDbWC8syba6nlVO6a7zphO6ivrHuqn7C/DG8Uv3UoPzIG0sbgTSOD6IOforSYr9M/UloM8tn0fp/aF8B7gnir8MrWxiSvaIxi2VPjVlK/0coDfWf7QbKKNsN7Fu2G/zFcc7PsQLL/xjFClBG2o0VvEJ1/DTUQck3z60s/+fBtj2ZY9sGSmI+ExkrsH7shE+N+s62IGSD06es3WS9xb7hmI6KOyBPOVZgPBoU+RGvn/K/HIgVjED5T1Pd0R6xD6Jix8oeYazgqxQrQLuBsYJfIdlDm9YnyrLsWf6vgTz/OvkbHnbjBUpDO8C+tRpzlJyptSIcQ7mc2QGzKyiLnYgVGH49aW1zlViB0j8cHzhWUNFujsYKPiPoqX7AWAHyFOkbVihW0Em7hnyKsWuYn+fu2EbW5xFIYzuANoLtx/MBemgj0Bf/Kum+spGxPgvOz7+b+SxKx0eS8Wmo46z/KO/sNyAP2W94BeqifB4cszH/34IN+wHxRslyyI/9rMj/GcjzErUHZf2zEVifDND+nMj/2QBtrBeWZdp5Oql00XjTifkG+gWsi6qfMH8Mr1Q/NSg/8qas7r5CaTi+s16jbL8Mbf5BzriN7cBxm3X3JVFX9AdebbGCn4Duzjh6PKayz6FYQdn5OtqwVyKwQvO1kPwq2lgvLMu0uZ5WrptiBaqfQjZW8Ur1UyNp1WvWwRFI63SsgOXTK1bwy6/xWEHMmI+yivk5VmD598z6wvxPlJF2YwWfoTpiPCNmXm/5j8zqmPbx3jm2LTZWYPn3zXC2ZqwA9Z1tQcgGp09Zu8l6i32ztWIFh0IfhGIFHNf0jhWcmdWjKFZwNMle1VjBSpDn47LfnYwVoB3gWIEac5ScqVgBjqFczuxAm3Pp6FiB4deT1jZXiRUo/QvFCirazdFYgZrjqH7AWIGaiyBWN8YKivjKc3cV0yw732D7USVWcCbpvles4CWnWAHKO/sNyEP2Gz4DdVE+D47ZmP88sGFXEm+ULIf8WI/5eggrFCv4vMj/uQBtrBeWZdp5OjnRsQL0C1gXQzGa9InhleqnBuVH3pTV3c9QGo7vrNco2xgDuzJn3MZ2VIkVsD+gzjYom1Cj+mL+0PykaO8oz0+UL6T2Go3k0EGbgH1ydfab9xq9O9KnNtptyvu0Tu+jKZoP8tkZtN2852UE0vA8Eo8NeMblPhobMBbFezLU/lA1T2bZG8zJz/vJLP/NwmcPyXPo/FdZecY2tCvPqBvvprZa/jsmVp6nbm15ZplFeeaY0Aik8fzRK57zoS6U/0e3Ifl/usvlX80lQvJfFCNh+Uf/bWvI/xUl5P+VAE0l/9a2PPnHeCLm/1xA/hV/Q/JftEYYkv/PUhqWG8mhg/KP/c7yb/l/I1L+jXYn5B95xPIfmjelT9m5Dq8JoP8ekn9er/WS/3NKyH/I91byb23Nk3/D43j5HwXkX+lg6Bxj2bUubMNnKA3LjeTQyfPnWf4t/19Eyr/R7oT8e85fi+IM7M+jboTkn9c5vOR/Ack/9hnLRuw59pi7K6wd6szmCOTBe1Ex/7cgNvTfNEdWPlLojsQiH2mE2qPmvCGs0PhUdDfGCNHGevF9FC/S3+r+mA6e/xro9LlWxSvVTw3Kj7xRZ05YJ9EGsr8We1cenhf774gYzgi8C50Xw7n7t+eNx322ALfsHa4c/1V3uJY9q8Z2A2WU7YY678d6hrKq1t54vlE/Zsv/tr6BMlJC1uVaNN9V8wLUQck3r91Z/j2zOqZ9PHSMxhwoidnIcIrGWae7avo7fVdNkd1kvVVn02r0N2Kp9RvWs8FEz3X5XhbLvwv0Aa9Foz0a7bOk1R6F7srjM3eoM7gWfUJWD3VGF9ei9yLZq3oX4zDI8z7Zb0+7wfdhoR1AjLwxR8lZQ5THMZTLmR1o8wx49Fr0qD1LWttcZS1a6Z86p9um3Rxdi1ZxQtUPuBaNPFXrJaG16E7atdA9PkV85bVhbCPrM9qI0N07bD+eCtBDG4G++Amk+8pGqnv9+I5ALJvifiPzWZSOh9aWWP9R3tlvQB6y3/AS1EX5PDhmY/5FYMPeSrxRshzyY4vOmfP9QeqceQgrdL4+dFZU0VbndrguSZKvk0oXjTedmG+gX8C6WLQmG8Mr1U8Nyo+8Kau7vL4de1cext/fmjNuYzvUPRvsD/CYvxeN3aH78MreV6n0mu+nKVozzrufYi3o7jXEG+/7KXjOpPbvhrBCsbwiuxE6H9C7nyK8rh57PwXfh6d00NLU3SmWpsYcJZ9F3xcMjbt4H94TFCtQa5kh2QvFapTsKb9Z6T/bDTXnV7oUuouF7Qb7h5yfYwWW/waKFaCMtBsr4HEcz9wo+ea5leV/EGzbjTm2baAk5i2RsQKncby/0+N4kd1kvcW+4fmjGkuRpxwrMB4NJjpOwfcvW/57ImMF7C+gPWJ/QcXvlD3CWMHnKVaAdgNjBQ87xal+FeR5hPwND7sR8q1536oac5Scqb2BOIZyObMDZldQFjsRKzD8etLa5iqxgti5e5t2czRWoPxw1Q8YK0Ceqvt7QrGCTtq1UAy0iK88d8c2sj6H4oloI9h+fCJAD20E+uKfj5hvxPosON94kGIFoX1Las6vdJz9BjWf43Ejb09T3jnZ3wYb9hfEG+87tXgfftk7tUIx9qIzuqF7hnp3aul+alB+5E1Z3eUYA47vrNco27i//C9yxm1sh1oLYX+Ax/yHA7EC/u4F6nXofsfQ2I314DaqWAGuH2L+vwHd/T7xRvmRIf0pirXxnEnF2kJYoflakd0Ine1jXeW4nxpbO7hnc6Ds+a+Qv58+MbxS/dRIWm0g3yUR+tYl6ifHGNTYqs6j4Jzu+x2KFayiWIH3npbQOj+fhcJybDfKjutK1tlusH/I+TlWMKpTx275v817q2SsgMfxT0EdlHzz3Mry75jVMe3j/mM15kBJzNdlOEWxAqdxvL/T43iR3WS9Dd2XoMZSdQ6V9Www0XEKXpuy/DOhDzhWgPaoqr/APoj6lkTK9yOzeqh4LsYKdibZqxqnOgbkebfst6fdCPnWvNdHjTlKztR+FBxDuZzZAbMrFe+ni44VGH49aW1zlVhB7Ny9Tbs5GitQfrjqB4wVIE/V3XihWEEn7VooBlrEV567qztglY3Iiwco+xG6qx9tBPriR5LuKxup9isMURqWTXHPoFgB6hfrf+hO99BauJrP8bihbBiP2Zj/JLBhy4k3sfdDWP6ivf58nkvdaxXCCsXYi87ZMG11Fx/XJUnydVLpovGmE/MNz3t0FK9Cd1Dg+QE+qx6ruxxjwPE9dN8W3pO8PGfcxnaotRD2B3jM35nGbqx3KFYQWmtvN1aAdiYvVvA20N0rcvzpJPGJFfCcqWysIHT+ocjnZdq9WMH4/KqfysYKQt/L84gVsHwWfQ8vNO7ifr7tI2IFIdnbGrGCUNxtImIFv/gqiBXcBbZts1Os4AO9WMFo2taKFXykYqwA7ZFHrOCTkbGCu51iBS+DPN9XMVYQshu9WEEvVvBz8Oz/bTFWELrDt0qs4JMdihVMqRgrCK2ZTUSs4FfAhv1hL1bQQjtPJ3uxgnK66xEr+MMOxQruprEb90Ow7uLeTZ5HeJ5BCN3pZPn/N+juP0Xwpp0zCDF3iIewngnQLtpLy7R7ZxDG51f91EhaxxOeO6Du8rdvVayqnTMILJ/q+7axd43g922/fOh4XHUGISR7RWcQQmeQQmcQQjHG0NnCiTiD8J8UK6joY3f0DELjuC3/p338Y6f52k8jYwW9Mwj5YynrWdkzCNtl/VoUKyhzZrHKGYS5WT2KziDMOG58u6ueQTgU5Hl29tvTbvTOIPTOIPwcPPv/tXoGAW0E2wG0ER5nEOaS7isbGeuz4BmE38x8FqXjrP+hdYuJPoNwNNiwU4k3vTMI+TrZO4NQTnc9ziCcmjNuYzuqnEGYQWM31rvdOwmUzrOfpnxfdbaDfd8VoLsXEW+87xqJma+HsEJnEIr2NDDt3l0j4/OrflIxetZBjImFziCUWcdD2cZxl+VTnUGIHXfxDMLNFCsoiv1P1Hcs2r2TQMk62w2M/yciP8cKLP+mrC/aXP+TsQLeY4TxDCXfed8luwVs27U5tm2gJOa7YZ46AXfIl/4eVdk9RkV2k/U2tNakYmxq7Y/1bDDRMcu8bxZ8KBArQHvEcU20RxwDeVbQVfYIYwXPUKwA7QbGCm4j2VNxfSzLsmf5nwN5/ij5Gx52g+9ZVTGj0Jij5KwhyuMYyuXMDrQ5l46OFRh+PWltc5VYgdI/Nd9p026OxgqKvlWvYgVqLoJYoVhBJ+1aaD2kiK88d1d76ZSNCK1h5O2FVPTQRqAv/gzpfui7LoirfBa8M3EzxQpQv9q9k0DNrdlvwPVX5fPgmI35Pw027HeJN0qWQ35s0Xyd12HUfD2EFYpTFO1pYNpqTwPXJUnydVLpovGmE/MN9AtYF0MxmvQp+11v9v9D3/WO1V3e/6ziAUp3MQb2uznjNrZDxSvZH+Axn/2B2P3RNaov5kcbwvxXNie0X0H5Qmqd85kcOmgTsG1nZv/z2s+fRPrUnVyL9/x2QNF8kPffq/UaJe9Gs2if/MU0NtQg39uorrWkta410bZGTnmFhf0yF34fBOmY/3s0l0R+lujXpUNQJgEMxK4oM0uxrfYofxJ9J0UvfeoirT+iLlf/2p63PvqeeVNrVN7qwu9YLgdE/reJ/MarQap7M4l6TlO6a7QtjduOaah/VodUZ18aHl+/gYr1i+Ef4jdE/mWQr0xfzEjGywLKu+nrE5D2EKWV/fZNKObM9g3t9gjk4TV7y/+f4MsNzR+PqWwg+s+d+DZNCOuJAO2iPW4jRFvNZbkuSZLvAyj9cLozfqDT38JQvFL9pNZsOZb0EKQ9QWmxd1HzOrDag6bk8wnRjhF4F/ouzhOAO0yxY+WbhWSvyDcbyX6X9c3YbpT99k0odsR6hrKK+Tl2bPl3yfqizf0gMnbMe05fhDqUibUdmtUx7ePdc2xb2fhdM8OZID+3dIyl7J7TIrvJehvae6C+J6XmVqxng4n2sflbbpb/QOgDjh2jPeK5JdqjUDyJ/XfUGYwdn57VYyhptRsYOz6MZE/NsbAsy57lfwvI85HZb0+7EbpLj9cJ1Jij5Ezt+8cxlMuZHWjzuzHRsWPDryetba4SO1b6p+aZbdrN0dhxbKwaY8dqLRyxQrHjTtq10Py9iK8cy1VrqcpGhL7Xx/bjmQA9tBHoi59Oul/0zb2Qz/Is4B5F8QHUL9b/2H2mMTFnHjeUDeMxG/OfAzbsUuKN9x0YobWwmDswQvGhoj1uTLt3B8b4/KqfGpQfeVNWdzk+HBtzxnWfS3PGbWwHjtusu8+JuqI/8GqLFWwC3b2xFytooc317MUKxqdNZKzgxg7FCpJerKB0rOCeV0Gs4Dmwbfc7xQoe6sUKRtO2VqzgqS6JFXw5MlbwglOs4Csgz5/sxQpCTy9WQPR6sYKtEyv4codiBf9+yJbfr7ZYwZ+DDftmL1bQQjtPJ3uxgnK66xEr+GaHYgUvVJzH1JJWOxSzz0ztY0N+jGS/1Rk59gmw3EM5dNAmYNt4n5nl/16kT220OyHvyCOWd2WzQ/eZqvkj+so8T1Z7/pS8G82i+exf09jwOOR7LBmf9rTAUH3N9559QtSZ+YVycDfkMdx+yt93/Fi5HY4fj6l4+jS8Kzsnv5vao+bkIazHA7RD+xIVbXVHDdclEfW0ckpXjDed0BXUB9aVkOynTwyvVD81KL+y/49B2uOUhvFY9gfx3rPQvUpo31g+HxftuBve8dhwt6hrivv+Q8bjKlsfkr0iW8+y97Ron9J/thuo/2w3UEZD34Rmu4HnyhKRn2NRln+frC9sfoMy0m4s6gWqI8bRlXzz3N3yHwe2bb8c2zZQEnNOhjNB46acs6G+sy0o8pfK2k3WW+ybpwnraYGlzgmxng0mesw2vH7KfyT0Acei0B6xj4v2KHTv+9OUhjqDsahzsnoMJa12A2NRx5PsKZ8Ny7LsWf5zQZ5Pyn572o3QuhjPRdWYo+RM+fs4hnI5swNmV1AWOxGLMvx60trmKrEopX/Kb23Tbo7GolRMUPUDxqLUvR2IFYpFddKuheYDRXwN3W3M+ow2gu0A2gi2H08G6KGNQF/8HNJ9ZSNjfZanAfdamm+gfrH+q3mQ0nH2G1QMm8cNZcN4zMb8F4AN20S88V775tha2bXv0HyzaA0ntB7YW/vW/RSz9h2ru7yGpr51HlqjUvIZ8vPTh3X3GVFX5Q98TODieZkVyfj8dwNWH2Gkv6/OfvdT/l8Qvqth3iPqMADvuE/vE/nvgTxWn2lJqx3jO2Cw7ndlv5W8W7425X2KkndsP8t7qK3pw7x5QOTHs+tW7wblRz5Z2l2Qdg/RKZIblkfk18egrY/PHY9bJAvsx98LWEoWrsl+91P+2wPyqHh+J7xjnt8v8iPPrT7TqA5YdpooZ/2h5NHytSmP05Q8YntYHpV8YX7mzYMiP8ocn+17ENLupTTUY6M5RDjI75/PVeaMz3cv1KeW87/Vld/xvAKxllF97nOkgzIxl+igvuC87wmy8/dDmtKTa7Pf/ZT/C+AzPU3zPix/H5W3tGdBz/54OL+88VLpyO2UhvxAG5XXTsx/TU47Pwn1/MLwlt9K76xebepdo6zePQRpMXr3sMiPawt8txze/ci2XtlkdVcK2+TBJGwP2Sb/aiC2cjuUv5/qflfJuqvxpMiO/P0BW35PozqwPcsbD1RfqTH4/hysSaL+qLfc732CtspvMoHxTZSFAUjH/L8PffVnwxozyanDPTl1HszJ/xDVwfJ/RchLyA6g/D9ImJb/jwHzd0piXp+D+WcBX0PpKY6xrNePiPzYX7wXBPn4CKVh3XlcfBjoc973En1MQzlnukmgvjymFtWXxxtL+0cYr/6a1gkegfIlbHVfqK8uFvWN7at7Au1jLCuHd3bE6Ajy4x+O15gDJTG/JcZ05ascBPj/mOOPpI+a17BdRpuBevgE+SRI/16qv40h341cR/HxsWt/o8b62yEHj/WKN5g/Zs6H/cg+No43B1Ca8rtqog5lx9Lboa2/csB43PsCuOnvNVSPIh/vkuw32+GfBuyw4mGI50XzGo4zYH88SGlKZidaHrH9LI+htqYP80aN/zivY3lU44eSR/azQnKTPiF5vA/a+jz5dg+K+igbzfUp8rmZr2bjB3Pys823/LNP2PK/8ns+LuoQkuMRkf/jos7TqA5YlmmjXiJPTqX2WP5doD0he2z90ubca4aSf+Qb99MIpPWJ/MzTR0X+EchjPGlQfuSvpaHd+Dilofzx3jyls7G6YWXTdx8kW/1AJG5NYCk7ybba8s8RMhGyLyEZL9JLq4/Sf/7eh7JVSlYtXydkFduTZ1OsPpyfeaPsBeo422q0DQ9SGsqq0VTy9QDUfVOELxDq26LYK9sv5UeqcZjnqPcF6GC9GqL8fQE6x7VJ5zhBp9MxyOOoPfcH2lM2FoLlOcZ7v2N7VJ153Tt9VmX/p3K05ISxMizHaj2dxzvL/44Txsqdkf2OWauKld28mKiKIaXP8mSs/UnSCZ9Tr/NOpM/JfiXa8bsJ626BhbKHY6flSaiOneAX6nPMnDF0RkDxF3WC1wKRl/dQGsrbfURH8TLWD8G15tMPKK5/aF20SD54n6zyrZR/gDbXsBPK1wkfANvDshDyd9KnbEyRZQH9gwcoDfuffVLlOyp7yX2c5zvympXlv7qk7xiSG0/fUcX5O2hDulpuQr5jWbkJ7VvDMdrG71CMrJaMHyfVmGv9ULS2MQnaYO+3g/dY7ipqM/tIjL2B8ls7B3PyGx77IrcFYgkPFNRhI9XhwYI6PEB1sPx3iDqE+J8+IZ9wctKqiyX0pr9GeFYffIf49UTLRzOJemrMP6On5CB9WJeVPmEaz2WUDVR6rrBud8QK+bfHEh21jntPgA6WvydAZ36bdOYLOmpvRi3nf6PD70LzyWOJzoOOdFBn5hOdhxzpINYqovOwIx0cj3jvTN4875M0z3sE0tT4w2cmLP9/njhW7mWa56lYCdPDcf9+0Q6m9/mMhtk/jNWUsEfyXJRhFfHuV4h3aq0mxDvL/1fAu18P8I51W/kY05JWfrBPPwJpvPZqaUnSGs9NH5Y5FSMfEuV4vHoU3peZK8boBuLXk9Y2VxmvHiV62Pb04fMmv1SN3uh5k8cEvRFBD8+bIE+RvmHxfljlbyjbOEJpOK79/+1dXYxdVRU+M/d25s60tUExQWvsECPUUNE0aUIcdY4lJNio6EMTjQFGQCv+JEo0EpXExAdsbCq247TTaTtnOqU8GEMASYyWGBOLUSEBEggQHvgLCRAgNEAIEEoO9yzm69dvr7PPvffMTMg9L+dnr7322nuvv73O/uE4Pcr3JnjGMkJ1Mt/WiwEpPxR9NxVvYd5bal/pQGflub6Sig9V9ZV4/tVK9ZWQTvaVqsZcMf+MU854l+WMi3Lqju32faX4cjrxlU72yFe6Aez9q2TvUVfE+EoHRD24vDdWgK/0VsX/Cdx2Bj8JbXfKaTuW7b6vtEgnfkP8fV8p7Cspf6NOX+lASZ3YV1L0KX8nv8aSuCvGl8L6Vei7c2N50/D3ypdSfonypax+hzorbyzntdEiH/qx18Czmv+E/dWr/lOxmeXqv+nOynP7T8Wsetl/KFtV+k/J5mZ4xjSsj+dXYv6l8is3UzkhG3/BFxfzYDvEzhkw+HGw8RcWz2rOANt45C1vfavBdfnPqbGS1xN661t53Ner/9afDfy3HgC814u8LNsIPyvoMHheS8MwvO7F4NOCp/L+O5pqmkPrXkL/YS8GnEu97gXbmdeRYD7vP6zBdSkT5yqZwPqwTHhz8vKr6hxe5vsM0mYJF8tXfm0TuDxap7uglfsR+yojXAaLfIn1Yb40+O2CL1X/W5vX0f/ef3jVpt5/+EzAe/M0M0jjucjef3ile2P/w6MOuYDsV91jVI4ZzAMtDUGr4W0S/A6wwb8ku27jpSSJk1k1PsMxF89Hmoe0hQhcni49KuAXnLKRLszLZTOdlq9G2ZLz5OYRAPCG+gnhY9pK9dM6gse2qTpenqe02PFylizWmfmzV3NoOGaldJXHe5mAV7bKW2+i5J/1RgZprDeQR1lvYN+y3uA4CMNzrNHgf1f0hY2/kEcq8LqMNR4lGo8ADYq/OYZo8IdBt/0+oNtWVcS5O9LOWj/Wsa8byjvrAk8H51dVvclyi30TszYY25T9emujIQGP+Hht1Qz0Ae+pgProCNEeG7/j9UrqH0Le7scLOtR6KxwvZ8R7GaQ1RF7mPYP/J/DzAvkbvdAbPLcT9QDiYJ7y+Ez5Z2hDOZ/pAdMryIt1xMQN/0hyZp07iVvFxqi71JvvxcRvFuWpfsCYOLYplm+4vP0q69RrGQDE6DWE5/0jsY7e+sOM0lBHsP446JSHOmIe6nCcZF/pyFifBf9DnqR/YhnAsfyjjLP8I7+z34BtyH4D7vetfB602Qh/N+iwR6htFC/Pwze2XccE/M0AM0f1QV4/FoErc8q+RcAfc8pGujAvlx2SSSWL1jZ1jDfQL2BZVP3k7eeu2kr1k9o/8hilxcou752P9p3lGnl7Aer8SMBuYz3QbrPszgla0R9Yqrl/vYoVPAWy+9oKjxV48fZ+rGCRnjId28tYQew8xHlK6yRWwPyp/r/F2l2c7/uPiFiBx3uZgO9FrID1RgZpyx0raE607ys5VvDRgsa8j4cnNM6qsYLRAk8/VrB8sYIPQx9wrAD1Ud2xgosKOspiBR8j3ssgrUqsYBz4eUPx3Eu90Y8V9GMF7yIv7u/XWAHqiIzSeh0ruIhkv1exgtucWAHLP8r4cscKtoIO205t048VhGWyHyuoJru9iBVsD9htrEcnsQL2B3juVH59G77h2Q9MbyMJ6ybWOaG5Vrx/qsFfDn6WzbVS61O+DHW7MlC30NwX3jvQ4G8APXEV+TpqP2A1D4f3lUL9ybCtRLfBD4COHRPhsuxf8hqnjjmOH02E4VoCjnEMijbgeTP7RD4134znhh+kMmadMmL3nZkhnNhmyhbOlaQfFnVLxLdBAX8wUN9ElH2oBO+swOPtL6f2nWGbquYt4fklrF9QL+C8pds3tp+9/ajt/TDV66BTr/0iH8s50j7r0K7aD/WHt+esvTNv7Rf1HBDvRt8P4RvrWNynpCFgLC+vcdopdCbjRF2IdF0bwLlLxBw8nvkMfGNbXLa/FK/fVHKuaEddwt9U/+wlWJ7f2RI0hd4PCDwhGmYEnk738I2VTdzD9xDJJvr3U0T7NNGOsKG94EL8zT6cOvsCYZi/Df6ww9/qjCOk69oAznmHv1W7XwjfmL/L9tnkWKw640jRjrqHv6n+Yf5mfdQSNIXe9wk8IRqmBR7j76kATi6T+SG/YtcRnE/87e3Tvk+Uid84hvQHQT+f33Y78BKfi6HOhMM6bgvgvNPhT1UHbx/Y/U6dkR5vn02VD/uvJcoas4dT/mX4TBaGkzAP8l4od0E73ZtqWgaYnpLLOw+rlZyp0yuMe8cGCF+S6Bih4R9JzmyLTmKESkcpvrf6dbhucgOug0M+ugae1Vxf7K+y87v+Q+M9JWOok3YUzyxj98I4638BnEnSnW5au/F0vJ4s5ldV28JxN2+9G+bbQ2nYJyG/FNsX4XmfcoN/EGTzX2n7ucazG15+P+6jy3wTOgfK8DUJ/nHnv9UeyM9z7qcq0h57Pg3KBsuxOjdTyZwn90j3d4pnlvtnHduq9rjzbKuyxbHnrXIcaYnXo8o9ULE+LC+91l2GX8UwvPWoeA4M6148P/Xk+afTs1fQg33L/IW4GoKOyeK5SfBvOvxVZle4DRU/Kp9fndnr2QaTfcVfBtclf32w6nm+nizlV1W/1vpWxZKmKA11Ie9ViWOAvUD7/cRfyk5i3quLZ7aTa9L2PTbW4slcmY0yerxYi4qpeuex8TjzkGgHhP9ecno7GPzZafJeO3j+Qo/2Dv/Scp8fwrFOjAVzLEitUfP+v+B+w6oPQvsNb0jb97J5Ll6MOYZ2pXeVvKFM/ayQNzXOZ5/VOyuF86LtGQrAh8afn0rbd7VHtIpNYTtdRTgNfhPgZH2gbOof4RvzYNn5dxx7VfFI7wyY+vz5ZOty75fB9sM7fzu0FzrCYjmx/I88NEn8j/b8JirT82M5L5YT4v/QucRp2r4r/i8bl19BOA3+YsAZE/vy+L/MR/B8JG8PbtM3Nfrnlyy3f8787/nnVeO8sfyPPHQZ+Vt4BrXi2SuL5ybBb0/b91j+wnFDpz6o4iFP93J8Rvmu3I8hOzNZPLPtujxt35foXPcPLbc+539vyr/19Gcd57p/P23fy+IzHFuaqkh7rLyhTH2e7A2OfdneTDllcl6U65C9MXxsG65L23dlb3BspuJBbG8M/ueAM2a87tmbsvE6x4OwXdgWIe3eeN3gupTPs5V8Yv1ZPr265lfVWBnbG9SHeykNZYN9mdg4T9n4fmPB/9216/WTA0CL4W4IyCbdDWZn2r6PQPl2b0bQ8eiJVx/667bNP+Z1L/llfTTaBf6nW1+/ZPDOXRvqwn/f8POv/P/uHTeV4f9A8TwE6Q3KM1zcm5A2JPA1CX4qbd/zvpsunk0WV4ny8m8LDtxA4K5oRnrs24iAbwh4K3tUwFvaakhDGUcYbC/ENQLpCH8kbd+tT1qQx/KvE+XjHIUkQDd+GyT41QJ+tYDP6zmbtp9H4JvhqvKPtRveXn/8u/dNPPbcY3XJzs7NzbN2f+url9aFf/8rX9vy23M+8VJd+P/0709f+tI3Xvh4GX6W7/xScmF9bHzaEvCWhjLG8jcK3xsC1zDlM/i/p+270lWWf50of4jKV3TjN5YLpS9GBHzePnekizR32m97htbd+MDg1Sfq4otf33PdLW+f9edn6sJ/x5ZNn1v7zfN+Uxf+tSf+dtkTr//kvLrw3/jkqYd3/eojL9aF/wtzv9i5Zsutt9WF/y+rH9h611zrirrwj39y9znr//vTNXXhX9VcPzN26+RXyvC/A4b7Fr5uQwkA",
      "custom_attributes": [
        "abi_utility"
      ],
      "debug_symbols": "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l6lzmTqXqXOZOpepc5k6l6lzmTqXqXOZOpepc5k6l6lzmTqXqXOZOpepc5k6l6lzmTqXqXOZOpepc5k6l6lzmTqXqXOZOpepc5k6l6lzmTqXqXOZOpepc5k6l6lzmTqXqXOZOpepc5k6l6lzmTqXqXOZOpepc5k6l6lzmTqXqXOZOpepc5k6l6lzmTqXqXOZOpepc5k6l6lzmTqXqXOZOpepc5k6l6lzmTqXqXOZOtepc50616lznTrXqXOdOtepc50616lznTrXqXOdOtepc50616lznTrXqXOdOtepc50616lznTrXqXOdOtepc50616lznTrXqXOdOtepc50616lznTrXqXOdOtepc50616lznTrXqXOdOtepc50616lznTrXqXOdOtepc50616lznTrXqXOdOtepc50616lznTrXqXOdOtepc50616lznTrXqXOdOtepc50616lznTrXqXOdOtepc50616lznTrXqXOdOtepc50616lznTrXqXOdOtepc50616lznTrXqXOdOtepc50616lznTrXqXOdOtepc50616lznTpfU+dr6nxNna+p8zV1vqbO19T5mjpfU+dr6nxNna+p8zV1vqbO19T5mjpfU+dr6nxNna+p8zV1vqbO19T5mjpfU+dr6nxNna+p8zV1vqbO19T5mjpfU+dr6nxNna+p8zV1vqbO19T5mjpfU+dr6nxNna+p8zV1vqbO19T5mjpfU+dr6nxNna+p8zV1vqbO19T5mjpfU+dr6nxNna+p82xIsmxTzjov0qE/D88G5a/OH50hG/KhGLpNX50/kiEdGg8fDx8PHw8fDx8PH48YjxiPGI8YjxiPGI8YjxiPGI8YjzsedzzueNzxuONxx+OOxx2POx63PbJx6ZEM6dAa2kNnyIZ8KIbGQ8ZDxkPGQ8ZDxkPGQ8ZDxkPGQ8ZDx0PHQ8dDx0PHQ8dDx0PHQ8dDx2ONxxqPNR5rPNZ4rPFY47HGY43HGo89Hns89njs8djjscdjj8cejz0eezzOeJzxOONxxuOMxxmPMx5nPM54nPGw8bDxsPGYOt9T53vqfE+d76nzbH7ylXSbss6LZEiH1tAeOkM25EPj4eMR4xHjEeMR4xHjEeMR4xHjEeMR43HH447HHY87Hnc87njc8bjjccfjtkc2Rz2SIR1aQ3voDNmQD8XQeMh4yHjIeMh4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",
      "is_unconstrained": true,
      "name": "get_config"
    },
    {
      "abi": {
        "error_types": {
          "10522114655416116165": {
            "error_kind": "string",
            "string": "Can't read a transient note with a zero contract address"
          },
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13060541637244024094": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8556029555939094797": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 128
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_utility"
      ],
      "debug_symbols": "TJ1LkjS9bmT3csc9SPAFUFvpQVs/ZTKTSWb9GGnzXQEn4D7Rd1z3Lx4GI4CMjGRl/cc//sf//G//75//y7/82//69//zj3/6z//xj//2v//lX//1X/75v/zrv//3//p//+Xf/+3v//sf//h9/2fef/zT/E//WH/h/P1j//gn//tn4J+Jfxb+2fjn4B/HP4F/bv6zf/jnb5T798/APxP/LPyz8c/BP45/Av/c/Of88A9GORjlYJSDUQ5GORjlYJSDUQ5GcYziGMUximMUxyiOURyjOEZxjOIYJTBKYJTAKIFRAqMERgmMEhglMEpglItRLka5GOVilItRLka5GOVilItRLkax3+/9a+/f8f6d79/1/t3v3/P+9fdvvH/fePbGszeevfHsjWdvPHvj2RvP3nj2xrM33njjjTfeeOONN95444033njjjTfe+BvP7IP7YP4KrOBvTFsfzIJV8Des+Qd/4478j70gCu6D74IHWMHfyGN/MAtWwS74Rj4feEEUfHP+juIrAoAV/I08xwezYBXsglPgBVFwH3yFAbCCGvnUyKdG/kpkfsvyFQnAC6LgPviKBWAFo2AWrIIa2Wtkr5G9RvYaOWrkqJGjRo4aOWrkqJGjRo4aOWrkqJFvjfyV1fxOwVdYgFmwCnbBKfCCKLiA8dUZwApGwSxYBbvgFHhBFNTIViNbjWw1stXIViNbjWw1stXIViNbjTxq5FEjjxp51MijRh418qiRR408auRRI88aedbIs0aeNfKskWeNPGvkWSPPGnnWyKtGXjXyqpFXjbxq5FUjrxp51cirRl418q6Rd428a+RdI+8aedfIu0bOGrwfRMF9kDWYYAWjYBasgl1wCmrkUyOfGvmrwTU+sIJR8Dfy8g9WwS44BV4QBffBV4MAKxgFNXLUyFEjx+tII7wgCl5HGvdXYAWjYBasgl1QI98a+dbIXw3u33/6x/xqEGAFo2AWrIJdcAq8IApqZKuRrUa2GvmrwW0frIJdcAq8IArug68GAVYwCmrkUSOPGvmrwR0feEEU3AdfDQKsYBTMglWwC2rkWSPPGnnWyKtGXjXyqpFXjbxq5FUjrxp51cirRl418q6Rd428a+RdI+8aedfIu0beNfKukXeNfGrkUyOfGvnUyKdGPjXyqZFPjXxq5FMje43sNbLXyF4je43sNbLXyF4je43sNXLUyFEjR40cNXLUyFEjR40cNXLUyFEj3xr51si3Rr418q2Rb418a+RbI98a+b6R1+9XYAWjYBasgl1wCrwgCmpkq5GtRrYa2Wpkq5GtRrYa2Wpkq5GtRh418qiRR408auRRI48auWpwVQ2uqsFVNbiqBlfV4KoaXFWDq2pwVQ2uqsFVNbiqBlfV4KoaXFWDq2pwVQ2uqsFVNbiqBlfV4KoaXFWDq2pwVQ2uqsFVNbiqBlfV4KoaXFWDq2pwVQ2uqsFVNbiqBlfV4KoaXFWDq2pwVQ2uqsFVNbiqBlfV4KoaXFWDq2pwVQ2uqsFVNbiqBlfV4KoaXFWDq2pwVQ2uqsFVNbiqBlfV4KoaXFWDq2pwVQ2uqsFVNbiqBlfV4KoaXFWDq2pwVQ3uqsFdNbirBnfV4K4a3FWDu2pwVw3uqsFdNbirBnfV4K4a3FWDu2pwVw3uqsFdNbirBnfV4K4a3FWDu2pwVw3uqsFdNbirBnfV4K4a3FWDu2pwVw3uqsFdNbirBnfV4K4a3FWDu2pwVw3uqsFdNbirBnfV4K4a3FWDu2pwVw3uqsFdNbirBnfV4K4a3FWDu2pwVw3uqsFdNbirBnfV4K4a3FWDu2pwVw3uqsFdNbirBnfV4K4a3FWDu2pwVw3uqsFdNbirBnfV4K4a3FWDu2pwVw3uqsFdNbirBnfV4K4a3FWDu2pwVw3uqsFdNbirBnfV4K4a3FWDu2pwVw3uqsFdNbirBnfV4KkaPFWDp2rwVA2eqsFTNXiqBk/V4KkaPFWDp2rwVA2eqsFTNXiqBk/V4KkaPFWDp2rwVA2eqsFTNXiqBk/V4KkaPFWDp2rwVA2eqsFTNXiqBk/V4KkaPFWDp2rwVA2eqsFTNXiqBk/V4KkaPFWDp2rwVA2eqsFTNXiqBk/V4KkaPFWDp2rwVA2eqsFTNXiqBk/V4KkaPFWDp2rwVA2eqsFTNXiqBk/V4KkaPFWDp2rwVA2eqsFTNXiqBk/V4KkaPFWDp2rwVA2eqsFTNXiqBk/V4KkaPFWDp2rwVA2eqsFTNXiqBk/V4KkaPFWDp2rwVA2eqsFTNXiqBk/V4KkaPFWDp2rwVA161aBXDXrVoFcNetWgVw161aBXDXrVoFcNetWgVw161aBXDXrVoFcNetWgVw161aBXDXrVoFcNetWgVw161aBXDXrVoFcNetWgVw161aBXDXrVoFcNetWgVw161aBXDXrVoFcNetWgVw161aBXDXrVoFcNetWgVw161aBXDXrVoFcNetWgVw161aBXDXrVoFcNetWgVw161aBXDXrVoFcNetWgVw161aBXDXrVoFcNetWgVw161aBXDXrVoFcNetWgVw161aBXDXrVoFcNetWgVw161aBXDXrVoFcNetWgVw161aBXDXrVoFcNetWgVw161aBXDXrVoFcNRtVgVA1G1WBUDUbVYFQNRtVgVA1G1WBUDUbVYFQNRtVgVA1G1WBUDUbVYFQNRtVgVA1G1WBUDUbVYFQNRtVgVA1G1WBUDUbVYFQNRtVgVA1G1WBUDUbVYFQNRtVgVA1G1WBUDUbVYHw1eOyDUTAL/kY++4NdcAq8IArug68GAVYwCmZBjbxr5F0j7xp518i7Rj418qmRT418auRTI58a+dTIp0Y+NfKpkb1G9hrZa2Svkb1G9hrZa2Svkb1G9ho5auSokaNGjho5auSokaNGjho5auSokW+NfGvkWyPfGvnWyLdGvjXyrZFvjXzfyPf3K7CCUTALVsEuOAVeEAU1stXIViNbjWw1stXIViNbjWw1stXIViOPGnnUyKNGHjXyqJFHjTxq5FEjjxp51MizRp418qyRZ408a+RZI88aedbIs0aeNfKqkVeNvGrkVSNXDd6qwVs1eKsGb9XgrRq8VYO3avBWDd6qwVs1eKsGb9XgrRq8VYO3avBWDd6qwVs1eKsGb9XgrRq8VYO3avBWDd6qwVs1eKsGb9XgrRq8VYO3avBWDd6qwVs1eKsGb9XgrRq8VYO3avBWDd6qwVs1eKsGb9XgrRq8VYO3avBWDd6qwVs1eKsGb9XgrRq8VYO3avDvc/hfkzWNptm0mnbTafKmaGqHtcPaYe2wdlg7rB3WDmuHtcPaMdox2jHaMdox2jHaMdox2jHaMdox2zHbMdsx2zHbMdsx2zHbMdsx27Hasdqx2rHasdqx2rHasdqx2rHasdux27Hbsdux27Hbsdux27Hbsdtx2nHacdpx2nHacdpx2nHacdpx2uHt8HZ4O7wd3g5vh7fD2+Ht8HZEO6Id0Y5oR7Qj2hHtiHZEO6Idtx23Hbcdtx23Hbcdtx23HbcdXefWdW5d59Z1bl3n1nVuXefWdW5d59Z1bl3n1nVuXefWdW5d59Z1bl3n1nVuXefWdW5d59Z1bl3n1nVuXefWdW5d59Z1bl3n1nVuXefWdW5d59Z1bl3n1nVuXefWdW5d59Z1bl3n1nVuXefWdW5d59Z1bl3n1nVuXefWdW5d59Z1bl3n1nVuXefWdW5d59Z1bl3n1nVuXefWdW5d59Z1bl3n1nVuXefWdW5d59Z1bl3n1nVuXefWdW5d59Z1bl3n1nVuXefWdW5d59Z1bl3n1nVuXefWdW5d59Z1bl3n1nVuXefWdW5d59Z1bl3n1nVuXefWdW5d59Z1bl3no+t8dJ2PrvPRdT66zkfX+eg6H13no+t8dJ2PrvPRdT66zkfX+eg6H13no+t8dJ2PrvPRdT66zkfX+eg6H13no+t8dJ2PrvPRdT66zkfX+eg6H13no+t8dJ2PrvPRdT66zkfX+eg6H13no+t8dJ2PrvPRdT66zkfX+eg6H13no+t8dJ2PrvPRdT66zkfX+eg6H13no+t8dJ2PrvPRdT66zkfX+eg6H13no+t8dJ2PrvPRdT66zkfX+eg6H13no+t8dJ2PrvPRdT66zkfX+eg6H13no+t8dJ2PrvPRdT66zkfX+eg6H13no+t8dJ2PrvPRdT66zkfX+eg6H13no+t8dJ2PrvPRdT67zmfX+ew6n13ns+t8dp3PrvPZdT67zmfX+ew6n13ns+t8dp3PrvPZdT67zmfX+ew6n13ns+t8dp3PrvPZdT67zmfX+ew6n13ns+t8dp3PrvPZdT67zmfX+ew6n13ns+t8dp3PrvPZdT67zmfX+ew6n13ns+t8dp3PrvPZdT67zmfX+ew6n13ns+t8dp3PrvPZdT67znM30rlJ0XSLvjr33F781fmj0TSbVtNuOk3eFE23yNvh7fB2eDu8Hd4Ob4e3w9vh7Yh2RDuiHdGOaEe0I9oR7Yh2RDtuO247bjtuO247bjtuO247bjtuOXLj0iNrGk2zaTXtptPkTdHUDmuHtcPaYe2wdlg7rB3WDmuHtWO0Y7RjtGO0Y7RjtGO0Y7RjtGO0Y7ZjtmO2Y7ZjtmO2Y7ZjtmO2Y7ZjtWO1Y7VjtWO1Y7VjtWO1Y7VjtWO3Y7djt2O3Y7djt2O3Y7djt2O3o+t8dZ2vrvPVdb66znPnk8+k0+RN0XSLss5B1jSaZtNqaoe3w9vh7fB2RDuiHdGOaEe0I9oR7Yh2RDuiHbcdtx23Hbcdtx23Hbcdtx23HbccuTnqkTWNptm0mnbTafKmaGqHtcPaYe2wdlg7rB3WDmuHtcPaMdox2jHaMdox2jHaMdox2jHaMdox2zHbMdsx2zHbMdsx2zHbMdsx27Hasdqx2rHasdqx2rHasdqx2rHasdux27Hbsdux27Hbsdux27Hbsdtx2nHacdpx2nHa0XW+u8531/nuOt9d57vrfHed767z3XW+u8531/nuOt9d57vrfHed767z3XW+u8531/nuOt9d57vrfHed767z3XW+u8531/nuOs+dVx5Jq2k3nSZviqb7KDdgPbKm0TSbVtNuOk3eFE3tsHZYO6wd1g5rh7XD2mHt+Oo8fkm36KvzR9Y0mmbTatpNp8mb2jHaMdvx1XmcpNE0m1bTbjpN3hRNt+ir80ft+Oo8PGk2rabddJq8KZpu0Vfnj6ypHbsdux27HV+dx03ypmi6RV+dP7Km0TSbVtNuasdpx2nHaYe3w9vh7fB2eDu8Hd4Ob4e3w9sR7Yh2RDuiHdGOaEe0I9oR7Yh23Hbkr7HmFZa/yQqaTX+Oa0m76TT9OS5+9TCa7qPc5PXImkbTbFpNu+k0eVM0tcPaYe2wdlg7rB3WDmuHtcPaYe0Y7RjtGO0Y7RjtGO0Y7RjtGO0Y7ZjtmO2Y7ZjtmO2Y7ZjtmO2Y7ZjtWO1Y7VjtWO1Y7VjtWO1Y7VjtWO3Y7djt2O3Y7djt2O3Y7djt2O3Y7TjtOO047TjtOO047TjtOO047Tjt8HZ4O7wd3g5vh7fD2+Ht8HZ4O6Id0Y5oR7Qj2hHtiHZEO6Id0Y7bjtuO247bjtuO247bjq5z7zr3rvPoOo+u8+g6j67z6DqPrvPoOo+u8+g6j67z6DqPrvPoOo+u8+g6j67z6DqPrvPoOo+u8+g6j67z6DqPrvPoOo+u8+g6j67z6DqPrvPoOo+u8+g6j67z6DqPrvPoOo+u8+g6j67z6DqPrvPoOo+u8+g6j67z6DqPrvPoOo+u8+g6j67z6DqPrvPoOo+u8+g6j67z6DqPrvPoOo+u8+g6j67z6DqPrvPoOs+9aNeToukWZZ2DrGk0zabVtJtOUzu8Hd6OrPORZE2jaTatpt10mrwpmm7Rbcdtx23Hbcdtx23Hbcdtx23HLUduVntkTaNpNq2m3XSavCma2mHtsHZYO6wd1g5rh7XD2mHtsHaMdox2jHaMdox2jHaMdox2jHaMdsx2zHbMdsx2zHbMdsx2zHbMdsx2rHasdqx2rHasdqx2rHasdqx2rHbsdux27Hbsdux27Hbsdux27Hbsdpx2nHacdpx2nHacdpx2nHacdpx2eDu8Hd6OrPObtJp205/Dfr9EJwbxNn61XmjEQZzERdxE2oK2oC1ou7Rd2i5tl7ZL26Xt0nZpu7Tdso3cJ1doxEGcxEXcxEN0YhBpM9qMNqPNaDPajDajzWgz2oy2QdugbdA2aBu0DdoGbYO2QdugbdI2aZu0TdombZO2mbaR6MQgpm1/uH5EIw7iJC7iJh6iE4NI26Zt07Zp27Rt2jZtm7ZN26Zt03ZoO7Qd2g5th7ZD26Ht0HZoO7Q5bU6b0+a0OW1Om9PmtDltTlvQFrQFbUFb0Ba0BW1BW9AWtF3aLm2Xtkvbpe3Sdmm7tF3abtvs9yMacRAncRE38RCdGETajDajzWgz2ow2o81oM9qMNqNt0DZoG7QN2gZtg7ZB26Bt0DZom7RN2iZtk7ZJ26Rt0jZpm7Sxlxh7ibGXGHuJsZcYe4mxlxh7ibGXGHuJsZcYe4mxlxh7ibGXGHuJsZcYe4mxlxh7ibGXGHuJsZcYe4mxlxh7ibGXGHuJsZcYe4mxlxh7ibGXGHuJsZcYe4mxlxh7ibGXGHuJsZcYe4mxlxh7ibGXGHuJsZcYe4mxlxh7ibGXGHuJsZcYe4mxlxh7ibGXGHuJsZcYe4mxlwz2ksFeMthLBnvJYC8Z7CWDvWSwlwz2ksFeMthLBnvJYC8Z7CWDvWSwlwz2ksFeMthLBnvJYC8Z7CWDvWSwlwz2ksFeMthLBnvJYC8Z7CWDvWSwlwz2ksFeMthLBnvJYC8Z7CWDvWSwlwz2ksFeMthLBnvJYC8Z7CWDvWSwlwz2ksFeMthLBnvJYC8Z7CWDvWSwlwz2ksFeMthLBnvJYC8Z7CWDvWSwlwz2ksFeMthLBnvJYC8Z7CWDvWSwlwz2ksFeMthLBnvJYC8Z7CWDvWSwlwz2ksFeMthLBnvJYC8Z7CWDvWSwlwz2ksFeMthLBnvJYC8Z7CWDvWSwlwz2ksFeMthLBnvJZC+Z7CWTvWSyl0z0kkjcxEN0YhBvI3oJ0IiDOIm0GW1Gm9FmtBltg7ZB26Bt0DZoG7QN2gZtgzZ81ad9iC/7BBrxs9lInMRF3MRDdGIQb2P2kodGpG3RtmhbtC3aFm2LtkXbpm3TtmnbtG3aNm2btk3bpm3Tdmg7tB3aDm2HtkPboe3Qdmg7tDltTpvT5rQ5bU6b0+a0OW1OW9AWtAVtQVvQFrQFbUFb0Ba0XdoubZe2S9ul7dJ2abu0Xdpu23LfYqERB3ESF3ETDzFtKzGItzF7yfeFuSO3MBYO4iQu4iYeohODeBsHbYO2QdugbdA2aBu0DdoGbYO2SdukbdI2aZu0TdombZO2SdukbdG2aFu0LdoWbYu2RduibdG2aNu0bdo2bZu2TdumbdO2adu0bdoObYe2Q9uh7dB2aDu0HdoObYc2p81pc9qcNqfNaXPanDanzWkL2oK2oC1oC9qCtqAtaAvagrZL26Xt0nZpu7Rd2i5tl7ZL223b/v2IRhzESVzETTxEJwaRNvaSzV6y2Us2e8lmL9nsJZu9ZLOXbPaSzV6y2Us2e8lmL9nsJZu9ZLOXbPaSzV6y2Us2e8lmL9nsJZu9ZLOXbPaSzV6y2Us2e8lmL9nsJZu9ZLOXbPaSzV6y2Us2e8lmL9nsJZu9ZLOXbPaSzV6y2Us2e8lmL9nsJZu9ZLOXbPaSzV6y2Us2e8lmL9nsJZu9ZLOXbPaSzV6y2Us2e8lmL9nsJZu9ZLOXbPaSzV6y2Us2e8lmL9nsJZu9ZLOXbPaSzV6y2Us2e8lmL9nsJZu9ZLOXbPaSzV6y2Us2e8lmL9nsJZu9ZLOXbPaSzV5y2EsOe8lhLznsJYe95LCXHPaSw15y2EsOe8lhLznsJYe95LCXHPaSw15y2EsOe8lhLznsJYe95LCXHPaSw15y2EsOe8lhLznsJYe95LCXHPaSw15y2EsOe8lhLznsJYe95LCXHPaSw15y2EsOe8lhLznsJYe95LCXHPaSw15y2EsOe8lhLznsJYe95LCXHPaSw15y2EsOe8lhLznsJYe95LCXHPaSw15y2EsOe8lhLznsJYe95LCXHPaSw15y2EsOe8lhLznsJYe95LCXHPaSw15y2EsOe8lhLznsJYe95LCXHPaSw15y2EsOe8lhLznsJYe95LCXHPaSw15y2EsOe8lhLznsJc5e4uwlzl6S2zz/PhFJXMRNPEQnBvE2Zi95aMRBpM1oM9qMNqPNaDPaBm2DtkHboG3QNmjLXvL9PZGR2z8Lg5i2XKjsJQ+N+NmmJU7iIm7iIToxiLcxe8lDI9K2aFu0LdoWbYu2RduibdOWvWTm6mQveTiJi7iJh+jEIN7G7CUPaTu0HdoObYe2Q9uh7dB2aHPanDanzWlz2pw2p81pc9qctqAtaAvagragLWgL2oK2oC1ou7Rd2i5tl7ZL26Xt0nZpu7TdtuU+0kIjDuIkLuImHqITg0ib0Wa0GW1Gm9FmtBltRpvRZrQN2gZtg7ZB26Bt0DZoG7QN2gZtk7ZJ26Rt0jZpm7RN2iZtk7ZJ26Jt0bZoW7Qt2hZti7ZF26Jt0bZpYy8J9pJgLwn2kmAvCfaSYC8J9pJgLwn2kmAvCfaSYC8J9pJgLwn2kmAvCfaSYC8J9pJgLwn2kmAvCfaSYC8J9pJgLwn2kmAvCfaSYC8J9pJgLwn2kmAvCfaSYC8J9pJgLwn2kmAvCfaSYC8J9pJgLwn2kmAvCfaSYC+57CWXveSyl1z2kstectlLLnvJZS+57CWXveSyl1z2kstectlLLnvJZS+57CWXveSyl1z2kstectlLLnvJZS+57CWXveSyl1z2kstectlLLnrJSDTiIE7iIm7iIToxiLdx0bZoW7Qt2hZti7ZF26Jt0bZo27Rt2jZtm7ZN26Zt07Zp27Rt2g5th7ZD26Ht0HZoO7Qd2g5thzanzWlz2pw2p81pc9qcNqfNaQvagragLWgL2oK2oC1oC9qCtksbeslKHMRJTNtJ3MRDdGIQ78OJfa8PjTiIk7iIm3iITgwibUab0Wa0GW1Gm9FmtBltRpvRNmgbtA3aBm2DtkHboG3QNmgbtE3aJm2TtknbpG3SNmmbtE3aJm2LtkXbom3RtmhbtC3aFm2LtkXbpm3TtmnbtG3aNm2btk3bpm3Tdmg7tB3aDm2HtkPboe3Qdmg7tDltTpvT5rQ5bU6b0+a0OW1OW9AWtAVtQVvQFrQFbUFb0Ba0XdoubZe2S9ul7dJ2abu0XdrYS4y9xNhLjL3E2EuMvcTYS4y9xNhLjL3E2EuMvcTYS4y9xNhLjL3E2EuMvcTYS4y9xNhLjL3E2EuMvcTYS4y9xNhLjL3E2EuMvcTYS4y9xNhLjL3E2EuMvcTYS4y9xNhLjL3E2EuMvcTYS4y9xNhLjL3E2EuMvcTYS4y9xNhLjL3E2EuMvcTYS4y9xNhLjL3E2EuMvcTYS4y9xNhLjL3E2EuMvcTYS4y9xNhLjL3E2EuMvcTYS4y9xNhLjL3E2EuMvcTYS4y9xNhLjL3E2EuMvcTYS4y9xNhLjL3E2EuMvcTYS4y9xNhLjL3E2EuMvcTYS4y9xNhLjL3E2EsGe8lgLxnsJYO9ZLCXDPaSwV4y2EsGe8lgLxnsJYO9ZLCXDPaSwV4y2EsGe8lgLxnsJYO9ZLCXDPaSwV4y2EsGe8lgLxnsJYO9ZLCXDPaSwV4y2EsGe8lgLxnsJYO9ZLCXDPaSwV4y2EsGe8lgLxnsJYO9ZLCXDPaSwV4y2EsGe8lgLxnsJYO9ZLCXDPaSwV4y2EsGe8lgLxnsJYO9ZLCXDPaSwV6Cfa/fX8id2Pf6cBM/27JEJwbxNmYveWjEQZzERdxE2pw29JKdeBvRS4BGHMRJXMRNPEQn0ha0XdoubZe2S9ul7dJ2abu0Xdpu27Dv9aERB3ESF3ETD9GJQaTNaDPajDajzWgz2ow2o81oM9oGbYO2QdugbdA2aBu0DdoGbYO2SVv2kjUTB3ESF3ETD9GJQbyN2Use0rZoW7RlL9kjcRMP8bNt/LdBvI3ZS9ZKNOIgTuIibuIhOjGIt/HQdmg7tB3aDm2HtkPboe3Qdmhz2pw2p81pc9qcNqfNaXPanLagLWgL2oK2oC1oC9qCtqAtaLu0XdoubZe2S9ul7dJ2abu03bZh3+tDIw7iJC7iJh6iE4NIm9FmtBltRpvRZrQZbUab0Wa0DdoGbYO2QdugbdA2aBu0DdoGbZO2SdukbdI2aZu0TdombZO2SduiLXvJuImDOImLuImH6MQg3sbsJQ9p27Rt2jZtm7ZN26Zt07ZpO7Qd2g5th7ZD26Ht0HZoO7Qd2pw2p81pc9qcNqfNaXPanDanLWgL2oK2oC1oC9qCtqAtaAvaLm2Xtkvbpe3Sdmm7tF3aLm23bdj3+tCIgziJi7iJh+jEINJmtBltRpvRZrQZbUab0Wa0GW2DtkHboG3QNmgbtA3aBm2DtkHbpG3Slr1kr8RJXMS8U/DEQ3Ri3ilE4m3MXvLQiIM4iYu4iYfoRNoWbZu2TdumbdO2adu0bdo2bZu2Tduh7dB2aDu0HdoObYe2Q9uh7dDmtDltTpvT5rQ5bU6b0+a0OW1BW9AWtAVtQVvQFrQFbUFb0HZpu7Rd2i5tl7ZL26Xt0nZpu23DvteHRhzESVzETTxEJwaRNqPNaDPajDajzWgz2ow2o81oG7QN2gZtg7ZB26Bt0DZoG7QN2rKXnJloxEH8bOckLuImHqITg3gbs5c8NOIg0rZoW7RlLzk59ewlD4N4G7OXPDTiIE7iIm4ibZu2Tdum7dB2aDu0HdoObYe2Q9uh7dB2aHPanDanzWlz2pw2p81pc9qctqAtaAvagragLWgL2oK2oC1ou7Rd2i5tl7ZL26Xt0nZpu7TdtmHf60MjDuIkLuImHqITg0ib0Wa0GW1Gm9FmtBltRpvRZrQN2gZtg7ZB26Bt0DZoG7QN2gZtk7ZJ26Rt0jZpm7RN2iZtk7ZJ26Jt0bZoW7Qt2hZt7CXOXuLsJc5e4uwlzl7i7CXOXuLsJc5e4uwlzl7i7CXOXuLsJc5e4uwlzl7i7CXOXuLsJc5e4uwlzl7i7CXOXuLsJc5e4uwlzl7i7CXOXuLsJc5e4uwlzl7i7CXOXuLsJc5e4uwlzl7i7CXOXuLsJc5e4uwlzl7i7CXOXuLsJc5e4uwlzl4S7CXBXhLsJcFeEuwlwV4S7CXBXhLsJcFeEuwlwV4S7CXBXhLsJcFeEuwlwV4S7CXBXhLsJcFeEuwlwV4S7CXBXhLsJcFeEuwlwV4S7CXBXhLsJcFeEuwlwV4S7CXBXhLsJcFeEuwlwV4S7CXBXhLsJcFeEuwlwV6Cfa/fF+5P7HsFZi95aMRBnMRF3MRDdCJtm7ZD26Ete0lY4iQu4iYeohODeBuzlzw0Im1Om9OGXuKJh+jEIN5G9BKgEQdxEheRtqAtaAvagrZL26Xt0nZpu7Rd2i5tl7ZL220b9r0+NOIgTuIibuIhOjGItBltRpvRZrQZbUab0Wa0GW1G26Bt0DZoG7QN2gZtg7ZB26Bt0DZpm7RN2iZtk7ZJ26Rt0jZpm7Qt2hZti7ZF26Jt0bZoW7Qt2hZtm7ZN26Zt07Zp27Rt2jZtm7ZN26Ht0HZoO7Qd2g5th7ZD26Ht0Oa0OW1Om9PmtLGXXPaSy15y2Usue8llL7nsJZe95LKXXPaSy15y2Usue8llL7nsJZe95LKXXPaSy15y2Usuewn2vUYkOjGI2ZX/ng0u7Ht9aMTP9n219sK+14eL+NnuTjxEJwbxNmYveWjEQZzERaTNaDPajLavl4yfffj1kkIjjg8jcRIXcX+Y6/D1kkIn/tmGncTb+PWSws/2/Wrkyn2vhZP42UZO5+slhYfoxCDexq+XFBpxECeRtkXbom3RtmhbtG3aNm2btk3bpm3TtmnbtG3aNm2HtkPboe3Qdmg7tB3aDm2HtkOb0+a0OW1Om9PmtDltTpvT5rQFbUFb0Ba0BW1BW9AWtAVtQdul7dJ2abu0XdoubZe2S9ul7bYt970WGnEQJ3ERN/EQnRhE2ow2o81oM9qMNqPNaDPajDajbdA2aBu0DdoGbYO2QdugbdA2aJu0TdombZM29hJjLzH2EmMvMfYSYy8x9hJjLzH2EmMvMfYSYy8x9hJjLzH2EmMvMfYSYy8x9hJjLzH2EmMvMfYSYy8x9hJjLzH2EmMvMfYSYy8x9hJjLzH2EmMvMfYSYy8x9hJjLzH2EmMvMfYSYy8x9hJjLzH2EmMvMfYSYy8x9hJjLzH2EmMvMfYSYy8x9hJjLzH2EkMvicRBnMTPNmfiJh7iZ/t+d2flvtfCW5j7Xse3UW/lvtfCQfxsayQu4iZ+tnUTnRjEz7Z/H2YveWjEz/Z9GLJy32vhIn62nYNlL3noxM/2/TnilfteH2YvefjZPOebveThJH627435yn2vhYf42SLnm73k4W3MXhK5ZtlLHg7iZ4tc9ewlDzfxEJ0YxNuYveShEQeRtkXbom3RtmhbtC3aNm2btk3bpm3TtmnbtG3aNm2btkPboe3Qdmg7tGUvyfvq3Pda6MTPdvNkZS8BZi95aMRBnMRF3MRDdCJtTlvQFrRlL7kncRIXMW2eeIhOTFseZvYSYPaSh0YcxElcxE08RCfSdtuW+17n7yQacRDnh564iJv4Z5s2E50YxPvhd7pz32uhNebb6pzNzrF2Yv5UGs6PaMRBnMRF3MRDdGIQaXPanDanzWlz2pw2p81pc9qctqAtaAvagragLWgL2oK2oC1ou7Rd2i5tl7ZL26Xt0nZpu7TdtuU+yEIjDuIkLuImHqITg0ib0Wa0fa9T8/sympX7IAsXcRMP0YmfbazE2/i9ThUaMW07cRLTdhI38RCdGMTbOH/EtN3EQZzEz/Z918zKfZCFh/jZ8k4i90EW3sbvdarQiIP42WYkLuImHmLacmYriLfxe52aKxfqe50qHMTPtnKw73WqcBNz3JH4jZu3MLm3ce484uwPO6ee/eHhJh6iE4P4jZs3Nrm3sdCIg5i2nEP2h4ef7eQksz88dGIQb2P2h4ef7eRFkP3h4SQuYtqyArI/PExbTjL7w8PbmP3h4WfL+6zc21g4iYu4iYf42Tynk/3h4S3MvY2FafPEQZzEtP0SN/E0Zs0/zBEi8ftv81Yudybi/+cFUfDNKdKTdf3QiIM4iYv4eb6/pbVyT2LhtwL5UDD3JBbexizmfDaXGxELJ3ERNzEVN9GJQbyNWcwPjfhn+2u/iZO4iJt4Psz5fsVcGMT7Yc7sK+ZCI6YtF2qnLVf9K+a/rp24iYfoxCDexq/EV95k5JbDwkXcxEP0Rk/MS9CDmIqcb6Qi1ywmcRE38RC98auIlS8luUOvMIi3MHfoFRpxECdxETfxEJ0YRNqMNqPNclxLzBFGYo6wEm/j+BFzhJ04iJO4iJt4iDnudwJyJ936vgBu5U66NXNmXzEUbmKOcBOdGMTbuH5EI362fG3MnXSFacuDz2J4eIjfuPmWPXfHrXxtzN1xhXnEkZgj5GHmBf7QiUHMcXMdvjvfQiOmLVcnL/uHi0jboe3Qdmg7t9F/fS6cZ9N5Np1n03k2nWczawinMKxPYdYQTlbwbAbPZtYQzkXwbAbPZvBsBs/m5dm81uft8mze2Sfr8mxens2swjyFuYsN5y13sRXOOoW5iw0LlbvYCg/RiVEnK3exPbQf0epk5S62wkmkzWgz2ow267OZW8FW3lflVrDCIH7TyadEuRWs0IiDOImLuImH6MTPlrduuRXsYb4yPDTiIE5i2nK+WTgPD9GJny2fSeVWsIdZOA8/W94H5lawwkn8bN8vAK7cClZ4iE5MW14wWSJ5d5ibvgoncRFz3DzznuPmOc4Xn7xnzE1fhbcxfsS05RFnOT2cxEX8bCePLWvo5Hyzhk5OJ2sobxRzp9dfHSQacRAncRE38RA/W96D5U6vws/mnzh3ehUacRAncRE/W97Q5U6vQicGMW3fdHKnV6ERP1s+/sudXoWL+NliJH62fFKVO70Kg3gb87XwoRFzXE/cxNOYZZpPlHKXVeE37v1OYe6yKjTiIE7iIm7iIToxiGnLI84yvTPRiIM4iYu4iTluHnyWXt6y5s6pv7cBiZO4iDlCLkmW3kMnBvE25mvWw7TlOc6CfPhn279c1K8gCzcxPsx1+Ips/3IdviIrzPmexNULlUX28BCdmOPmknz19vCrt0KezcuzeXk2L22XtkvbpS3rLTH3J+288c79SYVGzHqzxElcxE08RCfmsZ3E2zh+RCMO4iQuon/oiUG8jfNHNOIgTuIibuIh0jZpm7Qt2hZti7ZF26Jt0bZoW7Qt2hZtm7ZN26Zt07Zp27Rt2jZtm7ZN26Ht0HZoO7Qd2g5th7ZD26Ht0Oa0OW1Om9PmtDltTpvT5rQ5bUFb0Ba0BW1BW9AWtAVtQVvQdmm7tF3aLm2Xtkvbpe3Sdmm7Zdu5E6nQiIM4iYu4iYfoxCDSZrQZbUab0Wa0GW1Gm9FmtBltg7ZB26Bt0DZoG7QN2gZtg7ZB26Rt0jZpm7RN2iZtk7ZJ26Rt0rZoQy+5iYM4ift1xP1DAwE6MYi3cf+IRhzESVxE2jZtm7ZN26bt0HZoO7Qd2g5th7ZD26Ht0HZoc9qcNqfNaXPanDanzWlz2py2oC1oC9qCtqAtaAvagragLWi7tF3aLm2Xtkvbpe3Sdmm7tN222e9HNOIgTuIibuIhOjGItBltRpvRZrQZbUab0Wa0GW1G26Bt0DZoG7QN2gZtg7ZB26Bt0DZpm7RN2iZtk7ZJ26Rt0jZpm7Qt2hZti7ZF26KNvcTYS4y9xNhLjL3E2Ety+9H+/vLezu1HhZP42b7Pb3duPyo8xM/2PWXduf2o8DZmL3loxEFMmycu4iYeohODeBuzlzw04iDS5rQ5bU6b0+a0OW1BW9AWtAVtQVvQFrQFbdlLLM9Q9hJg9pKHRhzESUzbTdzEQ/xs36PgnduPCm9hbj8q/Mb9nhXv3FK0v2fFO7cUFQYxR/gujdxSVGjEb77fc8SdW4oKF3ET03YSnRjE25id4HsSuXOb0P4e5+3cJlToxFzfVGTNA7PmHxpxECdxET/bzNXJmn/oxM82cyWz5oFZ8w+NOIiTuIibeIhOpG3RljU/8wxlzX9PQ3duEyqcxEXcxEN0YhBvY9b8Q9qy5meerKz5h4uYtrxKsuYfOjFteQqz5oFZ8w8/28rBsuYfTuJnW3mVZM0/PMTP9j1z3LlNqPA2Zs3vnE7W/MNBTFtOJ2v+4SZ+tpOXRtb8wyB+tpMnK2v+oRE/28n5Zs0/XMTPdtKWNf/QiZ/N8/rNmk/MbUKFn+371HbnNqHCSfxsMRM38RA/2/d4bOc2ocLbmP3h+3WMnduECgfxs92cTvaHh5v4Zzvf852dX49XGMT74beo+fV4hUYcH6btu38oXMT94U08RCd+tmy6+fV4D79eUvjZsq/n1+MVTuJny4aXX49XeIifbWCwIN7Gr5ecrO78erzCQfxsM+f79ZLCTfxsK9fs6yWFQfxsWSL59XiFRvxseYHn1+MVLuJn27nqXy8pdOJn23lAXy95+PWSws+20/b1ksJJ/Gwnr76vlxQe4mc7efV9vaTwNn695Jy0fb2kcBA/m+dgXy8p3MTP5hjMiUH8bJGL+vWSQiN+tsgl+XpJ4SJ6Nbzc6rVnHnz2h4eDOImLuImH6MRvvpHXzr2FudWr0IiDOImLuInf6sROdGIQ0/atZG71KjRivs7fxElcxLSdxBzXE29jdoKHRhzESVzETTxEJ9I2aJu0TdombZO2SdukbdI2aZu0TdoWbYu2RduibdG2aFu0LdoWbYu2TdumbdO2adu0bdo2bZu2Tdum7dB2aDu0HdoObYe2Q9uh7dB2aHPanDanzWlz2pw2p81pc9qctqAtaAvagragLWgL2oK2oC1ou7Rd2i5tl7ZL26Xt0nZpu7Tdtu3fj2jEQZzERdzEQ3RiEGkz2ow2o81oM9qMNqPNaGMv2ewlm71ks5ds9pLNXrLZSzZ7yUYviUQnBvE2opcAjTiIk7iIn+37sGnnnrJCJ6btJt5G9BKgEQdxEhdxEw/RibQt2jZt2Uu+jxl37ikrnMQ/m+cdXu4pKzxE/zCPLbsGfiz7w/fp2c7dY4U5wk48RCcG8TZ+/aHQPsypf/2hcBIX8bNZTvLrD4VO/GyWU//6w8OvPxR+tnw6k9vWCidxEdOWBx9py/lGjvu9QuZX0xUacRBz3LyMbo6bR/F1As8nArnxzfO9f258KwziLcyNbz5mohEHcRI/W97/5m43zzvd3O3m+S4/d7t5vuTnbjfPO93c7VZoxEGcxEXcxM+W71hzZ1zhrcsot8MVGnEQJ3ERN/EQnRhE2iZtk7ZJ26Rt5gHlms1NPMQ8oFzJr+YLb+P6EY04iJO4iJt4iLQt2lba8rztH9GIgziJi/jZVh5x1vxDJwbxs33f9rtzm12hET9bPhzIbXae72Zym11h2iLxENOW08n+8PA2Zn94aMRBnMRF3MRDpM1pc9qCtqAtaAvagragLWgL2oK2oO3Sdmm7tF3aLm2Xtkvbpe3SdtuWX0JXaMRBnMRF3MRDdGIQaTPajDajLRvIt+ls5/a9wk08xHwVAQbxNo4f0YiDOImLuInfuPkGOr9YDq96+cVy/m1m2/nFcoWLuImH6MRozE7wbYfbuUPwrcPiES8ecdb8wyB+R5yPx3KHYKERB5Fnc9O2eTY3z+bm2dw8m5tnM2sec8iafziIPJtZ85hD1vzDQ6SNNe+seWfNO2veWfPOms99g0/sXEnnSjpXMmsec3CuZHAlWfPOmnfWvLPmnTXvrHlnzecWwifOmgderuTlSl6et6z5h1xJ1ryz5p0176x5Z80Haz5Y88Gazy2EmENuISzcxEN0Yh7bTryNWfP5jCm3EBYO4iSmLeeAmgceohODeBuz5h8a8bOdnGTW/MO8f1iJXlWYXwvn+aw4vxbu4XenUGjEPkMxJ3ERN/EQnRhEnqHFM7R4hhbP0JrERdzEQ+zrIbcmej7mzq2JhYOYq5PrkP0hH9zl1sTCQ3RiEG9j9oeHRhzEfpoUeHoAdGIQbyOeHgCNOIiTuIi0OW1Om9PmtAVtQVvQFrQFbUFb0Ba0BW1B26Xt0nZpu7Rd2i5tl7ZL26Xttu3+fkQjDuIkLuImHqITg0ib0Wa0GW1Gm9HGZ47XaDPajDajbdA2aBu0DdoGbYO2QdugbdA2aJu0TdombZO2SdukbdI2aZu0TdoWbYu2RduibdG2aFu0LdoWbYu2TdumbdO2adu0bdo2bZu2Tdum7dB2aDu0HdoObewll73kspdc9pLLXnLZSy57yWUvuewll73kspdc9pLLXnLZSy57yWUvuewll73kspdc9pLLXnLZSy57yWUvuewll73kspdc9pLLXnLZSy57yWUvuewll73kdi85v+4l59e95Py6l5xf95Lz615yft1Lzq97yfl1Lzm/7iXn96PNaDPajDajzWgz2ow2o81oM9oGbYO2QdugbdA2aBu0DdoGbYO2SdukbdI2aZu0TdombZO2SdukbdG2aFu0LdoWbYu2RduibdG2aNu0bdo2bZu2TdumbdO2adu0bdoObYe2Q9uh7dB2aDu05TuU73t1Tu61LLyN+Q7loREHcRIXcRMPkTanzWkL2oK2oC1oC9qCtqCtP/U82Gv58DbeH9GIg5g2T1zETUwb/lsnBjGP7e8+9eRey0IjDuIkLuImHqITg0ib0Wa0GW1Gm9FmtBltRpvRZrQN2gZtg7ZB26Bt0Pb1Ev9+MezkXkv/vivg5F7LwtuY71seGnEQJ3ERN/EQact9V9+TvYO9lsDcd/XQ3rafg72WDycx9+/sxE08RCcG8TbmvquHRhzESaRt05bvW76tBSf3T7rn/zffoXgeRT7BeLiIm5gjfNdv7ol0zzOUNf9wEhdxEw/xW99vG8LJPZGFtzFr/qERB3ESFzFtuepZ8w+dGMS05TnOpxIPc33zksuafziJi7iJh+jEPLZv1fML1fzbsXRy92OhE2uf2MHuR2DubnpoxEGcxEXcxEN0Im1G26Bt0DZoG7QN2gZtg7ZB26Bt0DZpm7RN2iZtk7ZJ26QtKzZfvnKnZGGe4/wP8knDw++K+n538uROycJJXMRNPEQnBvE25vOHh7Tl84fvw9KTOyUL19v1d7BT8uEhemM+afg+cTy5+9FvXlyn9uwd7H58eIi1Z+9g9+PD25i7H0+uWe5+fDiIk7iIm3iITgzibQzagras45uHmRV78f/N9c2jyIoFZsU+NGKOkOf4q8L45ap/VVh4C3OXYqERB3F+OBIXcRMP0YlBvI32I+Z8I3EQJ3ER0zYTDzFtOzGIt3H8iEYcxElcxE08RNqyjrOf5S7Fh1nHD+3tyzy5S7FwEnO/Z65D1vHDQ3RiEG9jvvI+NOIgTiJti7aVa/ZdXLnzMH651DtX5yZO4iJu4jfC9zn6yd2EYTnu92paOImLuImH+K2v5eqcIN7GrzYLjTiIk7iIactL2Q/RiUFMW57j+BFrP+3JzYJhuWYRxNt488c80Yjj7bI92EL4cBE3Mcf9bLktML49AgfbArMgsS3w4SLm1lpLPEQnfpfRxWC3MV9YHxpxECdxETfxEJ1Im9GWpTdyvllk30aGkxsA49uncHIDYGEQb+PMEXZijnASD9GJQbyNX+EUfus7cqnXIE7iIm7iIToxiGn7rr7c1FdoxEFMW65OFtnDzzbzvH0vgIVODOJt/F4WC404iJO4iLTl29/sBNjU9zCIuQk8J5mP0h4aMa9UT5zERdzEQ3RiEG9jPkp7aETagrbINcuLK2tz5lJnbc68drI2Hw7iJOYIOVi+WOZ73tx8V2jEQZzERfzWN2+Fc/NdoRODeBvzxfKhEQcxbSdxETfxENNmiUFM21dZuc0u8q1cbrOLfNOW2+wKd+PMmd1EIw7iJC7iJh6iE4N4Gxdt+cAqOy22zj2cxO86y6aLrXMPD/G7zrKvY+vcw9uYD6weGnEQJ3ERN/EQadu0ZW3uPIVZhd/GgJNb52LnuciXxYdOjMZ8Adw5WL7U7Tz4fKl7eIhODOJtzJe6nVdqGHEQJ3ERN/EQnZi2lXgbswofGjFteY6zCh9+tpNX6vcKWXiITvxsJ1cnKzYxN8kVGnEQJ3ERN/EQnRjE79r59lKd3C9XaMT8ZY5f4iQuYv7qSCQeohODeBvzIfVDIw7iJC4ibYO2fI39PqU9uR0u8r1IboeLfO+U2+EKN/EQc4Q84nw1zQdWucWtcBE38RCd+K1vPnnKLW4P89X0oREHcRIXcRNzvnnE+Wr6MIi3MV9N82FRbnErzPl+pZdb0SKfouRWtMJJzDnkkmRtPjxEJwbxNmZtPjTiIE4ibVG/+vSHh+jE+tWnk1vRHuYHSA+/KypvUXIrWuEkLuImHqITg3gLcytaoREH8Vuz79d4Tm4vi3zfktvLIt9n5fayQiMOYo6wE3OEk3gb8y3iQyMO4iR+65vvA3LLWOEhOjGItzFfNx8aMW15xFlvDxdxE9N2E5342fIpSn5Z3cN83XxoxM+Wz0vyy+oKF3ETD9GJQbyNWZsPjUgbfpHNExdxE/PX5nJJ8nXzYRDz1+byXOQHPQ+NOIiTuIibeIhODCJtTltWdz6dye1lcfH/zdXJo8g6fngbs44f5gh53r7avPn+LbeMFQbxNn61WWjE8WHWxVebhYu4iYfoxCDewtwyFvnwJbeMFQ7iJKZtJm5ijrsTb6P9iEYcxEnMcU/iJuZReKIT05bTsds40nYTjfjZ8g1/bg4r/Gz5MCO/da7ws+UDitwyVvjZLA/zq+6HX3XffOiQW8YK05YHNCcxbXlAcxPTlgc0nZi2PKB5G1fa8oCWET9bvsPOLWOFn23kAX3VXfjZ8i14bhkrzHsN4G3Mu+KHRhzESUxbLsnexENMWx7xV92Ft/Gr7kIjDuIkLuImHiJthzbPcXN9PUfIRfUcIVfSD9GJQbyNwfkG5xucb3C+wfkG5xucb3C+wfkGV+fSdmnLmscBZXXjgC7ne3u+uQ2s0IiD2PPNbWCFm3iITgxizze3gRUacRBpM9qyuvOAcmsXDii3dr1JDs436/jhIm4i5zs438H5Ds53cr6T852c7+R8J+c7uTqTtklbViwOCLWZB7Q438X5rkN0YhB5Nr/avN83U5zcrlX41ea3lf1gu9bDRdzEb9x8AJRbsG7WMbZg5VtEbMF6uIg5Qh5Qvpo+dOLXS/JtKrZgAfPV9KERB3ESF3ETD9GJtDltWYXfrx2d3FZ1J/6/3/rmk5HcVlUYxNuYr7H5Lim3St18V5dbpQqdGMT70HOrVOG3vt/DF8+tUoWTuIibeIhODGLa/MOst4dGHMS0jcRFTNtKPEQnBvE2Zm0+NOIgTuIi0pbvQr/30o6tUg+D+J3Nk/9tbpV6aMTv2jl5FLlV6uEibuIhOjGItzG3Sj00Im2LtqzYb5eB5/anu3Kpsza/u1fP7U+FgziJ3wjfYyHPLU1354nN18KHRhzESVzEb313Ll++Fj50YhBvo/+IRhzEnG9eyvm6+XATDzFteYbydfNh2vKI83XzYdryx7JiT65DPtP9HkV4bmkq3MRDdGIQb2O+u31oxEGk7dKWNY9znDX/0IlBvIW5panQiIM4iYuYtpl4iE4M4m3Mmn+Y/60nBvE2ZsU+NOIg5swicTXma+H3fMdzO1HhJH7/7fdlt57biQoP8TtDnpPMent4G7Pevi/28NxOVDiI3xnyXKh80vtwEw/RiUG8jXlP+9CIg0jbpi3vXoFZm5hZ1ub3WMhzO1HhJC5ijpBLnfXmub5Zbw8HcRIXcRO/9f0eknhuJyoM4m3MentoxEGcxLSdxE08RCemLc9xvm4C8z41cnXyPjXyv81X04eTuIibeIhODOItzK9YKzRibv38JU7iIubWT0s8RCfmtXMTb2M+6X1oxEGcxEXcxEN0Im1GW9bm9w0HnpuMbuD/+63OzaPIe9qHQbyNWbHfhhnPjUP3eyTjuXGo0IlBvI159/rwW9/v02rPjUOFk7iIm3iITgxi2nLV83XzoREHMW15jvP95sPcVvXVBb427aERBzFHAC7iJh6iE4N4G7OOHxpxEGlz2pw2p81pc9qctqAtaAvagras45vXTv4F+d8vL4j8E/LFLhzCl5x/Rr7YhIfwFF7C4sU3qOUpxDeoAYOY+6O+KxXfoPbQiLkb65c4iYu4iYfoxCDextwK8dCItBlthtWzZKzSVxm54+iPV7IJD+EpjHFOMsb5zlTuJWo24SE8hZcwVvsmH2EXDuFLXj9hEx7C8O7kJbyFj3B6LddthXB6Lc/p/gmb8BCewkt4Cx9hFw5h8WaTyBfl3MFUOIjfOc8XudzBVLiJ3xWWtwC5g6kwiLcxdxc+NOIgTuIibiJtTltg9fIKDKxSTj6wSjlP1P7jI+xk1Pj3eNEnatnyjKOWH2/hI+zCIZyr/T1w9PzGs2YTHsJTeAlv4SMMryeH8CXbTxjekTyE4Z3JR9iFc/zvAzRfqHowqv57yOMLVf94CGP8nMNYwlv4CLtwCF8yusRjEx7C4p3ineKd4p3ineKd4l3iXeJd4l3iXeJd4l3iRZf4Hon5Qpd4fMnoEo9NeAh/dZOPWtZrAPh/h/Aln58whsyfPbzkc3tU8xHO8b+nbZ47pJov2XP8mZeqG3/Wh/AUFq+L18XrLhzCl/xaAli8IS60gZmXP9rA4xDGsXxtZqE9PDbhIZzjzywLtI3HW/gIw/uVyEZ7yEdUG+3h8RDG+JG8hLfwEXbhEL5ktIe8Zjbaw+MhPIWX8BY+wk5GS8jHdBulnw/cNkr/8RF24RC+ZJR+Pj/bKP3HQ3gKL+EtfIRdGN6dfMko/ccmPISn8OK5Q+k/PsIujPPytduNssa64cX/8RLewjiWvJa2rBVq/LEJY/z0nim8hDF+XidHztGRc3TkHB3xunhdvKj9x1NYrg2Xa8PF6+JCXefNY+7Wap7CSxhj5jX5bvPzGIM3nvv+hHP8fCC5UeOPp3COn48c97vNx88eYRcW76X3/H7CJjyEp/AS3sJ0HdT1t7nOD+r68RDGsazkJbyFj3CO/32y4Ae3A48vGbcDj+E9yRg/54baf3yEMX4kh/Alo/Yfm/AQnsLw3uQtfIRdOIQvGbX/2IRzzHz3dvDSnW/UDmoZjJfuxyY8hKdwzjmf7h/U+OMj7MIhfMmo/ccmDG+eI9T+4yW8hY+wCwfPHWofjNp/bMI4LzP5cN3wmv44hC8Zr+n5UPqErBVq/PEWxvjpxev74xDG+HmdXDlHV87RlXN0xXvFe8WL2n/swnJtXF4b/vsJD+Fdz6zyO8cKnRhEjPddj7n/C0+q8uvFChcxJ/ttNHRHcT924ZxsPrfO/WLvR8ePaEQaB42DxrGJh+jEINI2qUAR52NnRxE/PsKY/0oO4UtGET/Ok5xvdB0v4I+n8BKG9yRjfE++ZBT6Y4wfyUN4Ci/hLXyEXRjePNEodDAK/bEJD+EpvIS3cI6Zj34dL9SRa4vCfbyEt/ARduGccz4JdxQ0GAX92ISH8BRewlsY3jxHKPTHIXzJKPTHJjx47lDoj5fwFsZ5+a7PQBHnugVewB8P4SmMYznJXKvATfrjS8aLeT4DD7yYPx7CGD+Sl/zsFj7C4jXxmnjxYv7YhIfwFBbvEFdWdS4b9ok9NOIgYrybnB+45CHlI/qHQczJ5lP+QHE/NuGcbD44x7Yw/OhaxE2kcdG4aMzH9MD9IxpxEGnbVKCIs3MHihiMIn6M+a/kITyFl3Ce5PwgIfBq/diFQxjevABR6PmQPFDoj5cwxs/5o9Afu3AIXzIK/bEJw5snGoX+eAlv4SPswiF8yVnElo+p82vC/jjXNgu3OIRvc+4RazbhkbySp/AS3sJH2IVD+JIN3p1swkN4Ci/hLXz63F0U+uMQvmQUd77Y5h6yt265iaz5CLswjuW7lnLLWK3VHMJTGOOnd27hI4zxIznkZ+UcLTlHS7xLvEu8awlv4SPswuLd4sqqzjeAuaGscBMPEeN91+PlXpbLvSyXe1lyn5lZfj6QG82at3BO1vDfO380iL175jqNTqPT6JO4iJt4iLQ5FVnElp8n5Nd5NS9hzD8v8DjCLhzCeZLzKX5+q1ezCQ9hePMCRKHn0+6LQn8cwhj/7+KKHwr9sQkP4Sm8hLcwvDfZhUP4klHoj014CE/hHPN76h+56eyPR7IJD+EpvIS3cM75+22T+KGgH4fwJc+fsAkP4SkM707ewkfYhUP4klHo37mLHwr98RCewjgvMzm4buuSUdCPTRjHcpJlrfYRdmGMn959yecnjPHzOjlyjo6coyPn6Ij3iPeI94TwJbtcGy7XhovXxZVVPXNq+Wn7w9uYn7Y/xHh5PeYH6xO4iYeYk/0+B4gfivvxJaO4Zy58bpLBj2LLKXASabw0Xhp7I2r8eiNq/HojalhvRA1sSns4ibnY37P/MBTx4xDG/L8L3FDEj014COdJ/p73h+HV+vEWPsLwfhegodC/Z8NhKPTHQxjjR/IS3sJH2IVD+JJR6FgTFPrjITyFl/AWPsJORhF/z63D8Kq8cm1RuI+PsAuH8CWjoFeuOQr68RCewkt4Cx9hF4Y3zxEKHYxCf2zCQ3gKL547FPrjI+zCOC9fMzMUMdbNp/AS3sI4lryWXNYqfsImjPHTixfzx0sY4+d1EnKOQs5RyDkK8V7xXvHixfzxFJZr48q1ccV76Rp4Af+e8cfAC/h3FxYDL+CPl/AWPsIuHMLZS1KFbeZAIw7iJC7iJh5i/jrDt7wDJf/dW8VAyT8ewlMYh5PDoOQfH2EXDuFLRsk/zt/7iMRBnMRF3MRDdGIQbyN+UyuPeMnRoBk83sJHWI5mydEsOZotR4Nm8HgIT2Ee0OYBbR7Q5gFtHtDmAZ0fkct3uHz49aw84iNHg1J/HMKX7HI0LkfjcjQuR+NyTbhcEy7XhPOAnAfkPKDgAQUPKHhAweshuHzB5cPvb+URhxzNlSv8yhV+5Qq/cjRXjubK0Vw5mivXxJVr4vKamL8+oPkz4iBO4iJu4iE6sZcvd87lL7dG7pwrnMRFxKHM5Pqd15j4/c1E/P4mEOu0kofwFMY67eTNHz1EJ9I4aJw0Zg94OIiTuIi0TSpw1/59+BfYTVc8hDH/XLxX++AtfIRxnnMBX+2DL/nVPji9J+eDF/zvw6TArrniI5zjn7xe8IL/+JLxgv/YhIfwFIY3TzRe8B8fYRcO4UtGF3hswhgzz7vjZ3Nt8YIPxgv+YxMewlMYc841xwv+4yPswiF8yaj1xyYMb54j1PrjJbyFj7ALB88daj0Ze+2KTRjXmyefXjfsoysO4UvGzf73+VhgvxzWauGm/vEWzvE9vbipfxzCOf73+VVgH9372WHCQ1i8Q7xDvHjlf+zCIcxrA/voisWF713IQ8f3LgCdGEQcx3c94svEIofIr1h4uIg52e9DuMAmuGIXxiLl4Pk1C/jR/JqFh0akcdO4acyvQHl4iE4MIm2HChSxg7fwEcb8IzmELxlF/DhP8vfBW2BHXPEUXsLpjbwAUeiRFxEKHYxCf5zjR15cKPTHU3gJb+Ej7MLw5olGoYNR6I9NeAhP4SW8hTHmd96x881y/bHzrXgJb+Ej7MKYcyRfMgr6sQkP4Sm8hLcwvDfZhUP4klHoj0149LnbKPTHS3gL43r7mhl2xL11wzv2x0N4CueY3+djgZ1vb63wCO7xJePF/KYXL+aPh3CO/31+Fdj5Vj8r52jJOVriXeJd4sWL+WMTlmtjy7WxxbvFhS82ymXOLzZ6aMRBxHHM5PO+lCnwXWQPg5iT/T6EC2x5KzZhLFIuPL4fKX8U348E3EQanUanEd+PlIjvRwIacRBpCypQxDcXBkUMRhE/xvzzAkcRP57CSzhPct7aYvtbsQuH8OcdeaeIbW7j+zApsM2teAnv5JF8hF04hC85C73YhOGdyVN4CW/hI+zCIXzJA2PuZPzsSXbhEL7k+RM2Ycw5kqfwEt7CR9iFQ/iSF7w32YSH8BRewlv48NwtFw7hS0Zxfx9GBra/vXXbW/gIu3COaXktHVmrM4SncI5v6c0X8+IjnONbXidHztGRc+Ryjly8Ll4Xry/hLSzXhsu14eINceEbCfPQ8Y2EwE08RBxHXo/48sEcAl8+CBzEnOz3IVxgf1vxFsYi5eD5BYTvR4N4C3NzW6ERB3ESF3ETD9GJVKCIDTyFlzDmH8lH2IVDOE9yfvCWe96aTXgIp/f7tqFwFHp+mOQo9MchnOPnBzCOQn9swkN4Ci/hLQzvTHbhEL5kFPpjEx7CUxhjfucd29xGfkiGbW7FQ3gKL+EtjDnnmqOgH4fwJZ+fsAkP4SkMb54jFPrjI+zCIXzJKHScOxT64yE8hXG9eXJw3fySUdCPTTjHzM/HsM3trVUcYRfO8fMzNGxze5wv5sU5fj5rxja397NXztGVc3TFe8V7xXtD+DZjK1yxCQ/hJfxVdX7UkbvfCm9jfs3hQxzHTP7aRX5cFfjOX+Ah5mTzQzjsbyu+ZBR3fvCW+9vej+Y3ID6cRBoHjYPG/AbEh0G8jfkNiA9pm1SgiPPDv0ARPw5hzD//exTxYxMewnmS84O3wKv14y18hNP7fTdrBAo9P0wKFPrjIZzj5wcwgUJ/vIWPsAuH8CWj0FeeaBT64yE8hZfwFj7CTkYR5wdy2OY28kMybHMrPsIuHMKXjILOD8awza14CE/hJbyFj7ALw5vnCIUORqE/NuEhPIUXzx0K/fERdmFcb18BYvsb1g3b34qX8BbOMfPDM2xzw1phm1uxCef4+RkAtrkVL+EcP5/pY5tb/awLh7B4h3iHePFi/ngKL+EtLN4hrqzq7OO3v6s/cvNb4SLiOGby1y4GhriN/WX9gf1tIx/0Y39b8RTGIuXg+MJ+/OghOpHGReOmEV/YDxzESVxE2jYVKOINNuEhjPlH8hLewkc4T3I+3L94tX58yXi1fpze/ADgotDzQfBFoT8+wjl+Pri/KPTHl4xCf2zCQ3gKw5snGoX++Ai7cAhfMgr9sQljzDzveFXOB7jY5pZ8sc2t2ISH8BTGnCN5Cx9hFw7hS0ahPzZheG/yFF7CW/gIu3DUubs/FDoYhf7YhHG9efKpdbvY/lYcwpeMO/XvEcrFNre3Vrgjf7yFc3xPL17MH4dwjv99AHCxze397JJztOQcLfEu8S7x4sX8sQuHsFwbW7xbXHgB/x7qX2x/G9+z+Yvtb8UhfMmo/ccmPIS/XmJ5GvH3cYCbeIhODOJtxN/HAc73F2tu7nQr3EQcTB4kCv5xCF8yCv6xCQ/hKbyEt7B4Q7wh3hDvFe8V7xXvFe8V7xVv/skAy+st37E/DOItNDSK76HyzZ1x+feJbn5HW+Em4oAi2YVDGAf0nZncL/d+ND8qfziINBqNRmPe3z90YhBv46BtUIGX8e9TlIt9ccUunPMP/PeXjA7w2ITzhHyfYFzsiytewlsY3pWM8b8OY+gAj00Y45/kKbyEt/ARduEQhjdPNDrAYxMewlN4CW/hQ0YHiDzveJW/ubZ4lX+8hY+wC4dwzvnmmuNV/rEJD+EpvIS38BGGN88RmsHjS0YzeGzCQ3jy3KEZPN7CRxjnJQsQhY51Q6E/nsJLGMeS19KVtcKrf/JAUT/GnHfyEJ7CWKuTvOVnj7ALh7B4Tbx49X88hKfwEhaviSv/oOz3GcLN/XGFgziJGM+Tv3bxwxBBvI0o7u/TjDtQ3I+HMCabg+et/PvRTTxEGieNk8a8v39oxEGcRNoWFVnEE5xFXGzCI3kkT+ElvIVP8kx24RC+5APvSsb4eRGdJbyFMX5eXMeFQ/iS/SdswkMY3jzRvoS38BF24RC+5PgJY8w87/nKPS3XNgu3+JLzlbvYhIdwzjlflLDHrXgLH2EXDuHbnHvcmuGdyUN4Ci/hLXyEvc9d7nVrvmT7CeO8WPLudcO3xhW7cAjjWL5rCfvcsFbY51a8hDHn9I4j7MJYq5PMc4RvmSs2YfFO8U7xzi18hF04hMW7xLUwpidjzEg+wi4cwpeM2n9swuP9edg78bdmgYu4iYfoxCDeRvzN6FTgb0YDF3ETcSx5fvPPx+e9YG5nKzRiLv7IxUFRP17CuVAjL7D+c9I3vxKuMIg0Bo1BY/456YeTuIibSFtQgQIfWXQo8MdTGPPPCxsF/vgIu3Ce6JEXMAo8GRvbik0Y3pOM8T35CLswxo/kS0YhPzbhITyFlzC8N/kIu3AIX/L4CZvwEM4xv080Ljawze8TjYsNbMUmPISn8BLOOX8fBlx8EVyxC4fwJa+fsAkPYXjzHKHYH2/hI+zCIXx57lDsj014COO8zGTnuuFF/PEl40X8MY4lr6Uja4UX8cdHGOOnFy/ijy8ZL+IzrxOXc+RyjlzOkYvXxevixYv44xCWayPk2gjxhri+qt5Ytu+1vRAj5pWHl3YwXtofm/AQnsJLOI9k5Sqj8h+7cHpXzgyVn4zvhytO7/cRzcUuueIp/D36yMLMTXKFh+jEIN7G/ErYh0YcxEnMcS3RiTiWmXzJqPbHJjyEp/ASxhru5CPswvCe5EtGp3gM70oewlM41zCXPP9Q9cNDdGIQb2P+oeqHRhzEScTReLILhzCOJtccfeCxCeNobvIUzlXceXXghv/xEU7vzrOHXvH4ktErHpvwEJ7C8OYxooc8PsIuHMKXnF8g+wP+Db/yPW/uotv5TiR30RUeohODeBvzD9E/tG/cnPV3X1A4iYu4P8zr7esghU4M4m38+kehEQdxErFCOTX0iMchjBX61gLfI1dswjgzO3kK48yc5C18hOH15BC+ZNw1PDbhITyF4Y3kLXyEXTiEL/nrIytfaHOv3cr7n/ymuTWBm3iITgzibZw/4neO8jUst94VTuIifrYBPEQnBvE2fj2i0IiDOIm8IrCtrjiE5YrYckVsuSK2XBFbrogtV8SWK2LLFbHlithyRWy5Io5cEUeuiCNXxJEr4sgVceSKOHJFHLkijlwRR64I5xXhvCKcV4TzinBeEc4rwnlFOK+I4BURvCKCV0TwigheEcErInhFBK+I4BURvCIur4jLK+Lyiri8Il6PuMkuHMK3Gd83N79PRK+jRzwewlP4O5p8gcpteYWH6MQg3kb7EY04iHnCvw8zL7bnFbtwCF8ybiUe43A8eQhP4SUMbyQfYReGN5cOtxJg3Eo8Tm9+oIdtezM/0MO2vZkfoGHbXvEWPsIuHGS8ccgPzfAtdMX42Z3swvjZk/w3Z9wV5a69QiMO4iQuIkbOFUNZ5/v63ICHO47cf1c4iTkGfm4TD9GJQbyNeNeQ77Kx7644Fzk/q8G+u+IlnNPOZ+q51w63fdhq99YmhvAUXsK53vkxD7bgFbuwrDfeKoDxVuGxeK94Ub75URC21xWHcI6Zn11ie12xCQ/hKbyE81jyo47AS/xjFw7h9OYTH3wDXbEJpzdvV/ANdDOflOMb6Iq38BF24RC+ZNT3YxOG9yZP4c+78sl37tKz4iPswpGcx5L1/Tjru9iEh/AUXsJbGN6V7MI4v7luE97k9RM24SE8heE6yUfYhXGMnnzJ+ycMV67hHsLpyqeV2N1XvIXTm58fY3dfcQhfcnaRYhMewvDmdXiW8BY+wi4cwjjevGbQNrKTxWsb+d+8tgHewkfYhUP4kvGwIXtwvD4DHsJTGH0m54Y+8/gIu3AIX/L9CZvwEMa65TV5j7ALh/BtxpfhrXyCji/DKx7CU3gJb+H05kNcfBlecQhfcvaclY8SsEuweAinN+8jsEuweAvDu5Lh3cnw5tzsksdP2ISH8BTOl7Qkb4qmWzR/TVaEGs9bOWzsK57C3wtpHslX7Y9OkzdF0y1CLedDmouazYep+R11C/+FN0XTd/eW6/vV6iNrGk2zaTWlZeYZRIU+zpWf+G9C+JKzQhdm7hgnr0A/wt98c0THKLmOfslZh8UmPIRnrVD06kavbvTqRq9u9Ope45rexTVFjeUDW3wPXTGOPK8V1NhjzPnvHH9/H+p7CmFAIw7iJC7iJmLoyIB6+R47fuFvlIP/KP8y28NF/Bvlu93/8BCdGMTb+BVKYfrWC0NDXskLIrw8V9gacvbf5ff9OSmMNhGGhm8VcFR4yX3Lh9fcCkeDa4BlIVwJeOGtYHWWvjA0TA06g6UzWDqDpTNYOoOlM9g6g60z2DqDrTPYOoOtM9g6g60zwMtyhYtq+v5MQpfNF0zD0DA1LAmOk4uZoXwrHA1fST0M4m3M2/WHRhzESVzETTxE2oK2oO3Sdmm7uOhQTHdqWBryKDcWEDVfIZd8YZVR9RUuA/bbdTANQ8PUkDPYE2FrOBpyBmgO2JLX4UrAq+xeCKZhaPjW/AIXcRMP0YnRiBbxPWf6Ao7hIOAYcHS4U6/gGkIDjgFD4269gmkYGqaG7ygwFpoHOhk253VwDek/A+FKQPOokP6DZUPzqJD+gxVA86iwNXyvzZjZ1zoKg3gbv6ZRaESMjdVF8Z/3v+AYAuFKQPlXMA15DI5FQPlXWBq2hqMhH8EDg3gb87EdTosbcRAncRE3ET5c0nmz3iEk4HagAmaPsxZbw3cGcPD5sO5hEHPlHKc17787mAasHM4DukgFuHFS0EUq4EjgQRdxHCO6SGDJ0EUijwQb/DqYhu8GIoCTuIhpiDxubNhbMREwzkLII4mNkEcSByGPJBwBo2Fo3F9XuBLyxuECjTiIuSLxQo5zfwjf7Qdk+efQH+ZcL44ZNX9xSKj5CkvD1pCrfnHkqPoKoeFKQNVXMA1Dw9QADxYVL/8Xi4rX9YtFRQFfHBxe1yscDS4BBVwBo2G5UaYVMBqWNm/E9w9Lm++J9w+LmC/mHbaGkwHrlqXWITRc8eQtef0vWYQdhoapYcnqoDwrHA0u4eoaoBTfYaMUK+jqoODetXZxPDhZF8eDk5UF9wI22nUwDUPD1LA0YEU3wtHgGjCDg4AZ5MFhy93+BQJmcBEGy2WiVCssDemxF0LDlZClislkqT4cxDwSMwSMMxC+Us2VzM12hTlXeyFXy7AmWaodloatIVfLYJ+uITRcCVmqHUzD0DA1wIO1XxgNa7/xn2HtN/4zrP12DaHhSvhK1bEC3ytt4SBO4iJu4iE6MYi30Wlz2pw2p81pc9qcNqfNaXPagragLWgL2oK2oC1o++oZr9a5za5wECdxETfxEJ0YxFuYu+sKjTiIk7iIm3iITgwibUab0Wa0GW1Gm9FmtOWN8h4HIS+8MRDywht55WJPXO7Z+f7WYW5DAU7iIuYOdmAQb2O+TO1xEbaGoyEnNzHT3FGKCeSOUmBWxEMjDuIkLuImHqITaTu05XOmPXGUeHGbE+HbXI9Z59cvPQzibcyvX3poxEGcxEXcRNqCtqAtaLu0XdoubZe2/K50nKL8rvSHh/hnw91SbjgrvIXYVrbxxh7fsrbnRsgzi7fJ+J61DqHhSsCLVQXTMDRMDUvD1qAzMJ2B6QzwMoa3eNhy1sE0DA1Tw9KwNRwNriE06AymzmDqDKbOIL9i9QIXcRMP0YnRiJc3PAfEF7Ht+f6X7xjwSv2+ie2xC38HgNf+901s4PcXUMAmPISncC4RHu5h+9jGwz3sH+tgGnIh8KQPW8g6LA1bw9HgGkLDleA/DaZBZ+A6A9wPL9QAWkaFowEzwLnE/XAFzACnBffDeO+KP2W68TgGf8u0w9SQM8DDHfw50w45AzyoyR1ofwHTyY+MNh6z4Lve3uHgRvmxCQ/hKbyEYcjDwp6zjTeT2HS28bgEu846TA15JHj2jI1nHY4G1xAS0ELwvAW7yTbuLrGdbON5C/aTdXANoeFKQKOoYBqGhqkBM9gIW8PRgBkchNBwJaBRVMAMsNZoFBWmhpzB4y18hKEHh/Al4z75sQkP4RTjhKO9PN7COO4XXENouBL20IBVvAhHQn4OhXXPD6IeTuLXIHFp5F9IehjE25h/IemhEQdxEhdxE7HCL7iGkICCx2Ohg4KvMDTk2jquFxR8ha3hO8T3E04M4m38Kr3QiIM4iYu4ibRd2i5tt225vazQiIM4iYu4iYfoxCDSZrQZbbinwIM2fCdch6UBKxoIR4NryNOIG15sPauAVoGnZdh81mFomBqWBlQMZo1WUSFngMdt2IO28bgNm9A2HrdhF1oH04AZ4BDQKiosDd+6v584RCcG8TZ+baIQY1+EPAbcY2JL2sb9JPakdbgS8saiQx4DnpXh6+Q6TA1Lw9bwzQDPs95fTsUa4r34fQF+HABuRyrAj6PJ25GDp174XrkOKwOUeTtynidvRzrk/VM2gLdn7TF2uIKPsAtHDoSTnvcOFbKVdDANQ8PUsDRgwjjIOBpcw+WMscXksQnjdw3AU3gJp+4tQz5s6+Aa8oDt/cxlwJ63gydG2PTWYWjANk/wEt7CR9iFQ/iSse3tsQkPYfGaeE28Jl4Tr4nXxDvEO8Q7xDvEO8Q7xDvEO7DaGyE0XAkTq42fmaZhaMjLCw/EsPutw9ZwNGAGgYAZXARs+UvG79U9NuHUjx/C1LA0bA1Hg2sIDVdCNqQOpkFnsHUGW2eAjfM4Smycf+zCIXzJ2GH72ISHMPZagZfwFsaBv+AaQsOV4DjwgWAahoatAaOhUNGmBq4jtKkKpmFowGi4QAKj4TDjSrg/DaZhaJga8qRMnBR0oQpHg2sIDZcBu+A6mAbM4CBMDUvD1oAZGIJrwAwGwpVgPw05AwyW3ah4Ci/hLXyEYcgWih1uB30bW9wOXo7wTXgdtoajAUfiCKHhSkCPqWAacgbYkYK/GtthadgajgbXkDPA+wL87dgK2WQ6mAbMAMeDNlNhacAMMGu0Gby3x9+Q7YAZXIQrAW0GH4BftJkKQ8PUsDRsDUeDawgNV8LRGRydwdEZHJ3B0RkcncHRGRydwdEZHJ2B6wxcZ+A6A9cZuM7AdQauM3CdgesMXGcQOoPQGYTOIHQGoTMInUHoDEJnEDqD0BlcncHVGaCz4ekP/shth6Vha/ibwfg9duEQvsWW2w6bTXgIT+EljAMcGdCc8oGUYfdhBxzGQpgaloat4WhwDSFhwLMReFoMewuxKIZv+uvgGkIDTsvJgBZVwTQMDVOkU2cwt4ajwTWEhisBLerNDS2qwtAwNSyZG1pUhaNBZ7B0BktnIC3KftKi7Cctyn5b12Avmc7Ws7D1LGw9C69FYW5bz8LRs3B0BkdncHQGR8/C0bNw9CwcXYOja/BaFObmehZcz4LrWXA9C69FOcLWgBkEgmsIDVcCWtTB0GhRFYaGqWFp2BqOBteQMzgoZ7SoF66WGbrSQW2jK1VYGrYGvfhwv1VBT/2VU4+dkR1Mw9Agpx47IztsDUeDawgNcvmb/TSYBhzpQtgajgYs70bA8mLWuOt6Yfw0mIahYWpYGraGowGevPiwS7KDaRga4AmEpWFrOBpw34fDRkurcCWgpVUwDUPD1LA04J0MJvrewr1wJby3cC/gSC8C7sgxa7SnCkdDehxnG+2pwpWA9pQfwRv2TNYAZ2iYGnQGR2dwdAbvPdsLoeFK8J8GnYGrFH0n37MZtkd2CA04uCxafNNhhxzacSmj71SYGvLgHBcf+k6FowHLi7mh71S4EnBrVAEzwGlEE6owNSwNOYPAyUKrCZwstBoEbJ/skJ7cEGn4hsQOU8PSsDUcDa4BM5gIVwJaTQXTMDRMDUvD1oCh85TgLweffHps+NPBHZaGreFocA04hEC4EtBdKpiGoWFqWBq2BszgIriG0HAloLtUMA1DTjC6S4WlYWvANZo9BF+uWCuKhlJhaJgacuh8GG7YqVmLiIZS4UpAQ7mYARpKhaEhPRdX1dHTePQ0Hj2NR2dwdAZHZ4CGUsE06IXkeiG5zsBV6v0E3LAHtNiEcwfBAk/hJZyHdbGwaCUVXEMe1oUbreQFtJIKaceZxR83ezyFl/AWPsIuHMK3GTtFi014CE/hJbyFj7ALh7B4TbwmXhOvidfEa+I18eJ+5r4QGq4E3M/khyiGP13c4ZN7fjxj+FLHDkvDzjAQjgbPYAih4UrIXuS51daw4bQDZjARpoalATM4CEcDZhAIoQEzwJGunwbT8M1g4EDfX1IDL+EtfISdnC3J7YU8EsPRZ+NxVBf+1HGHo8E15JGg2rBXtcL5aTANQwNmgCvgLA1bw9HgGkJDzmDgeLIldTANQ0POAHcy+MLIDltDzmBg1nkr5Pko2vDXkztgBjjp8dOAGWCiMTRMDUvD1nA0uIbQcCXcnwadwdUZXJ3B1RlcncHVGVydwdUZXJkBvnqyg2kYGqaGpWFrOBpcQ2jQGZjOwHQGpjMwnYHpDExnYDoD0xmYzsAwgyxxfE1lB9MwNOD9C3gJb+Ej7MIhfMnvkTnYhHGAFyEPIz+WMHxvZYc8jPyIwfDNlR1Mw9AwNSwNWwM8WV34Qspau62LghZVYWnYGvK0TBwcWlSF0HAlHL0wjs7g6IVx9MI4emEcvTCOXhhHLwy0qDfRoxeG64XhemG4rgFaFN7L4jsuO2BFN8LR4BpCA9YAQ6NFVTANQ8PUsDRsDUcDZoBLDC3qBXSld+rRlRauN3SlClPD0rDlNF499VdP/dVTf+XU42sxO5gGOfVbu9LWrrS1K23tSlu70tautLUrbe1K2MHs+RmsYQdzh60hPbnr1bCD2Rdmjd5T4UpA76lgGoaGqWFp2BrgWQhXAu6dKpgGeDbC1LA0bA14vcdhoz1VCA1XAtpTBdMwNEwNS0Nu/PmBQ/iS8/YJd5XYz1w8hHGMgbA0bA255whq7Dl6HMJY4iwb7IDuYBrSjqXLdlW8hLfwEXbhEL7k7FPFJixeF6+L18Xr4nXxunhdvCHeEG+IN8Qb4g3xoi/hKSx2OncIDdjghZ+5Pw252nhOj83OHaYGbDDDSblbA7a44cxjJ3SF0IAdW1ls2CPdATMYCEPD1JArEOAtfIRdOIQvGbdG+CgOu6MdH55hd7TjqT52R3cIDVcCmhA+zMDu6A5Dw9SwNGAGmBve2lVwDbk9xsCX/L60H5zbY37gITyFl/AWPsIuHMKXjD1Jj8W7xIt+lN8uYNgY7ef9L1vD0eAaQsOVgPd6FUzD0DA16AzQr3DLiO3UHVwDZoD1Rct6AS2rAmaAywi3WBWmhqMhf/kAnF2o2ISH8BRewlv4COM4cJniNqnClYDbpAqmYWiYGpYGrCQuU7SjCq4BMzgIVwLumSp8M8DN+8Ff+3k8hZfwFj7CcL8QGi4DvvzTc0u64ds/OwwNefT4jMNxt1Rha8ijxwcEjrulCqEhZ5Ab3A17s+t/+TrQeuhE/HAgXAnoPhVMw9AwNeT08QAeG647HA2uIWeAh+nYcF0BN0cVcgaBA8PNUYWpATPYCFvD0eAaMIODgBngeHALhOfa2HzdYWnYGtKDZ8fYlu14doxt2X4xUbQcvFBiW3YH0zA05AzwXBXbsjtsDUcDZoDjQZfBiyv2Ygfu0LAXO3Arhr3YgbsA7MXusDRsDUeDawgNNwPm5j8NerHivVuFpWFr0KJwLQqHFIftV0L8NOCwsSAxNEwNS8PWcDS4htBwJdyfBp3B1RlkWwo8MsQe7w5bw9HgGkJDziD3Exs2eXcwDUMDZuAIS8PWgBlchJwBHptip3eHnAGeH2Kvd4ecAR4ZYrd3h6lhadgajgbXEBquhPHToDMYOoOhMxg6g6EzGDqDoTMYOoOhM5g6g6kzmDqDqTOYOoOpM5g6g6kzmDqDqTNYOoOlM1g6g6UzWDqDpTNYOoOlM1g6g6Uz2DqDrTPYOoOtM9g6g60z2DqDjRlMhNBwJaANVkAtgIfwFF7CW/gIu3AIX7LjABcC2toLOIyN4BpCw5WAtlbBNAwNWC7Ud+hpCV2Uq4uCFlVhaMBpQRtAi6qwNRwNemFcncGVCwM7wDuYhqFhalicG3aAdzgaXENwbve1KITXol7QGWiLutqirraoqy3qaou62qKuyaV5Tc7CHT8NpmHI3MbUsDToDLRFXW1RV1vU1RZ1tUVdbVF3ynVwX4t6Qc/C1LMw5Tq4r0W9oGdBW9TVFnW1RV1tUVdb1NUWdbVFXW1Rd+l1sPQsLD0LW8/C1rPwWlQgTA2YwUXYGo4G15AzwPNd7B2vgBZVwTQMDVPD0rA15Azw4BZ7xzvgUUSyGxsFNogHnp5jg3iHpWFr0JPterJdT7ZryYWW3GtiL+gFH3qyQ0926MkOPdmhF7w2vht6uV293K5ebmhv+DQA28A7HA1YUKwb2tvErNHeMgz8jfgOpmFomBqWhq3haMCb0JUBD8wrmIahYWpYGuC5CEeDa8gjzQ8aBv44fAU0sQp5pPlgfuCbaztMDUvD1nA0uIbQcCWgiVXQGUydwdQZTJ3B1BlMncHUGUydwdQZLJ3B0hksncHSGSydwdIZLJ3B0hmgieVHHQO7y2PhNKKJVTANQ8PUsDRsDUeDawgNOgP86i+mht/8fTyE8/eOJ3gJb+F8JozjxVeQPA7hS8b3jzw24SE8hZfwFhavixc9Kz+BGdgXHguFiM6Un1sM7AvvcDS4BPSfjWrB7dXzoP9U2BqOBtcQGvJsYBWx4buDaRgapoalYWs4GnA8FyE0XAm4vaqAGSyEoSEfTR7wEt7CR9iFQ/iS0ZLyKfvAt97Gfv9LaLgS3o5LsAkP4Sm8hLfwEXbhEL7kJd4l3iXeJd4l3iXeJd4l3iXeJd4t3i3eLd4t3i3eLd4t3i3eLV70iY2Am50KeV3kk/CBbd4d8srM35kY2ObdYWs4GlxDaLgS8FiqgmkYGnQGuA86qADcB1XAB+1gFw7hS8adDl59sas7Dq7U7Br3/Q8uHMLfSBf/ffaSYhP+DBe2bDHFS3gLH2EXDuHbjB3exSY8hKcwztFBwJnI04+d2pHP0wd2ancYGqaGHC1/TWBgc3bkk/YxUPYVTMPQMDUsDXk28k36wLbtDq4hNFwJuBOpYBqGBszgh7A0bA1HA2awEUIDZpCvSdi23cE0DA1Tw9KwNRwNriE06Ay+xjIMJ/trLM1D+PslSHv//RLewt8vXxoO8WsszSF8yecnbMJDeAov4S0s3iNedA3HhYveEDg16A2BKxK9ocLR4BJwVxEoENxVBC4O3FVU2BqOBtcQGvJsBFYa9xsVTMPQMDUsDVvD0YAZoHRwJ1LhMmDPdgfMwBGGhu/U5PPiga3XkZ/RDOy97mAa8PMXYWr4zu14/9UWPsJORufI3y4Y2EodF1P5+sPIt88jd1I3H+FvpHxXPHIbdfMlf51hTCzC1xiah/AUXsJb+Ai7cAhf8hLvEi9q/r6QZxKvMBOVjZcSfFNvBbzHqGAaMBrOJN4vXKws3i9UuBJwH1DBNAwN+ULyw6nJ+4AOW8PR4BpCw5WQFd0BMzgIQ8PUsDRgBrhS/GjADHB9eGi4EuKnwTQMDVPD0rA1HA06g68/DLyHzJ3QxV93aP6uDry1zG3QzVP4uyrxVj/3QDcfYRcO4duc25+bTXgIT+ElvIWxsnnhYhPzzU8bBzYx3/x674FNzB2Whq0Bo2ULwYbka/Dk/UOHqWFp2BqOhjwb+VHdwK7kDldC3j90MA1Dw9SwNOB4AuFocA2hATPIKwW7mTtgBhsBHvzMwpFiqdbR4BLyzcRFV8ee5Q5Lw9ZwNLiG0HAlZC/pYBp0Bvnyj3ekuWW5eQt/lzLen+d+5eYQzksZK+E/YRMewlN4CW/hI+zCISzeEC/6w8AlgC4wUBPoAgNnEO8jKlwJeCdRAaOhJvDeAC+T2EbcITRcBmwj7mAa8A7hhzA1LA1bw9HgGkLDlWCYwUEwDUPD1IAZGMLWgBlMBNcQGq6EgfdIG8E0DA1Tw9KwNRwNriE0XAlTZ5C3HHiXkzuPm6fwd2XiTWpuO24+wt+Vifdeuee4+ZLzlqPYhIfwFF7CW/gIi3eJd2NlcQbRUyYuNfQUPL3GpuIOriEkoHPg9RC7hC9e+LBNuMPR4BpCw5WAew08KsVm4Q5Dw9SwNGwNR4NrwAxQBrjXeAH3GhVMA2aAKwW9pAJGy1aAPb0XbRJ7ejtsDTk3PJPEnt4OoeEyYE9vB9MwNEwNS8PWcDRkDw9wCF/y1y5G7jUd+W3IzUP4u2Jz3+3IL0lu3sJH2IVD+JLHT9iEh7B4h3jRBfBcHTt5L56oYivvxdNP7OXtMDUsDRgNQ+Me4K0N7gEqDA1Tw9KwNeTZyK2zA1t0O4SGKyHfaXQwDUPD1IAZHISt4WhwDZgBrhTcUbyAOwo84sMW3Q5Dw9SQM8DDvIOOUeFocA2h4UpAx6hgGoaGqUFnkHcXeESRm3ubXfi7MvFIIrf2FufdRXH2cFRBDOEpvIS38BF24RC+5HxDUizeK150GzxOxPbci8eJ2J578ZwQ23M7mIahIUfDywm22l68HmKrbQXcUVQwDUPD1JBnA8/88AXJHY4G1xAargTcUVQwDZjBD2FqWBq2BsxgI7gE9BI8zMOu3A5Dw9SwNGwN8ASCa8CR4izgPcgL6D+4Qh39p0LOANcl9ut2yBngKRP263bIGeBJG/brdsgZ4KkZ9utWQP8JLAj6TwXM4CBMDZgBDhv9pwJmgMNG/6mAGeCw0X9eQP/BEyls3u2QM8DjKWze7ZAzwDMdbN7tkDPA43hs3u2QM8CjH2zerZBvbNBKPN/YFA/hKbyEtzDcL7iG0AA31gX3KhVMw9AwNSwNW8PR4BpCg87g6gxw53NxZvClgHhq5PhWQDz0cXwtYIXLEPhiwAqmQY4H+3E7LA1bw9HgGkKDHA/243YwDToD0xmgS+Gwc29tHXbure1DGHo8eevSYWpYGvR4hh7P0OMZejxDj2fq8Uw9nqnHM/V4pq7o1BlMnQF60TvsNeSwlx7P0uPJ9y0djgbXoMez9Hi2Hs/W49l6PFuPZ+vxbD2ercezdUW3zmDrDF5fwWGfLYd99HiOHs8JDXrFu14hrleIY0UHwtTwrSg6cODm5fERdnLAMREw0vtfciQcSt6OFB/hbyT01Nwo23zJeTuCXp27ZJuH8BRewlv4CLtwCN/m3BzbbMK45jYCzoQj4Ey8/+xKsJ8G05Cj4Qllbln9dpAhhIYrAZVfwTQMDXk28BjxovIrbA1Hg2sIDVfC/GnA8VyEoWFqWBowg4VwNGAGByE0XAnrp8E0DA1Tw9KwNRwNOoN80HEfX3J+wlr86fHBS25XbZ7Cnxsvs7lXtfkIu3AIX3J+wlpswkN4Cov3iBddAx/zXvQGPC++6A0DVyR6Q4WlYWvI0fDwM/eUfnsNEYaGqWFp2BqOhjwbeCyae0oZroTsEh1Mw9AwNSwNmAFKB/cXFVxDaMAMvqtgvi8erpAzyCeh8331cIWcQT7VnO/Lh/PjwJm7TUf2/pmbTZtdOIQvORtMsQkP4Sm8hMVr4kU3ys9O5w/dqMKVgG5UwTQMDVPD0rA1HA2YwUYIDVcCulEF0zA04GdwcOgfFUzD0DA1LA0564WTiv7xQpb9b+EMZ9132BrwMxPBNYSGv1nPH66qr/ibTXh87OApvIT3x1iJ72ai2YVD+JL9J2zCQ3gKL2HxunjzScdv4USjSywcDbrEwrTRJSpsDUcDRsOpQcVvnA1UfIWlYWs4GlxDno2NGkXFIxgqvoJpGBqmhqVha8DxBIJrCA1XAu4rck/oNNxXVMAMDgJm8H5madgajgbXEBquBFR/BdMwNOgMvuqfhnl+xd98hL/LMm8JZm4Ybb7kr+6nYfW+sm8ewlN4CW/hI+zCIXzJS7xLvOgP+ax6Gu4i8knmzA2g3y5shCsh7yM6mIYc7eBQ0R/y3fw09IcKV8L5aTANQ0Oejfx25Jn7Ohm2hqPBNYSGKwHvOSpgBjijuK+oMDUsDZgBrhQ/Et439oKH8BRewjlSPmubhm5RwTWEhisB9xQVTMPQMDUsDTqDqzO4OoOrM7gyg/H7aTANQ8PUsDRsDVjNi4AZDITQcCWgw1QwDUPD1LA0bA1Hg84Av9sS4EvGrrDH2B4EHsJTGPsowVv4CLtwCF/y20UKNuEhPIXFO8WLdzD5ye0cuM/IZ7xz4D4jvz96DtxnVFgatgaMhuVAt3Ac9x4apoalYWs4GvJs5JPcif2dHa4EdJgKpmFomBqWBswAq4MOU8E1hAbMAFcKOkwFzGAhDA1Tw9KwNRwNriE0XAl45lFBZ4D7GJwe3MY8XsKpx6KjKz12YRw9+JJfRwKb8BCewkt4Cx9hFxbvpXei2+Tj9znRU+L9L1i/QHANoeFKQOfIxzsTW0N/+fR8Ym9oB9cQGq4E3IFUyEXJ5+pz4g6kwtSwNGwNR4NrCA04njxb2FfawTQMDZjBQlgaMAMsLzpGhSsB71kuFh69pAKOFMuLXlJhaYAH08F7lgquITRcCbhbqWAahoapYWnQGWydwdYZbJ3B1hkcncHRGRydwdEZHJ3B0RkcncHRGRydQfYffM/ezB2rDKZhaJgalob8TSqcUvSVVwroKxVMg1ZMYGRc8KEVE1oxoRUTOIJsmthx2sE04AhwjaORvAHQSSpozV6dwdUZXJ3BlZrF3tMOpmFomBq2hvwFhHzSPPM7dTvYTwMO7iAMDVPD0pC/h4DGl9+py+AaQgNmkFWWG1W/38NDmBqWhvTkk9+ZG1UZXENouBKy7XQwDTkDw1Jl2+mwNGwNR4NrCA1XwsLQEwEDYOGXawgNVwJ+T6WCacAh4JTgV1UqLA1bw9HgGkLDlYDfWDGcRvzKSoWhYWpYGraGIycYv7hSITRcCa+FbIQlK+pbw9HgGnBwuPhCFzGGhqkBHswgtoajIT0DV1XoaQw9jVdP49UZXJ3B1RncpWFr0Avp6oV0ZQa5w5UBNz2BsDRsDUcDDi4v5f3e51wE0zA05CHkg+650TYqbA15CPkEe+73PucNEBquhKEzGDqDoTMYU8PSsDUcDTqDoVJ0ioFFRKeosDTg4A7C0eAaQkNeIbmFeWI/agfTMDRgBjg/aCgDE0VDqRAa0oOn6xsNpYJpGBqmhqVha8gZ4Fn9RkOpEBquBDSUCqZhaJgaMDQuF9xf4An4RnOoMDRMDUvD1oBDwClB26gQGq6E+GkwDUPD1IAZ4DSioVQ4GlxDaLgS0FDeCUZDqTA0TA24RjdCyIrey3DQNiqYBhxcIMgi5mZWBtcAz0W4EnAfUiE9+HwAO1prAJsalgadgekMTGeA+5AKV8L4aTANOoOhUnSK80JouBLwjqcCDs4Q8CxvI2wNR0MeQu7Lngdto8KVgLaBT0LOkueZZw0NU4POYOkMls5guYbQIE9Uz/5p0BlslaJT4NOMg05RITTg4LJkDjpFBdMwNOQVgs85Dm49KmwNRwNmgEsZDQWfjRw0lApDA34vF9coGkqFreFocA2h4UpAQ9m4QtBQKgwNU8PSsDUcDS4BnQKfgBzcYGwsPJpDhaPBNYSGy+BoG/g8xdE2KgwNU8PSsDUcDa4BM3CEKwENpYJpGBqmhsUT7GgoFY4G14BrNK9rR6fAijrey1RYGrYGHFwg6CLiHUsF0wAPZoD7kApLQ3pys/n0eXQA1xAadAZLZ7B0BrgPqTA1LA1bg85gqRSd4q0ono1UmBqWBhycIeATNxwpnoC8gCcgFfIQ8ImRo21UmBryEPAJi5+tAxwNrkFncHQGrjPAE9gKQ8PUsDToDFyl6BR4YXF0igpDAw4OJYNOUWFrOBryCsFnQ45bjwpXAm49KmAGuJTRUPDxiaOhVDga0oOPXLAdtcNlwHbUDqZhaJgacga5T34GGkqFo8E1hIYrAQ2lgmnA0BMBAyyEKwE3GBVMw9AwNeAQDsLWcDS4htBwJaChVDANmIEjTA1Lw9ZwNLiG4AkONJQX0FAqmAZcoxvhyIrivUyF0HAl4L0M3qzG1kV8X9fxwtYAD2aA+5AKoSE9gavq6Gk8ehqPnsajMzg6g6MzwH1IBdegF9LRC8l1Bq7St8tsIBwNriE04OBwKcv+sxmy/2yG7D+b2KBq+FAJO1Q7uIY8hHg/c2WAt//sBdOgM7g6g6szuFvD0eAaQoPMAHtUO+T5wadSF52iwtGAgzsIoeFKQKeokFcIPv65uPWoMDUsDZhBIMBzEa4ENJQK6cEzb2xs7TA1LA1bw9HgGnIGeJSMja0V0FAqmIahYWpYGrYGDI1TghsMfOKDfakdloat4WhwDTgEnBK0jRfQNiqYhqFhalgatgbMAKcRDaVCaLgS0FAqmIYhJxgNpcLSsDXgGs0+etEp3orivUyFoWFqwMHh4nNdRLxjqXAl4D4EH/9gQ2uHoeHzDHyugw2tPYCextDTGDqD0BmEzgD3IRVMg15IVy+kqzO4KkWnyI8H1tupWsE0DA04OEPADukXXENouPkzI0O2jQ6mYWSYCFMGePvhX9gadAamMzCdgeyUXz/ZKb9+slN+/WSn/Hp7UyuoNDvFyE+TFjadVpg/DTi4gzA0TA1Lw87gCEeDawgNmEFkWPBchKlhaUjPO6fZUDq4htBwJWRD6WAacgZvqbKhdFgatoajwTWEhivhYGhcLgcDYOGPawgNV4L/NJgGHAJOiU8NS8PWcDS4htBwJQRmgNMYpmFomBqWhq3hyAkO1xAaroSLa3QjLFnRuzUcDa4BB5cXH7a7vkXEdtcOUwM8F2FrOBrSk58zLWx37QHkNGK7awedgekMTGeAryGrsDUcDa5BZzBUmp0CX5G2ch/r972GCFvD0eAaQsOVgIZSAb9TA+n7nZoXpoalYWs4GlxDSMBv9l6cBTSUvINchoZSYWnYGnCkbzTXEBquBDSUCqZhaMCR4qLAk5IKW8PR4BpCw5WAZygVTMOSBTl6pOg7FVxDaNAjdT1S1yN1PVL0nQpLw9agR+p6pK5H6nqkoUcaeqQxNOhah671+11dLEjokaK7vHB/GkyDHunVI716pFeP9OpVdfWqunpVXTnSt1e2gmkYGqaGpWFrOBpkrcf7Ld6LIEeKHbEdpoalQY4UO2I7uIbQIFfVGD8NpkGPdOiRDj3SoUc69EiHHukIDbrWU9f6fQuBISwNW8PRgCPNFyN8Xyq+sGHh+1I7DA1Y0YOwNGwNWFFHcB0gNFwJW2ewdQZbZ4Df/K2wNGwNR4POYKv04HIJhKlhaciDm1hrNKEKriE05OUysdZoQhVMw9CQM5iYG25xJi5Y3OJUCA3w4OLDLU4F0zA0TA1Lw9aAGeAKwS1OhdBwJaAJVTANQ8PUgKHzcsnvSf2+2RfBNAwNU8PSsDXkIeSnvgt7YzuEhisBtzgVTMPQMDXkDPID2PW+arXC0eAaQsOVgO6CE4z9tB2GhqkBBXgRQlYUtzgv4BangmnAwQ0EXUS8M6rgGnAImAHeGb2wfhqwiAtBT+PS07j0NC6dwdIZLJ0BbnEqXAlbL6StF9LWGWyVvm9FwoLgOwIqXAn4VpIKOLiNkB1pYzR890iFowHXwUEIDVcC2saCB9999AbAdx9VmBp0Bq4zcJ0BvoGkQmi4EvANJBV0BqFSdIr1gmsIDXlwGyWDTlHBNAwNeYVsFAZuVypsDUdDziB/qW9ho+vID0YXNrp2GBrgWQhLw9ZwNLiG0HAloKHkV4wt7IftMDRMDUvD1nA0uAR0ClyW2OiKb3Zb2Oja4WhwDaHhSkDbyE99Fza6dhgapoalYWs4GlxDziA/gF3Y6FoBDaWCaRgapoYlJxgNpcLR4BpQgNlHsQW2VhRPVyosDVsDDg4X39ZFPD8NpgGHgBngPqTC0oBFxFV19DQePY1HT+PRGbjOwHUGuA+pMDXoheR6IbnOwFX6vlcRZ+F9r+ILU8PSgIPDpfy+cRGLiG8kegHfSFQB18FBGBqmBiwizs/7lsY3wNHgGnQGV2bwvte1gmkYGqaGpWFrECm2wI78sHthC2yHoSEPLj+RXtgC22FrOBryCsG9P7bAdrgScOtRIWeAe2VsdMUXoC5sdO1wNMCzEELDlYCGUsE0DA1TA2awEbaGo8E1hIYrAQ2lgmnA0I6AAbDwaA4v4AajgmkYGqaGPITAKUHbqHA0uIbQcCWgoVQwDTmDwGlEQ6mwNGwNR4NrCDnBaCgvoKFUMA0owItwZEXxXqZCaLgS8F4mcPGFLiLesVTYGnAImAHuQyqEBiwirqqrp/Hqabx6Gq/O4OoMrs4A9yEVXINeSFcuJOyH7TA0ZKfAG+n3fa4VXENowMHlpXze9zxjtPc9zy8sDbgODsLR4BqwiPDgWxnfAPhWxgqmQWcwdAZDZ4BvQqtwNLiG0KAzmCpFp4gXtoajIQ8uP5Fe2ALb4UpAp6iQV0h+urywBbbD1LA05AzySwgXNrqO/GB0YaNrBTSUCvAshKFhalgatoajwTVgBrhC0FBeQEOpYBqGhqlhadgaMDQuF9xgXCw8mkOFpWFrOBpcw3cIE0+/sNG1QraNDqZhaJgaloat4WTAacyG0iE0XAn3p8E0DDnBaCgVloatAQWYfRRbYN+KYgtsh6FhasDBDQRZRGx07XAlGA5hIpiGoQGLuBCWDrA1HA06A9MZmM4A9yEVTMPQMDXoDIZK0SnwKdz7ZtcKpmFowMFthOxI+Mz1fX9rhdCA6yC7JTa6djANWEScH3x/6xvg/XWJF7YGncHSGSydAZ6pvoBnqhVMw9CgM9gq3bjIsYj7Sjg/DXlw72eyU3SYGpaGLDN8uowtsB1cQ2jIGRguZYcHV6JPDUsDPLhG/WhwDaHhSkBDqWAaMANcIWgoFZaGreFocA2h4Uq4GBqXy8UAWPjrGkLDZcBG1w6mIQ8Bn/pio2uHpWFrOBpcQ2i4EtBQ8KEtNrp2GBqmhqVhazg8wWGuITRcCQMFeBEWVxRbYDscDa4BB5cXHza61iLij1dVmBpwCJjB+/tVLxwNWMSFEDqAnsalp3HpDJbOYOkM1tKwNRwNrkFnsFWKv5uLF5aQv3a18L2rHY4GHFxeyiF/7WqF/LWrFfLXrhY2uk58moSNrh22BiwiPPirlzVAaLgSXGfgOgPXGby/dvXC0rA1HA06A1cpOsV4YWpYGvLg8AEStsB2cA2hIa8QfICELbD/v7dv25UgN478Fz37oXgn/SsLwxjL44WAgSSMpQUWhv59qytPJeP0UUVnF7P3Re6Y8cRhkckgmZlMKggIIoKjBRJnkkTXJFEESXRV0BHI3zlsVAqzKggIIoKEICMoCKQFRUBD0BEMACIoJwgIIoKEQKgPc5FE1yR+f0l0VRARJAQZQUFwfIIEg8bXQ3hfoCMYAOQtvBMEBBFBQnC0QDxmkuiqoCJoCDqCAUAERQZYKrgqiAgSApmAQ0CHHs0DgMjGCQIC+bgoADuxVAQNgXyCtED2IV9A9iEnkE4Uq6o4jBWHseIwVmxBxRZUbIHsQ04wADQ0pIaG1LAFDf+obD0kZiQpsElCPpICewLZepwgIIgIEoKMQLRKRlvezTxBQ9ARDADybuYJAoKIQJK65HeF3w1+y2dKB4iaHKBIMqyCgCAiSAgygoKgImgIOgJsQcAWBGxBwBYEbEHAFgRsQcAWBGzBV4m1JGAA+Cqy9gUCAmnBEHAM6OG5KpsUVDtBQ3B86RFBK5IzewIRnRMcX3oEzcomZdW+CKSu2gkyAmxBwhYkbIE8zXuCAUCe5j1BQIAtyPhHZXtyBPSKpMkqGABEdIr8NyI6J4gIEoJjGI8IWpE0WQUVQUMgLagHENE5gj9lE9E5QUIgf0fsQETnBBVBQ9ARDAAiOieQFoiFiOicICHICAqCiqAh6ABEdKqYi+xVqnS87FVO0BB0BAOA7FVOcHxClSGRvcoJEoKMoCCoCBqCjkBacAyjFI9VEBBEBAlBRlDmAEs2rYKGoAMQqTmCjUXSZL96VNJkFRQEFYF83GF8khn71YlS+1VBRCB/R1ogu5gTFATyd7qAhgQdAQyj5MwqwBYkbIHsYk6QERQEFQG2IOEf/XrEWzrk6xHvL5ARFARCPQQcitSETR70PUFAcHzCEUErkgyrICM4PuHr78jh5yRoCDoCbEHFFlRsgRyLTpAQZAQFAbag4h8VpThBRJAQyMdlAQVBRdAQHBbSZGLILuYLyC7mBAGBtEBMWQSliSWKoJygIZC/IzYqgvIFRFBOEBBEBAlBRiAtEAsRQTlBQ9ARjAkk/1VBQBARHNRHbK1Iqdd0hLmKlHpVEBBEBAlBRnB8gqyaktiqoCHoCAYAEZQTBAQRgbSgCMgICoKKoCHoCMYcYElsVRAQRAQycklAgx6V884JBgA575xAPq4KwE6UI84JKgL5O9IC2YecYACQfcgRZCpSI/YkKDiMBYexYAsKtqBgC2QfcoKOAA2poiFVbEHFPypbjy5mKVuPI8xVJJdVwQAgW48TBAQRQUJwaJWsmlEcKCeoCBqCjmAAOJLSFAQEx9+R3W2Uw88JKoKGQL5UjEKOOOULRAQJwTFYQzpRZOMEFYH0qNjokVCiBGOCI+V1goAgIkgIMoKCoCJoCKAFR5brBDJYWUBGUBDIx1UBDUFHMACIoBy+wCK5rAoigoRAWtAFyN8ZAjqCAeCQjXyE7YoktiqICBKCjKAgqAjaAaSrDnVRMADkDUFAEBEkBBmBUB/mIhmreZOOLxFBQpARFAQVgXyCDEnpCAaAuiEICCKChCAjkBbIMNaKoCHoCAYAeUf8BAEG+EtdvkBCkBGIjRYBA3pUngo/QUAQEcjHifF17MTeEHQE8nekBWNDEBAcfyeIVQ0cxoHDOHAYB7ZgYAsGtmCMCSTlVUFAEBEkBAXBQX1E3Yrksp7g2KEoCAjk46KAhCAjKAgeWtXkJH7ksk7QEQwAh6dEQUAQESQEGcHRiUdYqEjKq4IBQATlBPKlQiCCcoKEICN4qHKRFfBIeZ2gIegIBoDDU6IgIIgIpEeLgIqgIegIBoCyIZDvqQKErQkQti6gIxgAREOOW6VFslwVHP0WpdWiISfICI7viWJVoiEnaAg6ggFANOQEAYG0QIyvJQQZQUFQETQEx8jJiVKqvp79JoJyAuzRLn9HrKoXBBVBQ9ARyJeKiYnUnCAgiAjkS6UFIjUnKAikBTKMIjUn6AikBcdnSwlYBQGBtKAIOFpwhKyKFIfNRyyqSHHYfMSiihSHVdAAiO4cMYgimbEKIoKEQP5OFtCmKUv+q4IBIG4IIoJjOosD4kh5naAhEKOQFhx5Jyc48k4UBAQRQUKQERQEFcHxCUn6WvYhJwgIIgLpqiogIygIKoLjS8XteGTGTjAAHA4VBQFBRJAQZAQFwfF3spjL4TY5gUhNkvERqTlBRJAQyJcKtUjNCSqChqAjGACOaHLJMvRHNFlBRJAQZAQFQUXQEHQEA4BITZI5J1JzgoygIDi+NMtsFKk5QUcwAByRoPJFcByTFEQECUFGUBBUBG0CSYbNMsBSHFZBRJAQZAQFwf53ZJk8MmbPn33+HPrzITHnzzB/7n9VDodH/uz5M8+fZf6s82fTnyIpMlxHBuwOkoCMoCCQ/ikCGoKOYAAQfTlBQBARJAQZQUGALUjYgoQtSNiCjC3I2IKMLcjYAtGXI2ZbpCKsgo5gAJANSxYCOSidICJICDKCgqAiaAikBVXAACDKc4KAQFrQBCQEGUFBUGHoRXlO0BEMALLJOUFAEBGgvTW0N9nKSGBS8mkVDAByapLwo+TTZnGcSD6tgoQgIzi+VBwNkk+roCHoCI4WSJBE8mmzhN4kn1ZBRJAQZAQFQUXQEHQEYwJJu1Wwt0C8hkfS7fkzzZ/73xZH4FFx9vxZ58/9r/Yvsj5/Dv35UKLzZ5g/4/yZ5s88f5b5s86f86+F+dei9KO0WHRIllspJJsl5CdZtAoagg5AjkcSoJJysVm2Q1IuVkFF0BB0BAOA7GYkfCdZtAoigoQgIygIKoKGQFqwCRgARG1OEBBIC6RHRW1OIC2Q8Ra1kXNCE7U5QUPQEQwAojYnCAgigoQgI8AWHOEh2fIfubb6u8Pvh6xHaf6xxzl/B/j90HTZ3x/5t/o7w+8Cvyv8bvC7w+8xfx9u3vN3gN/wdzv8XdEWCclJAm2WeJYUlM0SK5CCsgoigoRA2IRa1EACVZJNqyAgiAgSgozgGA0JOkk2rYKGoCMYAOQwdIKAICKQFmQBGUFBUBFIC4aAjuBogQQOpO6sgoAgIkgIMoKCoCI4WiAyJUm3CgYAcc+cICCICBKCjEB23vK7wu8Gvzv8HvO3bHS+fstfkKEVfRGdl6RaBbJrSgIGADktnSAgiAgSgoygIKgIpMfEHERFJNgjRWYVRAQJQUZQEFQEx5fKjlmKzCoYAGTPcoKjBbJHloqzChKCjKAgqAgaAmmB2JPsZiQI02U3c4KAICJICDKCAmPacbQ7jrbsZk4wAIgWnSAgiAgSAtAiSdFV0BGMCSRFN0vgZqAWDdSi8aVFX0B69IugIegIpEflvwmghiMEBBEBtiBgCwK24EuLvkBD0BGAHksmrwL8oyIyElSSFF0FDYF83BAwAIjInCAgePydIgEiSdFVkBEUBPUAQcA4wGGjkoirICCQv5MEJAQZQUFQETQEHYG0QCykbAgCgoggIcgICoIKoAq1DEkVAun4mhEUBBVBQ9ARyCfIkLQNQUAQESQEGUFBUBEcLZDAjeTrKhgADnVREBBEBAkGuGcEBUFFIDZ6KLnUoj17dEQECUFGcFBLrEZycc9OHENBlVxcBfIJUUBEkBAcf+eIlFTJxVWCiqAh6AiwBQFbEAKCiCAhyAiwBQH/qCjFcUypUotWQUSQEMjHZQHzzFIlyVbBAJDEDoqAgCAikE6sAjISFAQVAbYgYQsStuDr1PQFAoKIICHAFmT8o6IUQTpRlOIEAYF83BCQEGQEBcFhIUfkp0qSrYKOYAAQQYkyPiIoURoqgnKCgkD+jtioCMoJOoIBQATlBAFBRCAtEAsRQTlBQVARNAQdwQAggnICoRZz6UIgHd87ggFgbAgCgohAPkGGRGTjBAVBRdAQdARjAkmyVXC04AgDVUmyVZAQZAQFQUXQ5gBLkq2CAUAE5QRio11AmT0qSbYKGoKO4KA+gldVkmy/OlGSbBVkBPIJ0oJYETQEx985tu5VkmxPgrQhCAiwBQlbkLAFsg85QUXQEHQE2IKMf1S2HkdgrUotWvHmVkmyVdAQdAAiGycQNuleEYcTCJv8UZGAJCMnEz2JVclEP0FFcLQgi7nIRD/BACAT/evvyEQ//01EkBBkBMcJLHwRVAQNQQfQsQ9kf/D12bI/OAH2Thc2MT6Z9fkLyPeIIcmsP0FAEBEkBBlBQXD0aBazlFl/go5AWnAYhWTClsONXiUTthz+8SqZsOVwfNejEmz42kYclWAnKAge/Sb+gSoJs+XwTldJmC2Hd7pKwqyCiCAhyAgKgorg+NLDiV0lYVbBAHDsKcrht66SMFuKNFTE4XBiV0mYLUV650hHyf3r3xQEFcHDS5CbUB/RHQUBgfwd6V6RgBMcX1qkq0QCTlARyJfKZ4sEnGAAkEOKbIske1ZBRJAQZARHC6r0gSjFCRqCjmAAkK3HCQKCiED+jhjfET0WR2CVTNhSpXdqRJAQSKvFRkVdTiCtln4TdTlBRyCtln4TdTlBQBARJAQZQUFwtKCJ8ck24gQdwQAg24gTBAQRekdOH19WJaePEzQEHYH8HSEQ3TlBQBARPGZ9/urRI0asoCCoCBqCjmBMIKm0Co4ePfy5VWrEKigIKgL50iygIxgARHdOcMxGmXNHjdgJEoKMoCCoCBqCDkDU5fDvVMmeVZAQyJd+/TcFQUUgXypdJVuPE8iXHqYsebUKAgJpwRCQEGQEBUFF0BB0BEcLjlpmVfJqFQQEEUFCkBEcfS3L1JFkGyR9ox4FY4NEletRMHaCgCAiSAgygoLgGFNZt6WurIKOYAA4rgFJkkY90m8niAgSgoygIKgIGoIO4AjpSG5XlSTbctyQqJJkqyAjKAgqgoagI5AxPSRAcnEVBAQRwfGlcnhIR3K/goKgImgIOoIB4MhnURAQyJeKuchO6AQVgXypjLbshE4wJpBc3HLEHKrk4iqQL60CEoKMQFrQBFQEDUFHMACIVp0gIJAWdAEJQUZQEFQEDYFY1dE7kpj7ZVU5glXlmBBkBAVBRdAQdARgVZKyqyAgiAjAqo6U3QkKgoqgIegIwKokZVfBl1X94x//8off/vLHX/72p7/8+d//9vuvv/7hX/9H/8F//+Ff/9f//OGvv/z+65//9od//fPff/vtX/7wf3757e/H/9N///WXPx//92+//L7/213Ofv3zf+7/dyf8rz/99uvj1z/+Zf7X2/V/+nDKfv3X+3mpK0GI4RtFuKboj4DKwbD7uCfBSN8IImnD8aSTtGF3yFxSkM8YWb9idztefkW+ZsjKkKEJrX3778v1f3/cJD7++zTibECr5pHY8smwuybG5TfQwXx4z74Gs8Jghu+f0a8pJJhzUDzco9AKM8Xj+d+zK/aA/qRI360ykC85SrN89WaZDL2aGWo4Z8W+mCrDvjn5zsDM8kjnkN7cPUPXHIlZRdS+qC1dcrDuHGXTvuj5ujuJcUrRcxnVfUs2OUr+zlFXh4R+yDg/5PGC3fWHEI5HNuMXxyPhUDlq+U4x2LAOnST7kfyKIhLbau0c1I6K17KZoefzM/aI+zUDsc7d36FDuqumcuTvhhWJcfbHqVQaMdp1I4ho7mcXNe+9M6d593FvPNrleFCraNu5gDzy5S6HtDHde2zfvnQvh0uKvjymY3lM07Y6poks5+N4DEnW890jNce0FPuHhIfT9OtDSrj8EGKcR41psaztkoBLxahqFCFdjWgq6+rNOB4vvZyqt5/3LlUvNboSRZ0i0Bu7u+47B+uOfo7IHjUDhmI3jCPxVgyjwCx7NozM9mnHSf6LY1QQjO9fkkk74txf7C6wyVHfGBOdJRmXgOcxycQ+d6f92Ru7Lx4WxKcezUQ+9x33UJLaKrbk+3Yrl3XryHXVOvi3DN1x7b9ruv4Wtv0MbSpgH9CS/p1jrNoHtVKjBNL+aEdlH+mPth+pL/ujRLbANt38hQb98SSEhSnpURToa/PXYJEe3xeFwhb6nvR403O95mCb0DZOjt3z3K85iJ3u0THdLPQUrjmYmsZ50Io457rdQIxSWMa6FNZt1dT5wPao23o4OT93aGVGGucy+RCdS460PrA1Lw8s645cdBP3eIPiuhnVoTuaQ3f09e5g0pF12j8Sny6b0YiNPqr6q2cFJP3HlGXtOAKpX7vzQdpBrLRGbccj0HPJ8Y6o10tRb3l5m9/Ymt/q1rUhLffrhlTWJTFol3zbwzxxEEt9PLx8Dm+Ag9NbHWI7LrSxeFyg39F0UB7FoC+/ozNP6Kbeib7VuddPT+3okfoWzoFtPZRrDuZ1Um8Pmmgs392pnY7I0AkXYYH7wUFs9EjukvNX2u4xDN2VQk88M1ALn13xcNxfjyo9SOqIPC4q3uNo6vt63DS6x9GjcvR4zUFPLWM7OeLW2+WpZTDPU08qX71en3xGYrahTs1HbSzgqHaOXk/ledwJuOZwODuN5bMTVfN9OzwPk6iAz2M7lk/4fGSbOv9HyPesY8TJQawjbIGZaVL72H/DYbK+0RD10qYUOmkImy/TA/Q4oAPJk+N8yzQgkjQggl65d0hyi+qz6FsgJHXd3MPWPmvvZQ7vPouvV9uwMc9x6NqUEPD08vQ1YfkIxQwtpXk2Tj3cmjUp6e4j7cHia2MN6bOzJmXdaadKJCDQcNMR+pc+rd98nk/uWxZv6seDPl9Rll7ukYxaz8/Z5YCRdIdZw8IcxlnDdqhDw+SPavzXcyY6bFFDdNijhri8SQ3RYZd63ARf26ZyCtM+9cVCM3cAo2/X8s4iUPspX9fejlkIP0gG3YzoktcjunGfMkLSZ1V1Rnr32Mt2T1XrPBW2GK/FjAWibHFv2gxY/0espBlszTyeQJZhSQlXmfQGychtbv83QtKYppZzvRsVfWTPs5+Fo4buNAdsq1Lp77Sjz3YMImXMkxtGUw/XBtr+3BK6nRnHi2znuvvtWPUkzTmurhB07u5xC/2aiAlAz3OXR3KaBmH232Ncbasy3QKohzzWLZKWVOYoi9MvVMk6k5vDisfiUuYVjwWmjCte2RxWvBKWVzxKYfPMsFPEMRekFSFfRwv5xBtxrpqjkIlHA1NHof+vANnAqfeUxcIiU7YVj7cjawQ14iHgRzvo3rtqIuIj4Ha942WxKXl4/ksVwbXynJPDYlPzRJO360yUUFmkPwYVkdgwDvvUqyw6tZ/+lOXxO19G2ujSKe80fw1OIOsvjVBZTxK1LK8TVJ275h2k8O2U96TOLEbVsk6+ljOcR7byBklTUWwYFP5Jwpa9KUf7LgkCKs+SxuJUu66f0tpGaoSEWGwbOji7k6ZerxMsUlWKrr+lgEMh2U8Caa6ce6yLnARYWOaoqqHmOuBA8WStTKPTNvfg3+fNc0sqiyFuQ2OIA/atz/mrbMWxilrry6JGI1VWUeubi6gxHdjj0zo48VtY4kkHWMQqzim8xwPIeYCFrMy7NBa1Mu/SWNDJuEvr1WGX1tvyLo1S2PwSzcNfNDaHcRlheVxoSMA6Ljx0ZRoXSmEbl8T3in1mRJCTPI9czcjmKERWh4OsjnVZHQ6yGrf/D7J6vNl9RgSuXWhxY8aadM2LGFZ4njRxc5DVuDnIatyWZTVuDrIat2VZ5RS26Ut3rG1+Sod2PG82Iwtd7V4cjebv9hgHoXGQ+BgcQgIxLIcEYnAICcSwHBLgFEYbYY6rqtlZ/dum9+loFFnsKqUZVwTv9fOgsMBVU4fCo/Lr5KhPwsruO6VN/b27rNVLEt4hUT+mf0t5e+4QFrvaN24a3sCQ8T5dn0gSC8Wlf2IgPyny+pk1ssCT9cx6ZKSunlkjuz9lO7PSdph1iHnAzTrEoldGHWKXZcw6lOKyDlEKkw5xS7WuVTTyZF+rkoeNpOZhI33dRoaDjbAAltFGKIXRRtg+U9MbBxYReBZElppodSNEFrsy2wfbvpvtg8WujPbBIld2++jr9tHX7YOtuq1pptZAL+CzhbCgUwq6Idq3NYWQOHirYvE4VhWPY1VZP1YVj2NVWT9WFYdjFdshtqHXn3sL1ztEGriqSpJaJOsdC12F47XHr+UOE8+2JxdApSmsemMubWG2ZI/ZPJHQ639d/QgZyi6k56vtLHAVK2T04SWeZ+8KWyTm14SA2TjP05ddrjJ7RapDSkCsDikBsS6nBMTmkBIQ23JKAKewrRJU4POMWuVOVgl6mchqISxqZbYQFrUyWwiLWlktpHtYyFi3kLFsIVzMtODI4xWfazGjV6ysB14WsDIeeFk7zEbWPTarfX2z2j02q319s9rXN6v0PvOWZ1QUctd+LLvDw6s6PLyqY92rOjy8qmPdqzrKZwc3zmRcvHn2c3CZkW1ZHYBbQyfiG9vMVoZuM6Esw/M2M220jpR6RCH77VkNE7trVTQlqQwMm7UnCgczTduymabNwUzTtmymnMJopsw6elLrGNQ6+roGpc3Bo5rCskc1BQePagrLHlVOYTum0gvFRStT1XpZa4ww7FsfrVbZK0b/n4pK0YJ+oc8o9YYk8Q2SNAvUfLsf8YOEXrAyleRLgZvpaeqkJh+lsBVwS+x6lbWCG/OVGUu40btVxrp89lFpZFSM5pG3etfGtnksDNcpzSnyGmqmap6JplVaC8LRz2kzJtvZ59A6f1FTTPafMO+eUndekOidoh5JWmVKcX3ysjtWxsnLKIyTl+ZUGScvDVDZJi8LT5knr3lUyOSl5pG0Ys6+G+nX5sGCS8bCmolV/DOObV4vl5rycr3UxOJT1spynMRYfSyx+JS1/FiiESpbKUZuZJsKWUp3haxqAaHew3V941Ro9ew8SyphfeLnHmHinoNeBdyXKrKpKg6SWtYltaxLanGQ1LIuqcVDUouDpHLz0Jps+eHVvjSPuq2bB4tPGc2jrqsydecazYOFpozmwW5Umc3DPCq3zQPUA+OX7+wvc1Blz3hQ/mljzFdvK7SemoOdtnU7bet22hzstK3bafOw0+Zgp9w6Vj0YJcyS7aFcPwaQWECpVs0qqb2RZZ9dpRrz7v6GZ6BufrmjNXUJtR7nXCnhqRW0AJCWd9p3QfNTHhP4Owkz01jnHQh4KuLpFZNEK/9t6paOj0c/LjmInVY10wrVA8J4mi2diphWlcQLFD8oWCt0b9rQu/WDgp33u9aQTwNSQfb/6ImElqmCh13AWfc4Un0jYVeoIMHuW+3SZwqig7MYSoNLNj8ouIHNqg4RhvbZOAat9DtmAjbs1X/0KRegNgWo3xQx26sRid2ginmb8Wjw5fzgaOvL5OjLy+RYfr4is2iUcZnMLBxlWybzFh2WSfOokGWSWkfSTLKIcY+3OEqcpY/T5TMWmV2cKqMUjfHVcZNDS8swjhezxeQLytuyn59SGC2dB6NMFYtzoNU2DSWLeSuM8y0sb0szu+v0eHpcQ2J5u5xvb5CUmyRZIwWPpwYJSV8eF/otGlnbf979lqj7l8c7xndJ9N5VRQ//eyRJHWOPVz2vSVhIKmwzGP34HS7dlpTG/DQHJ9FM1LFHBG+SzGKbI9V6k8T6pg6LSpkf1Ynrr6bQdswC1aOXRNphJcHd8nskutDsP+s9kv2Eqqfc/XdjNGyIiwrbwI3Em8bWp7HhPH6PpI5Jcj0B31jDLx1Dmd2danpMbY04/ej+3/S4V2aRKaufjJNk/ZacRyAk9E6K1piMLZOvScuniJzz8t6KXsCy7a141T/broYW/bPtatitJ+spwj4qjYwKtQ7N0Iut51scadr6vuC1uxzbMkeamyvUsfc46nSV9WuOUtZPRJzDdCLi35KnkeXa1zlu2liKA25eXI8tDYDUWaG2RTbraK3cWX+81WsprHF9cDmHw+C2ML+FTFwWmgqb1qYMAfIN3+zUeY+sEytjd6ZsJXoyfZBqFP2W0cjprNL3huY73Yl0B1uziyZg7RP8ujx9ZlElo+cvt/U4f27LcX5KYVyz23qcP7flOH9uDnF++6gQPaXWYfP8cQ6j56+HdRnjlm7z2vV1K+3rVsoiQlavHa3tZ/IOdYe5wgJTxrlCw1J2hwyjsR4qOYn1jExJrK4hTmJ0DfE+MbqGKInVNTQcsvzyWM7y4+2wuobMJMw1xEmMriFG8oZriNuJ0atjl+fLzV2hFf4sDhm+p5rvUebW6k1nStHHGHIhzpTy4o0rU6J/2RwS/ennYI5LJI8PFV7kz/g5LFDk8zmxw+Up9jnpk5ZWqu7eSyuDNIO9AK9vS+WIr4w/UywX/OetUAY8y/xsBbsJNmvi5QhbmmqnCFuvWpxn6z3fIxkd8qjgJtg7JI+Sq3ra3SCU+E6n6r38PMjQ0vJ+6xR7R+pVw/13ufyUFyS2keEkxpGhJMaR4TN35snVmImAeDxPVdafp+LtmE6mMMb1EwovSDSMEbcYbpL0NN90/datzz2SHZYZdoHKuswUjzeMCrtDFWrTG/r773L1FOIrEtNDSIUW+TM+hFToJSrjQ0glO1SkKNnhqn/Jy1f9S3a46l/y8lV/TmG6Dc4txPgYS6EPVBkfY+EkxsdYCn2iyljYtrBKUNbCtqU41PkpZbnODx1g6ysbhd6kMtYtLMWhfGopDuVTS1kun1qKQ/nUUpfLp3IKmwQUh0pQpSaHcWG3qYzjUovHuNT1cakflWbrQw6F1vo3FqQr7NaO2UJeXKayWQgLjxgthF6nsloIu09ltBBKYZy59CRhK45d6MtU5uLYpXUPG3Eo91P6crmf0h3K/ZS+XO6HU9hsJNNgje0hh9L5mzKnEl0/5FBY5Mr6kENhZf6sDznwDjE+5FBo/Mr4kENh16psDzmUERz2u7TQn3W/y25Wmfe7rNSfcb87HKpjl+FQPLWM5eKpZTgUTy1juXgqp7DpELVU41pVt+ixVlWPh6mqx8NUdf1hqurxMFVdf5iqrj9MVYz3TMlDDjVs6yfV6vEoVfV4lKquP0pVPR6lquuPUtX1R6n4qmt8yKHSR6mMDznUMBzMLDocq2p0OFbVuHysqtHhWFXj8rGKUzhsmY0POVRW8s/6kEOlt4CMDzlUGtMwPuRQadDK+JBDpe9SGR9yoIuE8SGHmtK6V6Qmh+d+anKooF7TcgX1mhwqqNe0XEGdU5imLxd440MONQcHC8kOntWaHTyrNS97Vmt28KzWvOxZ5RQ2C+FiZnvIoeaxfuCtzINnO/DSdpiNrHhsVsv6ZrV4bFbL+ma1LG9W6bJrfcihlu4xuA5e1VqXvaq1OnhVa132qnIKh8E1PuRQWazK+JAD32YaH3Ko9Ekq00MOtdKy8paHHGr1MNO2bqbNw0zbupk2BzNl1mF8yKF6PEdVPZ6jquvPUVWP56jq+nNUdf05KpqrlpteFcvoUX0rfy+30CbJdcJb7fSiuS1/r7Lafy5p4t9q8KTr8vYvSDRrbl8St5skTTMJ94lRbpJUtbTa4/Vl0Uq9ZtbRGdunR2cuNLVX8jksWhX28M+8IjnyVWLkKxLVo/33iJckxGL3DjuHuOUwyOewjPGqB81cyTMIlV4JGtqxcQuXN+jrWL5jXWm4KoZZobHlS/9OHbRi5aYsR+b3pOlv0ZRpJqFAPOHHLSlmsq1q3YlW8RmCpzFu23qJlbatl1hp23KJFUphuwjbtvUSK21bLrHSNocSK/ZRaWRU1kustG29xMorjm2Zw1ZBowXqwYdr4+VenxpLvbzgMJV6OTZQ199iqgbygsN0jZ5/S9ZVJmFtwmeOuH26HaaSM3aOm3POWHKmsUiTteTMC2M3Gkj+8MDYysU0XrPOVi7mRUNM5WIa8+/atjKNhaqs5WJoO2zlYl5tVNvcvY/eLzaqjd6vMu52KYntsiffpjZ1ie4/rw01rResbmm5YDWlMO6D8nrB6paXC1a37FCw2j4q15r84hCja3YY43rvkNfLovFTjDFKzUmaGsj+M9wjCdtWZpwq32xJSbNEQ71/KOt1HspgxXz3UKZf9DigVULDPimN2S8YenurX7ImE8UMk+cnSVtXeH4c2qYM9FtTJ4agJhvI6l2Wz/+tONRYo+2wdikd2vkUSUZn1XsmH+LMNAnpth8i5umHiPX2zIm6QXtQkpnDMug12twgzfv5TtKLW8magrc7uK/u8zd2N8p6tZmSGGtP0AtW1hvjL1bxOX3DzdvR1lyC1uhb6urwKhVrtj+1g4Xf52XRGHO8jktQkhZmfQMSH2nt0yShTs/3HhW6SdL0IdLdyRIJCZt36p9tud6jGPnURUyOfosibFHn3Vavw06NXa/KfQp0BzML440+HeqOCCMyO+ssmjAfOhjh5q3z0Gqap/iaruul8cvrdV5exweOntvS+MtVGuyBfVpMb7VDrWRvRyftYGbSkpbCehzZ0mWfNFYm0PrW0ou7+OpQbL1eR7BfXKPXsi37kbFeKSOlqFriYP+Z71GY9JnebrbqMyWxSuv4NIlZnymJVZ9HX9ZnRmHUZ37es+lzZ29YWfWZ9qlVn1mqhXVT01m8yThp6GVe66ShJEZ771v7MIl10nAS46Tp7K6VbdJQCtukoRTmScPuWRknDe9T66Thd3GN6x2/Rmta7yiFbb0b61OXJxQYpy53xRlnXQwfJjFPXUpinbosdmWcuozCOHVpBM06dVmOo3Xq0j41Tl16q9i83qVtddLwC8HGScNJrPZOr1l5kJgnDSWxThp2zco4aRiFcdKk6jBpmOvLOmlon5rXu8105sUSR09XtToLYOV5mycn8Gv+qAoyaKVjKCzQAmkJc1pp4CiF2R/taVxo/CrMPPoA3/J8r+BFMzS3AbLn2vMVOgd/ZM99WcqCgz+Sk1hVqIQPk5ilrHis/2V9/S/r63/xWP+Lw/pfwoelLGwJvqZeSwit5xfmhcC4hUsxozeTzdOX3pKyTV96qdg6fZPHodnD50VJzNO3Orirel12V1EK4/StHu6qtu6u4n1q3b7Ta+ObluVOW7+uC9JZYCNv6vPOIcfr6csrlBRI5h2kJWyzannrgJYnMatIW98E0MoiVhWJHkcRFydg99gEdI9NQF/fBPT1TUD32AR0h01AD59WkXlHMeWNnCNoYcCuxVbySOlaRbJDAeo+1jcB2SFmxUmsM298msQ8fT1iVn09ZtXXY1bdI2Y1HGJW3SNmxQsuJU0JCqlhtdTw9DVsE6BZzhnG9pGXZ6YounpjNu17FJqoVeClsbcoqj4hVaFu1G2KcpNC+6Le7YuqfVHv9kXTD2l3+wIpbvYF7upu9sVM4Gt3+6Lrh/S7fYEUN/uiV6Vod1uh9YR7v9mKoX7DcbcvkOJuK/opwoNIDi/OZs1YpyTGG8CDX6wac3UsjITeq27/RIR/FCRJ/B1dW5o5vUhkzeGnLbHm8PNaU5aoMKcwRYVfUJh2lMXDK1wcvMIjfZrEuqPkJMYd5UjLWaqUwrajpBTmHWVez1LlfWrdURaHLKiRl1MHefEt66SpDg6QkeuHScyThpJYJw2tA2ibNHksT5o8HCYNqwJonTS0T83HMFpercCjVeUyDDpYDb8UNoiDokP3iYNaSJ0W0vFa1BNHY+eXqueXcovhKEHx8+zxFoMaabxsw4tidVEvqm94cHjqTSYfuejd7lyzB8e44jBX70vbdUXkUemjlWpeIWPlrOePYRn/m95E3uPx7ZqDmehu23CncuseLN+Kq7/jPhmzT1i9alpKcDouRrjcuY+2LW/+m8d62TzWy5Y+TGJeL5tDFtVoy1lUlMK4XjaHLKrR1rOoeJ+a10ta51FdCKmTV1FGp3VVdNLgU7HPnk9WCDBpRZQc0RnyPGWKw36Z3aQy7pdb95j/DqnHo3+axDz/KYl1/rOHgIzzn1EY5/8IDvOfZbhb5z/tU2vqkfkV33T9iu9gtQz2aaq3/jo8jPbOG6/m2Utfm7JdHChjffZyEuPE21188dMs1vn7gsU4gcVpuTaDOYdtCnMO6xzeWfryJH7RseYLcw4JN/uSvF4GoDlk3BSPbeujxOenWeyzJ2SP2RPa+uwJbX32hOYxe+LmMHtC/vAamBKU9MPUu+dy2PReRJhVRUK5fnN575T8aZba9TpBHdtVpZUXHLNWch013ORosx3jmoMarPpKRrxt9Ho1AkvZ3544hIPrWlJvXEzgJ3mPJM7ntNLGpCQlh8lHr/EELe+/O4H6zaaEeXElhF7usoD/KI3bbSlxlkzM7TZLnSXt+rj9RVPaUmRflJdvWnMO65qRHe5ahy1/3GxT1tNKKu1upxh1iXIYdck4OJSDbqmN30I5jN9i3NozjaUnL6vG8jOgVWOLh7EWF40tLhpbXDS2uGhscdHY4qKx1UFjq4PGVheNrR83W7PGVgeNrQ4aW5c1ljseTZ/CKUxfYnV/EgrumDYK7AsXuVVgm4elNheBbS4C21wEtrkIbHMR2OYisN1BYLuDwHYXge0fN1uzwHYHge0OAtvXBZZGdm0CSylsAmuML1OBDR4CGzwEdnhY6nAR2OEisMNFYIeLwA4XgR0eAhu2dYGlHEaBpRxmgQ3bx83WKrC8U2wCyzlsAmsdHCZtNNXUJrCUwiawxoRXJrDVQ2Crh8AGh+KBnMQssC9YjALLWawCy1msAvuCxSiwL77IKrDRQWCjg8BGF4GNHzdbs8BGB4GNDgIb1wU2LUe6OIVNYNNynItfkLIKLL+qZRVYjzhXcIlzBZc4V3CJcwWXOFdwiXMFlzhXcIhzBYc4V3CJc4X8cbM1C6xDnCs4xLnCepzrxQVSLfdYKjz88hbFfHQRn1p4oqA3cq1PDHES2xNUvIaHaWg5hWlkrZVE2MDSGi/WBYdXm7EuOA41BTmJfcHhLNYFh7KYFxzKYl5wOIt1weFfZF1wal5fcGpeX3CqQxGsneXjZmtecGinGBccymFccIyDw6StL38Kp7AJbF/+EF4Dzyqw0SNzLTQPS20uAttcBLa5CGxzEdjmIrDNRWC7g8B2B4HtLgLbP262ZoHtDgLbHQR2XZd4KVqbwNb1HWxd38HSUsVWgeVFk60COzwsdbgI7HAR2OEisMNFYIeLwA4PgY3busBSDqPAUg6zwMbt42ZrFVjeKTaB5Rw2gbUODpO2sr6DLes72LK+gw0ePung4ZOOwcFSKYlZYF+wGAWWs1gFlrNYBfYFi1FgX3yRVWCjg8BGB4GNLgIbP262ZoGNDgIbHQQ2rgtsWk5b4xQ2gU3raWv02S+rwPIHyKwCmzwsNbkIbHIR2OQisMlFYJOLwCYXgc0OApsdBDa7CGz+uNmaBTY7CGx2ENi8LrDra0VfXyr6+krBHyO13mwbHhcvokeQK7oEuaJLkCu6BLmiS5ArugS5okuQKzoEuaJDkCu6BLli/bjZmgXWIcgVHYJcsTroUl7NqnhBYcmqKMy/nsLQ13PSt0qWT8UmIi0hp+Y+BzY/yXxYTpbhFLbFJiynyvBH662LTffIkY49OMxa+kKTebHhLNbFhrKYFxvKYl5sOIt1seFfZF1sel9fbHpfX2y6w7tEIY6Pm615sel9fbHpfX2x6ctxsraestbWU9baespaqQ4pa5zEKrDJ4QktTmIW2BcsRoHlLFaB5SxWgX3BYhTYF19kFNi0rQss5TAKLOUwC2wKHzdbq8DyTrEJLOewCax1cGj9nLS8m+cUlt18a8tXYTiFTebbesm37BB25CRmmfe4tEVJ7DIfPa7CcBazzEePqzAvWKwyHz2uwqS0fhWGclhlPnlchUnp42Zrlvm0fhWGcxhlPq2f7/kM3KJOnrClabH1LZKcJkndLkj23t8oS8iTJd9jyXEWTo3lqtRoYQ8wm/vkBYm1T7JLn+TVPsmDPnYBn7Nt8HJo6u/RpAo06ZKm0FrZWyiTJsDr9G/R2MrjcgpTddwXFJbiuJk+mmMfnRc0xtHJ9NE78+hQGtvocArT6LygMI1OYE80JX1aZf8JT5H18QZJ1PcZdpJ6SULFMWZ9vzPmMHfk+6L8XU1YxYuQx9ziwEL8k4Q9La+vVnV8bKLlNzi6vjbbYWz/CQfbUm8aLogBuvW5Xn5i7pcjKVwaMhprSGVxCz1vpb1bL8f3jbFpl2PDjSSNPo2k3uMoUcv/l5SubYQ9ZlDGPD+OOu6S6JMkjCTlsGqsfCHfpXWb0prwVbJipxlJjxe7tN0lKfo2w0AjeY8k6iN6Y4+53f2cou9W77ODkLCcta4Ht9HL9ZplJ4HN2pskPSlJr4SE9kmffTI20idU6Pt87RmO5z+mDqtPiC/FXyojPaD0HPSB9W8PHJZnaWRPce0T7WTZfxId6NVh1WLBZeuqxTisq1YfDqvW2NZXLRbcsq9a5rFpbGyYlYyuVjIGWXJoAoJttXjVEnW8xA2e5PzZErYf0BHOGx0d+j6L7eF43pI8/S41MYMt1GC3abD9Xr/GEHRjEvr17jUzR7+xXzN/qql0NbUWrq2etsTWr1xfq/ZIrzFf6itdteyHx1c0xsPjCxrr4XHv3f55HuMTOpzD9oTOCw7TEzrsUdzaZkSnX6osu/phPT9m+lSTcSWmx2HjSkw5jCtxZvdYrCtxZiNjXIlzGA4rsX1s2j0bsR0fKYXx9JiZU9p6enxBYtoPMKea8fAYXM6OweHAFtbPa7R+l/G4ZuYgpzXOYTus8SJv1kWG9qrxPM5bYrUR2idG9wLlcPgaq63yb7HZKnv/x2qrZg5iq5zDZquM4w2v/LbuneC7CJtzIrMqbTbnRGHbb50w+y5hUuz/+LkZLN08pZlujt/yDkfW3JCU4/X2kJXDtoX4aH9sah77jieQ/ijUAT2fSd3jo9M+0vOGqLB35GvUzUzFk8QTS1ru1cS23FEjLhEyOVKxM+gOs2IGxjMDvQSkXxEKvmuaqp0jx7mpi+mSYx8T+sr4FNT9NxxZn9RjPRBNn+EtUQPitaBPMbWnr2GBEuu8pRzGeUsf2bL1CPOKdPWx7j/jFUNdtXPKYLJz9hVWO6ccZjuvw8HO6e3KTc9A+29oSbdzFO3UWArhoM9Nb+o12DV9G2S2sEeGrLOFchhnC7uW5aAf33sEvLPPPULXp5DHPGzPU1182n/YOfo6B1jqDw7mcGtdBbUNcBKPbOfoRTP8Ojof3uLoyjHAxn5wcC3UBNke812OPDnKOgc8Of/M0SJz16mTeffcjUsOdtHVOraUwzi2nMM2tjRBIpbzW/afY50D5st7HHpGTrGVexxJ3Ur7r+0eR1Yh2xesm/1xpKR8tQPP6rc56k0OuLQ7btpH1qTNlNPNsc0awth/tpscqkEpl7tjW4Ny1HZzzum4hM7GlnKMuRXawt25P4NlW1znCLfb0SZHvccx5h2Bkdt6O5gWJgddTw66nhx0PTroenTQ9eig69FB1+O6rrOkt10zksaWe761/8ijnf2RRyf7ILo/bZvuT/v1/lTu3qzG2I6o0fXQbCqpCW9t/GRhaaulnSytwMQL/ZmEnoTCVHfwbof2TEIOMmmbx6kNQ/8/SNiJOWx5XsDCuzk/P4j2bYEtQGN9S1nGHKFxbSyNpoqlouraMPz4fLzjLGWbLCWn62NzofdzdAbtDncY5z2y8q0prFTN3JFk3JH8+BzCsXvJNIiZxnWXsCv7pW3K0SAN4i2OobuaMiAd6b2haSoG+yq4bTdZep5egF6u+2Qs+4fHsn84bMxdtVvTvCG0+66uHCuFB9yChnXitXPmBYea6oj1yhFJh6W3+S299Zuztw/Nitp/MxcxvW1rdHpxDpvTqzDnqs3p9UaP5H67X9tkKfkuSxmTpRGXZGEPcFlHh3IYR4dtcVxGB3ukj9ujM897Y9wUxrHNNWuEWIjDOK4qI6cwSSP/ltJUTUbNG7O0sRpg4Rz7srXNHPaGqXNvsUz/5v47lrss8xJ0w6vUb9jsaDPdZDClDoXSDLWU/Xdp92hi1J1jTJDVG9O4SRLiTZKiV7JjgaTCt0j2T1Bp2/DU9ETCHo6MQRf0GBNO46c5WNg50hzNP45Fq9F8+j3zHnTcMv2e1Rst7DF466cwjjJl6WkrXe0cTeWxtBIuOfbuWE9e4RzGNbQtJ6/w/tCEsdLTIP3BqqzVrCGXmntiLCxwo76XGrbrAzVtSNH9Wi1pu/s5Rb1ieyyp3GfR76nbuM8SleVb1PVpkIkulq7TtwzGsZzrMJZzHYZDrsPwyHUoI67nOgT2ukzO6l7IeaCB5OemOJy2hsNpayyftniHFLXTXFpnHdIdOqQvd0jdts92yKwllitetXjukLrF5Q7hHNYOWU5iY9MuDV2t8hby5WaGc2jqx85RrzdEdWsOG7zK7iZZd0X0lfIaZpGMQhoSPParNQSPz6GudR3j8PBgz/FJz01h+02904oe8f5OO+oo6hao23U7aAapdZ1gJGPK4n7Sg8DWj1vLtJrfpnWzcB/xLoleUah4VeIHCb1gCLcmK96VeNrp0Xv6m+5H9mNNuiahn9PSuVscDTMO3uqTPju2Y3j8mYQ+7evD8u2ib6rXvfLimWG9iBIjdstPFpaWFmbqwR7+v8syY1u7PeS7LFkvCu7yVhgLO20ZC+m9eAi6NvWWdNa567cNQy3LrkZKYYvC0C8xbulfdIdxT1/ZE15mraaVA4wlNypVSONF35qItRov+lIO40XfymoAWZMQKnNqGy/6VuYJM1/0tY8NmXrUSIwVNyqLblkrbgzmoa+q0ftPvC5Y3yCZLrX9Z7hHYq64QVtS0rwfV69J4sarafY6Uzs6bJX6WzRFaxfsvyFP/V0a7ZgHJanGQHsmjdm9uL14q3tz06UrwzT8SULmj7EoyuClA0w1USiHsSRKZQEhY0mUWjcabLOVRKEtsfYqHV09ZewDne5OnjBvmYUAC8+bVh/znDyx3p6DUSOQD0oyeeg2B/y46e5OSeuYgC79pOBbYW1H+JZz/uZWWG9YBXTkLGzLGQs/frVZhhkTJX9sDZqDd6s5eLda/iyH0WXIO1Vzxfb+zaxT23JDKMce15gXTjdmr5SlzuyMmsZdll7UXvHo9ibLaDOWuoWbLGbXBW/LDMk+MhoIS88eh3TKYj6kUxbzIb07PFH4onPHTPsK4Xa3WAWbd4tVsM1DxFiCg6eZBZztnmYasLJ6mgNZxNpQP1cbaCrvkPSmmtDHt4SCN0hG0OsgI+AB92enrAe+eEPKfKGhjJtfE1X4RxyEpG3hs1+T5gYjfUvs+9GQ9NmG5D5fA9loQ8pyQziHbZfStvXNQaBvNcEuBW9P/LCzsezBpBQ2DyZ9r8LqwaQkVg9mY/ps9mDyLEebB7OFsu7BbFSfbR5MymH0YDY2OFYPZmOWZvRgNnafy+zBtI8N8WBSIzF6MJtDjcDASsmYPZiUxOrBrMHBg0lbYvRgBnYR0u7BfEFj9WC+orF6MGnPWD2YlMTqwWQeO6OvrYx1DyblMHowW1ovlt14joPRg0lbYuxVPro2D+YLc7V6MF/QWD2Yr2isHky6zbF5MPlOyeTBZDt64/Gx5epwfGy0cKD1+LjRM6heAU7YrT+S82hOXNBU45xCuUmS9R5U/l7Z7ZmETcAWuzpONpJryI4Gxi05pTBe7awOW3JKYt6SF4+kAvq8WO3zsk/frocm0i2blnXet2yYOxneIRlax3yL4SZJ1ytQT1dSnkha9SiY2apDwczAayu2mdJWW7keZBbCa7otz/3b1YXwDoneNN1JOutaF5GtHiLLTD/Og0baQiSmz0i6dm3aIpk/zeVOV/O40xUazZqaDyM8MvuvHtoM3SVDgVa/Lfoeay4NV8HtuVfY9b+WyjyBkfNkc3ipiD5ZbXU6tPWXilpzeKmo9fWXilr3eKnIPjaNjQ21ErW12NiRh5Gk0Gbpx9Fuk2zrJE2DkqlVYvQs3vXNiVJudmyCdHl0lL9JotaWMLP1B8lweLrwBYnNscQ/J2/jn3rKf7QkfbwlcwbuMVIHkrsTMMUxSwV2YvY0+7FW3Yi2SGWpORiKefLcHp42q1IxVeob9R7O6roBz4E/Fw3aFL07s6/hnTQlLfuEOjuRmn1CtCVGn9CLnVKbu7bR+/VOiaayDMhNGCPeYjHGzZpDennnl71s+6Qelp925RzGfVIPaX2f1NnrTcZ9Ug/FYZ9kHxsq0+vBmU4fPbNKo0d6efNIL28e6eXNIb38xanLHJzpPnnhzSMvvHnkhbf1vPDmkBfeHPLCOytfaF1B6dtl5hU0rceqmkNe+AtzNUdVukte+Csaa1TlhdtPDX//PS6rSnV6oWhnicAybrEY9xbsFRC7K7Qa52AgOd0sPNOGVnruG7sM29l9r1LVvVUq5vw+xVjZLWO8CQt30feV4A2SphnMu5truybptGNdWOQuymlr/S5LazP3eETGwi4oavisYaDnLY6RZ15dv8kRtqjzDyv5/mSh5QyNece8Y8c2iwhG0rHM775vurR60cDquVuxkzzSy+cpvabrZwApTatavWj3rbfrtvTSlmPPvCFqKXtDOmsIzY1LszLivhlN173S6aWvrmG0MJClP2Vjs3hEm3caWge7zc/GQh9LKfow8X4UrFciyd9b0aBvwbe036IwSTUr62KWakpiFllmaz4sdqnm89gq1dTUjFLNOKxSTUNwZqlmxQzNUs1ftLBJdaROFPNGh8VWbLMnMgeIdfZwErPd8/O+B4t99rThMXtYXUPr7GEc1tnDOOyzpxeH2UM71jp72CMM1gUwsjd1bQsgpzAtgC8oTFOYOQzMU5iSmCcfi3r5sNinMGUxT2FW3NA6hUddn8KMwz6Fh0MhI96x1imcqsMCOLa4PnuGx+zxWLrGVj7NYp49nMU6ewYrc2icPZTDOHsoh3n2DLZps84e3rHmBTCZzsVYdLk+N4Rt2nKaJUbxCaLdfuwNCXlTY8v4BPrPpjAXl0aLsIx8+zE2bB0NmiFUAnxNCuGthmiWAxQZfWpIZK5hu66x+15GXWOuVLOuZY8D7Yjp0yx2XYseu4IR13cFlMOqa9FjVzA8yhvyjvXQtbAl+J5K5CSxXUHQuEqJeKHhWdmqRyjiCJcvTuTmEIrgJOYpmNqnWewTOXn4t0Ze929RDutEzh7+rZEd/Fu8Y60TubDc4W0+C7zhQwo/JjJ9x2tTb3kOWBH6eSLTpoQCab+DNYXtZC3voMSSPASlrO8M2M0ks6AUj6jkKOnTLHZBKS47g+KwMygOO4PisjMoHjuDkj4tKEnjiSlv7KBRaay2zxd6U7oWFJZra5/I1WFn0D12Bt1jCrpEvoZL5Gu4RL6GQ+RrOES+hkvka3hEvoZL5Ive3kyabBRSgyt52/NBnUW+smZDZxjhR96enWM+roD5tm9yaB5YwRf93uKYTyt8f/3qLke5y6H9UW/3R9X+qLf7Y7772G73B3Lc7Q/c8t3tj5kn2G73R9dv6bf7Aznu9kfXyl293W6H1mXr/W47hrocx+3+QI7b7Zil+4gGxUoD57YUd04Sg+bpRl5BnSYIjrlqFsrCbrroGxf5W1HR9sbnGDPTKYk17Z+3xFpVvqflMDOlsIWZ+3JKbOweDuXusE+M21Y/zWLdbb5gMe42d5bllFjOYdttcg7rbnN3q66nxL7oWOtuczjkWe3fU5Znz/DIsxrZw+5D/zSLffZQFvPsiWF99jAO6+yJwWP2xOwwe2jHms9qrEZOnHUKItxyeQ6q7t/DysEcVZ/OqCr6gp9JqKFg1XO8W/VMwkqZ1aonnHKPommBqW+Hk/co1FrjdStYveeyRb0Cv+G54rlH2euRucwnNbHg1gLJuCThVqbbrJSgRvJPK0v8eQu9kpWxANKPz2H3DTa93FwDvpf8g4SZ6m7kcENz6y40IVx3LnW3jNktWG/5yd2SWI0C8HKMcL2r39hDXraTQdoc1lBOYl79cvk0i30NzcVjDc19fQ3NfX0Nzd1jDS3rqVovOta8hrIrwV1dDalDacT883voGzM6e+BBledJvHPQa57aJVgKrT9Pnu6xnS7LOc8pOOQ8cxLzJK7bp1nsUkBZzFJQ07oUMA6rFNTkIQWspqFZCvhjbcb7mXTR6OpiS3gT/rlG494UXkRTbyJ2eAzix82h5DGPWUVD4+W97pCLwEnMM7DlT7PY5zFlMc9jWtHQOI8Zh3Ue07I05nnMajeY5zHtWOuSvrnMHgeX7OaRyePjTO0fZ7HPnu7iku0OLtnu4JLtLi7Z4eGS7fXDq2BKUEoQk/qeKxUzkhxm1ZNQEllKR/00S+16faGO7aoWzAuOWda3jhpucrTZjnHNQQ12m6+A3TZ6vYkxWlmfOJSDKVJSV11M4D15jyRqwtjOx65Hb+s3ZzlJCFo8fXcN9ZtNCfOeTAi93GUBr1Iat9tS4qzQmNttljoL50GtuXe/aEpbiuyLwvKFb85hXDMoh3nNCOHjZpuyHlce3r6bnWLTJc5h0yXr4FBdoltqo8ZSDqPGGrf2rdw8eRk19sUZ0Kqx0cNYo4vGRheNjS4aG100NrpobHTR2OSgsclBY5OLxqaPm61ZY5ODxiYHjU0OGkvdj0aNpRxGjTW6QQkH91IbNfaFv9yqsdnDWLOLxmYXjc0uGptdNDa7aGx20djioLHFQWOLi8aWj5utWWOLg8YWB40tDhpLo71GjaUcRo01Rp2ZxtKkAKvG8vQEq8ZWD2OtLhpbXTS2umhsddHY6qKx1UVjm4PGNgeNbS4a2z5utmaNbQ4a2xw0tjloLM1KNWos5TBqrDE7lnEMB419kUZt1djuYazdRWO7i8Z2F43tLhrbXTS2u2jscNDY4aCxw0Vjx8fN1qyxw0Fjh4PGDgeN3RxiXptDzGtbj3nR61VWjeUXvYwaGz1iXtEl5hVdYl7RJeYVXWJe0SXmFV1iXtEh5hUdYl7RJeYVw8fN1qqx0SHmFR1iXtEh5sVznbTWZKnwSM1bFPPZR3wM4omC3uc1Pmj0gsT45hWvDGIa2xccprE1VyhhY0sLyFjXHF7KxrrmOBQy5CT2NYezWNccymJecyiLec3hLNY1h3+Rdc1JdX3NSXV9zUkOVbYirR7tY7bmNYd2inHNoRzGNcc4OFTbSl3X2FLXNbYsfwuvtmfV2OKRZxGzh7FmF43NLhqbXTQ2u2hsdtHY7KKxxUFji4PGFheNLR83W7PGFgeNLQ4aWxw0NjvsY7PDPjY77GM3j33s5qGx1cNYq4vGVheNrS4aW100trpobHXR2Oagsc1BY5uLxraPm61ZY5uDxjYHjW0OGhsd9rHRYR8b1/ex2cM/nV38093DWLuLxnYXje0uGttdNLa7aGx30djhoLHDQWOHi8aOj5utWWOHg8YOB40dDhq79XWN3fq6xm7LuWz8LTKrxvJX0YwamzYHY6UkZo19wWLUWM5i1VjOYtXYFyxGjX3xRUaNTWFdYymHUWMph1ljU/i42Vo1lneKTWM5h01jrYND74qtrxcvOGwa29fXC/5aqlljPe5kJI+YV3KJeSWXmFdyiXkll5hXcol5JZeYV3KIeSWHmFdyiXml9HGzNWusQ8wrOcS80nrM68Vr0qY8C05hyrNgr1emI2XvoEjpW/nLpzyLxI75+oYfvOaZn3W+x/X1psf19cb4gjvNc/TInQ4eudOpJIeJS5+EMq83nMW63lAW83pDWczrDWexrjf8i6zrTd3W15u6ra831eEBpJ3l42ZrXm/qtr7e1G19vanLMbPQHfLYukMeW1/PY6Op5OZaFpTErLHNw1ibi8Y2F41tLhrbXDS2uWhsc9HY7qCx3UFju4vG9o+brVlju4PGdgeN7eu6xK4R2vb0Lygse/rQ81hX+jzWlT4v35IJxSHTg5OYld7jShclsSv98Lglw1nMSj88bsm8YLEq/fC4JZO39VsylMOo9JTDrPR5+7jZWpWed4pN6TmHTemtg8N0aWOvjxR9gLPO2yn7keQNiqxlREHnnyloFVFTIyiDqQ20YkssWlI1fpu5abxBUodWR64j3SSZL0ZHLO76Fkk63kcSh9gW2eewzKi0qUts96qlmyy2arUvOEzVal9xWKrV8rFpWgn/8ZDmzQH+RpLvksRJkq6HJmZWxi2lNP2msI7Xdziy7m1SjuGao32WI8dZWjmWm8OrTwbFhsXA3xuZriLQxl0lwZbcJum6Cd9/3ibRfQQnYU8xGdcZSmHUeJqzHZVkX7qvTYRz6KM2I8KVzu8c7C0143rXV/uis/fcWjq1sDToiZCanaNn5ehlu8cxwrntLt/eRX6rHW22Y9SbHDqqO93NdgzV9TLy7f7ok+N6XFiV3bwPzCmEBd+Jvs3R7nHUeLoRcm3pHsd8Vj03ZmP8RdazT/u2kcczMqtfl6s+vp0rvkzZ6zstsT3jkdnLXLZnPLrDs3bd4/GaXNqnWcyPeHAW6yMe2SGIlR2CWNkliJU9gli8Y62PeESXWUyf5jLO4ldNMU7j2lencYgO85iTmKdgC59msU9kymKeyOzhJutEZhzWiUwfkDJPZLqQWicy7VjjRGYNKcejy2L2W77eacXMohwldt03Rtzz9WcS8jm1ac/WBqffJxL+NV33jWGL7GuSx9fkz35NaNqOPbxza8dWkr6tXFKu9zjibMd+El7n6NvNb9l0dFMYN9uh71WXtN3u0zH7tNzkyJOjJmKpVNCMvm/KYfR9G4WV+b6jQ4bbixXYGJPL7DxvFufRHWJyL1iMMTnOYo3JcRZrTO4FizEm9+KLjDG5wqJYxj0F5TDuKSiHeU9Rto+brTUmxzvFpkucw6ZL1sGh2uaQrZcdsvXyerZed5DY7qGwJTiYKiUxK+wLFqPCcharwnIWq8K+YDEq7IsvsipsdFDY6KCw0UVh48fN1qyw0UFho4PCxmWFrZEFPWvVoCecctLINznqTQ64tAJT+C2OPOP8GcLA73GkOjnaTY4wlAP89O9x1KAclbSD5XJ2HZfQ2dhSjqGiOLZwk0O9lTtHXOcIt9vRJke9xzHmIjFyW29HvrZ1WpbNOLacwza2nMM2tmaOcLsdprGlHMaxNbeDjG2m1Xiz7hQfWj5j2k8usFLW01k4hy0VpZT2WQ5bOgvt06RLZUxtI33KTgFFfek1bFdORdqMPPNhMu5UfzYjrrtIC1Mho4uUfk2Jaqj7PuXyazhH0R4p9bpHQmYp9vFIU/liKdtNFmNyHuewJee94LAk5+XlNNK8nEaallN70nJqD6s7GrZNtXT/jQvlU5DzBYvuCh8s6TpUmjNb+LdQJk/ArfJbPFY7pRxGO+UcFjtlRThGUiXb2wNb5VLe4NAT984RLjny5mEnL1jMdpKc7CQ52ElysJN0z07+bQe//PFPv//7b3/54y9/+9Nf/vzf+3/3jwfV73/65T9++/UL/tff//xH+Ld/+79/Pf/Nf/z+p99++9P//ve//v6XP/76n3///dcH0+Pf/WH7+p//Feoj92D/397+7V/+kOSf9OOfjL7/k/D1/7R7Bh7/Ox7/KBz/6OHefPxv+7d/PJr6/wA=",
      "is_unconstrained": true,
      "name": "get_current_value"
    },
    {
      "abi": {
        "error_types": {
          "10522114655416116165": {
            "error_kind": "string",
            "string": "Can't read a transient note with a zero contract address"
          },
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13060541637244024094": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8556029555939094797": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_utility"
      ],
      "debug_symbols": "TL1LkjRLj1y5lzvmIGAvwGorPaA0u0lKiZSwRPgY1eaZDjVAdVLf0fpv2jE3dyA8PCwj/+Of//+//pf/89//87/+j//27//rn3/5f/7jn//yP//13/7tX//7f/63f////t///a///j/+/r//8c/v+z/z/vMv8z/9s/7C+fvH/vkX//tn4J+Jfxb+2fjn4B/HP4F/bv6zf/jnb5T798/APxP/LPyz8c/BP45/Av/c/Of88A9GORjlYJSDUQ5GORjlYJSDUQ5GcYziGMUximMUxyiOURyjOEZxjOIYJTBKYJTAKIFRAqMERgmMEhglMEpglItRLka5GOVilItRLka5GOVilItRLkax3+/9a+/f8f6d79/1/t3v3/P+9fdvvH/fePbGszeevfHsjWdvPHvj2RvP3nj2xrM33njjjTfeeOONN95444033njjjTfe+BvP7IP7YP4KrOBvTFsfzIJV8Des+Qd/4478j70gCu6D74IHWMHfyGN/MAtWwS74Rj4feEEUfHP+juIrAoAV/I08xwezYBXsglPgBVFwH3yFAbCCGvnUyKdG/kpkfsvyFQnAC6LgPviKBWAFo2AWrIIa2Wtkr5G9RvYaOWrkqJGjRo4aOWrkqJGjRo4aOWrkqJFvjfyV1fxOwVdYgFmwCnbBKfCCKLiA8dUZwApGwSxYBbvgFHhBFNTIViNbjWw1stXIViNbjWw1stXIViNbjTxq5FEjjxp51MijRh418qiRR408auRRI88aedbIs0aeNfKskWeNPGvkWSPPGnnWyKtGXjXyqpFXjbxq5FUjrxp51cirRl418q6Rd428a+RdI+8aedfIu0bOGrwfRMF9kDWYYAWjYBasgl1wCmrkUyOfGvmrwTU+sIJR8Dfy8g9WwS44BV4QBffBV4MAKxgFNXLUyFEjx+tII7wgCl5HGvdXYAWjYBasgl1QI98a+dbIXw3u33/6Z341CLCCUTALVsEuOAVeEAU1stXIViNbjfzV4LYPVsEuOAVeEAX3wVeDACsYBTXyqJFHjfzV4I4PvCAK7oOvBgFWMApmwSrYBTXyrJFnjTxr5FUjrxp51cirRl418qqRV428auRVI68aedfIu0beNfKukXeNvGvkXSPvGnnXyLtGPjXyqZFPjXxq5FMjnxr51MinRj418qmRvUb2GtlrZK+RvUb2GtlrZK+RvUb2Gjlq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6zq3rnPrOreuc+s6t65z6zq3rnPrOreuc+s6t65z6zq3rnPrOreuc+s6t65z6zq3rnPrOreuc+s6t65z6zq3rnPrOreuc+s6t65z6zq3rnPrOreuc+s6t65z6zq3rnPrOreuc+s6t65z6zq3rnPrOreuc+s6t65z6zq3rnPrOreuc+s6t65z6zq3rnPrOreuc+s6t65z6zq3rnPrOreuc+s6t65z6zq3rnPrOreuc+s6t65z6zq3rnPrOreuc+s6t67z0XU+us5H1/noOh9d56PrfHSdj67z0XU+us5H1/noOh9d56PrfHSdj67z0XU+us5H1/noOh9d56PrfHSdj67z0XU+us5H1/noOh9d56PrfHSdj67z0XU+us5H1/noOh9d56PrfHSdj67z0XU+us5H1/noOh9d56PrfHSdj67z0XU+us5H1/noOh9d56PrfHSdj67z0XU+us5H1/noOh9d56PrfHSdj67z0XU+us5H1/noOh9d56PrfHSdj67z0XU+us5H1/noOh9d56PrfHSdj67z0XU+us5H1/noOh9d56PrfHSdj67z0XU+us5H1/noOh9d56PrfHSdj67z0XU+us5H1/noOp9d57PrfHadz67z2XU+u85n1/nsOp9d57PrfHadz67z2XU+u85n1/nsOp9d57PrfHadz67z2XU+u85n1/nsOp9d57PrfHadz67z2XU+u85n1/nsOp9d57PrfHadz67z2XU+u85n1/nsOp9d57PrfHadz67z2XU+u85n1/nsOp9d57PrfHadz67z2XU+u85n1/nsOp9d57kb6dykaLpFX517bi/+6vzRaJpNq2k3nSZviqZb5O3wdng7vB3eDm+Ht8Pb4e3wdkQ7oh3RjmhHtCPaEe2IdkQ7oh23Hbcdtx23Hbcdtx23Hbcdtx23HLlx6ZE1jabZtJp202nypmhqh7XD2mHtsHZYO6wd1g5rh7XD2jHaMdox2jHaMdox2jHaMdox2jHaMdsx2zHbMdsx2zHbMdsx2zHbMdux2rHasdqx2rHasdqx2rHasdqx2rHbsdux27Hbsdux27Hbsdux27Hb0XW+us5X1/nqOl9d57nzyWfSafKmaLpFWecgaxpNs2k1tcPb4e3wdng7oh3RjmhHtCPaEe2IdkQ7oh3RjtuO247bjtuO247bjtuO247bjluO3Bz1yJpG02xaTbvpNHlTNLXD2mHtsHZYO6wd1g5rh7XD2mHtGO0Y7RjtGO0Y7RjtGO0Y7RjtGO2Y7ZjtmO2Y7ZjtmO2Y7ZjtmO2Y7VjtWO1Y7VjtWO1Y7VjtWO1Y7Vjt2O3Y7djt2O3Y7djt2O3Y7djt2O047TjtOO047Tjt6DrfXee763x3ne+u8911vrvOd9f57jrfXee763x3ne+u8911vrvOd9f57jrfXee763x3ne+u8911vrvOd9f57jrfXee763x3nefOK4+k1bSbTpM3RdN9lBuwHlnTaJpNq2k3nSZviqZ2WDusHdYOa4e1w9ph7bB2fHUev6Rb9NX5I2saTbNpNe2m0+RN7RjtmO346jxO0miaTatpN50mb4qmW/TV+aN2fHUenjSbVtNuOk3eFE236KvzR9bUjt2O3Y7djq/O4yZ5UzTdoq/OH1nTaJpNq2k3teO047TjtMPb4e3wdng7vB3eDm+Ht8Pb4e2IdkQ7oh3RjmhHtCPaEe2IdkQ7bjvy11jzCsvfZAXNpj/HtaTddJr+HBe/ehhN91Fu8npkTaNpNq2m3XSavCma2mHtsHZYO6wd1g5rh7XD2mHtsHaMdox2jHaMdox2jHaMdox2jHaMdsx2zHbMdsx2zHbMdsx2zHbMdsx2rHasdqx2rHasdqx2rHasdqx2rHbsdux27Hbsdux27Hbsdux27Hbsdpx2nHacdpx2nHacdpx2nHacdpx2eDu8Hd4Ob4e3w9vh7fB2eDu8HdGOaEe0I9oR7Yh2RDuiHdGOaMdtx23Hbcdtx23HbcdtR9e5d51713l0nUfXeXSdR9d5dJ1H13l0nUfXeXSdR9d5dJ1H13l0nUfXeXSdR9d5dJ1H13l0nUfXeXSdR9d5dJ1H13l0nUfXeXSdR9d5dJ1H13l0nUfXeXSdR9d5dJ1H13l0nUfXeXSdR9d5dJ1H13l0nUfXeXSdR9d5dJ1H13l0nUfXeXSdR9d5dJ1H13l0nUfXeXSdR9d5dJ1H13l0nUfXeXSdR9d5dJ1H13l0nedetOtJ0XSLss5B1jSaZtNq2k2nqR3eDm9H1vlIsqbRNJtW0246Td4UTbfotuO247bjtuO247bjtuO247bjliM3qz2yptE0m1bTbjpN3hRN7bB2WDusHdYOa4e1w9ph7bB2WDtGO0Y7RjtGO0Y7RjtGO0Y7RjtGO2Y7ZjtmO2Y7ZjtmO2Y7ZjtmO2Y7VjtWO1Y7VjtWO1Y7VjtWO1Y7Vjt2O3Y7djt2O3Y7djt2O3Y7djt2O047TjtOO047TjtOO047TjtOO047vB3eDm9H1vlNWk276c9hv1+iE4N4G79aLzTiIE7iIm4ibUFb0Ba0XdoubZe2S9ul7dJ2abu0Xdpu2Ubukys04iBO4iJu4iE6MYi0GW1Gm9FmtBltRpvRZrQZbUbboG3QNmgbtA3aBm2DtkHboG3QNmmbtE3aJm2TtknbTNtIdGIQ07Y/XD+iEQdxEhdxEw/RiUGkbdO2adu0bdo2bZu2TdumbdO2aTu0HdoObYe2Q9uh7dB2aDu0HdqcNqfNaXPanDanzWlz2pw2py1oC9qCtqAtaAvagragLWgL2i5tl7ZL26Xt0nZpu7Rd2i5tt232+xGNOIiTuIibeIhODCJtRpvRZrQZbUab0Wa0GW1Gm9E2aBu0DdoGbYO2QdugbdA2aBu0TdombZO2SdukbdI2aZu0TdrYS4y9xNhLjL3E2EuMvcTYS4y9xNhLjL3E2EuMvcTYS4y9xNhLjL3E2EuMvcTYS4y9xNhLjL3E2EuMvcTYS4y9xNhLjL3E2EuMvcTYS4y9xNhLjL3E2EuMvcTYS4y9xNhLjL3E2EuMvcTYS4y9xNhLjL3E2EuMvcTYS4y9xNhLjL3E2EuMvcTYS4y9xNhLjL3E2EuMvcTYSwZ7yWAvGewlg71ksJcM9pLBXjLYSwZ7yWAvGewlg71ksJcM9pLBXjLYSwZ7yWAvGewlg71ksJcM9pLBXjLYSwZ7yWAvGewlg71ksJcM9pLBXjLYSwZ7yWAvGewlg71ksJcM9pLBXjLYSwZ7yWAvGewlg71ksJcM9pLBXjLYSwZ7yWAvGewlg71ksJcM9pLBXjLYSwZ7yWAvGewlg71ksJcM9pLBXjLYSwZ7yWAvGewlg71ksJcM9pLBXjLYSwZ7yWAvGewlg71ksJcM9pLBXjLYSwZ7yWAvGewlg71ksJcM9pLBXjLYSwZ7yWAvGewlg71ksJcM9pLBXjLYSwZ7yWAvGewlg71kspdM9pLJXjLZSyZ6SSRu4iE6MYi3Eb0EaMRBnETajDajzWgz2oy2QdugbdA2aBu0DdoGbYO2QRu+6tM+xJd9Ao342WwkTuIibuIhOjGItzF7yUMj0rZoW7Qt2hZti7ZF26Jt07Zp27Rt2jZtm7ZN26Zt07ZpO7Qd2g5th7ZD26Ht0HZoO7Qd2pw2p81pc9qcNqfNaXPanDanLWgL2oK2oC1oC9qCtqAtaAvaLm2Xtkvbpe3Sdmm7tF3aLm23bblvsdCIgziJi7iJh5i2lRjE25i95PvC3JFbGAsHcRIXcRMP0YlBvI2DtkHboG3QNmgbtA3aBm2DtkHbpG3SNmmbtE3aJm2TtknbpG3StmhbtC3aFm2LtkXbom3RtmhbtG3aNm2btk3bpm3TtmnbtG3aNm2HtkPboe3Qdmg7tB3aDm2HtkOb0+a0OW1Om9PmtDltTpvT5rQFbUFb0Ba0BW1BW9AWtAVtQdul7dJ2abu0XdoubZe2S9ul7bZt/35EIw7iJC7iJh6iE4NIG3vJZi/Z7CWbvWSzl2z2ks1estlLNnvJZi/Z7CWbvWSzl2z2ks1estlLNnvJZi/Z7CWbvWSzl2z2ks1estlLNnvJZi/Z7CWbvWSzl2z2ks1estlLNnvJZi/Z7CWbvWSzl2z2ks1estlLNnvJZi/Z7CWbvWSzl2z2ks1estlLNnvJZi/Z7CWbvWSzl2z2ks1estlLNnvJZi/Z7CWbvWSzl2z2ks1estlLNnvJZi/Z7CWbvWSzl2z2ks1estlLNnvJZi/Z7CWbvWSzl2z2ks1estlLNnvJZi/Z7CWbvWSzl2z2ks1estlLNnvJZi857CWHveSwlxz2ksNecthLDnvJYS857CWHveSwlxz2ksNecthLDnvJYS857CWHveSwlxz2ksNecthLDnvJYS857CWHveSwlxz2ksNecthLDnvJYS857CWHveSwlxz2ksNecthLDnvJYS857CWHveSwlxz2ksNecthLDnvJYS857CWHveSwlxz2ksNecthLDnvJYS857CWHveSwlxz2ksNecthLDnvJYS857CWHveSwlxz2ksNecthLDnvJYS857CWHveSwlxz2ksNecthLDnvJYS857CWHveSwlxz2ksNecthLDnvJYS857CWHveSwlxz2ksNecthLDnvJYS857CWHveSwlxz2EmcvcfYSZy/JbZ5/n4gkLuImHqITg3gbs5c8NOIg0ma0GW1Gm9FmtBltg7ZB26Bt0DZoG7RlL/n+nsjI7Z+FQUxbLlT2kodG/GzTEidxETfxEJ0YxNuYveShEWlbtC3aFm2LtkXbom3RtmnLXjJzdbKXPJzERdzEQ3RiEG9j9pKHtB3aDm2HtkPboe3Qdmg7tDltTpvT5rQ5bU6b0+a0OW1OW9AWtAVtQVvQFrQFbUFb0Ba0XdoubZe2S9ul7dJ2abu0Xdpu23IfaaERB3ESF3ETD9GJQaTNaDPajDajzWgz2ow2o81oM9oGbYO2QdugbdA2aBu0DdoGbYO2SdukbdI2aZu0TdombZO2SdukbdG2aFu0LdoWbYu2RduibdG2aNu0sZcEe0mwlwR7SbCXBHtJsJcEe0mwlwR7SbCXBHtJsJcEe0mwlwR7SbCXBHtJsJcEe0mwlwR7SbCXBHtJsJcEe0mwlwR7SbCXBHtJsJcEe0mwlwR7SbCXBHtJsJcEe0mwlwR7SbCXBHtJsJcEe0mwlwR7SbCXBHtJsJdc9pLLXnLZSy57yWUvuewll73kspdc9pLLXnLZSy57yWUvuewll73kspdc9pLLXnLZSy57yWUvuewll73kspdc9pLLXnLZSy57yWUvuewlF71kJBpxECdxETfxEJ0YxNu4aFu0LdoWbYu2RduibdG2aFu0bdo2bZu2TdumbdO2adu0bdo2bYe2Q9uh7dB2aDu0HdoObYe2Q5vT5rQ5bU6b0+a0OW1Om9PmtAVtQVvQFrQFbUFb0Ba0BW1B26UNvWQlDuIkpu0kbuIhOjGI9+HEvteHRhzESVzETTxEJwaRNqPNaDPajDajzWgz2ow2o81oG7QN2gZtg7ZB26Bt0DZoG7QN2iZtk7ZJ26Rt0jZpm7RN2iZtk7ZF26Jt0bZoW7Qt2hZti7ZF26Jt07Zp27Rt2jZtm7ZN26Zt07ZpO7Qd2g5th7ZD26Ht0HZoO7Qd2pw2p81pc9qcNqfNaXPanDanLWgL2oK2oC1oC9qCtqAtaAvaLm2Xtkvbpe3Sdmm7tF3aLm3sJcZeYuwlxl5i7CXGXmLsJcZeYuwlxl5i7CXGXmLsJcZeYuwlxl5i7CXGXmLsJcZeYuwlxl5i7CXGXmLsJcZeYuwlxl5i7CXGXmLsJcZeYuwlxl5i7CXGXmLsJcZeYuwlxl5i7CXGXmLsJcZeYuwlxl5i7CXGXmLsJcZeYuwlxl5i7CXGXmLsJcZeYuwlxl5i7CXGXmLsJcZeYuwlxl5i7CXGXmLsJcZeYuwlxl5i7CXGXmLsJcZeYuwlxl5i7CXGXmLsJcZeYuwlxl5i7CXGXmLsJcZeYuwlxl5i7CXGXmLsJcZeYuwlxl5i7CXGXmLsJcZeYuwlxl5i7CWDvWSwlwz2ksFeMthLBnvJYC8Z7CWDvWSwlwz2ksFeMthLBnvJYC8Z7CWDvWSwlwz2ksFeMthLBnvJYC8Z7CWDvWSwlwz2ksFeMthLBnvJYC8Z7CWDvWSwlwz2ksFeMthLBnvJYC8Z7CWDvWSwlwz2ksFeMthLBnvJYC8Z7CWDvWSwlwz2ksFeMthLBnvJYC8Z7CWDvWSwlwz2ksFeMthLBnvJYC/BvtfvL+RO7Ht9uImfbVmiE4N4G7OXPDTiIE7iIm4ibU4beslOvI3oJUAjDuIkLuImHqITaQvaLm2Xtkvbpe3Sdmm7tF3aLm23bdj3+tCIgziJi7iJh+jEINJmtBltRpvRZrQZbUab0Wa0GW2DtkHboG3QNmgbtA3aBm2DtkHbpC17yZqJgziJi7iJh+jEIN7G7CUPaVu0Ldqyl+yRuImH+Nk2/tsg3sbsJWslGnEQJ3ERN/EQnRjE23hoO7Qd2g5th7ZD26Ht0HZoO7Q5bU6b0+a0OW1Om9PmtDltTlvQFrQFbUFb0Ba0BW1BW9AWtF3aLm2Xtkvbpe3Sdmm7tF3abtuw7/WhEQdxEhdxEw/RiUGkzWgz2ow2o81oM9qMNqPNaDPaBm2DtkHboG3QNmgbtA3aBm2DtknbpG3SNmmbtE3aJm2TtknbpG3Rlr1k3MRBnMRF3MRDdGIQb2P2koe0bdo2bZu2TdumbdO2adu0HdoObYe2Q9uh7dB2aDu0HdoObU6b0+a0OW1Om9PmtDltTpvTFrQFbUFb0Ba0BW1BW9AWtAVtl7ZL26Xt0nZpu7Rd2i5tl7bbNux7fWjEQZzERdzEQ3RiEGkz2ow2o81oM9qMNqPNaDPajLZB26Bt0DZoG7QN2gZtg7ZB26Bt0jZpy16yV+IkLmLeKXjiITox7xQi8TZmL3loxEGcxEXcxEN0Im2Ltk3bpm3TtmnbtG3aNm2btk3bpu3Qdmg7tB3aDm2HtkPboe3Qdmhz2pw2p81pc9qcNqfNaXPanLagLWgL2oK2oC1oC9qCtqAtaLu0XdoubZe2S9ul7dJ2abu03bZh3+tDIw7iJC7iJh6iE4NIm9FmtBltRpvRZrQZbUab0Wa0DdoGbYO2QdugbdA2aBu0DdoGbdlLzkw04iB+tnMSF3ETD9GJQbyN2UseGnEQaVu0Ldqyl5ycevaSh0G8jdlLHhpxECdxETeRtk3bpm3Tdmg7tB3aDm2HtkPboe3Qdmg7tDltTpvT5rQ5bU6b0+a0OW1OW9AWtAVtQVvQFrQFbUFb0Ba0XdoubZe2S9ul7dJ2abu0Xdpu27Dv9aERB3ESF3ETD9GJQaTNaDPajDajzWgz2ow2o81oM9oGbYO2QdugbdA2aBu0DdoGbYO2SdukbdI2aZu0TdombZO2SdukbdG2aFu0LdoWbYs29hJnL3H2EmcvcfYSZy9x9hJnL3H2EmcvcfYSZy9x9hJnL3H2EmcvcfYSZy9x9hJnL3H2EmcvcfYSZy9x9hJnL3H2EmcvcfYSZy9x9hJnL3H2EmcvcfYSZy9x9hJnL3H2EmcvcfYSZy9x9hJnL3H2EmcvcfYSZy9x9hJnL3H2EmcvcfYSZy8J9pJgLwn2kmAvCfaSYC8J9pJgLwn2kmAvCfaSYC8J9pJgLwn2kmAvCfaSYC8J9pJgLwn2kmAvCfaSYC8J9pJgLwn2kmAvCfaSYC8J9pJgLwn2kmAvCfaSYC8J9pJgLwn2kmAvCfaSYC8J9pJgLwn2kmAvCfaSYC/BvtfvC/cn9r0Cs5c8NOIgTuIibuIhOpG2Tduh7dCWvSQscRIXcRMP0YlBvI3ZSx4akTanzWlDL/HEQ3RiEG8jegnQiIM4iYtIW9AWtAVtQdul7dJ2abu0XdoubZe2S9ul7bYN+14fGnEQJ3ERN/EQnRhE2ow2o81oM9qMNqPNaDPajDajbdA2aBu0DdoGbYO2QdugbdA2aJu0TdombZO2SdukbdI2aZu0TdoWbYu2RduibdG2aFu0LdoWbYu2TdumbdO2adu0bdo2bZu2Tdum7dB2aDu0HdoObYe2Q9uh7dB2aHPanDanzWlz2thLLnvJZS+57CWXveSyl1z2kstectlLLnvJZS+57CWXveSyl1z2kstectlLLnvJZS+57CWXvQT7XiMSnRjE7Mp/zwYX9r0+NOJn+75ae2Hf68NF/Gx3Jx6iE4N4G7OXPDTiIE7iItJmtBltRtvXS8bPPvx6SaERx4eROImLuD/Mdfh6SaET/2zDTuJt/HpJ4Wf7fjVy5b7Xwkn8bCOn8/WSwkN0YhBv49dLCo04iJNI26Jt0bZoW7Qt2jZtm7ZN26Zt07Zp27Rt2jZtm7ZD26Ht0HZoO7Qd2g5th7ZD26HNaXPanDanzWlz2pw2p81pc9qCtqAtaAvagragLWgL2oK2oO3Sdmm7tF3aLm2Xtkvbpe3SdtuW+14LjTiIk7iIm3iITgwibUab0Wa0GW1Gm9FmtBltRpvRNmgbtA3aBm2DtkHboG3QNmgbtE3aJm2Ttkkbe4mxlxh7ibGXGHuJsZcYe4mxlxh7ibGXGHuJsZcYe4mxlxh7ibGXGHuJsZcYe4mxlxh7ibGXGHuJsZcYe4mxlxh7ibGXGHuJsZcYe4mxlxh7ibGXGHuJsZcYe4mxlxh7ibGXGHuJsZcYe4mxlxh7ibGXGHuJsZcYe4mxlxh7ibGXGHuJsZcYe4mxlxh7iaGXROIgTuJnmzNxEw/xs32/u7Ny32vhLcx9r+PbqLdy32vhIH62NRIXcRM/27qJTgziZ9u/D7OXPDTiZ/s+DFm577VwET/bzsGylzx04mf7/hzxyn2vD7OXPPxsnvPNXvJwEj/b98Z85b7XwkP8bJHzzV7y8DZmL4lcs+wlDwfxs0WuevaSh5t4iE4M4m3MXvLQiINI26Jt0bZoW7Qt2hZtm7ZN26Zt07Zp27Rt2jZtm7ZN26Ht0HZoO7Qd2rKX5H117nstdOJnu3myspcAs5c8NOIgTuIibuIhOpE2py1oC9qyl9yTOImLmDZPPEQnpi0PM3sJMHvJQyMO4iQu4iYeohNpu23Lfa/zdxKNOIjzQ09cxE38s02biU4M4v3wO92577XQGvNtdc5m51g7MX8qDedHNOIgTuIibuIhOjGItDltTpvT5rQ5bU6b0+a0OW1OW9AWtAVtQVvQFrQFbUFb0Ba0XdoubZe2S9ul7dJ2abu0Xdpu23IfZKERB3ESF3ETD9GJQaTNaDPavtep+X0Zzcp9kIWLuImH6MTPNlbibfxepwqNmLadOIlpO4mbeIhODOJtnD9i2m7iIE7iZ/u+a2blPsjCQ/xseSeR+yALb+P3OlVoxEH8bDMSF3ETDzFtObMVxNv4vU7NlQv1vU4VDuJnWznY9zpVuIk57kj8xs1bmNzbOHcecfaHnVPP/vBwEw/RiUH8xs0bm9zbWGjEQUxbziH7w8PPdnKS2R8eOjGItzH7w8PPdvIiyP7wcBIXMW1ZAdkfHqYtJ5n94eFtzP7w8LPlfVbubSycxEXcxEP8bJ7Tyf7w8Bbm3sbCtHniIE5i2n6Jm3gas+Yf5giR+P23eSuXOxPx//OCKPjmFOnJun5oxEGcxEX8PN/f0lq5J7HwO+w7E29jFvNDIw7ip8hbhNyIWLiJh+jEIP7ZVj7Sy42IhUYcxPlhzvcr5sJNPB/mzL5iLgxi2r5azY2IK28cciPiyqeGuRGxcBIXcRMP8RvXcpLfLUChEQdxElejJ67ETfwUeZeRO/9WvlLkzr9CIw7iJK7Gm//fnO9dxE08RCcG8RbmDr1CIw7iJC7iJh6iE9uWe/FW3m3lrruVL3K56+7v1SvxEJ34jTBm4m38qqXQiIM4iTnuSswRvhOQO+lWvjHOnXSFg5gjeOIibuIhOjGIacsjzmJ4+NlmHnwWw8NJ/MbNV8zcHbfyBSZ3xxXmfE9ijpCHmRf4w0XcxBw31+F7V1UYxLTl6uRl/9CItB3aDm2HtnOI3ufi8Gwenk3n2XSeTefZzBrCKfToU5g1hJMVPJvBs5k1hHMRPJvBsxk8m8GzGTybEX3egmfz/vpkXZ7Ny7OZVYhTmPWG83b7bOYuNpzC3MWGhcpdbIWTuIi7TlbuYit0YtTJyl1sD+1HpM1oM9qMNuuzmVvB/u7fEhdxE3M6N9GJQbyNWQwPjTiIk7iIn23ldLJEHjoxiLcxC+fhZ1s53yych5O4iGmLxEN0YtpyZlk4wCych58tH1rlVrDCSVzEz5b3jLnpa+28SrJEgFkiD42Y4+aZ9xw3z3G++Oy8uLJwHh6iE9OWR5zlBMxyemjEtOWxZQ2dnG/WUN4o5k6vv6aV+CkOfiyItzFr6KERB3ES05arnpX18LPlHV/u9CoM4i3MnV6FRvxseR+YO70KF3ET0+aJTgxi2r6Z5U6vQiN+tnz8lzu9/u6lExdxEw/RidGYr3qxEwdxNmaZRoqzTB/muDfRiUG8jVmmD404iJO4iJv42fKhVe6y+ru1TwzibcwyfWjEQfzGzdvb3Dm18pY1d06tfOyVO6cKjZgj5JJk6T1cxE08RCemLc9xFiQwC/LmomZBPhzEHDfX4Suy/ct1+IrsYRZZfnKfu6HeQmWRPZzERdzfCLkkX70VOpFnM3g2L8/mpe3Sdmm7tGW9Jeb+pJ033rk/qTCIWd2fIvcnFRpxECdxEfPYVuIhOjGIt/G7Gyw04vpwJ27iIToxiLdx/ohGHMRJpG3SNmmbtE3aJm2LtkXbom3RtmhbtC3aFm2LtkXbpm3TtmnbtG3aNm2btk3bpm3Tdmg7tB3aDm2HtkPboe3Qdmg7tDltTpvT5rQ5bU6b0+a0OW1OW9AWtAVtQVvQFrQFbUFb0Ba0XdoubZe2S9ul7dJ2abu0Xdpu2XbuRCo04iBO4iJu4iE6MYi0GW1Gm9FmtBltRpvRZrQZbUbboG3QNmgbtA3aBm2DtkHboG3QNmmbtE3aJm2TtknbpG3Shl7iibcRvQQ4XkfcPzQQ4CJu4iE6MYi3cf+IRqRt07Zp27Rt2jZtm7ZN26Ht0HZoO7Qd2g5th7ZD26Ht0Oa0OW1Om9PmtDltTpvT5rQ5bUFb0Ba0BW1BW9AWtAVtQVvQdmm7tF3aLm2Xtkvbpe3Sdmm7bbPfj2jEQZzERdzEQ3RiEGkz2ow2o81oM9qMNqPNaDPajLZB26Bt0DZoG7QN2gZtg7ZB26Bt0jZpm7RN2iZtk7ZJ26Rt0jZpW7Qt2thLjL3E2EuMvcTYS4y9JLcf/Z2yxNuYveThZ/v+8t7O7UeFk/jZvqesO7cfFR6iE4N4G7OXfI9hd24/KhzESVzETTxEJwbxNjptTpvT5rQ5bU6b0+a0OW1OW9AWtAVtQVvQlr3E8gxlL3noxCDexuwlD9PmiYM4iWmLxE08RC/MjUb7e1a8c0vR/p4V79xSVLiJ3wjfs+KdW4oKg/jN93uOuHNLUaERBzFtK3ERN/EQc9xv+XKb0P4e5+3cJlS4iHnEqciaf+jEIN7GrPmHRkxbrk7W/MNFzPnmSmbNP3RiEG9j1vxDIw7iJC4ibYu2rPmZZyhr/nsaunOb0MOs+YdGHMRJXMRNPEQn0pY1P/NkZc0/NGLa8irJmn+4iGnLU5g1/9CJn21hsNuYNf/ws628SrLmH07iZ/ueOe7cJlR4iJ9t53Sy5h/exqz5ldPJmn84iJ9t56WRNf9wEz/byZOVNf8wiJ/t5Hyz5h8a8bOdtGXNP1zEz+Z5/WbNP3TiZ/Ncs7x/SMxtQoWf7ftIdec2ocJJ/Gzf47Gd24QKD/GzxUkM4m3M/vA9WNq5TahwED/b93xn59fjFW7iZ/ue+uz8erzCIP7Zzi9t3/1DoRHHh544iYv4ZzvZdPPr8QqdGB/uxNv49ZLCz5YNL78er3ASP1t2ufx6vMJD/GxZ3fn1eIW38eslZ+Z8v15SOIifbeaafb2kcBM/W5ZIfj1eYRA/W17g+fV4hUb8bCtX/eslhYv42XYe0NdLCp342Xbavl7y8OslhZ/t5NX39ZLCSfxsJ6++r5cUHuJnO2n7eknhbfx6yd/HYolGHMTP5jnY10sKN/GzeS7q10sKg/jZPJckfkQjrmp4udVrzzz47A8Pb2P2h4dGHMRJXMRvvpHXztcfCp0YxFuYW70KjTiI3+rETFzETUybJToxiPkK+V20C/cPQCOmbSXmuDvxEJ0YxNuYneChEQdxEheRtkHboG3QNmibtE3aJm2TtknbpG3SNmmbtE3aFm2LtkXbom3RtmhbtC3aFm2Ltk3bpm3TtmnbtG3aNm2btk3bpu3Qdmg7tB3aDm2HtkPboe3Qdmhz2pw2p81pc9qcNqfNaXPanLagLWgL2oK2oC1oC9qCtqAtaLu0XdoubZe2S9ul7dJ2abu03bbt349oxEGcxEXcxEN0YhBpM9qMNqPNaDPa2Es2e8lmL9nsJZu9ZLOXbPaSzV6y0UtO4iJu4iE6MYi3Eb0EaMS03cRJXMS0eeIhOjGItxG9BGjEQZzERaRt0bZoy17yfcy4c0/Zw+wlDz9b3uHlnrLCSfxseYeXX2P3fiz7w/fp2c7dY4V/I/j3kdnO3WOFi7iJh+jE+DCn/vWHh19/KDRi2nKSPomLmLacuh+iEz9bPp3JbWsPv/5QaMTPlo9Zctua5zvW/Go6z5vT/Gq6wiDexpvj5mV0c9w8ipvj5nS+TuD53j83vhVu4iF+tpHT+TpB4S3MjW+Fny3vf3O3m+edbu5283yXn7vdPF/yc7eb551u7nYrDOJt/Mq/0IiD+NnyHWvujCs8dRnldrjCIPaVmtvhCo04iJO4iJtI26Bt0DZom7TNPKBcszmIk5gHlCv51XzhIToxiLdx/YhGHMRJpG3RttKW5205MYi3cf+IRvxsK4/4q/nCRdzEz/b9ttvObXaFQfxs+XAgt9l5vpvJbXaFaTuJk5i2nE72h4eH6MQg3sbsDw+NOIiTSJvT5rQ5bU6b0xa0BW1BW9AWtAVtQVvQFrQFbZe2S9ul7dJ2abu0XdoubZe227bcvldoxEGcxEXcxEN0YhBpywbybTrbuX2vcBAncdVLUm7fKzxEJwbxNqKXAI04iHkUNzHqVS+/WM6/zWw7v1iu0IiDOImLuInfOnzb4XbuEHzrsHjEi0ecNf9wE7/1zcdjuUOwMIi3cfNsbto2z+bm2dw8m5tnc/NsouZzDqh54G08PJtZ85hD1vzDSaSNNe+seWfNO2veWfPOmnfnteNcSedKOlcyax5zcK6kcyVZ886ad9a8s+adNe+seWfNe/C8oeaBXMngSgbPW9b8Q64ka95Z886ad9a8s+adNe+seWfNx6/PW/yMOIiTuIi5kjPxEHMlV2IQb2PW/MM8tpxD1vzDSVzETTxEJwYxbTnJ8SNmzY/EVVWYXwvn+aw4vxau0IlB7DMU80c04iBO4iJuYp+h3LBYGESeofUjGnEQJ3ERv3HzMXduTSy8jdkf8nFebk30fHCXWxMLJ3ERN/EQnRjE23j6aVLg6QFwETfxEJ0YxNuIpwdAI9LmtDltTpvT5rQ5bU5b0Ba0BW1BW9AWtAVtQVvQFrRd2i5tl7ZL26Xt0nZpu7Rd2m7b7u9HNOIgTuIibuIhOjGItBltRhufOV6jzWgz2ow2o81oM9oGbYO2QdugbdA2aBu0DdoGbYO2SdukbdI2aZu0TdombZO2SdukbdG2aFu0LdoWbYu2RduibdG2aNu0bdo2bZu2TdumbdO2adu0bdoObYc29pLLXnLZSy57yWUvuewll73kspdc9pLLXnLZSy57yWUvuewll73kspdc9pLLXnLZSy57yWUvuewll73kspdc9pLLXnLZSy57yWUvuewll73kspdc9pLLXnLZSy57yWUvud1Lzq97yfl1Lzm/7iXn173k/LqXnF/3kvPrXnJ+3UvOr3vJ+f1oM9qMNqPNaDPajDajzWgz2oy2QdugbdA2aBu0DdoGbYO2QdugbdI2aZu0TdombZO2SdukbdI2aVu0LdoWbYu2RduibdG2aFu0Ldo2bZu2TdumbdO2adu0bdo2bZu2Q9uh7dB2aMt3KN+fHji517LwEJ0YxNuY71AeGnEQJ5E2p81pc9qcNqctaAvagragrT/1PNhr+fAQnRjE25jvUL4NEif3WhYOYtrw3y7iJuaxeaITg3gLc69loREHcRIXcRMP0YlBpM1oM9qMNqPNaDPajDajzWgz2gZtg7ZB20hbJH627zfyT+61LDxEJwbxNub7lodGHMRJpC33XX1P9g72Wj50YrxtPwd7LYG57+ph7t+ZiYM4iYu4iYfoxCDextx39ZC2TVu+b/m2FpzcP+mO/2+uTh5FPsF4aMRBzBFOYo6QZyhrHpg1/9CIgziJub43cRMP0YlBvI1Z8w+NmLZc9az5h4u4iZ8t8hznU4mHWfN5yaHmE7H/AWjEQZzERfxs34aDk1+o5t+OpZO7HwsXsfaJHex+fOjEIN7G3L3w0IiDOImLSJvRZrQZbUbboG3QNmgbtA3aBm2DtkHboG3QNmmbtE3aJm1ZsfnylTslC/Mc4z9w4ndFfb87eXKn5MN80vDQiIM4iYu4iYfoRNry+cP3YenJnZKF9nb9HeyUfDiJi/iN+33ieHL3o9+8uE7t2TvY/fhwEmvP3sHux4eHmDsEc81y9+PD25i7Hx8acRAncRE38RBpc9qyjm8eZlbsxf/3W9+bR5EV+9CJ0ZivxzfPcb7y3lz1rMKHh+jEIN7C3KUY3291ntylWDiIk7iIm3iITkzbSbyN+cr70Ihps8RJTNtM3MRDdGIQb+P4EY04iJNIW9Zx9rPcpVjoxHj7Mk/uUnyYdfww93vmOmQdP5zERdzEQ3RiEG9jvvI+pG3RtnLNVmKuTi71ytX5rp3ceVhoxEHMEW7iN4LluN+r6cOvNguNOIiT+K2v5ep8tVl4iE4M4m30H9GIOd+8lH0SF3ET05bn2J1Y+2lPbhYMyzWLTTzE/LGdGMT7dtkebCF8aMRBzHHTdnOEXOrcNpwFmdsCC4043jbck9sCCxcxN/J64iE6MYi3EduGgUYcxElcRNqMtiw9y/lmkX0bGU5uAIxvn8LJDYCFm3iI3wjfRoaTm/ri28hwclNf4SJu4iE68Vvf75cYTm7qe/gVTqERB3ESF3ET0zYSnRjE25hFNnJ1ssgepi3P257ERdzEQ3RiEG9jFuRDI9KWb3+zE2BT38NN/N5sZ/ljU9/DIOYm8O+yx6a+h0YcxElcxE08RCcGkbag7bvpjZkXV9bmzKXO2px57WRtPryNX20W5gg52M0R8uCvE4N4C3PzXaERv/XNW+HcfFe4iJt4iE4M4m20tK1EIw7iJKbtJm7iZ/v2dpzcZhf5Vi632UW+acttdoWD+M0sbzhz61zhbZw/ohEHcRIXcRMPkbZ8YJWdFlvngPnA6uF3nWXTxda5h5P4XWfZ17F17uEhOjGItzEfWD004iBOIm2btqzNlacwq/DbGHBy61zsPBf5svhwETfxG2HnYPlSt/Pg86Xu4SQu4iYe4re+O69UD+Jt/Cqr0IiDOImLmLaReIhODGLa8hxnFT5MW16pdxAncRE/28nVyYp96MQg3sLcJFdoxEGcxEXcxO/a+fZSndwvVxjE/NWR73TnfrlCI+avjpzESVzETTxEJwbxNuZD6odGpG3Qlq+x36e0J7fDRb4Xye1wke+dcjtc4SBOYo6QR5yvpvnAKre4FRpxECdxEb/1zSdPucWt0IlBvI35avrQiIOYtjzifDV9uImHmLY8x1mxwKzNfG6UW9Ein6LkVrSHeRv6MOeQS5K1+XASF3ETD9GJQbyNWZsPaYv61aeTW9EKF7F+9enkVrRCJ35XVN6i5Fa0h/kB0kMjDuIkLuImHqITabtty01n8f0az8ntZZHvW3J7WeT7rNxeVhjE25ivhd/vwpzcMhb5OCS3jBU6MYi3MV8LH37rm+8DcstY4SQu4iYeohODmLY84qy3h0YcxLR54iKm7SYeohOD+NnyeUl+WV2hEQdxEhdxEw/RiUGkDb/IthONOIj5i2y5JPhFNuAm5q/N5bnID3oeBvE25gc9D404iJO4iJtI26EtqzufzuT2srj4/+bq5FFkHT88RG/Mis33Q7llLPL9W24ZK9zEQ3RiEP+O+OYDldwyVmjEQZzERdzEQ0xbrnq+bj68hbllrDBtljiIOe5MPEQnBvE22o+Y467EQcyj2ImLmLacjh1i2jwxiGn7li83hxWm7SYO4mfLBxS5Zazws1ke5lfdhZ8tHzrklrHCz5b3fbllrPCz5S1rbhkrTFse0FzEtOUBzUNMWx7QDGLa8oDWj5i2PKA1iJ8t34LnlrHCvNcAHqITg3gbs7offrZ8u54byQonMW15xF91Fx6iE4N4G7/qLjTiIE4ibYe2k+Pm+nqOkIvqOUKupE/iIm7iIXK+zvk65xucb3C+wfkG5xucb3C+wdUJ2oK2rHkcUFY3DuhyvpfzvU4M4i3MbWAYN7eBFQ7iJC7iJh6iE4PYq5PbwAppy+rOA8qtXTig3Nr1Jmmcb9bxQyMOIuc7ON/B+Q7Od3C+g/MdnO/kfCfnO7k6k7ZJW1YsDihrEwe0ON/F+a5JXMRNPMQcNxKDmK+FX6Fju9ZDIw5ijgv8Rsg6xhasfIuILVgPjfiNsPOA8tX04SJ+vSTfpmIL1kMnBvE25nOjh0YcxElcRNqctqzC79eOTm6ruvl8J7dV3XwyktuqCjfxEHOEPFn5aprv6nKrVOEibuIhOjHXN5c66+1Dz61ShUYcxElcxE1M2050YhBvY9bb+iUa8bN9v8bjuVWqcBE38RCdGMTbmLX50Ii05bvQ7720Y6vUw038zubBf+vEIH7XzsmjyK1SD404iJO4iJt4iE4MIm2LtqzYb5eB5/anu3Kpsza/u1fP7U+Ft3H/iDlCJOYIeWLztfBhEG9jvhY+NOK3vjuXL18LHy7iJh6iE4N4Gz1tnmjEQZzEtOUZytfNh2nLI87XzYdpw4+lLdchn+l+jyI8tzQVDuIkLuImHqITg3gbL22Xtqx5nOOs+YeLuImH6MQg3sLc0lRoxLRZ4iQu4iYeojdmxX6PZDw3JBUeohODeBuzYr9nIJ4bkgrzv/XE25ivhQ/zv72JgziJ3xnynGTW28ND/M7Q98UentuJCm9j1pvnQuWT3oeDOImLuImH6MQg3sZN26Yt714ffiuJmWVtfo+FPLcTPczafGjEHCGXOuvNc32z3h7exqy3h0YcxG99v4ckntuJCjfxEJ0YxNuY96kP07YSB3ESFzFteY7zdfPhZ4tcnbxPDfy3tzHfsT404iBO4iJu4iE6kbZ8mpQHlF+8VmjEvHZu4iQuYl47nniITgzibcwnvQ+NOIiTuIi0GW1Zm983HHhuMrqR/9+8p408irynfbiJh/iN8G2Y8dw4dL9HMp4bhwoXcRMP0Ynf+n6fVntuHHqY97QPjTiIk7iIm5jzzVXP182HQbyN+br5PXzx3DhUmNuqTqITg3gbszYv0IiDOImLuImH6MQg3kanzWlz2pw2p81pc9qcNqfNaQvaso5vXjtZxzevh6zjh4u4iYfoxCDexqzjh0akLbcF7jxvuS3w4Sbmpqi8PPNr0x4G8TtveU+Ar017aMRBnMRF3MRDdGIQaTPa8q7420zhucno7wXckj15JIfwJX+vqM0zeSVjnJ3swiF8yfMnbMIj2ZOn8BLewkfYhUP4khe8M9mEh/AUhjeXbW3h9H4P0Ty/+aw5hC95/4RNeAhP4SW8hcWbjSFfiHPXUuFtzO9TzBe23LVUOIjfBZYv+7lrqXATD9GJQbyNuaPwoREHkTanzbF6eQUGViknH1ilnGcM4Sm8hDHO1ypyb9If5xm/JjyEp/AS3sJY7ayU68IhfJtzR1OzCQ/hKQzvTt7CR9iF0/s93vTc2lRs6f2eSXpuY2pewjn+96GZL1T94xz/e7DjC1X/+JJR9SPnMEx4CE/hJbyFj7ALh/AlT/FO8U7xTvFO8U7xTvFO8U7xTvEu8S7xLvEu8aJLfI/BfKFLPD7CLhzCl4zvWPXE1Zfzeg0AfIRdGEPmzx5e8rklqnkKY8qRvIWPMKacl+oJ+dlL9p+weF28Ll5fwlv4CLuweENcaAMzL3+0gcdbOMf89kz5Qnt4HMKXjLYxsyzQNh4P4SkMb5YI2kM+llpoD49v80Z7+B7A+UZ7eDyEp/AS3sJHGF5PDuFLRnt4bMJDeAovYYz5XQMbpZ8P2TZK//EUXsJb+AjnnPOZ2UbpP75klP5jEx7CU3gJwzuTj7ALh/Alo/QfG88dSv/xFF7COC+WfLluePF/bMJDGMeykmWtUOOPQxhzTu/5CZsw1iqvkyPn6Mg5OnKOjniPeI94Uftg1P5juTZcrg0Xr4sLdZ03j7lDqxg1/tiEMWZek6jxvGHccYRdGHOO5EtGjT/GnHP9UeP4WdT44yUs3iveK94bwrzhPb+fsAkP4SWcY34b6vygrh9fMuo6H0Ye1PXjITyFc/zv0wQ/uB14fIRdGN5v/Q9qf+fcUPuPpzDGP8lb+Ai7cAhfMmr/MbyePISn8BLewkfYhYOMus43bwcv3fk+7aCWH7twCF8yavxxzjmf6B/U+OMpvIS38BF24RCGN88Rav+xCQ/hKbyEN88dav+xCwcZ9Z6Pzw/qGuuG1/THW/gI41jyWgpZK9T44yGMOacXr++PtzDWKq+TkHMUco5CztEV7xXvFS9q//ESlmvjyrVxxXvpyi1feE6V3zNWuIibiPE8+dbTqfxKsUIjYrKRPIWXMCZ7kw9/1IlBpHHQOGgcgziJi7iJtA0qUMT5qNlRxI+ncM4/3xM6ivjxEXbhPMn5RtfxAg7GC/hjE4Z3JWP8nXyEXRjjn+RLRqE/NuEhPIWXMLx5olHoj104hC8Zhf7YhIcwxszzjhfqyLVF4T424SE8hZdwzjmffjsK+rELh/Alo9Afm/AQhjfPEQr98RY+wi4cwpfnDoX+2ISHMM5LXp8oYqwbXsAf3+bAC/hjHMtK5loFbtIfH2HMeSeH8CXjxfzbSOlhPEdhQ3gKi9fEa+LFi/njEOa1EeMnLN4hrqzqXDbsDXsYxNuIF+98sI9tYHnpYxvYw03EZCPZhUMYk82FX/0hEraCPRxEGheNi8Z8NP/QiUHsj6xyK1ghFSji7NyBIn7swjn/b3elB4oYjCJ+bMJ5kvPDg8Cr9eMlvIXhzQsQhZ4PxgOF/tiEMX7OH4X+eAlv4SPswiEMb55oFPpjEx7CU3gJb+FDRhHnY+r8ajCzX65tFm7xFj7CLhzCN/lb89wa1mzCQ3gKL+EtfIThnckhfMn2EzbhITz73F0U+uMtfIRxXr5mdlHEuW4Xd+qPp/ASxrGsZK5V7hMrnj9hzDm9cwhPYazVSd7ys0fYhcU7xbvEu0x4CE/hJSzeJS5sVIlEIw7iJGI8T+79K5f7Vy73r+Tesr//OH/wmPAQxmTx3y/+6CYeIo2HxkOj/4hGHMRJpM2pyCK2/Dwhv8Kr2YRz/pYXeBZx8RLewnmS8yl+fpNXcwhf8oU3L0AUej7tvij0x1sY4+fFhUJ/HMK3OH4o9McmPITh9eQlvIWPsAuH8CWj0B9jzJucP/s9uY/cadZ8yfmqXGzCQzjn/P2GSeR+s+YtfIRdOIQvGYX+GN6ZPISn8BLewkfY69zFD4X++JJR6I9xXix5c93WEXbhEMaxrI+3rNWewksYc07vPsIujLXK62TLOTpyjo6coyPeI94j3rOFj7BcG0eujSNeF1dW9cyp5SfsDw/RiRgvr8f8MH0CB3ESMdlI3sJHGJPNhc8P1N+P3sb8QP0hjZfGS2NvPo1fbz6NX28+jV9vPg1sREvE7rOHudjfs/8wFPHjLZzz/573h6GIH4fwJaOIv+f9YXi1fjyEpzC8Kxnj7+QQvmQUep4gQ6E/HsJTeAlv4SMMb64JCv3xJaPQH5vwEJ7CSxhjfufd8Kq8cm1RuI+n8BLewkc457xyzVHQjy8533oXm/AQnsJLGN48Ryj0xy4cwpeMQn9sPHco9MdTeAnjvFjy5br5T9iEhzCOJa8ll7VyFw5hzDm9eDF/bMJYq7xOQs5RyDkKOUch3hBviBcv5mC8mD+Wa+PKtXHFe8WFF/CV1xhewL+7sBh4AX9swkN4Ci/hLZy95JfoxCDexnz49tCIgziJ+SsMOxFLdJND+JJR8o/zcHYOg5J/PIWX8BY+wi6cvztxEm/j/BGNOIiTuIibeIi3j3jJ0bxmAB7CU1iOZsnRLDmaJUeDZvD4ktEMHvOANg9o84A2D2jzgDYPaDuRy7e5fPiVrDziI0eDUn+8hY+wHM2RozlyNC5H43JNuFwTLteE84CcB+Q8IOcBOQ/IeUDB6yG4fMHlw+9s5RGHHE3IFR5yhYdc4VeO5srRXDmaK0dz5Zq4ck1cuSYuD+jygG4f0Pz9iEYcxElcxE2M9wutkRvnHuaXkzw0Ig7Fkuv3XANf2vXQiTjrI/mS0QkeY51m8ugfzd/KfriINA4aB435W9kPb2P+VvZDI9I2qcBd+/fhX2A3XfElo/Z3Lh5q//EQnsI4z7mAr/bBR9iF4c354AX/+zApsGuueArn+N8HMIFdc8VH2IVD+JLxgv84vSdPNF7wH0/hJbyFj7ALBxkVfvK8O3421xYv+I9dOIQvGS/4jzHnXHO84D+ewkt4Cx9hFw5hePMcodYfm/AQnsJLePPcvVoHu3A0Y3+dfR9GBvbRYd2wj654Cx9hHMt3LWG/HNZq4ab+8RDG+OnFTf3jLZzjf59fBfbR1c+GMM8R9tEVi3eIF6/8j5fwFj7C4h3iwnct5KHjuxaAi7iJOA5Lvu97IgJfIPbQiDnZ70O4wCa44iWck/UcPL9a4f2oE4NI46Zx05hfe/JwEhdxE2nbVKCIHTyEpzDmf5K38BF24TzJ3wdvgR1xj/FS/tiE4c0LEIXueRGh0B+7cI4feXGh0MEo9McmPISn8BJOb+SJRqE/duEQvmQU+mMTHsIYM8877uBz/bHzrdiEh/AUXsKY80k+wi4cwpeMQn9swkMYXk9ewlv4CLtwCN8+dxuF/tiEhzCut53svW7YEVd8yXjH/hjHEsmyVngE9/gIY/z04sX88SXjxfz7/Cqw8+397JJztOQcLfEu8S7x4sX8cQjLtbHl2tji3eLClxnlMueXGT0M4m3Ei/f3WUjg+8ey5+P7xx5uYk72+xAusOWtOIRzsjcXPr81BT+a34n0cBBpdBqdxvwulYdODOJtDNqCChTxzYVBET92Ycw/L3AUMRhF/NiE8yTnrS22vxUv4S0Mb84Hhf59mBTY5lZswt/44/sAJvKLyJqX8BY+wi4cwjf5O9HYCldswkN4Ci/hLXzIA2POZPzsSl7CW/gIu3AIY87fmmObW7EJD+EpvIS38BGG15ND+JLXT9iEh/DkuUOhP97CRxjX29fMsP3trdsewlN4CeNYIlnWal/y+Qlj/PSeITyFc3zL6+TIOTpyjo6coyPeI14Xr5vwEJZrw+XacPG6uPAthHno+BZC4CBOIo4jr0d84SCGCOJtzOIe34dwgf1txUM4J2s5OL50ED+6iYdI46XxtjH/xmahEQdxEhfxEHOxLRlF/NiEMf+TPIWX8BbOk5wfvOWet+YQvmQU+vcNQ+Eo9PwwyVHoj7dwjp8fwDgK/XEIXzIK/bEJD+H0fr+qE9gKV7yFj7ALh/Alo9AfY8yZjJ/NtV0hfMn7J2zCQxhzzjVHQT/ewkfYhUP4klHoj+HNc4RCfzyFl/AWPsLOc4dCf3zJKPTHuN528ua6+RF24RDGseS1FLJWMYWXMMZPbxxhF87x81kztrm9n71yjq6coyveK94r3ruFj7BcG1eujUsvtr8Vf1WdH3UEvvwXeIhOxHF812Pge35P4iBOYk42P4TD/rbiI5yTzQ/ecn9b/ehtzG89fEjjoHHQmM/XHm7iITqRtkkFijg//AsU8eMtjPnjv3fhEL5kFHF+8BZ4tX48hKcwvJGM8W9yCF8yCj0/gAkU+uMhPIWX8BY+wuldeaJR6I8vGYX+2ISH8BRewhgzzztelfNDMmxzK57CS3gLH2HMOdccBf34kuMnbMJDeAovYXjzHKHQH7twCF8yCv2x8dyh0B9P4SWM6y0LEEWc64btb8UmPIRxLJHMtcI2t+IQxvifF9vcik04x89n+tjm9n7WlvAWFq+J18SLF3MwXswfm/AQFu8QV1Z19vHb388fufmt0Ig4Dkv+2kX2w9tf0B+3v6A/sL9t5IN+7G97jOJ+nJPN276LL+nPH8WX9AMXkcZF46IRX9IPvI34kn6gEWnbVKCINziELxlFnA/3seWteAhP4TzJ+XD/4tX68RF2YXjzAkSh54Pgi0J/PIVz/Hxwf1Hoj4+wC4fwJaPQH6c3H9ZjK1zxFF7CW/gIu3CQUcT5kBrb3EY+wMU2t2IXDuFbfLHNrRhzPslDeAov4S18hF04hOH1j1Hoj014CE/hJbzr3N0fCv2xCwcZxf19AHCx/S3X7WL7W/EWPsI4lvh4ylrhjvzxEMb46cWL+eMtnON/HwBcbHOrnw1hOUdLvEu8S7x4MX+8hLfwERbvEhdewL+H+hfb38b3bP5i+1vxFj7CLhzCl4y/iZOnEX8TBziIk7iIm3iI3pjfIxF5meX3SDwcRBxMHiQK/vEWPsIuHMKXjIJ/bMJDWLwh3hBviDfEG+IN8V7xXvFe8eafCfjl9Zbv2B9u4iHC+RVI7ozLv0l083vZCgcRB3SSl/AWxgF5svNHg3gbjUaj0WjM+/uHi7iJh0ibUYGX8e9TlIt9ccVLOOcf+O+PsAuHcJ6Q7xOMi31xxSY8hNP7/frSNXSA76n8NXSAxyGM8b+TaegAj014CE/hJbyF4c0TjQ7wOIQvGbf5j014CE9hjJnnHa/ykWuLV/nHQ3gKL+EtnHO+ueZ4lX8cwpeM9+SPTXgIT+H03jxHaAaPj7ALh/Aloxng3KEZPB7CUxj1cpOD64ZCB6PQH5swjiWvpStrhVf/xy6MOacXr/7J2CNXjLVayTxH2CNXvIS38BF24RC+ZPsJm7B4TVz5R2S/zxBu7o8rvI35R2Qf4jh28np/yO/mHrjCQ8SJPckhfMkobgyefzMWP5p/M/bhJNI4aZw05l+gfBjE25h/gfIhbYsKFPFjFw7hb/7z+8TjYs9bsQkP4ZlsyUt4Cx9hT/4uwPwmuT/Oi+iY8BDG+HlxnSW8hY+wC4fwJTu8eaLdhIfwFF7CW/gIOzkwZp73wM/m2sYWPsIuHMKXnAU980UJe9yKh/AUXsJb+Ai7cHotz1EWOji3uTWb8BCewqvPXe51az7CLox6+ZoZNrlh3fJL45qX8BbGsYxkrhX2uRWbMOac3jGFlzDWaiUf+VkXDmHxTvFO8c4hPIWX8BYW7xTXwvrvZBzLSZ7CS3gLH2EXDuH7/iTszS+QKzTiIE7iIm7iId73t5/vxN+JBhpxEHEseX7zT8Y70IlBxIWai4OifmzCWKi8wPpPSN+JPyEN3EQanUanEX9COhF/QhpoxEGkLahAgX+fwlxsbHuMAn+c8x95YaPAH0/hJZwneuQFjAJ/7MIhDO93kePL4ua38fZik1vxEsb4J/kIu3AIX7L9hE0YXk+ewkt4Cx9hFw7hS0aBf59oXGxgm98nGhcb2IpD+JJRyI9NOOf8fRhw8UVwxUt4Cx9hFw7hS17wzmQTHsJTeAlv4cNzh2J/HMKXjBf375O7i2+Ce+uGF/HHR9iFcSx5LR1ZK7yIP57CmHN68SL++AhjrfI6OXKOjpwjl3Pk4nXxunjxIv54C8u14XJtuHhDXF9Vbyzb99peiBHzysNL+2MXDuFLRuU/NmEcSa4yKv/xEk7vypmh8h+7MLyRfJuxS674e/SRhZmb5AoncRE38RCdGMTbmN8I+/AbN1tyboErxLFY8hF24RC+ZLzkPzbhXMPv44WL740rXsLwruQj7MLwjuRLRqd4nGv4SxzESVzETTxEJwbxNuYfp36Io9nJS3gL42hyzdEHHocwjua74rA3rhirmFcHbvgfT2F48+yhVzw+wi4cwpeMNwKP07vzGNFDHk/hJbyFj/C3lvkeJXfRrXzPm7vodr4TyV10hZO4iJt4iE78O5wVOevvvuDh1ywKjTi+OeT19nWQwkXcxEN0YhBv4/0RsUI5NfSIx1sYK5RrgR7xOITzzHyfDF1ssCvGmVnJQ3gKw7uTt/ARduEQvmTcNTyG9yQP4Sm8hLfwEf7WMl9oc6/dyvuf/Ka5NYGDOImLuImH6MTvHOVrWG69e/g1iUIjfrYBnMRF3MRDdGIQb+P6EXlFYFtd8RbmFYFvnisOYbkitlwRW66ILVfElitiyxWx5YrYckVsuSK2XBFbrogjV8SRK+LIFXHkijhyRRy5Io5cEYdXhPOKcF4RzivCeUU4rwjnFeG8IpxXhPOKcF4RwSsieEUEr4jgFRG8IoJXRPCKCF4RwSsieEVcXhGvR3jyEt7CRxhnJpJD+Db76xHg72jyBSq35RVO4iJu4iE6MYi3ES3g+zDzYnte8RLewkfYhfNwvq/2u9ie9xi3Eo9NGN6TPIWXMLyefIRdGN6bnN78QA/b9mZ+gIZte8VDeAov4U3GG4f80AzfQleMn53JSxg/u5L/5ox7h9y1VxjE2/g1gkIjYmRwHnW+r88NeLhryP13D8+PmGPkCn0lXTiJi7iJhwgdOISxyGnBu4bHJoxp50nxPPKcNd4EYG38kvGG4LEJ53rnxzzYgle8hGW98VbhsQuLN8SL8s2PgrC9rngL55j52SW21xWH8G3GN80Vm3AeS37UEXiJf7yEt3B684kPvoGuOITTm7cr+Aa6mU/K8Q10xUN4Ci/hLXyEXTiE4f0uB3wDXTG8kTyEp/AS/rwr7/5yp16zC4fwJWd9F5vwEJ7JI3kJ4/zmuk14wS4cwpe8fsJwreQpvIR38k4+wi4MV67huuQNV67VNuEhDO9NXsJb+Ai7cAhfct4crHySjd19xUN4Ci/hLQxvXjOvbeTxom1k/WIHYPEQnsJLeAsfYe8eHK/PgC/59Rkw+kzODX3m8RRewlv4CLtwCF/yxbrlNXmn8BLewkc4z1c+QceX4RXfZuwGLDbhIQxvJC/hLXyE4b3JIXzJ2XNwH4FdgsVDOL35YBW7BFc+NMUuQdwiYpdgsQuH8CWPn3C+pCWtpt10mrwpilDjeSuHjX2PUeOPvxfSnP1X7Y9m02raTacJY37XwEXN5sPU/I66fMiRO/Ye7abv7s2SvCmabtFXpY+sCZY8g6jQx1j5PGuo0MdHOGebj+WwRW/NHDMrsfibL/6LHAXHmXVY7MIhfMlfHT7q1Y1e3ejVjV7d6NWN4Jpe45qixvKBLb6HrjiPHOcbNfYYc85znH/sKY8v/9YT6ILsl3vzCo04iBj3IOCgHeFvlIP/KP8U20Mj/o3y7VT8cBIXcRMP0YnwBcKVgDL5nmx+wTQMDTn7hdHwcrswObzevvC94G78BF5vv7X7wtAwNSwNsAyEo8E1RJ2iL1wJKMoKOoOlM1g6g6UzWDqDpTNYOoOlM1g6g60z2DqDrTPYOoOtM8BrcoWDUvqwa+YLoeFKwMtyBZOQL6JrYWao3QpTw1dPuEq/8i08RCcG8TZm5T404iBOIm1BW9AWtAVtgYsOIR/mdzANOEpc6Sj4CrnkC6uMkq9wNLiG0HAZDK+tFXIGqHrDq2uFqQEzuAhbw9GQM9gDITRcCV/jQKnmvrzCQZzERdxEjD0zoBHshYBjwNGNqWFp2BryGLYjuIbQcCXgbr3CdxQP4Q+EqWFpSD8aHjbtdXAN6T9YNjSPF9A8DlYAzaPC0PC9MGNmX+so3MRDdGI0oi0crC6K/2DZUPznIBwNriE04BiwCCj/CqZhaJga8vk7cBMPMZ+IA4N4G/G0H2jEQYTvhaVhawgJefO9HFPIu+8O3xnA3PNJ3cNNzJVznNa8+e4QGnLlHOcBXaQC3Dgp6CIV8kgcS48u4jir6CKOGaCLOI4EXaRCaPhuIPIncntfoRHTED+EHCcMIceJgZBHEnmBYsPeioWQRxIbAaMdhK3haPhuHC4wiLcRHSEcAeNgvvn3z9//34mY6/vhnOvFIaHmK5iGoSFX/eLIUfUVtoajwTWEhisBVV8BHiwqXv4vFhWv6xeLigK+WFS8rleYGpYGl4AyvVhulGkFjIZ1w134xdI6fgaLiBfzCkPDN4P8FO4LS8PWcMST9+P9v4SGKyHfGncwWR2UZ4WpYWnQNUApvsNGKb5wdXVQcO9auzgenKyL48HJyoLr4BpCw2XARrsOpmFkmAhTw9KAGSwEzGAjYAYHATNwhMtyma9UXzAN8LywNRwNX5FBmaX68DYOHMlFyHHsh/CVKo4jS/VhztUMIVfLsCZZqh1Mw9CQq2UYLUu1w9ZwNLiG0HAlrJ8GeLD2C6PhkDf+M6z9xn+Gtd9Lw9ZwNHz70GD5XmkLb2NuqXtoxEGcxEXcxEOk7dB2aHPanDanzWlz2pw2p81pc9qctqAtaAvagravnh2XylfNhbfxq+RCIw7iJC7iJh4ibZe227b88rhCIw7iJC7iJh6iE4NIm9FmtBltRlveKO+xEPLCGz+EvPDGRsirfeSVu7AHJRF7UIBGzF8VAm7iacyXqT0cYWiYGjC5i/AtRgAP0YlBvI1ZEQ+NOIiTuIi0HdryIdOeOIh8cdsT65jfvYSJ5ncvPdzEQ3RiEG9jfkvLQyMOIm1BW9AWtAVtQVvQdmnLL0rH0eUXpT+cxD8b7khyt1nhIWKF8jrAV6ztORHyzOL5A75krcPWcDS4htBwJeSLVQfTMDToDExnYDoDvIzhOQf2m3UIDVfC+GkwDUPD1LA0bA06g6EzGDqDoTPI71i+QCMO4iQu4iZi7KxxfAvbxvvc9zVsBp7CS/g7ALyAv69he+zCIXzJ+Bq2x1giTAkvfuv9L64hNORC4Ekf9o91MA1Dw9SwNGwNR4NrCA06A9cZOGaAGkDLqDA1YAY4l7gfroAZ4LTgfhjv1vF3TDfeyOIPmVbA/XCFnAEe7uBvmXbIGaBp5/azv4Dp5OdFG49Z8EVvb564UX4cwpeMu+THJgwDDgt3whuHhTthvLPElrMXsOesA47kIgwNU8PSsDWkB89bsJVs40k29pJtPG/BZrIOS8PWcDS4htBwJaBRVMAMJsLQMDVgBgthazgaXANmsBGuBNwtV8gZOHgIT2HowVv4CLtwCF8ybpJxJtFeHg9hHPf7gaVhazgargTcTODdPbaedfgeEGFx8lMoYH4M9fBrkDgx+eeRHm7iIToxiLcx/zzSQyMOIlYYlyKqv8LWkAvr72dCw5WAgsfNL/6uaYeh4TtEHO1X7oWbeIhODOJtzD+w8tCIg0jbpe3Sdmm7tF3abttyY1mhEQdxEhdxEw/RiUHEiiLgnqKCacCKHoSpYWnAaQyEoyHPKZ6WYedZhysBraKCaUDFDISpIWeAx23YgLbxuA070DYet2ELWofQgBngENAqKpiGb90dOImLuImH6I2vG7yAY8DyoOxxR4oNaR2OBteQx4B7UHyXXAW8565gGoaGbwZ4gPT+bCrWA+/F8ZQIXyi37/tfXAP8OBrcjuCuCl8q1+HzHzwlwtfKHTywwffKdcj7J5xR7DwBY4cJjNhh8ngJ7xwIJz3vHTq4htBwJWQr6WAaMGEcZEwNS8PhjLG/5HEIY8N/Mn7l5bEJpw63hdjs1mFpyAN+q5UP2zrkAeP+FDveOlyGt+ftgE14CE/hJbyFj7ALh/Alm3hNvCZeE6+J18Rr4jXxmnhNvEO8Q7xDvEO8A6s9EbaGowGrvRBCw5WQPeXggRi2vnUYGqYGzADTmZiBI2C/H9iFQxj6bC7YANfBNAwNU8PSsDUcDa4hNOgMts5g6wywa/7xFF7CW/gIu3AIX/LbGAc24SGMA8fKnaVhazga8sDx2Ajfj9fhSsju1SFHGwMhRxu4jtCmKoSGKwHNCI+nsL3t4PEU9rd1cA2h4UrIHtQhT8rAoqELVZgaloat4WhwDaEBM8i6wC64DqZhaMAMLsLSkDPAsynshevgGnIGB3zJ2Y2KTXgIT2EYDCEHQm/H/raDpz74GrwOQ8PUkEeClzB8LV6Ho8E1hAbMIBcWfzK2g2kYGqaGpSFngC01+MOxHVxDaMgZ4K0u9uB1MA05A7y3x9+PPXhvjz8g2wEzcISjATPARNFmKlwJaDMVTMPQMDUsDVvD0aAz2DqDrTM4OoOjMzg6g6MzODqDozM4OoOjMzg6g6MzcJ2B6wxcZ+A6A9cZuM7AdQauM3CdgesMQmcQOoPQGYTOIHQGoTMInUHoDEJngM6Gpz/4C7cdTMPQ8DeDgRvT3HTYvIWPsAuH8C223HnYbMJ5gLmFw/A1f2e//yU05GHk0ynDN/11MA1Dw9SwNGwN8MwMg6fFsLcQi2L4mr8OS8PWkKclH5YZvuqvQ2i4EuZPpFNnMIeGqWFp2BqOBpe5vRb1wpWwfhpM5oYWVWFq0BksncHSGUiLsp+0KPtJi7Lf1jXYJtPZeha2noWtZwEt6s1t61nYeha2zmDrDI7O4OhZOHoWjp6Fo2twdA1ei8Lcjp6Fo2fh6FlwPQtoUfmA1LARsgPOwkFYGraGowFr8IYODVcCWlQF0zA0TA1LQ87goJzRoipomaErHdQ2ulIF0zA06MWH+60Keuqvnvqrp/5qAV4pQOyMfGcOOyM7DA1Tw9KwNRwNrkEuPns3VgNhaJga0pNPf83QuA5mjbuuCq4hNFwJuB+rYBqGhqkBno3gGkLDlYCWlreHhu8v7DA0TA2468Jho6VVOBpcQ2i4EtDSKpgG3CljomhcFY4G14Aj9QxoTwOzRnuqMDXgzOFsoz1VOBqwohchdIAr4fw06AyOzuDoDNCeKmwNR4Nr0Bm4StF38j2bYXtkh60hh84tBYavOeyQQzsuZfSdF9B3KuTBOS4+9J0KU0POwDE39J0KR4NrwAxwGtGEXkATqmAaMAOcLLQax8lCq6ngGtITWBC0GgR8P2IH0zA0TA1LQ84gH/4aviWxg2sIDVcC7p4qmIahAUNPBAyQC4+/G9zBNAwNU8PSgEM4CEeDawgNVwK6SwXTMDRgBo6wNGwNR4NrCA2XJxj7MTuYhqEB1+hGcFlRNJQKVwLuhCrg4AJBFxENpcLRAA9mgIZS4UpAQ7m4qo6exqOn8ehpPDqDozM4OgM0lAqhQS8k1wvJdQauUu8n4IY9oMUhnDsI8N+/PzkONuE8rIuFRSupsDTkYd33M0eDa0g7Lg38ZTMw/rLZYxMewlN4CW/hI+zC4r30YptosQkP4Sm8hLfwEXbhEBavidfEa+I18eJ+Jj8qMWwZ7XA0YK3fz4SGvIRyu7HhGx07mIbP7/kpjuFLHTtgBhdhazgaPH9mIISGmyH7JDacdjANmMFCmBpWhoOwNZwMONLpGkLDNwO83s73Z9TAJjyEp/AShgErtnEkOPpsPG74z/Iep8PUsDTkkaAisVe1g2sIDVdCtiQ3XAHHNAwNU8PSsDVgBjie4xpCw5WQLcnf6mRL6jA05AwGZp23Qp6Pog1/OrlDzmDgpGfr6pAzwM0l/nxyhfhpMA1Dw9SwNGwNR4Nr0BmEzuDqDK7O4OoMrs7g6gyuzuDqDK7O4OoMrswAf1+5g2kYGqaGpWFrOBpcQ2jQGZjOwHQGpjMwnYHpDExnYJjBQXANoeFKeE/OwSY8hKfwEt7CR9iFg4y2lRttDd9Z6fmxhOFLKzvgMC6CawgNV8L6aTANQ0N68mMJw7dR1totXRS0qAqmYWjI05KfRxg2DnfYGo4GvTC2zmDrhXH0wjh6YRy9MI5eGEcvDLSoN9GjF8bRC+PohXF0DdCi8F4WX3DZIWcwcU7RoiosDVsD1uAN7RpCw5WAFlXBNAwNUwNmgEsMLaqCy6lHV5q43tCVXkBXqmAahpzGq6f+6qm/euqvnnp0pQqhQU791q60tStt7Upbu9LWrrS1K23tSlu7EnYwe35gbdjB3GFoSE/uejXsYPb83Nawg7nD0eAaQsOVkL2ng2kYGuAZCEeDawgN8OTFhy/J7GAahgbcO+Gw373TC1vD0eAaQsOVsH4aTENu/MHqZncqPsKfBDeF2M9cfMloWflJnuG7MzsMDbnnCOuKPUePtzCW2BFcQ2hIO66lbFfFJjyEp/AS3sJH2IVDWLwuXhevi9fF6+J18bp4XbwuXhdviDfEG+JFX8JTWOx07rA1YIMXLsFwDVhtXCdoUi+gSVXABjOclDs05Ba3izOPndAVtgbs2MLJx/OlCjkDfGqGPdIvYI90h1yBAA/hKbyEt/ARhiHd2B3t+PAMu6MdT/WxO7rD1nA05JWLDzOwO7rDlYAmVME0YAYHYWpYGnJ7DCaN79x77MK5PQar9b6xP/l9Yz/YhIfwFF7CW/gIu7B4p3jRj3KztWFjtG+cA9wuVZgaloat4WhwDaHhSkC/qqAzQL/CpzHYTt1hacAMLsLR4BpyBviQA9/nWQG3WBWmhvzlgwV24RC+ZPwy8mMTHsJTGMeByxS3SRWOBtcQGq4E3CZVMA1YSVymaEcVlgbMAHPDO7kKruGbAe6jD/7UDxh/6uexCQ/hKQw3rj3cLVU4GtLtuF7RiCpcBnz5p+MzDsfdUoWhIY8eHxA47pYqbA05g9zgbtibXf/L14Fwn5BbrgvxwwfhaHANoeFKQPepkNPHA3hsuO4wNSwNOQM8TMeG6w6uIWcQODDcHL2Am6MKmAEODjdHFaaGpQEzWAiYAY4Ht0B4ro3N1x1Mw9AAz0VID54dY1u2X0wULQcvlNiW3SE0XAloOXiuim3ZHYaGqQEzwPGgy+DFFXuxHU8BsRc7cLuGvdjxgzS7TAfTMDRMDUvD1nAyYG7ZmjroxYr3bhVMw9CgReFaFA4pDtuPBteAw8aC+JUQPw2mYWiYGpaGreFocA06g9AZZFsKPDLEHu8OQ8PUsDRsDTkDPOHHJu8OoeEyYJN34Ckhdnl3GBowA0fADAJha8AMLoJryBngkSF2e1fIt3gdTMPQMDUsDVvD0eAadAamMxg6g6EzGDqDoTMYOoOhMxg6g6EzGDqDoTOYOoOpM5g6g6kzmDqDqTOYOoOpM5g6g6kzWDqDpTNYOoOlM1g6g6UzWDqDpTNYOoOlM9g6g60z2DqDrTPYmIEhbA1Hg2tALYAvGU3wsQkP4Sm8hLfwEcYB5stBvLb2Ag5jIiwNW8PR4BpCw5WA5oWH69gBXssVuiihi4IWVeFKQIvC4xjsAO8wNEwNemFcncHVC+PqhXH1wrhyYWAHeAfj3LADvMPUsDRszg07wDu4hlCPzkBb1NUWdbVFXW1RV1vUNbk0rx0NriE0XJnb+GkwDToDbVFXW9TVFnW1RV1tUVdb1B1yHdzXol7QszD1LEy5Du5rUS/oWdAWdbVFXW1RV1vU1RZ1tUVdbVFXW9Rdeh0sPQtLz8LSs7D0LLwWlbcS97WoFzADRxgapoalIWeA97fYO97BNYSGKwFNqoJpGBpyBnhfj73jHfCOFBxsFNggHnh6jg3iHUzD0KAn2/Vku55s15JzLbnXxF7QCz70ZIee7NCTHXqyQy94bXw39HILvdxCLze0N3wagG3gHaYGLCjWDe1tYtZobxVcQ2i4HQb+RnwH0zA0TA14EzoQXENouBLsp8E0wOMIU8PSgCMNhKPBNeBIL8KVgCZWwTQMDVPD0rA1HA2uQWcwdAZTZzB1BlNnMHUGU2cwdQZTZzB1BlNnMHUGS2ewdAZLZ7B0BktngCaWH3UM7C6PhdOIJlYhNFwJaGIVTMPQMDUsDVuDzgC/+vs4hC8Zv/c7wSY8hPOZsIGX8BY+wi4cwpeMLx95bMJDWLwuXvSshcmhMy0UIjpTfm4xsC+8w9SwNGA0VAturxbOLfpPhaFhalgatoY8G2/W6D8VQsNlwIbvDqZhaJgaMANH2BqOBteAGQyEKwHfqXfAJjyEp/AS3sJHGAefpwzfehu5wX3gW287HA3YqgcO4Ut+2y3BJjyEp/AS3sJHWLxTvFO8S7xLvEu8S7xLvEu8S7xLvEu8S7xbvFu8W7xbvFu8W7zoExsnBzc7FXBdXIQrATc7+TsTA9u8OwwNU8PSsDUcDa4hNFwJrjPAfdBBBeA+qAI+aAcv4S18hOHA1Y+ucfC/ZNe4uByzaRRv4W+k3Bo4sKO7OIQ/w8WY2WKKTXgIT+ElvIWPsAuHML3Y3l2Mc7QQcCYOAs6EI4SGKwFvwSpgtIuQo+WT9jFQ9hVCw5WAO5EKpiHPRr5JH9i23WFp2BqOBtcQGq4E3ImgOLBtu8PQMDVgBlhR3IlUwAw2gmsIDVcC7kQqmIahYWpYGrYGncHXWIbh/H6NpfmSv8YyDOfzayzNQ/j75UvDmF9jad7CR9iFQ/iSz0/YhIeweI940TUcB4De4Dg16A2OKxK9ocLUsDTkaPmkaGCjdgQuDtxVVBgapoalYWvIsxEoN9xvVAgNVwLuRCqYhqFhasAMUDq4E6lwNLgGzAArijsRhNy2PfJ998DW68jPaAb2XncIDfj5vFyw/brDd25zs97I/dfNU3gJw4GA/pAf8IzcSj3yrd/IndTNU/gbKd8RjtxG3XyEv6sz3zmP3EPdfMlfW2g24SE8hZfwFj7C4p3iRc3nB1cDO6Hjvv8lzyRaN76pt4NrCAl4J4GXH2yFjotzhPcLFY4G1xAargTcB1ycGtwHVBgapoalYWs4GlwDZoCzhfuAF1DrFUwDZoArBbVeIV9Gf7ic806gw9HgGkLDlZD9oYNpGBqmBp3B1x/GenyEXfi7OvBeLrdBF3+tofm7KvH2M/dAN0/hJbyFj7ALh/Btzr3PzSY8hLGyAwHrtxCwfnlFYhNzB9MwNGA0R8BogXAljJ8G0zA0TA15NgyzzvuHDkeDawgNV0LeP3QwDZjBQZgaloatATMwBNeAGWSNY8/yxQs49ixfvFKvvEvosDRg1lkT2LPcwTQMDVPD0rA1HA2uITToDPLlfz024SH8Xcobq5kv/8VbOC9lnNnjwiF8yf4TNuEhPIWX8BYWr4sX/WFgcugCAzWBLjBwBvE+osLR4BLwlmGgJvDeYOCs481Bha3haHANoSHPBl50sY24g2kYGqaGpWFrOBowg4UQGq4E9IUKmMFFGBrw/sgQloat4WjAe6SJEBquBPSSCqZhaJgaloat4WjQGeQtB9595M7j4rzlKP6uTLynyG3HzVP4uzIdh5i3HMVH2IVD+JLXT9iEh/AUFu8S78LK4gyip+Q++4FNxRdPr7GpuMPSsDVgNJz1vNe4eKHBNuEOU8PSsDUcDXk28DKKzcIdroS81+hgGoaGqWFpwPGgDHCvUcE1hAbMAGcYvaQCjidbAfb0XjzQw57eDkMD5oZFRMeosDUcDa4hNFwG7OntYBqGhqkhe3iAt/AR/q7Y/f77EL7kr1eM3I868kuSm4fwFF7CW/gIu3AIX/IQ7xAvugBekLCT9+KJKrbyXjz9xF7eCrhvqGAaMNpGwGgHITRcCeunwTQMDXk23krj7qDC1nA0uIbQcCXgjqICZrAQhoapYWnADHCGcUdRIWeAR3zYotvhSsh3Jx1yBniYd9AxKkwNS8PWcDS4htBwJaBjVNAZ5N0F3nfn5t7mJfxdmXgKkVt7m104eziWxS85fsImPISn8BLewkfYhcUb4kW3weNEbM+9eJyI7bkXzwmxPbdDaLgM2IR78TgRW20vngZiq20H1xAargTcUVTIs4FXV3xBcoepYWnYGo4G1xAacDxZBtiv28E0DA2YwURYGuDZCKHhSkAvqWAahgZ4DsLSgCPFWcB7kAqYASaK/lMBM8DJQv+pkDPAVY39uh1yBriWsV+3Q84AT82wX7dDziCwIOg/FXIGeAKG/bodMAMcNvpPBcwAh43+UwEzwGGj/1TADHDY6D8VMAMcNvpPhZwBnulg826HnMHFYaP/VMgZ4NEPNu92+Erx4AjyjU3xJecbm2ITHsJwY/lwr1Jha4Ab64J7lQqh4UrAvUoF0zA0TA1Lw9agMwidAe58Ls4M7m/w1Aj7cS8e+mA/boejwTWEBjke7MftYBqGhqlhadgajgbXEBp0BqYzQJfCYWNv7Tts7K19h4C9tR2uBPSiCqZBj2fo8Qw9nqHHM/R4hh7P0ONBl3ph6vFMXdGpM5g6A/Sid9joOO+wlx7P0uNBx6kwNSwNejxLj2fp8Sw9nqXHs/V4th7P1uPZejxbV3TrDLbOAH3lHfbrHjjso8dz9HjO1nA06BVy9ArJ/vHL30T4+3Tip+HrIOimgZuXx1N4CXv+cDayCIw0EHIk+PJ2pHgKfyOhP+ZG2eYjnLdBWIW8HSm+5Hw+WmzCQ3gKL+EtfITFe+m9+MLQ/FWLkdtc/8JG2BkOwtHgGkKCYTQMbRjtImwNR4NrCA1XQr5r+eExYm5ZZRgapoalYWs4GlwDZuAIV8L8aTANmMFAmBowg4WwNRwNriE0XAnrp8E0DA1Tg84gH3SgOnPHarMLf3oUbW5XLc5PWIs/Nz6cyb2qzVN4CW/hI+zCIXzJ+Yi1WLxHvAcr+wLWDzNFbzBckegNFUzD0JCj4eFn7in9thciXAnoDxVMw9AwNeTZwGPR3FPKcDS4htBwJdyfBtOA40HpvC8dfmFp2BowA1wp+OLhCpgBVgdfPZxhvu8ezqea8335cO4ZnrnbdNz3P0zhJbyFj7ALh/Al59OTYhMWr4kX3Sg/q5w/dKMKR4NrCA1XArpRBdMwNEwNmMFE2BqOBtcQGq4E9I98zDh/6B8VQsOVgP5RwTRg1jip6B8vbPwMFnGbhqEhfyY/+Ju5v5Nha/ib9cwXi5nbO5tD+H6MeX3F32zC4+MNnsJLeAsfYRcO4Uv2n7AJi9fFm086fgsnGl0if/F5/tAlFv4zdIkKQ8PUgNFwqKj4hbOBiq9gGoaGqWFpyLOxUaOo+AquITRcBkPFVzANQwNmcBCWhq3haMAMDCE0YAa5orm/89spjGAahoapYWnYGo4G1xAaroShM/iqf+YnmjO/6bd5Cn+XpWH6X+U3H+HvsszbhpnbRZsv+bsFaTbhITyFl/AWPsLineJFf8hnw9NwF5FPMmduAP12XiMcDa4hJKBzHAyN/nCwNugPFY4G1xAaroS8Qfjls4GZ+zoZhoapYWnYGo4G14AZ4IrEfcULuK+oYBowA1wpPjXkDlms7vvC3uT3fb1gE8ZIgTA1LA1bw9HgGkLDlYAOU8E06AyuzuDqDK7O4OoMrs7g6gyuzGD8fhpMw9CAGThCziCfks6BDlPhaHANoeFKQIepYBqGhqlBZ4DfbcE8saH0sQtjexD4krFZ7DH2AYKH8BRewlv4CLtwCF8ytpA+Fu8UL97B5Celc+A+I5/xzoH7jPz+6Dlwn1HBNAwNGO0gYDR41pWAO5AKpmFomBpwNrCK6DAVjgbXEBquBHSYCqYBM9gIU8PSsDXkDAJXCjpMhZxBPjGeAx3mBXSYCqZhaJgaloat4WhwDToD3MfgasVtzGMTTj0WA13p8RLG0YOPsAuH8CWjHT024SE8hZeweK940W3y8fuc6Cn5XH1O9JR8lD4nekqFreFowGi5HNga+kP1Ym9oh6VhazgaXEMuSj5XnxN3IC/gDqSCaRgapoalYWvADBzBNYSGKwFPQ/LJ/sTe0g6YAZYXHaPC0ZCei4VHL6mAI8XyopdUMA3wYDp4z1JhadgajgbXEBquBPSfCqZBZ7B1BltnsHUGW2ewdQZbZ7B1BkdncHQGR2dwdAZHZ3B0Bug/Fxcs+k+F0HAloP9UMA35m1Q4ca+vvP/BNYQGrRg0FrxJn6EVE1oxoRWTTQTfFDix47RDaLgZcI2jkbwB0EkqaM1encHVGVydwdWavVqzuK+pcBmw/bTD0JC/gJBPmmd+py6Da8DBLYQrIW9YOpiG/D0EvEvN79RlWBq2BszgIMCTl05uVGUwDfAEwtSwNGwNR4NrCA2YAZZq/jSYhqFhalgatoYjITuN5WPgmTtQB74Cf+YOVIat4WhwDaEhDwFv9BZ+VaWCaRgapoalYWs4GjADnEb8ykqFKwG/tFLBNAwNU04wfnGlwtZwNODMZYvHztRaUR8apoalAQeHi891Ef1KiJ8GeDCDGBqmBnhwVYWextDTGHoaQ2cQOoOrM7imYWjQC+nqhXR1BlekG50CN8Yb74AqDA1TA4a+CLizcoTQIHfWG20jH3TPjbZRYWjIQ8gn2HO/9zlvgK3haNAZmM7AdAbjp8E0DA1Tg85gqBSdYmAR0SkqmAYc3EKYGpaGrSGvkNzCPLEftUNouBLQUAbODxrKwETRUCpsDfAEgmsIDVcCGkoF0zA0YAa4QtBQKmwNR4NrCA1XAhpKhRx64nLJ+wv8Oeq50RwqXAl5f9HBNAwNeQgTpwRto8LWcDS4htBwJaChVMAMcBrRUCpMDUvD1nA0uJxgNJQKVwIaSgWcuYmwZUXv0eAaQgMOLi++3Mxai5ibWRmWBngc4WhwDfAEgpxGbGntYBp0BqYzMJ0B7kMqHA2uITToDIZK0SnOC1vD0eAaMHReygfva/Cc8eB9TYWpIQ8h92XPg7ZR4WjIQ8AnIWeGDiDPMw/e8VTQGSydwdIZrKVhazgaXIPOYKsUnQKfZhx0igpbAw5uIbiG0HAloFPg/cLBrUeFoWFqwAxwKaOh4LORg4ZS4UpAQ8GHHgcNpcLQMDUsDVvD0YAZ4ApBQ6lwJaChVDANQ8PUsDTgV45xueAGY2Ph0RwqTA1Lw9ZwNOA3m3FK0DYqXIb8olkG0zA0TA1LA2awEY4G1xAargQ0lArGE+xoKBWmhqUBZ24iXK6o471MBdMwNODgDoIsouMdS4XQAA9mgPuQCqYBnkCQ0+hzadgadAZTZzB1BrgPeQH3IRVMw9CgM1gqRad4K4pnIy+gbVQwDRj6IuAzPxwpnoBUcA15CPjEyNE2XkDbqJCHgE9Y/Mjnnn6mhqVBZ3B0BkdngCcgFeSTV2xM7WAadAauUnQKvLA4OkWFKwGd4qBk0CkqDA1TQ14h+GTKcetR4WhwDZgBLmU0FHx84mgoFaYGeHA8aCgVjgbXEBouQ6ChVMAMLsLQMDUsDVvD0eAaQgI6BT60CNxg5Db3GWgOFVxDaLgS0DYq5CHg44xA26gwNSwNW8PR4BpCA2aQpzHQUCqYhqFhalgaNk9woKFUcA0hAT0E9weBTvFWFO9lKmwNRwMOLi++2LqI7+s6Xhga4MEMcB9SYWuAB1fV1tO49TRuPY1HZ3B0BkdngPuQCkuDXkhHL6SjMzgqRafAu2rsQe2wNGwNGBqXsuw/myH7z2bI/rOJDaqGD5WwQ7XD0pCHEO9njg7gGkKDzuDqDK7O4A4NU8PSsDXoDK5IsUnV8KnURaeoMDXg4BbC1nA0uIa8QvDxz8Wtxwu49ahgGjCDgwCPIxwNrgGeQLgS0FAqmIahYWpYGjCDi3A0uIbQcCWgoVQwDUNDDo2PjLAv1fCJD/aldjANQ8PUsDTkIVycErSNCq4hNFwJaCgVTMPQgBngNKKhVNgajgbXEBqunGA0lAqmYWjAmZsILiuK9zIVrgS8l6mAg8PF57qIeMdS4WiABzPAfUiFKwH3IfhcBxtaa4DQ0xh6GkNnEDqD0BngPqRCaNAL6eqFdHUGV6XoFPh44O1UrRAaboeFnaqWnzMtbEjFzvL1+y0NW8PnGflp0sKm1A6h4WawDNg78gZ4++FfGBp0BqYzMJ2B7JRfP9kpv36yU379ZKf8entTK6g0O8XIT5MWNp12cA04uIVwJWSn6GAaRoaNMDUsDVsDZnAQ4PEM66fBNMCDc7qmhqVhazgaXENowAywVPunwTQMDVPD0rA1HAnZKYbhcskbjGFY+GwOHbaGo8E1hIY8BMMp8Z8G0zA0TA1Lw9ZwNGAGOI0eGq6E+GkwDUPDlBMcS8PWcDTgzM0M12RF79AwNSwNODhcfFcX8V4Ge18i9gI8jjA0TA3wBMLWAY4G1xAadAamM8DXkFUYGqaGpUFnYCodGPoi5NB517lyIyvD1LA0bA1Hg2tAr3rSK2H+NJiGoWFqWBq2huhfOFuGhpJ3kMvQUCqYhqEBR4rR0FAqbA1Hg2sIDVfC+z07XBTv9+xeGBqmhqVhazgaXENIeL+/iwU5eqToOxWWhq1Bj/TokR490qNHir5TwTQMDXqkrkfqeqSuR+p6pK5H6ldC6FqHrvX7XV0sSOiRortUcA2hQY/06pFePdKrR3r1qrp6VV29qq4e6dUjvXqkV470fSlqBdMwNEwNS4NzQbAj9h0pdsRWsJ8G0yBHih2xHZaGreFocA2hQY906JEOPdKhRzr0SIce6dgajgZZa2yDxbc3LOyD7TA0TA040onA73VY433XwAtXwutIC8E0DA1Y0Y2wdICt4WjQGSydwdIZoCNVMA1Dw9SgM9gq3bhc8vUUG2Y7mAYcHNb6NaEXloatAZcL1vo1oRdCw5WAJjQxN9ziTFywuMWpsDWkZ+Liwy1OhdBwJeAWp4JpGBowA1whuMWpsDUcDa4hNFwJaEIVMDQul4sBsPC4xalwGd73pFYwDUMDDiEQloat4WhwDaHhSkB3qYAZXIShYWpYGraGo8F5grGftsOVgDuhCrhGHWFzRbFRtoNrCA05dH7qu7AdthYR74wqLA3pWZgB3hlVcA3pyQ9gFzbK1gBLT+PS07h0BktnsHQGuMWpcDS4htCgM9gqfd+KhAV534r0wtHgGnBweSnjm1nxlU8L38zaYWrIQ8hPlxf2uXY4GrCI8ODbA2qAKwHffVRBZ+A6A9cZ4N6lwtZwNLgGnUGoFJ1ivbA0bA04OJQMOkWF0HAloFMsFAZuVyoMDVNDzmDjUkZD2bgS0VAqXAZsdB352eHCF612GBqmhqVhazgaMIOJEBquBDSUCqZhaJgalgYMnZcLNroOnB9sdO0wNSwNW8PRgEMIhNBwJeBRSwXTMDRMDUsDZnARjgbXEBquBDSUCiYnGA2lwtSwNOAadYQrK4qnKxVMw9CQQ+envgsbXWsRt2sIDek5mAHuQyqYhvQcXFVHT+PR03j0NB6dwdEZHJ0B7kNewH1IBb2QXC8k1xm4St/3KuIs4F3OC2gbFUwDDg6X8vvGRSwivpGogmvIQ8hPlxc2ulZA26iARcT5ed/SiAHetzS+sDToDK7O4OoM3rc0vnAZ3ve6VjANQ8PSkOcnP+xe2ALb4UpAp8hPpBe2wHYYGqaGvEJw748tsB2OBteQM8C9Mja64gtHFza6dpga0pOfHa6NhlLhaHANoeFKQEOpgBlMhKFhalgatoajwTWEBHSK/Nx5YaPrcCw8mkMF1xAargS0jQo4BJwStI0KU8PSsDUcDa4hNGAGOI1oKBVMw9AwNSwNW04wGkoF1xAS0EPyg/iFLbC1ongvU2FrOBpy6MDFF7qIeMdSYWhIT2AGuA+psDWkJ3BVhZ7G0NMYehqvzuDqDK7OAPchFZYGvZCuXkhXZ3BF+r7PFW+k3/e5VlgatgYc3ETIjoS3sed9z/MLpiEPIT9dXuf9dYgXlgYsIjz4JrQawDWEBp3B0BkMnQGeh1SYGpaGrUFnMFSKThEvDA1TAw4uELaGo8E15BWSny4vbIGtgFuPCqYhZ5BfprWw0XXkB6MLG107uIb05GeH66ChvICGUsE0DA1Tw9KAGeAKQUOp4BpCw5WAhlLBNAwNGBqXC24wLhYezaGCaRgapoalAYeAU4K2UcE1hIYrAQ2lgmkYGjADnEY0lApbw9HgGkLDlROMhlLBNAwNuEYdwWVF8V6mwmXAFtgO39ATn/pio+tbRGx07XA0eP6MIYSGKyHvQyY+x8BG1xrAhoapQWdgOgPTGeA+pEJokAsJ+2E76AyGStEp8Cnc+2bXCqHhSsCfocGHde/7W/GZ6/v+1gpbw8mfWQiuITRgEXF+8G2KbwB8m2KFoUFnsHQGS2eAZ6oVXENouBK2zmCrNDsFvuJoYQtsB9eAg3s/cyWcnwbTMDJchKlhadgacgaGSzkbysQHo9jo2sE0pAefHeaXsDIsDVvD0eAaQgNmgCskfhpMw9AwNSwNW8ORcDE0LpeLAbDwd2nYGo4G1xAacAh5SrDRtYNpGBqmhqVhazgaMIOLEBquBDSUCqZhaJg8wWFLw9ZwNOAazdrGFti3otgC22FqWBpyaHw4jI2ubxGx0bUC2kaF9OBDp3h/v+qFqSE9+AAJG117gKPBNegMps5g6QyWaRgapoalQWewVIq/m4sXlpC/drXwvasdpgYc3ETwf+pvWq2Qv3a1Qv7a1cJG14lPk7DRtcPQgEWE5/21qzfA1nA06AyOzuDoDN5fu3rBNAwNU4POwFWKToGbU2yB7WAacHAoGXSKCkvD1pBXCD5AwhbYDv+3t2/blSA3jvwXPeuheEle/CuGYcjyeCFgIAljaYGFoX/f6spTZJw+qujsYrZf5I4ZTxwWmQySmclkQ9ABqKBonEkTXZNGETTRdQBBcPwdjQxpYdYBGoI+QVdBOUFAEBFoC5KCjEAQFAQVQUPQAaignECpRYESFAUNQQcQNwQBQUSgn9AUZASCoCCoCBqCDkAF5QTagq4gIkgIMgJBUBDUOcBawXWADkAF5QRqo1WBQI/mgqAiaAgOanV4aaLr2YmSEGQEx9/RaJImug5QERx/R+NMmuh6EhQcxoLDWLAFBVtQsAW6DzlBQYCGVNCQCrag4h/VrYfGjDQFNmnIR1NgB6gIGoIOQAXlBAHBoVV6Cu1f72Z+gYxAEBQEFUFD0AF8pa/p7wS/M/zWz9QOUDU5QUXQEPQBRJNhBwgIIoKEICMQBAVBRdAQYAsCtiBgCwK2IGALArbgq8RaUFAQVAQNgbagHkDrqR2eK9m0oNoJMgL90qagIKgI9Eu7gg4EWlftBAEBtiBhCxK2QJ/mPUFBUBE0BNiCjH9UtydHQE80TXaAguD4OPn6bxqCDuBwoAxwDOMRQRNNkx0gIcgItAVZgf4dUdABqOicQP+O2oGKzgkSgoxAEBQEFYG2QC1ERecL6LHoBAFBRJAQZASCQKnVXHSvUrTjda9ygoxAEBQEFcHxCUWHRPcqX0D3KicICCKChCAjEATaAh1G1Z0TNAR9As2mHSAgiHOANZt2gIxAEOjIHXNb02S/elTTZAeICBIC/bisADpRa78O0AHoLqZoC3QXc4KIQDuxKMhIIAgKAmxBxBZEbIHuYk4QEEQECQG2IOEfVaUo2iH6iPcJAoKIQKmrgkORqrLpg74naAj0Ew61DCobJwgI9BP07+jh54tAHwE+gSDAFgi2QLAFeiz6AvoI8AkCgogAW1Dwj6pSnKADUKU4wfFxR9RNNP91gIQgIzgspOrE0F3MCSqChkBboKasglLVElVQTpAR6N9RG1VBOUFF0BB0ACooJwgItAVqISooJ8gIBEFBUBE0BH0CLQKbjtiaaKnXdIS5REu9DtAQdAAqGycICI5P0FVTE1sHyAgEQUFQETQEHYAKyhFkkqiCcoKIICHICARBmQMcVVBO0BB0AKohR7BRNJf17FE975ygIKgI9OMO49Nc1rMT9YhzgoRAP0FboPuQExQE2olFAQ5jxmEUHEbBFgi2QLAFug85gSBAQxI0JMEWFPyjuvVoapa69TjCXKK5rAMUBBVBQ9ABqKCcQFVZR1sdKCdICDICQVAQVAQNwJFQ0nR3G/Xwc4KEICPQL1Wj0CNO/gIdwPH41QDHYHXtRJWNEyQER492tdEjoWQQFAQVAbagQwuOlNcJAoKIICHICAQB/FHNZU1HeFA0l3WAiEA/LivICARBQXCYy+ELFM1lHaADUEE5gbagKNC/UxUIgoJA/05T0BB0ALoPOUFAEBEkBNoC7SpVlxMUBBVBQ9ABqDflBAHBgzofsTXRjNW8accfsnGCQzYGCAgigoQgH0CHRARBQVARNAQdgD4gfoKAQFugw1gSgoxAEBQEFUGDAVZ1+QKqLicICHTkkoICPapPhZ+gIegAmn6cGl/DTmwZgSDQv6MtaBVBQ6B/R62q4zB2HMaOw9ixBR1b0LEFvSCoCNCQOhiSprwOEBEodVdQEFQEDcFBfQTnRHNZBwgIIoKHVlU9iR+5rBMIgoKgImgIOoAj1WSAgODoxCMsJJryOkBBUBEcXxq+CDqAtCEICB6qLLoCHimvE2QEgqAgqAgagg4ga48mBQlBRiAICoIKQNXluDIrmsuajwCYaDnXfESCRMu5DlAQKFtV0BBov2mrVUNOEBDo96hVqYacICMQBAVBRdAQHC2IanyHhgwQEEQECUFGcIycnii16uvZbyooX6Bhjzb9O2pVLSJICDICQXB8aVQTU6k5QUPQAajURG2BSs0JIgJtgQ6jSs0JBIG2QD9bpeYEDYG24LAqLQ6bj5CVaHHYfMSiRIvD5iMWJVocdoCM4Pg7RwxCNDN2gA5AdecEx985gkyi+a9fpqz5rwMUBBVBB3C4XkUdEEfK6wQZgRqFtuDIOxmgImgIOoDD9TpAQBARJATHJyTt61QRNAQdQNauygoCgoggITi+VN2OR2bsBAVBRdAQdABHNHmAgCAiOP5OUnM53CYD6Jfq+KjUnKADUKk5gX6pUqvUnCAhyAgEQUFwfGnWoT+iyQN0AEc0eYCAICJICDICQVAQ6Jcec07TZAcICCIC/VKdjSo1JxAEBcHxpSdBQ9ABHMekAQKCiCAhyAh0THWAVVBO0CcoKignCAgigv3v6GHsyJg9f8r8WebPOn+2+XP/q3qCO/Jnz59h/ozzZ5o/8/x5fJEO15EBuwP9N8c5Z4CIQPsnKcgIBEFBUBE0BB2A6ssJAoKIAFuQsAUJW5CwBQlbkLAFCVuQsQWqL0fMVrQi7ACCoCDQHv0iaAg6AN3KnCAgiAgSgoxAW5AVFAQVQUOgLTjERhNlBwgIIoIEQ6/KcwJBUBBUBA1BB1DR3iram25lNDCp+bQDFAT6d6oC/TtNQQegynOCgEC/VOejKs8JMgJBcLRAgySaT5s19Kb5tAN0ALrJOUFAEBEkBBmBICgIsAUPTVLX3pF0qz+PlNvz5/631aV2VJw9f6b5c/+r6ik8UnDPn2X+rPNnmz/7+PlQovNnmD/j/Jnmz/nXwvxrQfvxsFlNnM263Goh2awhP82iHSAjEATKdgyelovNuh3ScrEDJAQZgSAoCI6+1/CdZtEO0AHobuYEAUFEkBBkBPo9TUFBUBE0BNqCwy60quwA2gLta1UbPSdUVZsTZASCoCCoCBqCDkDV5gQBAbbgCA/pXv7ItR2/BX4/ZD1+/f9X+N3g90PTo37iscE5fwf4HeF3gt8Zfgv8LvC7wu8Gv+HvNvi7qi0aktME2qzxLC0omzVWoAVlB+gAVEFOcLBpoEqzabMGqjSbdoCGoE+g2bQDBATHaGjQSbNpB8gIBEFBUBE0BB2AHoY0PqfZtANEBAmBtqAqEARHCzRwoHVnB2gIOgDd7ZwgIIgIEoKjBRoZ0qTbAQqCiqAh6ADUPXOCgEB33vo7we8MvwV+F/hd529VnvYF9EtEQUagu6agoCCoCBqCDkBPSycICCKChEB7TM1BVUTXIC0yO0AHoCpygoAgIkgI9EubAkFQEFQE2oKuoAPQPcsJAoKIICHICI4W6AZea9Fm3Ys33c2coCHoAHQ3c4KAIMKYNhzthqOtu5kTFAQVQUPQAagWnQC0SFN0BxAEBYF+6TGrO2pRRy3qX1r0BY6/o75zTcQdQBBoj379NxUJGgJQwx6wBQFbELAFX1r0BTICQVAQYAsC/lEVGQ0qaYruABmBflxVUBBUBA2BmsthypqiO0BAEBFoC7qCx9+R41qWaCLuAA1BP8BhfJqIO0BAEBEkBBmBINAWqIXkiqAh6ABkQxAQRAQJgVLrkBQl0I4vAUFEkBBkBIJAP0GHpFQEDUEHUDcEAUFEkBBoC3QYqyAoCCqChqADaBsMcAsIIoKEQG20KGjQo60D6BuCgECp1fg6dmIvCCqC4+9orEZzcRUUzcUd4Pg7R6SkaC6uEhTNxR0gIxAEBUFF0BB0AGFDEBBgCwL+UVWK45hSttAQdAC6azmBflxUMM8sRZNsBygIjk84AipFk2wH6ACSdmJWEIAATk1lg1NT2RK2IGELErbg69T0BRqCDuDr1PQFsAUZ/6gqRdBOVKU4QUOgH1cPoEpxgoAgIjgs5Ij8FE2yHUAQFATaAh0fFZSoDVVBOUFEcPydqDaqgnICQVAQVAQNQQegghLVQlRQThARJAQZgSAoCCoAVYqo5tKUQDu+CYKCoCJoCDoAlY2oQ6KycYKIICHICARBQVARaAt0GFVQFGiS7QABQUSQEOQ5wJpkO0BBUBGojZYDqFJoj2qS7QAZgSBQ6q4AOlGTbAcICI6/k7QFxz5kgIzg+DvH1r1oku0gqAgaAmxBwhYkbEGKCBKCjEAQYAsS/lHdehyBtaK1aNWbWzTJdoCMQBA0ACoOSbtXxeEEyqZ/VCUg6cjpRD9CBkVrxA6QEGgL1Fx0op+gIKjwd3Sin/+mA9CJfoKA4DiBqQxqjdgBMgJBgH2g+4Ovz9b9wQmwd47ENV3Ei2bCaiisaCasxoSKZsIO0BB0ADrrTxAQRARHj2Y1S531JxAE2gI1Cp31WT9OZ33WT9BZfzi+i1aC/dpGaCXYASKCR7+pf6Bowqwc3umiCbNyeKeLJswO0AHoZuEEAUFEkBDolzYFgqAg0BZ0BUcLRBuq4nA4sYsmzMqRgVK0EmxuX/8mIkgIHl6CXJT6iO4M0BDo3zm6N6oEnOD4UtGuUgk4QUJwfKnoZ6sEnKAgOL5Ut0WaPTtAB6CHlBMEBEcLivaBKsUJMgJBUBBUBA1BB6Aacnhiy5EjG9QRWDQTVor2jnQAuo04wdHqojaq6nICbbX2m6rLCQSBtlr7TdXlBA1BB6DqcoKAICLQFqjx6TbiBIKgIKgIGoIOvaOnjy+r0tPHCTICQXD8nZOgImgIOoAjRpy/evSIEQ8QESQEGYEgKAjqBFojVg5/btEasQNEBAnB8aWHM7RojdgBCoKK4JiNOueOGrEDHBWXBggIIoKEICMQBNqjSUEHoOpyAv1S/W9063GChEC/VLtKtx4n0C8tCiqChkBbcJil5tUOEBBEBAlBRiAItAVNQUXQEHQAqjsnCAiOvtZl6kiyDZq+UY6CsUGjyuUoGDtBQ9ABHH7YAQKCiOAYU123ta7sAIKgIDhaoHuXI/12gg7guAY0QEAQESQEGYEgOP5O1A5RRTpuSBRNsh0gIIgIEoKMQBAcY6qLuObiDtAQdABHeEcTynYQEEQECUFGIAgKgoqgAdCdkK7Bmos7QEJwfGnT0dad0AkKAv1SnZq6EzqBfukx9JqLO0BAoC0QBQlBRiAICoKKoCHQFhxDrym7AwQEEUFCkBGoVQUFYFU5gFXluCEICCKChCAjEARgVZqyO0BDAFZ1pOyeo32k7E4QESQEGYEgKAgqgi+r+sc/fv+7X//yxz/87U9/+fO//+23X3753b/8z/gH//27f/nX//ndX//w2y9//tvv/uXPf//119//7v/+4de/H/9P//3XP/z5+L9/+8Nv+7/dm//Ln/9z/7874X/96ddfHr/+8fv5X2/X/+nDD/v1X+8HoTYI9oPqN4pwTdEewYSDoac8CXr6RhBJG7aHj1DbsHtaLinIZ/Q8vmL3J15+Rb5myIMhQxNq/fbfy/V/f9y8Pf77XRtmA2oxj8SWT4awuyMuv4EO5sP59TWYBQYzfP+Mdk2hwY+D4uHlhlaYKR7v+p5dsQfrJ0X6bpWBfMlRFOSrN2UytGJmKOGcFfsqORj2Xcd3BmaWh5tTe3N3MV5zJGYVcfRFqemSg3Vnl230RcvX3UmMU0uO66jue63JIfk7R1kdEvoh/fyQx6N11x9COB5pil8cj0zCwVHkO0Vnw9rHJNkP3lcUkdhWreegNlS8ms0MLZ+fsYfSrxmIde6OjDGku2oOjvzdsCIxzvY47Gkjer1uBBHNdDxkr0axd+Y079bvjUe9HA9qFXU7F5BHOtzlkFame4/d15fu5XBJ0ZbHtC+PadpWxzSR5bwfb//oeh7jNO/9fGL/kPA4RHx9iITLDyHGedRkVsvaLgm4VPQyjCKkqxFNsq7ejCMfNfJU9faD3KXqpUpXojimCPTG7of7zsG6o50jsgfKgEHshnFkuqphCMyyZ8PIbJ927M+/OHoBwfj+JZm0I879xe7bmhzljTEZsyTjEvA8JpnY5+6nP3tjd7/DgvjUo5nI577j7oOk1IIt+b7dyrJuHbmsWgf/lj52XPvvkq6/hW0/j9fFv4SjdWhJ+87RV+2DWqlRAml/1KM8kvZH3c/Kl/0hkS2wdWz+9mDQ7I8nIRSmpEflnq/NX4VFun9fFIQt9C2N403L5ZqDbUJrPzli29o1B7HTPew1NgsthWsOpqZxHrQizrlmNxCjFEpfl8KyrZo6H9gWx7YeTs7PHVqYkca5TD5E55IjrQ9sycsDy7ojy9jE5d1NfN2M4tAd1aE72np3MOnIY9rvEbfrZlRio49y/cOzApL+Y8qydhzh0q/deSftIFZa4mjHI4JzyfGOqJdLUa95eZtf2Zpfy9ZGQ2pu1w0prEtiGF3ybQ/zxEEs9fGi8jm8AQ5Ob3WI7bhQ++JxgX5HHYPyqPJ8+R2NeUK34Z1oW5l7/fTUjhapb+Ec2NqCXHMwr9Pw9qCJRvnuTm10RPqYcBEWuB8cxEaPZCg9f6XtHkMfu1LoiWcGauGzKx4e+etRpQfJMSKPG4j3OOrwfe0/wz2OFgdHi9cc9NTSt5Mjbq1enlo68zy1NOSrleuTT0/MNoZT81H0CjiKneOo7qUcPdRrDoezU18+O1E137fD8zCJCvg8tn35hM9Htg7nfw/5nnUc7019cRDrCFtgZpqGfey/4TBZ3mjI8NKmFBppCJsv0wP0OKADyZPjfMs0IJJGQAS9cu+QPJ6kGevTFghJWTf3sNXP2rvM4d1n8fVqGzbmOQ5tNCUEPL08fU1YPkIxQ9sDKuNsnFq4NWtSGruPlPN2bawhfXbWpDx22qkQCQg03HSUoNI+Ld98nk/uWxZvasdzOl9Rlib3SHop5+fscsBImsOsYWEO46xhO9Q+wuSPMvvXcyY6bFFDdNijhri8SQ3RYZd63ARf26ZyCtM+9cVCM3cAvW3X8s4iUPspf6y9DbMQfpB0uhkZS16L6MZ9yghJn1XVGendYy/bPVUt81RYY7wWMxaIssW9aTNg/e+xkGawNfN4p1iHJSVcZdIbJD3Xuf3fCEllmirnetcL+sieZz8LR/Wx0+ywrUrS3mlHm+3oRMqYJzf0OjxcG2j7c0vodqYfb4Gd6+63Y9WTNOe4ukLQubvHLcbXREwAep67PJJTRxBm/9371bYq0y3A8JDHskXSksIcZXH6hQpZZ3J1WPFYXMq84rHAlHHFk81hxZOwvOJRCptnhp0ijrmgrQj5OlrIJ16Pc9XsQiYeDUylOrarqPE7eCIpqyseb0ceEdSIh4Af7aB77zISER8Bt+sdL4tN7evEcPFs4Fp5zslhsal5osnbdSZKKCzSH8MQkVgxDvvUqyw6tZ/+Bsvjd76MtNGlU19J/hqcQNZfGqGyniSKLK8TVJ3byDtI4dsp70mdWYyq5jH5as5wHtnkDZI6RLFiUPgnCVv2phztuyQIqDxLGotT7bp+SmvtqRISYrG1j8HZnTTlep1gkSqRsf4+qnVOEvtJIM2Vc491kZMAC8sc5TKGuXY4UDxZK9PotM09+Pd589ySwmKIWx8xxA771uf8VbbiWEWttmVRo5Eqq6i1zUXUmA7s8ekxOPFbWOJJB1jEKs4pvMcDyHmAhazMuzQWtTLv0ljQybhLa8Vhl9bq8i6NUtj8EtXDX9Q3h3HpYXlcaEjAOi48dGUaF0phG5fE94ptZkSQkzyPXM3IZhciq91BVvu6rHYHWY3b/4KsHg9RnxGBaxda3JixprHmRQwrPE+auDnIatwcZDVuy7IaNwdZjduyrHIK2/SlO9Y6P6VBO543m5GFrnYvzojm7/YYO6FxkPgYHEICMSyHBGJwCAnEsBwS4BRGG2GOqzKys9q3Te/T0Siy2FVKM64I3uvnQWGBqzocCo+SrpOjPAkru++UtuHv3WWtXJLwDonjY9q3lLfnDmGxq33jNsIbGDLep+sTSWKhuPRPDOQnRV4/s0YWeLKeWY+M1NUza2T3p2xnVtoOsw4xD7hZh1j0yqhD7LKMWYdSXNYhSmHSIW6p1rWKRp7sa1XysJFUPWykrdtId7ARFsAy2gilMNoI22eO9MaORQSeBZGlJlrdCJHFrsz2wbbvZvtgsSujfbDIld0+2rp9tHX7YKturSNTq6MX8NlCWNAphbEh2rc1QkgcvFVRPI5V4nGskvVjlXgcq2T9WCUOxyq2Q6x9XH9uNVzvEGngqgySVCNZ71joKhwP+30td5h4tj25AApNYR035tIWZkv2mM0TCb3+14YfIUPZhfR8tZ0FrmKBjD68xPPsXWGLxPyaEDAb53n6sstVZq9IcUgJiMUhJSCW5ZSAWB1SAmJdTgngFLZVggp8nlGr3MgqQS8TWS2ERa3MFsKiVmYLYVErq4U0Dwvp6xbSly2Ei9koOPJ4muZazOgVK+uBlwWsjAde1g6zkTWPzWpb36w2j81qW9+stvXNKr3PvOUZFYXctR/LbvfwqnYPr2pf96p2D69qX/eqdvns4MaZjIs3z34OLjOyLQ8H4FbRifjGNrNKH9tMKMvwvM1MG60jNTyikP32rIaJ3bWSkZIkHcNm9YnCwUzTtmymaXMw07QtmymnMJops46WhnV0ah1tXYPS5uBRTWHZo5qCg0c1hWWPKqewHVPphWIZlalKuaw1Rhj2rc+oVtkKRv+fikrRgn6hzSj1hiTxDZI0C9R8ux/xg4ResDKV5EuBm+lp6qQmH6WwFXBL7HqVtYIb85UZS7jRu1XGunz2UalkVIzmkbdy18a2eSwM1ynNKfIaaqZqnommVVoLwtHPqTMm29jn0Dp/caSY7D9h3j2l7rwgGXeKWiRplSnF9cnL7lgZJy+jME5emlNlnLw0QGWbvCw8ZZ685lEhk5eaRxoVc/bdSLs2DxZcMhbWTKzin3Fs83q51JSX66UmFp+yVpbjJMbqY4nFp6zlxxKNUNlKMXIj24aQpXRXyMooINRauK5vnIRWz86zpBLWJ37uESbuOYyrgPtSRTZV4iCpsi6psi6p4iCpsi6p4iGp4iCp3DxGTbb88GpfmkfZ1s2DxaeM5lHWVZm6c43mwUJTRvNgN6rM5mEeldvmAeqB8ct39pc5DGXPeFD+aWPMV28rtJ6qg53WdTut63ZaHey0rttp9bDT6mCn3DpWPRgSZsn2INePASQWUCplZJWUVsmyz65S9Xl3f8MzUDO/3FGPq1rqIYuwcZDw1ApaAGiUd9p3QZPjMYG/kzAzjWXegYCnIp5eMUm08t823NLx8ejHJQex0zLMtED1gNCfZkujIjaqSuIFih8UrBVjb1rRu/WDgp3326ghnzqkguz/0RMJLVMFD7uAs+5xpPpGwq5QQYLdt9qlzxREB2cxlAqXbH5Q8Hlf57xvN7XD9lhDovGovM0wMLhQfnDI+urUy/LqxCiMqxOLRllXJ3Z9yrY6ZRaLMq9O5lEhqxO1jjQSuCKGG97ikDgrDqfL1yMyC0dJFxmhtdJvcoyKLozjxWwxuWDyVlctnVLYLD1v6++KZFrwz1IpmLfCNt9yWHbyZ3Zb6vGU94hE5e1yvr1BIjdJ8nDQP57uIyRldVz4t4yA1uMV7JvfEse24fFi8F2Scd2poGP9PZI0/FGPVzKvSVhAKmwzBvz4HS69hZTG/CIGJxkJoH0PxN0kmTUueyrlJon1KZvo4EHNcdmDytsx60L3BkeHn+2wkuAm9T2SsdDsP8s9kv1gOA6X++/KaNgQyxC2jhuJN42tTWPDefweSemT5HoCvrGGX/pjMotN1XE6rJX42uj+3/SmVmYXp6zuKU6Sx7fk3K8dZTnzIpWjXGbN11+Tw/IpIue4vLdiFMa9VV5/lSKzm1PGXQ29N2U8RdhHpZJRodYxEuNibfkWR5q2vi949S7HtsyR5uYKdew9jjI9VO2aQ9L6iYhzmE5E/FvyNLJc2jrHTRtLscOFh+uxFZamU2Zh2BrZrOPJqLNSbrmWwrKtDy7ncBjcGua3kIlLn6PaRknIECDN781Onde3GrEyGpoyVcbJ7MpU6DK+pVdyOmPtyDMwhU/7PbeDrtky8p6ykKrwmRZOsXn+skNcKq/HpfJ6XCo7xKXyelwqe8SlskNciluHzfPHOYyeP37TySZj3NJtXru2bqVt3UppWMrotaNhKZN3qDnMlbacipLZPak3HDKMxnqo5CTWMzIlsbqGOInRNcT7xOgaoiRW1xA7rZtdQ12WXUO0HVbXkJmEuYY4idE1xEjecA1xOzF6dezyfLm5E3pvyuKQ4Xuq+QxkrrXcdKbIeAMhC3GmyMZLW5vy64VV+LPm19PPwdSSSN78ka15fE7/9OfEBneWyOewy1PrliZl7N6lSifNYHXTxpNOOeLj3s8UeVUVeSsGA55lfraCpafMUnQ5wpam2CnC1sqoibO1lu+R9AbpS3AB6x2SR6XTcdrdIJT4TqeO6/C5k6FljnIHir0jxw2//bdcfsoLEtvIcBLjyFAS48jwmVvnjcWYiYDQ61PGV6GEvk9lm7u0HdPJFHrPpB2UZIQx4hbDTZKW5lOq37r1iYRf0zEuM/SFKuMyQz/H+nSQ0Cp/pY6L8ftvuXqB8BWJ6f0hYZeorO8PSaKJVbb3h4RV+bNewpbsUEFd8nIFdckOFdQlL1dQ5xSmS9jcQoxvoAiLVlnfQOEkxjdQhBXps9aTFfZClbWerLB7VNbyOkIfmDKV16EDbH3cQsShKqWIQ1VKEYdCPyLLhX5EHAr9iCwX+uEUNglglmoelxc3qWzjQqvS2MaF3qWyjgu7TGUcF0qxLs3W9xOEFfmz1oGT0jwsxKGCitTlCipSHSqoSF2uoMIpbBZCVztjTWqpLjWppTrUpJZaPWykrduIQ01qacs1qTmF0UZosMb2foI0+vqv4f0EYZEr6/sJQh+lMr6fwDvE+H6C0PiV8f0EYfeqbO8nSHN480+6w5t/0h3e/JO+/OafeFQclO5QlFr6clFq6Q5FqaUvF6XmFDYdag5v/ZTN5a2fsjnYSPEo91fWy/0Vj3J/Zb3cX1kv90cF0fZ+Qtna+km1bA7OqhIcnFUlLDurSnBwVpWw7KziFEb7YKuu8f2Ewgv+2d5PKKE6mFloHmbmcKwqcflYVaLDsarE5WMVp3DYMhvfTyjsUSrr+wmF3gIyvp9QaEzD+H5CoUEr4/sJhT1LZX0/gS4SxvcTCn2XyugVKcmhcHl5UfPPNn1TXp6+tOqfdfqyq1XG6UspTNOXC7zx/YRCX6WyWkh28KyW7OBZLXnZs1qyg2e15GXPKqewWQgXM9v7CYVV/bMeeAt9VMp04KXtMBuZeGxWZX2zKh6bVVnfrEpaNzLmvje+n1CkeAxu9Rjctj64Dl7VUpa9qpzCYXCN7ycUFqsyvp/At5nG9xMKu9Zkez+hsOtVtvcTSvEw07JupsXDTOu6mVYHM2XWYXw/oVSHZ/5KdfColrrsUS21eAxuXR/cdY8q06Bcx1WxjB7Vt/L3cg11klwnvJVGL5rb8vcKrf3nkSb+rQZPuq4q/4JkZM3t68h2k6SOTMLdIOUmSRmWtvfd9WXR0qrH6LRPj85caEor5HM6LVDd07wi2fNVYuQrkqFH++8eL0mIxe5/4RzimkMnn8Myxss4aOZCXh8o9EpQHx0bt3B5g7705TvWhYarYpiVN2u+9O8UFmt6ZHuP7NlH5vekaW/RyDSTIBBP+HFLiplsLaPuRC1Y/f9pjOu2XmKlbuslVuq2XGKFUtguwtZtvcRK3ZZLrNTNocSKfVQqGZX1Eit1Wy+x8opjW+awVdCo/GkpuDYu9/rUWOrlBYep1EsNNChqqgbygsN0jZ5/Sx6rTMLahD/a0T7dDlPJGTvHzTlnLDlT6WvuxpIzL4zdaCDxwwNjKxdTec06W7mYFw0xlYup9IEq01amslCVtVwMbYetXMyrjWqdu/fe2sVGtdL7VcbdLiWxXfbk29Q6XKL7z2tDTesFq2taLlhNKYz7oLResLqm5YLVNTsUrLaPyrUmvzjEjDU79H69d8jrZdH4KcYYpeYkdRjI/jPcIwnbJjNOlW+2RNIs0VDuH8pamYcyWDHfPZSNL3oc0AqhYZ90FE//6hcMvb3VL3kkE8UMk+cniawrPD8ObVMG2q2pE0MYJhvI6i3L5/8qDjXWaDusXUqHdr4AktFZ9Z7JhzgzTUK67YeIefohYrk9c+LYoD0oycxhGfQj2lwhzfv5TtKLW8kjBa/Uy/v8ld2Nsl5tpiTG2hP0gpX1xviLVXxO33DzdrQ1l6C+eKxqhCUK1mz/3g56sXleFo0xx+u4BCWpYdY3IPGRWj9NEsr0fJfabpLU8f7n7mSJhITNu+Gfrbnco+j51EVMjn6LImxxzLutCCFhh5o2BbqBmYX+Rp/24Y4IPTI7KyyaMB866OHmrfNQS5qn+JKu66Xxy+tlXl7Hd4We21IbfUBiBHtgnxbTW+0YVrK3o5F2MDOpaZTCehzZ0mWfVFYmMMxno/agK5Zda08fRO/iD4fi/seuI9gvrtGPsi37kbFcKSOlKKPEwf4z36Mw6TO93WzVZ0pildb+aRKzPlMSqz73sqzPjMKoz/y8Z9Rn9oaVVZ9pn1r1maVaWDc1jcWbjJOGXua1ThpKYrT3tsmHSayThpMYJ01jd61sk4ZS2CYNpbBOmsbuWRknDe9T66Thd3GN6x2/Rmta7yiFbb3r61OXJxQYpy53xRlnXegfJjFPXUpinbosdmWcuozCOHVpBM06dVmOo3Xq0j41Tl16q9i83sW2Omn4hWDjpOEkVnun16w8SMyThpJYJw27ZmWcNIzCOGlSdpg0zPVlnTS0T63rXWumMy+WOHq6qtVYACvP2zw5gV/zZ2kRWukYCgvUQFrCnFYjcJTC7I/6NC40fhVmHn2Ab3m+V/CiGSO3AbLn6vPsd/BHtlyWpSw4+CM5iVWFcv8wiVnKssf6L+vrv6yv/+Kx/ovD+p/7h6UsbAm+plxLCK3nF+aFwLiFSzGjN5PN05fekrJNX3qp2Dp9k8eh2cPnRUnM07c4uKtaWXZXUQrj9C0O7qpW1t1VvE+t23d6bXwbZbnT1q7rgjQW2Mjb8HnnkOP19OUVSgSSeTtpCdusWt46oOVJzCpS1zcBtLKIVUWix1HExQlYPTYB1WMT0NY3AW19E9A8NgHNYRNQ+6dVZN5RTHkj5whaGLCNYiu5p3StItmhAHXr65uA7BCz4iTWmdc/TWKevh4xq7Yes2rrMavmEbNqDjGr5hGz4gWX0kgJCqlitdTv5+/OYlZ5ZDlnGNtHXp6ZQsbqjdm071GMRC2Bl8beoijjCakCdaNuU8hNitEX5W5flNEX5W5f1PEh9W5fIMXNvsBd3c2+mAl89W5ftPEh7W5fIMXNvmhlUNS7rRj1hFu72Yo+/Ib9bl8gxd1WtFOEO5EcXpzNmrFOSYw3gDu/WNXn6iiMhN6rrv9EhH8UJIn8HV1bmjm9SGTN4actsebw81pTlqgwpzBFhV9QmHaU4uEVFgevcE+fJrHuKDmJcUfZ03KWKqWw7SgphXVH2dN6lirvU+uOUhyyoHoO65Ome0waBwdIz/nDJOZJQ0msk4bWAbRNmlyXJ02uDpOGVQG0Thrap+ZjGC2vJvBolVyGQTur4ZfCBnFQdOg+cVALKdNCGl6LeuIQdn4p4/witxjqlv7Z2eMthmGk8bINL4rVxXFRfcODw3NvsmO+jLvduWQPjn7FYa7el7brisidPVYVZqmpkLFy1tPHsE4t27iJXEKo1xzMRHfbhjuVW/Ng+VZc/R33SZ99wupV01KC03HRw+XOvZe2vPkvHutl8Vgva/gwiXm9rA5ZVL0uZ1FRCuN6WR2yqHpdz6LifWpeL2mdx+FCSI28itIbrasyJg0+Ffvs+WSFANOoiJIjOkOePoVVmzTvl9lNKuN+uTqkHnMS69RtnyYxz39KYp3/7CEg4/xnFMb537rD/GcZ7tb5T/vUmnpkfsU3Xb/i21ktg9BG7YzdcdiucgboG6/m2Utfm7JdHJC6Pns5iXHi7S6+7dMs1vn7gsU4gXeWtDqDOYdtCnMO6xzeWcryJH7RsdZZXBwSbvamrJcBqA4ZN+Kxbd03GPHTLPbZE6LH7AmyPnuCrM+eIB6zJzSH2RPih9fAlKCkH6bePZfDpvciwqwqEuT6zWXtvM+ylDauE5S+XVVaecExayWXXsJNjjrb0a85qMEOX0mPt41+XI3AUva3Jw7h4LqWhjcuJvCTvEcS53NaaWNSkoLD5KPXeMIo7787gdrNpoR5cSWEJndZwH+U+u22SJwlE3O9zVJmSbvWb3/RlLYU6Rct37TmHNY1IznctQ5b/rjZpjxOK0nq3U4x6hLlMOqScXAoB91SG7+Fchi/xbi1ZxpLT15WjeVnQKvGioexiovGiovGiovGiovGiovGiovGioPGioPGiovGlo+brVljxUFjxUFjZVljuePR9CmcwvQlVvcnoeCOaaPAvnCRWwW2elhqdRHY6iKw1UVgq4vAVheBrS4CWx0EtjoIbHUR2PZxszULbHUQ2OogsHVdYGlk1yawlMImsMb4MhPY0h0ElucgWAW2e1hqdxHY7iKw3UVgu4vAdheB7S4C2x0EtjsIbPcQ2LB93GzNAtsdBLY7CGxfF1iaamoTWEphE1hjwisTWPEQWPEQ2OBQPJCTmAX2BYtRYDmLVWA5i1VgX7AYBfbFFxkFNoR1gaUcRoGlHHaBjR83W6vA8k6xCSznsAmsdXCYtKXlSBensAlsknWBjR4CGz0E1iPOFVziXMElzhVc4lzBJc4VXOJcwSXOFRziXMEhzhVc4lwhf9xszQLrEOcKDnGusB7nenGBdJR7lAIPv7xFMR9dxKcWnijojVzrE0OcxPYEFa/hYRpaTmEaWWslETqwyWHB4dVmrAuOQ01BTmJfcDiLdcGhLOYFh7KYFxzOYl1w+BdZF5wS1xecEtcXnOJQBGtn+bjZmhcc2inGBYdyGBcc4+AwaWvLn8IpbALblj+E18CzCmz0yFwL1cNSq4vAVheBrS4CW10EtroIbHUR2OYgsM1BYJuLwLaPm61ZYJuDwDYHgV3XJV6K1iawZX0HW9Z3sLRUsVVgedFkq8B2D0vtLgLbXQS2uwhsdxHY7iKw3UNg47YusJTDKLCUwyywcfu42VoFlneKTWA5h01grYPDpE3Wd7CyvoOV9R1s8PBJBw+fdAwOlkpJzAL7gsUosJzFKrCcxSqwL1iMAvvii6wCGx0ENjoIbHQR2PhxszULbHQQ2OggsHFdYNNy2hqnsAlsWk9bo89+WQWWP0BmFdjkYanJRWCTi8AmF4FNLgKbXAQ2uQhsdhDY7CCw2UVg88fN1iyw2UFgs4PA5nWBXV8r2vpS0dZXCv4YqfVmW/e4eBE9glzRJcgVXYJc0SXIFV2CXNElyBVdglzRIcgVHYJc0SXIFcvHzdYssA5BrugQ5IrFQZfialbFCwpLVoUw/3oK/eyNlL5VsnwqNhFpCblh7nNg85PMb8vJMpzCtthsy6ky/NF6c6kKjxzpWLvDrKUvNJkXG85iXWwoi3mxoSzmxYazWBcb/kXWxaaV9cWmlfXFpjm8SxRi+7jZmhebVtYXm1bWF5u2HCer6ylrdT1lra6nrElxSFnjJGaB7R6W2l0EtrsIbHcR2O4isN1FYLuHwKZtXWAph1FgKYdZYNP2cbO1CizvFJvAcg6bwFoHh9bPCcu7eU5h2c3XunwVhlPYZL4uX4WR7BB25CRWmU8el7YoiVnmX7AYZZ6zWGWes1hl/gWLUeZffJFV5uP6VRjKYZX56HEVJqWPm61Z5uP6VRjOYZT5uH6+5zNwi2PyhC1Niy1vkeQ0Scp2QbIPcKMsIU+WfI8lx1k4NcpVqVFhDzCb++QFibFPaEDJ3CeMxdYnudPHLuBztg1eDk3tPZpUgCZd0gitlb0FmTQBXqd/i8ZWHpdTmKrjvqCwFMfN9NEc++i8oDGOTqaP3plHh9LYRodTmEbnBYVpdAJ7oimNp1X2n/AUWetvkMTxPsNOUi5JEnvQPebxfmfMYe7I90X5u5qwihch97nFgYX4B0lhT8uPV6saPjZR8xscbbw222Bs/wkH21JvI1wQA3Trc738xNwvrZwm0nplDcksbjHOW2nv1svxfWNs6uXYcCNJvU0jKfc4jv2CckhKxEbYHds+z4+99Lsk40kSRpLYLWybsab8YuHbprQmfJVM7DQ9jePFLm13SWS8zdDRSN4jieMRvb7H3O5+jox3q1MphIQ5O9o4uPUm12uWnQQ2a2+StDRIWiEktE/a7JO+kT6hQt/ma89wPP8xdVh9Qnwp/lIZU6IKHcYD698eOJRnaWRPce0T7WTZfxIdaNlh1WLBZeuqxTisq1arDqtWa+urFgtu2Vct89hUNjbMSo5n5ZSkd7Lk0AQE22rxqiXD8RI3eJLzZ0vYfmCMcN7Y6NBbLMaH43lL8vS7lMTsJFGD3abBtnv9Go/CS18kjexemaPf2K+ZP9UkbZhaDcTqabjN1K9cX8vokVZivtRXumrZD4+vaIyHxxc01sNjyNv/Ao/xCR3OYXtC5wWH6QkdWrKmzohOu1RZ9uqx9fyY6VNNxpWYHoeNKzHlMK7Emd1jsa7EmfkKjStxDtVhJbaPTb1nI7bjI6Uwnh4zc0pbT48vSEz7ARqFsR0eg8vZMTgc2ML6eY0dTazHNTMHOa1xDtthLbv4oWmvGs/jvCVWG6F9YnQvUA6Hr7HaKv8Wm60yd5rVVs0cxFY5h81WqWvQ7pXf1r0TfBdhc05kVqXN5pxglwBmBsO+wk+K/R8/N4Olm6c0083xW97hyCM3ZA/jXW8PWTlsW4iP9sc2zGPfaATWH9QBPZ9JlTD7Y++mJxZh78iXODYzBU8STyz0MU9Tr7JQcokj4hIhkyOJnWHsMAtmYDwzVJZPMr4iCL5rmoqdI8e5qYvpkmMfE/rK+BTU/TccWZ/UIy8HopmrqEgcAfEi6FNM9flr+vq8pRzGeUsf2bL1CDuBtOFj3X/GK4ayaueUwWTnWdbtnHKY7bxUBzsn8z7GbZyB9t/QkmbnkNGpUYRwsNlSt+E12DV962S2sEeGrLOFchhnC7uW5aAf33sEvLPPPcLq0OyH7T4P2/NUF5/2H3aOts4BlvqDg+l6bUNQawcncc92jqNqj3I0dD68xdEGRwcb+8HBtXAkyLaY73LkySHrHPDk/DNH5Xch23DX1X7JQbXMOLaUwzi2nMM2tqy4XtoF8bT1KH2dA+bLexzjjJxilXscabiV9l/bPY48hGxfsG72Rypjn53wrH6bo9zkgEu7/aZ95JG0mXK6ObZ5hDD2n/Umx9CglOXu2JYwOEq9OefGuITGxpZy9LkV2sLduT+DZVtc5wi321EnR7nH0ecdgZ7rejuYFiYHXU8Oup4cdD066Hp00PXooOvRQdfjuq5X4j/ZNSON2HLLt/YfudezP3JvZB9E96d1G/vTdr0/fbiK1mNsEuiBfxuSmvDWxg+WyNJWpZ4sVWDihfZMQk9CYao7eLdDfSZhXbvN49SGof8fJGz+hi3PC1h4N+fHB/G+FdgCVDbMlKXPEerXxkILY9ckQ10rhh+fj3ecRbbJIjldH5uF3s8ZM2h3uMM475GVb01hft25I8m4I/nxOYRD0lgtJPXrLmHJYlK3wVEhDeItjj52NdIhHem9oalDDPZVcNtusrQ8vQBNrvukL/uH+7J/OGz0pnyHG0K77+rKsSL0UaVdWM+wTrx2zrzgGKbaY7lyRNJhaXV+S6vt5uxtfWRF7b+Zi5jetjU6vTiHzekl607zN3okt9v9WieL5Lss0idL7Wx0msPotPXRYaEql9HBHmn99ujM817vN4Wxb3PN6iEKcRjHVWXkFCZp5N8idahJL3kjliZ1NcDCOfZla5s57BVT595imf7N/XeUuyzzEnTFq9Rv2GyvM92kM6XmD0X1Pixl/y31Hk2MY+cYE2T1xtRvkoR4k0TGlewokFT4Fsn+CUPaNjw1PZFknis9okcx4TR+moPCLk+Zo/lH1YPVaD79nnkPOm6ZfU9dvdHS0/qnMA6ZsvS0lS52jjrkUaqES469O9aTVziHcQ2ty8krvD9Gwpi01Fl/dLbmjJBLyS0RlraxtozFL2zXB2raEBn7tSJpu/s5MrxieyxJ7rOM7ylbv88SB8u3qOvTIBNTkzamr3TGsZzr0JdzHbpDrkP3yHWQvq3nOgRWqz/n4V7IuaOB5OemOJy2usNpqy+ftniHyLDTLLWxDikOHVIcOqR9tkNmLbFc8KrFc4cUduvK2CGcw9YhZVuupkLttI/VKm8hX25mOMdI/dg5yvWGqGzisMEr7G6SdVcUEitwEWaRDGENaS6f0z0+h9ajH2P8eNoAxuepwlMJLFQw7rSiR7y9047SZbgFynbdjuSQE0dJ+pTF/aQHga0ft5YZyTE1lQT3Ee+SjCsKBa9K/Lw/TfoEb00WvCvxtNOj9/S3sR/ZjzXpmoR+Tk3nbrFXzDh4q0/a7NiG4fFnEvq0rw/Lt4u+qVz3yotnhsdFlBixW36ysITBMFMP9vD/XZYZ29rtId9lyeOi4C5vwljYactYSO/FQ9ClDm9JY53rcO+fveVgdDVSClsUhn6JcUv/ojuMe/rCnvAya3WnPkJbyY2SinF4yUXfwnTJeNGXchgv+pbU15MQSqb39U0XfQsrRmS+6GsfGzL1qJEYK24UFt2yVtxglRRiGRq9/8TrguUNkulS23+GeyTmihu0JZLm/bhyTRJpjYqwtTJTOxpsldpbNDJqF+y/IU/9XZrRMQ9KUo2B9kzqs3txe/FW9+Y6lq4M0/AnCTsV24qidF7Ex1QThXIYS6IUFhAylkQ58tFJsM1WEoW2xNqrdHTHKWMf6HR38oR5yywEWHjetPqY5+SJ5fYcjCMC+aAkk4duc8CPm+7ulEYdE9ClnxR8KzzaEb7lnL+5FR43rAI6cha25YyFH7/qLMOMiZI/tgbVwbtVHbxbNX6Ww+gy5J06csX2/s2sU2W5IZRjD/bMC6cbs1fKUmZ2Rkn9LkuTYa94dHuTpdcZS93CTRaz64K3ZYZkHxkNhKVFj0M6ZTEf0imL+ZDeHJ4ofNG5faZ9hXC7W6yCzbvFKtjmIWIswcHT3IOHp5k68a2eZlY9qvbh56odTeUdklaHJrT+LaHgDZIexnWQHvCA+7NT1gNfvCEyX2iQfvNr4hD+HntnX9M/+zVpbjDSt8S+p4YcOWafbEhu8zWQjTYkLTeEc9h2KXVb3xwE+ogH7FLw9sQPO+vLHkxKYfNgsk8xezApidWDWVnQy+zBpOWOjB7MylYKqwfzSFtf9GBSDqMHs7LZa/VgVlZm0OjBrMxKzB5M+9gQDyY1EqMHszrUCAysDIzZg0lJrB7MEhw8mLQlRg9mKNHDg/mCxurBfEVj9WDSnrF6MCmJ1YPJXs8w+tqkr3swKYfRg1nTerHsmsTBg0lbYuxVPro2D+YLc7V6MF/QWD2Yr2isHky6zbF5MPlOyeTBZBtp4/Gx5uxwfKy0cKD1+MiS81IZV4ATduuP5LyNm/3IaEtBbpLkcQ8qf6/s9kxCdjm5xjYcJxvJNdzq8pacUhivdhaHLTklMW/JxSOpgL4DWdq87NO266GJdMs2yjrvWzbMnQzvkPRRx3yL4SZJG1egnq6khOee9SiYWYtDwczAayvWmdK2OxavB5m9alDHtjy3b1cXwjsk46bpTtJI1xYXkS0eIstMP86DRtpCJKbPSNro2rRFMn+qy52u6nGnK1SaNTUfRnhk5V89tBmaS4YCrX4r4z3WLBVXwafqt5XVJ4zHDvM8gZHzZHV4qYg+WW11OtT1l4pqdXipqNb1l4pq9XipyD42lY0NtZJha7GyIw8jSaHO0o+93ibZ1knqCEqmWojRs3jXNyeK3OzYBOny6Ch/k2RYW8LM1p+f4/B04QsSm2OJf07e+j/1lD+T9PDxlswZuMdIHUjuTsAU+ywV2IjZ0xt4pYyNaI1MlrjdWw1FPj08dValoqrE8x9ndd2A58CfWk2bMu7O7Gv4taU0Gu+y+YQau+pl9gnRlhh9Qi92SnXu2npr1zslmsrSITeh93iLxRg3qw7p5Y1f9rLtkxq762XcJ1EO4z6psZiXdZ/U2OtNxn1SC8lhn2QfGyrT68GZxoJeZmn0SC+vHunl1SO9vDqkl784dZmDM80nL7x65IVXj7zwup4XXh3ywqtDXnhj/gbrCvrCXWdcQaNDrzrkhb8wV3NUpbnkhb+isUZVXrj9huHvv/tlValGLxTtLBFY+i0W497CJSiSi3EOBpLTzd5kqn1Uem4buwzb2H0vKcO9JQVzfp9irOyWMd6Ehbvo+0rwBkkdGcy7m2u7JmnM2HxY9rPXNm2t3WWpdeYe98hY2CiP8FnFQM9bHD3PvLp2kyNsccw/rOT7k4WWMzTmHfOO7dssIhhJx7I66fuma1Qv6lg9dxM7ySO9fJ7SS7p+BpDS7AGCMcgV18LntjRxuD1DGzIsZW9IYw2hvZJmZcR9M5que6XRS19thNFCR5b2lI3NLq3UeaehNrDb/Gws9LEUGQ8T70fBciWS/L2VEfQVfEv7LQqTVLOMcLNUUxKzyLLAlw+LXaqLeEg1C31ZpZpxWKWahuDMUs2KGZqlusi6VEfmvLBvdJiPyzZ7IkuTtc4eTmK2e3oCc2Gxzx7ubrPOHnbcsM4exmGdPfTYY549LTnMHu6iMs6eKOsLYGRFXWwLIKcwLYAvKExTOAWHKUxJzJOvf5zFPoUpi3kKs+KG1inMOKxTmHHYp3B3KGTEO9Y6hVNxWAA7u+dvnT3dY/Z0B7vvW/o0i3n2cBbr7OksldI4eyiHcfZQDvPs6SxqZZ09vGPNC2AynYux6HJ5bggLfeU0S4ziE0S7/dgbEvI2jC3jE+g/m8L2jyNahGXk6/PYBBbQDyNDSAJ8TQrhrYaMLAcoMvrUkMgcOXZdY/e9jLrGnFtmXcseW/Iew6dZ7LoWPXYFPa7vCiiHVdeix66ge5Q35B3roWthS/A9hchJYruCMOIqEvFCw7OyFY9QRE/L/q1YHUIRnMQ8BZN8msU+kZOHf6undf8W5bBO5OTh3+rZwb/FO9Y6kYWlkm3zWeANH1L4MZHpO17b8JbngBWhnycybUoQSPvtrClsJ2t5ByVK8hCUvL4zYM/GmwWFkpilQMKnWeyCIi47A3HYGYjDzkBcdgbisTOQ8GlBSSOemPLGDhr0Bndr84XelK4FhV4UMU/k4rAzaB47g+YxBV0iX90l8tVdIl/dIfLVHSJf3SXy1T0iX90l8kWrZaSRbBRShSt52/NBvdKLz2HMY/ialt/gmI8rYL7tmxwjD0zwRb+3OObTCt9fv7rLIXc5Rn+U2/1RRn+U2/0x332st/sDOe72B2757vbHzBOst/ujjW9pt/sDOe72RxuVu1q93Y5Rl621u+3ow+XYb/cHctxuxyzdRzQoFho4t6W4c5IYRp5u5BXUaYJgn6umUBZ202W8cZG/FRWtb3yOMTOdkljT/nlLrFXlW1oOM1MKW5iZU5h2m83DodwcHMpx2/KnWay7zRcsxt3mzrKcEss5bLtNzmHdbe5u1fWU2Bcda91tdoc8q/171mdP98iz6i52H8qnWeyzh7KYZw8rUWWdPYzDOntC95g9MTrMHtqx5rMaK7YcZ52CCLdcnoOq+/ew6yVH1aczqoq+4GcSaihY9RzvVj2TsAT5UsYJR+5R1FFg6tvh5D2KYa3xuhXsKRU5+lv1aMNzxXOPsoyvLPNJTSy4tUDSL0m4lY1tVkpQI/mnlSX+vMW4kpWxANKPz2H3DbZxubkEfC/5Bwkz1d3I4Ybm1lxoQrjuXOpu6bNbsN7yk7slsev44OXo4XpXv7GHvGwng7Q5rKHJZ++Y06dZ7GtoTh5raC7ra2gu62toLh5raF5P1XrRseY1lNWZa8PVkBqURvyRq7wJfWNmzB54UOV5Eu8crE7BqL6SsRRae548zWM7zW512bbTKTjkPHMS8ySW9mkWuxRQFrMUsDXDKgWMwyoFvLC2VQqYF8csBfyxNuP9THbPOrbhYkt4E/65RuP+PeyI3kZ9jt3X2K5yEUJLHvOYVTQ0Xt5rDrkInMQ8A2v8NIt9HlMW8zymgWrjPGYc1nlMH1Uyz2NaJ8Q6j2nHWpf0zWX2tOUqBXHzyOTZXGZPy59msc+e5uKSbQ4u2ebgkm0uLtnu4ZJt+cOrYEpQShCT+p4rFTOSHGbVkyCJLKU9f5qltHF9ofTtqhbMC45Z1rf0Em5y1NmOfs1BDXabr4DdNvpxE6NXWZ84lIPpWhquupjAe/IeSRwJYzsfux69rd+c5SQhjOLpu2uo3WxKmPdkQmhylwW8SqnfbovEWaEx19ssZRbOg1pz737RlLYU2ReF5QvfnMO4ZlAO85pBX330MduUx3Hl4e272Sk2XeIcNl2yDg7VJbqlNmos5TBqrHFrX+XmycuosS/OgFaNjR7GGl00NrpobHTR2OiisdFFY6OLxiYHjU0OGptcNDZ93GzNGpscNDY5aGxy0FjqfjRqLOUwaqzRDUo4uJfaqLEv/OVWjc0exppdNDa7aGx20djsorHZRWOzi8aKg8aKg8aKi8bKx83WrLHioLHioLHioLE02mvUWMph1Fhj1JlpLE0KsGosT0+wamzxMNbiorHFRWOLi8YWF40tLhpbXDS2OmhsddDY6qKx9eNma9bY6qCx1UFjq4PG0qxUo8ZSDqPGGrNjGUd30NgXadRWjW0extpcNLa5aGxz0djmorHNRWObi8Z2B43tDhrbXTS2f9xszRrbHTS2O2hsd9DYzSHmtTnEvLb1mBe9XmXVWH7Ry6ix0SPmFV1iXtEl5hVdYl7RJeYVXWJe0SXmFR1iXtEh5hVdYl4xfNxsrRobHWJe0SHmFR1iXvz66ag1KQUeqXmLYj77iI9BPFHQ+7zGB41ekBjfvOKVQUxj+4LDNLbmCiVsbGkBGeuaw0vZWNcch0KGnMS+5nAW65pDWcxrDmUxrzmcxbrm8C+yrjkpr685Ka+vOcmhytbO8nGzNa85tFOMaw7lMK45xsGh2iZ5XWMlr2usLH8Lr7Zn1VjxyLOgJYHNxppdNDa7aGx20djsorHZRWOzi8aKg8aKg8aKi8bKx83WrLHioLHioLHioLHJYR+bHPaxyWEfu3nsYzcPjS0exlpcNLa4aGxx0djiorHFRWOLi8ZWB42tDhpbXTS2ftxszRpbHTS2OmhsddDY6LCPjQ772Li+j80e/uns4p9uHsbaXDS2uWhsc9HY5qKxzUVjm4vGdgeN7Q4a2100tn/cbM0a2x00tjtobHfQ2K2sa+xW1jV2W85l42+RWTWWv4pm1Ni0ORgrJTFr7AsWo8ZyFqvGcharxr5gMWrsiy8yamwK6xpLOYwaSznMGpvCx83WqrG8U2wayzlsGmsdHHpXbH29eMFh09i2vl7w11LNGutxJyN5xLySS8wrucS8kkvMK7nEvJJLzCu5xLySQ8wrOcS8kkvMK6WPm61ZYx1iXskh5pXWY14vXpM25VlwClOeRWQl73Y/whdFSt/KXz7lWSRW4mO84QeveeZnnW/b+nrTtvX1pq3nzwSP3OngkTudJDhMXPoklHm94SzW9UaCx3pDWczrDWexrjf8i6zrjbT19Uba+nojDg8gxVQ+brbm9Uba+nojbX29keWYWWgOeWzNIY+treexHevSqsZyErPGVg9jrS4aW100trpobHXR2OqisdVFY6uDxlYHja0uGts+brZmja0OGlsdNLau61KNq3v6FxSWPX1oua4rfa7rSp+Xb8nQy+9mpRePTI/kcaWLktiVvnvckuEsZqXvHrdkXrBYlb573JLJ2/otGcphVHrKYVb6vH3cbK1KzzvFpvScw6b01sFhusRCBkXGA5xl3k7ZN/FvUORRRhR0/pmil9VGUAZTGwJ7ISDKKKkav83c1N8gKX1URy493SSZL0ZHLO76Fkk63gNSh9gW2eewzKi0DZfY7lVLN1ls1WpfcJiq1b7isFSr5WNTRyX8x0OaNwf4G0m+SxInSboemphZGbeU0vSbwjpe3uHIY2+TcgzXHPJZjr2Ro7RylJvDO54MihWLgb83Mm2IQO13lQRbcpukjU34/vM2ydhHcJIcl9cZSmHUeJqzHQfJvnRfmwjnGI/a9AhXOr9zsLfUjOtdW+2Lxt5zq+nUQqnQEyFVO0fLg6PJdo+jh3PbLd/eRX6rHXW2o5ebHGNUd7qb7ehD16Xn2/3RJsf1uNCkaGnjhTzBd6Jvc9R7HCWeboRcarrHMZ9Vz5XZGH+R9ezTtm3k8Yws9DW58fh2LvgyZSvvtKSOlgTaEupbsTzj0RyetXN5fiPzdc6DxfyIB2exPuKRHYJY2SGIlV2CWNkjiMU71vqIR3SZxfRpLuMsftUU4zQuZXUah+gwjzmJeQqyl7l8WOwTmbKYJzJzYVsnMuOwTmT6gJR5IrPS++aJTDvWOJHZii5bHDucLV/vtPbPYfuk2Ma+MeKerz2TkM8pdfRsqXD6fSLhX9PGvjFskXwNfZjL+jUtfvZrjuqSX19T7+0cJY23lSXlco8jznbsJ+F1jrbd/JZtjG4K/WY7xnvVkrbbfdpnn8pNjjw5SmLzLq77vimH0fdtFFbm+44OGW4vVmBjTC4z/7VZnHtxiMm9YDHG5DiLNSbHWawxuRcsxpjciy8yxuSEvuNo21NQDuOegnKY9xSyfdxsrTE53ik2XeIcNl2yDg7VNodsveyQrZfXs/Wag8Q2D4WV4GCqlMSssC9YjArLWawKy1msCvuCxaiwL77IqrDRQWGjg8JGF4WNHzdbs8JGB4WNDgoblxW2RBb0LGUEPeGUk3q+yVFucsClFZjCb3HkGefPEAZ+jyOVyVFvcoQ+OMBP/x5HCYOjkHawadfGuITGxpZy9CGKfQs3OYa3cueI6xzhdjvq5Cj3OPpcJHqu6+3I17bOqglax5Zz2MaWc9jG1swRbrfDNLaUwzi25naQsc20Gm8eO8WHls+Y9pMLTGQ9nYVz2FJRROSzHLZ0FtqnaSyVMdWN9SnPFDi9imG7cirSZuSZD5Nxp/qjGWVbd5EKi2YZXaT0a47NiX6NRLn8Gs4ho0ekXPdIyLTwn+RtsMh2k8WYnMc5bMl5LzgsyXl5OY00L6eRpuXUnrSc2iMsSLNtQ0v337hQPgU5X7CMXeGDJV2HSnNml2u2IJMn4Fb5LR6rnVIOo51yDoudsiIcPQ0l29sDW2WRNzjGiXvnCJccefOwkxcsZjtJTnaSHOwkOdhJumcn/7aDP/zxT7/9+69/+eMf/vanv/z5v/f/7h8Pqt/+9If/+PWXL/hff//zH+Hf/u3//fX8N//x259+/fVP/+ff//rbX/74y3/+/bdfHkyPf/e77et//jWUXOT3+/+2/G+//13Sf9KOf9Jl/yfh6/9pN/XH/5bHPwrHP9rjs79//G/+t388mvr/AQ==",
      "is_unconstrained": true,
      "name": "get_owner"
    },
    {
      "abi": {
        "error_types": {
          "10522114655416116165": {
            "error_kind": "string",
            "string": "Can't read a transient note with a zero contract address"
          },
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13060541637244024094": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8556029555939094797": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [
          {
            "name": "chain_id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 16
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "array",
            "length": 32,
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            }
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_utility"
      ],
      "debug_symbols": "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revcus6t69y6zq3r3LrOrevcus6t69y6zq3r3LrOrevcus6t69y6zq3r3LrOrevcus6t69y6zq3r3LrOrevcus6t69y6zq3r3LrOrevcus6t69y6zq3r3LrOrevcus6t69y6zq3r3LrOrevcus6t69y6zq3r3LrOrevcus6t69y6zq3r3LrOrevcus6t69y6zq3r3LrOrevcus6t69y6zq3r3LrOrevcus6t69y6zq3r3LrOrevcus6t69y6zq3r3LrOrevcus6t69y7zr3r3LvOvevcu86969y7zr3r3LvOvevcu86969y7zr3r3LvOvevcu86969y7zr3r3LvOvevcu86969y7zr3r3LvOvevcu86969y7zr3r3LvOvevcu86969y7zr3r3LvOvevcu86969y7zr3r3LvOvevcu86969y7zr3r3LvOvevcu86969y7zr3r3LvOvevcu86969y7zr3r3LvOvevcu86969y7zr3r3LvOvevcu86969y7zr3r3LvOvevcu86969y7zr3r3LvOvevcu86969y7zr3r3LvOvevcu86969y7zr3r3LvOvevcu86969y7zr3r3LvOvet8dJ2PrvPRdT66zkfX+eg6H13no+t8dJ2PrvPRdT66zkfX+eg6H13no+t8dJ2PrvPRdT66zkfX+eg6H13no+t8dJ2PrvPRdT66zkfX+eg6H13no+t8dJ2PrvPRdT66zkfX+eg6H13no+t8dJ2PrvPRdT66zkfX+eg6H13no+t8dJ2PrvPRdT66zkfX+eg6H13no+t8dJ2PrvPRdT66zkfX+eg6H13no+t8dJ1nV9JGr/JuOk1/Hifblb86B311/siavGk0zabVtJtOU3uc9oj2iPaI9oj2iPaI9oj2iPaI9oj2uO1x2+O2x22P2x63PW573Pa47XHLIxuXHlmTN42m2bSadtNpiqb2sPaw9rD2sPaw9rD2sPaw9rD2sPbw9vD28Pbw9vD28Pbw9vD28Pbw9hjtMdpjtMdoj9Eeoz1Ge4z2GO0x2mO2x2yP2R6zPWZ7zPaY7THbY7bHbI/VHqs9Vnus9ljtsdpjtcdqj9Ueqz12e+z22O2x22O3x26P3R67PbrOZ9f57DqfXeez6zw7oM5Imk2raTedpmi6RVnnIGvypvaI9oj2iPaI9oj2iPa47XHb47bHbY/bHrc9bnvc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GZZoRCcO4iQu4iYeYhBv46Lbotui26Lbotui26LbotuiW2bJyNXJLHloRCcO4iQu4iYeYhDpduh26Hboduh26Hboduh26HbodugWdAu6Bd2CbkG3oFvQLegWdAu6Xbpdul26Xbpdul26Xbpdul263XbL/tFCIzpxECdxETfxEININ6Ob0c3oZnQzuhndjG5GN6Ob0c3p5nRzujndnG5ON6eb083p5nQbdBt0G3QbdBt0G3QbdBt0G3QbdJt0m3SbdJt0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0Y5YEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJgllxmyWWWXGbJZZZcZsllllxmyWWWXGbJZZZcZsllllxmyWWWXGbJZZZcZsllllxmyWWWXGbJZZZcZsllllxmyWWWXGbJZZZcZsllllxmyWWWXGbJZZZcZsllllxmyWWWXGSJJ95GZAnQiE4cxElcxE08RLpNui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26bboduh26Hboduh26Hboduh26HbodugXdgm5Bt6Bb0C3oFnQLugXdgm6Xbpdul26Xbpdul26Xbpdul27Ikpl/s+pHNGK67cRBnMRF3MRDDOJtRJYAjUg3o5vRzehmdDO6Gd2Mbk43p5vTzenmdHO6Od2cbk43p9ug26DboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptum26Hboduh26Hboduh26Hboduh26Fb0C3oFnQLugXdgm5Bt6Bb0C3odul26Xbpdul26Xbpdul26XbpdtsNfa8PjejEQZzERdzEQwwi3ZglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOW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",
      "is_unconstrained": true,
      "name": "get_registered_emitter"
    },
    {
      "abi": {
        "error_types": {
          "10522114655416116165": {
            "error_kind": "string",
            "string": "Can't read a transient note with a zero contract address"
          },
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13060541637244024094": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8556029555939094797": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [
          {
            "name": "chain_id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 16
            },
            "visibility": "private"
          },
          {
            "name": "emitter_address",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "boolean"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_utility"
      ],
      "debug_symbols": "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wVM1eKoGT9XgqRo8VYOnavBUDZ6qwVM1eKoGT9XgqRqMqsGoGoyqwagajKrBqBqMqsGoGoyqwagajKrBqBqMqsGoGoyqwagajKrBqBqMqsGoGoyqwagajKrBqBqMqsGoGoyqwagajKrBqBqMqsGoGoyqwagajKrBqBqMqsGoGoyqwagajKrBqBqMqsGoGoyqwagajKrBqBqMqsGoGoyqwagajKrBqBqMqsGoGoyqwagajKrBqBqMqsGoGoyqwagajKrBqBqMqsGoGoyqwagajKrBqBqMqsGoGoyqwagajKrBqBqMqsGoGoyqwagajKrBqBqMqsGoGoyqwagajKrBqBqMqsGoGoyqwagajKrBqBqMqsGoGoyvBn18cAH3q0HA38i+P7CCWbAKdoEXnIIouA++GgTUyKNGHjXyqJFHjTxq5FEjjxp51MhWI1uNbDWy1chWI1uNbDWy1chWI1uNPGvkWSPPGnnWyLNGnjXyrJFnjTxr5Fkjrxp51cirRl418qqRV428auRVI68aedXIu0beNfKukXeNvGvkXSPvGnnXyLtG3jWy18heI3uN7DWy18heI3uN7DWy18heI58a+dTIp0Y+NfKpkU+NfGrkUyOfGvnUyFEjR40cNXLUyFEjR40cNXLUyFEjR418a+RbI98a+dbIt0a+NfKtkW+NfGvk+0b++zr91zSarGk2rabd5E2nKZraY7THaI/RHqM9RnuM9hjtMdpjtMdoD2sPaw9rD2sPaw9rD2sPaw9rD2uP2R6zPWZ7zPaY7THbY7bHbI/ZHrM9Vnus9ljtsdpjtcdqj9Ueqz1We6z22O2x22O3x26P3R67PXZ77PbY7bHbw9vD28Pbw9vD28Pbw9vD28Pbw9vjtMdpj9Mepz1Oe5z2OO1x2uO0x2mPaI9oj2iPaI9oj2iPaI9oj2iPaI/bHrc9bnvc9rjtcdvjtsdtj9seXeej63x0nY+u89F1PrrOR9f56DofXeej63x0nY+u89F1PrrOR9f56DofXeej63x0nY+u89F1PrrOR9f56DofXeej63x0nY+u89F1PrrOR9f56DofXeej63x0nY+u89F1PrrOR9f56DofXeej63x0nY+u89F1PrrOR9f56DofXeej63x0nY+u89F1PrrOR9f56DofXeej63x0nY+u89F1PrrOR9f56DofXeej63x0nY+u89F1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dDt0O3Q7dDt0O3Q7dAu6Bd2CbkG3oFvQDe8IHYmHGMTPbXyfULLpsHAQjTiJi7iJTjzEILZbth8WDqIRJ3ERN9GJhxhEug26DboNug26DboNug26DboNug26Gd2MbkY3o5vRzehmdDO6Gd2MbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26bbk43p5vTzemWWfK9Udeyf7HQiel2EoN4GzNLHg6iESdxETfRiXQ7dDt0C7oF3YJuQbegW9At6BZ0C7oF3S7dLt0u3S7dLt0u3S7dLt0u3W677d+POIhGnMRF3EQnHmIQ6TboNug26DboNug26DboNug26DboZnQzuhndjG5GN6Ob0c3oZnQzuk26TbpNuk26TbpNuk26TbpNuk26Lbotui26Lbotui26Lbotui26Lbptum26bbptum26bbptum26bbptujndnG5ON6eb083p5nRjlmxmyWaWbGbJZpZsZslmlmxmyWaWbGbJZpZsZslmlmxmyWaWbGbJZpZsZslmlmxmyWaWbGbJZpZsZslmlmxmyWaWbGbJZpZsZslmlmxmyWaWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmyWGWHGbJYZYcZslhlhxmyWGWHGbJYZYcZslhlhxmyWGWHGbJYZYcZslhlhxmyWGWHGbJYZYcZslhlhxmyWGWHGbJYZYcZslhlhxmyWGWHGbJYZYcZslhlhxmyWGWHGbJYZYcZslhlhxmyWGWHGbJYZYcZslhlhxmyWGWHGbJYZYcZslhlhxmyWGWHGbJYZYcZslhlhxmSbZ5/n0JlziIRpzERdxEJx5iEG/joduh26Hboduh26Hboduh26HboVvQLegWdMssMfwCiEXcxHTLhcoseRjEz21+j06yCbRwEI04iYu4iU48xCC2W7aDFg6iESdxETfRiYeYbr/E25hZ8nAQjTiJi7iJTjxEug26Gd2MbkY3o5vRzehmdDO6Gd2MbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26bbk43p5vTzenmdHO6Od2cbk43p9uh26Hboduh26Hboduh26HboduhW9At6BZ0C7oF3YJuQbegW9At6Hbpdul26Xbpdul26Xbpdul26Xbb7f5+xEE04iQu4iY68RCDSDdmyWWWXGbJZZZcZsllllxmyWWWXGbJZZZcZsllllxmyWWWXGbJZZZcZsllllxmyWWWXGbJZZZcZsllllxmyWWWXGbJZZZcZsllllxmyWWWXGbJZZZcZsllllxmyWWWXGbJZZZcZsllllxmyWWWXGbJZZZcZsllllxmyWWWXGbJZZZcZsllllxmyWWWXGbJZZZcZsllllxmyWWWXGbJZZZcZsllllxmyWWWXGbJZZZcZsllllxmyWWWXGbJZZZcZslFllhiEG8jsgQ4iEacxEXcRCfS7dLtltv8/X7EQTTiJC7iJjrxEINIt0G3QbdBt0G3QbdBt0G3QbdBt0E3o5vRzehmdDO6Gd2MbkY3o5vRbdJt0m3SbdJt0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RDVmyEm8jsgSYbviNZEacxEXcRCceYhBvI7IESDenm9PN6eZ0c7o53ZxuTrdDt0O3Q7dDt0O3Q7dDt0O3Q7dDt6Bb0C3oFnQLugXdgm5Bt6Bb0O3S7dLt0u3S7dLt0u3S7dLt0u22G/peHw6iESdxETfRiYcYRLoNug26DboNug26DboNug26DboNuhndjG5GN6Ob0c3oZnQzuhndjG6TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum27MksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksQd9r/mpd9L0+NOLntkbiIm6iEw8xiLcxs+ThIBqRbpNuyJKd6MRDDOJtRJYAB9GIk7iIdFt0W3RbdFt023TbdNt023TbdNt023TbdNt023RzujndnG5ON6eb083p5nRzujndDt0O3Q7dDt0O3Q7dDt0O3Q7dDt2CbkG3oFvQLegWdAu6Bd0yS9ZMvI2ZJQ8H0YiTuIib6MRDpNttN/S9PvzctiUacRI/t42/u4lOTLeVGMTbmFnycBCNOImLuIlOpNug26Cb0c3oZnQzuhndjG5GN6Ob0c3oNuk26TbpNuk26TbpNuk26TbpNum26Lbotui26Lbotui26Lbotui26Lbptum26bbptum26bbptum26bbp5nRzujndnG5ON6eb083p5nRzuh26Hboduh26Hboduh26Hboduh26Bd2CbkG3oFvQLegWdAu6Bd2Cbpdul26Xbpdul26Xbpdul26ZJXYTbyH6Xh8OohEncRE30YmHGES6DboNug26DboNug26DboNug26DboZ3YxuRjejm9HN6GZ0M7oZ3Yxuk26TbpNuk26TbpNuk26TbpNuk26Lbotui26Lbotui26Lbotui26Lbptum26bbptum26bbptum26bbptuTjenm9PN6eZ0c7o53ZxuTjen26Hboduh26Hboduh26Hboduh26Fb0C3oFnQLugXdgm5Bt6Bb0C2zZH81j77Xh4OYdwoncRIXMe8UItGJhxjEW4i+14eDaMRJXMRNdOIhBpFug26DboNug26DboNug26DboNug25GN6Ob0c3oZnQzuhndjG5GN6PbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26ab083p5nRzujndnG5ON6eb083pduh26Hboduh26Hboduh26HbodugWdAu6Bd2CbkG3oFvQLbPEZ2IQb2NmiXviIBpxEhdxE514iEG8heh7fTiIRky3SFzETXTiIQbxNmaWPBxEI9Jt0G3QbdBt0G3QbdDN6GZ0M7oZ3YxuRjejm9HN6GZ0m3SbdJt0m3SbdJt0m3SbdJt0m3RbdFt0W3RbdFt0W3RbdFt0W3RbdNt023TbdNt023TbdNt023TbdNt0c7o53ZxuTjenm9PN6eZ0c7o53Q7dDt0O3Q7dDt0O3Q7dDt0O3Q7dgm5Bt6Bb0C3oFnQLugXdgm5Bt0u3S7dLt0u3S7dLt0u3S7dLt9tu6Ht9OIhGnMRF3EQnHmIQ6cYsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZsllllxmyWWWXGbJZZag7/V74f5E3+vDQwzibcwseTiIRpzERaTboNug26BbZkl8X5Gg7/XhIBpxEhdxE514iEGk26TbpBuy5CRO4iJuohMPMYi3EVkCHES6Lbotui26Lbotui26Lbptum26bbptum26bbptum26bbptujndnG5ON6eb083p5nRzujndnG6Hboduh26Hboduh26Hboduh26HbkG3oFvQLegWdAu6Bd2CbkG3oNul26Xbpdul26Xbpdul26Xbpdstt4W+14eDaMRJXMRNdOIhBpFug26DboNug26DboNug26DboNug25GN6Ob0c3oZnQzuhndjG5GN6PbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui26bbptumW2ZJROIibmKm8k08xCB+bt+rtRf6Xh8O4ud2d+IkLuImOvEQg3gbM0seDiLdDt0O3Q7dviyx30g8xCDeD3MdviwpHET7MNfhy5LC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6MRDDGLON8+d+BEH0YiTuIib6MRvdVae1V8+FN7Gm265kncQjZjXrDxp8/PFw0383FZu1s1xvwPKl5kVDqIRJ3ERN9GJhxhEug26DboNug26DboNug26DboNug26Gd2MbkY3o5vRzehmdDO6Gd2MbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26bbk43p5vTzenmdHO6Od2cbk43p9uh26Hboduh26Hboduh26HboduhW9At6BZ0C7oF3YJuQbegW9At6Hbpdul26Xbpdul26Xbpdul26cYsucySyyy5zJLLLLnMksssucySiyxZiUG8jcgS4CAacRIXcRPT7SQeYhDT7UvPiywBDqIRJ3ERN9GJhxhEuk26TbohS27iJC7i55Z3eNlpVniIn1ve4V2kRv4z5EMkbuI3Qn4Vly8oKwzibcx8eDiI33zzbjBfUFa4iJuYbjnJzIeHQUy3nHrmw8NBTLeceubDw0XcxHTLg898yE/C2fh28uY0G98KjTiJ37gnT6NMgnwqkY1vJ580ZOPbyWcK2fhWeBszCR6mW04nk+DhJC7i55b3v9kDd/JON98/dvLpQb5/7OQlPzvjTt7pZmdcoREncRE30YnplnPI8v/Qf6h54CAacRIXcROdeIhBvI2DboNug26DboNuWfNf65Fn61zhIX5u34d4z9a5h1nzDwfRiJO4iJvoxEOkm9Eta/771OHZZldoxElcxE1MtzzirPmHQbyN3/1DfD8349lmV2jE74cBfzmzLx/i+zTj2WZX6B+uxEOMD3M6Xz483D/iIBpxEhdxE514iHTbdHO6Od2cbk43p5vTzenmdHO6Od0O3Q7dDt0O3Q7dDt0O3Q7dDt0O3YJuQbegW9At6BZ0C7oF3YJuQbdLt0u3S7dLt5tunriJTjzEeJckz5eOAfOlY4WDaMRJXMRNdGIexfkw82EDc76RuIib6MRDDOJttFyHm9jrmx2COMzsECwM4m38aj6+x2OeHYKFRpzE3s3sECx04iEGsXdzrB9x9BxQ88BJXMTdc8iaf3iIdGPND9b8YM0P1vxgzQ/W/Nh97ozNldxcyc2VzJrHHJwr6VxJ1vxgzQ/W/GDND9b8YM0P1vxw7htqHsiVPFzJw33Lmn/IlWTND9b8YM0P1vxgzQ/W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",
      "is_unconstrained": true,
      "name": "is_emitter_registered"
    },
    {
      "abi": {
        "error_types": {
          "10522114655416116165": {
            "error_kind": "string",
            "string": "Can't read a transient note with a zero contract address"
          },
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13060541637244024094": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15711892660910782274": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16216212843441549037": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "2014890719615096298": {
            "error_kind": "string",
            "string": "Field failed to decompose into specified 40 limbs"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "3378875131383195299": {
            "error_kind": "string",
            "string": "Invalid destination chain ID"
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "4648451262681811962": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "7555607922535724711": {
            "error_kind": "string",
            "string": "Preimage mismatch"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8171600539936659379": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 92
          },
          "8556029555939094797": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9589626482238399944": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "anchor_block_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "sponge_blob_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "vaa",
            "type": {
              "kind": "array",
              "length": 2000,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "length",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::side_effect::counted::Counted"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::scoped::Scoped"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::side_effect::counted::Counted"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::scoped::Scoped"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "note_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 32,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "log",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "fields",
                                          "type": {
                                            "kind": "array",
                                            "length": 18,
                                            "type": {
                                              "kind": "field"
                                            }
                                          }
                                        },
                                        {
                                          "name": "length",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::log::Log"
                                    }
                                  },
                                  {
                                    "name": "note_hash_counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "expected_non_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "expected_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "anchor_block_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "sponge_blob_hash",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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B+66d+a565t/XBfHvwFw1/3enru++cdz2fXQ/X7uGVdnPJ3uvnnuxZdzAklCSSLX75+J7qEhcNfN9dz1bQ+JXZx3bATcde/Mc9c3/yQujn9j4K77vT13ffNP6rLrofv93DOJzqQ63X3z3Esm5+SSFJKUrt8/E91DE+Cum+u569seUrk479gUuOvemeeub/6pXRz/ZsBd93t77vrmn8Zl10P3+7lnap1pdLr75rmXVs4+knSS9K7fPxPdQ3PgrpvruevbHjK4OO/YArjr3pnnrm/+GV0c/5bAXfd7e+765p/JZddD9/u5Z0admXS6++a5l1nOWSRZJdlcv38muodWwF0313PXtz1kd3HesTVw170zz13f/HO4OP5tgLvu9/bc9c0/p8uuh+73c88cOnPqdPfNcy+XnHNL8kjyun7/THQPbYG7bq7nrm97yOfivGM74K57Z567vvnnd3H82wN387j87l/AZddD9/u5Z36dBXS6++a5V1DOhSSFJUVcv38muocOwF0313PXtz0UdXHesSNw170zz13f/Iu5OP6dgLvu9/bc9c2/uMuuh+73c89iOovrdPfNc6+EnEtKSklKu37/TPhfGAbcdXM9d33bQxkX5x27AHfdO/Pc9c2/rIvj3xW4635vz13f/Mu57Hrofj/3LKuznE533zz3ysu5gqSipJLr989E99ANuOvmeu76tofKLs47dgfuunfmueubfxUXx78HcNf93p67vvlXddn10P1+7llFZ1Wd7r557lWTc3VJDUlN1++fie6hJ3DXzfXc9W0PtVycd+wF3HXvzHPXN//aLo5/b+Cu+709d33zr+Oy66H7/dyzts46Ot1989yrK+d6kvqSBq7fPxPdQx/grpvruevbHhq6OO/YF7jr3pnnrm/+jVwc/37AXfd7e+765t/YZddD9/u5ZyOdjXW6++a510TOTSXNJM1dv38muof+wF0313PXtz20cHHecQBw170zz13f/Fu6OP4Dgbvu9/bc9c2/lcuuh+73c8+WOlvpdPfNc6+1nNtI2krauX7/THQPg4C7bq7nrm97aO/ivONg4K57Z567vvl3cHH8hwB33e/tueubf0eXXQ/d7+eeHXR21Onum+deJzl3lnSRdHX9/pnoHoYCd91cz13f9tDNxXnHYcBd9848d33z7+7i+A8H7rrf23PXN/8eLrseut/PPbvr7KHT3TfPvZ5y7iXpLenj+v0z0T2MAO66uZ67vu2hr4vzjiOBu+6dee76+r/k4uL4jwLuut/bc9fX/yUWl10P3e/nnv109tfZx/WvewPkPFAySDLY9ftnonsYDdx1cz13ff0fHHBx3nEMcNe9M89dX/+HCVwc/7HAXfd7e+76+j8S4LLrofv93HOozmE63X3z3Bsu5xGSkZJRrt8/E93DOOCum+u569seRrs47zgeuOvemeeub/5jXBz/CcBd93t77vrmP9Zl10P3+7nnGJ1jdbr75rk3Ts7jJRMkE12/fya6h4nAXTfXc9e3PUxycd5xEnDXvTPPXd/8J7s4/pOBu+739tz1zX+Ky66H7vdzz8k6p+h0981zb6qcp0mmS2a4fv9MdA9TgLturueub3uY6eK841Tgrntnnru++c9ycfynAXfd7+2565v/bJddD93v556zdM7W6e6b594cOc+VzJPMd/3+megepgN33VzPXd/2sMDFeccZwF33zjx3ffNf6OL4zwTuut/bc9c3/0Uuux663889F+pcpNPdN8+9xXJeIlkqWeb6/TPRPcwC7rq5nru+7WG5i/OOs4G77p157vrmv8LF8Z8D3HW/t+eub/4rXXY9dL+fe67QuVKnu2+ee6vkvFqyRrLW9ftnonuYC9x1cz13fdvDOhfnHecBd90789z1zX+9i+M/H7jrfm/PXd/8N7jseuh+P/dcr3ODTnffPPc2ynmTZLNki+v3z0T3sAC46+Z67vq2h60uzjsuBO66d+a565v/NhfHfxFw1/3enru++W932fXQ/X7uuU3ndp3uvnnu7ZDzTskuyW7X75+J7mExcNfN9dz1bQ97XJx3XALcde/Mc9c3/70ujv9S4K77vT13ffPf57Lr4R7Xf8+9OvfpdPfNc2+/nA9IDkoOuX7/THQPy4C7bq7nrm97OOzivONy4K57Z567vvkfcXH8VwB33e/tueub/1GXXQ/d7+eeR3Qe1enum+feMTkfl5yQnHT9/pnoHlYCd91cz13f9nDKxXnHVcBd9848d33zP+3i+K8G7rrf23PXN/8zLrseut/PPU/rPKPT3TfPvbNyPic5L7ng+v0z0T2sAe66uZ67vu3hoovzjmuBu+6dee765n/JxfFfB9x1v7fnrm/+l112PXS/n3te0nlZp7tvnntX5HxVck1y3fX7Z6J7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aBDkBV0FjYJugiZBQdBd0EPQLOgp6CUoCnoL+gj6CvoJ+gu2EWwrGCDYTjBQsL1gkGAHwY6CnQQ7u3sdBIMFQwRDBbsIdhUMEwwXjBCMFIwS7CYYLRgj2F0wVrCHYJxgvGBPwQTBRMFegr0FkwT7CPYV7CfYX3CA4EDBQYJWwWTBwYJDBFMEhwqmCqYJDhNMF8wQHC44QjBTMEtwpOAowdGC2YJjBHMExwqOExwvOEEwV3Ci4CTByYJTBKcK5glOE8wXLBAsFCwStAlOF5whOFOwWHCW4C0C9w1793159+13911298109z1z961x9x1w941u9/1s921r991p901o971m9y1l951j9w1i931g9+1e911d981b9z1a961Y9x1X941V9/1T921S991Q901P971N9y1M951K9w1J931H9+1F911E981C9z1B960/9x0+94089/0692059903900297009y0z950x9w0w930u9+0s910r980p9z0o960m9x0l940j9/0h920g990e900d970b9y0a950Y9w0X930V9+0T910S980Q9z0P960N9x0M940K9/0I920H990F900E970C9y0Bd8+/u4Pf3Y/v7q5398q7O9/dfezurnR3j7m7Y9zd/+3u5nb3Zrs7rd190+4uaHdPs7tD2d1v7O4edvcCuzt73X267q5bdw+tuyPW3d/q7lZ19566O0ndfaHuLk93z6a7A9PdT+nujnT3Oro7F919iO6uQnePoLvjz92/5+7Gc/fWuTvl3H1v7i42d0+au8PM3S/m7v5y93K5O7PcfVburil3D5S7o8ndn+TuNnL3Drk7gdx9Pe4uHXfPjbuDxt0P4+5ucfequAUndx+JuyvE3ePh7thw91+4uyncvRHuTgd334K7C8HdU+DuEHDn+93Ze3cu3p1Zd+fJ3Vlvdw7bnZF255fd2WJ37tedyXXnZd1ZVnfO1J0Bdecz3dnJ/51rFLjzgO6snjtH5864ufNn7myYO7flzlS5807uLJI7J+TO8LjzNe7sizuX4s6MuPMc7qyFOwfhzii48wNub7/bd+/2xLv96m4vudvn7fZgu/3Rbu+y21fs9vy6/bhur6zbx+r2mLr9n25vpts36fY0uv2Gbi+g26fn9tC5/W1u75nbF+b2bLn9VG6vk9uH5PYIuf07bm+N2/fi9pm4PSBu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",
      "custom_attributes": [
        "abi_private"
      ],
      "debug_symbols": "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6JyPzvnonI/O+eicj8756JyPzvnonI/O+eicj8756JyPzvnonI/O+eicj8756JyPzvnonI/O+eicj8756JyPzvnonI/O+eicj8756JyPzvnonI/O+eicj8756JyPzvnonI/O+eicj8756JyPzvnonI/O+eicj8756JyPzvnonI/O+eicj8756JyPzvnonM/O+eycz8757JzPzvnsnM/O+eycz8757JzPzvnsnM/O+eycz8757JzPzvnsnM/O+eycz8757JzPzvnsnM/O+eycz8757JzPzvnsnM/O+eycz8757JzPzvnsnM/O+eycz8757JzPzvnsnM/O+eycz8757JzPzvnsnM/O+eycz8757JzPzvnsnM/O+eycz8757JzPzvnsnM/O+eycz8757JzPzvnsnM/O+eycz8757JzPzvnsnM/O+eycz8757JzPzvnsnM/O+eycz8757JzPzvnsnM/O+eycz8757JzPzvnsnM/O+eycz8757JzPzvnsnM/O+eycz8757JyvzvnqnK/O+eqcr8756pyvzvnqnK/O+eqcr8756pyvzvnqnK/O+eqcr8756pyvzvnqnK/O+eqcr8756pyvzvnqnK/O+eqcr8756pyvzvnqnK/O+eqcr8756pyvzvnqnK/O+eqcr8756pyvzvnqnK/OeXYgnWzk/XL+yJv+PE72DX85B305fzSaZtNq2k3WdJq8qT2sPU57nPY47XHa47THaY/THqc9Tnuc9vD28Pbw9vD28Pbw9vD28Pbw9vD2iPaI9oj2iPaI9oj2iPaI9oj2iPa47XHb47bHbY/bHrc9bnvc9rjtccsjG5cejabZtJp2kzWdJm+KpvYY7THaY7THaI/RHqM9RnuM9hjtMdpjtsdsj9kesz1me8z2mO0x22O2x2yP1R6rPVZ7rPZY7bHaY7XHao/VHqs9dnvs9tjtsdtjt8duj90euz0657tzvjvnu3O+O+fZ7XQsaTdZ02nypmi6RZlz0GiaTe1x2uO0x2mP0x6nPU57eHt4e3h7eHt4e3h7eHt4e3h7eHtEe0R7RHtEe0R7RHtEe0R7RHtEe9z2uO1x2+O2x22P2x63PW573Pa45ZHNUY9G02xaTbvJmk6TN0VTe4z2GO0x2mO0x2iP0R6jPUZ7jPYY7THbY7bHbI/ZHrM9ZnvM9pjtMdtjtsdqj9Ueqz1We6z2WO2x2mO1x2qP1R67PXZ77PbY7bHbY7fHbo/dHrs9dntYe1h7WHt0zq1zbp1z65xb59w659Y5t865dc6tc26dc+ucW+fcOufWObfOuXXOrXNunXPrnFvn3Drn1jm3zrl1zq1zbp1z65xnt5X/kmbTatpN1nSavCmabtGX80ftcdvjtsdtj9setz1ue9z2uOWRDViPRtNsWk27yZo+j5nkTdF0i76cPxpNs2k17SZrao/RHqM9vpz79wtG2ZT1aDTNptW0m6zpNHlTNLXHl3O/SaNpNq2m3WRNp8mboukW7fbY7bHbY7fHl/MYSdZ0mrwpmm7Rl/NHo2k2rab2sPaw9rD2sPaw9jjtcdrjtMdpj9Mepz1Oe5z2OO1x2sPbw9vD28Pbw9vD28Pbw9vD2+PLeeQZ9uX80Wj6PFbSatpNnwd+F/A0eVM03aIv549G02xaTbupPW573Pa47XHLI5u8Ho2m2bSadpM1nSZviqb2GO0x2mO0x2iP0R6jPUZ7jPYY7THaY7bHbI/ZHrM9ZnvM9pjtMdtjtsdsj9Ueqz1We6z2WO2x2mO1x2qP1R6rPXZ77PbY7bHbY7fHbo/dHrs9dnvs9rD2sPaw9rD2sPaw9rD2sPaw9rD2OO1x2uO0x2mP0x6nPU57nPY47XHaw9vD28Pbw9vD28Pbw9vD28Pbw9sj2iPaI9oj2iPao3PunXPvnHvn3Dvn3jn3zrl3zr1z7p1z75x759w759459855dM6jcx6d8+icR+c8OufROY/OeXTOo3MenfPonEfnPDrn0TmPznl0zqNzHp3z6JxH5zw659E5j855dM6jcx6d8+icR+c8OufROY/OeXTOo3MenfPonEfnPDrn0TmPznl0zqNzHp3z6JxH5zw659E5j855dM6jcx6d8+icR+c8OufROc/+s7hJp8mboukWZc5Bo2k2rabd1B6nPU57ZM530i3KnING02xaTbvJmk6TN7WHt0e0R7RHtEe0R7RHtEe0R7RHtEe0x22P2x63PW573Pa47XHb47bHbY9bHtms9mg0zabVtJus6TR5UzS1x2iP0R6jPUZ7jPYY7THaY7THaI/RHrM9ZnvM9pjtMdtjtsdsj9kesz1me6z2WO2x2mO1x2qP1R6rPVZ7rPZY7bHbY7fHbo/dHrs9dnvs9tjtsdtjt4e1h7WHtYe1h7WHtYe1h7WHtYe1x2mPL+d3JM2m1fTncWeSNZ0mb4qmW/Tl/NFomk2rqT28Pbw9vD28Pbw9oj2iPaI9oj2iPaI9oj2iPaI9oj1ue9z2uO1x2+O2x22P2x63PW573Ocxsx/u0WiaTatpN1nTafKmaGqP0R6jPUZ7jPYY7THaY7THaI/RHqM9ZnvM9pjtMdvjy/ndSdZ0mj4PT4qmW/Tl/NFomk2raTdZ02lqj9Ueqz12e+z22O2x22O3x26P3R67PXZ77Paw9rD2sPaw9rD2sPaw9rD2sPaw9jjtcdrjtMdpj9Mepz1Oe5z2OO1x2sPbw9vD28Pbw9vD28Pbw9vD28PbI9oj2iPaI9oj2iPaI9oj2iPaI9rjtsdtj9setz1ue9z2uO1x2+O2xy2P7Id7NJpm02raTdZ0mrwpmtpjtMdoj9Eeoz1Ge4z2GO0x2mO0x2iP2R6zPWZ7zPaY7THbY7ZH53x0zkfnfHTOR+d8dM5H53x0zkfnfHTOR+d8dM5H53x0zkfnfHTOR+d8dM5H53x0zkfnfHTOR+d8dM5H53x0zkfnfHTOR+d8dM5H53x0zkfnfHTOR+d8dM5H53x0zkfnfHTOR+d8dM5H53x0zkfnfHTOR+d8dM5H53x0zkfnfHTOR+d8dM5H53x0zkfnfHTOR+d8dM5H53x0zkfnfHTOR+d8dM5H53x0zkfnfHTOR+d8dM5H53x2zmfnfHbOZ+d8ds5n53x2zmfnfHbOZ+d8ds5n53x2zmfnfHbOZ+d8ds5n53x2zmfnfHbOZ+d8ds5n53x2zmfnfHbOZ+d8ds5n53x2zmfnfHbOZ+d8ds5n53x2zmfnfHbOZ+d8ds5n53x2zmfnfHbOZ+d8ds5n53x2zmfnfHbOZ+d8ds5n53x2zmfnfHbOZ+d8ds5n53x2zmfnfHbOZ+d8ds5n53x2zmfnfHbOZ+d8ds5n53x2zmfnfHbOZ+d8ds5n53x2zmfnfHbOZ+d8ds5n53x2zmfnfHbOZ+d8ds5n53x2zmfnPPvh/j6EExdxE414iE4M4i3MvrjCQZzERdxEIx6iE4NIt0G3QbdBt0G3QbdBt0G3kW4rMYi3cabbThzESVzETTTiIToxiLdx0W3RbdFt0W3RbdFt0W3RbdFt0W3TbdNt023TbdNt023TbdNt023TzehmdDO6Gd2MbkY3o5vRzehmdDt0O3Q7dDt0O3Q7dDt0O3Q7dDt0c7o53ZxuTjenm9PN6eZ0c7o53YJuQbegW9At6BZ0C7oF3YJuQbdLt0u3S7dLt0s31JKTeIhOTLebeAs3aglwECdxETfRiIfoxCDSbdBt0G3QbdBt0G3QbdBt0G3QbdBt0m3SbdJt0m3SbdJt0m3SbdJt0m3RbdFt0W3RbdFt0W3RbdFt0W3RbdNt023TbdNt023TbdNt023TbdPN6GZ0M7oZ3YxuRjejm9HN6GZ0O3Q7dDt0O3Q7dDt0O3Q7dDt0O3RzujndnG5ON6eb083p5nRzujndgm5Bt6Bb0C3oFnQLugXdgm5Bt0u3S7dLt0u3S7dLt0u3SzfWks1aYqwlxlpirCXGWmKsJcZaYqwlxlpirCXGWmKsJcZaYqwlxlpirCXGWmKsJcZaYqwlxlpirCXGWmKsJcZaYqwlxlpirCXGWmKsJcZaYqwlxlpirCXGWmKsJcZaYqwlxlpirCXGWmKsJcZaYqwlxlpirCXGWmKsJcZaYqwlxlpirCXGWmKsJcZaYqwlxlpirCXGWmKsJcZaYqwlxlpirCXGWmKsJcZaYqwlxlpirCXGWmKsJcZaYqwlxlpirCXGWmKsJcZaYqwlxlpirCXGWmKsJcZaYqwlxlpirCXGWmKsJcZaYqwlxlpirCXGWmKsJcZaYqwlxlpirCXGWnJYSw5ryWEtOawlh7XksJYc1pLDWnJYSw5ryWEtOawlh7XksJYc1pLDWnJYSw5ryWEtOawlh7XksJYc1pLDWnJYSw5ryWEtOawlh7XksJYc1pLDWnJYSw5ryWEtOawlh7XksJYc1pLDWnJYSw5ryWEtOawlh7XksJYc1pLDWnJYSw5ryWEtOawlh7XksJYc1pLDWnJYSw5ryWEtOawlh7XksJYc1pLDWnJYSw5ryWEtOawlh7XksJYc1pLDWnJYSw5ryWEtOawlh7XksJYc1pLDWnJYSw5ryWEtOawlh7XksJYc1pLDWnJYSw5ryWEtyfbEvycGiZO4iJtoxEN0YhBvYfYpFg7iJC7iJhrxEJ0YRLoNug26DboNumUt+f72xcy2xcJDTLebGMTbmLVkrsRBnMRF3EQjHqITg3gbF90W3RbdFt0W3RbdFt0W3RbdspbMXJ2sJQ8HcRIXcRONeIhODCLdjG5GN6Ob0c3oZnQzuhndjG5Gt0O3Q7dDt0O3Q7dDt0O3Q7dDt0M3p5vTzenmdHO6Od2cbk43p5vTLegWdAu6Bd2CbkG3oFvQLegWdLt0u3S7dLt0u3S7dLt0u3S7dLvtlr2QhYM4iYu4iUY8RCcGkW6DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26LboturCXBWhKsJcFaEqwlwVoSrCXBWhKsJcFaEqwlwVoSrCXBWhKsJcFaEqwlwVoSrCXBWhKsJcFaEqwlwVoSrCXBWhKsJcFaEqwlwVoSrCXBWhKsJcFaEqwlwVoSrCXBWhKsJcFaEqwlwVoSrCXBWhKsJcFaEqwlwVoSrCXBWhKsJcFaEqwlwVoSrCXBWhKsJcFaEqwlwVoSrCWXteSyllzWkstacllLLmvJZS25rCWXteSyllzWkstacllLLmvJZS25rCWXteSyllzUkp14G1FLgIM4iYu4iUY8RCfSbdJt0W3RbdFt0W3RbdFt0W3RbdFt0W3TbdNt023TbdNt023TbdNt023TzehmdDO6Gd2MbkY3o5vRzehmdDt0O3Q7dDt0O3Q7dDt0O3Q7dDt0c7o53ZxuTjenm9PN6eZ0c7qhlnxPQC5qCXAQ0y0SF3ETjXiITgzibUQtAQ4i3S7dLt0u3S7dLt0u3W65rd/vRxzESVzETTTiIToxiHQbdBt0G3QbdBt0G3QbdBt0G3QbdJt0m3SbdJt0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0W3TbdNt023TbdNt023TbdNt023TbdDO6Gd2MbkY3o5vRzehmdDO6Gd0O3Q7dDt0O3Q7dDt0O3Q7dDt0O3ZxuTjenm9PN6eZ0c7o53ZxuTregW9At6BZ0C7oF3YJuQbegW9Dt0u3S7dLt0u3S7dLt0u3S7dKNtWSwlgzWksFaMlhLBmvJYC0ZrCWDtWSwlgzWksFaMlhLBmvJYC0ZrCWDtWSwlgzWksFaMlhLBmvJYC0ZrCWDtWSwlgzWksFaMlhLBmvJYC0ZrCWDtWSwlgzWksFaMlhLBmvJYC0ZrCWDtWSwlgzWksFaMlhLBmvJYC0ZrCWDtWSwlgzWksFaMlhLBmvJYC0ZrCWDtWSwlgzWksFaMlhLBmvJYC0ZrCWDtWSwlgzWksFaMlhLBmvJYC0ZrCWDtWSwlgzWksFaMlhLBmvJYC0ZrCWDtWSwlgzWksFaMlhLBmvJYC0ZrCWDtWSwlgzWksFaMlhLBmvJYC0ZrCWDtWSwlgzWksFaMlhLJmvJZC2ZrCWTtWSylkzWkslaMllLJmvJZC2ZrCWTtWSylkzWkslaMllLJmvJZC2ZrCWTtWSylkzWkslaMllLJmvJZC2ZrCWTtWSylkzWkslaMllLJmvJZC2ZrCWTtWSylkzWkslaMllLJmvJZC2ZrCWTtWSylkzWkslaMllLJmvJZC2ZrCXZzjq+v+a6sp+1cBE/t7USjXiITgzibcxa8nAQJ3ER6XbohlriiU4M4m1ELQEO4iQu4iYakW5ON6eb0y3oFnQLugXdgm5Bt6Bb0C3oFnS7dLt0u3S7dLt0u3S7dLt0u3S77Ya+14eDOImLuIlGPEQnBpFug26DboNug26DboNug26DboNuWUuWfZi15OEgTuIibqIRD9GJQaTbotuiW9aSvRMXcRM/t43/9hCdmG4n8TZmLXk4iJO4iJtoxEN0It023YxuRjejm9HN6GZ0M7oZ3YxuRrdDt0O3Q7dDt0O3Q7dDt0O3Q7dDN6eb083p5nRzujndnG5ON6eb0y3oFnQLugXdgm5Bt6Bb0C3oFnS7dLt0u3S7dLt0u3S7dLt0u3S77Ya+14eDOImLuIlGPEQnBpFug26DboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbpNuk264Lvk+j9H3+nAQJ3ERN9GIh+jEINJt023TbdNt023TbdNt023TbdNt083oZnQzuhndjG5GN6Ob0c3oZnQ7dDt0O3Q7dDt0O3Q7dDt0O3Q7dHO6Od2cbk43p5vTzenmdHO6Od2CbkG3oFvQLegWdAu6Bd2CbkG3S7dLt0u3S7dLt0u3S7dLt0u3227oe304iJO4iJtoxEN0YhDpNug26DboNug26DboNug26DboNuiWtWSfxEGcxLxSuImbaMTP7ftbbAt9rw+DeBuzljwcxElcxE00It0W3RbdFt023TbdNt023TbdNt023TbdNt023YxuRjejm9HN6GZ0M7oZ3YxuRrdDt0O3Q7dDt0O3Q7dDt0O3Q7dDN6eb083p5nRzujndnG5ON6eb0y3oFnQLugXdgm5Bt6Bb0C3oFnS7dLt0u3S7dLt0u3S7dLt0u3S77Ya+14eDOImLuIlGPEQnBpFug26DboNug26DboNug26DbllLzBJvY9aSh+kWiZO4iJtoxEN0YhBvI2oJkG6LbotuWUtOTj1rycNDdGIQb2PWkoeDOImLSLdNt023TbdNt003o5vRzehmdDO6Gd2MbkY3o5vR7dDt0O3Q7dDt0O3Q7dDt0O3Q7dDN6eZ0c7o53ZxuTjenm9PN6eZ0C7oF3YJuQbegW9At6BZ0C7oF3S7dLt0u3S7dLt0u3S7dLt0u3W67oe/14SBO4iJuohEP0YlBpNug26DboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbpNuk26Tbotui26LbohtribOWOGuJs5Y4a4mzljhribOWOGuJs5Y4a4mzljhribOWOGuJs5Y4a4mzljhribOWOGuJs5Y4a4mzljhribOWOGuJs5Y4a4mzljhribOWOGuJs5Y4a4mzljhribOWOGuJs5Y4a4mzljhribOWOGuJs5Y4a4mzljhribOWOGuJs5Y4a4mzljhribOWOGuJs5Y4a4mzljhribOWOGuJs5Y4a4mzlgRrSbCWBGtJsJYEa0mwlgRrSbCWBGtJsJYEa0mwlgRrSbCWBGtJsJYEa0mwlgRrSbCWBGtJsJYEa0mwlgRrSbCWBGtJsJYEa0mwlgRrSbCWBGtJsJYEa0mwlqDv9XtR/ELf68Mg3kbUEuAgTuIibqIR6bbptum26Za1xFfiIE7iIm6iEQ/RiUG8jYduh26HbviOcxM30YiH6MQg3kZ8xwEO4iTSzenmdHO6Od2cbk63oFvQLegWdAu6Bd2CbkG3oFvQ7dLt0u3S7dLt0u3S7dLt0u3S7bYb+l4fDuIkLuImGvEQnRhEug26DboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptum26Gd2MbkY3o5vRzehmdDO6Gd2Mboduh26Hbqwll7XkspZc1pLLWnJZSy5ryWUtuawll7XkspZc1pLLWnJZSy5ryWUtuawll7XkspZc1pLLWoK+1/glGvEQP7fvLxos9L0+vI1ZS75XQi/0vT6cxM8tPHETjXiITgzifbjR9/pwECdxETfRiIf4ud2VGMTb+NWS+b3JaGffa+Ekrg9H4iYa8XwYiU4M4v3wfjh/xEH83EZO56slhZtoxEN0YhBv41dLCgeRbotui26Lbotui26Lbotum26bbptum26bbptum26bbptum25GN6Ob0c3oZnQzuhndjG5GN6Pboduh26Hboduh26Hboduh26HboZvTzenmdHO6Od2cbk43p5vTzekWdAu6Bd2CbkG3oFvQLegWdAu6Xbpdul26Xbpdul26Xbpdul263XbLvtfCQZzERdxEIx6iE4NIt0G3QbdBt0G3QbdBt0G3QbdBt0G3SbdJN9aSwVoyWEsGa8lgLRmsJYO1ZLCWDNaSwVoyWEsGa8lgLRmsJYO1ZLCWDNaSwVoyWEsGa8lgLRmsJYO1ZLCWDNaSwVoyWEsGa8lgLRmsJYO1ZLCWDNaSwVoyWEsGa8lgLRmsJYO1ZLCWDNaSwVoyWEsGa8lgLRmsJYO1ZLCWDNaSwVoyWEsGa8lgLRmsJYO1ZLCWDNaS7Hud8/uwzL7XwkH83KYlLuImfm7f7+7s7HstdOLnttItawkwa8nDz23txElcxM9tj0QjHuLntmdiEG9h9r3O72HIzr7Xwkn83GwkbqIRP7fvz+ju7HstDOLndr75Zt9r4SB+bt8X8z9cxE383Dznm7XkoRM/t++79M6+14dZSx5+bn4SJ3ERN9GIh+jEIN7GrCUP6bbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26WZ0M7oZ3bKWRJ4PWUseGvFzi9ysrCUPg3gbs5Y8HMRJXMRNNCLdDt0O3Q7dspZEJA7iJKbbTdxEI35uNw8za8nDIN7GrCUPB3ESF3ETjUi3oFvWkpvzzVoCzFryMN1yvllLHi7in9v6Zd6+WlJ4iP5hbvdXSwpvIdojR1KO5Yn5UzcxiLfxO7cKB3ESF3ETjXiIdDO6Gd0O3Q7dDt0O3Q7dDt0O3Q7dDt0O3ZxuTjenm9PN6eZ0c7o53ZxuTregW9At6BZ0C7oF3YJuQbegW9Dt0u3S7dLt0u3S7dLt0u3S7dLttlv2Qa7vZTQ7+yALJ3ERN9GIn9s4iU4M4m0c6eaJg5hukbiIm2jEQ3RiED+3r3dpZx9k4SB+bt+7Znb2QRZu4ueWVxLZB1noxCDexvUjfm7rlziJi7iJn9vKmX2fU4VO/NxWLtT3OfXw+5wq/Nx2DvZ9ThUuYh7FTvzGzUuY7G38Ky2JOUJOPevDw0XcRCMe4jduXthkb2Phbcz68PBzy2uc7G0s/NwsJ5n14aERD9GJQUy3PAmyPjwcxElMt0xA1oeHn9vJSWZ9eOjEIH5ueZ2VvY2FgziJi7iJ6ZbTyfrw0IlBTLecZNaHh4OYbhnIrA8PN/EWZr/i+v7c7s7OxJWXctmO+FcsEw/RiUG8jRnp72/Z7mxHLJzERdxEI35uec2Q7YiFQbyNGenI+WakH07i5xY5s4z0QyOm20lMN09Mt5t4GzPSDwdxEhfxG/fmJDO8D4N4GzO8D0djpvBa4iR+Fjfnm3nLq47s/ysM4m3MvD0cjZmLvCzJPr3CSVzETTTiIToxiLcx6BZ0C7oF3YJuQbcvATvvrGbv3c57qNl7t3+53d+5XriJ9mFu9/dZWOjEIN7C7L0rzHEtMUc4iTnCTQzibRw5QiQO4iQu4iYa8XMbv0Qnfm55CZj9dA+/MBR+4+bncfbI7fyunT1yhTlfT8wR8jDXjziIk5jj5jp8n1mFRky3XJ3lxCDSbdNt023TbS/i7r3YRjxEJwaRu2mzt9Cst9BOb5ZxN427abf34nA3D3fzcDcPd/NwN4/1vh3u5vHerMPdPNxNn72Fbr1vzt107y306IVyrm9wfYPrG7M3K7ibwd0M680K7mZwN4NuQbdLt0u327uZDWE7L8qyIaxwEr/p5E2fbAgrNOIhOjGItzHD8HAQP7e89MmGsMJNNOIhOjHdcr4ZHGAG5+EgpttNXMRN/Nzyui8bwgqd+LnldV82hD3M4DwcxM9tzcQcdyUeohODmON+O5+tX/v7hZ6drV87ryez9atwETcx3fKIM04PnRjEzy0vQ7Pfa+fdsez32nntmf1ee+d0MkM7fywz9PAQnRjE2/h9vhWmW656Juvh52Zp/H2+FRrxEJ0YxM8tb8Blv1fhIE5iuuV0Mm8PjZhuObPM28Mgfm4ntzvzdnIOmbeHk7iIm2jEb9yT252feonZ2fUwY5rXk9lrVfiNm5eL2WtVaMRDdGIQb2PG9OEgTmK6jcR0m4lGPEQnBvE2ZiDz8jb7p3Zesmb/1N9GJjoxiDlCLklG7+EgTuIibmK6ReIhplsuagby4W3M6EWuQ4Ys7/FlT1RhjmCJ0QuVIQPmZ9bDQcxxc0kybw83kbt5uJuHu3nodujmdHO6Zd6AmYC88M4upUIjZgLSAgkABvE2ZgIeDmIeWy5JJuDhJhrxEJ0YhdmPtPPbQfYjFS7iJhrxEJ0YxNuYH4sP6TboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbpNuk26bbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptulmdDO6Gd2MbkY3o5vRzehmdDO6Hboduh26Hboduh26Hboduh26Hbo53ZxuTjenm9PN6eZ0c7o53ZxuQbegW9At6BZ0C7oF3YJuQbeg26Xbpdul26Xbpdul26Xbpdul2y03y36kwkGcxEXcRCMeohODSLdBt0G3QbdBt0E31JJIPEQn3lcR7YcCAhzESVzETTTiIToxiHRbdFt0W3RbdFt0W3RbdFt0W3RbdNt023TbdNt023TbdNt023TbdNt0M7oZ3YxuRjejm9HN6GZ0M7oZ3Q7dDt0O3Q7dDt0O3Q7dDt0O3Q7dnG5ON6eb083p5nRzujndnG5Ot6Bb0C3oFnQLugXdgm5Bt6Bb0O3S7dLt0u3S7dLt0u3S7dLt0u222/j9iIM4iYu4iUY8RCcGkW6DboNug26DboNug26DboNug26sJYO1ZLCWDNaSwVoyWEuyCWl/j2Mtm5AKnfi5fR2alk1ID7OWPPzcvruslk1IhYu4iUY8xHQ7iUG8jVlLHg7iJC7iJhrxEOm26bbpZnQzuhndjG5GN6Ob0c3oZnQzuh26HbplLbm5Q1lLHm6iEQ/RiekWibcxa8nDdLuJk7iIm/g3rn33ii0bi+yXp8ZXHwoncX2Yp8ZXHwqNeD7ciU4M4m286ZYHdAdxEhcxx83luznC3/dNy2ahwkHMI96Ji7iJRjxEJwbxc/vuRFo2CxUOYs73Ji7iJhrxEJ0YxNs4f8RBpNuk25d5++6GWjYL2Xc31LJZqNCJQbyN60ccxElcxE2k20o3S3RiENPtO0uyWahwENMtt3Av4iZ+bjMH+zJf6MTP7XuUbNks9PDLfOHn9t1ztGwWKlzEz23ldL7MFx5iuuV0LIi38cu87Tw1vswXTuLntnOzvswXGvFz2znfL/OFQfzcdrr5jziIn5vl+ftlvnATPzfLNfuuHwqd+Lmd3Njv+uFh1oeHn9vJJcn68HARP7eT08n68PAQPzfP6WR9eHgbsz54nuBZHx5O4ucWuajf9UOhET+3SLfv+qEwiJ9bXrrnS/IKB/Fzy6KbL8kr3MTPLet6viSv0Il/bicLXr4k7+FXSwrHhznYV0sKF/HP7WS68yV5hYfoH+Z8v1pSeBu/WnK+v3tk+ZK8wkn83DIi+ZK8QiN+bnmC50vyCoP4uX334i1fklc4iJ/bygP6aknhJn5uK92+WlLoxM/tuw9u+ZK8h18tKfzcvrvjli/JK1zEz22n21dLCg/xczMMFsTb+NWSYznYV0sKJ/Fzs1zUr5YUGvFzO7kkXy0pjMasGlnwsuHLRh581oeHh+jEIN7GrA8PB/Gb78lz56sPhZtoxEN0YhBv41cfzsmz+qsPhZOYbrmSsYlGzE/IPGlx/QAMYrrlZt0cNw/oLuImGvEQnRjEW5itXYWDOImLuIlGPEQnBpFug26DboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptum25GN6Ob0c3oZnQzuhndjG5GN6Pboduh26Hboduh26Hboduh26HboZvTzenmdHO6Od2cbk43p5vTzekWdAu6Bd2CbkG3oFvQLegWdAu6XbpdurGWbNaSzVqyWUs2a8lmLdmsJZu1xFBLPHEQJ3ERN9GIh+jEIH5u38Mmy56ywkFMt0hcxE004iE6MYi3EbUEOIh0m3SbdMta8j1mtOwpK3Ti55ZXeNlT9jBrycPPLa/w8mV278eyPnxPzyy7xwq/Eb5HZpbdY4WDOImLuInffPNqMF9bV+jEIKZbTjLrw8NB/NxuTj3rw8NN/Nzy7ky2rRU6MYifW95myba1k99Y8wV1Jy9O8wV1hUY8xBw3T6OsBHn3IF9Q53lHIBvfPL/7Z+Nb4SQu4v4wp/NVgsJDdGJ8mPONtMjpRFpkcCItcjpf/D2vdLPbrdCIh+jEIN7GL/6e31izM65w9Wl0eUZdnqmXZ+rlmZqZf3gLsx2ucBAncRE30YiH6MQ8oJ14G8ePmAdkiZO4iJtoxEN0YhBv4/wR6TbpNtMtEjfRiIfoxCB+bjOP+Mt84SBO4uf2dZ9bttkVGvFzy5sD2Wbn+W0m2+wK0+1LQLbZFaZbTmdP4iJuohEP0YlBvI32I9LN6GZ0M7oZ3YxuRjejm9Ht0O3Q7dDt0O3Q7dDt0O3Q7dDt0M3p5nRzujndnG5ON6eb083p5nQLugXdgm5Bt6Bb0C3olgXkazqzbN8rvI1ZQB6O+kjK9r3CRdxEIx6iE4PYn3r50jnPL9D5ejl86uXr5fxrZrN8vVxhEG9j1oeHgziJ3zp87XCWHYJYh+wQxGFmh2DhIE7it755eyw7BAuNeIi9m9khWNi76etHHMRJXMTdc0DmgYfoxOg5ZOaBmfmHdGPmnZl3Zt6ZeWfmnZn33eeOb66kcSWNK5mZxxyMK2lcSWbemXln5p2Zd2bemXln5v1w35B5IFfycCUP9y0z/5Arycw7M+/MvDPzzsw7M+/MvDPz7tw350o6VzK4ksGVzMx/v4ls2UJYmCtpiUY8RCfmseUcMvPAzPzDQZzERdxEI6ZbTvI6MTP/rWS+HA4pzJfDed4rzpfDFW6iEXuH4ufEIPa5HuNHHMRJ7B3KhsVCIx6iE4PY50PMH3EQ8yhGohEP8Rs3b+dla6LnjbtsTXyY9eHhIE7iIm6iEQ+x7yYF7h4AB3ESF3ETjXiITgwi3YxuRjejm9HN6GZ0M7oZ3YxuRrdDt0O3Q7dDt0O3Q7dDt0O3Q7dDN6eb083p5nRzujndnG5ON6eb0y3oFnQLugXdgm5Bt6Bb0C3oxnuOcel26Xbpdul26Xbpdul26Xbpdtvt/n7EQZzERdxEIx6iE4NIt0G3QbdBt0G3QbdBt0G3QbdBt0G3SbdJt0m3SbdJt0m3SbdJt0m3SbdFt0W3RbdFt0W3RbdFt0W3RTfWkstacllLLmvJZS25rCWXteSyllzWkstacllLLmvJZS25rCWXteSyllzWkstacllLLmvJZS25rCWXteSyllzWkstacllLLmvJZS25rCWXteSyllzWkstacllLLmvJZS25rCWXteSyllzWkstacllLLmvJZS25rCWXteSyllzWkstacllLLmvJZS25rCWXteSyllzWkstacllLLmvJ7Vpyfl1Lzq9ryfl1LTm/riXn17Xk/LqWnF/XkvPrWnJ+XUvO70e3QbdBt0G3QbdBt0G3QbdBt0G3QbdJt0m3SbdJt0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0W3Tbf8hvL9RbGTvZaFi7iJRjxEJwbxNuY3lId0M7oZ3YxuRjejm9HN6GZ0O3Trp54ney0LF3ETjXiI6XYSg3gb8xvKzv82v6E8nMQ8tkjcRCMeohODeBvzG8rDQZxEugXdgm5Bt6Bb0C3odul26Xbpdul26Xbpdul26Xbpdtstey39+8Wwk72W/r2J4GSvZeEibqIRD9GJQbyN+b3lId2y7+q7s3ey17JwE+21/ZzstSx0Yvbv7MTbmH1XDwdxEhdxE414iE6k26Rbfm/5WgtO9k+64f+bq5NHkXcwHgbxNmYl+H5t7mRPpFvuUGb+oRODeBsz8w+/9f3aEE72RBYu4iYa8RCdGMR0y1XPzD8cxElMt9zjvCvxMDOfpxwyD3RiEG8j+h+Ag5jHlqueif06lk52PxYOYvWJHXQ/PtxEIx6iE4N4G7O76eEg0u3S7dLt0u3S7dLt0u22GzolHw7iJC7iJhrxEJ0YRLoNumVi8+MrOyULc4/xH2xinlE38RCdGMTbmHcaHg7iJC7iJtIt7z98D0tPdkoWxuv6O+iUBGan5MNB/Mb9njie7H7074nNQfdjfvig+xGY3Y8Pq2fvoPvx4SJmh2CuWXY/PjxEJwbxNmb348NBnMRFpJvRLXPseZiZWM//bybW8ygysQ830Yg5Qu5xfvJ6rnqm8OEibqIRD/Fb38ilzk/eh7cxc/xwECdxETcx3XLV85P3oRODmG65x/nJ+zDdduIkLuImGvEQnRjEW5hdioWDOF9f5kGX4sNNzA7MlXiITsx+z5F4GzPHDwdxEhdxE414iE6k26BbJvb7zYWTnYf+tWie7Dz07+n6yc7DwiDexvw0/Z6jn+wm9Jvj5qfpQycG8Tbm84CH3/reXJ38jH24iJtoxEN0YhBzvt+pnN2EhYM4iemWe5yfvA+rn/Zks6DfXLMM5MNFzB87iUb8tsVzsOPEIN7GjOlNtwzkzaXOtuEMZLYFFgYxW2tzL7Jt+OEgZiNvDpYfrA830YiH6MQg3ka0DQMHkW6Xbhm9m/P9QhZfI8PJBsD4+hRONgAWTuIing93Yo7wrXo29RUO4iQu4ibah554iE4M4m2cP+IgTmK6rcRNNOIhplskBvFz+37h4WRTX+EgTuIibqIRD9GJQaRbflhmJcimvsJJzCbwnGR+WD40YjaBn0QnBvE25oflw0GcxEXcRCPSzeh2cs3y5Dq5OrnUJ1cnz51jxEP0Rs8RcjDPEfLgfRONeIhODGKu73faZ/Nd4SBO4iJuohEPMd3yVI4g3sb7I35uM/f4y2bh5zYzWV82Y+K//cbNL23ZZld4C7N1LvKCM1vnCg/RiUG8jZnYh4M4iYtIt/yoy0qbrXOFTvzOsyy62Tr3ML9kPvzOs6zr2TpXuIibaMRDdGIQb2Nesj6k26JbZvN7hHqydS6+xoCTrXPxPZI82TpXOIiT+I2wcrCdI+TB79toP+IgTuIifuv7vTLnZDtc4SE6MYi3MfP2cBDTbSUu4iYaMd1yjzOFDz+378nrySa5h5nNh4P4ue1cnUzsw0004iE6MYi3MRP7cBDpljepR843b1I/NGL+6khud96kfhjE/NWRXLO8Sf1wECdxETfRiIfoxCC2G1rnHuaarcRcHUvM1TmJQbyNmeOHOUIk5gg30YlBvI35afpwEL/1zTtP2eJWuIlGPEQnBvE25qdpftfLFrfCSVzEdJuJ1pjZzPtG2YoWeRclW9EKnZhzyCXJbAIzmw8HcRIXcRONeIhOpJvVrz6dbEUrHMT61aeTrWiFm/idUXmJkq1ohU4M4m3MB0gPB3ESF3ET6eZ0yxRang+Zt/zeku1lkd+zsr2s0IiH+I1w8ojzUy9vh2TLWOEmGvEQnfitb34PyJYxYP710sJBnMRF3EQjpttKdGIQb2PmLW/fZHtZ4eeWd1HyZXWFm2jEzy3vl+TL6gqDeBszmw8HcRIXcRONSDf8IttJDOJtzAc9M5ckH/Q8nMT8tTlL3EQjHqITg3gb80HPw0GcRLptumW68+5MtpdF3p3J9rLImy/ZXla4iJuYI+S+5edmfn/LlrHCSVzETTTit755QyVbxgqDeBvzc/PhIE7iIqZbrnp+bj48RCemW+5xJhaYic37JdkcVriJRjxEJ+a4ub6ZY2Be0+ZlfjaHFaZbTifT/TDdcqkz3Q/TLZcv0/3wc8ubGfnWOWC+dS7yBkW2jBV+bt9vApxsGSv83PKmQ7aMFX5ued2XLWOF6WaJtzHTndep2TJWmG6euIjpFolGTLeb6MQ/t/vLA/rS/fBL982v4NkyVpjXGsBF3EQjHqIT0y2XZN7G9SOmWx7xl+7CRdxEIx6iE4N4G/ePSLdNt53j5vruHCEXdecIuZL2Iw7iJC4i52ucr3G+xvka52uc7+F8D+d7ON/D1Tl0O3Q70Qfkow/IOV/nfH0TjXiInK9zvs75BucbnG9wvsH5BucbnG9wdYJuQbc7+oDu7gO6nO/lfK8Tg9i7ma1dGDdbuwoncRE30YiH6MQg9upka1ch3cauA8p2LRzQHT3fOzjf+SMO4iQuYo57E434ZfNrZT9o13oYxNuYKRzAb4TMMVqw8isiWrAeBjFHyAPKT9OHg/jVkvyaihash5toxEN0YhBvY7ZgPRxEuhndMoXfrx2dbKu6eX8n26pu3hnJtqrCSVzEHCE36+QIuer+Iw7iJC7iJn7rmzdfslWq0IlBvI2Zt4eDOInplqueeXtoxENMt9zjzNvDdPs+s7JVqnAQJ3ERN9GIh+jEIJabo1Xq+y7taJV6OInfbm78t5toxO/c+RqaHa1SD4N4G7NV6uEgTuIibqIR6Tbolon9ugw825/ud03r2f50v6tXz/anwkP0xvyE/G4LebY03S+bni1NhUY8RCcG8VvflcuXn4UPB3ESF3ETjXiIOd9IDOJtzM/Nh+mWO5Sfmw/TLY84Pzcfpht+LN1yHbI98rsV4dnSVHgb89vtw0GcxEXcRCMeIt0O3TLz2OPM/MNBnMRF3EQjHqITg5huudSZ+YeDOImLuBszsTvPvkzsw0XcRCMeYs4styUTm5jtRPe7v+PZTlToxO+//V5269lO9DA/Cx9+O/TdRfFsJypcxG+Hvhd7eLYTFR7it0PfnRzPdqLC25itiQ8HcRIXcRONeIh0m3TLq9eH30piZpnN77aQZztRoROjMVP43SHyfMXatVzfzNvDQ3RiEG9j5u27SeLZTlQ4iYu4iUY8RCemmyXexvzcfDiIn9vJPc7PzYef28nVyevUg//2EJ0YxNuYeXs4iJO4iJtIt7ybhAPKduSHQczWz5wv2pGBg5jnTp7geaf34SYa8RCdGMTbmHd6Hw4i3S7dMpsnT5j83Pzu+ng2Gd2vo8azyahwEhfxG+FrmPFsHLrfLRnPxqHCQZzERdzEb32/p9WejUOFTgzibcxPyIeDOInp9kvcRCMeYrpZYjTma9Py0xSvTXtoxEPMEYBBvI35uflwECdxETfRiIdIt023TTejm9HN6GZ0M7oZ3YxuRrfM8XfnyfO1adfzfMgcPxzESVzETTTiIToxiHTDa9Ny3/DaNOAkZlNUnp752rSHRvz2bWEwJwbxNmb/w8NBnMRF3EQj0i3ollfFkfPNT9PIMOSn6fdHnTybjAoP0Quzneh+t7E8G4fud+/Ks3Go0IiH6MQgfuv73dHybBwqHMRJXMRNNOIhpttODOJtzBw/TLebOImf23enzPP1ZoVGPEQnBvE25lXxw0GcRLpl5vMzNhuSCg/x2838zMqGpMLbmP0P+YmeDUmFk7iIm2jEQ3RiEG+j0c3olun+bil6vrLs3px65vjmJDPHwMzxw0HMETwxR8iNzWw+vI35GftwECfx74jH77tl6PnOsmYTPsIuHMKX/EW0OV3zlM5r24eLuInwzM2OIwzPXLP7Ex7CMzkX8y5hHFMu3DXhI4zxcw43hG9ztjE1D+EpvIS3sAkfYRcOYfEd4jvEd4jvEN8hvkN8h/gO8R3iO8R3iu+ErydP4SW8hU34CGdX+XfabYQ9/78IO3ARNxHD4ef6LM++pof7R8Rcb/IUXsI51++OmGdvU/3oITqRjpuORkcbxElcxE2km9Hi5Fp/t+U8X0jWPIVz/l+rk2erU7MJH+Hc4+92mOd7yZov2X/C8LVkjJ97jzrw+Ahj/Nwg1IHHl4w68HgIT+ElDN9cE9SCx0fYhUP4klEjHg/hHHPmviPnM9cWOU825PzxEJ7CSzjnnLe6DDl/fIRdOIQvGTl/PIThu5OX8BY24SPswtF7Z8g5GDl/PISxLzP59Lplf1RzCF/ywrFYsqzV2sImjPHTd7lwCGP87zzJBqr62S17tGWPtvhu8d3iu4+wC4ewnBsmviZemeq88Mu+qkInBhHjfedjtlDhci9bqAo3EZO9yUfYhXOyeVsw26jej+YH/8NBpKPT0enoRjxEJwaRbkELhHjlwiDEj49wzj9vGBpC/PiSEeLHuckrT2R80D9ewlsYvrngCPrKuSHoyQdBf4zxPXkKL+EtbMJH2IXhG8mXjKA/HsJTeAlvYRPOMfML1sGHcn6XOgju4y1swkfYhXPOedf9INBgBPrxEJ7CS3gLmzB8d7ILh/AlI+iPh/Dk3iHoj7ewCWNfvmJ2EGKsmw3hKbyEcSyWLGtlIXzJ+DDPW60HH+aPpzDGz/PkyB4d2aMje3TE94jvEV98mD8ewnJuuJwbLr4uXpnqvJeU7wIrHMRJxHh5PuYTqLyDlK/9KgwiJvsVrYNwPx7COdm8n5x9XO9H7yYakY6XjpeOt++FZR9X4SBO4iIaMRc7bwc7QgxGiB/n/PPLnSPEj5fwFs5Nzm+sjk/rxy4cwvD9TkBH0PPmsiPoj7cwxvfkI+zCIXzJCPrjIQzfSF7CW9iEj7ALh/AlI8R5S9bxqXxybRHcxyF8yQj04yGcc8471I5AP97CJnyEXTiELxlBP7lHCPrjKbyEt7AJH+4dgv44hC8Z4c5HKo4QY91wpf74CLswjiXPpZC1whX54yWM8dMXH+aPjzDGz/MkZI9C9ujKHl3xveJ7xRcf5o9NWM6NK+fGpW/8fsL5dOQkbqIRDxHjfedj4LGWJw7iJGKyN3kLm3BONm9oZ7tW/WgQ+0EP2rUe0nHSMW+7PdxEIx4i3SYtEOKs3IEQP97COf+vA9IDIX7swiGcm5w3+AOf1o+H8BSGryVj/Fx8BP1xCGP8nD+C/ngIT+ElvIVNGL650Qj64xC+ZAT98RCewks4x8xbyYFP5ci1RXAfT+ElvIVNOOec95kDgX4cwpeMr96Ph/AUXsLwzT1C0B8fYRcO4UtG0LF3CPrjKbyEsS8zObhuuFJPvgj04yGMY7FkrtXFFfljF8b4J/mS8WH+GON7MvfojiW8hcV3iO8QX3yYP77k+RMewuI7xQvNJDcxiLeRLSYXH955y/+yx+Syx+Syx+Qi3IEfDOFLRrhv/vfoMwFO4iLScdNx03E7MYi3Me+vPaSb0QIhzgcDFyF+HMI5/69R1y9C/HgIT+Hc5Lwhf/Fp/diEjzB88wRE0PM+9kXQH09hjJ8nF4L+2ISPsAuH8CUj6Hkf8SLoj6fwEt7CJnyEnZwhHnkvP5vB/jjXNoNbfIRdOIRvcWRL2B+v5CE8hZfwFjbhI+zC8N3Jlzx+wkN4Ci/hXXsXPwT98RF2YezL/HjOWrfIjrHmLWzCOBZLlrVaP+EhjPHTdy3hLYzxPfnIz7pwCIvvFt8tvnsKL+EtbMLiu8UrUz1yannX/OEibiLGi+SvXAzgbTw/IiZ7k6fwEs7Jjlz4fOj9fvQQnUjHQ0enYzeIxq8bROPXDaLx6wbRQLPYQ1pkiMfIhckQF0/hnP/IEzy2sAkf4dzkkSdyfloXX/L9CcM3T0AEfeRJhKA/PsIYPzcIQX98mweC/ngIT+ElDN9INuEj7MIhfMkI+uMhnGN+N6kjO8z+eCRfcn4qFw/hKbyEc87fzfoYCPTjI+zCIXzJCPrjIQzfnbyEt7AJH2EXjt67gaCDEfTHQxj7MpMP1227cAhfsuFYLFnWyrawCWP89DUXDmGMn+fJkT06skdH9uiI7xHfI77nCLuwnBtHzg0XXxcvx5h5jjnGvMkuHMKXjOw/HsJTOGtJWqH9G2jEQ3RiEG9jNro8zF8zyOVF5FduHyL/+Ai7cB7OwjC3eSLyj4fwFF7CWzh/v8ETD9GJQbyN+H0M4CBO4iKeOuLsaHtHM1EMHl8yisFjOZopRzPlaKYcDYrB4yPswjygyQNaPKDFA1o8oMUDWpvI5VtcPvzaVB7xlqNB1B9P4SUsR7PlaLYczZaj2SEs54TJOWE8IOMBGQ/IeEDGAzIekPF8MC6fcfnwe1V5xEeO5mxhEz7CcjRHjubI0bgcjcs54XJOuJwTzgNyHpDzgJwH5Dwg5wEFz4fg8gWXL3/Z8rv5ENncVujEIOJQvrqeL9bKXzWN7Hkr3ESs00o+wi6MddrJt340u+EKB3ESF3ETjXiITgwi3QYtBvbZkk34CGP+nhzCl/yyD8Y+R/IUXsJbGL45H3zgfw+TYuEDH4wP/Mc5/vcAJhY+8B8v4S1swkfYheE7ky8ZVeDxEJ7CS3gLmzDG/PY937L1x7m2+MB/vIVN+Ai7MOaca44PfDA+8B8P4Sm8hLewCcM39whZfxzCl4ysPx7Ck3uHrD/ewiaM8+2rSeiOe+uGD/zHU3gJY8w8l0LWChf1jy8ZF/WWvriofzyFc3zL8+TKHl3Zoyt7dMX3iu+lLzrkiofwFF7CW/gI3/dWh8Cbvx4O4iTiOGbyee9yCLzk62EQc7LfQ7hAe1vxEMYi5eD5+gP8aL7+4KER6TjpOOmYryYB5qtJHg7iJNJt0QIhNvAlI8SPMX9PnsJLeAvnJn8P3mLjo/yxC4cwfL8TcCPo38Ok2Aj64y2c438PYGIj6I9dOIQvGUF/PIThmxuNoD/ewiZ8hF04hC8ZIcZJhSt4rD+C+ziELxmBfjyEMedccwT68RY24SPswiF8yQj6yT1C0B9P4SW8hU34cO8Q9MchfJvRFje+h2aB9jesG9rfio+wC2PM71xCmxvWCm1uxUs4x/f0xYf54yOc43/PrwJtbvWz3CO0uRWL7xTfKb74MH9swkfYhcV3iRdeOBSJm2jEQ8RxfOcj3hGWNR/vCHs4iTnZ7yFcoL+t2ISxSLnw+WaT96NBvI1GR6Oj0THfd/JwE414iHQzWiDEnguDED/ewpi/Jx9hFw7h3OS8tDV8Wj8ewlMYvjkfBD3yJELQH4dwjh95ciHoj4fwFF7CW9iE4ZsbjaA/DuFLRtAfD+EpvIQx5rfvaHMb30OyQJtb8RRewlvYhDFnT3bhEL5k3IJ7PISn8BKGbySb8BF24RC+ZAQ99+4g6I+n8BLG+XaSg+uGK3UwAv14CGPMmyxrhSvyxy6c49/0xYc5GB/mj3P87/lVoM3t/eyWPdqyR1t8t/hu8cWH+eNLNjk3TM4NE18TL7wpMA8dbwoE3ka8KRCI45jJX7nIL14HLwUEHmJO9nsIF+hvK75khPvm4PmCI/xovuDo4SLS0enodMwXHD0M4m3MFwM+pFvQAiG+YBcOYcw/T3CE+PEQnsK5yTdPZHxaPzbhIwzf7wTMDre/26+/5CE8hVfySN7CJnyEXTiEL3nAdyYP4Sm8hLewCR9hJ0+MuZPxs5ZswkfYhUP4khfm7MlDeAov4S1swkfYheEbyZe8f8JDeAov4c292yZ8hF0Y59tXzND+9tbNlvAWNmGMmeeSyVqdn/AQzvHzGRra3Iq3cI6f95rR5lY/K3t0ZI+O+Lr4uvj6FF7Ccm64nBsuvi5eeEFvLhVe0AtcxE3EceT5iHfx5jbjXbyJeBcvMCebD+HQ31a8hLFIufD57rL3o4foRDredsS7yx4O4iQu4iYasS0CIc6Hf4EQP57CmD/++y1swkc4NzkfvGXPW/Mlz58wfG9yjp8PkwJBf3yEc/x8ABMI+uNLRtAfD+EpvIThO5NN+Ai7cAhfMoL+eAhjzJ2Mn8213ZdsP+EhPIWXMOaca45APz7CLhzCl4ygPx7C8M09QtAfb2ETPsIuHNw7BB2MoD8ewjjfTvLhurkLh/AlB8bMcylkrWILm3COn88A0OZWHMI5ft7TR5vb+9kre3Rlj674XvG94nuPsAvLuXF5bqAVrngKf6nOOn77HfqRzW+FQcRxfOfj7Zfox+2X6Mftl+gH+ttm3uhHf1uxC2ORcnC8SD9/FC/SBw4iHScdJx3xIn3gIToxiHRbtECIF9iEjzDm78khfMkI8ePc5Ly5f/Fp/XgJb2H43uQcP28EXwQdjKA/zvHzxv1F0B8v4S1swkfYheGbG42ggxH0x0N4Ci/hLWzCGDP3HZ/KeQMXbW7FW9iEj7ALY8655gg0GIF+PISn8BLewiYM39wjBP1xCF8ygv54CE/uHYL+eAubMM63v2J20f6W63bR/lY8hZcwxrzJvVYXbW7Fl4wP8+9G/0WbW/EUzvG/BwAXbW71syZ8hMV3iO8QX3yYPx7CU3gJi+8UL3yAfzf1L9rf5ndv/qL9rXgKL+EtbMJH2N8fXrk//N0a4G3E360BDuIkLuIm+vtLMjc73QpvIwJveZAI/OMpvIS3sAkfYRcO4Us+4nvE94jvEd8jvkd8j/ge8T3ie8Q3/0bkzfMt/1LVw0lcRHhmQPKPUt08N/OPUj28jagGlouKavB4CuOAcmfyD1O9HzXiIdIx6Bh0zD9M9XAQJ3ER6XZpgY/x7ynKRV9c8RDO+X9PPC764oq3sAnnhnxPMC764opD+JJRGb5fX7oDFeC7K38HKsBjE8b4luzCIXzJqACPh/AUhu9J3sImfIRdOIQvGVXiMcaMZPxsri0+5R9fMj7lHw/hKZxz9lxzfMo/NuEj7MIhfMkoBo/T13OPUAweL+EtbMJH2Ll3KAaPLxnF4DGO8ZdsXDcE/bELhzCOJc8ll7XCp//jLYw5py8+/R+7MNYqzxOXPQrZo5A9CvEN8Q3xxaf/4yMs50bIuRHie8UrU+156Pnn5h4eohNxHN/5mE1w+cf2bvbAFS4iNtaTTfgIY5EiOfijtzH/rutDOg46DjrmX4l8aMRDdCLdJi0Q4sdb2IRz/t8Tj4uet+IQvmSE+HuCcSc+6h9P4SWcvt+vL92JoH935e9E0B9fMoL+3cm+6H4rnsJLeAub8BGGb240gv74khH0x0N4Ci/hLYwxc9/xyR25tgju4yW8hU34COec80MJPW7Fl4zv5I+H8BRewls4fW/uEYL+2IVD+JIR9MeDe4egP17CWxjH+Eu+XDdcwj8ewlMYx5Ln0pW1wmX74xDGnD/fhQ/zx0MYa2XJ3KP128ImfIRdOIQvGR/mj4fwFBbfIV74AP9uFF/0vM3vAcRFz1vxEJ7CS3gLm/B5f7b14u9MPgzibVw/4iBO4iJ+4+b1Hf765MMg3kbkPS/N8YcmDbiJRsSJmouDUD8O4W+h1nen/a7+M88Xf2zy4STS0ehodMw/8/zQiUG8jYduhxYZ8PU9hblobCt24UheyZecAS8ewjM5T+AMePEWNmH45knuGD9PqvgJD2GMnxsUS3gLm/ARduEQhm+uyf0JD+EpvIS3sAmfZjS2re+JxkUD2/qeaFw0sBWb8BF24RDOOX8PAy5e8VY8hKfwEt7CJnyE4buTQ/iS5094CE/h1XuHV7wVm/ARxr58Yc0+t1q3NYWX8BbGsViyrNW65P0Txvjpu6fwEsb4nix7tGWPtuzRFt8tvia+NoSnsJwbJueGia+J15dqw7J9n+2FGDHPvLOEt7AJH2EXDuE8kpmrjOQ/HsLpO3NmSP7jLQzfm3yEXfi79ZHBzCa5h/nW1oeDOImLuIlGPERvzL9PmyU5W+AKcSx5FiLtj7ewCR9hFw5hrOGXCrwkrngIw9eSl/AWhu9KPsIunGs4Em9j/gHph4M4iYu4iUY8RG9EHfh+y+qiN654CuNoPHkLmzCOJpJdGKt4ky95/YTT93vQcg214vES3sImfIRdOH1XHiNqCBg15PEQnsJL+M93B/Bv+J3febOLbuc3keyie/jVicJBnMRF3ET7xs1Zf9cFhU4M4ueW35fzL3MWDuIkLuImGvEQvRE1YuXUUCMeT2GsUK4FasRjE8bOYEwXxs5kHnDVAMZVw2P45tmHq4bHS3gLm/ARdmH45tmKqwYwrhoeD+EpvIS/tcwP2uy123n9k2+a2wN4C7MBr3AQJ3ERN/Hbo/wMy9a7QicG8XPLT49suyscxElcxE004iF64+QZgba64inMMwJvnis2YZ4RePNcMc8ItN49Xj9hnhFnTeElvIVN+Ai7MM+Is3hGnP0THsJTeAn3GZGddzgjsvHu7efmGWE8I4xnhPGMMJ4RxjPCeEYYzwjjGWE8I4xnxOEZcXhGHJ4Rh2fE4RlxeEYcnhGHZ8SrEZE8hKfwEsbO3GQTPsIu/B1NfkBlW97D+BEHcRIXcRONeIi54TtPXpSAx0N4Ci/hLZyHs3NZcCnx2IVDGL7fiYO2veIhDN9IXsJbOH3zgR7a9lY+0EPb3soHaGjbK75kfOl4PISnMH52JV8yisH3SzIX7XnF+FlL/pszspFde4VGPEQnRiPink+E0IC3DP//b4ydB/2lutCJOcZNvI1fogsHcRIXEXa5yPjW8BiLjP/GhYOMbwd5Tz177XD6o9XurY0dYRcO4VzvfMyDFrziISzrja8Kj7ew+B7xRXzzURDa64qncI6Zzy7RXldswkfYhUM4jyUfdTg+4h8P4SmcvnnHB2+gKzbh9M3LFbyBbuWdcryBrviSke/HQ3gKL+EtbMLwzT1Fvh/DN08B5DsZb6MrHsLpm1d/gXw/3sImfIRdOIQvGfnOu+Po6CvG/u5k+IK3sAkfYReG13cuoYuveAjjGE/yEt7C8IrkIwyvXCtcHDy+ZFwc5PNjdPcVT+ElvIVN+Ainb97JRndf8SXj4uDxEJ7COF5PPl3J8KI75BcdgMXMOzoAi4fwFF7Cu2twvDoDPsIujDqTc0OdAaPOPB7CU3gJb2ETPsJYtzwnUXMeD+EpvISxX3kuoeY8PsIuHMKXjJqTN3HxMrziKbyEP9+dtxLQJVh8hD051z9rTvElZ83ZeWMVXYI7b5qiSxCXiOgSLN7CJnyEvTm7AfPreb4W79FsWk27yYoGxgcfYRf+O668sZFtfaAv649G02xaTRjTk7EmX67zHXV5yZ8de49mU34GJ+0mazpN3hRNcPl2EK17xbnyeYsRrXvFSzhnm7fl0KK3v2bvixa94m++IIySrraEt7AJH2GvFbJeXevVPb26p1f39Ooe45qe4JoezDj/G/8J48jzXPEpjDnnHn8Z2zmzL2GPTpM3RdMtCoyZ80FO8nbjxR9YSvKmaPruaOU65s070GiaTatpN8El9xWpeJxnbd7IxFvnim/x9/docrrfncxP5Ejfrb1PHBXfnN9/FLVQn7gixk/FUAGXBbFUbBVW+/GJo8JV6AyGzmDqDKbOYOoMps5g6gymzmDqDKbOYOoMps5g6QyWzmBNFQu5+bAD8glTcVS4ihCxsbeYGYL6BJJa4gtPACdxETfRiIfoxCDexkzqQ7oduh26Hboduh2cdA7hKkIFjvKmQLpL5JJPrDLyXWKp2CpMxVHhKnIGb9fyo7REfpa2yBksxAvVoMRSkTNY2EIUihJHxVfUEbyvWhTexq9eFA7iJGLsDYFjwBmBQrDy6NB+12KomCpwDAGxVZiKo8JVfGfOBcIfAsWjxFCR/ntALBVbRfrvBXFUpP/eEKHiiviKx7P8SkfhJC7iJhoRY+fq4n11e2PZEP7tEEvFVmEqcAwYGvEvESquCHzGl/huBk3gJC5i3kgDGvEQnRjE24gKYz+IoWKqMBU5e3sDXBG4LQccxEnMlTNsa15ptzAVuXKGfUAVKQFvbAqqyBOoIoalRxUxnLGoIoY1RRU5mA6qSAlTkQ+VgE6MRlSJg+NGLTjYFNSCgyNBLTg4QXF5fXAkuL4+mDwupA8mjyvpEkvFn8+z/KpC4SHmipw8brydbp8L8V14PNzEnKv/IHKuPiBcRai4IpB6nxBDxVSxVGwVpuKocBG4MPAFgdE2BP4zg8BED8QVgc/1EkPFVoHRHCJUYDQsLS65HYuY3353YBHxYV7iikDUAuuGqJWYKpb44OK7/hdTcVS4ipDVQTyfOD8VQ4WuAaL4DhtRLKGrg8C9cw2BC2wWAhfYLASuxFZhKo4KVxEqsKKYNT62SwwVmAFOCnxsBw4OUQ0cAqIaOIQXVezpi+oTIQJRjSemiqXiCxlcvqgWHmIeyc1zA211+w6IL6oG3MSc650QOde7IFxFqLgiENW7IYaKqWKp2CpMxVHhIhDVi1kjqvdA4D/L48eb4vYNiKFiqlgqvvqHgb9P2sJDdGIQb+P3+Vo4iJO4iHTbdNt023TbdNt0M7oZ3YxuRjejm9HN6GZ0M7oZ3Q7dvjzjEygb6goP0YlBvI1fugsHcRIXkW5ON6eb083p5nQLugXdgm5Bt6Bb0C3oFnQLugXdbrvhnW722xBTxVKxVZiKo8JVhIqbIgOO3jj7GQR8MiHZmYar2WxMKzTi10o5gbcxu00fYnIOcVS4CkzuQnwjZSHKVrTCQZzERdxEIx6iE4NIN6NbfuzZeCLnPbBa+YKWh0G8jfmCloeDOImLuIlGPES6HbodujndnG5ON6eb0y3f2IItyje2PHTi54aTEm9sScQbW4BYIfzXgRV6/0vu7MAZkh9WLa6IvHPbYqiYKpaKrcJUHBU6g6szuDIDtJgZ7sGgx6zFVLFUbBWm4qhwFaHiihg6g6EzGDqDoTPIPz8+gEY8RCcG8TZOjH0gcAwO8R3Db4FdOIS/A/jlvtdfIQUP4Sm8hLcwligzj34xw01ENIy1mCpyIXB7Ea9ka2EqjgpXESquCPupGCqmCp2B6QwMM8AioWSUcBWYAfbSroiDGWBbDmaAbTmYAZbqLBVbRc4A92nwYrcWOQPcUcKr3Qw3hPBuN8PtnNeThtng4dHjKbyEt7AJwwEir4QN93vQZWa4d4M2sxZbBY4Eh4XiUsJVhIorAiUEX/Pxp0oNtxgMhQJ3LPAWtxah4lLgBW8thoqpYqnYKjCDBXFUuArMYENcESgUJYYKzMAgloqtAlfL4CPswvhqA75kXEI/HsJTeAnj8gRswkcYx30gQsUVsX4qlgqsokO4iOw3wX+U/SYPN/H7mMPq4T2NwNuI9zQCB3ESF3ETjXiIObd32Eh/iSsCgTecLwh8iaUi1xY3pvC3TFscFd8h4mjzuuHhbczrhoeDOImLuIlGPES6Od2cbkG3oFvQLegWdAu6Bd2CbkG3oNul26XbpRuuKQz7g2uKEqYCK/p+xlWECmxjnvvoNWuRe4qbYeg2a7FUbBWmImeAO3loOWuRM8DXBjSdGW7roevM8M0LbWctpgrM4EBsFabiW/cLdGIQb2O+jebhIGJsh8AxYHkQ+/P+sysCsS8xVOQx4HYf3h/XYqswFUfFd3WENfy+deDrP94gZ7ihh1fIGe7h4R1yLeCOn8HFCO66oZ2tRbrjUhsNbRZvaBfx/kwyOH/j73H+ohxM8Ovmj0M4J4wSg+a1FkPFVLFUbBWmAhOGD64cSoQI/P4qfgS/v/p4CudR4Ux6v6gONuG0w50ntLe1CBV5wG/n8lZbizxgXNuix63FUoHfCQWb8BF24RC+5Pe7ruAhPIWXsPhe8b3ie8X3iu+lL7rciofwFF7CW9iEj7ALY7UXxBWBilICq70hpoqlIk8v3HZDs1uLo8JVYAYHAjPIc+11vw3wEJ7CsMfBoOiUMBVHhasIFVcEylGJoWKq0BksncHSGaAV7gd24RC+ZLTCPR7CU3gJowscbMJHGAd+IULFFYEvRSU+7/ODSX4parFUHBU3RQYVvW8HXyPR/NZiqlgqMBpOkIPRcIL4T8VQMVUsFVuFpcCm+FHhKkLFFRE/FUPFVIEZIBexVZiKowIzwMJHqMgZ4M4Uut9aDBUo/OAlvIVN+Ah7M96Gd3DvK9vd/sSEyCPBPR/8bdgWR4WryCPBjQy8JK/E+KkYKqYKzABzG1uFqTgqXEWoyBmgJwl/KrbFUDFV5AzwZR5/OraFqcgZ4Jt9vlnvTxyIUIEZZJXLvj0KzAATXVPFUrFVmIqjwlWEiiti/1ToDLbOYOsMts5g6wy2zmDrDLbOYOsMTGdgOgPTGZjOwHQGpjMwnYHpDExnYDqDozM4OoOjMzg6g6MzODqDozM4OoOjMzg6A9cZuM7AdQaobLj3g5cAtjAVR8U3A3yS4z2AxZecZa14CE/hJbyFTTgPEB9KeLHfwUc13uzXIg8D96bwbr8WpuKocBWh4rYY6EY8+ZE30I2ItRvoRsSiDLzwr0WouCJQovJW2UA/YoupYqnYYjp0BuOocBWh4oqYPxVD5vZK1BNLxVZhMjeUqBKuQmcwdQZLZyAlavykRI2flKjxW7oGy2Q6S3dh6S4s3QWUqDe3rbuwdRe2zmDrDLbOYOsubN2FrbuwdQ22rsErUZib6S6Y7oLpLpjuAkpU3h4deNFgC+zCgQgVVwRKVAmsAYZGiSqxVGwVpuKocBWhImeQt1QHmiRbaMxQlfJm60BfZAtTcVToyYfrrRK69aFbH7r1oQEMDWDo1odufejWh2596NaHbv3V0//q6X/15EPh2ihCKFwlXEX6bKwbClfe1B3onmwxVEwVS8VWYSqOCheBkpa3iAe6JFtMFUsFfA6EqTgqXAWuuibEFYGSVmKomCqWiq3CVOBKGRNF4XoChavEUIEjdQhckWPWKE8lXAV2LiCuCJSnEljRCzFlgL1UbBU6g60z2DoDlKcSV4T9VAwVOgNTU9Sd/M420FDZ4opA3cnuyoE/Ctwih86bzwNtlS22ijw4w8mHulPCVeQMDHND3XkCdafEUIEZYBtRhEpsFaYCM8BmodQYNgulpsRQkT4HC4JSU2KrMBVHhasIFTmDgxVFqSkxVEwVS8VWYSoOBf5+8Ml7xwN/KPjkveOB9yS2MBVHhasIFTiE3BJ0Y7YYKqaKpWKrMBVHBWbgEKHiikB1KTFUTBWLG4x3LbYwFUcFztGsIejgrBVFQSmxVGwVOLiA0EVEQXkCBaUEfDADFJQSS0X6ZCvLwHsVewDdxq3buHUGW2dgOgMUlBJThZ5IpieS6QxMTU/fAR/oAC2ewtk/gG3PYlJswnlYjoVFKSkRKvKwHOOilJQYKtIdS5mVpHgLm/ARduEQvuQsLsVDWHxDfEN8Q3xDfEN8Q3xDfK/4XvG94nvF94rvFd8rvld8cT3jiASuZyDw/sYWWGuHmCryFMpm44F3OLYwFbnb2cc80G7aAjO4EFcEalGJnEF2Og20m7bIGeSTm4F20xamAjPYEK4iZ5DPGQde+1gCtShwpKhFJaaKbwa4nHl/7vixCR9hFw4ySlJgxVB4AkePwnOxYrjGKeEqQkUeycXQKEklhoqpYqnIGVycAShJJY4KVxEqrgiUpIvjQUkqMVUsFd8MHFcy+EPJLY4KT4FZ56WQ563ogT+WXCIrl6NE4c8lt5gpMNEsXi22ClNxVLiKUHFF+E/FUKEzcJ2B6wxcZ+A6A9cZuM7AdQahMwidQegMQmcQOoPQGYTOIHQGoTMIncHVGVydwdUZXJ3B1RlcncHVGVydwdUZXJkBXlzp+BhC+26LqWKpQMcB2ISPsAuH8CXjudzjITyFcYAOgcMIiCti4jAuxFAxVSwVW4WpOCrSJx9LDLyjstZu6aKsrcJUHBW5Lfk8YqBtuMUVkSWqhZwYeItli6ViqzAVR4WrCBVXJmp6YpieGKYnhukaoEShgOOVli1yBvkUZeAFly1CxRWBEjUwNEpUialiqdgqTMVR4SowA5xiKFFPoCq9rUdVGjjfUJVKbBWm4sg2um6969a7bn3o1qMqlZgqdOu1Km2tSlur0taqtLUqba1KW6vS1qqE/mUfCAZqT4mjIn0m1g21Z2LWqD0Q6F9uMVRMFUvFVmEqjgr45MmHLuUWQ8VUAZ8FsVWYiqMC104XIlRcEe/a6YmhYqpYKrYKUxGvBWhkM/PD7w5R4Z9D9jGM7GQuXEQc3YEwFUfF12uEA81eo4e3EWUqn/gNtD23mCrWa1Qa2fRcaMRDdGIQb+NXmAoHcRLpZnQzuhndjG5GN6Pboduh26Hboduh26HboRvKDm6yoo25xRXh6N/CEvtQgVXFaYAaVGKrQPcYTNGfVCI/lh3bi/6kElcE+pPwZeE1QJfIGeRDsYEG6BZbRX7denyEXTiELxlf8x7DAd6oMXg2htZnx017tD63uBRofW6RZyieVaD1ucVSsVWYCszgQLiKUJFtT/DEK/gfD+Fse5rgJbyFTfgIu3AIXzJe0/94CIvvFF9cDS2HwEEHxFHhKkLFFbF+KoaKqWKp2Cp0BihKeNiCXukWoQIzyAzg7ZwthoqcAZ5h4AWdLbYKF/FetwUewlN4CW9hEz7CLozjwKmBq6AncBVUYqiYKpaKrcJUYCVhinJUIlRgBvlhgbd4thgq8lzC4r8/xQnewiZ8hF0Y3jj3cDH0BC6GSqR39puPg0JUYqnA0ePUwcVQiaMijx73//EXuVtcEbgYMpwGKEf1v/wN8OrCV38K8cO5juimbjFUTBVLxVaR08f9dXRTt3AVoSJngHvl6KZuMVTkDLIde6CbusVWgRksiKPCVYQKzCBPErwJ1HHf2/EFDLet0VndwlQcFfC5EOmDW8Pouc4/+/E9MkkffFCi57rFVLFU5Axw2xQ91y2OCleBGeB4UGXw4YpWa8dNPrRaO+7rodXaA6aoMiVMxVHhKkLFFYHvabh7hxeLtpCTFX/Su4WpOCpcRaiAKQ4bRanEUIHDxoKgKJXYKkzFUeEqQsUVgaJUYqjQGbjOANdIuCOIFu4WR4WrCBVXBEoTLqjRw91iqlgqMAODMBVHBWaAWaM0XZxVKE1PoDTh9iBauVt8MwhcQ6GZu8VWYSqOClcRKi4FerpbDBVTxVKxVZiKo8JVhAqdwdAZDJ3B0BkMncHQGQydwdAZDJ3B0BkMncHUGUydwdQZTJ3B1BlMncHUGUydwdQZTJ3B0hksncHSGSydwdIZLJ3B0hksncHCDAbEFbF/KoYKXO6Bl/AWNuEj7MIhfMkof49xgBMCZe0JHMb7z0LFFXF+KoaKqWKpwHJtCN0W10VxXRSfKpYKbItBmIqjwlXoieE6g9ATI/TECD0xQk+M0BMjTOYWR4Wr0BMjrszt/lQMFToDLVGhJSq0RIWWqNASFVqi4sqpeX8/FUPFVLE4t/vbKkyFzOBqibpaoq6WqKsl6mqJulqi7pDz4L4S9YSpOCrkPLivRD0hu3C1RF0tUVdL1NUSdbVEXS1RV0vU1RJ1p5wHd+ouLN2FpbuwdBdeiToQWwVm4BBHhasIFTkD3L5Fa3iLoWKqWCq2ClNxVOQMcF8WreEt8Ag32SYLBfq/AzfH0f/dwlQcFbrZppttutnnp2KomCr0hD+62Uc3++hmH93soye8Fr7rerq5nm6upxvKG272o8u7havAgmLdUN4GZo3yVmKomCqWiq3CVBwVLgLXWbgTgEbwFlPFUrFVmAr44KRAESsRKnCk35XexJ+DbzFU4EgvxFKxVZiKo8JVhIorAkWsxFChMxg6g6EzGDqDoTMYOoOhMxg6g6kzmDqDqTOYOoOpM5g6g6kzmDqDqTNAEcsnGRPN45H3yyaax1tMFUvFVmEqjgpXESquiK0zwEurN3gKL+HPPhtfJxrHi4/w5533h+Z7ee7jS8bb9h4P4Sm8hLewCR9h8TXxRc2aT2D9MFNUpnw4MdH23cJVhAjUn4m04PJqYm9Rf0ocFa4iVFwRqD95c3qin7vFVLFUbBWm4qhwFZiBQ1wRuLwqMVRgBjhTcHlVIm9NYj3wVyseH2EXDuHbjB7vYhz8gsjpZv/6xEttS6CIlEBrL3gKL+EtbMJH2IVD+JLx/O2x+E7xneI7xXeK7xTfKb5TfKf4LvFd4rvEd4nvEt8lvkt8l/gu8V3iizqR95Ynurhb4Ly4EEtFnpn7DWAqjgpXESquiCwYLYaKqWKp0BngOijv7E/8AfsWaLUGh/Alv05vMDwmBEbCmYqqgYVB0Xh8ybiYcfAQnsLpADeUmMcmfIRdOIQvGcXl8RCewuIb4ovqgY8ANGLHxtGgRmxMGzWixFKxVWC0PEvQex15p31OxL7EVLFUbBWmAosyIVxFqLgiUERKDBVTxVKB4wkIU3FUuArMYEFcEbgSyQalia7sFlPFUrFVmIqjwlWEiiti6Qy+wjJ/mPRXWJqX8P4YW/gVluYj7B87OIQv+SsszUN4Ci/hLWzCR1h8t/iiauSDkImG7DAcDWqDYdqoDSVcRYjAVUU++5jow46DkwNXFSWOClcRKq4IlIh83DHRid1iqlgqtgpTcVS4CswA0UGteALFosRQgRngTEG9KPFtzcAZjRpxsNSoESWmCvw8tgc1osS3t7hMzvbqZheOZvRQR/7ywESndOQDnpmd0hPXe9ko3ezCOdIBX/JXGpq/szNf4zKzRbp5CW9hEz7CLhzCl5x/8KZYfKf4IvOOw0ey88HVXEh23sOceI9vi6FiqsBoWA58X3AcN74vPIHrgBJDxVSxVORuOLYG1wEljgpXESquCFwHlBgqMAOsDq4DSmwVpgIzwJmCrJfIGWSTykSncwncDykxVEwVS8VWYSqOClehM/jqw8T1cDY6Nw/h7+zAxXB2OTdv4e+sxIV7tjg3u3AIX3L8hIfwFF7CW1h8Q3zx7SMgUBsCM0VtwAUIepRbmIqjAqNlCUG/cWTD/0S/cYutwlQcFa4idyMf1U00HZfA9UOJoWKqWCq2ClOBGRwIVxEqrghcP+RrnSaalVtgBgsCPu9n0udiqXCVUCJE4N5DPgWcaEluYSqOClcRKq4I1JISQ8VUoTPIj39ctmdHcvMR/k5lXJ1nO3LzJX9VZOKLQfYiN0/hJbyFTfgIu3AIX/IR3yO+WR/u7wlPgZlmFbg/7GBeJZTIq4QWQwVGMwiMhl3HKy5KXBF4yUWJoWKqWCmQCbzoooSpOCpcRai4Iu5PBWawIaaKpWKrwAxwptyjImcwcH7k/YcWlwL9wy1yBrieQf9wi6ViqzAVR4WrCBVXxPip0BnkJQeu27KxuHkLf2cmrsayq7jZhb8z87wxLzkvOYqH8BRewlvYhI+wC4vvFN+FlcUBLKzfgcD6OYSrCBVXxMZoFyJHwwUiXoHcwlWEiisirzVa5G7gVilegdxiqdgqTMVR4SpCBY4nY4BXILcYKqYKzAArilpSAseDvUddwA099PS2OCowNywiKkaJKwIVo8RQMVUsFVuFqTgqdAZfxZj4fp9tvcVfvWj+zlhDcL9q0byEs4ZjzPx6UXyEXTiEb3N2ADcP4Sm8hLewCefKZn/zRCfvxUURWnkvrurQy9tiqzAVGC03Gv25F3fo0KDbYqnYKkzFUZG7gTuzaNFtcUXkN40WQ8VUsVRsFZjBhjgqXEWowAywovunImeAawK06LZYKraKnAFu5h1UjBKuIlRcEagYJYaKqWKp2Cp0Bnl1gS912dzbHMLfmYkvcdna2zyEvzPTcYj5JwKLt7AJH2EXDuFLzi8kxUNYfF18UW1wOxHtuRe3E9Gee3GfEO25LaaKpQKjYddxRYGqgFbbFkPFVLFUbBW5G7jnh7cft3AVoeJSoF+3xVAxVeB4AmKrMBVHBWawIEIEaglu5qErt8VSsVWYiqMCPgciVOBIcxfQldsCM8BEUX9KYAYXYqvIGeAuE/p1W+QMcKcN/botcga4a4Z+3RY5A1xjoF+3Rc4AV0zo122BGeCwUX9KYAY4bNSfEpgBDhv1pwRmgMNG/SmBGeCwUX9K5AxwTwfNuy1yBsgPmndb5AxQDdC82yI/FDGb/GJTvIS3sAkfYXhj+XCtUuKKwLUKbvqgh7fFVLFUbBWm4qhwFaHiinCdgesMcOXjOB5c3+CuEfpxL276oB+3BGpRiaFiqtDjCT2e0OMJPZ7Q4wk9ntDjuXo8V4/n6opencHVGaBK4bDRW/sOG7217xDQW9tiqdgqTIUcD3prW4QKOR701rYYKqaKpWKrMBU6g6EzQC16h42K8w576vFMPR5UnBKuIlTo8Sw9nqXHs/R4lh7P0uNZejxLj2fp8Sxd0aUz2DoD1JV32K964LC3Hs/W49lyxof9VOgZYnqG4OolfxPhT2wVeRGB2eDi5bELBxlVArc4A7UAtwIDf7P4/Q9H2IW/keq/v+S8HCn+auCbXV6OFC/hLWzCR9iFQ/iS8/5osfiG+KIm5K9aTLS5Xty7RJvrxR09tLm2GCqmCoyGTcZVSGCPcBUCgZbVFkPFVLFU5G7gNiJaVlscFa4iVFwRSH6JoQIzcIilYqswFZjBhHAVmMGGuCJQE0oMFVPFUrFVmIqjwlXoDPJGB7YnO1abh3CeHVj0fMJavIXzrMTB5xPWYhcO4UvOJ6zFQ3gKL+EtLL5bfFE18pdLJvpQL+4Xow/1XhwaakMJU3FU5PNg3PzMntKvJRFiqdgqTMVR4Sry8S9ui2ZPaYssEi2GiqliqdgqTAWOB7uF64sSoeKKCMwAZ0oMFZgBVieWCszgDZAzGFi3fKjyMvVdXjSH8CXn3ZPiITyFl/AWNmHxveKbd09+A7HM2ycQK3tPKYaKqWKp2CpMxVHhKjCDBXFFjJ+KoWKqWCImfsYhhoqpYqnYKkwFZh0QLgKNFXkHc/3QWVHiqMifyV93XT80V5S4IjL8FyNn+IuncO4yhs3wF5tw7jLmns9XikP4kvP5SvEQnsJLeAubsPia+Oadjt/ERqNK5GPx9UOVyBue64cqUeKocBGoBRNDI/ETa4PElzAVR4WrCBW5G3mTb/2Q+BJDxVSxVGwVpuKowAwORKi4Iu5PBWaAM+VOFZgBVvRiBu9nTMVR4SpCxaUYSH+JoWKqWCq2ir8ZrHy2tfJFvs0u/P369O/995f8Bb95fLzBU3gJb2ETPsIuHMKXPH/C4jvFF/Uh35ewsv/za9WGyPXLJ4UrO0AphoqpIkfLp51roD7kTcU1UB+eQPtViaFiqlgqcjc2Vho9WCWOClcRKq4I+6kYKjCDAbFUbBWmAjPADpuLwB9+woLi7z493sImjJECwlWEiisCdaTEUDFVLBVbhanQGbjOwHUGrjMInUHoDEJnEDqD0BmEziB0BqgwG+cnKozhXEOFeQIVpsRQMVUsFVuFqTgqXIXO4P2C3sevofTxEMYvdYCX8BbO36u54CPswiF8yXgxwuMhPIWX8BYW3yG+AyuLyeE6I+/xronrjHw99Jq4zihhKo4KjJZ5eI2deYdvvc7OEluFqTgqXAV2A7NGhXkCFabEUDFVLBVbhanADAzCVYSKKwIV5uAsQIUpkTPIO8ZrosKU2CpMxVHhKkLFFYGrlRJDhc7gfdsBb2ETxkUg2IVDGN8yknFL9PEQnsJLeAub8BF24RAW3xBfVJuDExc15WBrUFMOzkjUlBJXBGpKCYwWEBgNPqgPJULFpVi4AikxVKDpeEAsFVuFqTgqXEWouCLw/SOfEyz0lbaYKpYKzGBCmArMYEFcEfjOUgLd1QYxVeBID8RWYSrgg+ngO0uJUHFF4GqlxFAxVSwVW4Wp0BksncHSGSydwdYZbJ3B1hlsncHWGWydwdYZbJ3B1hlsnQHqT96JXQv1p8RUsVRsFaYif5MKI7+6gv/h1ZUnpoqlAiPjhD+SmHVChSYG1zX4HEXHaYupAr8fgHMc1zU1gKk4KnQGrjNwnUFoZkMzi+uaEkuFziDUFMUlEB8UlxJDBQ5uQywVW4WpSJ9AsFCQSoSKS7FRkPKW7tooO3mfbW2UnRKmAj4B4SpCxRWBslNiqJgqMIMLsVWYiqPCVYSKKwIFqQR+hWRA5AB5F3dt1JMSVwTqSYmhYqrIQ8ibsGu/X1V5wlQcFa4iVFwRqCclMANsI+pJiaViqzAVR4XLBqOelLgiUE9KYOcWhMmK4kKlhKsIFTg4nHxHFxFlo8RWAR/MAFckJVwFfHBWHd1G12103UbXGbjOwHUGKCgljgo9kVxPJNcZhJqiUuDCeOMbUImjwlVgaJzK73sODvtOFUtF/oYMruSyW5XiqPAU2J/3PecNcCkMZaPEUDFVLBVbhak4KlyFzMCGmmalGNmovNCI2sJU4OA2hKsIFVdEVoqB2znoR20xVSwVmMGBgA8mOkPFFbHgExBDxVSxVGwVpuKowAwuRKi4IvZPxVAxVSwVW0UOnV3LK7tUJ/7kwcouVYqlYqswFUdFHsLAlliouCLyOqTFUDFVLBVbBWaAbTxHhasIFVeE/1QM2WCfKpaKrQI7tyCurGj8VAwVUwUODidf6CKGqwgV8MEM7k/FUAEfnFVXt/HqNl7dxqszuDqDqzO4lwKNrS2GiqliqTAVuC/1xBWBslFiqMDQFwJ3nxbEUeEq8hCyL3sdlI0nUDZK5CHgSciZcj/zzKViq9AZTJ3B1BnMUCF3VM/6qRgqdAZLTVEp8DTjoFKUuCJQKfCc46BSlJgqloo8Q/CcI9tbKY4KV4EZ5Kl8UFDwbOSgoJRYKuATEKbiqHAVoeKKQEEpgRngDEFBKbFUbBWm4qhwFSEClQJPQPIts99rFSCOClcRKq4IlI0SeQh4nnJQNkosFVuFqTgqXEWowAywjSgoJYaKqWKp2CpMNhgFpYSrCApHDclfPliOSoEVzbZWClNxVODg8uTLl83WImZbK8VUAR/MANchJUwFfALCdYBQIdvoU2cwdQZTZ4DrkBJbhak4KnQGU01RKd6K4rtMia3CVGDoC4FnfjhSfGMpMVTkIeCJkaNslNgq8hDwhMX30QFcRajQGZjOwHQG+PpSYqnYKkyFzsDUFJUCHyyOSlFiqcDBbQhTcVS4ijxD8GTKcenxBC49SgwVmAFOZRQUPD5xFJQSrgI+OB4UlCdQUEoMFVPFUrFVYAY4Q1BQSriKUHFFoKCUGCqmihwaDy0cFxjZ5r4CxaHEUDFVLBVbRR4CHmcEykYJVxEqrggUlBJDxVSBGRjEVmEqjgpXESouNzhQUEoMFVMFdm5BOFc08F2mxBWB7zIlcHAHQhcR31hKHBXwwQxwHVLiisB1SDb0r9i6jVu3ces2bp3B1hlsnQGuQ0qECj2RTE8k0xmYmqJS4Fs1elBbhIorApceeNwU0n+2QvrPVkj/2UKDKl6VtNCh2iJU5CEc/MzrP3tiqJgqdAauM3CdgR8VriJUXBGhMwg1RaXAU6lApSjhKnBwiAwqxROoFCWGijxD8PgncOlRYqswFZgBTmUUFDwUuSgoJYYK+ATEUrFVmIqjwlWECswgz5CLglJiqJgqloqtwlQcEagUeGR0cYGBJz4XxaGEqTgqXEWoyEPId2AsNKa2GCqmiqViqzAVRwVmYBCh4opAQSkxVEwVSzYYBaWEqTgqsHNZRy8qxVtRfJcpsVRsFTi4A6GLiG8sT6BslIAPZoDrkBJLBXxwVh3dxqPbeHQbj87g6AxcZ4DrkBJThZ5IrieS6wxcTfEwF48H8F7UFlPFUoGhcSrj913iiVBxRaBs4GkSmlJbTBV5CHjOhPei9gCm4qjQGVydgXTK7590yu+fdMrvn3TK7590ym+8F7XFUZH7k0+TNppOWwwVOLgNsVRsFaYiz5B8gLR/uPQoESquCBSUfM600aiK981tNKq2MBXwCQhXESquCBSUEkPFVIEZYKlQUEqYiqPCVYSKKwIFpUQOnY87NppXx8XCoziUuCJwgVFiqJgq8hAutgRlo4SpOCpcRai4IlBQSmAG2EYUlBJLxVZhKo4Klw1GQSlxRaCglMDOLQiTFcV3mRKuIlTg4HDyhS4ivrGU2CrggxngOqSEq4APzqrQbby6jVe38eoMrs7g6gxwHVLiqNAT6eqJdGUG6HBtgaEvxDc02nr2wIvJSriKUHFF4OVkJYaK2b9Jtcf7nZontgpTcVS4ilBxReA3Z/LTbOfrTidakHa+75TCVBwVONI3Wqi4ItZPxVAxVSwV+D27gDAVR4WrCBVXxP6pGCqmCpMF2Xqk21WEiivC9EhNj9T0SE2P1LYKU3FU6JGaHqnpkR490qNHevRIz1Kha310rd/v6mJBjh6p/1QMFVOFHqnrkboeqeuRup5VrmeV61kVeqShRxp6pKFHGnqkoUcaelaFrnXoWr/f4sWCXD3Sq/m5mp+r+bl6pFeP9OqRXjnSbImlGCqmCjnS+dsqTMVR4SpChZxVc/xUDBXpk7eONvpgWxwVrgJHmh9G871r4AcxVSwVWNENYSqOCqyoQYQOcEXgN39L6AyWzmDpDFCRSpiKo8JV6Ay2mm6cLgdiqzAVODis9StCT4SKK+IVIaz1K0JPTBVLRc5gYG55iTPzwehGW2yLKyIvcebAyZeXOC2miqViqzAVRwVmgDPkhIorAkWoxFAxVSwVWwWGxukSGAALH1PFUrFVmIqjAoeALYlQcUXcn4qhYqpYKrYKzADbiOpSwlWEikuBftoWgxuMftoWS8VWgXPUIS5X9L1/tcRQMVXk0PnUd793rWIR38tWS4SK9JmYAd63WmKoSJ98ALvRKFsDzK3CVOgMps5g6gxwifMELnFKDBVThc5gqel7KxIW5L0VCeK9FemJoQIHtyCyIi2MhrcHlHAVeQj5dHmjz7UEykYJLCJ88BvCbwD8hnCJrUJnYDoD0xng2qXEFYFrlxJDhc7gqCkqxXwiVFwRqBT5nGmjBbbFVLFU5BkyEQxcrpQ4KlxFzmDhVEZBWTgTUVBKLBXps3COoqCUOCpcRai4IlBQSmAGOENQUEosFVuFqTgqXEVQbFQKnJZodJ3YHzS6tnAVoeKKQNkogUMIiKliqdgqTMVR4SpCBWaQ24hG1xZDxVSxVGwVxg3eKCglXEWIQA3J58EbLbC1omurMBVHRQ6dT303Gl1rEfdQMVWkz8YMcB1SwlSkTz6A3Wh07QF0G7duo+kMTGdgOgNch5TYKvREMj2RTGdgavreq4hdwLecEluFqcDB4VR+b1zEIuLXb0oMFXkI+XR5o9G1xVaBRcT+vLc0vgFcRajQGYTOIHQG7y2NTywVW4Wp0BmEmqJSbCwiKkWJpQIHh8igUpQ4KlxFniG49kcL7BNogW0xVOQMcK1s7xXwA+KocBXpk88Ot6GgPIGCUmKomCqWiq0CM1gQR4WrCBVXBApKiaFiqsDQBoEBcuHR6NpiqJgqloqtAocQEEeFqwgVVwQKSomhYqrADLCNKCglTMVR4SpCxZUNRkEpMVRMFThHHcJlRfFdpsQVge8yJXLog5Pv6CLiG0uJoyJ9DmaA65ASVwSuQw7OKtdtdN1G1210nYHrDFxngOuQEqFCT6TQEyl0BqGm7w3QWJD3BugnQsUVgUuPg1P5vecZo733PD9hKvIQ8unyRqNri1CBRUyfg6c8GODgKU+JqWKp2CpMxVHhKkLFFTF0BkNNUSnOE0eFq8DBBcQVgUpRYqjIMySfLm+0wLbYKkxFziBfQrjR6IqXeG40urYYKtInnx3ug4JSYqswFUeFqwgVmEGeIeiHbTFUTBVLxVZhKo4IVArH6YILDMfCoziUMBVHhasIFTgEbAnKRomhYqpYKrYKU3FUYAbYRhSUElcECkqJoWKqWLLBKCglTMVRgXM06yhaYGtF8V2mxFKxVeTQgZMvdBHxjeUJlI0S6ROYAa5DSiwV6YPnGGh07QF0G69u49UZXJkBul5bDBVTxVKxVZgKMXX8dQk8hcObXVtMFUsFDm5B+D/1Vyy2v78h8cQVgbKBp8todG0xVWARDWLrAKbiqNAZTJ3B1BngL9WUGCqmiqVCZ7DUFJUCD7vRAttiqMDB4WdQKUpsFaYizxA8XUYLbItQcUWgoOTf+NhodMWLsjYaXVuYivTBs0NHQSkRKq4IFJQSQ8VUgRngDEFBKWEqjgpXESquCBSUEhgapwsuMPAIGI2uLa4IXGCUGCqmChwCtgRlo4SpOCpcRai4IlBQSmAG2EYUlBJLxVZhKo4Klw1GQSlxKdAp2wLnqEMYVxQtsC1cRaj4hl54OIxG17eIaHRtsVVY/gxmkNchLVxFpJgQso1odG0xVOgMps5g6gxwHVLiqHAVoUJnsNQUlQIfLCF/7WrjvastXAUOLk/lkL92tUP+2tUO+WtXG42ueKfTRqNri6MCiwif99eu3gBXxPtrV0/oDExnYDqD99eunjAVR4Wr0BkcNc1KgXdmbbTAtjAVOLiAcBWh4orA37HCAyS0wLaYKpaKnAGeM6HRdeEpAhpdW1wR+LtVeDKEF7O2mCqWiq3CVBwVmAHOkAgVV8T9qRgqpoqlYv+f3t5oR3LeSNB9F1/7QmQEI8h9lcVg4J2dPTBgeAaemQUOBn73oyIrqa+znVGsFOvc2Iz+u4NKifxEkZ8oBiN1by5DdJUx7z9E1xkIA2VQGBiD8RPqCCqDhiAdDBKDzEAYKINxBG0ExsAZVAYNQT4YpOsC9x1cr0AYKIPRRn0EDWdUDgaJQWbQU48JryG6Pk6iOIPKoNczVpOG6DqDxKDXM9aZhuj6SKC8jMrLqDwC5REoj0AbgnIwYEMqbEiFR1BYaR96yFgzGgqsjCWfocDOIDHIDISBMigMOqvGU2j7/G7mZ1AZNASf3838DBKDzEAYjPemRtlRriiPnzlOwOdX8D6DxCAzEAbKoDAwBs6gMuARNB5B4xE0HkHjETQeQeMRNB5B4xE0HsHYYq3PQpWhyc4gMcgMxhH4CMYFzSNwBpXB+KW1BwM6jyAxGL+0jUCQYHxa7xEUBjyCxCNIPILxWPQZjE/rPYLEIDPgEWRW2ocn0hf0ytBkH8GAziPoP07GvxnQeQTCQBn0y9hX0MrQZGfgDCqDcQTagwGdvvhTxjawM1AGox4bgTFwBpVBQzCg8wgSg3EEo4UM6DwCZVAYGANnUBk0BAM6MprLGKvoOPFjrPIIKoOGYIxVHkFi0H+Cjkvy+dnNz0AZFAbGwBlUBg3B4I6Oyzi48wgyA2GgDAoDwwUe3HkElUFDMFAjo28PoHye0QGUR2AMnMH4cb3xDTP28ySOvV9nIAzGTygjKAyMwTiJNoLKBLiMw5mdAY8g8QgSj2CMYh5BYWAMnAGPILPSQYq+SlXSmEB5BIWBMRipe1NOn5/qHtnGNMkjyAzGT6gjUAaFwfgJo57x8PNIUBk0BMojUB6B8gjGY9EjUAaFgTHgESgrHaR4BMJAGfQf11fdyvBfZ+AMKoPeQvoKWkljFPMIEoPMYBzBaMoDKGW0xAGUR1AZjHpGGx1AeQSJQWYgDJRBYTCOYLSQAZRHUBk0BAMojyAxyAyEwUg9mssYh9g48QMOjyAzEAbKoDDoP2HcNYfYOoPKoF3BEFtnkBhkBsJgHIGMoDAwBs6gMmgIBlDGBc4DKI8gMxAG48qlEdTrjI79Xh/BwMYjSAzGj9MR4CQOl3UGzmD8hHEEYxzyGYxxyCMYJ9FGgMs49oidgTLgEQiPQHgEYxzyCBoCPRgkBjwCZaVj6NEXF8pwWaUvc5Xhsj6CMfR4BIlBZiAMlMGg8rjaYwLlETiDyqAhGLMpjyAxyAx6PWN0m8fDzyNwBpXB+KWjUYxHnPwZCANl0C+Wj5M4sPEInEE/oz7aaBdKHgm6UDKDxIBHUHkElUdQCwNj4AwqAx5BY6UDKD769gDKIzAG48eNLjOA8gjaFQyXdQa9ufS5wDJc1hkIA2UwjsBGMOrxETQEAxuPYNRTR5AZCANlUBgYA2cwjqCNoCEYdHkEiUFmIAyUQWHQU/e1tTKMVelra2UYqzNQBoWBMXAG/SfUcUkGNj6DgY1HkBhkBsJAGRQG4wjGZRx0eQSVQUMw6PIIEoOMCzzo8giUQWEwrlznwdjb9XFGxzjkEWQGwmD8uNH4jCdxjEMeQUMwxiF1HMEYhzyCzGDUM1qV8zI6L6PzMjqPwHkEziMY45BHkBiwIVU2pMojqKx0PLHU0SzHCOURJAaZQU/dF+fKcFlnUBgYgw9W+XgS7y7rFbQr6Hu7XkFikBkIA2VQGPST2JeFylBeH8EAyiNIDPovbSPBAMojUAaFwQeVy7gDduX1CiqDhqDPlMwgMcgMhME4ozICZ1AZNARjuPIIEoPxe3QEI1sZwchmI2gIBkMewcjmI8gMxnkbRz0Y8ggKg/F72gicQWXQEAyGPILEIDP4OALta3hlWK4zKAyMgTOoDPqVG0+UY9fXx3kbQHkEPKM26hmtyoyBM6gMGoKOGj1GE+uomUFmIAzGLx1H4IWBMRhHMC6jVwYNQR1HMH52TQwyg3EEo1XVcQTjAtdxBOOSdO5oGme0PxnNoCLo3NE0zkHnzgyEgTLo9aRxDsZw5bMpj+HKCIb/OoPEQBj07jwmILryegWVwWgU/Qi68noFiUFmIAyUQWFgDBxBH4don2gvQ2ydQWYgDMap0hEUBsbAGfRfOqYduxk7gz6hMoPEIDMQBsqgMDAGvZ6+ZFW6/3oF45eO66OZgTBQBuOXjtRqDJxBZdAQlINB/6V5XPq+mjwDYaAMCgNj4Awqg4agPwzNYPxSH4EyKAyMwfildQSVQUMwUPMI+i/9TNAfk2YgDJRBYWAMnEFFMIDyeYEHUB6BMFAGhYExOOsZY5puzD6KbRY/BjePYrqK+SqetdbRYz7g8iiWq2hX0a9ifRTHJrA6Llc3YM8gjaAwMAbj/HwmqAwagsGXR5AYZAbCQBkUBsaAR5B4BIlHkHkEmUeQeQSZR5B5BIMvfc22jB1hZ9AQ9AHLDMYZHQn6g9IMhIEyKAyMgTOoDMYRdPYNUXYGiUFmMI6gjEAZFAbGwHHpB3keQUMwyPMIEoPMQBiwvRW2tzGU6QuTZfi0j8AOBqMeH8Gop45AGCiDwmD80jYCZ1AZNASDPGORZPi0Opbehk87A2GgDAoDY+AMKoOGYAxyHgGP4INJY2KgS7ePol7Fs+7xRN93nH0U/SqetY6n1a7gfhY/SPQopquYr6JcRb2K5SraVfSreNXWZm1DqdWxhDnEWR2327GRrMrnX3MGlUFDkEa2NoKebQyHxnaxM3AGlUFDMEYzj6Cf+7F8NyzaGQgDZVAYGANnUBmM39MvoQ/aPILEIDMYRyAjUAbjCMoIxhGMUzVo8wgqg4Zg0OYRJAaZgTBQBoUBj6AvD427endtZ7ld5a7MjXto32t2ljPKH0wfd+3u385yQdlQdpQryu0q96HNo5xQziijXkO9gy1jSW4ItDrWs8aGsjrWCsaGsjMQBsqgZxsLVcOm1bFQNWzaGWQGwkAZFAb9aoxFp2HTzqAyaAjawSAxyAyEwTiC0b7Hw9AjMAbOYBzBOKOtXcGwaXUsHIx9Z2eQGQgDZVAYGANn0I9grAwN6fYRpINBYpAZCANlUBh8NM2x1t1t3FmuKLer3Ec6j3JCedSgIxi/pIygMhijpt646nhaegSJQWYgDJRBYWAMHMGgyFiIGpvM6ljsGZvMzkAYKIPCwBg4g/FL6wgagjFmeQSJwTiCNgJhoAwKA2PgDCqDfgRjEWbsRatjEaaO0cwjyAyEgTIoDAzX1Hi1jVd7jGY+g8GiR5AYZAbCQBmARUPRnUFD8Empz2D80jwCsKiSRfWTRZ9Br8c/E1QGDcFg0VjfqQ00rC0zEAY8gsYjaDyCTxZ9BpVBu4KxZe0MEgNh0FOPRaWh6M6gMhg/rjfloejOIDHIDEZzqSNQBoWBMRhH0NvoEHG1v5ZVhog7g8yg1zOWJoaIO4PCwBg4g8qgIRiDnPGYO3zdGWQGwkAZFAbGwBEM7owFoiHi6ljfGSLuDIyBM6gMGoJBl7G6MkTcGWQGwkAZFAbGwBmMIxiXcdDlMxh0eQSJQWYgDBQXeNDlERgDZzDaaCf52Iv2cUYHNh6BMigMRurR+JwncWDjESQGvZ6xVjNc3Bkog17PWCkZLu5MwMtYeRkrj6DxCBqPYADlEQgDNqTGhtR4BO2q1I5Biv6YYseRGQgDZTB+XB7B9cxiQ7J9BOlg0OvpCyo2JNsZCINxEnUEhQmMgTPgESQeQeYRfD41fQaZgTBQBjyCzEoHKdo4iYMUjyAzGD/OR6AMCgNj0OvpKz82JNsZNARjIPMIxhGM69OBUo5xoB0oMzAG3oM0gsqgIehAmUFikBkIg3EEo4WUwsAYOIPKoCGwg0FiMFKP5mIjwTjx1hD4wSAxyAyEwfgJ45J4YWAMnEFl0BDUg0FiMI5gXMYqDJRBYWAMnEHFBa4NQTsYJAajjdoIDGe0OYPKoF1BOkbqNgKcxCHZzqAw6PX0lSwbku0MKoNeTx+625BsHwlSYpAZ8AgSjyDxCJIxcAaVARrSMG5nwEo7KUpfWLOxF+2YzbUh2c6gMmgIOjZmMLKN0yvGYGQblXYElL7uYml09P7gb2OP2Bk4g3EEdQQNwejojyChntHRH/9FGCiDwqA/S45WNfaInUFl0BAYz4EJfrYpA54dG9lGcxm9Po2WOHp9Hv9l9PpHkBkIA2VQGBiDfkbzaJaj1z+ChmD0+jwaxej1efy40evz+Amj1+dxrrvSNkYONnaCnYExGI/hIxh9O4+TOPp2Hle7ZQbCQBkUBsbAGYxfOi7wQMAIhjA7g3EEbQT9CPrbKDaE2dInsW0Is6UbKDZ2glX7DIyBI+irO2MOy8Z+rzPIDEY9OgJl0H9pn9e1PBDwCJxB/6V9KteGPfsIBgIeQf+lY1g07NkZCANlUBj0I9Dx4wYpHkFl0BD0occMEoPMQBiMemQEve2UcRV0/JtxdlQYKIN+1H321sbmrzMYRz3O26DLI2gIBl10nLdBl0eQGQgDZVAYGINxBKPxjWHEI2gIxjDiESQGmYHg7NioZ1wscwaVQUMwuPPZEgd3HkFmIAx6r/88VX2NeAbGwBlUBg1BV2lnkBj0M/r548aY4hEYA2fQf2kZDWmMKT6DwZ1HkBj03iijhfQdl2agDAoDY+AMKoN2BcOeLX1+x4Y9OwNlMH6pjsAYOIPxSz9TNwRj6NEnkW14tTPIDMYR+AiUQWFgDJxBZdAQDO70vcxseLUzyAyEgTIoDPq5HnemLtmmIUJY3zA2jdVe6xvGXkFmIAyUQWFgDPo1HWOKsa/sDBqC7rPMoB/BGFN0/fYKhIEyKAyMgTOoDBqCvqQzpC0bkm3pb0jYkGxnUBgYA2dQGTQEg0h9kt+GizuDzEAY9F86hvvS5f4ZGANnUBk0BP3N5hkkBplB/6VjtDFc3Bk4g/5Lx616uLiPYIyEHsH4paNRjJHQIxi/dPTGwapHUBiMIxgtZLDqEVQGDcFg1SNIDDKDcQSjO48x0iMoDIyBM6gMRqvqP3uIuZ+tSg+0Kj2UQWFgDJxBZYBWNZTdz+YylN0ZZAbCAK2qK7tXYAycQWWAVjWU3RkkBmhVY2fOc8L+73/8w3ks//2HQaiPyeAxLOoln6U6S+1RGkOhXuq/82MadwyCeklmSWep1/GhIY0hUS/5LNX599qjNB6yPqYMNc1SnqVZh846xljpY4JtDJR6adRRzt+q/beOmuzxaz5K49f0UpqlPEujJjszlI8M6Tp7dsX98cBnqdfSZ+p6LR+zbONG0uT8d4489fF3PuZDx9/ppTRLeZZklnSWyizZo/R5vj6OsH7UNM7zx1rXOM9Wz//ScOXTvPJpXvk0r3yaVz7NK58e5+pj6WWcq17qR/ixljGufC+VWRp1+OPK+8cRfvSa//78uR/LZOPn9pLMks7SSHZ8/MPUz+JARfv4g/zyx6bezsd5Nv/7+Sd/+bd/+dN//vnf/vrP//m3f/3Xj//4+IP/+MP/+J///Yd//9Pf/vWv//mH//HX//rLX/74h//7p7/8V/9L//Hvf/pr/////NPfzv96HtC//vV/n/9/Jvw/f/7Lv36U/v7H618fr//pmKns//pjSmomOKctVlN8fCP4M8XHR2evFPLrUeQghTwO4sTsleBs7IsJLD3OwXmLnQnOIcsvCfR1gtTX2nuGj9dRX6YowY+wPM+DubxMEZ3K/hWOzxNR9eWp9OCC9q2BxwU9R2lXiqK/pKh3r0b4M9rjZ3x80+7lz0hBjg+/8TPHh4I4c1j5NUWKrunHhPjnNS35ZYqgXbk/LmkVXA7X5QxVHz/jXGl/nSFomvlo84qe86Yzh/7arFLQNOsHh8ZBNH99EBZc0u52jEZxnsyrcdf23vXw19cjahX+scIwWoUf7WWKFhHv407/STxNr1Lk4+41zen2Nc357jX9ePR6laH1T3T0FGfxat7ng836D0kfU2GfP6Sklz8kaJx969TRso6XCWJUNJuNIsnLK+r32R3l0L6V1aDe+QT4+j7YwttQnl0EZ+OcwPslh0Snoz6uyLmOhgxlvWF0Y2Y0jIJe9twwJGierQ/LP3M0AzCefklwHPkaWZyTYlcO+8Y1mb1EeQt4viYStM9zgv9xNs7ZedwQn86oBPg81yzaTGJuPJJfB1riG1pHvds64t/S5mjrLJu8/C0aDTz7R4A/wVEbjqT+miPdbR9hK11EYHg+vO9iMs6Hnw/Zr8+HRjdYn0O/cxXpOh9PINSIpH2Djc+xn+Mm3X69KWh0o68fKyXjOKra6xzRGNTbI8c5F11f5wja6bleNgcLVdLrHBFN+9dORo7MPlfXG8giCku6j8KS7zb1+MLWPIf1h748oSVqpPm6TX5A52WOcv/CFrt9YaPToWUO4j6+SvH6MOqG09Hunw477p+OCB06u/25vBccRtBGP3bzf5xSA9J/67LRcfRVp8/ReQuOI2illudxfCz9vMzxHajbS6ib3R7mW3TPdzvqPBDX+vpAanRKcpqn5JcxzFOOoKV+fIr5cXkTHpy+dULWHhc83XxcCH+Hz4vysVf0y9/hwci0HnN2oh52jfXl+YdoOLfwuLBeU3mdI5pzmpM9bKLnKvqvGcIr0maHy7jB/ZYjaKPd9RjPX3K8l6HNUSnOxHOGsIVfp8JUXnfXGj5Izivy8aLiezl8zn19vJX0Xo6aZ46aX+cIn1ra8ciRj+ovn1pqNPNUZeKr2usnn1qitjGnND+2zkIOW89R7UGej1cGXufY8OxUbz87hTQ/h8PXwyQJ+Hxt2+0n/PjK+pz2b0nfax0tXzmC1tEkaqUym8fHp1PlxcA2Po45SSuS6uvjiHrLNf/z8XiOHL8OGZqF6yAy10E4JfeNHB/fsZn3piO9zlHvt/TWfrall+vKnv339X02HdGc8fj40EiT+NxiT0luPzxFbUzkeiqWmt7qLyJz3CGqx8sc6Sg/22FE5xhbLOj86Yie8fuS8Tin9sts5/PEbdBUa//exef6Si3vJWlmj59zkiBIEs0hr3aaFC1wLPaaaGza0uO3fGzO/7rPpA2D05Q2jE5Tuj08TWnD+LS/8n5vgBqnWBqhxveY69bf6vGS7Slaejof7+dNt7YcJEnhKGTe7Wrm/G16SvKzUL2WeM9Fl+M9qNr1OOg5v2ZZtAK1tuAdHgbu/S1bcBjRLbN/R3RcFhHeZOQbSZr6Ne4/giQtQmp53O6acXLsufNH61BtDjEbRlRS6neOo17H0QKSRVO4qfmc2jqA9ucjCUczrX+r53Hb/eV56onMondvEGHfPRcs5q/JVl/33XgJx+fqy1lu7dWoSsIRwJwaz3bk4EhqNEOWrwkhC24z0jbc8KIFqeUbXrQitXjD07zhhqdy+4YXplibkokeIvrvHEdxVvV6wjDseC1fd81Wgo4Xrkj1jas/V8Yau96TvhItSa3d8eLj0Ll0mvkM8NtxhENvs4mAc6Xt9YA3WpQ67xNzbufAnMqzSRMtSl0PNHoEWlGJlvj7t7A+W7tzAfbprEbLUufIfmb5KOvLJbbw1jm+Yvp5cVJw/w2XplYfJIrfvk+EdK5TOJD0y0PeE52jxSnX2flcFY8jR/lGEp9QdK4G/5bEotvehaNzlISVlGekRQtUJ9cfaPUmHiQJWqy3eXHOGRp7fZ+Ilqg+9gt9oLFgPkHWnwTkunOei1zBk0C0HvOxjcZcXfrYW+IV1CJGy3GNwX/tN89HUqPFw6PNxcOGcWt5TtLuQ82P21ALl6hWoeZ5C9QiDpwL0/Pi5F/WI544EC1V5asLnwsBwfNAtFa1PEqLlquWR2nRatPiKM3rhlGat9ujtDDF0igtBNrydal5w3Wpcvu6hIsBq9clXrNaui5hirXrkuOxYr1UiOBJPl6yupY0WwmwWjdgtd3HatuB1fb/A1b792QfCwLBFFqLGqvMe17mqsJvnabtwGrbgdV2H6ttB1bbfay2DVgN5dTrp1Qcx/NgM0crV0l1LuMnPX9YkGYD4vOxYUUgH7dXBPKxYUUgH7dXBOIUa20kejSqNrWs+sug93h+A+MIUTRH35i9froo4bqVzwmFj81erxz2ZNpHLzrJMed7T6zZyyTxCcnzx9RfXLffTkg0HVCnBv3LivH56PCUpEQrcfIPGsjvKez+M2uO1p1Wn1lzqvefWXP04tTaM2t4HMscimbAlzkUrV4tcih6S2aZQ1lvcyhMscShuKWu3qvClaf1e1Xe0kbahjYSLWAtthFJG9pItIC12EbCFIttJBpnTq+xlfoaiJGTuDqNkKO1q+X2EQ3f19tHvd8+2ob2Ea1cLbaPMMVi+4juuu5T1GqcBXxuIdGik6Q5IDqHNSVIsmG2KuuGx6qsGx6rst5+rMpadzSzdr+Z3X+sCkeI3uZ7z9XT6xFiuHBlM4l4Du530dJV6p+A+7zd0Ts70lOSUF6dr8rJka4jOddsnpKE7/3VOY+g2G9Bnt+AjhauskHo49s7xdZvEtevSYk2znP3jd6qWp0VyWWDEpBtgxKQ7bYSkG2DEpDtthIQp1i7S4SA12vVSmtwlwjfIlptIdGq1XoLqTtaSLvdQvzY0EKiZavFFhKmWGshMczmTiMfH+t4DbPw3arVB95owWrxgTc6juVG5jsGq35/sOo7Bqv1/mC13h+shi8yH3qtisJd++22W3fMqtYds6r1/qxq3TGrWu/Pqlb/2YubLxmXr5z9dnHDd6wOnROAh3MS8RvDTC9tDjOxH8Nvw8wWbiA1Z0Rhv/1Gw+gtqzKVpNK4bOZPKXY003a/mbYdzbTdb6ZtQzONWkeV2Tpa0DrkOO4zSI4NM6py3J5RlWPDjKoct2dU4xRrj6nhm8Rlbkll9nKTsSDDOfR5LKdoNa7+P+1cFL0aJaleq9QHk+RvJJFrZ5pf3o94ThK/X7W0F5+kuJk+mnqwGV+YYm3nNonerlrc00GiubK1vdskfLVqcUO+9avyeke+5eahh73bxo7rsTBp0MbizdOW9vCUUKtc3Aku/jl+rcnW6OeEG/zlqZicRfS7J3XniyTznaKaA61Sst7vvNE7VoudN0qx2HlDp2qx84YLVGudN1qeWu68y1cl6Lxh85C5Vc45Gqmvm0e0uLS4o6ZEW/0tXlu5v0+qyO2NUiVan1reUi5MsroDY7Q+tb4FY/TQv7jHXtjIjgkykXdBZnPnoFrT632NJXq3KvWPvIwu49yY+PmMRHDXNF8FPG9VwaBKNyBV7yNV7yNVNyBV7yNVdyBVNyA1bh5zMzZN1l43j5LvN49ofWqxeZT7VA6ncxebR7Q0tdg8ojeqlpvH8lV5u3mAHly//M74UtMku/JB+bck0cLU4g7rYhvaqd1vp3a/ndqGdmr326ntaKe2oZ3GrePuDEZJ117tqbz+CoBEC0pm0yqx6sFtP3qVql3v7h98Bnq+68fnw6/zUd88p2u714uHG3Ue1/IYHi1/y2H3e+0Xi1IrvTZKsdhrwyWpxV4bLSct9tqaNvTa5asS9NqwdcgUWzKnYb+Vo+RrC1Z5uZ2+xK8/lTKXHKy9mWPudBHmiHvL2qNprbdbepRisaW3cIV/aedUaXe3To2PYrG/RatRi/0tWo2yNF9qNT6C/dbf1pOUN5PonLj8+NRZkMRvX5fwt8yJ/o+vBr/5W/J81P/4Kuu7SeZrIMYJx+8lkfmc/vG9wZdJNHx36rjWxj7K6eUsSphmdT7niyRTjGvnHPabSa6t/9o5Dn0zyeLMkkavPq3OLOlxezuV+DiujXJbxRDz9+NYTWLHu0nmjeYs2ntJzgHzHHSfZY/ShJ9emWBrHEh8s7HVq7GxH38vibUryesO+I17+MvnVA3fopobCLsHz3bh+H/pI0Oa2v3H9jiJzt+i2l5PIGiOv5wytxF0ff1r8v1nf823n/3DFGtjK833n/01337217zh2X/9qnhwVcLWMYWh7FXfyiFXWz9veP5ujuN2DrkGV+TY93LMi3ume50j3Ppv7YnoixxLT0Txb9GrkanV+znebGOSG0Tw19c2WptKdm2Y6TnqddGB+LUbsttrFGq6f3HjHBsurqfrtwQdN1wDOeZWeSlBf/rmSb1ea6lBKws/WLS0Y4hquHtgmb+l+euns/A49Jqw57fOno8jvGeX6YNoCTbL1nLcnvnTcv+TqFpufxM1TLF4zy73V/u13F7t17Lhu6jrVyXgadg61mb+4hxrM39qx32MxS19adZO7X4rtfut1PT2rJ3a3e+jxkex2FfC16XW+kr0stQ3JmSiNKsPlXGS1WfkMMnq1FCcZHFqKD4ni1NDYZLVqaHoaX15aij8KNXa1FB4HKtTQ8tJoqmhOMni1FCU5BtTQ3E7WZzVWcfz68Fd9O7U0oRMPKa6voun7vbmZEqZe8NriSZTooWqVe9Y64YvUIc/h0vuOfgUitYNGrW246d/Tq54lyP4OdH7U/dbWrE5ei9egmm7aElD55duNPNrx88pym0qhkcxM/BZ5vejiD6pfW3RdU6qpZdHEc5zV5t7hRy16ntJWoXWgRdTvpPkYwfI+bR7YCnxOyd1vias7fWlLdFE+YYU54mcbz6d5fLqp3yVZOnKfJFk7crESVavTNhz/XqTK+trgJQj/BL12tdyynFbo46P45pkSq1pcBxhkrmMkY+c3kxS5fq25C+n9SlJkvu3mZL0/m0m/Dmrn1QpKf6kynxh+CyXVx9m+yrJ0ndZSrTJ3up3WUoKxaq177KUvOHl1LJju79yf7u/smO7v3J/u79yf7u/uIUsfhuiRKtVq9+GiJMsfhuiRG9Tre6zWaLN/lb32SzRdn+r246UcK++pW1Hwgu8uul/kQ3bqBXZsI1akQ3bqBW5vY1akQ3bqBW5vY1anGINAVFLXb4uumHT/6K3N/0vumHT/6K3N/2PU9xH8+q+8kU37KBWdMMOaqVs2EGtlNs7qJWyYQe1Um7voBanWGsh4d1uca/eEn+lanWv3lJ8RxupO9rI7T3Uim3YQ63Y7T3U4hSLbSRcrFnbV75Y+L3qhX3lS7RytbqvfIleqlrdVz4+IYv7ypdw/WpxX/kSf+F5ZV/5Em72tzrejV6sWh7vRi9WLY93XW6Pd6PjWOaQlw0cilauFjkUvRa1zKFou79FDoUp1jgUttTVe1VNW+5VdUcbqbKhjYQfi15rI9GS03Ibibb8W2wjYYq1NhIBcW1f+VLbhifVtmOyqu2YrGr3J6vajsmqdn+yqt2frArvuov7ypfw01SL+8qX8ONUy81sw2OVHRseq+y4/Vhlx4bHKjtuP1bFKTYMmRf3lbfo01Sr+8pb+BbQ4r7yFq5pLO4rb+Gi1eK+8hbtMbe6r3x4k1jcV96iD1StzopY2rDnr6UNm6laur2ZqqUNm6laur2ZapxirfuGgF/cV97ysaGF5A0zq5Y3zKxavj2zannDzKrl2zOrcYqlFvIFzNb2lbe84UNqlm9/SM12fCTLZMNg1eT2YNVkw2DV5PZgNU6x2Mii6fvFfeVNfMfFrTsu7u1ZVdMNs6qmt2dV4xQbLu7ivvIWrVUt7isfDzMX95W36LWmtX3lLXq9am1fedMdzVTvN9Oyo5mW+820bGimUetY3FfeyoYPl1jZMKNqxe5fXN9xcev9i3t/RjXc+c/nq2LKGdVv+Xvqya8kr4U3izeZW/P3LNq4b4sm/ssePPJ6t+0vkkxrzizYKj9O4tMkNI/8+zCJzZZmNb9+WdTCWbPlq9N++upcNxqrFvycaLUqnbOd1yuSTV+JkV8lmTw6yy2/TBK02HM59XGJXVMLfk5kjNt80FQLdmW38JWgNk9sPtLLN+jNb79jbeFyVU5TN82uL+d3LFpr+rC9pz37YX5faeq30pSrmaSC9YTf3pKKmqzb3HfCjbuiP1/jen+LFav3t1ixenuLlTDF2ouwVu9vsWL19hYrVjdssbJ+VTy4Kve3WLF6f4uVr3Ict3Os7aBh4Seq+Np4ee+cLm718kWOpa1erIWLoku7gXyRY+k1+vi36LzLCPcm/O042k8fx9KWM+s53uxzi1vOeLTStLrlzBeNfbGByA9fmLXtYjzes25tu5gvDmRpuxiP5nfXhjIefg5pcbuY8DjWtov5aqDq1+i91fpioOrh+1WLo90wydrLnvEw1eeU6Fl82VA93d+w2tPtDavDFGvjIE/3N6z2fHvDas8bNqxevyoBk+OHmHnPTq29HDt4vr8tWvwUs7hKHSfx2UDOYnovSTqOcq1T6ZtHUuTaosHefyirdj2U4Y753Yey+Ys+HtAsSBP9JGnXeeHS27fOi06ZKCs6z+9J7D7h48eh48JAfavr5JRmk03B3VtuP/+7bNhjLTyO1VMaXtq50cN5leXdJp/yZZokeXseIus1D5Ht7Z6T5wDtI2XQcyKDfq42OzTv53eSvngreSp45i/f5/fo3ajVV5vDJGvDkfgFq9U3xr+4i1/dN735dvSqS+Al/NDsnPAqxj3bn44jWn6/XhbNWfPrdYkwSR8pfN76gvURLz+d5HxCO652Vt9M4vO7iOckSw6SRP1uzs+62nspmj64SDn6WynSkWe/O6wESaKHmnoBuqKZpfaNc9rmdERqOWpnHq0mXB86aOnNt87TOUt1PcWbvN4vLX553a6X1523z6djcQs/IDEXezBOy/Kt45it5DyOGhxH1EzOm7xez2lJXp4Tj7YJTLVd70gxyfkQ+8sPit/FnxOKXu31CvYXr9HPbVvOR0Z7RcYwhc0tDs6ivpdiic/h282rfA6TrKLVfzrJMp/DJKt8dr/N5yjFIp/j571FPkffsFrlc3hOV/kcqRbLg5povWmx04Qv8652mjDJanuv9sNJljtNmGS100TvWi12mijFYqcJ9yhc7TTRe1arnSY8p6udJn4Xd/F+F79Gu3S/C1Os3e/8fteNhYLFrhtPxa31unocP5xktevGSRa7bo3Wrta6bphireuGKVa7bo0cx8WuG5/T1a5bN7wBX492u9OEfsVqpwmTrLb38DWrHUmWO02YZLXTRK9ZLXaaKMVip0llQ6eJpr5WO014Tlc7jbWlZ15ucfT0qlaNFrD0eptHBfOav28tEu50jI0FPAVHEk1azYUjSdf58KfrEq5fpcujT/gtz+8VfHEY022APefPr9BtmI+s2W+jrO2Yj2wbphKrHD+cZBllsuP+L/fv/3L//i877v+y4f4vxw+jLB2CX2OvERLu55euFwLzkV7CLHwzebn7hm9JLXXf+KXixe4bJ1nteTvmvMIky91XN0xXVb09XRWmWOy+umG6qpb701XxOV3tvuFr48fclluO+npfkBotbOgx57w1aX49Fol3KCmQeVtwJNFgdeVbB+H2JMsUKbcHAfHOIqsUOXY8iuyYBAyTLFPEdgwC7P4gwO4PAmzHIMA2DALs+GmKXO8oih7Bc0S4MWCdm61oE3k9CMgbNqCufn8QkDesWcVJVnue/3SS5e67Y82q3l+zqvfXrOqONau6Yc2q7lizijdckqkEJXHulvr0/B2tWem0nBXX9sPLW05R5t2bNu33UkxRq+BLY99KYfMTUoZ9o95OUd5MMc+FvXsubJ4Le/dc+Pwh/u65YIo3zwVHdW+ei0vg83fPRZ0/pL57LpjizXNRbabwd49i7idc65tH0ea8YXv3XDDFu0dRHxBuAXLizdlWjfUwyeIbwC1+sapdd8cSJQnfq/Z/AOHfNiRJ8Xd01zTz8EWiVYc/PJJVhz/ea2plVThOsbQq/EWKpRGlbJgVjpMsDgZb+ukkqyPKOMniiLKl25ZqmGJtRBmmWB1RtnTfUo3P6eqIUjZYUC3fVgfjzbdWO41umABpufxwkuVOEyZZ7TThPoBrnSbX250m1w2dJtoFcLXThOd0+TEs3F6t4KNV5eUyaIv28JN0YB2UE7pPOcIWYlcLqXwt6imHRc8vNp9fylsZ+mvovz97fCvDbKT55TF8sVldni+qH3xweDqbET60zHe71XRHjvYqx/LufXK83hG5afjRytm8knLnrOcfExn/x3wT2VLy1zmiJnq2bbxTedQdWX7ZXP070yftOifRftXhVoLXxEVLL0fuTdvtwX/Zcb8sO+6XJf9wkuX7ZdlgUbVy26IKUyzeL8sGi6qV+xZVfE6X75fhPo9zCkFq8FWUZuG+KrPT8FOxT123RRsBytwRRTMnQ567jG4YL0dvUi2Ol4vv6P8b1ONmP51kuf+HSVb7f/QhoMX+H6VY7P9+bOj/keG+2v/Dc7q66rj8FV95/RXfFu1lcHbT+dZfxYfRvvON1+XeG35tak0clHq/98ZJVjtevLvbhiTLvTdMstp7ow9WLfbeKMVi741SLPfeaAPA1d4bntPV3qsbRJvW7r/9XzaINmXLaHWHshsmWe40bce8ars/r9ruz6u2HfOqbcO8apMfvuWJYAc/mnbPu1+Hr0GkaxORVF5/YvlcxJGfzmJ1vj1g7Xi1scoXOa6tka1ZejOHX8fRXuWIG+ucGWn53fY+34PgvvXvdpkgRQwzmTNvWTAn8r0k+fp0lhyvm/v5pHX/DdU4SUpzK/9zwqe+eSjpekklpVrezYK5ImlvH0vfV2dkKepvZ7Fr+7ra3v5FF9ckh7/o9lvVcY61u0WcY/V2Mf7ezzZb0flkIsXfPSlLVPoixxKWli9OhLZwCL0G2DDFGmAXB/IRYMNHrFXAxg97q4CVHS1VtgBWtgBWtgBWtgBWtgBWtgBWNgBWNgBWtgBWf7zZLgNWNgBWNgBW7gM2nGFcA2yYYg2wi/OcQYp4BnoRsF/Mha8CtuxoqWULYMsWwJYtgC1bAFu2ALZsAWzZANiyAbBlC2Dtx5vtMmDLBsCWDYAt9wEbLuGuATZMsQbYxYXkELDHDsAeOwDrO1qqbwGsbwGsbwGsbwGsbwGsbwGsbwCsbwCsbwFs/fFmuwxY3wBY3wBYvw/Y0CldA2yYYg2wi2ZrBFjdAVjdAti2o6W2LYBtWwDbtgC2bQFs2wLYtgWwbQNg2wbAth2ATcePN9tlwLYNgG0bANvuAzbdX+RK9xe50u1FrvhNqFXAxu9kLQI27VjkSlsWudKWRa60ZZErbVnkSlsWudKWRa60YZErbVjkSlsWuVL+8Wa7Cti0YZErbVjkSvcXub54U3Tu61gMX3j5Vorr64r8psJTivDV29VvCcVJ1r41FW/WsXRp4xRLV3Z1y5DwwuqGG068rczqDWfD5oFxkvUbTpxl9YYTZlm+4YRZlm84cZbVG078i1ZvOCr3bzgq9284umG3q9S/yvizzXb5hhOelMUbTphj8YazeHEitNntnxKnWAOs3f4h8WZ3q4A9dmhrqexoqWULYMsWwJYtgC1bAFu2ALZsAaxtAKxtAKxtAaz9eLNdBqxtAKxtAOx9LsV7zq4BVu+PYPX+CDbck3gVsPHuyKuA9R0t1bcA1rcA1rcA1rcA1rcA1rcAtm4AbN0A2LoFsPXHm+0yYOsGwNYNgK33ASv3R7ByfwQrt39I/M2GVS+4bZmTbjtaatsC2LYFsG0LYNsWwLYtgG07AJvvfxMrzrEI2Lzjq1hnlh9vtquAjU/KGmDjHGuAXb04EdrSbW0tTrEG2MWvSEWADb/vtQrY+Etji4DNaUNLDZMsA/aLLIuAjbOsAjbOsgrYL7IsAvaLX7QK2LwBsHkDYPMWwOYfb7bLgM0bAJs3ADbfB+z9e0W9f6uo9+8U8VdHVwHrO168yDsWufKWRa68ZZErb1nkylsWufKWRa68ZZErb1jkyhsWufKWRa6sP95slwG7YZErb1jkyrqBS3LXqvgixYpVUaL5dUntcTZEftmy8mmrihzuFTeb+3Vh9dejiL8+vnRZ4xRLV3X1G+jRRbUNjnScZPlmY8eGXht+imn5ZhNnWb3ZhFmWbzZhluWbTZxl9WYT/6LVm435/ZuN+f2bjW34AFHK/uPNdvlmY37/ZmN+/2Zjt9fJ/L6y5veVNb+vrBXdoKzFSZYBW3e01LoFsHULYOsWwNYtgK1bAFu3ALZuAGzdANi6BbDtx5vtMmDrBsDWDYCt97kUbdyxOJqPU6yM5r3cfhUmTrGG+XJ/v7e8Y9kx71h2lB0vbYVJljH/RZZFzMdZVjEfZ1nF/BdZFjH/xS9axHz/ezcxH+ZYxHyYYxnzkn682a5iPj4pa5iPc6xhfvXiRFyKe+CRZ+f52PxoprFvJVG5ktjxIsl5gVuYJemVRd/LovnaMjWXV5uMavSl5dVz8lWSxXMSLigtn5Moy+I58fCrFvg5x4FPhEr9XhoxpJHXacLNsY+ux36mSfgM/bfSrG2MG6dY2hf3ixQr2+Jq+HWc9avzRZrVqxN+3W796qTb2xbHKdauTrq9abG06FtMMr+hchbxzbHavpEkzw8xnEnsdZJoRJ51fqgza7pG5OdN+VeaRDteJG3XEAc34t+TRN+Qn5+nqvyqhOs3ctT5WdmKa/sPckRD6mMuF+SE0/q0Qf4YN7w8EHs0kdo8OpASrVvM5y05T+vL6/uNa+Mvr03cSM4x9NVI7L0cJc8N/4tI0Eaid2zb9fzYrL2bZH57JEoiIncbq4SrhSdajwutws+PlfU0TebjxYm2d5OU+TWGxkbyvSR5fi2vnQOyd39OmR+oFrMgSbQTUJ0Pbq2W1/es9SQYrH0zSZWZpFqQJDwn9Ton7QjOSQj6en3WGY/nv3WdaH9CfhL+JRkl2r6gappfUv/lS4blGY3RN7fOjvbIchYDDljZcNeKFpdX71pRjtW7ltUNdy1r9+9a0eLW+l1r+dp4dG2iVtI/pzOStBbcckIBYe1u8dWRzImXfODbm78fSTQemFf4HLJHVye+6Sx9IT4+Er3mXUyiBqthgz2uBlvfO685pTkwSTUYvUYT/avnNf42U6mzqXkKWn243LZ0XmO+2jwj1bK+5Gt411p/ePwqzeLD4xdpVh8ez7PrP59n8eM5cY61j+d8kWPlOTSF3/Hya0WnvqZs2/D8GH6kafVOHD0Or96Joxyrd+LoPZblO3E0V7h6J251x514+dr4e21k7fExTLH49KjRpPTq0+MXSZbGA/m421LjtwpWnx1DhX7xgS3Msfq8ljc8rq3miJ7W8oaHtbzjJhOe1dXn8bxlfiFvmF7IP/trlicX8v22WtL9trqcI2ircY61tlq2rJnEZ3VtdiIeRaxNTmi0S9vS5ESOPtJ6GQznSPxKcf7x82FEurnIpZvzt3wnh043RDSn1znq3SW+8Hwcs3lowkPN7+dDwgno69OoJV3n4zxNz1miD8ZbnoMZ45PEU5Zoh8a1sxr9FstzxQVfvs9S1jPMEabRwHjKEP2KVOavSIVfNBVbz6H5GtRleZnjvCbh58QvoJ5lPLI+nVG720rDeXQreS6IW+GcovjTr4kWSlb7bZhjsd+GH9laOyPRm3x1zrGexfwqQ73dzuvddh62rsV2HuZYbuda77fz+KMAx3wGOss4krqeo8yTmkt5nSPsLX7MWYOT6UcLekv0kaHV3hLmWOwt0WtZG/jx6xnB7OzzGYkWfM+H7XY9bF9Pdflp/LGeo97PgZb6W46ovXudQPWGSeKm6zlqmYZf5eTDt3LUmaOhjf2WI2bhFGRr1ndz6JWj3M+Br8w/54hmu4vNSeZz5q69zBF+p2zx2oY5Fq9tnGPt2pZogqu/sDnaei7tfg70l+/lmM/Ikr28l0PmtNJZOt7LoRNk5w3rzfPRVyo/j4PP6m/nsDdz4KXd9mb70Cltisqb11bnEsZZ9DdzTAaJlnevraWZw/zNPjevS6rRtQ1ztGsodKR3+/61WHbk+znS28fhVw57L0e73hFo6vePI2Jh2cD1soHrZQPXdQPXdQPXdQPXdQPX9T7Xwy+LmstcW6761vhDmz/Oh7YajIPC8akfc3xaX49Px7LT3TW2coQP/MdEqvCtjd+zRNpq8UcWL+h4qT4nCZ+E0kV3zG4nf04SLBrIcT1OHVz692+dlIJ7t0cnJczSrlPbXl/l8F17lzKx6Fw3fH4ui7OU48pSVF4/75YjEvlm0z9nynGBziWRXw4leg/lGkoohxK//ZzIXZWJ+XKuQr/MEVkmxY+Zw+EvfCtHm8OR0uARfe/S+OzF5+3rON7MUvV6fK/l9Tlptyd22+2J3RShJJ2t6Xq155x0ejUjUlLUUnOa6zH59azKFzlmU23ZXs0ghpel+vVbqtc3e29tU2c6y9Hcbsn3Z6viHGuzVSXfnq36xhnR+vZ59StL0XezlHZl8RZdnbrh6tT7Vydam9lydXhGanv76lwPaq29CcZ2XPeslvJr0CfRu2SMUyyhMf4txSdNmukRtLT7KyNxjvO2dVzyudN5+1aWa2LyLOfybpbr7WXnO9DfaLPNL0+kRaROGqZps6Wc5eLvpcl5jhyzQMfN0t5MkvKbScp8lzoX2IDfSiLH3DdODj7uPCWRaOfjNG/oOQu78VMfLOFk+uoyfInenVpdhg9/z/UCcz40+j2RvLJke0QbSq/+lChHubD0NJS29Rw+8Vi8pJc5ztNR7t9DwxyL99Did++h8fmYplep0qLz0aJ7zlwrMa0SZLHwUWne/NLx+tE+PJAyx2tW5Hj355Q5nXUuApX3s8zfY0d7P0ueWX5ZLn3+wGhwYuvsvqVFOW5LCvW2pFA3SAp1h6RQoveuViWF8PMjOmcX9Jx/w1XR5yPZ8LDlGx62/PbDVng+ymylWrxG58M2nA/bcD7qj56PawcwNb4g8dv5qPdFqzjH4vmot0WrGk1mt3mr0iPpy5FMnGMKG2cOC0ZDtewY3UUfylodEp0PkwFU07W1RYkOZMtgtbYdPyfctWde4/QxfX1dn6d9mUqL9NX5Jiqnw+t3jsNamXMCdrw+jtD7XLxJhEnaRcXzMQ/LUc9LBGGS/j3YkYSDiO8mmS8WGF9w+O1dq+jGyXcdjW84PA3zwrfrjzkYOZ9p5HWS8Oe4PIaKzekJfOuc1OvEVi5qPyexI/10ll9ezxV7fVbiLHm+PpIzT8vvWaJXsNMlDJyL9u9muRa2kh76bhadr/edeCtRluhRa3H7u/jkivmcKqnByQ0/Prv4jmD04Lg4zximWFuCib9yvDae/+J0LA7oLekGVtdQ91vbKCP8eOzq67mWoh2G117PDXMsvp5raYM6YNEbnIuv51qOhgSrr+euX5ug64WNZHGfDIuWtlb3yYhGSdkmo88iX/KzbyS55tPOYnovyfI+GeGRFLnearMoSbyTZp2LQWcZQ6X6rTRl7jhwlmGXfzfNPDEfKYM9FMIzI+06vRxefOv0qs9bl6Ib/p7k9pYbYfdZ3ckkzLG4kYlFq0GLG5lYuNnG6kYm4ZEsntX46s6njPNCy7udJ13vhqWEG883W33Wq/Nke7sP5rn8+JEy6DzhMAeTuPLuSGnuPgIu/Zbii6HwPI70iyn+zaHwfC8qcSLnxrA8yhI/fvm1eTL1xt+GBuX+7FacY212yza8XBXmWJsh++KkTlHsPL8andRy+0DCHOdc0fWa6BG11zCLXWqGSXs3Sy2zvfLR7ZtZml8LqUd6M8vy1EV8LNd67IfOEGSxvOMh3fKOh/Qwy/JDerSR3fJDenxy2+V8pfT2aVkFdnxaVoG9fImiLMf9mWbztGGm2cLlqtWZ5kgx9jbnubyxqXwnSfXJhNp+sQm+kaSl+RJHS3zA/f2k3F/3ig+kXN9VKO3NX5Mn+FtuLfo17Wd/jVwDDPnF6ns+kGirwR0HovX6hscRHojcH+mEORZHKfX+4CDaCK8ZRilWXp+QlG7PYIYp1mYw07FhBjNMsjyDGU6irM5ghpsUrc5g7thg0DZsMGgbNhi0HRsM2oYNBm3LBoO2Y4PBsJEszmB6tBSyOoNZZMMMZphkdQazyIYZzPBIVmcwi26ZwYzTLM9gfpFmdQYzPDOrM5hhktUZzPAhfW2uLeo+qzOYZXWtN5jB9KS3ZzA9lQ0zmOGRrJ5V2TCDGTfX5RnMOM3yDOYXaVZnMMNhztoMZjxSWpnBjO47i0+PnnXD06PnDSZ6C9WtucO88KQ+q3mh3pemZKySyns5dL4Apb/uxfaUIxIVPdc5Z3K81gyjN8QXX+hsd8fi0e9YHYqHOVZH4i47XIJo0Xs8yX3mqMfLy5JyvFF+uUZqVCbTd5K0uen4kdObSep87enpNZT0fGbbDgKE+wauzh/FGyH6ZbKZl9cXOUV9b47Gtf7yukL6TpL5dumZpAanVrfAVTfANWz6+Xq+kCPloOlHSeo8tXLkoP/4lve4fMd7XMlCWer6isFZ1ldfxUy+RUwIt6ot8+OpWpy3v6etaj1+8JJyPXgFj5HhGGlxrsGjGf/FuYYwx+Jcg0cLxatzDR7tXbU41+DRS0fLcw3r18ajaxO2ktnWskdPOlESSX7t09j87STH/SQ+1yLFLWj00TLXL3Mn5c0TK7DkOT/+zSSztQmF1t9/To1+ztqXIr5IsjafFP8cPdo/nCB/TuLpx4/k6oHn0uiGJO92QMnt2tevBs0+/O5wX7b9nFfOEZbidr/aUMpPXx6/tpAKqeThd9mvrXATnwB/Z3V4KPOVmfMeHrSUcJlrcSooesNrfSooOpLFqaAvRkp+jdpafblY5uFLXmfruJSE1vJbWVZdmg1WucfveC2OkyJvcnWcFOVYHSe1tGGc1PL9cVKTHeOk5Wvj0XrZhjWZaDppGY07rHLfYZX7Dqvcd1jlvscq9z06uO/QwX2HDu73dXDboIPbBh28RpbH4h20Hm3DHTQ8ksWz6jt0cN+jg/seHdz36OBfTPvNhv+hML3cSaqmL7JkZGlvZVkcW4QvMSxPhdbFPpgClTua2vU2t2WuR/QObI3mQovN6a1iVH1/zRF9EeaXF2DxCvp5J/hGEp/i8jnNdbxOUqMFrz1ZzrHycbW1+m4W90s5bjnKEr2XONfNnMs838rR9NLp6ps50pFn/zugoP2eJdzCcFE3jk9sO66NA3NwYsNdguq0Lq1xx9yjrCf5sMqvp3ST19/sC9O4zR2L3HkvfD6WGu1btvjSTHwgs6WcB1KjA4l3Rr52QzwHo/L6rNTwXa86l9FSY5b6rHIHXPHrVQavaLf63FjCL5uU+RXh81HQXkEy/jjKXPEt/PD1t1IsoTrazWUZ1XULZKOFrz1Z1lEdZllGdbT0tYpqrfdRHS7BLaM6EqaWUR2e2EVU52jj+PWBTrnde/Jh93tPnGS53YcLX1uyrPee4jt6T7SX4WrviXKs9h47dvQekw29p/iG3hNubLF4A8zRrhRrN8A4xdIN8IsUS104+nL1chcOkyx3vnjKbkeW9S4cZlnuwtGOhqtdOMqx2oWjHOtd2DfsXxSf2NUunOuOG2D4TYy13iNpQ++RLe2+yk9nWe89YZbl3hPtbrjae6Icq70nyrHee6JVq+XeE57Y5Rvg2nMxN1q25wOJlr5Urp1F+dmhs/2sH0jSYzY25ffKfz+U6OlrrhZx63h/vjYtWtBP0xAqCb9GUvrWgUzLAXuL+jMJbAfXIgV5lWttB9faBiK1I/10lmWuxVlWudaO+6OCMMci18Icy1xrO3Y1jE/sDq6lQ/B77DVOWvQqbUlzXaVkvszwTLayYymipXy7I9uGpYg4yXIXTOWns6x35LRjfqul+/NbYY7Vjpx2zG+1vGF+Kz6xqx1Zww8jXt/wPfjxhN86cvjtrmPOlmviRtDPHTk8lFSg/bboUKL7+sq3T3I0b7gOlHx/ZBDNpS4DJUyyjIItz01hlnWgyJaRgWwYGciGkYFsGRnIjpGBpJ8Gisz1RNEjeNBoGq7V1utzuiKvgRJ9vWu9I+v9kUFkTi135DDJchfcsvLVtqx8tS0rX23DylfbsPLVtqx8tR0rX23Lyle4SYZM2SiJ45W8Iz3/nmhkMG1oxRX+8PbWc1zfVKBv+80c0wMr/Irft3JcX1T49YtX7+Yo7+aY58PePh82z4e9fT6ubz362+eDOd49HxzyvXs+Lk/Q3z4fdf6W+vb5YI53z0edG3ZVf/s45nZstb57HG1OOba3zwdzvH0c1459AYNyCRfO1xT3OElO09PN4cbp4QJT3zHq865ZwizRmy7z0xb6y16i/o2fs2imh0lWtf/4SBa1/+zl9jJzmGJtmTlOsTba3DGh7FsmlLfYWmGW9dFm3aHEtnpfiQ1zrI426w4ltrUNSmx8YldHm3WHZ9WiN7wWe0/d4VnVHZ5Vaz+eZb33hFmWe0+0b9Bq74lyrPae1u73nnwceUPvCU/s8rNatDdcvvYpyHjL5XlRNR/RntGSDqyqci74OUnYULjZOd+tek4SfYPBbD7hlPdS+Nxf6peHk++lmK01vz6KiK/lyPMV+IPPFc9nNNrOTcv1JU1ut3UjSXuZJG5lc5glgq2Rf29lKf6qxXwlS7kB0m8/J/IqjvlysyV+I/m3JFFTPRs53tA86pY0Kb0+ueF0S7tOC7dZfppuyeH975rlaOn1qP6ItmJafDJoO+6hO+5+4xsNP5tl9R76RZbFe+iZ5baqFedYu4fGOdbvofm+qvXFiV2+h0bfKahzqkEq9kXU318XCD8tM3sPvqPyWyc+JFpCmbuvKLdCq78ehxzH/eH0eSC3H0bl2OA8x0mWO7HUn86yjoIwyzIKNN1HQZRjFQWadqAg2tNwGQXxN9oW38+MVlNznVNswjfhn/doPH9P9Ihe5/4cH+9MvXIRkpcd/Vhvv7uQfIOLECdZ7oEl/3SW9X4cZlnux+GOhov9OMqx2o/Dbykt9+NoS8Plfhye2NV+3Lb0Hru/S0Hb0Xvalt5j+tNZ1nuP6Y7eY36/95jf7z3mO3qPHxt6j+kP3wVFsJUgpb7nnYrjr51eu56kIsGt1PWns1idry9YO17tBfNFjmtbX2uW3szh13G01znCBntcH/96u9HPNzGal/sdx8ubXJM5VZcFsyffS5KnMHbmi1BSZUPnC18cSnPz9HNqqL55KOl6TyalWt7NglklaW8fS8nXDo3qb2exa+M87DX33V90oU1y9Iva7Re+4xyr94y24YXvM8uPN1vR+bjyMdv35klZ5FKYY5FLixcnzBEOqRd/S5hj8bcsDu0jxvoOxvoOxqZjQ2MNkywz9ossi4yNs6wyNs6yytgvsiwy9otftMjY8EOJi4yNPz65xtj4g42rjE3px5vtKmPjk7LGpS++6rnEpdWLE7ItnH5cZGyYY5Gxi9OgQY54lnqRsV/Ml68yNu9orHkLY/MWxuYtjM1bGJu3MDZvYaxsYKxsYKxsYaz8eLNdZqxsYKxsYKxsYGy42rvI2DDHImMXV52jHKEUsMjYL/SEVcbqjsaqWxirWxirWxirWxirWxirWxhbNjC2bGBs2cLY8uPNdpmxZQNjywbGltuM/cJKXfotX+RY+i3Ldmx0PuoOxtYtjLUdjdW2MNa2MNa2MNa2MNa2MNa2MNY3MNY3MNa3MNZ/vNkuM9Y3MNY3MNY3MLb6fcZWv8/YenvNK369apWx8Yteq4zdseaVtqx5pS1rXmnLmlfasuaVtqx5pS1rXmnDmlfasOaVtqx5pfbjzXaZsRvWvNKGNa+0Yc0rfv107jVZDB+p+VaK67OP/BjEU4rwfd7FDxp9kWTxm1fxziCL95wwx+I9Z3GHkvDaHjvuOceGe07esJFhnGT5nvNFlsV7Tpxl9Z4TZ1m953yRZfGe88UvWrzn5HR7l604x+I9J8yxfM8Jt7Pf02xX7znxSVm758Q51u45qxcnZJvofcaK3mes3P4t8W57q4zVHZ5Fzjsaa97C2LyFsXkLY/MWxuYtjM1bGCsbGCsbGCtbGCs/3myXGSsbGCsbGCsbGJs2jGPThnFsuj+ODbdIXmVsvFnzKmN1R2PVLYzVLYzVLYzVLYzVLYzVLYwtGxhbNjC2bGFs+fFmu8zYsoGxZQNjywbGHhvGsceGcexxfxwrO+anZcf8dLiL73JjtS2MtS2MtS2MtS2MtS2MtS2M9Q2M9Q2M9S2M9R9vtsuM9Q2M9Q2M9fuMjT8ytcbYOMcaY1c/dhUyNu1gbNrB2LqjsdYtjK1bGFu3MLZuYWzdwti6hbFtA2PbBsa2LYxtP95slxnbNjC2bWBs28DY+/eLL3IsMvb+/SL+WuoqY/OOdzJkx5qXbFnzki1rXrJlzUu2rHnJljUv2bLmJRvWvGTDmpdsWfOS9OPNdpWxsmHNSzasecn9Na8vvia95FnEKZY8i+ijd5La/FaP/LL95ZNnITnaZWc29+vC6jPn7bh/v7Hj/v3G7vszxw53+tjhToukDR03/CTU8v0mzrJ6vwmzLN9vwizL95s4y+r9Jv5Fq/cbqffvN1Lv329kwweQzrWuH2+2y/cbqffvN1Lv32/k9prZxx6D9xm7wWOruuO33GdsnGSZsWVHYy1bGFu2MLZsYWzZwtiyhbFlC2PLBsaWDYwtWxhrP95slxlbNjC2bGBsuc8l07tj+i9SrIzpU83335KJcyySPt/fGU43mB5xkmXS73ilK0yyTnrf8ZZMnGWZ9L7jLZkvsqyS3ne8JSP1/lsyYY5V0tcdb8lI/fFmu0z6ev8tmTjHIunr7af86B1rK/P7m3a9nHLeX9Yz6NxEFJR/zlDr3WMIMywdQ4oUoFzmhqr5l34r7RtJrM29ka3Jm0mu70Vnbu36rSTn3WFueHvk4OeUOMucEDvn1OTNLGt71X6RY2mv2q9yrOxVG18bn/vgf3xG880L/EsSfTdJvpLI60uT9Qi/cC7XrCnu4vadHDpHNqI5vc5RfjaH5mtj5VzevLzzg0HZuRX4965MnRDw9i5JeCRvJ6lzCH4W304yRxFxkkj7XkN8nGKN8SU0tvNMct64X1MkzjE/adMyXuj8NUf0buviPfe4fc+Nvubm8mBhcZyJJL6eo8+OjRy1HO/laOkx6C6/fBX5W8fh13E0ezPHvKpnujePo02ul6Zvn4965Xh9XSz6DlWp8/t4hV+JfjuHv5fD8mMSQc3lvRzXR9XVgzbm8fdYH+e0Hkfw6QyV8Fty89PbavwuZbXvHInPI0nhkeRoZmXlIx6+4aN2vuObdhp9lmtPluVPeMRZVj/hoRuWsHTDEpZuWcLSHUtY8Yld/YRH2tKLww9zLfbirw5lsRur3e3GKW3ox3GS5S6o7aezrHfkMMtyR44+27TakaMcqx05/HzUckeONt5f7sjhiV3syNEdvRx5jnAOfT3SOn9OQLeS6xw3Zo756nOSaOrK55k1x9PvU5L419Q5bkxHDn5N+Fmu1V8TvQa649f0fc8+f42/N3IsMr+sXETtvRz5Oo7zSfh+jnq8+VuOeXUltTePY36tusjx9jlt1zktb+bQK4dJ1O/y7ZnvOMfazPcqWKMVubTBb/viDry4IqfRWHoZzm4bVuS+yLK4IhdnWV2Ri7Osrsh9kWVxRe6LX7S4IqfRGtbqmCLKsTqmCDeLWx5T1B9vtqsrcvFJWeRSmGORS4sXJ8yxwdXTDa6e3nf1fANifQth246m2rYQtm0hbNtC2LaFsG0LYdsOwpbjPmHDHIuEDXMsE7YcP95sVwkbn5Q1KsU51qi0enGCHNH+GCJmc9ETTznS9M0c9mYOvLKCLvytHHqt8yuWgb+XQ+zK4W/mSG3mwDz993JYmjksOI5oqrHO65JqdG3DHG1CsR3pzRxztvLMke/nSG8fh1857L0c7bpJNPX7x6Gv23rk269e2zjH2rWNc6xd2+Uc6e3jWLq2YY7Fa7t8HNG1Dffi1TlS/GD5tab9NAVW5L7OEudYU1GKlJ/NsaazhOdU5q0yix/ROa2hKfCYVUzHq0nF8DD08mGUI9XfDiPKsjpFWqLVrMUp0vDXlDwbasnl5a+Jc5R5Roq9PiNJo5cWxvn6zFKON7MsynlxjjU574scK3Ke3NZI5bZGKrfVHrmt9oQvsxzHZOlZ5o3yaZHziyxzVPiRRV4vlWoOV69SufIkDpW/lWe1nYY5FttpnGOlnUZbcDSZJDuPB0PlUr6RYz5xnznSyxySd7STL7Ist5O0qZ2kDe0kbWgn6XY7iXwjn8cg8MC8rCYo0922BIHLfTVBbvPWLwfdvFpXU1h7ZPBffsTyMVzvodWE6Q+X1QR1GvkN0shzgtxP1svh3HQDxfEiW3seekTqV77GYr882tb3jqPKyxzR+yJzabbBO/8HJ8Pu/pClS2oQm88HkeeDCO7UmmROi8nLHNFBTGj5cQQHEb7WZJck+SGu5Nco/yKP2ZXHMfX5D/JECE25XdPTdJvqd7LUZtdTpbyZpfqjlVTe4r5BjukWe+Jof/kKp3ToNc/OKdi03l/SpXoTX8v/vtQ5V9ne+Pd1vuNR+bTytGBfQlV8zpkYtebvpPD5MOt8Avxeijkrn8sbJ+J84sOtKL9zOzwHFemakEeTauv3kuLzehgmStPzdHyJpuPrnPVtou8cRs7pmivhDem3T0q1CKF1PmmcSwscbrV3s1iQxY7o2uRrBkmO481jSVd3S83TyyxhI5nCz7lq/frUhtMd0+D/+PbX60Zi0b7XWY8rCzpu1eckwRRSPeZ6ZT14s372VC1ag3K3ieKKYeA/yBK9SljmbFYKlo/s2PExGTvahvXXOMvqaqWldHulMcyxvNJoacPb1as/J/wiRniRbT4e//oO7e8/x7ZcHt9weXzDOYk6T6uz87x9XlcFbctRY1tVqy3f16LjHGvr0ZZ3qNWWN6jV8YldVKvDO08r17SyBXeeHL43UiZlz5OC0bvrt9L49G/TUfHs/ZQmmsGQfKmzJfpB0QZqgiP5eIu9vP5BcZo6Xx2RxNc+vpcmpfnOxlnGq3Xr50XbfDm4HOhA/+C8hC9NHddTp+DxJD03fokMlRMD803BVLGU+ftp8WhobXNdpf7yOsz6aUllOgjnIzVPy/JzRsnXK60ZM6Ln+tuvvyVa3qk+x8TnWB+T+Ic/Zwm31Mc3XwuyqH0nC94QUjyD/oMs0XTzvMQfk8ZRkmgPX/ULLOe0jb2e5jAtIbTnMP/Q9HqCIs7iE5apYr/Y72Xx+UDo1aMcoSl26Vl8MP0HZ7ftGKWX4/4ovez4jIOFbz0tj9LDLMvDwA1fu7ItX7uyssEHjC/Q8gg73L5v/dS2Dad2LUc4wg4b/uIIOzyvyyNskx0jbNvQZO3+HuVhjvVmv+O7WfGJXRxhf3FDLcflbkgNaB19erxNazNx4bX9liPtmN2J1pTW7xvR6tbqfcN3bGNrXnbcN8JjWe7K0Xez1ruy398MIMyx3g2jharlbhielOVu6OGM8TUkFWzW377TC8+lLrmWutrrJNHuy2XabaVhwvhsNE85QsN2vsyRD9qg38py/tPZaA9J7x8LsuS3j0WuLKXsOBauUXzzWOamAvnAm8A3jqWGZzfcxSpPn8GDHE12IDv6utIqslvZgewtL/5Y2zBXG+VYx2S0I+YyJre8JRZfoNWhfl+gvX2BfMNbVX7/5Z8vGv7iUL/t2LbIjx3jAz/qhvN6/5XTMMdy5/G0YcOh+MTuGWPUawa7wcB/Hh54/AWtx5l1o9iTnnNEt558zRCds+5/fyGyxAdS5XJJNDqQKMcU0Crvo9/Kcc1dn3OJKUoSbWbhZa4MOF2451ug52PDjdSjlZvFG6nnHRu7e96xm3p8LMtsyzs2U/Ns99kW5VjnUq4buJTLz3Mp2QqXwiR8B4Uv9vwGt1D+lsupkvT67bGPHYqDblj8kcX5DPUb3iR+AfV6eTS9lO3OJNF7W8dcuRE+tXwvSZpjLslHejNJzlcSiY4kVCmul+os/Dnhnl/lekj2470k+eqD+ZdNv56TRFNvS2+ifXUck/j5aMG1iRZsdhxHuniff/HSv5dEdiQ57ie5OHA21qCNhK+RyrUipxCPv5dE5zAnqW5J4u8mmYBNavZ2kuNaMk0bfs7bSa5573Od/diQRN5OolcS09dJit/uw/FxzO6XLOo5pd1nSUj5+abQx/cnXh+HpQ2Uj5IsU97u0zU+jkXKW/nZ41il/BdJZEeS436SVcqHg9dVyodJVim/nsTfTbJI+S+SrFF++ee8nWSV8stJ5O0ki5T3+3SNj2OR8jX9LOX77ezzqbwFJ7XKhs4XJlntfOtJ/N0ki53viyRrnW/557ydZLXzLSeRt5Msdr6Wbzf6+DgWO18037/a+cKn8Xbt9pWCyxut6Cw/jYcrVKvjtCjJ8jit3WdrfBxr47R6pJ89jtVx2hdJZEeS436SxXFaPez+rSJOsnir+EYSfzfJ2q3iqyRLt4r1n/N2ksVbxXoSeTvJ2q2iptvPWl8cx9qtoqb7swIx5deexmvaMOcaJlmlfM236frFcSxSPsvPHsci5b9KIjuSHPeTrFI+b5hzjZOsUj5vmHP9Iski5fOGOdf1n/N2klXK5w1zrl8kWaS83KbrF8exSHlpP0v5xafxGq1nLXe+MMlq51tP4u8mWex8XyRZ63zLP+ftJKudbzmJvJ1ksfOV43bni49jsfOV27MCsbpgenW+9Np/qOH7WKvqQo22NV5VF2r0UtequlCL31cX4iSL6kKcZFFdqHbcnyypOxa16o5FrXp/UavuWNSq9xe16o5FrbpjUavuWNSqOxa16o5FrbpjUavuWNSqOxa16o5FrbpjUavuWNSqOxa16o5FrXp/UavuWNSq9xe1vqD84mRJuEiwSvkoyTLl6326xsexSPnqP3scq5T/IonsSHLcT7JK+ZY3UD5Mskr59ST+bpJFyn+RZI3yyz/n7SSrlF9OIm8nWaN8u7+s9cVxrFG+HfKzlF+cLGnRXoarnS9Ostj5vpHE302y1vm+SrLU+dZ/zttJFjvfehJ5O8li50u3lYEvjmOx80W7GC52vvhpfE1daGnDiwRtx6JW27Go1e4varUdi1rt/qJW27Go1XYsarUdi1ptx6JW27Go1XYsarUdi1ptx6JW27Go1XYsarUdi1ptx6JW27Go1e4varUdi1rt/qLWF5RfexpvumHONUyyTPn7r2l9cRyLlNfys8exSnndMOf6VZLjfpJVypcNc65xklXKlw1zrl8kWaR82TDnuv5z3k6ySvmyYc71iySLlL//mtYXx7FIeUs/S/nVp3Hb8CJBnGS1860n8XeTLHY+2/AiwfrPeTvJaudbTiJvJ1nsfH5bGfjiOBY7n9+eFYjVhf6awWfnq8GOc2GSOj9Pd0681XeTXJ8pqfbukTS/pAMJ9rGMd9ScX+zLBfuhf3Oja7uGjAaYfDNLu/Y+acF22eEW4u3atF5fbyHearif5vxSm/zy5bznLcRbtNlcm18AbNid2uw5RbTR1eJ3aFqNvni0ulNpi1a1lnfrabVGZ3Zpt55Wo1mK1d16WgsHsIu7qrW24+svLVoqWN3dJv5Bq9sPhT9occuf1Rz+9nGsbYkWN5TV7fdaq1saSttwXtuG81p3tJLwzC5uUiXHsWGv7TPL7b22v8ix1NriHKsoOLPc32v7ixN7/2s2Jc+Pa563VHl1H5UjhYxNfvWdjw/XPtJ4fU4TCsXz0y/nWDi9upV+fJowuPPMzYZVOQL17xxImVvZfny+JTiQaA9az3O7YfOCx7enb618keYce84vDFc/WpAmnDA8rq/2iQQ/KXotVq4N1aXgSL6XpF5PgfyQzfrYT+e3HUs5/HWbzeEXi22i4AJbef4lOZylm59fzRm/5Pck0Sdcy/wgdy0YP6b6rSS6mGT559Tg50Rb7uv86jq+yvh7ikjUznaZzbXeTyL4GOo3k5Qribx7JGWOhaXU4Ejk2NBK4iSrrWT15zR5s5XUOa91RB0n2opQj/kRKT08Oq+h7zKfds7JtutIND3fzKOvc6Wa5nRSxcPod7PMz/d+lSU8LROv5z/04LS0u49vcuhx//HtzJLuj2O/OJblcaxuGcfqhnGsbhmD6v3PHH1xUjaMQcscs52zl/rqfh5lqPlxfU/EBqPYaOkgf8ziPlrJOaVaXo+0ou8TpWvKL3HeMNX6rYOxOdY6yzgrvx+MRMi//8G/gu8gcrbu95Mbi1rzI25nudrrR4ToJa6i17cqVYNHhEjWsmM+Bp6j+yNIEjxgF5vTw7+cV/nWgUxWW0rBgcR2/8U2w2R3fW4ntuErR2eWDV85OrPI/ZuPbfjK0Zllw1eOvsiyOLF0ZvH7tw3zHbcNaxtuG4s/x8u7F3n5rh6te63f1V3uX57FHOE5iXKsX2LfMTIIT+ziyOALRqb5nusJOn/NyOhlrtVJofhA5pdiz0WwYFIoepvLi80vNp3lEkwK1bzhtv7V0XiZwC7t9VeFzzThtyYuSv7yJnJZHwGWeTMtNMB+a3DRAtjyJ6i/SlPnMvaJbsnvprkcvY8vWd84mtUPYkd769kcIYs5PuUh+TsHs+Gz2qXM8XHhBMLztY4mMq5J63o+yP6a4p/O8E//8ue//fNf/u1f/vSff/63v/7Hx7/8+GrbWPn+40fZ+7hJe7mi3K5yPlBOKGeUBWVFuaBsKKPejHoz6hXUK6hXUK+gXkG9gnoF9QrqFdQrqFdRr6JeRb2KehX1KupV1KuoV1Gvot6CegvqLai3oN6CegvqLai3oN6CegvqNdRrqNdQr6FeQ72Geg31Guo11Guo11Gvo15HvY56HfU66nXU66jXUa+j3op6K+qtqLei3op6K+qtqLei3op6K+ptqLeh3oZ6G+ptqLeh3oZ6G+ptqLdd9abjQDmhnFEWlBXlgrKh7ChXlFFvQr0J9SbUm1BvQr0J9SbUC14l8CqBVwm8SuBVAq8SeJXAqwReJfAqgVcJvErgVQKvEniVwKsEXiXwKoFXCbxK4FUCrxJ4lcCrBF4l8CqBVwm8SuBVAq8SeJXAqwReJfAqgVcJvErgVQKvEniVwKsEXiXwKoFXCbxK4FUCrxJ4lcCrBF4l8CqBVwm8SuBVAq8SeJXAqwReJfAqgVcJvErgVQKvEniVwKsEXiXwKoFXCbxK4FUCrxJ4lcCrBF4l8CqBVwm8SuBVAq8SeJXAqwReJfAqgVcZvMrgVQavMniVwasMXmXwKoNXGbzK4FUGrzJ4lcGrDF5l8CqDVxm8yuBVBq8yeJXBqwxeZfAqg1cZvMrgVQavMniVwasMXmXwKoNXGbzK4FUGrzJ4lcGrDF5l8CqDVxm8yuBVBq8yeJXBqwxeZfAqg1cZvMrgVQavMniVwasMXmXwKoNXGbzK4FUGrzJ4lcGrDF5l8CqDVxm8yuBVBq8yeJXBqwxeZfAqg1cZvMrgVQavMniVwasMXmXwKoNXGbzK4FUGrzJ4lcGrDF5l8CqDVxm8yuBVBq8yeJXBqwxeZfAqg1cZvMrgVQavMngl4JWAVwJeCXgl4JWAVwJeCXgl4JWAVwJeCXgl4JWAVwJeCXgl4JWAVwJeCXgl4JWAVwJeCXgl4JWAVwJeCXgl4JWAVwJeCXgl4JWAVwJeCXgl4JWAVwJeCXgl4JWAVwJeCXgl4JWAVwJeCXgl4JWAVwJeCXgl4JWAVwJeCXgl4JWAVwJeCXgl4JWAVwJeCXgl4JWAVwJeCXgl4JWAVwJeCXgl4JWAVwJeCXgl4JWAVwJeCXgl4JWAVwJeCXgl4JWAVwJeCXgl4JWAVwJeCXgl4JWAVwJeCXgl4JWAVwJeCXil4JWCVwpeKXil4JWCVwpeKXil4JWCVwpeKXil4JWCVwpeKXil4JWCVwpeKXil4JWCVwpeKXil4JWCVwpeKXil4JWCVwpeKXil4JWCVwpeKXil4JWCVwpeKXil4JWCVwpeKXil4JWCVwpeKXil4JWCVwpeKXil4JWCVwpeKXil4JWCVwpeKXil4JWCVwpeKXil4JWCVwpeKXil4JWCVwpeKXil4JWCVwpeKXil4JWCVwpeKXil4JWCVwpeKXil4JWCVwpeKXil4JWCVwpeKXil4JWCVwpeKXil4JWCVwpeKXhVwKsCXhXwqoBXBbwq4FUBrwp4VcCrAl4V8KqAVwW8KuBVAa8KeFXAqwJeFfCqgFcFvCrgVQGvCnhVwKsCXhXwqoBXBbwq4FUBrwp4VcCrAl4V8KqAVwW8KuBVAa8KeFXAqwJeFfCqgFcFvCrgVQGvCnhVwKsCXhXwqoBXBbwq4FUBrwp4VcCrAl4V8KqAVwW8KuBVAa8KeFXAqwJeFfCqgFcFvCrgVQGvCnhVwKsCXhXwqoBXBbwq4FUBrwp4VcCrAl4V8KqAVwW8KuBVAa8KeFXAqwJeFfCqgFcFvCrgVQGvCnhVwKsCXhXwqoBXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXFbyq4FUFryp4VcGrCl5V8KqCVxW8quBVBa8qeFXBqwpeVfCqglcVvKrgVQWvKnhVwasKXlXwqoJXFbyq4FUFryp4VcGrCl5V8KqCVxW8quBVBa8qeFXBqwpeVfCqglcVvKrgVQWvKnhVwasKXlXwqoJXFbyq4FUFryp4VcGrCl5V8KqCVxW8quBVBa8qeFXBqwpeVfCqglcVvKrgVQWvKnhVwasKXlXwqoJXFbyq4FUFryp4VcGrCl5V8KqCVxW8quBVBa8qeFXBqwpeVfCqglcVvKrgVQWvKnhVwasKXlXwqoJXFbyq4FUFryp41cCrBl418KqBVw28auBVA68aeNXAqwZeNfCqgVcNvGrgVQOvGnjVwKuWUC941cCrBl418KqBVw28auBVA68aeNXAqwZeNfCqgVcNvGrgVQOvGnjVwKsGXjXwqoFXDbxq4FUDrxp41cCrBl418KqBVw28auBVA68aeNXAqwZeNfCqgVcNvGrgVQOvGnjVwKsGXjXwqoFXDbxq4FUDrxp41cCrBl418KqBVw28auBVA68aeNXAqwZeNfCqgVcNvGrgVQOvGnjVwKsGXjXwqoFXDbxq4FUDrxp41cCrBl418KqBVw28auBVA68aeNUuXslx8eosJ5QzyoKyolxQNpQd5Yoy6k2oN6HehHoT6k2oN6HehHoT6k2oN6HejHoz6s2oN6PejHoz6s2oN6PejHoz6hXUK6hXUK+gXkG9gnoF9QrqFdQrqFdRr6JeRb2KehX1KupV1KuoV1Gvot6CegvqLai3oN6CegvqLai3oN6CegvqNdRrqNdQr6FeQ72Geg31Guo11Guo11Gvo15HvY56HfU66nXU66jXUa+j3op6K+qtqLei3op6K+qtqLei3op6K+ptqLeh3oZ6G+ptqLeh3oZ6G+ptqBe8gt8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd9+llEveAW/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbz/LqBe8gt8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2gd8u8NsFfrvAbxf47QK/XeC3C/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47WcZ9YJX8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3K/x2hd+u8NsVfrvCb1f47Qq/XeG3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t5/lq1747Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99+llEveAW/3eC3G/x2g99u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Q6/3eG3O/x2h9/u8NsdfrvDb3f47Wf5qhd+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u8Nvd/jtDr/d4bc7/HaH3+7w2x1+u3e//VxwqL2cUZaPchp/R3u59HJB2XrZetlRrr088rRebh/lD16dixj930pCOaMsKCvKBWVD2VGuKLerrKPefgyaUM4oC8qKckHZUHaUK8rtKpder/RzWBLKGWVBWVEuKBvKjnJFuV1lQ72Geg31Wq9XvZcV5YKyodzr1f67rNdbci/3eot+lP1AudfrRy9nlAVlRbmgbCg7yhXldpXrgTLqrai3ot6Keivqrai3ot6Keivqbai3od6Gehvqbai3od6Gehvqbai3XfV2v32WE8oZZUFZUS4oG8qOckUZ9SbUm1BvQr0J9SbUm0a93suGsqNcUe711v5vc6+3Si8nlHu9tfRyr7f2fzt49Vnu9dbay4ayo1xRHvV+tPM2ePVZTihnlHu9rR/n4FVLvVxQNpT9Ov7Bq5Z7uV3lwavPckI5X/928OqzrCij3sGrJn//4x/+75/+9uc//a+//Ot//OF//PcZ/p//+uu//Oef/+2vn+F//r///vgv/+tvf/7LX/78//zzv//t3/7lX//3f/3tX//5L//2Lx//7Q/Hx/98NIH/eVI+p386/3K6/qj9MevHH+XPv3r+pXMu/4/pYzeXf/rjH2T8ifU/8Xb+yWemc0Hk44/k+PijNP6o2scf1fqRT2YV5fhjKR9/pB9/9JFQ0x9LeqQ6cVT84z+X3w/K5h9l/WNuH3/k849E/yj9j+oj7/mXRB959fij9mrb9S/aH7XnTcf8J/WPUh//5Prv6R+csxxXk65fnNMfs/3T3//+93/6+/8H",
      "is_unconstrained": false,
      "name": "receive_value",
      "verification_key": "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"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17765343328382640478": {
            "error_kind": "string",
            "string": "Source chain IDs and emitter addresses length mismatch"
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "6539902769847294746": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 16
          },
          "6788092787179896647": {
            "error_kind": "string",
            "string": "Caller is not owner"
          }
        },
        "parameters": [
          {
            "name": "source_chain_ids",
            "type": {
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 8,
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 16
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec"
            },
            "visibility": "private"
          },
          {
            "name": "emitter_addresses",
            "type": {
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 8,
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "register_emitter"
    },
    {
      "abi": {
        "error_types": {
          "10522114655416116165": {
            "error_kind": "string",
            "string": "Can't read a transient note with a zero contract address"
          },
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13060541637244024094": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "14401109495927734611": {
            "error_kind": "string",
            "string": "Field failed to decompose into specified 16 limbs"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15546539856497705002": {
            "error_kind": "string",
            "string": "u16 to u8 conversion failed"
          },
          "15711892660910782274": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16216212843441549037": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "2014890719615096298": {
            "error_kind": "string",
            "string": "Field failed to decompose into specified 40 limbs"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "4648451262681811962": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "6539902769847294746": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 16
          },
          "7555607922535724711": {
            "error_kind": "string",
            "string": "Preimage mismatch"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8171600539936659379": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 92
          },
          "8556029555939094797": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9589626482238399944": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "anchor_block_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "sponge_blob_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "destination_chain_id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 16
            },
            "visibility": "private"
          },
          {
            "name": "value",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "fee_nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::side_effect::counted::Counted"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::scoped::Scoped"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::side_effect::counted::Counted"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::scoped::Scoped"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "note_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 32,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "log",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "fields",
                                          "type": {
                                            "kind": "array",
                                            "length": 18,
                                            "type": {
                                              "kind": "field"
                                            }
                                          }
                                        },
                                        {
                                          "name": "length",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::log::Log"
                                    }
                                  },
                                  {
                                    "name": "note_hash_counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "expected_non_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "expected_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "anchor_block_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "sponge_blob_hash",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_private"
      ],
      "debug_symbols": "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6JyPzvnonI/O+eicj8756JyPzvnonI/O+eicj8756JyPzvnonI/O+eicj8756JyPzvnonI/O+eicj8756JyPzvnonI/O+eicj8756JyPzvnonI/O+eicj8756JyPzvnonI/O+eicj8756JyPzvnonI/O+eicj8756JyPzvnonI/O+eicj8756JyPzvnonM/O+eycz8757JzPzvnsnM/O+eycz8757JzPzvnsnM/O+eycz8757JzPzvnsnM/O+eycz8757JzPzvnsnM/O+eycz8757JzPzvnsnM/O+eycz8757JzPzvnsnM/O+eycz8757JzPzvnsnM/O+eycz8757JzPzvnsnM/O+eycz8757JzPzvnsnM/O+eycz8757JzPzvnsnM/O+eycz8757JzPzvnsnM/O+eycz8757JzPzvnsnM/O+eycz8757JzPzvnsnM/O+eycz8757JzPzvnsnM/O+eycz8757JzPzvnsnM/O+eycz8757JzPzvnsnM/O+eycz8757JyvzvnqnK/O+eqcr8756pyvzvnqnK/O+eqcr8756pyvzvnqnK/O+eqcr8756pyvzvnqnK/O+eqcr8756pyvzvnqnK/O+eqcr8756pyvzvnqnK/O+eqcr8756pyvzvnqnK/O+eqcr8756pyvzvnqnK/OeXYgnWzk/XL+yJv+PE72DX85B305fzSaZtNq2k3WdJq8qT2sPU57nPY47XHa47THaY/THqc9Tnuc9vD28Pbw9vD28Pbw9vD28Pbw9vD2iPaI9oj2iPaI9oj2iPaI9oj2iPa47XHb47bHbY/bHrc9bnvc9rjtccsjG5cejabZtJp2kzWdJm+KpvYY7THaY7THaI/RHqM9RnuM9hjtMdpjtsdsj9kesz1me8z2mO0x22O2x2yP1R6rPVZ7rPZY7bHaY7XHao/VHqs9dnvs9tjtsdtjt8duj90euz0657tzvjvnu3O+O+fZ7XQsaTdZ02nypmi6RZlz0GiaTe1x2uO0x2mP0x6nPU57eHt4e3h7eHt4e3h7eHt4e3h7eHtEe0R7RHtEe0R7RHtEe0R7RHtEe9z2uO1x2+O2x22P2x63PW573Pa45ZHNUY9G02xaTbvJmk6TN0VTe4z2GO0x2mO0x2iP0R6jPUZ7jPYY7THbY7bHbI/ZHrM9ZnvM9pjtMdtjtsdqj9Ueqz1We6z2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",
      "is_unconstrained": false,
      "name": "send_value_private",
      "verification_key": "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"
    },
    {
      "abi": {
        "error_types": {
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15546539856497705002": {
            "error_kind": "string",
            "string": "u16 to u8 conversion failed"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "6539902769847294746": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 16
          },
          "8228371833434187583": {
            "error_kind": "string",
            "string": "Trying to read from uninitialized PublicImmutable"
          }
        },
        "parameters": [
          {
            "name": "destination_chain_id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 16
            },
            "visibility": "private"
          },
          {
            "name": "value",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "fee_nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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AAAa+woqDwETJAIAEwAABx4lAAAbDRwKAgEAKAIAAgQBACcCEwEALQgBDycCFQQRAAgBFQEnAw8EAQAiDwIVJwIWBBBDA6oAAQACABYAEwAVLQsLAQAiAQIBLQ4BCy0IAQEnAgIEIAAIAQIBJwMBBAEAIgECAi0KAhMtDhITACITAhMtDhQTACITAhMtDggTACITAhMtDggTACITAhMtDggTACITAhMtDggTACITAhMtDggTACITAhMtDggTACITAhMtDggTACITAhMtDggTACITAhMtDggTACITAhMtDggTACITAhMtDggTACITAhMtDggTACITAhMtDggTACITAhMtDggTACITAhMtDggTACITAhMtDggTACITAhMtDggTACITAhMtDggTACITAhMtDggTACITAhMtDggTACITAhMtDggTACITAhMtDggTACITAhMtDggTACITAhMtDggTACITAhMtDggTACITAhMtDggTACITAhMtDggTACITAhMtDggTACITAhMtDggTLQgBAicCCAQJAAgBCAEnAwIEAQAiAgIILQoIEi0OARIAIhICEi0OCxIAIhICEi0OCxIAIhICEi0OCxIAIhICEi0OCxIAIhICEi0OCxIAIhICEi0OCxIAIhICEi0OCxItDgINJwIBBBAnAgIEHy0KDgQjAAAJCgwqBAEIJAIACAAAF6ojAAAJHC0LDQQtCAEIAAABAgEtCAELAAABAgEtCAENJwIPBP4ACAEPAScDDQQBACINAg8nAhAE/QAqEA8QLQoPEg4qEBITJAIAEwAACXMtDgoSACISAhIjAAAJWC0ODQgtDhELLQgBDScCDwT5AAgBDwEnAw0EAQAiDQIPJwIQBPgAKhAPEC0KDxIOKhASEyQCABMAAAm8LQ4KEgAiEgISIwAACaEtCAEPAAABAgEtDg0PLQgBDScCEAQgAAgBEAEnAw0EAQAiDQIQJwISBB8AKhIQEi0KEBMOKhITFCQCABQAAAoKLQ4KEwAiEwITIwAACe8nAhAECCcCEgT4LQoOASMAAAodDCoBEBMkAgATAAAWciMAAAovLQsPAicCBAT9LQoOASMAAApBDCoBEg0kAgANAAAWASMAAApTLQsLAgAqAhINDioCDQ8kAgAPAAAKbiUAABr7LQsIAgwqDQQPJAIADwAACoQlAAAbHy0CAgMnAAQE/iUAABp4LQgFDwAiDwIQACoQDRItDgwSACoNEQIOKg0CDCQCAAwAAAq7JQAAGvsMKgIEDCQCAAwAAArNJQAAGx8tAg8DJwAEBP4lAAAaeC0IBQwAIgwCDQAqDQIQLQ4FEAAqAhEFDioCBQ0kAgANAAALBCUAABr7DCoFBAIkAgACAAALFiUAABsfLQIMAycABAT+JQAAGngtCAUCACICAg0AKg0FDy0OCQ8AKgURCQ4qBQkMJAIADAAAC00lAAAa+wwqCQQFJAIABQAAC18lAAAbHy0CAgMnAAQE/iUAABp4LQgFBQAiBQIMACoMCQ0tDgMNLQ4FCAAqCRECDioJAgMkAgADAAALmiUAABr7LQ4CCy0LBQIAIgICAi0OAgUtCAECAAABAgEpAgADAGXvzn4tCAEIJwIJBP8ACAEJAScDCAQBACIIAgktCgkLLQ4DCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCwAiCwILLQ4KCy0OCAInAgME/i0KDgEjAAAU1AwqAQQIJAIACAAAFasjAAAU5i0LAgEAIgECAjkDoABEAEQABwADAAIgAgABIQIAAi0IAQQAIgQCBy0LBwctCgcGJwII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",
      "custom_attributes": [
        "abi_public"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "send_value_public"
    },
    {
      "abi": {
        "error_types": {
          "10522114655416116165": {
            "error_kind": "string",
            "string": "Can't read a transient note with a zero contract address"
          },
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13060541637244024094": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8556029555939094797": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [
          {
            "name": "message_ciphertext",
            "type": {
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 17,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec"
            },
            "visibility": "private"
          },
          {
            "name": "message_context",
            "type": {
              "fields": [
                {
                  "name": "tx_hash",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "unique_note_hashes_in_tx",
                  "type": {
                    "fields": [
                      {
                        "name": "storage",
                        "type": {
                          "kind": "array",
                          "length": 64,
                          "type": {
                            "kind": "field"
                          }
                        }
                      },
                      {
                        "name": "len",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "std::collections::bounded_vec::BoundedVec"
                  }
                },
                {
                  "name": "first_nullifier_in_tx",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "recipient",
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::messages::processing::message_context::MessageContext"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_utility"
      ],
      "debug_symbols": "TJ3LsjS7bpzf5Yw9aIIECfpVPHBYvigUoZAifBnp5b0KSSBz4vOltX8milXIrq5G9/qPf/yP//lP/++f/+u//Nv/+vf/84///F/+4x//9L//5V//9V/++b/+67//9//2f//l3//t7//3P/7x+/6f+Pt/53/6R4x//Gf/+x/D/0z8z8L/OP5n438O/ifwPzf/5/7wP1jlYpWLVS5WuVjlYpWLVS5WuVhl/H7vf8f7X3v/O9//rve//v53v/8973/j/e9bb7z1xltvvPXGW2+89cZbb7z1xltvvPXGW8/eevbWs7eevfXsrWdvPXvr2VvP3nr21ptvvfnWm2+9+dabb7351ptvvfnWm2+9+dZbb7311ltvvfXWW2+99dZbb7311ltvvfXW87eev/X8redvPX/r+VvP33r+1vO/9c73vxf/u3/vf8f737/1xu+DWbAK/pYc84O/NUf+x6cgCu6D8ysYBX8r2/hgFqwCL/hb2eyDUxAF38rfEXztARgF38rxwSxYBV6wC05BFNwHX8sARkGtfGvlWyt/zTO/bfnaB3AKouAC7OsiwCiwglmwCrxgF5yCKKiVR608auVRK49aedTKo1YetfKolUetPGplq5W/1pr2gRXMglXgBbvgFETBffD1GKBWnrXyrJVnrTxr5Vkrz1p51sqzVl618qqVV628auVVK69aedXKq1ZetfKqlb1W9lrZa2Wvlb1W9lrZa2Wvlb1W9lp518q7Vt618q6Vd628a+VdK+9aedfKu1Y+tfKplU+tfGrlUyufWvnUyqdWPrXyqZWjVo5aOWrlqJWjVo5aOWrlrwenfxAF98HXg4BRYAWzYBV4wS6olW+tfN/KM3swPhgFVvC38pofrAIv2AWnIArug68HAaPACmrlUSuPWnm8RJrjFETBS6Rpv4JRYAWzYBV4Qa1stbLVyl8Prv0HXw8CRoEVzIJV4AW74BREQa28auVVK69a+evBdT5YBV6wC05BFNwHXw8CRoEV1MpeK3utnK+A64NTEAX3wdeDgFFgBbNgFXhBrbxr5V0r71r51MqnVj618qmVT618auVTK59a+dTKp1aOWjlq5aiVo1aOWjlq5aiVo1aOWjlq5Vsr31r51sq3Vr618q2Vb618a+VbK9+38vr9CkaBFcyCVeAFu+AUREGtPGrlUSuPWnnUyqNWHrXyqJVHrTxq5VErW61stbLVylYrW61stbLVylYrW61stfKslWetPGvlWSvPWnnWyrNWnrXyrJVnrbxq5VUrr1p51cqrVl618qqVV628auVVK3ut7LWy18peK3ut7LVy9eCqHlzVg6t6cFUPrurBVT24qgdX9eCqHlzVg6t6cFUPrurBVT24qgdX9eCqHlzVg6t6cFUPrurBVT24qgdX9eCqHlzVg6t6cFUPrurBVT24qgdX9eCqHlzVg6t6cFUPrurBVT24qgdX9eCqHlzVg6t60KsHvXrQqwe9etCrB7160KsHvXrQqwe9etCrB7160KsHvXrQqwe9etCrB7160KsHvXrQqwe9etCrB7160KsHvXrQqwe9etCrB7160KsHvXrQqwe9etCrB7160KsHvXrQqwe9etCrB7160KsHvXrQqwe9etCrB7160KsHvXrQqwe9etCrB7160KsHvXrQqwe9etCrB7160KsHvXrQqwe9etCrB7160KsHvXrQqwe9etCrB7160KsHvXrQqwe9etCrB7160KsHvXrQqwe9etCrB7160KsHvXrQqwe9etCrB7160KsHvXrQqwe9etCrB7160KsHvXrQqwe9enBXD+7qwV09uKsHd/Xgrh7c1YO7enBXD+7qwV09uKsHd/Xgrh7c1YO7enBXD+7qwV09uKsHd/Xgrh7c1YO7enBXD+7qwV09uKsHd/Xgrh7c1YO7enBXD+7qwV09uKsHd/Xgrh7c1YO7enBXD+7qwV09uKsHd/Xgrh7c1YO7enBXD+7qwV09uKsHd/Xgrh7c1YO7enBXD+7qwV09uKsHd/Xgrh7c1YO7enBXD+7qwV09uKsHd/Xgrh7c1YO7enBXD+7qwV09uKsHd/Xgrh7c1YO7enBXD+7qwV09uKsHd/Xgrh7c1YO7enBXD+7qwV09uKsHd/Xgrh7c1YO7enBXD+7qwV09uKsHT/XgqR481YOnevBUD57qwVM9eKoHT/XgqR481YOnevBUD57qwVM9eKoHT/XgqR481YOnevBUD57qwVM9eKoHT/XgqR481YOnevBUD57qwVM9eKoHT/XgqR481YOnevBUD57qwVM9eKoHT/XgqR481YOnevBUD57qwVM9eKoHT/XgqR481YOnevBUD57qwVM9eKoHT/XgqR481YOnevBUD57qwVM9eKoHT/XgqR481YOnevBUD57qwVM9eKoHT/XgqR481YOnevBUD57qwVM9eKoHT/XgqR481YOnevBUD57qwVM9eKoHT/XgqR481YOnevBUD57qwVM9eKoHT/XgqR481YOnejCqB6N6MKoHo3owqgejejCqB6N6MKoHo3owqgejejCqB6N6MKoHo3owqgejejCqB6N6MKoHo3owqgejejCqB6N6MKoHo3owqgejejCqB6N6MKoHo3owqgejejCqB6N6MKoHo3owqgejejCqB6N6MKoHo3owqgejejCqB6N6MKoHo3owqgejejCqB6N6MKoHo3owqgejejCqB6N6MKoHo3owqgejejCqB6N6MKoHo3owqgcje/B8YAWz4G/lPT7wgl1wCqLgPvh6EDAKrGAW1MpRK0etHLVy1MpRK99a+dbKt1a+tfKtlW+tfGvlWyvfWvm+le/vVzAKrGAWrAIv2AWnIApq5VErj1p51MqjVh618qiVR608auVRK49a2Wplq5WtVrZa2Wplq5WtVrZa2Wplq5VnrTxr5Vkrz1p51sqzVp618qyVZ608a+VVK69aedXKq1ZetfKqlVetvGrlVSuvWtlrZa+VvVb2WtlrZa+VvVb2WtlrZa+Vd628a+VdK+9aedfKu1betfKulXetvGvlUyufWvnUyqdWrh681YO3evBWD97qwVs9eKsHb/XgrR681YO3evBWD97qwVs9eKsHb/XgrR681YO3evBWD97qwVs9eKsHb/XgrR681YN/n7L/mkaTNc2m1eRNu+k0RVN7jPYY7THaY7THaI/RHqM9RnuM9hjtYe1h7WHtYe1h7WHtYe1h7WHtYe0x22O2x2yP2R6zPWZ7zPaY7THbY7bHao/VHqs9Vnus9ljtsdpjtcdqj9Ue3h7eHt4e3h7eHt4e3h7eHt4e3h67PXZ77PbY7bHbY7fHbo/dHrs9dnuc9jjtcdrjtMdpj9Mepz1Oe5z2OO0R7RHtEe0R7RHtEe0R7RHtEe0R7XHb47bHbY/bHrc9bnvc9rjtcduj+3x0n4/u89F9PrrPR/f56D4f3eej+3x0n4/u89F9PrrPR/f56D4f3eej+3x0n4/u89F9PrrPR/f56D4f3eej+3x0n4/u89F9PrrPR/f56D4f3eej+3x0n4/u89F9PrrPR/f56D4f3eej+3x0n4/u89F9PrrPR/f56D4f3eej+3x0n4/u89F9PrrPR/f56D4f3eej+3x0n4/u89F9PrrPR/f56D4f3eej+3x0n4/u89F9PrrPR/f56D4f3eej+3x0n4/u89F9PrrPR/f56D4f3eej+3x0n4/u89F9PrrPR/f56D4f3eej+3x0n4/u89F9PrrPR/f56D4f3eej+3x0n4/u89F9PrrPrfvcus+t+9y6z6373LrPrfvcus+t+9y6z6373LrPrfvcus+t+9y6z6373LrPrfvcus+t+9y6z6373LrPrfvcus+t+9y6z6373LrPrfvcus+t+9y6z6373LrPrfvcus+t+9y6z6373LrPrfvcus+t+9y6z6373LrPrfvcus+t+9y6z6373LrPrfvcus+t+9y6z6373LrPrfvcus+t+9y6z6373LrPrfvcus+t+9y6z6373LrPrfvcus+t+9y6z6373LrPrfvcus+t+9y6z6373LrPrfvcus+t+9y6z6373LrPrfvcus+t+9y6z6373LrPrfvcus+t+9y6z2f3+ew+n93ns/t8dp/P7vPZfT67z2f3+ew+n93ns/t8dp/P7vPZfT67z2f3+ew+n93ns/t8dp/P7vPZfT67z2f3+ew+n93ns/t8dp/P7vPZfT67z2f3+ew+n93ns/t8dp/P7vPZfT67z2f3+ew+n93ns/t8dp/P7vPZfT67z2f3+ew+n93ns/t8dp/P7vPZfT67z2f3+ew+n93ns/t8dp/P7vPZfT67z2f3+ew+n93ns/t8dp/P7vPZfT67z2f3+ew+n93ns/t8dp/P7vPZfT67z2f3+ew+n93ns/t8dp/P7vPZfZ6zShvT1dF0i7LPT9JosqbZtJq8aTedpmi6j3Jw6dFosqbZtJq8aTedpmhqj9Eeoz1Ge4z2GO0x2mO0x2iP0R6jPaw9rD2sPaw9rD2sPaw9rD2sPaw9ZnvM9pjtMdtjtsdsj9kesz1me8z2WO2x2mO1x2qP1R6rPVZ7rPZY7bHaw9vD28Pbw9vD28Pbw9vD28Pbw9tjt8duj90euz12e+z22O2x22O3x26P0x6nPU57nPY47XHa47THaY/THqc9oj2iPaI9oj2iPaI9oj2iPaI9oj26z1f3+eo+X93nq/s856L2TdpNpyma7qMcjno0mqxpNq0mb9pNpyma2mO0x2iP0R6jPUZ7jPYY7THaY7THaA9rD2sPaw9rD2sPaw9rD2sPaw9rj9kesz1me8z2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TLdInMRFdOImHmIQbyOyBDiIdDt0O3Q7dDt0O3Q7dDt0C7oF3YJuQbegW9At6BZ0C7oF3S7dLt0u3S7dLt0u3S7dLt0u3W67rd+POIhGnMRFdOImHmIQ6TboNug26DboNug26DboNug26DboZnQzuhndjG5GN6Ob0c3oZnQzuk26TbpNuk26TbpNuk26ZZZ8v3trOYBYeBszS77fw7WcQSw04iQuohM38RCDeBudbk43p5vTzenmdHO6Od2cbk63TbdNt023TbdNt023TbdNt023TbdDt0O3Q7dDt0O3Q7dDt0O3Q7dDt6Bb0C3oFnQLugXdgm5Bt6Bb0O3S7dLt0u3S7dLt0u3S7dLt0u22W44vFg6iESdxEZ24iYcYRLoNug26DboNug26DboNug26DboNuhndjG5GN6Ob0c3oZnQzuhndjG6TbpNuk26TbpNuk26TbpNuk26TbswSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSWbWbKZJZtZspklm1mymSWbWbKZJZtZspklm1mymSWbWbKZJZtZspklm1mymSWbWbKZJZtZspklm1mymSWbWbKZJZtZspklm1mymSWbWbKZJZtZspklm1mymSWbWbKZJZtZspklm1mymSWbWbKZJZtZspklm1mymSWbWbKZJZtZspklm1mymSWbWbKZJZtZspklm1mymSWbWbKZJZtZspklm1mymSWbWbKZJZtZspklm1mymSWbWbKZJZtZspklm1mymSWbWbKZJZtZspklm1mymSWbWbKZJZtZspklm1mymSWbWbKZJZtZspklm1mymSWbWbKZJZtZspklh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKQJTtxEZ24iYcYxNuILAEOohHptui26Lbotui26Lbo5nRzujndnG5ON6dbZonhzxkcYhA/N8uNyix5OIifm53ESVxEJ27iIQbxNmaWPBxEuh26Hboduh26Hboduh26Bd0ySyx3J7Pk4SQuohM38RCDeBszSx7S7dLt0u3S7dLt0u3S7dLttluOehYOohEncRGduImHGES6DboNug26DboNug26DboNug26DboZ3YxuRjejm9HN6GZ0M7oZ3Yxuk26TbpNuk26TbpNuk26TbpNuk26Lbotui26Lbotui26Lbotui26Lbk43p5vTzenmdHO6Od2cbk43p9um26bbptum26bbptum26bbptum26Hboduh26Hboduh26Hboduh26Fb0I1ZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJgllxmyWWWXGbJZZZcZsllllxmyWWWXGbJZZZcZsllllxmyWWWXGbJZZZcZsllllxmyWWWXGbJZZZcZsllllxmyWWWXGbJZZZcZsllllxmyWWWXGbJZZZcZsllllxmyWWWXGbJZZZcZsllllxmyWWWXGbJZZZcZsllllxmyWWWXGbJZZZcZsllllxmyWWWXGbJZZZcZsllllxkSSQOohEncRGduImHGMTbeOh26Hboduh26Hboduh26HbodugWdAu6Bd2CbkG3oFvQLegWdAu6Xbpdul26Xbpdul26Xbpdul263XKbv9+POIhGnMRFdOImHmIQ6TboNug26DboNug26DboNug26DboZnTLLPn+LtzMQdbCSfzcvj/zNXOWtXATDzGItzGz5OEgGnES6TbpNuk26TbpNum26Lbotui26Lbotui26Lbotui26OZ0c7o53ZxuTjenm9PN6eZ0c7ptum26bbptum26bbptum26bbptuh26Hboduh26Hboduh26Hboduh26Bd2CbkG3oFvQLegWdAu6Bd2Cbpdul26Xbpdul26Xbpdul26XbrfdMPf6cBCNOImL6MRNPMQg0m3QbdBt0G3QbdBt0G3QbdBt0G3QzehmdDO6Gd2YJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1lizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLMHca/4BXMy9PnRiup3EQwziLcTc68NBNOIkLqITN/EQ020k3kZkCXAQjTiJi+jETTxEug26Gd2MbkY3o5vRzehmdDO6Gd2MbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui25ON6eb083p5nRzujndnG5ON6fbphuy5CYacRIX0YmbeIhBvI3IEiDdDt0O3TJLViQ6cRM/t4X/Noi3MbNk/RIH0YiTuIhO3MRDDOJtvHS7dLt0u3S7dLt0u3S7dLt0u+2GudeHg2jESVxEJ27iIQaRboNug26DboNug26DboNug26DboNuRjejm9HN6GZ0M7oZ3YxuRjej26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26LbopvTzenmdHO6Od2cbk43p5vTzem26bbptum26bbptum26bbptum26XbohmevnmjESVxEJ27iIQbxNuLZK5BuQbegW9At6BZ0C7oF3YJul26Xbpdul26Xbpdul26Xbpdut90w9/pwEI04iYvoxE08xCDSbdBt0G3QbdBt0G3QbdBt0G3QbdDN6GZ0M7oZ3YxuRjejm9HN6GZ0m3SbdJt0m3SbdJt0m3SbdJt0m3RbdFt0W3RbdFt0W3RbdFt0W3RbdHO6Od2cbk43p5vTzenmdHO6Od023TbdMkv8lziJi/i5+UzcxEP83L4/Xzcx9wrMLHk4iEacxEV04iYeIt0O3YJuQbegW9At6BZ0C7oF3YJuQbdLt0u3S7dLt0u3S7dLt0u3S7fbbph7fTiIRpzERXTiJh5iEOk26DboNug26DboNug26DboNug26GZ0M7oZ3YxuRjejm9HN6GZ0M7pNuk26TbpNuk26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",
      "is_unconstrained": true,
      "name": "process_message"
    },
    {
      "abi": {
        "error_types": {
          "12256088423018033107": {
            "error_kind": "string",
            "string": "Function _validate_emitter_and_update_value can only be called by the same contract"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14415304921900233953": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15546539856497705002": {
            "error_kind": "string",
            "string": "u16 to u8 conversion failed"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16810041750452690220": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 27
          },
          "17765343328382640478": {
            "error_kind": "string",
            "string": "Source chain IDs and emitter addresses length mismatch"
          },
          "18173155084464344029": {
            "error_kind": "string",
            "string": "Emitter not registered"
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "6539902769847294746": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 16
          },
          "6788092787179896647": {
            "error_kind": "string",
            "string": "Caller is not owner"
          },
          "8228371833434187583": {
            "error_kind": "string",
            "string": "Trying to read from uninitialized PublicImmutable"
          },
          "9967937311635654895": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          }
        },
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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DEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgtDEkYACIYAhgt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JwMQBAEAIhACES0KERItDgISACISAhItDgMSACISAhItDgQSACISAhItDgMSACISAhItDgUSACISAhItDgYSACISAhItDgMSACISAhItDggSACISAhItDgcSACISAhItDgkSACISAhItDgoSACISAhItDgkSACISAhItDgwSACISAhItDg0SACISAhItDgUSACISAhItDgsSACISAhItDggSACISAhItDg4SACISAhItDgcSACISAhItDgkSACISAhItDgoSACISAhItDgkSACISAhItDgwSACISAhItDg0SACISAhItDgUSACISAhItDgsSACISAhItDg8SCiBHSgIkAgACAAAoGScCAwQeLQgBBCcCBQQeAAgBBQEtCgQFKgMABQXpSUPomzfdLAAiBQIFACIQAgYnAgcEGy0CBgMtAgUELQIHBSUAADcNJwIGBBsAKgUGBS0MTAUAIgUCBS0OAQUAIgUCBTwOAwQtCwUGACIMAg0AKg0EDy0LDwcAIhUCDwAqDwQRLQsRDQoqBw0PBCoGDwctDgcFACIESwYtCgYEIwAAJhUAIgUCDAAqDAYNLQsNBC0LBwwtAgwDJwAEBCElAAA4HC0IBQ0AIg0CEQAqEQYSLQ4EEi0ODQcAIgZLBC0KBAYjAAAluy0LEA4tCw0VACoVBhYOKhUWFyQCABcAACi4JQAANukMIhZQFSQCABUAACjKJQAAOAoAIg4CFwAqFxYYLQsYFS0LFA4tAg4DJwAEBCElAAA4HC0IBRYAIhYCFwAqFwYYLQ4VGC0OFhQAIgZLDi0KDgYjAAAjHAAiDUsVACIGAhgAKhgNGS0LGRctCxAYDCoVFBkkAgAZAAApNyUAADgKLQIYAycABAT/JQAAOBwtCAUZACIZAhoAKhoVGy0OFxstDhkQLQoVDSMAACFpLQsXGAAqDRgZDioNGR0kAgAdAAApfyUAADbpACIQAh0AKh0NHi0LHhgtCxQdDCoZEh4kAgAeAAApoyUAADgKLQIdAycABAT+JQAAOBwtCAUeACIeAh8AKh8ZIC0OGCAtDh4UACINSxgtChgNIwAAFtYAIhICHwAqHw0gLQsgHi0LHh8AIh8CHy0OHx4tCxgfACIfAh8tDh8YLQgBHwAAAQIBLQ4YHy0ISB0jAAAqEwwqHRMgJAIAIAAAKsQjAAAqJS0LHx4EKg0THy0I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",
      "custom_attributes": [
        "abi_public"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "public_dispatch"
    },
    {
      "abi": {
        "error_types": {
          "10522114655416116165": {
            "error_kind": "string",
            "string": "Can't read a transient note with a zero contract address"
          },
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13060541637244024094": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8556029555939094797": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_utility"
      ],
      "debug_symbols": "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i26LbpklM1cns+ThIE7iIm7iIRrRiUGk26Hboduh26Hboduh26Hboduh26Gb0c3oZnQzuhndjG5GN6Ob0c3o5nRzujndnG5ON6eb083p5nRzugXdgm5Bt6Bb0C3oFnQLugXdgm6Xbpdul26Xbpdul26Xbpdul2633bIptHAQJ3ERN/EQjejEINJt0G3QbdBt0G3QbdBt0G3QbdBt0G3SbdJt0m3SbdJt0m3SbdJt0m3SbdFt0W3RbdFt0W3RbdFt0W3RjVkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJZdZcpkll1lymSWXWXKZJZdZcpkll1lymSWXWXKZJZdZcpkll1lymSWXWXKZJRdZEom3EVkCHMRJXMRNPEQjOpFuk26Lbotui26Lbotui26Lbotui26Lbptum26bbptum26bbptum26bbptuh26Hboduh26Hboduh26Hboduh25GN6Ob0c3oZnQzuhndjG5GN6Ob083p5nRzujndnG5ON6eb0y2z5PtrbzMbWQsH8XPLP96VvayFm3iIRnRiEG9jZsnDQaTbpdul26Xbpdul26XbLbeVza2FgziJi7iJh2hEJwaRboNug26DboNug26DboNug26DboNuk26TbpNuk26TbpNuk26TbpNuk26Lbotui26Lbotui26Lbotui26Lbptum26bbptum26bbptum26bbptuh26Hboduh26Hboduh26Hboduh25GN6Ob0c3oZnQzuhndjG5GN6Ob083p5nRzujndnG5ON6eb083pFnQLugXdgm5Bt6Bb0C3oFnQLul26Xbpdul26Xbpdul26XbpdujFLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsG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",
      "is_unconstrained": true,
      "name": "sync_private_state"
    }
  ],
  "name": "MessageBridge",
  "noir_version": "1.0.0-beta.15+1a930357477fc0c210dc5a8960680282d4cfa24e",
  "outputs": {
    "globals": {
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "minters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Wormhole"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "state",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "sequences",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "owner",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "receiver_address",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000009"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "token_address",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000d"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_1",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000011"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_2",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000012"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_3",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000013"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_4",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000014"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_5",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000015"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_6",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000016"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_7",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000017"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_8",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000018"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_9",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000019"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_10",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_11",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001b"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_12",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001c"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_13",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001d"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_14",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001e"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_15",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001f"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_16",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000020"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_17",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000021"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_18",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000022"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_19",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000023"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "current_guardian_set_index",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000024"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "MessageBridge"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "config",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "owner",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "registered_emitters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "current_value",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_emitter_chain_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 16
                    }
                  },
                  {
                    "name": "_emitter_address",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "_value",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "MessageBridge::_validate_emitter_and_update_value_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::_validate_emitter_and_update_value_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_wormhole_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "_chain_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 16
                    }
                  },
                  {
                    "name": "_owner",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "_message_fee",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "_consistency",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  }
                ],
                "kind": "struct",
                "path": "MessageBridge::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "MessageBridge::get_config_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "wormhole_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "chain_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 16
                    }
                  },
                  {
                    "name": "message_fee",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "consistency",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  }
                ],
                "kind": "struct",
                "path": "types::config::Config"
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::get_config_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "MessageBridge::get_current_value_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::get_current_value_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "MessageBridge::get_owner_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::get_owner_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_chain_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 16
                    }
                  }
                ],
                "kind": "struct",
                "path": "MessageBridge::get_registered_emitter_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "array",
                "length": 32,
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 8
                }
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::get_registered_emitter_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_chain_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 16
                    }
                  },
                  {
                    "name": "_emitter_address",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "MessageBridge::is_emitter_registered_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "boolean"
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::is_emitter_registered_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "message_ciphertext",
                    "type": {
                      "fields": [
                        {
                          "name": "storage",
                          "type": {
                            "kind": "array",
                            "length": 17,
                            "type": {
                              "kind": "field"
                            }
                          }
                        },
                        {
                          "name": "len",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 32
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "std::collections::bounded_vec::BoundedVec"
                    }
                  },
                  {
                    "name": "message_context",
                    "type": {
                      "fields": [
                        {
                          "name": "tx_hash",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "unique_note_hashes_in_tx",
                          "type": {
                            "fields": [
                              {
                                "name": "storage",
                                "type": {
                                  "kind": "array",
                                  "length": 64,
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              },
                              {
                                "name": "len",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "std::collections::bounded_vec::BoundedVec"
                          }
                        },
                        {
                          "name": "first_nullifier_in_tx",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "recipient",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::messages::processing::message_context::MessageContext"
                    }
                  }
                ],
                "kind": "struct",
                "path": "MessageBridge::process_message_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::process_message_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_vaa",
                    "type": {
                      "kind": "array",
                      "length": 2000,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "_length",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "MessageBridge::receive_value_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::receive_value_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_source_chain_ids",
                    "type": {
                      "fields": [
                        {
                          "name": "storage",
                          "type": {
                            "kind": "array",
                            "length": 8,
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 16
                            }
                          }
                        },
                        {
                          "name": "len",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 32
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "std::collections::bounded_vec::BoundedVec"
                    }
                  },
                  {
                    "name": "_emitter_addresses",
                    "type": {
                      "fields": [
                        {
                          "name": "storage",
                          "type": {
                            "kind": "array",
                            "length": 8,
                            "type": {
                              "kind": "array",
                              "length": 32,
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 8
                              }
                            }
                          }
                        },
                        {
                          "name": "len",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 32
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "std::collections::bounded_vec::BoundedVec"
                    }
                  }
                ],
                "kind": "struct",
                "path": "MessageBridge::register_emitter_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::register_emitter_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_destination_chain_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 16
                    }
                  },
                  {
                    "name": "_value",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "_fee_nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "MessageBridge::send_value_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::send_value_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_destination_chain_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 16
                    }
                  },
                  {
                    "name": "_value",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "_fee_nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "MessageBridge::send_value_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::send_value_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "MessageBridge::sync_private_state_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::sync_private_state_abi"
        }
      ]
    }
  },
  "transpiled": true
}
