{
  "file_map": {
    "100": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr",
      "source": "use super::utils::compute_fn_selector;\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::utils::get_params_len_quote;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault, panic};\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let seen_selectors =\n        &mut UHashMap::<Field, Quoted, BuildHasherDefault<Poseidon2Hasher>>::default();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n        let fn_name = function.name();\n\n        // Since function selectors are computed as the first 4 bytes of the hash of the function signature,\n        // it's possible to have collisions. With the following check, we ensure it doesn't happen within\n        // the same contract.\n        if seen_selectors.contains_key(selector) {\n            let existing_fn = seen_selectors.get(selector).unwrap();\n            panic(\n                f\"Public function selector collision detected between functions '{fn_name}' and '{existing_fn}'\",\n            );\n        }\n        seen_selectors.insert(selector, fn_name);\n\n        let params_len_quote = get_params_len_quote(parameters);\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $params_len_quote] = dep::aztec::context::public_context::calldata_copy(1, $params_len_quote);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index: &mut u32 = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[external(\"public\")]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "104": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/macros/functions/call_interface_stubs.nr",
      "source": "//! Stubs are auto-generated wrapper functions that provide an ergonomic interface for cross-contract calls.\n//! Instead of manually serializing arguments and creating call interfaces, stubs allow natural syntax, e.g. for\n//! enqueuing calls to public functions:\n//!\n//!   ExternalContract.at(address).some_method(arg1, arg2).enqueue()\n\nuse crate::macros::utils::{AsStrQuote, compute_fn_selector, is_fn_view};\nuse super::stub_registry;\nuse protocol_types::meta::utils::derive_serialization_quotes;\nuse std::meta::unquote;\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\npub comptime fn register_private_fn_stub(f: FunctionDefinition) {\n    let stub = if is_fn_view(f) {\n        create_private_static_stub(f)\n    } else {\n        create_private_stub(f)\n    };\n    stub_registry::register(f.module(), stub);\n}\n\npub comptime fn register_public_fn_stub(f: FunctionDefinition) {\n    let stub = if is_fn_view(f) {\n        create_public_static_stub(f)\n    } else {\n        create_public_stub(f)\n    };\n    stub_registry::register(f.module(), stub);\n}\n\npub comptime fn register_utility_fn_stub(f: FunctionDefinition) {\n    let stub = create_utility_stub(f);\n    stub_registry::register(f.module(), stub);\n}\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, Quoted, u32, Field) {\n    // Dear privacy adventurer,\n    // Chances are, you've command+clicked on the name of an external function\n    // call -- seeking to view that function -- only to end up here.\n    // Here's an explanation:\n    // The external contract that you're calling was likely annotated with the `#[aztec]`\n    // annotation -- as all good aztec contracts are. This triggers a macro which generates\n    // a \"contract interface\" for that contract, which is effectively a pretty interface\n    // that gives natural contract calling semantics:\n    //\n    // `MyImportedContract.at(some_address).my_method(arg1, arg2).enqueue();\n    //\n    // Unfortunately, the usage of macros makes it a bit of a black box.\n    // To actually view the target function, you could instead command+click on\n    // `MyImportedContract`, or you can just manually search it.\n    // If you want to view the noir code that gets generated by this macro, you can\n    // use `nargo expand` on your contract.\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n\n    let (serialized_args_array_construction, _, serialized_args_array_name) =\n        derive_serialization_quotes(fn_parameters, false);\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name,\n        fn_name_str, fn_name_len, fn_selector,\n    )\n}\n\ncomptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, serialized_args_array_name, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            )\n        }\n    }\n}\n\ncomptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, serialized_args_array_name, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, serialized_args_array_name, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            )\n        }\n    }\n}\n\ncomptime fn create_utility_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, serialized_args_array_name, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::UtilityCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::UtilityCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            )\n        }\n    }\n}\n"
    },
    "105": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\n// Used by `create_mark_as_initialized` (you won't find it through searching)\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\n// Used by `create_mark_as_initialized` (you won't find it through searching)\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\n// Used by `create_init_check` (you won't find it through searching)\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\n// Used by `create_init_check` (you won't find it through searching)\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\n// Used by `create_assert_correct_initializer_args` (you won't find it through searching)\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender().unwrap()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n// Used by `create_assert_correct_initializer_args` (you won't find it through searching)\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender().unwrap()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "108": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{\n        auth_registry::AUTHORIZE_ONCE_REGISTRY,\n        call_interface_stubs::{\n            register_private_fn_stub, register_public_fn_stub, register_utility_fn_stub,\n        },\n    },\n    notes::NOTES,\n    utils::{\n        fn_has_authorize_once, fn_has_noinitcheck, is_fn_contract_library_method, is_fn_external,\n        is_fn_initializer, is_fn_internal, is_fn_test, is_fn_view, modify_fn_body,\n        module_has_initializer, module_has_storage,\n    },\n};\nuse dep::protocol_types::meta::utils::derive_serialization_quotes;\nuse std::meta::{ctstring::AsCtString, type_of};\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) {\n    register_private_fn_stub(f);\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    let (args_serialization, _, serialized_args_name) =\n        derive_serialization_quotes(original_params, false);\n\n    let context_creation = quote {\n        $args_serialization\n        let args_hash = dep::aztec::hash::hash_args_array($serialized_args_name);\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, args_hash);\n    };\n\n    let function_name = f.name();\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        let assertion_message = f\"Function {function_name} can only be called internally\";\n        quote { assert(context.msg_sender().unwrap() == context.this_address(), $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        let assertion_message =\n            f\"Function {function_name} can only be called statically\".as_ctstring().as_quoted_str();\n        quote { assert(context.inputs.call_context.is_static_call, $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (\n            quote { aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_private(context); },\n            quote { aztec::macros::functions::initialization_utils::mark_as_initialized_private(&mut context); },\n        )\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        quote { aztec::macros::functions::initialization_utils::assert_is_initialized_private(&mut context); }\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any. Note that the message\n    // discovery call syncs private events as well. We do not sync those here if there are no notes because we don't\n    // have an API that would access events from private functions.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f, true)\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is serialized and hashed before being passed to the context.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n\n        let (return_serialization, _, serialized_return_name) =\n            derive_serialization_quotes([(return_value_var_name, return_value_type)], false);\n\n        body = body_without_return;\n\n        quote {\n            $return_value_assignment\n            $return_serialization\n            context.set_return_hash($serialized_return_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    // A quote to be injected at the beginning of the function body.\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) {\n    register_public_fn_stub(f);\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n\n    let args_len_quote = if original_params.len() == 0 {\n        // If the function has no parameters, we set the args_len to 0.\n        quote { 0 }\n    } else {\n        // The following will give us <type_of_struct_member_1 as Serialize>::N + <type_of_struct_member_2 as Serialize>::N + ...\n        original_params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n            <$param_type as $crate::protocol_types::traits::Serialize>::N\n        }\n            })\n            .join(quote {+})\n    };\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len_quote] = dep::aztec::context::public_context::calldata_copy(1, $args_len_quote);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    let name = f.name();\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        let assertion_message = f\"Function {name} can only be called internally\";\n        quote { assert(context.msg_sender().unwrap() == context.this_address(), $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        let name = f.name();\n        let assertion_message =\n            f\"Function {name} can only be called statically\".as_ctstring().as_quoted_str();\n        quote { assert(context.is_static_call(), $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (\n            quote { aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_public(context); },\n            quote { aztec::macros::functions::initialization_utils::mark_as_initialized_public(&mut context); },\n        )\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        quote { aztec::macros::functions::initialization_utils::assert_is_initialized_public(&mut context); }\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f, false)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    register_utility_fn_stub(f);\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage(f.module()) {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process or they may be used to sync private events from TypeScript\n    // (`sync_private_state` function gets invoked by PXE::getPrivateEvents function).\n    let message_discovery_call = create_message_discovery_call();\n\n    // A quote to be injected at the beginning of the function body.\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Injects an authwit verification check of the form:\n/// ```\n///   if (!from.eq(context.msg_sender().unwrap())) {\n///         assert_current_call_valid_authwit::<N>(&mut context, from);\n///     } else {\n///         assert(authwit_nonce, \"Invalid authwit nonce. When 'from' and 'msg_sender' are the same, authwit_nonce must be zero\");\n///     }\n/// ```\n/// where `from` and `authwit_nonce` are the names of the parameters that are expected to be present in the function definition.\n/// This check is injected by the `#[authorize_once(\"from_arg_name\", \"nonce_arg_name\")]`, which allows the user to define\n/// which parameters to use.\n///\n/// # Arguments\n/// * `f` - The function definition to inject the authwit verification check into. The function must have parameters\n///         matching the names specified in the `#[authorize_once]` attribute.\n/// * `is_private` - Whether the function is a private function (`true`) or a public function (`false`). This determines\n///                  which authwit verification method to use: `assert_current_call_valid_authwit` for private functions\n///                  or `assert_current_call_valid_authwit_public` for public functions.\npub(crate) comptime fn create_authorize_once_check(\n    f: FunctionDefinition,\n    is_private: bool,\n) -> Quoted {\n    let maybe_authorize_once_args = AUTHORIZE_ONCE_REGISTRY.get(f);\n    let authorize_once_args = if maybe_authorize_once_args.is_some() {\n        maybe_authorize_once_args.unwrap()\n    } else {\n        // We need to for authorize_once to have already executed so that we can retrieve its params - this depends on\n        // the order in which the attributes are applied.\n        panic(\n            f\"Functions marked with #[authorize_once] must have the #[external(\\\"private\\\")] or #[external(\\\"public\\\")] attribute placed last\",\n        )\n    };\n\n    let (from_arg_name, nonce_arg_name) = authorize_once_args;\n    let name: Quoted = f.name();\n\n    let from_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{from_arg_name}\".quoted_contents());\n    let (from_arg_name_quoted, from_arg_type) = if from_arg_candidates.len() == 1 {\n        from_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {from_arg_name} parameter. Please specify which one to use in #[authorize_once(\\\"...\\\", \\\"authwit_nonce\\\")]\",\n        )\n    };\n    if from_arg_type\n        != quote { dep::protocol_types::address::aztec_address::AztecAddress }.as_type() {\n        panic(\n            f\"Argument {from_arg_name_quoted} in function {name} must be of type AztecAddress, but is of type {from_arg_type}\",\n        )\n    }\n\n    let nonce_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{nonce_arg_name}\".quoted_contents());\n    let (nonce_arg_name_quoted, nonce_arg_type) = if nonce_arg_candidates.len() == 1 {\n        nonce_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {nonce_arg_name}. Please specify which one to use in #[authorize_once(\\\"from\\\", \\\"...\\\")]\",\n        )\n    };\n    if nonce_arg_type != quote { Field }.as_type() {\n        panic(\n            f\"Argument {nonce_arg_name_quoted} in function {name} must be of type Field, but is of type {nonce_arg_type}\",\n        );\n    }\n\n    let nonce_check_quote = f\"{nonce_arg_name_quoted} == 0\".quoted_contents();\n\n    let fn_call = if is_private {\n        // At this point, the original args of the fn have already been altered by the macro\n        // to include PrivateContextInputs, so we need to adjust the args_len accordingly.\n        let args_len = f.parameters().len() - 1;\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit::<$args_len> }\n    } else {\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit_public }\n    };\n    let invalid_nonce_message = f\"Invalid authwit nonce. When '{from_arg_name}' and 'msg_sender' are the same, '{nonce_arg_name}' must be zero\"\n        .as_ctstring()\n        .as_quoted_str();\n    quote {         \n        if (!$from_arg_name_quoted.eq(context.msg_sender().unwrap())) {\n            $fn_call(&mut context, $from_arg_name_quoted);\n        } else {\n            assert($nonce_check_quote, $invalid_nonce_message);\n        }\n    }\n}\n\n/// Checks if each function in the module is marked with either #[external(...)], #[contract_library_method], or #[test].\n/// Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_external(f) & !is_fn_contract_library_method(f) & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[external(...)], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "110": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/macros/notes.nr",
      "source": "use crate::note::note_getter_options::PropertySelector;\nuse std::{collections::bounded_vec::BoundedVec, meta::{ctstring::AsCtString, type_of}};\n\n/// Maximum number of note types within 1 contract.\ncomptime global MAX_NOTE_TYPES: u32 = 128;\n\n/// A BoundedVec containing all the note types within this contract.\npub comptime mut global NOTES: BoundedVec<Type, MAX_NOTE_TYPES> = BoundedVec::new();\n\ncomptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < MAX_NOTE_TYPES,\n        f\"A contract can contain at most {MAX_NOTE_TYPES} different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_type_impl(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n    let typ = s.as_type();\n    let note_type_name: str<_> = f\"{name}\".as_ctstring().as_quoted_str!();\n    let max_note_packed_len = crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                // This static assertion ensures the note's packed length doesn't exceed the maximum allowed size.\n                // While this check would ideally live in the Packable trait implementation, we place it here since\n                // this function is always generated by our macros and the Packable trait implementation is not.\n                // Note: We set the note type name and max packed length as local variables because injecting them\n                // directly into the error message doesn't work.\n                let note_type_name = $note_type_name;\n                let max_note_packed_len: u32 = $max_note_packed_len; // Casting to u32 to avoid the value to be printed in hex.\n                let note_packed_len = <$typ as Packable>::N;\n                std::static_assert(note_packed_len <= $max_note_packed_len, f\"{note_type_name} has a packed length of {note_packed_len} fields, which exceeds the maximum allowed length of {max_note_packed_len} fields\");\n\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullification: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullification: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::traits::Packable::pack(self).concat( [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::context::PrivateContext,\n                note_hash_for_nullification: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullification, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullification: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullification, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _, _)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates the core note functionality for a struct:\n///\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - NoteHash trait implementation: Handles note hash and nullifier computation\n///\n/// # Requirements\n///\n/// The note struct must:\n/// - Have an `owner` field\n/// - Implement the `Packable` trait\n/// - Not exceed `MAX_NOTE_PACKED_LEN` when packed\n///\n/// # Registration\n///\n/// Registers the note in the global `NOTES` BoundedVec to enable note processing functionality.\n///\n/// # Generated Code\n///\n/// For detailed documentation on the generated implementations, see:\n/// - `generate_note_properties()`\n/// - `generate_note_type_impl()`\n/// - `generate_note_hash_trait_impl()`\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n    assert_has_packable(s);\n\n    // We register the note in the global `NOTES` BoundedVec because we need that information inside the #[aztec] macro\n    // to generate note processing functionality.\n    NOTES.push(s.as_type());\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_type_impl = generate_note_type_impl(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n\n    quote {\n        $note_properties\n        $note_type_impl\n        $note_hash_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n///\n/// # Requirements\n///\n/// The note struct must:\n/// - Implement the `Packable` trait\n/// - Not exceed `MAX_NOTE_PACKED_LEN` when packed\n///\n/// Unlike the `#[note]` macro, there is no requirement for an `owner` field.\n///\n/// # Registration\n///\n/// Registers the note in the global `NOTES` BoundedVec to enable note processing functionality.\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    assert_has_packable(s);\n\n    // We register the note in the global `NOTES` BoundedVec because we need that information inside the #[aztec] macro\n    // to generate note processing functionality.\n    NOTES.push(s.as_type());\n\n    let note_type_id = get_next_note_type_id();\n    let note_properties = generate_note_properties(s);\n    let note_type_impl = generate_note_type_impl(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_type_impl\n    }\n}\n\n/// Asserts that the given note implements the `Packable` trait.\n///\n/// We require that notes have the `Packable` trait implemented because it is used when emitting a note in a log or as\n/// an offchain message.\ncomptime fn assert_has_packable(note: TypeDefinition) {\n    let packable_constraint =\n        quote { crate::protocol_types::traits::Packable }.as_trait_constraint();\n    let note_name = note.name();\n\n    assert(\n        note.as_type().implements(packable_constraint),\n        f\"{note_name} does not implement Packable trait. Either implement it manually or place #[derive(Packable)] on the note struct before #[note] macro invocation.\",\n    );\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    let note_name = note.name();\n\n    assert(\n        has_owner,\n        f\"{note_name} does not have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "111": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/macros/storage.nr",
      "source": "use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract should have this macro (or `storage_no_init`) applied to it, and the\n/// struct has to be called 'Storage'.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    let struct_name = s.name();\n    if struct_name != quote { Storage } {\n        panic(\n            f\"The #[storage] macro can only be applied to a struct with name 'Storage', got '{struct_name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage_no_init\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ, _) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot });\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields = storage_layout_fields.push_back(\n            quote { pub $name: dep::aztec::state_vars::storage::Storable },\n        );\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::state_vars::storage::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract can have this macro (or storage_no_init) applied to it, and the struct\n/// has to be called 'Storage'.\npub comptime fn storage_no_init(s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n\n    // We do need to make sure that the type is called Storage, since we'll do `Storage::init` later on.\n\n    if s.name() != quote { Storage } {\n        let name = s.name();\n        panic(\n            f\"The #[storage_no_init] macro can only be applied to a struct with name 'Storage', got '{name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(typ: Type, slot: Quoted) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    let constructor = if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot });\n\n        quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }\n    } else {\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        quote { $struct_name::new(context, $slot)}\n    };\n\n    (constructor, get_storage_size(typ))\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n"
    },
    "113": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod private_events;\npub mod private_notes;\npub mod process_message;\n\nuse crate::{\n    messages::{\n        discovery::{\n            private_notes::MAX_NOTE_PACKED_LEN, process_message::process_message_ciphertext,\n        },\n        processing::{\n            get_private_logs, pending_tagged_log::PendingTaggedLog,\n            validate_enqueued_notes_and_events,\n        },\n    },\n    utils::array,\n};\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, note nonce, storage slot and note\n/// type ID and attempts to compute its note hash (not hashed by note nonce nor siloed by address) and inner nullifier\n/// (not siloed by address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, note_nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullification = aztec::note::utils::compute_note_hash_for_nullification(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(note_nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullification);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\npub type ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* note nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private logs are downloaded and inspected to find new private\n/// notes, partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Note that the state is synchronized up to the latest block synchronized by PXE. That should be close to the chain\n/// tip as block synchronization is performed before contract function simulation is done.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    // First we process all private logs, which can contain different kinds of messages e.g. private notes, partial\n    // notes, private events, etc.\n    let mut logs = get_private_logs(contract_address);\n    logs.for_each(|i, pending_tagged_log: PendingTaggedLog| {\n        debug_log_format(\n            \"Processing log with tag {0}\",\n            [pending_tagged_log.log.get(0)],\n        );\n\n        // We remove the tag from the pending tagged log and process the message ciphertext contained in it.\n        let message_ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n        process_message_ciphertext(\n            contract_address,\n            compute_note_hash_and_nullifier,\n            message_ciphertext,\n            pending_tagged_log.context,\n        );\n        logs.remove(i);\n    });\n\n    // Then we process all pending partial notes, regardless of whether they were found in the current or previous\n    // executions.\n    partial_notes::fetch_and_process_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    // Finally we validate all notes and events that were found as part of the previous processes, resulting in them\n    // being added to PXE's database and retrievable via oracles (get_notes) and our TS API (PXE::getPrivateEvents).\n    validate_enqueued_notes_and_events(contract_address);\n}\n"
    },
    "114": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub note_nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given note nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    note_nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Found valid nonces for a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullification,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        note_nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullification = compute_note_hash_for_nullification(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(note_nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullification);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        note_nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let note_nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(note_nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash = compute_unique_note_hash(\n            note_nonce,\n            compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash),\n        );\n        let inner_nullifier = note.compute_nullifier_unconstrained(\n            compute_note_hash_for_nullification(retrieved_note, STORAGE_SLOT),\n        );\n\n        NoteAndData { note, note_nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.note_nonce, note_and_data.note_nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == first_note_and_data.note_nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == second_note_and_data.note_nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "115": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::{\n            enqueue_note_for_validation, get_pending_partial_notes_completion_logs,\n            log_retrieval_response::LogRetrievalResponse,\n        },\n    },\n    utils::array,\n};\n\nuse protocol_types::{\n    address::AztecAddress,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for logs that would result in the completion of pending partial notes, ultimately resulting in the notes\n/// being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    // Each of the pending partial notes might get completed by a log containing its public values. For performance\n    // reasons, we fetch all of these logs concurrently and then process them one by one, minimizing the amount of time\n    // waiting for the node roundtrip.\n    let maybe_completion_logs =\n        get_pending_partial_notes_completion_logs(contract_address, pending_partial_notes);\n\n    // Each entry in the maybe completion logs array corresponds to the entry in the pending partial notes array at the\n    // same index. This means we can use the same index as we iterate through the responses to get both the partial note\n    // and the log that might complete it.\n    assert_eq(maybe_completion_logs.len(), pending_partial_notes.len());\n\n    maybe_completion_logs.for_each(|i, maybe_log: Option<LogRetrievalResponse>| {\n        // We clear the completion logs as we read them so that the array is empty by the time we next query it.\n        // TODO(#14943): use volatile arrays to avoid having to manually clear this.\n        maybe_completion_logs.remove(i);\n\n        let pending_partial_note = pending_partial_notes.get(i);\n\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log plaintext to get\n            // the complete packed content.\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                log.log_payload,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            // TODO(#11627): is there anything reasonable we can do if we get a log but it doesn't result in a note\n            // being found?\n            if discovered_notes.len() == 0 {\n                panic(\n                    f\"A partial note's completion log did not result in any notes being found - this should never happen\",\n                );\n            }\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                enqueue_note_for_validation(\n                    contract_address,\n                    pending_partial_note.storage_slot,\n                    discovered_note.note_nonce,\n                    complete_packed_note,\n                    discovered_note.note_hash,\n                    discovered_note.inner_nullifier,\n                    log.tx_hash,\n                    pending_partial_note.recipient,\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
    },
    "116": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/discovery/private_events.nr",
      "source": "use crate::{\n    event::event_selector::EventSelector,\n    messages::{encoding::MAX_MESSAGE_CONTENT_LEN, processing::enqueue_event_for_validation},\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::GENERATOR_INDEX__EVENT_COMMITMENT,\n    hash::poseidon2_hash_with_separator_bounded_vec, traits::FromField,\n};\n\n/// The number of fields in a private event message content that are not the event's serialized representation\n/// (1 field for randomness).\nglobal PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of an event's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, randomness, etc.).\npub global MAX_EVENT_SERIALIZED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN;\n\npub unconstrained fn process_private_event_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n) {\n    // In the case of events, the msg metadata is the event selector.\n    let event_type_id = EventSelector::from_field(msg_metadata as Field);\n\n    assert(\n        msg_content.len() > PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n        f\"Invalid private event message: all private event messages must have at least {PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private event message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN\",\n    );\n\n    let serialized_event_with_randomness = msg_content;\n\n    let event_commitment = poseidon2_hash_with_separator_bounded_vec(\n        serialized_event_with_randomness,\n        GENERATOR_INDEX__EVENT_COMMITMENT,\n    );\n\n    // Randomness was injected into the event payload in `emit_event_in_private` but we have already used it\n    // to compute the event commitment, so we can safely discard it now.\n    let serialized_event = array::subbvec(\n        serialized_event_with_randomness,\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n    );\n\n    enqueue_event_for_validation(\n        contract_address,\n        event_type_id,\n        serialized_event,\n        event_commitment,\n        tx_hash,\n        recipient,\n    );\n}\n"
    },
    "117": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::enqueue_note_for_validation,\n    },\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\n// See the call to `std::static_assert` below to see what's in these fields.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        enqueue_note_for_validation(\n            contract_address,\n            storage_slot,\n            discovered_note.note_nonce,\n            packed_note,\n            discovered_note.note_hash,\n            discovered_note.inner_nullifier,\n            tx_hash,\n            recipient,\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
    },
    "118": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/discovery/process_message.nr",
      "source": "use crate::messages::{\n    discovery::{\n        ComputeNoteHashAndNullifier, partial_notes::process_partial_note_private_msg,\n        private_events::process_private_event_msg, private_notes::process_private_note_msg,\n    },\n    encoding::{decode_message, MESSAGE_CIPHERTEXT_LEN, MESSAGE_PLAINTEXT_LEN},\n    encryption::{aes128::AES128, message_encryption::MessageEncryption},\n    msg_type::{\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n    },\n    processing::message_context::MessageContext,\n};\n\nuse protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\n/// Processes a message that can contain notes, partial notes, or events.\n///\n/// Notes result in nonce discovery being performed prior to delivery, which requires knowledge of the transaction hash\n/// in which the notes would've been created (typically the same transaction in which the log was emitted), along with\n/// the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier` function. Once\n/// discovered, the notes are enqueued for validation.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\n///\n/// Events are processed by computing an event commitment from the serialized event data and its randomness field, then\n/// enqueueing the event data and commitment for validation.\npub unconstrained fn process_message_ciphertext<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_ciphertext: BoundedVec<Field, MESSAGE_CIPHERTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    process_message_plaintext(\n        contract_address,\n        compute_note_hash_and_nullifier,\n        AES128::decrypt(message_ciphertext, message_context.recipient),\n        message_context,\n    );\n}\n\npub unconstrained fn process_message_plaintext<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_plaintext: BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    // The first thing to do after decrypting the message is to determine what type of message we're processing. We\n    // have 3 message types: private notes, partial notes and events.\n\n    // We decode the message to obtain the message type id, metadata and content.\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(message_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            message_context.tx_hash,\n            message_context.unique_note_hashes_in_tx,\n            message_context.first_nullifier_in_tx,\n            message_context.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        process_private_event_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n            message_context.tx_hash,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "119": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::utils::array;\nuse protocol_types::constants::PRIVATE_LOG_CIPHERTEXT_LEN;\n\n// We reassign to the constant here to communicate the distinction between a log and a message. In Aztec.nr, unlike in\n// protocol circuits, we have a concept of a message that can be emitted either as a private log or as an offchain\n// message. Message is a piece of data that is to be eventually delivered to a contract via the `process_message(...)`\n// utility function function that is injected by the #[aztec] macro.\npub global MESSAGE_CIPHERTEXT_LEN: u32 = PRIVATE_LOG_CIPHERTEXT_LEN;\n\n// TODO(#12750): The global variables below should not be here as they are AES128 specific.\n// ciphertext_length (2) + 14 bytes pkcs#7 AES padding.\npub(crate) global HEADER_CIPHERTEXT_SIZE_IN_BYTES: u32 = 16;\n\npub global EPH_PK_X_SIZE_IN_FIELDS: u32 = 1;\npub global EPH_PK_SIGN_BYTE_SIZE_IN_BYTES: u32 = 1;\n\n// (17 - 1) * 31 - 16 - 1 = 479\nglobal MESSAGE_PLAINTEXT_SIZE_IN_BYTES: u32 = (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS)\n    * 31\n    - HEADER_CIPHERTEXT_SIZE_IN_BYTES\n    - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES;\n// Each field of the original note log was serialized to 32 bytes. Below we convert the bytes back to fields.\n// 479 / 32 = 15\npub global MESSAGE_PLAINTEXT_LEN: u32 = MESSAGE_PLAINTEXT_SIZE_IN_BYTES / 32;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MESSAGE_PLAINTEXT_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u16 {\n    fn from(value: u8) -> u16 {\n        value as u16\n    }\n}\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u16> for u32 {\n    fn from(value: u16) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u16> for u64 {\n    fn from(value: u16) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u16> for u128 {\n    fn from(value: u16) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u16> for Field {\n    fn from(value: u16) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i16 {\n    fn from(value: i8) -> i16 {\n        value as i16\n    }\n}\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i16> for i32 {\n    fn from(value: i16) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\n\nimpl From<i16> for i64 {\n    fn from(value: i16) -> i64 {\n        value as i64\n    }\n}\n\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u16 {\n    fn from(value: bool) -> u16 {\n        value as u16\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for u128 {\n    fn from(value: bool) -> u128 {\n        value as u128\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i16 {\n    fn from(value: bool) -> i16 {\n        value as i16\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            let body = if type1 == type2 {\n                quote { self }\n            } else if type1 == quote { bool } {\n                quote { self != 0 }\n            } else {\n                quote { self as $type1 }\n            };\n\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        $body\n                    }\n                }\n            },\n            );\n        }\n    }\n\n    let u_types =\n        [quote { bool }, quote { u8 }, quote { u16 }, quote { u32 }, quote { u64 }, quote { u128 }];\n\n    for type2 in u_types {\n        let body = quote { self as Field };\n\n        impls = impls.push_back(\n            quote {\n                impl AsPrimitive<Field> for $type2 {\n                    fn as_(self) -> Field {\n                        $body\n                    }\n                }\n            },\n        );\n    }\n\n    for type1 in u_types {\n        let body = if type1 == quote { bool } {\n            quote { self != 0 }\n        } else {\n            quote { self as $type1 }\n        };\n\n        impls = impls.push_back(\n            quote {\n                impl AsPrimitive<$type1> for Field {\n                    fn as_(self) -> $type1 {\n                        $body\n                    }\n                }\n            },\n        );\n    }\n\n    impls.join(quote {})\n}\n"
    },
    "120": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encoding::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, MESSAGE_CIPHERTEXT_LEN, MESSAGE_PLAINTEXT_LEN,\n        },\n        encryption::message_encryption::MessageEncryption,\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__message_bytes__from_PT,\n            get_arr_of_size__message_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\n/**\n * Computes N close-to-uniformly-random 256 bits from a given ECDH shared_secret.\n *\n * NEVER re-use the same iv and sym_key.\n * DO NOT call this function more than once with the same shared_secret.\n *\n * This function is only known to be safe if shared_secret is computed by combining a \n * random ephemeral key with an address point. See big comment within the body of the function.\n * See big comment within the body of the function.\n */\nfn extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [[u8; 32]; N] {\n    /*\n     * Unsafe because of https://eprint.iacr.org/2010/264.pdf Page 13, Lemma 2 (and the * two paragraphs below it).\n     *\n     * If you call this function, you need to be careful and aware of how the arg\n     * `shared_secret` has been derived.\n     *\n     * The paper says that the way you derive aes keys and IVs should be fine with poseidon2\n     * (modelled as a RO), as long as you _don't_ use Poseidon2 as a PRG to generate the * two exponents x & y which multiply to the shared secret S:\n     *\n     * S = [x*y]*G.\n     *\n     * (Otherwise, you would have to \"key\" poseidon2, i.e. generate a uniformly string K\n     * which can be public and compute Hash(x) as poseidon(K,x)).\n     * In that lemma, k would be 2*254=508, and m would be the number of points on the * grumpkin curve (which is close to r according to the Hasse bound).\n     *\n     * Our shared secret S is [esk * address_sk] * G, and the question is: * Can we compute hash(S) using poseidon2 instead of sha256?\n     *\n     * Well, esk is random and not generated with poseidon2, so that's good.\n     * What about address_sk?\n     * Well, address_sk = poseidon2(stuff) + ivsk, so there was some\n     * discussion about whether address_sk is independent of poseidon2.\n     * Given that ivsk is random and independent of poseidon2, the address_sk is also\n     * independent of poseidon2.\n     *\n     * Tl;dr: we believe it's safe to hash S = [esk * address_sk] * G using poseidon2,\n     * in order to derive a symmetric key.\n     *\n     * If you're calling this function for a differently-derived `shared_secret`, be\n     * careful.\n     *\n     */\n\n    /* The output of this function needs to be 32 random bytes.\n     * A single field won't give us 32 bytes of entropy.\n     * So we compute two \"random\" fields, by poseidon-hashing with two different\n     * generators.\n     * We then extract the last 16 (big endian) bytes of each \"random\" field.\n     * Note: we use to_be_bytes because it's slightly more efficient. But we have to\n     * be careful not to take bytes from the \"big end\", because the \"big\" byte is\n     * not uniformly random over the byte: it only has < 6 bits of randomness, because\n     * it's the big end of a 254-bit field element.\n     */\n\n    let mut all_bytes: [[u8; 32]; N] = std::mem::zeroed();\n    // We restrict N to be < 2^8, because of how we compute the domain separator\n    // from k below (where k <= N must be 8 bits). In practice, it's extremely\n    // unlikely that an app will want to compute >= 256 ciphertexts.\n    std::static_assert(N < 256, \"N too large\");\n    for k in 0..N {\n        // We augment the domain separator with the loop index, so that we can\n        // generate N lots of randomness.\n        let k_shift = (k as u16 << 8);\n        let separator_1 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY as u16;\n        let separator_2 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY_2 as u16;\n\n        let rand1: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_1);\n        let rand2: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_2);\n\n        let rand1_bytes: [u8; 32] = rand1.to_be_bytes();\n        let rand2_bytes: [u8; 32] = rand2.to_be_bytes();\n\n        let mut bytes: [u8; 32] = [0; 32];\n        for i in 0..16 {\n            // We take bytes from the \"little end\" of the be-bytes arrays:\n            let j = 32 - i - 1;\n            bytes[i] = rand1_bytes[j];\n            bytes[16 + i] = rand2_bytes[j];\n        }\n\n        all_bytes[k] = bytes;\n    }\n\n    all_bytes\n}\n\nfn derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits<let N: u32>(\n    many_random_256_bits: [[u8; 32]; N],\n) -> [([u8; 16], [u8; 16]); N] {\n    // Many (sym_key, iv) pairs:\n    let mut many_pairs: [([u8; 16], [u8; 16]); N] = std::mem::zeroed();\n    for k in 0..N {\n        let random_256_bits = many_random_256_bits[k];\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n        for i in 0..16 {\n            sym_key[i] = random_256_bits[i];\n            iv[i] = random_256_bits[i + 16];\n        }\n        many_pairs[k] = (sym_key, iv);\n    }\n\n    many_pairs\n}\n\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [([u8; 16], [u8; 16]); N] {\n    let many_random_256_bits: [[u8; 32]; N] = extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe(\n        shared_secret,\n    );\n\n    derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits(many_random_256_bits)\n}\n\npub struct AES128 {}\n\nimpl MessageEncryption for AES128 {\n    fn encrypt<let PlaintextLen: u32>(\n        plaintext: [Field; PlaintextLen],\n        recipient: AztecAddress,\n    ) -> [Field; MESSAGE_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the message in `do_process_message`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        // TODO (#17158): Currently we unwrap the Option returned by derive_ecdh_shared_secret_using_aztec_address.\n        // We need to handle the case where the ephemeral public key is invalid to prevent potential DoS vectors.\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient).unwrap();\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        // It is safe to call the `unsafe` function here, because we know the `shared_secret`\n        // was derived using an AztecAddress (the recipient). See the block comment\n        // at the start of this unsafe target function for more info.\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, body_iv, body_sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        std::static_assert(\n            ciphertext_bytes.len() == 16 * (1 + (PlaintextLen * 32) / 16),\n            \"unexpected ciphertext length\",\n        );\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, header_iv, header_sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        std::static_assert(\n            header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES,\n            \"unexpected ciphertext header length\",\n        );\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut message_bytes_padding_to_mult_31 =\n            get_arr_of_size__message_bytes_padding__from_PT::<PlaintextLen * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        message_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut message_bytes = get_arr_of_size__message_bytes__from_PT::<PlaintextLen * 32>();\n\n        std::static_assert(\n            message_bytes.len() % 31 == 0,\n            \"Unexpected error: message_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        message_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            message_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            message_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..message_bytes_padding_to_mult_31.len() {\n            message_bytes[offset + i] = message_bytes_padding_to_mult_31[i];\n        }\n        offset += message_bytes_padding_to_mult_31.len();\n\n        // Ideally we would be able to have a static assert where we check that the offset would be such that we've\n        // written to the entire log_bytes array, but we cannot since Noir does not treat the offset as a comptime\n        // value (despite the values that it goes through being known at each stage). We instead check that the\n        // computation used to obtain the offset computes the expected value (which we _can_ do in a static check), and\n        // then add a cheap runtime check to also validate that the offset matches this.\n        std::static_assert(\n            1\n                + header_ciphertext_bytes.len()\n                + ciphertext_bytes.len()\n                + message_bytes_padding_to_mult_31.len()\n                == message_bytes.len(),\n            \"unexpected message length\",\n        );\n        assert(offset == message_bytes.len(), \"unexpected encrypted message length\");\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make messages produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let message_bytes_as_fields = bytes_to_fields(message_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final message\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; MESSAGE_CIPHERTEXT_LEN] = [0; MESSAGE_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..message_bytes_as_fields.len() {\n            ciphertext[offset + i] = message_bytes_as_fields[i];\n        }\n        offset += message_bytes_as_fields.len();\n\n        for i in offset..MESSAGE_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the message\n            // (all the \"real\" message fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the message to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt(\n        ciphertext: BoundedVec<Field, MESSAGE_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, MESSAGE_PLAINTEXT_LEN> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, MESSAGE_CIPHERTEXT_LEN, MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) != 0;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret\n        // TODO(#17158): handle invalid ephemeral keys when decrypting to prevent DoS vectors\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk.unwrap());\n\n        // Derive symmetric keys:\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with messages with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext =\n            aes128_decrypt_oracle(header_ciphertext_bvec, header_iv, header_sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, body_iv, body_sym_key);\n\n        // Each field of the original note message was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::{\n            encoding::MESSAGE_PLAINTEXT_LEN, encryption::message_encryption::MessageEncryption,\n        },\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{address::AztecAddress, traits::FromField};\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt() {\n        let env = TestEnvironment::new();\n\n        // Message decryption requires oracles that are only available during private execution\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3];\n\n            let recipient = AztecAddress::from_field(\n                0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n            );\n\n            // Mock random values for deterministic test\n            let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(eph_sk).times(1);\n\n            let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(randomness).times(1000000);\n\n            let _ = OracleMock::mock(\"privateGetNextAppTagAsSender\").returns(42);\n\n            // Encrypt the message\n            let encrypted_message = BoundedVec::from_array(AES128::encrypt(plaintext, recipient));\n\n            // Mock shared secret for deterministic test\n            let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n                EmbeddedCurveScalar::from_field(eph_sk),\n                recipient,\n            );\n\n            let _ = OracleMock::mock(\"utilityGetSharedSecret\").returns(shared_secret.unwrap());\n\n            // Decrypt the message\n            let decrypted = AES128::decrypt(encrypted_message, recipient);\n\n            // The decryption function spits out a BoundedVec because it's designed to work with messages with unknown length\n            // at compile time. For this reason we need to convert the original input to a BoundedVec.\n            let plaintext_bvec = BoundedVec::<Field, MESSAGE_PLAINTEXT_LEN>::from_array(plaintext);\n\n            // Verify decryption matches original plaintext\n            assert_eq(\n                decrypted,\n                plaintext_bvec,\n                \"Decrypted bytes should match original plaintext\",\n            );\n\n            // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n            // static methods of the struct).\n            let _ = AES128 {};\n        });\n    }\n}\n"
    },
    "137": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/processing/mod.nr",
      "source": "pub(crate) mod event_validation_request;\npub mod message_context;\npub(crate) mod note_validation_request;\npub(crate) mod log_retrieval_request;\npub(crate) mod log_retrieval_response;\npub(crate) mod pending_tagged_log;\n\nuse crate::{\n    capsules::CapsuleArray,\n    event::event_selector::EventSelector,\n    messages::{\n        discovery::{\n            partial_notes::DeliveredPendingPartialNote, private_events::MAX_EVENT_SERIALIZED_LEN,\n            private_notes::MAX_NOTE_PACKED_LEN,\n        },\n        processing::{\n            log_retrieval_request::LogRetrievalRequest,\n            log_retrieval_response::LogRetrievalResponse,\n            note_validation_request::NoteValidationRequest, pending_tagged_log::PendingTaggedLog,\n        },\n    },\n    oracle,\n};\nuse event_validation_request::EventValidationRequest;\nuse protocol_types::{address::AztecAddress, hash::sha256_to_field};\n\n// Base slot for the pending tagged log array to which the fetch_tagged_logs oracle inserts found private logs.\nglobal PENDING_TAGGED_LOG_ARRAY_BASE_SLOT: Field =\n    sha256_to_field(\"AZTEC_NR::PENDING_TAGGED_LOG_ARRAY_BASE_SLOT\".as_bytes());\n\nglobal NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\n/// Searches for private logs emitted by `contract_address` that might contain messages for one of the local accounts,\n/// and stores them in a `CapsuleArray` which is then returned.\npub(crate) unconstrained fn get_private_logs(\n    contract_address: AztecAddress,\n) -> CapsuleArray<PendingTaggedLog> {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `fetchTaggedLogs`\n    // oracle. This makes PXE synchronize tags, download logs and store the pending tagged logs in a capsule array.\n    oracle::message_processing::fetch_tagged_logs(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    CapsuleArray::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT)\n}\n\n/// Enqueues a note for validation by PXE, so that it becomes aware of a note's existence allowing for later retrieval\n/// via `get_notes` oracle. The note will be scoped to `contract_address`, meaning other contracts will not be able to\n/// access it unless authorized.\n///\n/// In order for the note validation and insertion to occur, `validate_enqueued_notes_and_events` must be later called.\n/// For optimal performance, accumulate as many note validation requests as possible and then validate them all at the\n/// end (which results in PXE minimizing the number of network round-trips).\n///\n/// The `packed_note` is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\npub(crate) unconstrained fn enqueue_note_for_validation(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `NoteValidationRequest`\n    CapsuleArray::at(contract_address, NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        NoteValidationRequest {\n            contract_address,\n            storage_slot,\n            note_nonce,\n            packed_note,\n            note_hash,\n            nullifier,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Enqueues an event for validation by PXE, so that it can be efficiently validated and then inserted into the event\n/// store.\n///\n/// In order for the event validation and insertion to occur, `validate_enqueued_notes_and_events` must be later\n/// called. For optimal performance, accumulate as many event validation requests as possible and then validate them\n/// all at the end (which results in PXE minimizing the number of network round-trips).\npub(crate) unconstrained fn enqueue_event_for_validation(\n    contract_address: AztecAddress,\n    event_type_id: EventSelector,\n    serialized_event: BoundedVec<Field, MAX_EVENT_SERIALIZED_LEN>,\n    event_commitment: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `EventValidationRequest`\n    CapsuleArray::at(contract_address, EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        EventValidationRequest {\n            contract_address,\n            event_type_id,\n            serialized_event,\n            event_commitment,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Validates all note and event validation requests enqueued via `enqueue_note_for_validation` and\n/// `enqueue_event_for_validation`, inserting them into the note database and event store respectively, making them\n/// queryable via `get_notes` oracle and our TS API (PXE::getPrivateEvents).\n///\n/// This automatically clears both validation request queues, so no further work needs to be done by the caller.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(contract_address: AztecAddress) {\n    oracle::message_processing::validate_enqueued_notes_and_events(\n        contract_address,\n        NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n        EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n    );\n}\n\n/// Efficiently queries the node for logs that result in the completion of all `DeliveredPendingPartialNote`s stored in\n/// a `CapsuleArray` by performing all node communication concurrently. Returns a second `CapsuleArray` with Options for\n/// the responses that correspond to the pending partial notes at the same index.\n///\n/// For example, given an array with pending partial notes `[ p1, p2, p3 ]`, where `p1` and `p3` have corresponding\n/// completion logs but `p2` does not, the returned `CapsuleArray` will have contents\n/// `[some(p1_log), none(), some(p3_log)]`.\npub(crate) unconstrained fn get_pending_partial_notes_completion_logs(\n    contract_address: AztecAddress,\n    pending_partial_notes: CapsuleArray<DeliveredPendingPartialNote>,\n) -> CapsuleArray<Option<LogRetrievalResponse>> {\n    let log_retrieval_requests =\n        CapsuleArray::at(contract_address, LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT);\n\n    // We create a LogRetrievalRequest for each PendingPartialNote in the CapsuleArray. Because we need the indices in\n    // the request array to match the indices in the partial note array, we can't use CapsuleArray::for_each, as that\n    // function has arbitrary iteration order. Instead, we manually iterate the array from the beginning and push into\n    // the requests array, which we expect to be empty.\n    let mut i = 0;\n    let pending_partial_notes_count = pending_partial_notes.len();\n    while i < pending_partial_notes_count {\n        let pending_partial_note = pending_partial_notes.get(i);\n        log_retrieval_requests.push(\n            LogRetrievalRequest {\n                contract_address,\n                unsiloed_tag: pending_partial_note.note_completion_log_tag,\n            },\n        );\n        i += 1;\n    }\n\n    oracle::message_processing::bulk_retrieve_logs(\n        contract_address,\n        LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT,\n        LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT,\n    );\n\n    CapsuleArray::at(contract_address, LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT)\n}\n"
    },
    "149": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::{Deserialize, Packable, Serialize};\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, note_nonce: Field },\n//   Settled{ note_nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Deserialize, Eq, Serialize, Packable)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_note_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_note_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_note_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_note_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_note_nonce }\n            }\n        } else if maybe_note_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_note_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_note_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_note_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.note_nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.note_nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    note_nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    note_nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n"
    },
    "152": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().note_nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullification<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullification_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullification`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullification_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let note_nonce = retrieved_note.metadata.to_pending_previous_phase().note_nonce();\n\n        compute_unique_note_hash(note_nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullification =\n        compute_note_hash_for_nullification(retrieved_note, storage_slot);\n    let inner_nullifier =\n        retrieved_note.note.compute_nullifier(context, note_hash_for_nullification);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "156": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(privateCallPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "157": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize,\n{\n    let serialized_option = load_oracle(contract_address, slot, <T as Deserialize>::N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(utilityStoreCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(utilityLoadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(utilityDeleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(utilityCopyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), value);\n        });\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            let new_value = MockStruct::new(7, 8);\n            store(contract_address, SLOT, new_value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n        });\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n            delete(contract_address, SLOT);\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            delete(contract_address, SLOT);\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 5;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 10;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 1;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 2;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n            assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n            assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 2;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 1;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n            assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n            assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n        });\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            copy(contract_address, SLOT, SLOT, 1);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let value = MockStruct::new(5, 6);\n            store(other_contract_address, SLOT, value);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let _: Option<MockStruct> = load(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            delete(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            copy(other_contract_address, SLOT, SLOT, 0);\n        });\n    }\n}\n"
    },
    "158": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(privateNotifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(privateNotifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(privateNotifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "159": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use crate::context::utility_context::UtilityContext;\n\n#[oracle(utilityGetUtilityContext)]\nunconstrained fn get_utility_context_oracle() -> UtilityContext {}\n\n/// Returns a utility context built from the global variables of anchor block and the contract address of the function\n/// being executed.\npub unconstrained fn get_utility_context() -> UtilityContext {\n    get_utility_context_oracle()\n}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars, true)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n    predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        let mut result = if double_predicate {\n            // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n            embedded_curve_add_unsafe(point1, point1)\n        } else {\n            let point1_1 = EmbeddedCurvePoint {\n                x: point1.x + (x_coordinates_match as Field),\n                y: point1.y,\n                is_infinite: false,\n            };\n            let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n            // point1_1 is guaranteed to have a different abscissa than point2:\n            // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n            // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n            // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n            // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n            // therefore we only want to do this if we need the result, otherwise it needs to be eliminated as a dead instruction, lest we want the circuit to fail.\n            embedded_curve_add_unsafe(point1_1, point2_1)\n        };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n    _predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    // Ensure is_infinite is comptime\n    let point1_1 = EmbeddedCurvePoint { x: point1.x, y: point1.y, is_infinite: false };\n    let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n    embedded_curve_add_unsafe(point1_1, point2_1)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2, true)[0]\n}\n"
    },
    "160": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(privateStoreInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(privateLoadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "161": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(utilityGetContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\nstruct GetContractInstanceResult {\n    exists: bool,\n    member: Field,\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n\nunconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_deployer_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_class_id_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_deployer_internal_avm(address)[0] };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_class_id_internal_avm(address)[0] };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address)[0] };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "165": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr",
      "source": "use protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\nuse protocol_types::traits::{Deserialize, Serialize};\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(utilityGetPublicDataWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> PublicDataWitness {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    get_public_data_witness_oracle(block_number, public_data_tree_index)\n}\n"
    },
    "166": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(utilityGetKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "167": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(utilityGetPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] != 0 } },\n        ivpk_m: IvpkM { inner: Point { x: result[3], y: result[4], is_infinite: result[5] != 0 } },\n        ovpk_m: OvpkM { inner: Point { x: result[6], y: result[7], is_infinite: result[8] != 0 } },\n        tpk_m: TpkM { inner: Point { x: result[9], y: result[10], is_infinite: result[11] != 0 } },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "169": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/message_processing.nr",
      "source": "use protocol_types::address::AztecAddress;\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn fetch_tagged_logs(pending_tagged_log_array_base_slot: Field) {\n    fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(utilityFetchTaggedLogs)]\nunconstrained fn fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n// This must be a single oracle and not one for notes and one for events because the entire point is to validate\n// all notes and events in one go, minimizing node round-trips.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {\n    validate_enqueued_notes_and_events_oracle(\n        contract_address,\n        note_validation_requests_array_base_slot,\n        event_validation_requests_array_base_slot,\n    );\n}\n\n#[oracle(utilityValidateEnqueuedNotesAndEvents)]\nunconstrained fn validate_enqueued_notes_and_events_oracle(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {}\n\npub(crate) unconstrained fn bulk_retrieve_logs(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {\n    bulk_retrieve_logs_oracle(\n        contract_address,\n        log_retrieval_requests_array_base_slot,\n        log_retrieval_responses_array_base_slot,\n    );\n}\n\n#[oracle(utilityBulkRetrieveLogs)]\nunconstrained fn bulk_retrieve_logs_oracle(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n\n    #[test]\n    fn check_decompose_edge_cases() {\n        assert_eq(decompose(0), (0, 0));\n        assert_eq(decompose(TWO_POW_128 - 1), (TWO_POW_128 - 1, 0));\n        assert_eq(decompose(TWO_POW_128 + 1), (1, 1));\n        assert_eq(decompose(TWO_POW_128 * 2), (0, 2));\n        assert_eq(decompose(TWO_POW_128 * 2 + 0x1234567890), (0x1234567890, 2));\n    }\n\n    #[test]\n    fn check_decompose_large_values() {\n        let large_field = 0xffffffffffffffff;\n        let (lo, hi) = decompose(large_field);\n        assert_eq(large_field, lo + TWO_POW_128 * hi);\n\n        let large_value = large_field - TWO_POW_128;\n        let (lo2, hi2) = decompose(large_value);\n        assert_eq(large_value, lo2 + TWO_POW_128 * hi2);\n    }\n\n    #[test]\n    fn check_lt_comprehensive() {\n        assert(lt(0, 1));\n        assert(!lt(1, 0));\n        assert(!lt(0, 0));\n        assert(!lt(42, 42));\n\n        assert(lt(TWO_POW_128 - 1, TWO_POW_128));\n        assert(!lt(TWO_POW_128, TWO_POW_128 - 1));\n    }\n}\n"
    },
    "171": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::note::{note_interface::NoteType, retrieved_note::RetrievedNote};\n\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(privateNotifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(privateNotifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(privateNotifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(utilityGetNotes)]\nunconstrained fn get_notes_oracle<Note, let M: u32, let MaxNotes: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; M],\n    _select_by_offsets: [u8; M],\n    _select_by_lengths: [u8; M],\n    _select_values: [Field; M],\n    _select_comparators: [u8; M],\n    _sort_by_indexes: [u8; M],\n    _sort_by_offsets: [u8; M],\n    _sort_by_lengths: [u8; M],\n    _sort_order: [u8; M],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    // This is always set to MAX_NOTES. We need to pass it to TS in order to correctly construct the BoundedVec\n    _max_notes: u32,\n    // This is always set to <RetrievedNote<Note> as Packable>::N. We need to pass it to TS in order to be able to\n    // correctly construct the BoundedVec there.\n    _packed_retrieved_note_length: u32,\n) -> BoundedVec<[Field; <RetrievedNote<Note> as Packable>::N], MaxNotes>\nwhere\n    // TODO(https://github.com/noir-lang/noir/issues/9399): `Note: Packable` should work here.\n    RetrievedNote<Note>: Packable,\n{}\n\npub unconstrained fn get_notes<Note, let M: u32, let MaxNotes: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Option<RetrievedNote<Note>>; MaxNotes]\nwhere\n    Note: NoteType + Packable,\n{\n    let packed_retrieved_notes: BoundedVec<[Field; <RetrievedNote<Note> as Packable>::N], MaxNotes>\n         = get_notes_oracle::<Note, M, MaxNotes>(\n            storage_slot,\n            num_selects,\n            select_by_indexes,\n            select_by_offsets,\n            select_by_lengths,\n            select_values,\n            select_comparators,\n            sort_by_indexes,\n            sort_by_offsets,\n            sort_by_lengths,\n            sort_order,\n            limit,\n            offset,\n            status,\n            MaxNotes,\n            <RetrievedNote<Note> as Packable>::N,\n        );\n\n    let mut notes = BoundedVec::<_, MaxNotes>::new();\n    for i in 0..packed_retrieved_notes.len() {\n        let retrieved_note = RetrievedNote::unpack(packed_retrieved_notes.get(i));\n        notes.push(retrieved_note);\n    }\n\n    // At last we convert the bounded vector to an array of options. We do this because that is what the filter\n    // function needs to have on the output and we've decided to have the same type on the input and output of\n    // the filter and preprocessor functions.\n    //\n    // We have decided to have the same type on the input and output of the filter and preprocessor functions because\n    // it allows us to chain multiple filters and preprocessors together.\n    //\n    // So why do we want the array of options on the output of the filter function?\n    //\n    // Filter returns an array of options rather than a BoundedVec for performance reasons. Using an array of options\n    // allows setting values at known indices in the output array which is much more efficient than pushing to a\n    // BoundedVec where the write position depends on previous iterations. The array can then be efficiently converted\n    // to a BoundedVec using utils/array/collapse.nr::collapse function from Aztec.nr. This avoids expensive dynamic\n    // memory access patterns that would be required when building up a BoundedVec incrementally. For preprocessor\n    // functions we could use BoundedVec return value as there the optimization does not matter since it is applied in\n    // an unconstrained context. We, however, use the same return value type to be able to use the same function as\n    // both a preprocessor and a filter.\n    let mut notes_array = [Option::none(); MaxNotes];\n    for i in 0..notes.len() {\n        if i < notes.len() {\n            notes_array[i] = Option::some(notes.get_unchecked(i));\n        }\n    }\n\n    notes_array\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(utilityCheckNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n// TODO: Oracles below are generic private log oracles and are not specific to notes. Move them somewhere else.\n\n/// Returns the next app tag for a given sender and recipient pair.\n///\n/// This also notifies the simulator that a tag has been used in a note, and to therefore increment the\n/// associated index so that future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub unconstrained fn get_next_app_tag_as_sender(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> Field {\n    get_next_app_tag_as_sender_oracle(sender, recipient)\n}\n\n#[oracle(privateGetNextAppTagAsSender)]\nunconstrained fn get_next_app_tag_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> Field {}\n\n/// Gets the sender for tags.\n///\n/// This unconstrained value is used as the sender when computing an unconstrained shared secret\n/// for a tag in order to emit a log. Constrained tagging should not use this as there is no\n/// guarantee that the recipient knows about the sender, and hence about the shared secret.\n///\n/// The value persists through nested calls, meaning all calls down the stack will use the same\n/// 'senderForTags' value (unless it is replaced).\npub unconstrained fn get_sender_for_tags() -> Option<AztecAddress> {\n    get_sender_for_tags_oracle()\n}\n\n#[oracle(privateGetSenderForTags)]\nunconstrained fn get_sender_for_tags_oracle() -> Option<AztecAddress> {}\n\n/// Sets the sender for tags.\n///\n/// This unconstrained value is used as the sender when computing an unconstrained shared secret\n/// for a tag in order to emit a log. Constrained tagging should not use this as there is no\n/// guarantee that the recipient knows about the sender, and hence about the shared secret.\n///\n/// Account contracts typically set this value before calling other contracts. The value persists\n/// through nested calls, meaning all calls down the stack will use the same 'senderForTags'\n/// value (unless it is replaced by another call to this setter).\npub unconstrained fn set_sender_for_tags(sender_for_tags: AztecAddress) {\n    set_sender_for_tags_oracle(sender_for_tags);\n}\n\n#[oracle(privateSetSenderForTags)]\nunconstrained fn set_sender_for_tags_oracle(_sender_for_tags: AztecAddress) {}\n"
    },
    "174": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(utilityGetSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "175": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(utilityStorageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: u32,\n    length: u32,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(address.to_field(), storage_slot, block_number, N)\n}\n\npub unconstrained fn storage_read<T>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"utilityStorageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"utilityStorageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"
    },
    "176": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/version.nr",
      "source": "/// The ORACLE_VERSION constant is used to check that the oracle interface is in sync between PXE and Aztec.nr. We need\n/// to version the oracle interface to ensure that developers get a reasonable error message if they use incompatible\n/// versions of Aztec.nr and PXE. The TypeScript counterpart is in `oracle_version.ts`.\n///\n/// @dev Whenever a contract function or Noir test is run, the `utilityAssertCompatibleOracleVersion` oracle is called and\n/// if the oracle version is incompatible an error is thrown.\npub global ORACLE_VERSION: Field = 3;\n\n/// Asserts that the version of the oracle is compatible with the version expected by the contract.\npub fn assert_compatible_oracle_version() {\n    // Safety: This oracle call returns nothing: we only call it to check Aztec.nr and Oracle interface versions are\n    // compatible. It is therefore always safe to call.\n    unsafe {\n        assert_compatible_oracle_version_wrapper();\n    }\n}\n\nunconstrained fn assert_compatible_oracle_version_wrapper() {\n    assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n}\n\n#[oracle(utilityAssertCompatibleOracleVersion)]\nunconstrained fn assert_compatible_oracle_version_oracle(version: Field) {}\n\nmod test {\n    use super::{assert_compatible_oracle_version_oracle, ORACLE_VERSION};\n\n    #[test]\n    unconstrained fn compatible_oracle_version() {\n        assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n    }\n\n    #[test(should_fail_with = \"Incompatible oracle version. TXE is using version '3', but got a request for '318183437'.\")]\n    unconstrained fn incompatible_oracle_version() {\n        let arbitrary_incorrect_version = 318183437;\n        assert_compatible_oracle_version_oracle(arbitrary_incorrect_version);\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n"
    },
    "180": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::HasStorageSlot;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\n\n/// Map\n///\n/// A key-value storage container that maps keys to state variables, similar\n/// to Solidity mappings.\n///\n/// `Map` enables you to associate keys (like addresses or other identifiers)\n/// with state variables in your Aztec smart contract. This is conceptually\n/// similar to Solidity's `mapping(K => V)` syntax, where you can store and\n/// retrieve values by their associated keys.\n///\n/// You can declare a state variable contained within a Map in your contract's\n/// #[storage] struct.\n///\n/// For example, you might use\n/// `Map<AztecAddress, PrivateMutable<ValueNote, Context>, Context>` to track\n/// token balances for different users, similar to how you'd use\n/// `mapping(address => uint256)` in Solidity.\n///\n/// > Aside: the verbose `Context` in the declaration is a consequence of\n/// > leveraging Noir's regular syntax for generics to ensure that certain\n/// > state variable methods can only be called in some contexts (private,\n/// > public, utility).\n///\n/// The methods of Map are:\n/// - `at` (access state variable for a given key)\n/// (see the method's own doc comments for more info).\n///\n/// ## Generic Parameters\n/// - `K`: The key type (must implement `ToField` trait for hashing)\n/// - `V`: The value type:\n///   - any Aztec state variable:\n///     - `PublicMutable`\n///     - `PublicImmutable`\n///     - `PrivateMutable`\n///     - `PrivateImmutable`\n///     - `PrivateSet`\n///     - `DelayedPublicMutable`\n///     - `Map`\n/// - `Context`: The execution context (handles private/public function\n///   contexts)\n///\n/// ## Usage\n/// Maps are typically declared in your contract's #[storage] struct and\n/// accessed\n/// using the `at(key)` method to get the state variable for a specific key.\n/// The resulting state variable can then be read from or written to using its\n/// own methods.\n///\n/// ## Advanced\n/// Internally, `Map` uses a single base storage slot to represent the\n/// mapping\n/// itself, similar to Solidity's approach. Individual key-value pairs are\n/// stored at derived storage slots computed by hashing the base storage\n/// slot\n/// with the key using Poseidon2. This ensures:\n/// - No storage slot collisions between different keys\n/// - Uniform distribution of storage slots across the storage space\n/// - Compatibility with Aztec's storage tree structure\n/// - Gas-efficient storage access patterns similar to Solidity mappings\n///\n/// The storage slot derivation uses `derive_storage_slot_in_map(base_slot,\n/// key)` which computes `poseidon2_hash([base_slot, key.to_field()])`,\n/// ensuring cryptographically secure slot separation.\n///\n/// docs:start:map\npub struct Map<K, V, Context> {\n    pub context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n\n// Map reserves a single storage slot regardless of what it stores because\n// nothing is stored at said slot: it is only used to derive the storage slots\n// of nested state variables, which is expected to never result in collisions\n// or slots being close to one another due to these being hashes. This mirrors\n// the strategy adopted by Solidity mappings.\nimpl<K, T, Context> HasStorageSlot<1> for Map<K, T, Context> {\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    /// Initializes a new Map state variable.\n    ///\n    /// This function is usually automatically called within the #[storage]\n    /// macro.\n    /// You typically don't need to call this directly when writing smart contracts.\n    ///\n    /// # Arguments\n    ///\n    /// * `context` - One of `PrivateContext`/`PublicContext`/`UtilityContext`.\n    ///               The Context determines which methods of this struct will\n    ///               be made available to the calling smart contract function.\n    /// * `storage_slot` - A unique identifier for this Map within the contract.\n    ///                    Usually, the #[storage] macro will determine an\n    ///                    appropriate storage_slot automatically. A smart\n    ///                    contract dev shouldn't have to worry about this, as\n    ///                    it's managed behind the scenes.\n    /// * `state_var_constructor` - A function that creates the value type (V)\n    ///                             given a context and storage slot. This is\n    ///                             typically the constructor of the state\n    ///                             variable type being stored in the Map.\n    ///\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n\n    /// Returns the state variable associated with the given key.\n    ///\n    /// This is equivalent to accessing `mapping[key]` in Solidity. It returns\n    /// the state variable instance for the specified key, which can then be\n    /// used to read or write the value at that key.\n    ///\n    /// Unlike Solidity mappings which return the value directly, this returns\n    /// the state variable wrapper (like PrivateMutable, PublicMutable, etc.)\n    /// that you then call methods on to interact with the actual value.\n    ///\n    /// # Arguments\n    ///\n    /// * `key` - The key to look up in the map. Must implement the ToField\n    ///           trait (which most basic Noir & Aztec types do).\n    ///\n    /// # Returns\n    ///\n    /// * `V` - The state variable instance for this key. You can then call\n    ///         methods like `.read()`, `.write()`, `.get_note()`, etc. on this\n    ///         depending on the specific state variable type.\n    ///\n    /// # Example\n    ///\n    /// ```noir\n    /// // Get a user's balance (assuming PrivateMutable<ValueNote>)\n    /// let user_balance = storage.balances.at(user_address);\n    /// let current_note = user_balance.get_note();\n    ///\n    /// // Update the balance\n    /// user_balance.replace(new_note);\n    /// ```\n    ///\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n}\n"
    },
    "188": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr",
      "source": "use crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::storage::HasStorageSlot,\n    utils::with_hash::WithHash,\n};\nuse protocol_types::{\n    constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator,\n    traits::Packable,\n};\n\n/// # PublicImmutable\n///\n/// PublicImmutable is a public state variable type for values that are set once\n/// during initialization and remain permanently unchanged.\n///\n/// You can declare a state variable of type PublicImmutable within your contract's\n/// #[storage] struct:\n///\n/// E.g.:\n/// `your_variable: PublicImmutable<T, Context>`\n///\n/// PublicImmutable stores an immutable value in public state which can be _read_\n/// from public, utility and even _private_ execution contexts.\n///\n/// The methods of PublicImmutable are:\n/// - `initialize`\n/// - `read`\n/// (see the methods' own doc comments for more info).\n///\n/// # Generic Parameters:\n///\n/// * `T` - The type of value stored (must implement Packable).\n/// * `Context` - The execution context (PublicContext, PrivateContext, or UtilityContext).\n///\n/// # Advanced\n///\n/// PublicImmutable leverages `WithHash<T>` to enable efficient private reads of\n/// public storage. The `WithHash` wrapper optimizes reads by hashing values that would\n/// be larger than a single field into a single field, then proving inclusion of only\n/// the hash in public storage.\n///\n/// This optimization is particularly valuable when T packs to multiple fields,\n/// as it maintains \"almost constant\" verification overhead regardless of the\n/// original data size.\n///\n/// ## Optimizing private reads in your contract\n/// Since reading T from public immutable storage in private contexts has \"almost\n/// constant\" constraint costs regardless of T's size, it's recommended to group\n/// multiple values into a single struct when they are to be read together. This is\n/// typically useful for configuration data set during contract initialization. E.g.:\n///\n/// ```noir\n/// use dep::aztec::protocol_types::{address::AztecAddress, traits::Packable};\n/// use std::meta::derive;\n///\n/// #[derive(Eq, Packable)]\n/// pub struct Config \\{\n///     pub address_1: AztecAddress,\n///     pub value_1: u128,\n///     pub value_2: u64,\n///     ...\n/// }\n/// ```\n///\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\n/// `PublicImmutable` stores both the packed value (using M fields) and its hash (1 field), requiring M + 1 total\n/// fields.\nimpl<T, Context, let M: u32> HasStorageSlot<M + 1> for PublicImmutable<T, Context>\nwhere\n    T: Packable<N = M>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    /// Initializes a new PublicImmutable state variable.\n    ///\n    /// This function is usually automatically called within the #[storage] macro.\n    /// You typically don't need to call this directly when writing smart contracts.\n    ///\n    /// # Arguments\n    ///\n    /// * `context` - One of `PublicContext`/`PrivateContext`/`UtilityContext`. The\n    ///               Context determines which methods of this struct will be made\n    ///               available to the calling smart contract function.\n    /// * `storage_slot` - A unique identifier for this state variable within the\n    ///                    contract. Usually, the #[storage] macro will determine an\n    ///                    appropriate storage_slot automatically. A smart contract\n    ///                    dev shouldn't have to worry about this, as it's managed\n    ///                    behind the scenes.\n    ///\n    /// docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n        )\n    }\n}\n\nimpl<T> PublicImmutable<T, &mut PublicContext> {\n    /// Initializes a PublicImmutable state variable instance with a permanent value.\n    ///\n    /// This function sets the immutable value for this state variable. It can only\n    /// be called once per PublicImmutable. Subsequent calls will fail because the\n    /// initialization nullifier will already exist.\n    ///\n    /// # Arguments\n    /// * `value` - The permanent value to store in this PublicImmutable.\n    ///\n    /// # Panics\n    /// Panics if the value is already initialized.\n    ///\n    /// # Advanced\n    ///\n    /// This function performs the following operations:\n    /// - Creates and emits an initialization nullifier to mark this storage slot\n    ///   as initialized. This prevents double-initialization.\n    /// - Wraps the value in `WithHash<T>` for efficient private reads.\n    /// - Stores the wrapped value in Aztec's public data tree.\n    ///\n    /// docs:start:public_immutable_struct_write\n    pub fn initialize(self, value: T)\n    where\n        T: Packable + Eq,\n    {\n        // We emit an initialization nullifier to indicate that the struct is initialized. This also prevents\n        // the value from being initialized again as a nullifier can be included only once.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        self.context.storage_write(self.storage_slot, WithHash::new(value));\n    }\n\n    /// Reads the permanent value stored in this PublicImmutable state variable.\n    ///\n    /// # Returns\n    /// * `T` - The permanent value stored in this PublicImmutable.\n    ///\n    /// # Panics\n    /// Panics if the value is not initialized.\n    ///\n    /// # Advanced\n    ///\n    /// This function performs the following operations:\n    /// - Checks that the state variable has been initialized by verifying the\n    ///   initialization nullifier exists\n    /// - Reads the `WithHash<T>` wrapper from public storage\n    /// - Extracts and returns the original value T\n    ///\n    /// The function will panic if called on an uninitialized PublicImmutable.\n    ///\n    /// docs:start:public_immutable_struct_read\n    pub fn read(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        assert(self.is_initialized(), \"Trying to read from uninitialized PublicImmutable\");\n        WithHash::public_storage_read(*self.context, self.storage_slot)\n    }\n\n    /// Reads the value stored in this PublicImmutable without checking if the value\n    /// is initialized.\n    ///\n    /// This function bypasses the initialization check and directly reads from\n    /// storage.\n    /// If the PublicImmutable has not been initialized, this will return a\n    /// zeroed value.\n    /// However, if the variable is _known_ to be initialized, this is cheaper\n    /// to call than `read`.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The value stored in this PublicImmutable, or empty/default values if\n    ///         uninitialized.\n    ///\n    pub fn read_unsafe(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        WithHash::public_storage_read(*self.context, self.storage_slot)\n    }\n\n    fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.nullifier_exists(nullifier, self.context.this_address())\n    }\n}\n\nimpl<T> PublicImmutable<T, UtilityContext> {\n    /// Reads the permanent value stored in this PublicImmutable state variable.\n    ///\n    /// Notice that this function is executable only within a UtilityContext, which\n    /// is an unconstrained environment on the user's local device.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The permanent value stored in this PublicImmutable.\n    ///\n    pub unconstrained fn read(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        // TODO(#15703): this fn should fail if the variable is not initialized\n        WithHash::utility_public_storage_read(self.context, self.storage_slot)\n    }\n}\n\nimpl<T> PublicImmutable<T, &mut PrivateContext> {\n    /// Reads the permanent value stored in this PublicImmutable from the anchor\n    /// block.\n    ///\n    /// Private functions execute asynchronously and offchain. When a user begins\n    /// private execution, their view of the chain 'branches off' from the current\n    /// public state, since public state continues to advance while they execute\n    /// privately. Therefore, private functions read from a historical snapshot of\n    /// public state rather than the current state.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The permanent value stored in this PublicImmutable at the historical\n    ///         block referenced by the private context.\n    ///\n    /// # Advanced\n    ///\n    /// This function performs a historical read using the block header from the private\n    /// context. The `WithHash` optimization is particularly valuable here because it\n    /// reduces the number of required inclusion proofs by proving membership of\n    /// only the hash instead of the full packed value.\n    ///\n    /// The historical read mechanism:\n    /// - Uses an oracle to obtain the value from the anchor block\n    /// - Proves inclusion of the value's hash in the public data tree\n    /// - Proves that the root of this public data tree is correct, relative to the\n    ///   anchor block header.\n    /// - Verifies that the oracle-provided value matches the stored hash\n    ///\n    pub fn read(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        // TODO(#15703): this fn should fail if the variable is not initialized\n        WithHash::historical_public_storage_read(\n            self.context.get_anchor_block_header(),\n            self.context.this_address(),\n            self.storage_slot,\n        )\n    }\n}\n"
    },
    "19": {
      "path": "std/hash/mod.nr",
      "source": "// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"
    },
    "190": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr",
      "source": "use crate::context::{PublicContext, UtilityContext};\nuse crate::state_vars::storage::HasStorageSlot;\nuse dep::protocol_types::traits::Packable;\n\n/// # PublicMutable\n///\n/// PublicMutable is a public state variable type for values that can be read\n/// and written within #[external(\"public\")] functions of your smart contract.\n///\n/// You can declare a state variable of type PublicMutable within your contract's\n/// #[storage] struct:\n///\n/// E.g.:\n/// `your_variable: PublicMutable<T, Context>`\n/// or:\n/// `your_mapping: Map<Field, PublicMutable<T, Context>>`\n///\n/// The methods of PublicMutable are:\n/// - `read`\n/// - `write`\n/// (see the methods' own doc comments for more info).\n///\n/// ## Example.\n///\n/// A voting contract's proposal count can be represented as a PublicMutable<u64>.\n/// The count can be read by anyone to see how many proposals exist, and incremented\n/// when new proposals are submitted.\n///\n/// # Generic Parameters:\n///\n/// * `T` - The type of value stored (must implement Packable).\n/// * `Context` - The execution context (PublicContext or UtilityContext).\n///\n/// # Advanced\n///\n/// Unlike private state variables which use notes, PublicMutable stores values\n/// directly in Aztec's public data tree. This enables direct read and write\n/// access to the current state during public function execution.\n///\n/// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\nimpl<T, Context, let M: u32> HasStorageSlot<M> for PublicMutable<T, Context>\nwhere\n    T: Packable<N = M>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    /// Initializes a new PublicMutable state variable.\n    ///\n    /// This function is usually automatically called within the #[storage] macro.\n    /// You typically don't need to call this directly when writing smart contracts.\n    ///\n    /// # Arguments\n    ///\n    /// * `context` - One of `PublicContext`/`UtilityContext`. The Context determines\n    ///               which methods of this struct will be made available to the calling\n    ///               smart contract function.\n    /// * `storage_slot` - A unique identifier for this state variable within the\n    ///                    contract. Usually, the #[storage] macro will determine an\n    ///                    appropriate storage_slot automatically. A smart contract\n    ///                    dev shouldn't have to worry about this, as it's managed\n    ///                    behind the scenes.\n    ///\n    /// docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n}\n\nimpl<T> PublicMutable<T, &mut PublicContext> {\n    /// Reads the current value stored in this PublicMutable state variable.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The current value stored in this PublicMutable.\n    ///\n    /// docs:start:public_mutable_struct_read\n    pub fn read(self) -> T\n    where\n        T: Packable,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n\n    /// Writes a new value to this PublicMutable state variable.\n    ///\n    /// # Arguments\n    ///\n    /// * `value` - The new value to store in this PublicMutable.\n    ///\n    /// # Advanced\n    ///\n    /// This function updates the value stored in Aztec's public data tree.\n    /// The new value becomes immediately available to subsequent reads within\n    /// the same transaction.\n    ///\n    /// docs:start:public_mutable_struct_write\n    pub fn write(self, value: T)\n    where\n        T: Packable,\n    {\n        self.context.storage_write(self.storage_slot, value);\n    }\n}\n\nimpl<T> PublicMutable<T, UtilityContext> {\n    /// Reads the current value stored in this PublicMutable state variable.\n    ///\n    /// Notice that this function is executable only within a UtilityContext, which\n    /// is an unconstrained environment on the user's local device.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The current value stored in this PublicMutable.\n    ///\n    pub unconstrained fn read(self) -> T\n    where\n        T: Packable,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"
    },
    "210": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends the elements of the second `BoundedVec` to the end of the first one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let ALen: u32, let BLen: u32, let DstLen: u32>(\n    a: BoundedVec<T, ALen>,\n    b: BoundedVec<T, BLen>,\n) -> BoundedVec<T, DstLen> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "213": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DstLen` elements from a source array, starting at `offset`. `DstLen` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SrcLen: u32, let DstLen: u32>(src: [T; SrcLen], offset: u32) -> [T; DstLen] {\n    assert(offset + DstLen <= SrcLen, \"DstLen too large for offset\");\n\n    let mut dst: [T; DstLen] = std::mem::zeroed();\n    for i in 0..DstLen {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DstLen to be 0, so we always get back an empty array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "214": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DstMaxLen` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DstLen` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DstLen` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SrcMaxLen: u32, let DstMaxLen: u32>(\n    bvec: BoundedVec<T, SrcMaxLen>,\n    offset: u32,\n) -> BoundedVec<T, DstMaxLen> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "216": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "217": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "220": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use protocol_types::{point::Point, utils::field::sqrt};\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\n/// Returns a `Point` in the Grumpkin curve given its x coordinate.\n///\n/// Because not all values in the field are valid x coordinates of points in the curve (i.e. there\n/// is no corresponding y value in the field that satisfies the curve equation), it may not be\n/// possible to reconstruct a `Point`. `Option::none()` is returned in such cases.\npub fn point_from_x_coord(x: Field) -> Option<Point> {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    sqrt(rhs).map(|y| Point { x, y, is_infinite: false })\n}\n\n/// Returns a `Point` in the Grumpkin curve given its x coordinate and sign for the y coordinate.\n///\n/// Because not all values in the field are valid x coordinates of points in the curve (i.e. there\n/// is no corresponding y value in the field that satisfies the curve equation), it may not be\n/// possible to reconstruct a `Point`. `Option::none()` is returned in such cases.\n///\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Option<Point> {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n\n    sqrt(rhs).map(|y| {\n        // If there is a square root, we need to ensure it has the correct \"sign\"\n        let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n        let final_y = if y_is_positive == sign { y } else { -y };\n        Point { x, y: final_y, is_infinite: false }\n    })\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord, point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n    use dep::protocol_types::utils::field::pow;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign).unwrap();\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2).unwrap();\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_valid() {\n        // x = 8 is a known quadratic residue - should give a valid point\n        let result = point_from_x_coord(Field::from(8));\n        assert(result.is_some());\n\n        let point = result.unwrap();\n        assert_eq(point.x, Field::from(8));\n        // Check curve equation y^2 = x^3 - 17\n        assert_eq(pow(point.y, 2), pow(point.x, 3) - 17);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_invalid() {\n        // x = 3 is a non-residue for this curve - should give None\n        let x = Field::from(3);\n        let maybe_point = point_from_x_coord(x);\n        assert(maybe_point.is_none());\n    }\n\n}\n"
    },
    "224": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr",
      "source": "use crate::{\n    context::{PublicContext, UtilityContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    abis::block_header::BlockHeader, address::AztecAddress, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `M` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `M`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let M: u32> {\n    value: T,\n    packed: [Field; M],\n    hash: Field,\n}\n\nimpl<T, let M: u32> WithHash<T, M>\nwhere\n    T: Packable<N = M> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn utility_public_storage_read(\n        context: UtilityContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + M as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\n// Note: I don't derive Packable on `WithHash` because `derive_serialize` function does not support setting \"N = M\"\n// as I do here 3 lines below. This could be worked around by placing the \"where\" clause directly on the `WithHash`\n// struct, but Jake mentioned that the syntax is not expected to be supported at least until Noir 1.0.\n// Relevant discussion on Slack:\n// https://aztecprotocol.slack.com/archives/C04QF64EDNV/p1752593876160699?thread_ts=1752589887.955379&cid=C04QF64EDNV\nimpl<T, let M: u32> Packable for WithHash<T, M>\nwhere\n    T: Packable<N = M>,\n{\n    let N: u32 = M + 1;\n\n    fn pack(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n        for i in 0..M {\n            result[i] = self.packed[i];\n        }\n        result[M] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; Self::N]) -> Self {\n        let mut value_packed = [0; M];\n        for i in 0..M {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[M];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::test::OracleMock;\n\n    global STORAGE_SLOT: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let env = TestEnvironment::new();\n\n        env.private_context(|context| {\n            let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n                context.anchor_block_header,\n                context.this_address(),\n                STORAGE_SLOT,\n            );\n\n            assert_eq(result, std::mem::zeroed());\n        });\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        env.public_context(|context| { context.storage_write(STORAGE_SLOT, value_with_hash); });\n\n        env.private_context(|context| {\n            let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n                context.anchor_block_header,\n                context.this_address(),\n                STORAGE_SLOT,\n            );\n            assert_eq(result, value);\n        });\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn bad_hint_uninitialized_value() {\n        let env = TestEnvironment::new();\n\n        env.private_context(|context| {\n            let block_header = context.anchor_block_header;\n            let address = context.this_address();\n\n            // Mock the oracle to return a non-zero hint/packed value\n            let value_packed = MockStruct { a: 1, b: 1 }.pack();\n            let _ = OracleMock::mock(\"utilityStorageRead\")\n                .with_params((\n                    address.to_field(), STORAGE_SLOT, block_header.global_variables.block_number,\n                    value_packed.len(),\n                ))\n                .returns(value_packed)\n                .times(1);\n\n            // This should fail because the hint value is non-zero and the hash is zero (default value of storage)\n            let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n                block_header,\n                address,\n                STORAGE_SLOT,\n            );\n        });\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn bad_hint_initialized_value() {\n        let env = TestEnvironment::new();\n\n        env.public_context(|context| {\n            // Write the value and hash separately so that the hash is wrong\n            let value = MockStruct { a: 5, b: 3 };\n            context.storage_write(STORAGE_SLOT, value);\n\n            let incorrect_hash = 13;\n            let hash_storage_slot = STORAGE_SLOT + (value.pack().len() as Field);\n            context.storage_write(hash_storage_slot, [incorrect_hash]);\n        });\n\n        env.private_context(|context| {\n            let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n                context.anchor_block_header,\n                context.this_address(),\n                STORAGE_SLOT,\n            );\n        });\n    }\n}\n"
    },
    "231": {
      "path": "/home/jpag/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr",
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "25": {
      "path": "std/meta/expr.nr",
      "source": "//! Contains methods on the built-in `Expr` type for quoted, syntactically valid expressions.\n\nuse crate::meta::op::BinaryOp;\nuse crate::meta::op::UnaryOp;\nuse crate::option::Option;\n\nimpl Expr {\n    /// If this expression is an array literal `[elem1, ..., elemN]`, this returns a slice of each element in the array.\n    #[builtin(expr_as_array)]\n    // docs:start:as_array\n    pub comptime fn as_array(self) -> Option<[Expr]> {}\n    // docs:end:as_array\n\n    /// If this expression is an assert, this returns the assert expression and the optional message.\n    #[builtin(expr_as_assert)]\n    // docs:start:as_assert\n    pub comptime fn as_assert(self) -> Option<(Expr, Option<Expr>)> {}\n    // docs:end:as_assert\n\n    /// If this expression is an assert_eq, this returns the left-hand-side and right-hand-side\n    /// expressions, together with the optional message.\n    #[builtin(expr_as_assert_eq)]\n    // docs:start:as_assert_eq\n    pub comptime fn as_assert_eq(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_assert_eq\n\n    /// If this expression is an assignment, this returns a tuple with the left hand side\n    /// and right hand side in order.\n    #[builtin(expr_as_assign)]\n    // docs:start:as_assign\n    pub comptime fn as_assign(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_assign\n\n    /// If this expression is a binary operator operation `<lhs> <op> <rhs>`,\n    /// return the left-hand side, operator, and the right-hand side of the operation.\n    #[builtin(expr_as_binary_op)]\n    // docs:start:as_binary_op\n    pub comptime fn as_binary_op(self) -> Option<(Expr, BinaryOp, Expr)> {}\n    // docs:end:as_binary_op\n\n    /// If this expression is a block `{ stmt1; stmt2; ...; stmtN }`, return\n    /// a slice containing each statement.\n    #[builtin(expr_as_block)]\n    // docs:start:as_block\n    pub comptime fn as_block(self) -> Option<[Expr]> {}\n    // docs:end:as_block\n\n    /// If this expression is a boolean literal, return that literal.\n    #[builtin(expr_as_bool)]\n    // docs:start:as_bool\n    pub comptime fn as_bool(self) -> Option<bool> {}\n    // docs:end:as_bool\n\n    /// If this expression is a cast expression `expr as type`, returns the casted\n    /// expression and the type to cast to.\n    // docs:start:as_cast\n    #[builtin(expr_as_cast)]\n    pub comptime fn as_cast(self) -> Option<(Expr, UnresolvedType)> {}\n    // docs:end:as_cast\n\n    /// If this expression is a `comptime { stmt1; stmt2; ...; stmtN }` block,\n    /// return each statement in the block.\n    #[builtin(expr_as_comptime)]\n    // docs:start:as_comptime\n    pub comptime fn as_comptime(self) -> Option<[Expr]> {}\n    // docs:end:as_comptime\n\n    /// If this expression is a constructor `Type { field1: expr1, ..., fieldN: exprN }`,\n    /// return the type and the fields.\n    #[builtin(expr_as_constructor)]\n    // docs:start:as_constructor\n    pub comptime fn as_constructor(self) -> Option<(UnresolvedType, [(Quoted, Expr)])> {}\n    // docs:end:as_constructor\n\n    /// If this expression is a for statement over a single expression, return the identifier,\n    /// the expression and the for loop body.\n    #[builtin(expr_as_for)]\n    // docs:start:as_for\n    pub comptime fn as_for(self) -> Option<(Quoted, Expr, Expr)> {}\n    // docs:end:as_for\n\n    /// If this expression is a for statement over a range, return the identifier,\n    /// the range start, the range end and the for loop body.\n    #[builtin(expr_as_for_range)]\n    // docs:start:as_for_range\n    pub comptime fn as_for_range(self) -> Option<(Quoted, Expr, Expr, Expr)> {}\n    // docs:end:as_for_range\n\n    /// If this expression is a function call `foo(arg1, ..., argN)`, return\n    /// the function and a slice of each argument.\n    #[builtin(expr_as_function_call)]\n    // docs:start:as_function_call\n    pub comptime fn as_function_call(self) -> Option<(Expr, [Expr])> {}\n    // docs:end:as_function_call\n\n    /// If this expression is an `if condition { then_branch } else { else_branch }`,\n    /// return the condition, then branch, and else branch. If there is no else branch,\n    /// `None` is returned for that branch instead.\n    #[builtin(expr_as_if)]\n    // docs:start:as_if\n    pub comptime fn as_if(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_if\n\n    /// If this expression is an index into an array `array[index]`, return the\n    /// array and the index.\n    #[builtin(expr_as_index)]\n    // docs:start:as_index\n    pub comptime fn as_index(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_index\n\n    /// If this expression is an integer literal, return the integer as a field\n    /// as well as whether the integer is negative (true) or not (false).\n    #[builtin(expr_as_integer)]\n    // docs:start:as_integer\n    pub comptime fn as_integer(self) -> Option<(Field, bool)> {}\n    // docs:end:as_integer\n\n    /// If this expression is a lambda, returns the parameters, return type and body.\n    #[builtin(expr_as_lambda)]\n    // docs:start:as_lambda\n    pub comptime fn as_lambda(\n        self,\n    ) -> Option<([(Expr, Option<UnresolvedType>)], Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_lambda\n\n    /// If this expression is a let statement, returns the let pattern as an `Expr`,\n    /// the optional type annotation, and the assigned expression.\n    #[builtin(expr_as_let)]\n    // docs:start:as_let\n    pub comptime fn as_let(self) -> Option<(Expr, Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_let\n\n    /// If this expression is a member access `foo.bar`, return the struct/tuple\n    /// expression and the field. The field will be represented as a quoted value.\n    #[builtin(expr_as_member_access)]\n    // docs:start:as_member_access\n    pub comptime fn as_member_access(self) -> Option<(Expr, Quoted)> {}\n    // docs:end:as_member_access\n\n    /// If this expression is a method call `foo.bar::<generic1, ..., genericM>(arg1, ..., argN)`, return\n    /// the receiver, method name, a slice of each generic argument, and a slice of each argument.\n    #[builtin(expr_as_method_call)]\n    // docs:start:as_method_call\n    pub comptime fn as_method_call(self) -> Option<(Expr, Quoted, [UnresolvedType], [Expr])> {}\n    // docs:end:as_method_call\n\n    /// If this expression is a repeated element array `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_array)]\n    // docs:start:as_repeated_element_array\n    pub comptime fn as_repeated_element_array(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_array\n\n    /// If this expression is a repeated element slice `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_slice)]\n    // docs:start:as_repeated_element_slice\n    pub comptime fn as_repeated_element_slice(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_slice\n\n    /// If this expression is a slice literal `&[elem1, ..., elemN]`,\n    /// return each element of the slice.\n    #[builtin(expr_as_slice)]\n    // docs:start:as_slice\n    pub comptime fn as_slice(self) -> Option<[Expr]> {}\n    // docs:end:as_slice\n\n    /// If this expression is a tuple `(field1, ..., fieldN)`,\n    /// return each element of the tuple.\n    #[builtin(expr_as_tuple)]\n    // docs:start:as_tuple\n    pub comptime fn as_tuple(self) -> Option<[Expr]> {}\n    // docs:end:as_tuple\n\n    /// If this expression is a unary operation `<op> <rhs>`,\n    /// return the unary operator as well as the right-hand side expression.\n    #[builtin(expr_as_unary_op)]\n    // docs:start:as_unary_op\n    pub comptime fn as_unary_op(self) -> Option<(UnaryOp, Expr)> {}\n    // docs:end:as_unary_op\n\n    /// If this expression is an `unsafe { stmt1; ...; stmtN }` block,\n    /// return each statement inside in a slice.\n    #[builtin(expr_as_unsafe)]\n    // docs:start:as_unsafe\n    pub comptime fn as_unsafe(self) -> Option<[Expr]> {}\n    // docs:end:as_unsafe\n\n    /// Returns `true` if this expression is trailed by a semicolon.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// comptime {\n    ///     let expr1 = quote { 1 + 2 }.as_expr().unwrap();\n    ///     let expr2 = quote { 1 + 2; }.as_expr().unwrap();\n    ///\n    ///     assert(expr1.as_binary_op().is_some());\n    ///     assert(expr2.as_binary_op().is_some());\n    ///\n    ///     assert(!expr1.has_semicolon());\n    ///     assert(expr2.has_semicolon());\n    /// }\n    /// ```\n    #[builtin(expr_has_semicolon)]\n    // docs:start:has_semicolon\n    pub comptime fn has_semicolon(self) -> bool {}\n    // docs:end:has_semicolon\n\n    /// Returns `true` if this expression is `break`.\n    #[builtin(expr_is_break)]\n    // docs:start:is_break\n    pub comptime fn is_break(self) -> bool {}\n    // docs:end:is_break\n\n    /// Returns `true` if this expression is `continue`.\n    #[builtin(expr_is_continue)]\n    // docs:start:is_continue\n    pub comptime fn is_continue(self) -> bool {}\n    // docs:end:is_continue\n\n    /// Applies a mapping function to this expression and to all of its sub-expressions.\n    /// `f` will be applied to each sub-expression first, then applied to the expression itself.\n    ///\n    /// This happens recursively for every expression within `self`.\n    ///\n    /// For example, calling `modify` on `(&[1], &[2, 3])` with an `f` that returns `Option::some`\n    /// for expressions that are integers, doubling them, would return `(&[2], &[4, 6])`.\n    // docs:start:modify\n    pub comptime fn modify<Env>(self, f: fn[Env](Expr) -> Option<Expr>) -> Expr {\n        // docs:end:modify\n        let result = modify_array(self, f);\n        let result = result.or_else(|| modify_assert(self, f));\n        let result = result.or_else(|| modify_assert_eq(self, f));\n        let result = result.or_else(|| modify_assign(self, f));\n        let result = result.or_else(|| modify_binary_op(self, f));\n        let result = result.or_else(|| modify_block(self, f));\n        let result = result.or_else(|| modify_cast(self, f));\n        let result = result.or_else(|| modify_comptime(self, f));\n        let result = result.or_else(|| modify_constructor(self, f));\n        let result = result.or_else(|| modify_if(self, f));\n        let result = result.or_else(|| modify_index(self, f));\n        let result = result.or_else(|| modify_for(self, f));\n        let result = result.or_else(|| modify_for_range(self, f));\n        let result = result.or_else(|| modify_lambda(self, f));\n        let result = result.or_else(|| modify_let(self, f));\n        let result = result.or_else(|| modify_function_call(self, f));\n        let result = result.or_else(|| modify_member_access(self, f));\n        let result = result.or_else(|| modify_method_call(self, f));\n        let result = result.or_else(|| modify_repeated_element_array(self, f));\n        let result = result.or_else(|| modify_repeated_element_slice(self, f));\n        let result = result.or_else(|| modify_slice(self, f));\n        let result = result.or_else(|| modify_tuple(self, f));\n        let result = result.or_else(|| modify_unary_op(self, f));\n        let result = result.or_else(|| modify_unsafe(self, f));\n        if result.is_some() {\n            let result = result.unwrap_unchecked();\n            let modified = f(result);\n            modified.unwrap_or(result)\n        } else {\n            f(self).unwrap_or(self)\n        }\n    }\n\n    /// Returns this expression as a `Quoted` value. It's the same as `quote { $self }`.\n    // docs:start:quoted\n    pub comptime fn quoted(self) -> Quoted {\n        // docs:end:quoted\n        quote { $self }\n    }\n\n    /// Resolves and type-checks this expression and returns the result as a `TypedExpr`.\n    ///\n    /// The `in_function` argument specifies where the expression is resolved:\n    /// - If it's `none`, the expression is resolved in the function where `resolve` was called\n    /// - If it's `some`, the expression is resolved in the given function\n    ///\n    /// If any names used by this expression are not in scope or if there are any type errors,\n    /// this will give compiler errors as if the expression was written directly into\n    /// the current `comptime` function.\n    #[builtin(expr_resolve)]\n    // docs:start:resolve\n    pub comptime fn resolve(self, in_function: Option<FunctionDefinition>) -> TypedExpr {}\n    // docs:end:resolve\n}\n\ncomptime fn modify_array<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_array().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_array(exprs)\n    })\n}\n\ncomptime fn modify_assert<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert().map(|(predicate, msg)| {\n        let predicate = predicate.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert(predicate, msg)\n    })\n}\n\ncomptime fn modify_assert_eq<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert_eq().map(|(lhs, rhs, msg)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert_eq(lhs, rhs, msg)\n    })\n}\n\ncomptime fn modify_assign<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assign().map(|expr| {\n        let (lhs, rhs) = expr;\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_assign(lhs, rhs)\n    })\n}\n\ncomptime fn modify_binary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_binary_op().map(|(lhs, op, rhs)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_binary_op(lhs, op, rhs)\n    })\n}\n\ncomptime fn modify_block<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_block().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_block(exprs)\n    })\n}\n\ncomptime fn modify_cast<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_cast().map(|(expr, typ)| {\n        let expr = expr.modify(f);\n        new_cast(expr, typ)\n    })\n}\n\ncomptime fn modify_comptime<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_comptime().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_comptime(exprs)\n    })\n}\n\ncomptime fn modify_constructor<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_constructor().map(|(typ, fields)| {\n        let fields = fields.map(|(name, value)| (name, value.modify(f)));\n        new_constructor(typ, fields)\n    })\n}\n\ncomptime fn modify_function_call<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_function_call().map(|(function, arguments)| {\n        let function = function.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_function_call(function, arguments)\n    })\n}\n\ncomptime fn modify_if<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_if().map(|(condition, consequence, alternative)| {\n        let condition = condition.modify(f);\n        let consequence = consequence.modify(f);\n        let alternative = alternative.map(|alternative| alternative.modify(f));\n        new_if(condition, consequence, alternative)\n    })\n}\n\ncomptime fn modify_index<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_index().map(|(object, index)| {\n        let object = object.modify(f);\n        let index = index.modify(f);\n        new_index(object, index)\n    })\n}\n\ncomptime fn modify_for<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for().map(|(identifier, array, body)| {\n        let array = array.modify(f);\n        let body = body.modify(f);\n        new_for(identifier, array, body)\n    })\n}\n\ncomptime fn modify_for_range<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for_range().map(|(identifier, from, to, body)| {\n        let from = from.modify(f);\n        let to = to.modify(f);\n        let body = body.modify(f);\n        new_for_range(identifier, from, to, body)\n    })\n}\n\ncomptime fn modify_lambda<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_lambda().map(|(params, return_type, body)| {\n        let params = params.map(|(name, typ)| (name.modify(f), typ));\n        let body = body.modify(f);\n        new_lambda(params, return_type, body)\n    })\n}\n\ncomptime fn modify_let<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_let().map(|(pattern, typ, expr)| {\n        let pattern = pattern.modify(f);\n        let expr = expr.modify(f);\n        new_let(pattern, typ, expr)\n    })\n}\n\ncomptime fn modify_member_access<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_member_access().map(|(object, name)| {\n        let object = object.modify(f);\n        new_member_access(object, name)\n    })\n}\n\ncomptime fn modify_method_call<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_method_call().map(|(object, name, generics, arguments)| {\n        let object = object.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_method_call(object, name, generics, arguments)\n    })\n}\n\ncomptime fn modify_repeated_element_array<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_array().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_array(expr, length)\n    })\n}\n\ncomptime fn modify_repeated_element_slice<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_slice().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_slice(expr, length)\n    })\n}\n\ncomptime fn modify_slice<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_slice().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_slice(exprs)\n    })\n}\n\ncomptime fn modify_tuple<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_tuple().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_tuple(exprs)\n    })\n}\n\ncomptime fn modify_unary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unary_op().map(|(op, rhs)| {\n        let rhs = rhs.modify(f);\n        new_unary_op(op, rhs)\n    })\n}\n\ncomptime fn modify_unsafe<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unsafe().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_unsafe(exprs)\n    })\n}\n\ncomptime fn modify_expressions<Env>(exprs: [Expr], f: fn[Env](Expr) -> Option<Expr>) -> [Expr] {\n    exprs.map(|expr| expr.modify(f))\n}\n\ncomptime fn new_array(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { [$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_assert(predicate: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert($predicate, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert($predicate) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assert_eq(lhs: Expr, rhs: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert_eq($lhs, $rhs, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert_eq($lhs, $rhs) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assign(lhs: Expr, rhs: Expr) -> Expr {\n    quote { $lhs = $rhs }.as_expr().unwrap()\n}\n\ncomptime fn new_binary_op(lhs: Expr, op: BinaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { ($lhs) $op ($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_block(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_cast(expr: Expr, typ: UnresolvedType) -> Expr {\n    quote { ($expr) as $typ }.as_expr().unwrap()\n}\n\ncomptime fn new_comptime(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { comptime { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_constructor(typ: UnresolvedType, fields: [(Quoted, Expr)]) -> Expr {\n    let fields = fields.map(|(name, value)| quote { $name: $value }).join(quote { , });\n    quote { $typ { $fields }}.as_expr().unwrap()\n}\n\ncomptime fn new_if(condition: Expr, consequence: Expr, alternative: Option<Expr>) -> Expr {\n    if alternative.is_some() {\n        let alternative = alternative.unwrap();\n        quote { if $condition { $consequence } else { $alternative }}.as_expr().unwrap()\n    } else {\n        quote { if $condition { $consequence } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_for(identifier: Quoted, array: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $array { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_for_range(identifier: Quoted, from: Expr, to: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $from .. $to { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_index(object: Expr, index: Expr) -> Expr {\n    quote { $object[$index] }.as_expr().unwrap()\n}\n\ncomptime fn new_lambda(\n    params: [(Expr, Option<UnresolvedType>)],\n    return_type: Option<UnresolvedType>,\n    body: Expr,\n) -> Expr {\n    let params = params\n        .map(|(name, typ)| {\n            if typ.is_some() {\n                let typ = typ.unwrap();\n                quote { $name: $typ }\n            } else {\n                quote { $name }\n            }\n        })\n        .join(quote { , });\n\n    if return_type.is_some() {\n        let return_type = return_type.unwrap();\n        quote { |$params| -> $return_type { $body } }.as_expr().unwrap()\n    } else {\n        quote { |$params| { $body } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_let(pattern: Expr, typ: Option<UnresolvedType>, expr: Expr) -> Expr {\n    if typ.is_some() {\n        let typ = typ.unwrap();\n        quote { let $pattern : $typ = $expr; }.as_expr().unwrap()\n    } else {\n        quote { let $pattern = $expr; }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_member_access(object: Expr, name: Quoted) -> Expr {\n    quote { $object.$name }.as_expr().unwrap()\n}\n\ncomptime fn new_function_call(function: Expr, arguments: [Expr]) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    quote { $function($arguments) }.as_expr().unwrap()\n}\n\ncomptime fn new_method_call(\n    object: Expr,\n    name: Quoted,\n    generics: [UnresolvedType],\n    arguments: [Expr],\n) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    if generics.len() == 0 {\n        quote { $object.$name($arguments) }.as_expr().unwrap()\n    } else {\n        let generics = generics.map(|generic| quote { $generic }).join(quote { , });\n        quote { $object.$name::<$generics>($arguments) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_repeated_element_array(expr: Expr, length: Expr) -> Expr {\n    quote { [$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_repeated_element_slice(expr: Expr, length: Expr) -> Expr {\n    quote { &[$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_slice(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { &[$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_tuple(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { ($exprs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unary_op(op: UnaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { $op($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unsafe(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { \n        // Safety: generated by macro\n        unsafe { $exprs }\n    }\n        .as_expr()\n        .unwrap()\n}\n\ncomptime fn join_expressions(exprs: [Expr], separator: Quoted) -> Quoted {\n    exprs.map(|expr| expr.quoted()).join(separator)\n}\n"
    },
    "253": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\nuse std::meta::derive;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct FunctionSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    pub inner: u32,\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "294": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\nuse std::meta::derive;\n\n// Aztec address\n#[derive(Deserialize, Eq, Packable, Serialize)]\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    /// Returns an address's `AddressPoint`, which can be used to create shared secrets with the owner\n    /// of the address. If the address is invalid (i.e. it is not a properly derived Aztec address), then this\n    /// returns `Option::none()`, and no shared secrets can be created.\n    pub fn to_address_point(self) -> Option<AddressPoint> {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // An invalid AztecAddress is one for which no y coordinate satisfies the curve equation, which we'll\n        // identify by proving that the square root of y_squared does not exist.\n        let mut y_opt = sqrt(y_squared);\n        if y_opt.is_none() {\n            Option::none()\n        } else {\n            let mut y = y_opt.unwrap();\n\n            // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n            // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n            // note: The field modulus is MAX_FIELD_VALUE + 1\n            if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n                y = (MAX_FIELD_VALUE + 1) - y;\n            }\n\n            Option::some(\n                AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } },\n            )\n        }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    // We use the AZTEC_ADDRESS_LENGTH constant to ensure that there is a match between the derived trait\n    // implementation and the constant.\n    let serialized: [Field; AZTEC_ADDRESS_LENGTH] = address.serialize();\n    let deserialized = AztecAddress::deserialize(serialized);\n    assert_eq(address, deserialized);\n}\n\n#[test]\nfn to_address_point_valid() {\n    // x = 8 where x^3 - 17 = 512 - 17 = 495, which is a residue in this field\n    let address = AztecAddress { inner: 8 };\n    let maybe_point = address.to_address_point();\n    assert(maybe_point.is_some());\n\n    let point = maybe_point.unwrap().inner;\n    // check that x is preserved\n    assert_eq(point.x, Field::from(8));\n\n    // check that the curve equation holds: y^2 == x^3 - 17\n    assert_eq(pow(point.y, 2), pow(point.x, 3) - 17);\n}\n\n#[test]\nunconstrained fn to_address_point_invalid() {\n    // x = 3 where x^3 - 17 = 27 - 17 = 10, which is a non-residue in this field\n    let address = AztecAddress { inner: 3 }; //\n    let maybe_point = address.to_address_point();\n    assert(maybe_point.is_none());\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n"
    },
    "307": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr",
      "source": "use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Deserialize, Empty, Hash, Serialize},\n};\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: Field,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl LeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: Field) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"
    },
    "309": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "// TODO: Expose other wrapped functions than debug (info, warn)\n// ['silent', 'fatal', 'error', 'warn', 'info', 'verbose', 'debug', 'trace']\n\npub global SILENT_LOG_LEVEL: u8 = 0;\npub global FATAL_LOG_LEVEL: u8 = 1;\npub global ERROR_LOG_LEVEL: u8 = 2;\npub global WARN_LOG_LEVEL: u8 = 3;\npub global INFO_LOG_LEVEL: u8 = 4;\npub global VERBOSE_LOG_LEVEL: u8 = 5;\npub global DEBUG_LOG_LEVEL: u8 = 6;\npub global TRACE_LOG_LEVEL: u8 = 7;\n\n/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Same as debug_log, but allows to customize the log level.\n/// Consider changing just to 'log'\npub fn debug_log_with_level<let N: u32>(log_level: u8, msg: str<N>) {\n    debug_log_format_with_level(log_level, msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_array_oracle_wrapper(DEBUG_LOG_LEVEL, msg, args) };\n}\n\n/// Same as debug_log_format, but allows to customize the log level.\n/// Consider changing just to 'log_format'\npub fn debug_log_format_with_level<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field; N],\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_array_oracle_wrapper(log_level, msg, args) };\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` slice.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole slice: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format_slice<let M: u32>(log_level: u8, msg: str<M>, args: [Field]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_slice_oracle_wrapper(log_level, msg, args) };\n}\n\n// We provide two versions of the debug log oracle: one that takes args as a slice and another one that takes args as an array.\n// We do this since conversion from array to slice generates overhead in public functions, since opcodes need to be emitted for the conversion.\n// By exposing the two flavors, we avoid conversions since the AVM is able to handle both arrays an slices in this oracle.\n\nunconstrained fn debug_log_slice_oracle_wrapper<let M: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field],\n) {\n    debug_log_slice_oracle(log_level, msg, args);\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_slice_oracle<let M: u32>(log_level: u8, msg: str<M>, args: [Field]) {}\n\nunconstrained fn debug_log_array_oracle_wrapper<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_array_oracle(log_level, msg, N, args);\n}\n\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_array_oracle<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    length: u32,\n    args: [Field; N],\n) {}\n"
    },
    "319": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "mod poseidon2_chunks;\n\nuse crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_log::{PrivateLog, PrivateLogData},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root_from_sibling_path,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    poseidon2::Poseidon2Sponge,\n    side_effect::{Counted, Scoped},\n    traits::{FromField, Hash, ToField},\n    utils::field::{field_from_bytes, field_from_bytes_32_trunc},\n};\n\npub use poseidon2_chunks::poseidon2_absorb_in_chunks_existing_sponge;\nuse poseidon2_chunks::poseidon2_absorb_in_chunks;\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(note_nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [note_nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_nonce_and_unique_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    let note_nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n    compute_unique_note_hash(note_nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        compute_nonce_and_unique_note_hash(siloed_note_hash, first_nullifier, note_index_in_tx)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: Scoped<Counted<NoteHash>>) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.innermost())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: Scoped<Counted<Nullifier>>) -> Field {\n    let value = nullifier.innermost().value;\n    // Q: shouldn't we be checking whether the _whole_ nullifier is empty?\n    // A: We don't have to. The init and inner circuits add contract address to non-empty nullifiers.\n    // So we know we should silo it if the contract address is not empty.\n    if nullifier.contract_address.is_zero() {\n        value // Return `value` instead of 0 because an already-siloed nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, value)\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<Counted<PrivateLogData>>) -> PrivateLog {\n    let log = private_log.innermost().log;\n    if private_log.contract_address.is_zero() {\n        log\n    } else {\n        let mut fields = log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, log.length)\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn compute_app_secret_key(\n    master_secret_key: EmbeddedCurveScalar,\n    app_address: AztecAddress,\n    app_secret_generator: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [master_secret_key.hi, master_secret_key.lo, app_address.to_field()],\n        app_secret_generator,\n    )\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let contract_address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    let recipient_bytes: [u8; 20] = recipient.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let rollup_version_id_bytes: [u8; 32] = rollup_version_id.to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n\n    let mut bytes: [u8; 148] = std::mem::zeroed();\n    for i in 0..32 {\n        bytes[i] = contract_address_bytes[i];\n        bytes[i + 32] = rollup_version_id_bytes[i];\n        // 64 - 84 are for recipient.\n        bytes[i + 84] = chain_id_bytes[i];\n        bytes[i + 116] = content_bytes[i];\n    }\n\n    for i in 0..20 {\n        bytes[64 + i] = recipient_bytes[i];\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: Scoped<L2ToL1Message>,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.inner.recipient,\n            msg.inner.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n/// Computes sha256 hash of 2 input fields.\n///\n/// @returns A truncated field (i.e., the first byte is always 0).\npub fn accumulate_sha256(v0: Field, v1: Field) -> Field {\n    // Concatenate two fields into 32 x 2 = 64 bytes\n    let v0_as_bytes: [u8; 32] = v0.to_be_bytes();\n    let v1_as_bytes: [u8; 32] = v1.to_be_bytes();\n    let hash_input_flattened = v0_as_bytes.concat(v1_as_bytes);\n\n    sha256_to_field(hash_input_flattened)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = [separator.to_field()].concat(inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n/// Computes a Poseidon2 hash over a dynamic-length subarray of the given input.\n/// Only the first `in_len` fields of `input` are absorbed; any remaining fields are ignored.\n/// The caller is responsible for ensuring that the input is padded with zeros if required.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_in_chunks(input, in_len);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_in_chunks(input, in_len);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n// This function is  unconstrained because it is intended to be used in unconstrained context only as\n// in constrained contexts it would be too inefficient.\npub unconstrained fn poseidon2_hash_with_separator_bounded_vec<let N: u32, T>(\n    inputs: BoundedVec<Field, N>,\n    separator: T,\n) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs.get(i));\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0x3b18c58c739716e76429634a61375c45b3b5cd470c22ab6d3e14cee23dd992);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0xaab2a5828156782b12a1dc6f336e2bc627eb1b9514b02d511f66296990c050);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        L2ToL1Message { recipient: EthAddress::from_field(1), content: 2 }.scope(\n            AztecAddress::from_field(3),\n        ),\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `yarn-project/stdlib/src/hash/hash.test.ts`\n    let hash_from_typescript = 0x0081edf209e087ad31b3fd24263698723d57190bd1d6e9fe056fc0c0a68ee661;\n\n    assert_eq(hash, hash_from_typescript);\n}\n\n#[test]\nunconstrained fn poseidon2_hash_with_separator_bounded_vec_matches_non_bounded_vec_version() {\n    let inputs = BoundedVec::<Field, 4>::from_array([1, 2, 3]);\n    let separator = 42;\n\n    // Hash using bounded vec version\n    let bounded_result = poseidon2_hash_with_separator_bounded_vec(inputs, separator);\n\n    // Hash using regular version\n    let regular_result = poseidon2_hash_with_separator([1, 2, 3], separator);\n\n    // Results should match\n    assert_eq(bounded_result, regular_result);\n}\n"
    },
    "328": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      "source": "use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_tree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n/// These values are precomputed and we run tests to ensure that they are correct.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_tree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_tree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_tree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_tree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_tree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_tree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_tree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_tree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_tree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_tree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_tree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_tree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"
    },
    "332": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use utils::derive_serialization_quotes;\n\npub mod utils;\n\n/// Generates the generic parameter declarations for a struct's trait implementation.\n///\n/// This function takes a struct type definition and generates the generic parameter declarations\n/// that go after the `impl` keyword. For example, given a struct with generics `N: u32` and `T`,\n/// it generates `<let N: u32, T>`.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate generic declarations for\n///\n/// # Returns\n/// A quoted code block containing the generic parameter declarations, or an empty quote if the struct\n/// has no generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// This function generates:\n/// ```\n/// <let N: u32, T>\n/// ```\ncomptime fn get_generics_declarations(s: TypeDefinition) -> Quoted {\n    let generics = s.generics();\n\n    if generics.len() > 0 {\n        let generics_declarations_items = generics\n            .map(|(name, maybe_integer_typ)| {\n                // The second item in the generics tuple is an Option of an integer type that is Some only if\n                // the generic is numeric.\n                if maybe_integer_typ.is_some() {\n                    // The generic is numeric, so we return a quote defined as e.g. \"let N: u32\"\n                    let integer_type = maybe_integer_typ.unwrap();\n                    quote {let $name: $integer_type}\n                } else {\n                    // The generic is not numeric, so we return a quote containing the name of the generic (e.g. \"T\")\n                    quote {$name}\n                }\n            })\n            .join(quote {,});\n        quote {<$generics_declarations_items>}\n    } else {\n        // The struct doesn't have any generics defined, so we just return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates the `where` clause for a trait implementation that constrains non-numeric generic type parameters.\n///\n/// This function takes a struct type definition and a trait name, and generates a `where` clause that\n/// requires all non-numeric generic type parameters to implement the specified trait.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the where clause for\n/// - `trait_name`: The name of the trait that non-numeric generic parameters must implement\n///\n/// # Returns\n/// A quoted code block containing the where clause, or an empty quote if the struct has no non-numeric\n/// generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// And trait name \"Serialize\", this function generates:\n/// ```\n/// where T: Serialize\n/// ```\ncomptime fn get_where_trait_clause(s: TypeDefinition, trait_name: Quoted) -> Quoted {\n    let generics = s.generics();\n\n    // The second item in the generics tuple is an Option of an integer type that is Some only if the generic is\n    // numeric.\n    let non_numeric_generics =\n        generics.filter(|(_, maybe_integer_typ)| maybe_integer_typ.is_none());\n\n    if non_numeric_generics.len() > 0 {\n        let non_numeric_generics_declarations =\n            non_numeric_generics.map(|(name, _)| quote {$name: $trait_name}).join(quote {,});\n        quote {where $non_numeric_generics_declarations}\n    } else {\n        // There are no non-numeric generics, so we return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates a `Serialize` trait implementation for a struct type.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A quoted code block containing the trait implementation\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Log<N> {\n///     fields: [Field; N],\n///     length: u32\n/// }\n/// ```\n///\n/// This function generates code equivalent to:\n/// ```\n/// impl<let N: u32> Serialize for Log<N> {\n///     let N: u32 = <[Field; N] as Serialize>::N + <u32 as Serialize>::N;\n///\n///     #[inline_always]\n///     fn serialize(self) -> [Field; Self::N] {\n///         let mut serialized_params = [0; _];\n///         let mut offset = 0;\n///\n///         let serialized_member = Serialize::serialize(self.fields);\n///         let serialized_member_len = <[Field; N] as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             serialized_params[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         let serialized_member = Serialize::serialize(self.length);\n///         let serialized_member_len = <u32 as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             serialized_params[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         serialized_params\n///     }\n/// }\n/// ```\npub comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n\n    // We care only about the name and type so we drop the last item of the tuple\n    let params = nested_struct.0.fields(nested_struct.1).map(|(name, typ, _)| (name, typ));\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Serialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_serialize_clause = get_where_trait_clause(s, quote {Serialize});\n\n    let (function_body, params_len_quote, serialized_params_name) =\n        derive_serialization_quotes(params, true);\n\n    quote {\n        impl$generics_declarations $crate::traits::Serialize for $typ\n            $where_serialize_clause\n        {\n            let N: u32 = $params_len_quote;\n\n            #[inline_always]\n            fn serialize(self) -> [Field; Self::N] {\n                $function_body\n\n                $serialized_params_name\n            }\n        }\n    }\n}\n\n/// Generates a `Deserialize` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Deserialize` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Deserialize for MyStruct {\n///     let N: u32 = <AztecAddress as Deserialize>::N + <Field as Deserialize>::N;\n///\n///     fn deserialize(serialized: [Field; Self::N]) -> Self {\n///         let mut offset = 0;\n///         let mut member_fields = [0; <AztecAddress as Deserialize>::N];\n///         for i in 0..<AztecAddress as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let x = <AztecAddress as Deserialize>::deserialize(member_fields);\n///         offset += <AztecAddress as Deserialize>::N;\n///\n///         let mut member_fields = [0; <Field as Deserialize>::N];\n///         for i in 0..<Field as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let y = <Field as Deserialize>::deserialize(member_fields);\n///         offset += <Field as Deserialize>::N;\n///\n///         Self { x, y }\n///     }\n/// }\n/// ```\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Deserialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_deserialize_clause = get_where_trait_clause(s, quote {Deserialize});\n\n    // The following will give us <type_of_struct_member_1 as Deserialize>::N + <type_of_struct_member_2 as Deserialize>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Deserialize>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly deserializing the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let function_body = if params.len() > 1 {\n        // This generates deserialization code for each struct member and concatenates them together.\n        let deserialization_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as Deserialize>::N];\n                    for i in 0..<$param_type as Deserialize>::N {\n                        member_fields[i] = serialized[i + offset];\n                    }\n                    let $param_name = <$param_type as Deserialize>::deserialize(member_fields);\n                    offset += <$param_type as Deserialize>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        // This will give us e.g. `a, b, c` for a struct with three fields named `a`, `b`, and `c`.\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n\n            $deserialization_of_struct_members\n\n            Self { $struct_members }\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Deserialize::deserialize(serialized) }\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Deserialize for $typ\n            $where_deserialize_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn deserialize(serialized: [Field; Self::N]) -> Self {\n                $function_body\n            }\n        }\n    }\n}\n\n/// Generates a `Packable` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Packable` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Packable for MyStruct {\n///     let N: u32 = 2;\n///\n///     fn pack(self) -> [Field; 2] {\n///         let mut result: [Field; 2] = [0_Field; 2];\n///         let mut offset: u32 = 0_u32;\n///         let packed_member: [Field; 1] = self.x.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         let packed_member: [Field; 1] = self.y.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         result\n///     }\n///\n///     fn unpack(packed: [Field; 2]) -> Self {\n///         let mut offset: u32 = 0_u32;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<AztecAddress as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let x: AztecAddress = <AztecAddress as Packable>::unpack(member_fields);\n///         offset = offset + <AztecAddress as Packable>::N;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<Field as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let y: Field = <Field as Packable>::unpack(member_fields);\n///         offset = offset + <Field as Packable>::N;\n///         Self { x: x, y: y }\n///     }\n/// }\n/// ```\npub comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Packable` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_packable_clause = get_where_trait_clause(s, quote {Packable});\n\n    // The following will give us <type_of_struct_member_1 as Packable>::N + <type_of_struct_member_2 as Packable>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Packable>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly returning the packed member,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let pack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate packing code that:\n        // 1. Packs each member\n        // 2. Copies the packed fields into the result array at the correct offset\n        // 3. Updates the offset for the next member\n        let packing_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let packed_member = $crate::traits::Packable::pack(self.$param_name);\n                    let packed_member_len = <$param_type as $crate::traits::Packable>::N;\n                    for i in 0..packed_member_len {\n                        result[i + offset] = packed_member[i];\n                    }\n                    offset += packed_member_len;\n                }\n            })\n            .join(quote {});\n\n        quote {\n            let mut result = [0; Self::N];\n            let mut offset = 0;\n\n            $packing_of_struct_members\n\n            result\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            $crate::traits::Packable::pack(self.$param_name)\n        }\n    };\n\n    // For structs containing a single member, we can enhance performance by directly unpacking the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let unpack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate unpacking code that:\n        // 1. Unpacks each member\n        // 2. Copies packed fields into member array at correct offset\n        // 3. Updates offset for next member\n        let unpacking_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as $crate::traits::Packable>::N];\n                    for i in 0..<$param_type as $crate::traits::Packable>::N {\n                        member_fields[i] = packed[i + offset];\n                    }\n                    let $param_name = <$param_type as $crate::traits::Packable>::unpack(member_fields);\n                    offset += <$param_type as $crate::traits::Packable>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n            $unpacking_of_struct_members\n            Self { $struct_members }\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Packable::unpack(packed) }\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Packable for $typ\n            $where_packable_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn pack(self) -> [Field; Self::N] {\n                $pack_function_body\n            }\n\n            #[inline_always]\n            fn unpack(packed: [Field; Self::N]) -> Self {\n                $unpack_function_body\n            }\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Packable, Serialize};\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct Smol {\n        a: Field,\n        b: Field,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct HasArray {\n        a: [Field; 2],\n        b: bool,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct Fancier {\n        a: Smol,\n        b: [Field; 2],\n        c: [u8; 3],\n        d: str<16>,\n    }\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct HasArrayWithGenerics<T, let N: u32> {\n        pub fields: [T; N],\n        pub length: u32,\n    }\n\n    #[test]\n    fn serde_on_smol() {\n        let smol = Smol { a: 1, b: 2 };\n        let serialized = smol.serialize();\n        assert(serialized == [1, 2], serialized);\n        let deserialized = Smol::deserialize(serialized);\n        assert(deserialized == smol);\n\n        // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n        let packed = smol.pack();\n        assert_eq(packed, serialized, \"Packed does not match serialized\");\n    }\n\n    #[test]\n    fn serde_on_has_array() {\n        let has_array = HasArray { a: [1, 2], b: true };\n        let serialized = has_array.serialize();\n        assert(serialized == [1, 2, 1], serialized);\n        let deserialized = HasArray::deserialize(serialized);\n        assert(deserialized == has_array);\n    }\n\n    #[test]\n    fn serde_on_fancier() {\n        let fancier =\n            Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n        let serialized = fancier.serialize();\n        assert(\n            serialized\n                == [\n                    1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                    0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n                ],\n            serialized,\n        );\n        let deserialized = Fancier::deserialize(serialized);\n        assert(deserialized == fancier);\n    }\n\n    #[test]\n    fn serde_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let serialized = struct_with_array_of_generics.serialize();\n        assert(serialized == [1, 2, 3, 3], serialized);\n        let deserialized = HasArrayWithGenerics::deserialize(serialized);\n        assert(deserialized == struct_with_array_of_generics);\n    }\n\n    #[test]\n    fn packable_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let packed = struct_with_array_of_generics.pack();\n        assert(packed == [1, 2, 3, 3], packed);\n\n        let unpacked = HasArrayWithGenerics::unpack(packed);\n        assert(unpacked == struct_with_array_of_generics);\n    }\n\n}\n"
    },
    "333": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/meta/utils.nr",
      "source": "/// Generates serialization code for a list of parameters and the total length of the serialized array\n///\n/// # Parameters\n/// - `params`: A list of (name, type) tuples to serialize\n/// - `use_self_prefix`: If true, parameters are accessed as `self.$param_name` (for struct members).\n///                      If false, parameters are accessed directly as `$param_name` (for function parameters).\n///\n/// # Returns\n/// A tuple containing:\n/// - Quoted code that serializes the parameters into an array named `serialized_params`\n/// - Quoted code that evaluates to the total length of the serialized array\n/// - Quoted code containing the name of the serialized array\npub comptime fn derive_serialization_quotes(\n    params: [(Quoted, Type)],\n    use_self_prefix: bool,\n) -> (Quoted, Quoted, Quoted) {\n    let prefix_quote = if use_self_prefix {\n        quote { self. }\n    } else {\n        quote {}\n    };\n\n    let params_len_quote = get_params_len_quote(params);\n    let serialized_params_name = quote { serialized_params };\n\n    let body = if params.len() == 0 {\n        quote {\n            let $serialized_params_name: [Field; 0] = [];\n        }\n    } else if params.len() == 1 {\n        // When we have only a single parameter on the input, we can enhance performance by directly returning\n        // the serialized member, bypassing the need for loop-based array construction. While this optimization yields\n        // significant benefits in Brillig where the loops are expected to not be optimized, it is not relevant in ACIR\n        // where the loops are expected to be optimized away.\n\n        let param_name = params[0].0;\n        quote {\n            let $serialized_params_name = $crate::traits::Serialize::serialize($prefix_quote$param_name);\n        }\n    } else {\n        // For multiple struct members, generate serialization code that:\n        // 1. Serializes each member\n        // 2. Copies the serialized fields into the serialize array at the correct offset\n        // 3. Updates the offset for the next member\n        let serialization_of_struct_members = params\n            .map(|(param_name, param_type): (Quoted, Type)| {\n                quote {\n                let serialized_member = $crate::traits::Serialize::serialize($prefix_quote$param_name);\n                let serialized_member_len = <$param_type as $crate::traits::Serialize>::N;\n                for i in 0..serialized_member_len {\n                    $serialized_params_name[i + offset] = serialized_member[i];\n                }\n                offset += serialized_member_len;\n            }\n            })\n            .join(quote {});\n\n        quote {\n            let mut $serialized_params_name = [0; $params_len_quote];\n            let mut offset = 0;\n\n            $serialization_of_struct_members\n        }\n    };\n\n    (body, params_len_quote, serialized_params_name)\n}\n\n/// Generates a quoted expression that computes the total serialized length of function parameters.\n///\n/// # Parameters\n/// * `params` - An array of tuples where each tuple contains a quoted parameter name and its Type. The type needs\n///              to implement the Serialize trait.\n///\n/// # Returns\n/// A quoted expression that evaluates to:\n/// * `0` if there are no parameters\n/// * `(<type1 as Serialize>::N + <type2 as Serialize>::N + ...)` for one or more parameters\npub comptime fn get_params_len_quote(params: [(Quoted, Type)]) -> Quoted {\n    if params.len() == 0 {\n        quote { 0 }\n    } else {\n        let params_quote_without_parentheses = params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n                    <$param_type as $crate::traits::Serialize>::N\n                }\n            })\n            .join(quote {+});\n        quote { ($params_quote_without_parentheses) }\n    }\n}\n"
    },
    "334": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl Serialize for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn serialize(self: Self) -> [Field; Self::N] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn deserialize(serialized: [Field; Self::N]) -> Self {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] != 0 }\n    }\n}\n\n// TODO(#11356): use compact representation here.\nimpl Packable for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn pack(self) -> [Field; Self::N] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; Self::N]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "335": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\nuse crate::traits::{Deserialize, Serialize};\nuse std::meta::derive;\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "342": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::{default::Default, meta::derive};\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nmod test {\n    use crate::{\n        point::POINT_LENGTH,\n        public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n        traits::{Deserialize, Serialize},\n    };\n    use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\n    #[test]\n    unconstrained fn compute_public_keys_hash() {\n        let keys = PublicKeys {\n            npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n            ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n            ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n            tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n        };\n\n        let actual = keys.hash();\n        let expected_public_keys_hash =\n            0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n        assert(actual.to_field() == expected_public_keys_hash);\n    }\n\n    #[test]\n    unconstrained fn compute_default_hash() {\n        let keys = PublicKeys::default();\n\n        let actual = keys.hash();\n        let test_data_default_hash =\n            0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n        assert(actual.to_field() == test_data_default_hash);\n    }\n\n    #[test]\n    unconstrained fn serde() {\n        let keys = PublicKeys {\n            npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n            ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n            ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n            tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n        };\n\n        // We use the PUBLIC_KEYS_LENGTH constant to ensure that there is a match between the derived trait\n        let serialized: [Field; POINT_LENGTH * 4] = keys.serialize();\n        let deserialized = PublicKeys::deserialize(serialized);\n\n        assert_eq(keys, deserialized);\n    }\n}\n"
    },
    "347": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "363": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty: Eq {\n    fn empty() -> Self;\n\n    fn is_empty(self) -> bool {\n        self.eq(Self::empty())\n    }\n\n    // Requires this Noir fix: https://github.com/noir-lang/noir/issues/9002\n    // fn assert_not_empty<let U: u32>(self, msg: str<U>) { // This msg version was failing with weird compiler errors.\n    //     // We provide a default impl but it's likely inefficient.\n    //     // The reason we include this function is because there's a lot of\n    //     // opportunity for optimisation on a per-struct basis.\n    //     // You only need to show one element is not empty to know that the whole thing\n    //     // is not empty.\n    //     // If you know an element of your struct which should always be nonempty,\n    //     // you can write an impl that solely checks that that element is nonempty.\n    //     assert(!self.is_empty(), msg);\n    // }\n\n    // This default impl is overwritten by types like arrays, because there's a much\n    // more efficient approach.\n    fn assert_empty<let S: u32>(self, msg: str<S>) {\n        assert(self.is_empty(), msg);\n    }\n}\n\nimpl Empty for Field {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u16 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\n\nimpl<T> Empty for [T]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty()]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\nimpl<A, B> Empty for (A, B)\nwhere\n    A: Empty,\n    B: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        (A::empty(), B::empty())\n    }\n}\n\nimpl<T> Empty for Option<T>\nwhere\n    T: Eq,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\n// pub fn is_empty<T>(item: T) -> bool\n// where\n//     T: Empty,\n// {\n//     item.eq(T::empty())\n// }\n\n// pub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\n// where\n//     T: Empty,\n// {\n//     array.all(|elem| is_empty(elem))\n// }\n\n// pub fn assert_empty<T>(item: T) -> ()\n// where\n//     T: Empty,\n// {\n//     assert(item.eq(T::empty()))\n// }\n\n// pub fn assert_empty_array<T, let N: u32>(array: [T; N]) -> ()\n// where\n//     T: Empty,\n// {\n//     // A cheaper option than `is_empty_array` for if you don't need to gracefully\n//     // handle a bool result.\n//     // Avoids the `&` operator of `is_empty_array`'s `.all()` call.\n//     for i in 0..N {\n//         assert(is_empty(array[i]));\n//     }\n// }\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u16 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value != 0\n    }\n}\nimpl FromField for u1 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u16 {\n    fn from_field(value: Field) -> Self {\n        value as u16\n    }\n}\nimpl FromField for u32 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Associated Constants\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize for str<N> {\n///     let N: u32 = N;\n///\n///     fn serialize(self) -> [Field; Self::N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; Self::N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize {\n    let N: u32;\n\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let M: u32> Serialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; Self::N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n/// Implementation of Deserialize for BoundedVec.\n///\n/// This implementation deserializes a BoundedVec from an array of Fields. The array contains:\n/// 1. The serialized items, each taking up T::N Fields\n/// 2. The length of the BoundedVec as the last Field\n///\n/// # Type Parameters\n/// * `T` - The type of items stored in the BoundedVec, must implement Deserialize\n/// * `M` - The maximum length of the BoundedVec\n///\n/// # Fields Array Layout\n/// [item1_field1, item1_field2, ..., item2_field1, item2_field2, ..., length]\n/// Where:\n/// - itemN_fieldM: The M-th Field of the N-th item (T::N Fields per item)\n/// - length: The number of items in the BoundedVec (1 Field)\n///\n/// Total length N = T::N * M + 1, where:\n/// - T::N is the number of Fields needed to deserialize one item\n/// - M is the maximum length of the BoundedVec\n/// - +1 is for storing the length\n///\n/// # Note\n/// Not deriving this because it's not supported to call derive_deserialize on a \"remote\" struct (and it will never\n/// be supported).\nimpl<T, let M: u32> Deserialize for BoundedVec<T, M>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut new_bounded_vec: BoundedVec<T, M> = BoundedVec::new();\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        let len = fields[<T as Deserialize>::N * M] as u32;\n\n        for i in 0..len {\n            let mut nested_fields = [0; <T as Deserialize>::N];\n            for j in 0..<T as Deserialize>::N {\n                nested_fields[j] = fields[i * <T as Deserialize>::N + j];\n            }\n\n            let item = T::deserialize(nested_fields);\n            new_bounded_vec.push(item);\n        }\n\n        new_bounded_vec\n    }\n}\n\n// This may cause issues if used as program input, because noir disallows empty arrays for program input.\n// I think this is okay because I don't foresee a unit type being used as input. But leaving this comment as a hint\n// if someone does run into this in the future.\nimpl Deserialize for () {\n    let N: u32 = 0;\n\n    fn deserialize(_fields: [Field; Self::N]) -> Self {\n        ()\n    }\n}\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl<T, let M: u32> Serialize for BoundedVec<T, M>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M + 1; // +1 for the length of the BoundedVec\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut fields = [0; Self::N];\n\n        let storage = self.storage();\n\n        for i in 0..M {\n            let serialized_item = storage[i].serialize();\n\n            for j in 0..<T as Serialize>::N {\n                fields[i * <T as Serialize>::N + j] = serialized_item[j];\n            }\n        }\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        fields[<T as Serialize>::N * M] = self.len() as Field;\n\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Associated Constants\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let M: u32> Deserialize for str<M> {\n///     let N: u32 = M;\n///\n///     #[inline_always]\n///     fn deserialize(fields: [Field; Self::N]) -> Self {\n///         str::<Self::N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize {\n    let N: u32;\n\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let M: u32> Deserialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        str::<Self::N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Associated Constants\n/// * `N` - The length of the Field array, known at compile time\n#[derive_via(derive_packable)]\npub trait Packable {\n    let N: u32;\n\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n\n#[test]\nunconstrained fn bounded_vec_serialization() {\n    // Test empty BoundedVec\n    let empty_vec: BoundedVec<Field, 3> = BoundedVec::from_array([]);\n    let serialized = empty_vec.serialize();\n    let deserialized = BoundedVec::<Field, 3>::deserialize(serialized);\n    assert_eq(empty_vec, deserialized);\n    assert_eq(deserialized.len(), 0);\n\n    // Test partially filled BoundedVec\n    let partial_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2]]);\n    let serialized = partial_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(partial_vec, deserialized);\n    assert_eq(deserialized.len(), 1);\n    assert_eq(deserialized.get(0), [1, 2]);\n\n    // Test full BoundedVec\n    let full_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2], [3, 4], [5, 6]]);\n    let serialized = full_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(full_vec, deserialized);\n    assert_eq(deserialized.len(), 3);\n    assert_eq(deserialized.get(0), [1, 2]);\n    assert_eq(deserialized.get(1), [3, 4]);\n    assert_eq(deserialized.get(2), [5, 6]);\n}\n"
    },
    "365": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable for bool {\n    let N: u32 = BOOL_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> bool {\n        (fields[0] as u1) != 0\n    }\n}\n\nimpl Packable for u8 {\n    let N: u32 = U8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable for u16 {\n    let N: u32 = U16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable for u32 {\n    let N: u32 = U32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable for u64 {\n    let N: u32 = U64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable for u128 {\n    let N: u32 = U128_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable for Field {\n    let N: u32 = FIELD_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable for i8 {\n    let N: u32 = I8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Packable for i16 {\n    let N: u32 = I16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Packable for i32 {\n    let N: u32 = I32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Packable for i64 {\n    let N: u32 = I64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Packable for [T; M]\nwhere\n    T: Packable,\n{\n    let N: u32 = M * <T as Packable>::N;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized = self[i].pack();\n            for j in 0..<T as Packable>::N {\n                result[i * <T as Packable>::N + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Packable>::N, M>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "366": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal U1_SERIALIZED_LEN: u32 = 1;\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> bool {\n        fields[0] != 0\n    }\n}\n\nimpl Serialize for u1 {\n    let N: u32 = U1_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u1 {\n    let N: u32 = U1_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u1\n    }\n}\n\nimpl Serialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self]\n    }\n}\n\nimpl Deserialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n}\n\nimpl Deserialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Serialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n}\n\nimpl Deserialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Serialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n}\n\nimpl Deserialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Serialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n}\n\nimpl Deserialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Serialize for [T; M]\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M;\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; _] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized_t = self[i].serialize();\n            let T_N = serialized_t.len();\n            for j in 0..T_N {\n                result[i * T_N + j] = serialized_t[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let M: u32> Deserialize for [T; M]\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Deserialize>::N, M>(Deserialize::deserialize, result)\n    }\n}\n\nimpl<T> Serialize for Option<T>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N + 1;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n\n        result[0] = if self.is_some() { 1 } else { 0 };\n\n        let value_serialized = self.unwrap_unchecked().serialize();\n        for i in 0..<T as Serialize>::N {\n            result[1 + i] = value_serialized[i];\n        }\n\n        result\n    }\n}\n\nimpl<T> Deserialize for Option<T>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        if fields[0] == 1 {\n            let mut value_fields = [0; <T as Deserialize>::N];\n            for i in 0..<T as Deserialize>::N {\n                value_fields[i] = fields[1 + i];\n            }\n\n            Option::some(T::deserialize(value_fields))\n        } else {\n            Option::none()\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Serialize};\n\n    #[test]\n    fn u16_serialization() {\n        let a: u16 = 10;\n        assert_eq(a, u16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i8_serialization() {\n        let a: i8 = -10;\n        assert_eq(a, i8::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i16_serialization() {\n        let a: i16 = -10;\n        assert_eq(a, i16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i32_serialization() {\n        let a: i32 = -10;\n        assert_eq(a, i32::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i64_serialization() {\n        let a: i64 = -10;\n        assert_eq(a, i64::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn option_field_serialization() {\n        let opt_some = Option::some(5);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n\n    #[test]\n    fn array_serialization() {\n        let array = [1, 2, 3, 4];\n\n        let serialized: [Field; 4] = array.serialize();\n        let deserialized: [Field; 4] = Deserialize::deserialize(serialized);\n        assert_eq(deserialized, array);\n    }\n\n    #[test]\n    fn nested_array_serialization() {\n        let nested_array = [[1, 2, 3, 4], [5, 6, 7, 8]];\n\n        let serialized: [Field; 8] = nested_array.serialize();\n        let deserialized: [[Field; 4]; 2] = Deserialize::deserialize(serialized);\n\n        assert_eq(deserialized, nested_array);\n    }\n\n    #[test]\n    fn option_array_serialization() {\n        let opt_some = Option::some([2, 5]);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n}\n"
    },
    "384": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "global KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\npub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO: This currently only exists to aid point compression in compress_to_blob_commitment().\n// Once compression is part of BigCurve it can either be removed or optimized to be used elsewhere.\npub fn byte_to_bits_be(byte: u8) -> [u1; 8] {\n    let mut mut_byte = byte;\n    let mut bits: [u1; 8] = [0; 8];\n    for i in 0..8 {\n        bits[7 - i] = (mut_byte & 1) as u1;\n        mut_byte >>= 1;\n    }\n    bits\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n/// Returns Option::some(sqrt) if there is a square root, and Option::none() if there isn't.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\nunconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n\n#[test]\nunconstrained fn sqrt_valid_test() {\n    let x = 16; // examples: 16, 9, 25, 81\n    let result = sqrt(x);\n    assert(result.is_some());\n    assert_eq(result.unwrap() * result.unwrap(), x);\n}\n\n#[test]\nunconstrained fn sqrt_invalid_test() {\n    let x = KNOWN_NON_RESIDUE; // has no square root in the field\n    let result = sqrt(x);\n    assert(result.is_none());\n}\n"
    },
    "388": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_u64(&mut self) -> u64 {\n        self.read() as u64\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() != 0\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert_eq(self.offset, self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "444": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/uint-note/src/uint_note.nr",
      "source": "use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    history::nullifier_inclusion::ProveNullifierInclusion,\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    messages::logs::note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{\n            GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER,\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT, PRIVATE_LOG_SIZE_IN_FIELDS,\n        },\n        hash::{compute_siloed_nullifier, poseidon2_hash_with_separator},\n        traits::{Deserialize, FromField, Hash, Packable, Serialize, ToField},\n    },\n};\n\n// UintNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the amount).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n/// A private note representing a numeric value associated to an account (e.g. a token balance).\n#[derive(Deserialize, Eq, Serialize, Packable)]\n#[custom_note]\npub struct UintNote {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintPartialNotePrivateContent, and\n    //   b) have the public field at the end\n    // Correct ordering is checked by the tests in this module.\n\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The number stored in the note.\n    value: u128,\n}\n\nimpl NoteHash for UintNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because UintNote has just one variant (where the value is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let private_content =\n            UintPartialNotePrivateContent { owner: self.owner, randomness: self.randomness };\n        let partial_note = PartialUintNote {\n            commitment: private_content.compute_partial_commitment(storage_slot),\n        };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.value)\n    }\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullification: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullification, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(\n        self,\n        note_hash_for_nullification: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullification, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: u128, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness }\n    }\n\n    pub fn get_value(self) -> u128 {\n        self.value\n    }\n\n    pub fn get_owner(self) -> AztecAddress {\n        self.owner\n    }\n\n    /// Creates a partial note that will hide the owner and storage slot but not the value, since the note will be later\n    /// completed in public. This is a powerful technique for scenarios in which the value cannot be known in private\n    /// (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// This function inserts a partial note validity commitment into the nullifier tree to be later on able to verify\n    /// that the partial note and completer are legitimate. See function docs of `compute_validity_commitment` for more\n    /// details.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` so that they can discover the\n    /// note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        completer: AztecAddress,\n    ) -> PartialUintNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = UintPartialNotePrivateContent { owner, randomness }\n            .compute_partial_commitment(storage_slot);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content =\n            UintPartialNotePrivateLogContent { owner, randomness, public_log_tag: commitment };\n\n        let encrypted_log = note::compute_partial_note_private_content_log(\n            private_log_content,\n            storage_slot,\n            recipient,\n        );\n        // Regardless of the original content size, the log is padded with random bytes up to\n        // `PRIVATE_LOG_SIZE_IN_FIELDS` to prevent leaking information about the actual size.\n        let length = encrypted_log.len();\n        context.emit_private_log(encrypted_log, length);\n\n        let partial_note = PartialUintNote { commitment };\n\n        // Now we compute the validity commitment and push it to the nullifier tree. It can be safely pushed to\n        // the nullifier tree since it uses its own separator, making collisions with actual note nullifiers\n        // practically impossible.\n        let validity_commitment = partial_note.compute_validity_commitment(completer);\n        context.push_nullifier(validity_commitment);\n\n        partial_note\n    }\n}\n\n/// The private content of a partial UintNote, i.e. the fields that will remain private. All other note fields will be\n/// made public.\n#[derive(Packable)]\nstruct UintPartialNotePrivateContent {\n    // The ordering of these fields is important given that it must match that of UintNote.\n    // Correct ordering is checked by the tests in this module.\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl UintPartialNotePrivateContent {\n    fn compute_partial_commitment(self, storage_slot: Field) -> Field {\n        // Here we commit to all private values, including the storage slot.\n        poseidon2_hash_with_separator(\n            self.pack().concat([storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\n#[derive(Packable)]\nstruct UintPartialNotePrivateLogContent {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintNote, and\n    //   b) have the public log tag at the beginning\n    // Correct ordering is checked by the tests in this module.\n    public_log_tag: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteType for UintPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        UintNote::get_id()\n    }\n}\n\n/// A partial instance of a UintNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the value field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the value to the public), resulting in a UintNote that can be used like any other one (except\n/// of course that its value is known).\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct PartialUintNote {\n    commitment: Field,\n}\n\nglobal NOTE_COMPLETION_LOG_LENGTH: u32 = 2;\n\nimpl PartialUintNote {\n    /// Completes the partial note, creating a new note that can be used like any other UintNote.\n    pub fn complete(self, context: &mut PublicContext, completer: AztecAddress, value: u128) {\n        // A note with a value of zero is valid, but we cannot currently complete a partial note with such a value\n        // because this will result in the completion log having its last field set to 0. Public logs currently do not\n        // track their length, and so trailing zeros are simply trimmed. This results in the completion log missing its\n        // last field (the value), and note discovery failing.\n        // TODO(#11636): remove this\n        assert(value != 0, \"Cannot complete a PartialUintNote with a value of 0\");\n\n        // We verify that the partial note we're completing is valid (i.e. completer is correct, it uses the correct\n        // state variable's storage slot, and it is internally consistent).\n        let validity_commitment = self.compute_validity_commitment(completer);\n        assert(\n            context.nullifier_exists(validity_commitment, context.this_address()),\n            \"Invalid partial note or completer\",\n        );\n\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the value). The contract will later find it by searching\n        //  for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(value));\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    /// Completes the partial note, creating a new note that can be used like any other UintNote. Same as `complete`\n    /// function but works from private context.\n    pub fn complete_from_private(\n        self,\n        context: &mut PrivateContext,\n        completer: AztecAddress,\n        value: u128,\n    ) {\n        // We verify that the partial note we're completing is valid (i.e. completer is correct, it uses the correct\n        // state variable's storage slot, and it is internally consistent).\n        let validity_commitment = self.compute_validity_commitment(completer);\n        // `prove_nullifier_inclusion` function expects the nullifier to be siloed (hashed with the address of\n        // the contract that emitted the nullifier) as it checks the value directly against the nullifier tree and all\n        // the nullifiers in the tree are siloed by the protocol.\n        let siloed_validity_commitment =\n            compute_siloed_nullifier(context.this_address(), validity_commitment);\n        context.get_anchor_block_header().prove_nullifier_inclusion(siloed_validity_commitment);\n\n        // We need to do two things:\n        //  - emit an unencrypted log containing the public fields (the value) via the private log channel. The\n        //  contract will later find it by searching for the expected tag (which is simply the partial note\n        //  commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_private_log(\n            self.compute_note_completion_log_padded_for_private_log(value),\n            NOTE_COMPLETION_LOG_LENGTH,\n        );\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    /// Computes a validity commitment for this partial note. The commitment cryptographically binds the note's private\n    /// data with the designated completer address. When the note is later completed in public execution, we can load\n    /// this commitment from the nullifier tree and verify that both the partial note (e.g. that the storage slot\n    /// corresponds to the correct owner, and that we're using the correct state variable) and completer are\n    /// legitimate.\n    pub fn compute_validity_commitment(self, completer: AztecAddress) -> Field {\n        poseidon2_hash_with_separator(\n            [self.commitment, completer.to_field()],\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT,\n        )\n    }\n\n    fn compute_note_completion_log(self, value: u128) -> [Field; NOTE_COMPLETION_LOG_LENGTH] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, value.to_field()]\n    }\n\n    fn compute_note_completion_log_padded_for_private_log(\n        self,\n        value: u128,\n    ) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS] {\n        let note_completion_log = self.compute_note_completion_log(value);\n        let padding = [0; PRIVATE_LOG_SIZE_IN_FIELDS - NOTE_COMPLETION_LOG_LENGTH];\n        note_completion_log.concat(padding)\n    }\n\n    fn compute_complete_note_hash(self, value: u128) -> Field {\n        // Here we finalize the note hash by including the (public) value into the partial note commitment. Note that we\n        // use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator(\n            [self.commitment, value.to_field()],\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\nimpl ToField for PartialUintNote {\n    fn to_field(self) -> Field {\n        self.commitment\n    }\n}\n\nimpl FromField for PartialUintNote {\n    fn from_field(field: Field) -> Self {\n        Self { commitment: field }\n    }\n}\n\nmod test {\n    use super::{\n        PartialUintNote, UintNote, UintPartialNotePrivateContent, UintPartialNotePrivateLogContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{address::AztecAddress, traits::{Deserialize, FromField, Packable}},\n        utils::array::subarray,\n    };\n\n    global value: u128 = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a UintNote has the same note hash as a PartialUintNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n\n        let note = UintNote { value, randomness, owner };\n        let note_hash = note.compute_note_hash(storage_slot);\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n\n        let partial_note = PartialUintNote {\n            commitment: partial_note_private_content.compute_partial_commitment(storage_slot),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(value);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular UintNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular UintNote.\n\n        let note = UintNote { value, randomness, owner };\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n        let commitment = partial_note_private_content.compute_partial_commitment(storage_slot);\n\n        let private_log_content =\n            UintPartialNotePrivateLogContent { owner, randomness, public_log_tag: commitment };\n        // The following is a misuse of the `deserialize` function, but this is just a test and it's better than\n        // letting devs manually construct it when they shouldn't be able to.\n        let partial_note = PartialUintNote::deserialize([commitment]);\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(value)[0],\n        );\n\n        // Then we extract all fields except the first of both logs (i.e. the public log tag), and combine them to\n        // produce the note's packed representation. This requires that the members of the intermediate structs are in\n        // the same order as in UintNote.\n        let private_log_without_public_tag: [_; 2] = subarray(private_log_content.pack(), 1);\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(value), 1);\n\n        assert_eq(private_log_without_public_tag.concat(public_log_without_tag), note.pack());\n    }\n}\n"
    },
    "46": {
      "path": "std/slice.nr",
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice with its index, returning a\n    // new slice containing the mapped elements.\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U] {\n        let mut ret = &[];\n        let mut index = 0;\n        for elem in self {\n            ret = ret.push_back(f(index, elem));\n            index += 1;\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for elem in self {\n            f(elem);\n        }\n    }\n\n    // Apply a function to each element of the slice with its index\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        let mut index = 0;\n        for elem in self {\n            f(index, elem);\n            index += 1;\n        }\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq(&[].map(|x| x + 1), &[]);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq(&[].mapi(|i, x| i * x + 1), &[]);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_each(|_x| assert(false));\n        assert(empty_slice == &[]);\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_eachi(|_i, _x| assert(false));\n        assert(empty_slice == &[]);\n    }\n\n    #[test]\n    fn map_example() {\n        let a = &[1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, &[2, 4, 6]);\n        assert_eq(a, &[1, 2, 3]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = &[1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, &[2, 5, 8]);\n        assert_eq(a, &[1, 2, 3]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_each(|a| { *b_ref = b_ref.push_back(a * 2); });\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { *b_ref = b_ref.push_back(i + a * 2); });\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n    #[test]\n    fn len_empty() {\n        let empty: [Field] = &[];\n        assert_eq(empty.len(), 0);\n    }\n\n    #[test]\n    fn len_single() {\n        assert_eq(&[42].len(), 1);\n    }\n\n    #[test]\n    fn len_multiple() {\n        assert_eq(&[1, 2, 3, 4, 5].len(), 5);\n    }\n\n    #[test]\n    fn push_back_empty() {\n        let empty: [Field] = &[];\n        let result = empty.push_back(42);\n        assert_eq(result.len(), 1);\n        assert_eq(result[0], 42);\n    }\n\n    #[test]\n    fn push_back_non_empty() {\n        let slice = &[1, 2, 3];\n        let result = slice.push_back(4);\n        assert_eq(result.len(), 4);\n        assert_eq(result, &[1, 2, 3, 4]);\n    }\n\n    #[test]\n    fn push_front_empty() {\n        let empty = &[];\n        let result = empty.push_front(42);\n        assert_eq(result.len(), 1);\n        assert_eq(result[0], 42);\n    }\n\n    #[test]\n    fn push_front_non_empty() {\n        let slice = &[1, 2, 3];\n        let result = slice.push_front(0);\n        assert_eq(result.len(), 4);\n        assert_eq(result, &[0, 1, 2, 3]);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds\")]\n    fn pop_back_empty() {\n        let slice: [Field] = &[];\n        let (_, _) = slice.pop_back();\n    }\n\n    #[test]\n    fn pop_back_one() {\n        let slice = &[42];\n        let (result, elem) = slice.pop_back();\n        assert_eq(result.len(), 0);\n        assert_eq(elem, 42);\n    }\n\n    #[test]\n    fn pop_back_multiple() {\n        let slice = &[1, 2, 3];\n        let (result, elem) = slice.pop_back();\n        assert_eq(result.len(), 2);\n        assert_eq(result, &[1, 2]);\n        assert_eq(elem, 3);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds\")]\n    fn pop_front_empty() {\n        let slice: [Field] = &[];\n        let (_, _) = slice.pop_front();\n    }\n\n    #[test]\n    fn pop_front_one() {\n        let slice = &[42];\n        let (elem, result) = slice.pop_front();\n        assert_eq(result.len(), 0);\n        assert_eq(elem, 42);\n    }\n\n    #[test]\n    fn pop_front_multiple() {\n        let slice = &[1, 2, 3];\n        let (elem, result) = slice.pop_front();\n        assert_eq(result.len(), 2);\n        assert_eq(result, &[2, 3]);\n        assert_eq(elem, 1);\n    }\n\n    #[test]\n    fn insert_beginning() {\n        let slice = &[1, 2, 3];\n        let result = slice.insert(0, 0);\n        assert_eq(result.len(), 4);\n        assert_eq(result, &[0, 1, 2, 3]);\n    }\n\n    #[test]\n    fn insert_middle() {\n        let slice = &[1, 2, 3];\n        let result = slice.insert(1, 99);\n        assert_eq(result.len(), 4);\n        assert_eq(result, &[1, 99, 2, 3]);\n    }\n\n    #[test]\n    fn insert_end() {\n        let slice = &[1, 2, 3];\n        let result = slice.insert(3, 4);\n        assert_eq(result.len(), 4);\n        assert_eq(result, &[1, 2, 3, 4]);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds\")]\n    fn insert_end_out_of_bounds() {\n        let slice = &[1, 2];\n        let _ = slice.insert(3, 4);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds\")]\n    fn remove_empty() {\n        let slice: [Field] = &[];\n        let (_, _) = slice.remove(0);\n    }\n\n    #[test]\n    fn remove_beginning() {\n        let slice = &[1, 2, 3];\n        let (result, elem) = slice.remove(0);\n        assert_eq(result.len(), 2);\n        assert_eq(result, &[2, 3]);\n        assert_eq(elem, 1);\n    }\n\n    #[test]\n    fn remove_middle() {\n        let slice = &[1, 2, 3];\n        let (result, elem) = slice.remove(1);\n        assert_eq(result.len(), 2);\n        assert_eq(result, &[1, 3]);\n        assert_eq(elem, 2);\n    }\n\n    #[test]\n    fn remove_end() {\n        let slice = &[1, 2, 3];\n        let (result, elem) = slice.remove(2);\n        assert_eq(result.len(), 2);\n        assert_eq(result, &[1, 2]);\n        assert_eq(elem, 3);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds\")]\n    fn remove_end_out_of_bounds() {\n        let slice = &[1, 2];\n        let (_, _) = slice.remove(2);\n    }\n\n    #[test]\n    fn fold_empty() {\n        let empty = &[];\n        let result = empty.fold(10, |acc, x| acc + x);\n        assert_eq(result, 10);\n    }\n\n    #[test]\n    fn fold_single() {\n        let slice = &[5];\n        let result = slice.fold(10, |acc, x| acc + x);\n        assert_eq(result, 15);\n    }\n\n    #[test]\n    fn fold_multiple() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.fold(0, |acc, x| acc + x);\n        assert_eq(result, 10);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds\")]\n    fn reduce_empty() {\n        let empty: [Field] = &[];\n        let _ = empty.reduce(|a, b| a + b);\n    }\n\n    #[test]\n    fn reduce_single() {\n        let slice = &[42];\n        let result = slice.reduce(|a, b| a + b);\n        assert_eq(result, 42);\n    }\n\n    #[test]\n    fn reduce_multiple() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.reduce(|a, b| a + b);\n        assert_eq(result, 10);\n    }\n\n    #[test]\n    fn filter_empty() {\n        let empty = &[];\n        let result = empty.filter(|x| x > 0);\n        assert_eq(result.len(), 0);\n    }\n\n    #[test]\n    fn filter_all_true() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.filter(|x| x > 0);\n        assert_eq(result, slice);\n    }\n\n    #[test]\n    fn filter_all_false() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.filter(|x| x > 10);\n        assert_eq(result.len(), 0);\n    }\n\n    #[test]\n    fn filter_some() {\n        let slice = &[1, 2, 3, 4, 5];\n        let result = slice.filter(|x| x % 2 == 0);\n        assert_eq(result, &[2, 4]);\n    }\n\n    #[test]\n    fn all_empty() {\n        let empty = &[];\n        let result = empty.all(|x| x > 0);\n        assert_eq(result, true);\n    }\n\n    #[test]\n    fn all_true() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.all(|x| x > 0);\n        assert_eq(result, true);\n    }\n\n    #[test]\n    fn all_false() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.all(|x| x > 2);\n        assert_eq(result, false);\n    }\n\n    #[test]\n    fn any_empty() {\n        let empty = &[];\n        let result = empty.any(|x| x > 0);\n        assert_eq(result, false);\n    }\n\n    #[test]\n    fn any_true() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.any(|x| x > 3);\n        assert_eq(result, true);\n    }\n\n    #[test]\n    fn any_false() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.any(|x| x > 10);\n        assert_eq(result, false);\n    }\n\n    // utility method tests\n    #[test]\n    fn append_empty_to_empty() {\n        let empty1: [Field] = &[];\n        let empty2: [Field] = &[];\n        let result = empty1.append(empty2);\n        assert_eq(result.len(), 0);\n    }\n\n    #[test]\n    fn append_empty_to_non_empty() {\n        let slice = &[1, 2, 3];\n        let empty = &[];\n        let result = slice.append(empty);\n        assert_eq(result, slice);\n    }\n\n    #[test]\n    fn append_non_empty_to_empty() {\n        let empty = &[];\n        let slice = &[1, 2, 3];\n        let result = empty.append(slice);\n        assert_eq(result, slice);\n    }\n\n    #[test]\n    fn append_two_non_empty() {\n        let slice1 = &[1, 2];\n        let slice2 = &[3, 4, 5];\n        let result = slice1.append(slice2);\n        assert_eq(result, &[1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    fn as_array_single() {\n        let slice = &[42];\n        let array: [Field; 1] = slice.as_array();\n        assert_eq(array[0], 42);\n    }\n\n    #[test]\n    fn as_array_multiple() {\n        let slice = &[1, 2, 3];\n        let array: [Field; 3] = slice.as_array();\n        assert_eq(array[0], 1);\n        assert_eq(array[1], 2);\n        assert_eq(array[2], 3);\n    }\n\n    // complex scenarios\n    #[test]\n    fn chain_operations() {\n        let slice = &[1, 2, 3, 4, 5];\n        let result = slice.filter(|x| x % 2 == 0).map(|x| x * 2).fold(0, |acc, x| acc + x);\n        assert_eq(result, 12); // (2*2) + (4*2) = 4 + 8 = 12\n    }\n\n    #[test]\n    fn nested_operations() {\n        let slice = &[1, 2, 3, 4];\n        let filtered = slice.filter(|x| x > 1);\n        let mapped = filtered.map(|x| x * x);\n        let sum = mapped.fold(0, |acc, x| acc + x);\n        assert_eq(sum, 29); // 2^2 + 3^2 + 4^2 = 4 + 9 + 16 = 29\n    }\n\n    #[test]\n    fn single_element_operations() {\n        let single = &[42];\n\n        // Test all operations on single element\n        assert_eq(single.len(), 1);\n\n        let pushed_back = single.push_back(99);\n        assert_eq(pushed_back, &[42, 99]);\n\n        let pushed_front = single.push_front(0);\n        assert_eq(pushed_front, &[0, 42]);\n\n        let (popped_back_slice, popped_back_elem) = single.pop_back();\n        assert_eq(popped_back_slice.len(), 0);\n        assert_eq(popped_back_elem, 42);\n\n        let (popped_front_elem, popped_front_slice) = single.pop_front();\n        assert_eq(popped_front_slice.len(), 0);\n        assert_eq(popped_front_elem, 42);\n\n        let inserted = single.insert(0, 0);\n        assert_eq(inserted, &[0, 42]);\n\n        let (removed_slice, removed_elem) = single.remove(0);\n        assert_eq(removed_slice.len(), 0);\n        assert_eq(removed_elem, 42);\n    }\n\n    #[test]\n    fn boundary_conditions() {\n        let slice = &[1, 2, 3];\n\n        // insert at boundaries\n        let at_start = slice.insert(0, 0);\n        assert_eq(at_start, &[0, 1, 2, 3]);\n\n        let at_end = slice.insert(3, 4);\n        assert_eq(at_end, &[1, 2, 3, 4]);\n\n        // remove at boundaries\n        let (removed_start, elem_start) = slice.remove(0);\n        assert_eq(removed_start, &[2, 3]);\n        assert_eq(elem_start, 1);\n\n        let (removed_end, elem_end) = slice.remove(2);\n        assert_eq(removed_end, &[1, 2]);\n        assert_eq(elem_end, 3);\n    }\n\n    #[test]\n    fn complex_predicates() {\n        let slice = &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\n        let even_greater_than_5 = slice.filter(|x| (x % 2 == 0) & (x > 5));\n        assert_eq(even_greater_than_5, &[6, 8, 10]);\n\n        let all_positive_and_less_than_20 = slice.all(|x| (x > 0) & (x < 20));\n        assert_eq(all_positive_and_less_than_20, true);\n\n        let any_divisible_by_7 = slice.any(|x| x % 7 == 0);\n        assert_eq(any_divisible_by_7, true);\n    }\n\n    #[test]\n    fn identity_operations() {\n        let slice = &[1, 2, 3, 4, 5];\n\n        let mapped_identity = slice.map(|x| x);\n        assert_eq(mapped_identity, slice);\n\n        let filtered_all = slice.filter(|_| true);\n        assert_eq(filtered_all, slice);\n\n        let filtered_none = slice.filter(|_| false);\n        assert_eq(filtered_none.len(), 0);\n    }\n\n    #[test(should_fail)]\n    fn as_array_size_mismatch() {\n        let slice = &[1, 2, 3];\n        let _: [Field; 5] = slice.as_array(); // size doesn't match\n    }\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        if result {\n            for i in 0..self.len() {\n                result &= self[i].eq(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let self_len = self.len();\n        let other_len = other.len();\n        let min_len = if self_len < other_len {\n            self_len\n        } else {\n            other_len\n        };\n\n        let mut result = Ordering::equal();\n        for i in 0..min_len {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self_len.cmp(other_len)\n        }\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use super::{Eq, max, min, Ord};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n\n    #[test]\n    fn correctly_handles_unequal_length_slices() {\n        let slice_1 = &[0, 1, 2, 3];\n        let slice_2 = &[0, 1, 2];\n        assert(!slice_1.eq(slice_2));\n    }\n\n    #[test]\n    fn lexicographic_ordering_for_slices() {\n        assert(&[2_u32].cmp(&[1_u32, 1_u32, 1_u32]) == super::Ordering::greater());\n        assert(&[1_u32, 2_u32].cmp(&[1_u32, 2_u32, 3_u32]) == super::Ordering::less());\n    }\n}\n"
    },
    "51": {
      "path": "/home/jpag/Playground/aztec/crosschain/wormhole-demo/packages/aztec/src/message_bridge/src/main.nr",
      "source": "use aztec::macros::aztec;\n\npub mod config;\npub mod utils;\n\n#[aztec]\npub contract MessageBridge {\n    use aztec::{\n        macros::{\n            functions::{initializer, external, internal},\n            storage::storage,\n        },\n        protocol_types::address::AztecAddress,\n        state_vars::{map::Map, public_mutable::PublicMutable, public_immutable::PublicImmutable},\n    };\n    use crate::{\n        config::Config,\n        utils::vaa::{encode_message_payload, decode_vaa},\n    };\n    use wormhole::Wormhole;\n\n    // ============================================================================\n    // STORAGE\n    // ============================================================================\n\n    #[storage]\n    struct Storage<Context> {\n        // Core configuration (immutable after deployment)\n        config: PublicImmutable<Config, Context>,\n\n        // Owner/admin address\n        owner: PublicMutable<AztecAddress, Context>,\n\n        // Registered emitters\n        // chain id => emitter address (one emitter per chain)\n        registered_emitters: Map<u16, PublicMutable<[u8; 32], Context>, Context>,\n\n        // currently stored value\n        current_value: PublicMutable<u128, Context>,\n    }\n\n    // ============================================================================\n    // INITIALIZATION\n    // ============================================================================\n\n    #[external(\"public\")]\n    #[initializer]\n    fn constructor(\n        wormhole_address: AztecAddress,\n        chain_id: u16,\n        owner: AztecAddress,\n        message_fee: u128,\n    ) {\n        storage.config.initialize(Config::new(\n            wormhole_address,\n            chain_id,\n            message_fee,\n        ));\n        storage.owner.write(owner);\n\n        // Initialize last received values to zero\n        storage.current_value.write(0);\n    }\n\n    #[external(\"public\")]\n    fn register_emitter(source_chain_id: u16, emitter_address: [u8; 32]) {\n        // 1. check caller is admin\n        let owner = storage.owner.read();\n        assert(owner == context.msg_sender().unwrap(), \"Caller is not owner\");\n\n        // 2. register emitter (store full 32-byte address)\n        storage.registered_emitters\n            .at(source_chain_id)\n            .write(emitter_address);\n    }\n\n    // ============================================================================\n    // SEND MESSAGE (Aztec -> EVM)\n    // ============================================================================\n\n    #[external(\"public\")]\n    fn send_value_public(\n        destination_chain_id: u16,\n        value: u128,\n        fee_nonce: Field,\n    ) {\n        // no auth checks\n        let caller = context.msg_sender().unwrap();\n        let config = storage.config.read();\n\n        // 1. Encode the message payload (just destination_chain_id + value)\n        let wormhole_payload = encode_message_payload(value, destination_chain_id);\n\n        // 2. Publish message publicly through Wormhole\n        let _ = Wormhole::at(config.wormhole_address).publish_message_in_public(\n            0, // nonce\n            wormhole_payload,\n            config.message_fee,\n            1, // consistency level (1 = confirmed)\n            caller,\n            fee_nonce,\n        ).call(&mut context);\n    }\n\n    #[external(\"private\")]\n    fn send_value_private(\n        destination_chain_id: u16,\n        value: u128,\n        fee_nonce: Field,\n    ) {\n        // no auth checks\n        let caller = context.msg_sender().unwrap();\n        let config = storage.config.read();\n\n        // 1. Encode the message payload (just destination_chain_id + value)\n        let wormhole_payload = encode_message_payload(value, destination_chain_id);\n\n        // 2. Publish message privately through Wormhole\n        let _ = Wormhole::at(config.wormhole_address).publish_message_in_private(\n            0, // nonce\n            wormhole_payload,\n            config.message_fee,\n            1, // consistency level (1 = confirmed)\n            caller,\n            fee_nonce,\n        ).call(&mut context);\n    }\n\n    // ============================================================================\n    // RECEIVE MESSAGE (EVM -> Aztec)\n    // ============================================================================\n    \n    #[external(\"private\")]\n    fn receive_value(vaa: [u8; 2000], length: u32) {\n        // 1. verify the VAA through Wormhole\n        let config = storage.config.read();\n        Wormhole::at(config.wormhole_address).verify_vaa(vaa, length).call(&mut context);\n\n        // 2. decode the VAA (envelope + payload) and compute vaa nullifier\n        let (vaa_envelope, vaa_payload, vaa_nullifier) = decode_vaa(vaa);\n\n        // 3. validate destination chain is this chain\n        assert(\n            vaa_payload.destination_chain_id == config.chain_id,\n            \"Invalid destination chain ID\"\n        );\n\n        // 4. emit the nullifier to prevent replays\n        // note: will fail if nullifier has already been emitted\n        context.push_nullifier(vaa_nullifier);\n\n        // 5. validate emitter and update state (done in public to read public storage)\n        MessageBridge::at(context.this_address())\n            ._validate_emitter_and_update_value(\n                vaa_envelope.emitter_chain_id,\n                vaa_envelope.emitter_address,\n                vaa_payload.value,\n            )\n            .enqueue(&mut context);\n    }\n\n    #[external(\"public\")]\n    #[internal]\n    fn _validate_emitter_and_update_value(\n        emitter_chain_id: u16,\n        emitter_address: [u8; 32],\n        value: u128,\n    ) {\n        // Validate emitter from VAA envelope (not sender from payload)\n        let registered_emitter = storage.registered_emitters\n            .at(emitter_chain_id)\n            .read();\n        assert(registered_emitter == emitter_address, \"Emitter not registered\");\n\n        // Update state with received value\n        storage.current_value.write(value);\n    }\n\n    // ============================================================================\n    // VIEW FUNCTIONS\n    // ============================================================================\n\n    #[external(\"utility\")]\n    unconstrained fn get_config() -> Config {\n        storage.config.read()\n    }\n\n    #[external(\"utility\")]\n    unconstrained fn get_owner() -> AztecAddress {\n        storage.owner.read()\n    }\n\n    #[external(\"utility\")]\n    unconstrained fn is_emitter_registered(chain_id: u16, emitter_address: [u8; 32]) -> bool {\n        let registered_emitter = storage.registered_emitters\n            .at(chain_id)\n            .read();\n        registered_emitter == emitter_address\n    }\n\n    #[external(\"utility\")]\n    unconstrained fn get_registered_emitter(chain_id: u16) -> [u8; 32] {\n        storage.registered_emitters\n            .at(chain_id)\n            .read()\n    }\n\n    #[external(\"utility\")]\n    unconstrained fn get_current_value() -> u128 {\n        storage.current_value.read()\n    }\n}\n"
    },
    "52": {
      "path": "/home/jpag/Playground/aztec/crosschain/wormhole-demo/packages/aztec/src/message_bridge/src/utils/mod.nr",
      "source": "pub mod vaa;\n\n// VAA structure offsets (hardcoded for 1 signature)\npub global VAA_HEADER_SIZE: u32 = 6;        // version(1) + guardian_set(4) + num_sigs(1)\npub global VAA_SIGNATURE_SIZE: u32 = 66;    // guardian_index(1) + signature(64) + recovery(1)\npub global VAA_ENVELOPE_START: u32 = VAA_HEADER_SIZE + VAA_SIGNATURE_SIZE; // = 72\npub global VAA_ENVELOPE_SIZE: u32 = 51;     // timestamp(4) + nonce(4) + emitter_chain(2) + emitter_addr(32) + sequence(8) + consistency(1)\npub global VAA_PAYLOAD_START: u32 = VAA_ENVELOPE_START + VAA_ENVELOPE_SIZE; // = 123\n\npub global VAA_MAX_LENGTH: u32 = 2000;      // max VAA length in Wormhole spec\npub global VAA_BODY_MAX_LENGTH: u32 = 1860; // max body length in Wormhole VAA spec\n\n// Message payload structure (18 bytes): destinationChainId (2) + value (16)\npub global MESSAGE_PAYLOAD_LENGTH: u32 = 18;\npub global MESSAGE_NULLIFIER_LENGTH: u32 = VAA_ENVELOPE_SIZE + MESSAGE_PAYLOAD_LENGTH; // 51 + 18 = 69\npub global MESSAGE_NULLIFIER_PACKED_LENGTH: u32 = 3; // ceil(69 / 31) = 3\n\n/// Decoded VAA envelope (excludes header and signatures)\npub struct DecodedVAAEnvelope {\n    pub timestamp: u32,\n    pub nonce: u32,\n    pub emitter_chain_id: u16,\n    pub emitter_address: [u8; 32],\n    pub sequence: u64,\n    pub consistency_level: u8,\n}\n\n\n/// Decoded message payload (18 bytes)\npub struct DecodedVAAPayload {\n    pub destination_chain_id: u16,\n    pub value: u128,\n}\n\n// probably should just use Field::to_le_bytes but meh\npub fn u16_to_u8(value: u16) -> [u8; 2] {\n    // Safety: constrained below, use unconstrained for bitwise ops\n    let decomposed = unsafe { _u16_to_u8(value) };\n    let asserted = decomposed[0] as u16 * 256 + decomposed[1] as u16;\n    assert(asserted == value, \"u16 to u8 conversion failed\");\n    decomposed\n}\n\nunconstrained fn _u16_to_u8(value: u16) -> [u8; 2] {\n    let high = (value >> 8) as u8;\n    let low = (value & 0xFF) as u8;\n    [high, low]\n}"
    },
    "53": {
      "path": "/home/jpag/Playground/aztec/crosschain/wormhole-demo/packages/aztec/src/message_bridge/src/utils/vaa.nr",
      "source": "use keccak256::keccak256;\nuse poseidon::poseidon2::Poseidon2;\nuse crate::utils::{\n    VAA_MAX_LENGTH,\n    VAA_ENVELOPE_START,\n    VAA_PAYLOAD_START,\n    MESSAGE_NULLIFIER_LENGTH,\n    MESSAGE_NULLIFIER_PACKED_LENGTH,\n    DecodedVAAEnvelope,\n    DecodedVAAPayload,\n    u16_to_u8,\n};\nuse nodash::pack_bytes;\n\npub struct DecodedVAA {\n    pub envelope: DecodedVAAEnvelope,\n    pub payload: DecodedVAAPayload,\n}\n\n/// Parse a raw VAA and extract envelope, payload, and compute nullifier\n///\n/// VAA structure (with 1 signature):\n///   Bytes 0-5:     Header (version, guardian set, num sigs) - skipped\n///   Bytes 6-71:    Signature - skipped\n///   Bytes 72-122:  Envelope (timestamp, nonce, emitter chain, emitter addr, sequence, consistency)\n///   Bytes 123+:    Payload\npub fn decode_vaa(vaa: [u8; VAA_MAX_LENGTH]) -> (\n    DecodedVAAEnvelope,\n    DecodedVAAPayload,\n    Field,\n) {\n    let envelope = decode_vaa_envelope(vaa);\n    let payload = decode_vaa_payload(vaa);\n    let nullifier = compute_vaa_nullifier(vaa);\n    (envelope, payload, nullifier)\n}\n\n/// Parse the VAA envelope (starts at byte 72 for 1 signature)\n///\n/// Envelope structure (51 bytes):\n///   Bytes 0-3:   timestamp (u32, big-endian)\n///   Bytes 4-7:   nonce (u32, big-endian)\n///   Bytes 8-9:   emitter_chain_id (u16, big-endian)\n///   Bytes 10-41: emitter_address (32 bytes)\n///   Bytes 42-49: sequence (u64, big-endian)\n///   Byte 50:     consistency_level (u8)\npub fn decode_vaa_envelope(vaa: [u8; VAA_MAX_LENGTH]) -> DecodedVAAEnvelope {\n    let offset = VAA_ENVELOPE_START;\n\n    // timestamp (4 bytes, big-endian)\n    let mut timestamp_bytes: [u8; 4] = [0; 4];\n    for i in 0..4 {\n        timestamp_bytes[i] = vaa[offset + i];\n    }\n    let timestamp = Field::from_be_bytes(timestamp_bytes) as u32;\n\n    // nonce (4 bytes, big-endian)\n    let mut nonce_bytes: [u8; 4] = [0; 4];\n    for i in 0..4 {\n        nonce_bytes[i] = vaa[offset + 4 + i];\n    }\n    let nonce = Field::from_be_bytes(nonce_bytes) as u32;\n\n    // emitter_chain_id (2 bytes, big-endian)\n    let mut chain_id_bytes: [u8; 2] = [0; 2];\n    for i in 0..2 {\n        chain_id_bytes[i] = vaa[offset + 8 + i];\n    }\n    let emitter_chain_id = Field::from_be_bytes(chain_id_bytes) as u16;\n\n    // emitter_address (32 bytes)\n    let mut emitter_address: [u8; 32] = [0; 32];\n    for i in 0..32 {\n        emitter_address[i] = vaa[offset + 10 + i];\n    }\n\n    // sequence (8 bytes, big-endian)\n    let mut sequence_bytes: [u8; 8] = [0; 8];\n    for i in 0..8 {\n        sequence_bytes[i] = vaa[offset + 42 + i];\n    }\n    let sequence = Field::from_be_bytes(sequence_bytes) as u64;\n\n    // consistency_level (1 byte)\n    let consistency_level = vaa[offset + 50];\n\n    DecodedVAAEnvelope {\n        timestamp,\n        nonce,\n        emitter_chain_id,\n        emitter_address,\n        sequence,\n        consistency_level,\n    }\n}\n\n/// Parse the VAA payload (starts at byte 123 for 1 signature)\n///\n/// Payload structure (18 bytes):\n///   Bytes 0-1:   destination_chain_id (u16, big-endian)\n///   Bytes 2-17:  value (u128, big-endian)\npub fn decode_vaa_payload(vaa: [u8; VAA_MAX_LENGTH]) -> DecodedVAAPayload {\n    let offset = VAA_PAYLOAD_START;\n\n    // destination_chain_id (2 bytes, big-endian)\n    let destination_chain_id = (\n        (vaa[offset] as Field) * 256\n        + (vaa[offset + 1] as Field)\n    ) as u16;\n\n    // value (16 bytes, big-endian) - parse as u128 via Field multiplication\n    let mut value_bytes: [u8; 16] = [0; 16];\n    for i in 0..16 {\n        value_bytes[i] = vaa[offset + 2 + i];\n    }\n    let value = Field::from_be_bytes(value_bytes) as u128;\n\n    DecodedVAAPayload {\n        destination_chain_id,\n        value,\n    }\n}\n\n/// Compute nullifier from VAA bytes (for replay protection)\nfn compute_vaa_nullifier(vaa: [u8; VAA_MAX_LENGTH]) -> Field {\n    // Pack the relevant bytes (envelope + payload) for hashing\n    let mut nullifier_bytes = [0; MESSAGE_NULLIFIER_LENGTH];\n    for i in 0..MESSAGE_NULLIFIER_LENGTH {\n        nullifier_bytes[i] = vaa[VAA_ENVELOPE_START + i];\n    }\n\n    let packed = pack_bytes(nullifier_bytes);\n    Poseidon2::hash(packed, MESSAGE_NULLIFIER_PACKED_LENGTH)\n}\n\n/// Encode a message payload for sending via Wormhole (Aztec -> EVM)\n///\n/// Payload structure (18 bytes):\n///   Bytes 0-1:   destination_chain_id (u16, big-endian)\n///   Bytes 2-17:  value (u128, big-endian)\n///\n/// Returns 8 chunks of 31 bytes for Aztec Field compatibility\npub fn encode_message_payload(\n    value: u128,\n    destination_chain_id: u16,\n) -> [[u8; 31]; 8] {\n    let mut wormhole_payload: [[u8; 31]; 8] = [[0; 31]; 8];\n\n    let destination_chain_bytes = u16_to_u8(destination_chain_id);\n    let value_bytes: [u8; 16] = Field::to_be_bytes(value as Field);\n\n    // Chunk 0: destination_chain_id (2 bytes) + value (16 bytes) = 18 bytes total\n    wormhole_payload[0][0] = destination_chain_bytes[0];\n    wormhole_payload[0][1] = destination_chain_bytes[1];\n    for i in 0..16 {\n        wormhole_payload[0][2 + i] = value_bytes[i];\n    }\n\n    wormhole_payload\n}\n\n// Keccak hash of VAA body (for signature verification)\npub fn compute_vaa_hash(body_bytes: [u8; 1860], body_length: u32) -> [u8; 32] {\n    let mut actual_body = [0; 1860];\n    for i in 0..body_length {\n        actual_body[i] = body_bytes[i];\n    }\n\n    // Double hash as per Wormhole spec\n    let hash: [u8; 32] = keccak256(actual_body, body_length);\n    let double_hash: [u8; 32] = keccak256(hash, 32);\n\n    double_hash\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0, \"cannot pop from an empty vector\");\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            let _ = vec.get(0);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_beyond_length() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            let _ = vec.get(3);\n        }\n\n        #[test]\n        fn get_works_within_bounds() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(2), 3);\n            assert_eq(vec.get(4), 5);\n        }\n\n        #[test]\n        fn get_unchecked_works() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(0), 1);\n            assert_eq(vec.get_unchecked(2), 3);\n        }\n\n        #[test]\n        fn get_unchecked_works_past_len() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(4), 0);\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_setting_beyond_length() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            vec.set(3, 4);\n        }\n\n        #[test]\n        fn set_unchecked_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(0, 10);\n            assert_eq(vec.get(0), 10);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn set_unchecked_operations_past_len() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(3, 40);\n            assert_eq(vec.get(3), 40);\n        }\n\n        #[test]\n        fn set_preserves_other_elements() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            vec.set(2, 30);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 30);\n            assert_eq(vec.get(3), 4);\n            assert_eq(vec.get(4), 5);\n        }\n    }\n\n    mod any {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn returns_false_if_predicate_not_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, false, false]);\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn returns_true_if_predicate_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, true, true]);\n            let result = vec.any(|value| value);\n\n            assert(result);\n        }\n\n        #[test]\n        fn returns_false_on_empty_boundedvec() {\n            let vec: BoundedVec<bool, 0> = BoundedVec::new();\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn any_with_complex_predicates() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            assert(vec.any(|x| x > 3));\n            assert(!vec.any(|x| x > 10));\n            assert(vec.any(|x| x % 2 == 0)); // has a even number\n            assert(vec.any(|x| x == 3)); // has a specific value\n        }\n\n        #[test]\n        fn any_with_partial_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            assert(vec.any(|x| x == 1));\n            assert(vec.any(|x| x == 2));\n            assert(!vec.any(|x| x == 3));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn map_with_conditional_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.map(|x| if x % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([1, 4, 3, 8]);\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn map_preserves_length() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|x| x * 2);\n\n            assert_eq(result.len(), vec.len());\n            assert_eq(result.max_len(), vec.max_len());\n        }\n\n        #[test]\n        fn map_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let result = vec.map(|x| x * 2);\n            assert_eq(result, vec);\n            assert_eq(result.len(), 0);\n            assert_eq(result.max_len(), 5);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn mapi_with_index_branching_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.mapi(|i, x| if i % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([2, 2, 6, 4]);\n            assert_eq(result, expected);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_each_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_each(|_| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_each_with_side_effects() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let mut seen = BoundedVec::<u32, 3>::new();\n            let seen_ref = &mut seen;\n            vec.for_each(|x| seen_ref.push(x));\n            assert_eq(seen, vec);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_eachi_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_eachi(|_, _| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_eachi_with_index_tracking() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([10, 20, 30]);\n            let mut indices = BoundedVec::<u32, 3>::new();\n            let indices_ref = &mut indices;\n            vec.for_eachi(|i, _| indices_ref.push(i));\n\n            let expected = BoundedVec::from_array([0, 1, 2]);\n            assert_eq(indices, expected);\n        }\n\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n\n        #[test]\n        fn from_array_preserves_order() {\n            let array = [5, 3, 1, 4, 2];\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array(array);\n            for i in 0..array.len() {\n                assert_eq(vec.get(i), array[i]);\n            }\n        }\n\n        #[test]\n        fn from_array_with_different_types() {\n            let bool_array = [true, false, true];\n            let bool_vec: BoundedVec<bool, 3> = BoundedVec::from_array(bool_array);\n            assert_eq(bool_vec.len(), 3);\n            assert_eq(bool_vec.get(0), true);\n            assert_eq(bool_vec.get(1), false);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n\n    mod push_pop {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn push_and_pop_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            assert_eq(vec.len(), 0);\n\n            vec.push(1);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 1);\n\n            vec.push(2);\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.get(1), 2);\n\n            let popped = vec.pop();\n            assert_eq(popped, 2);\n            assert_eq(vec.len(), 1);\n\n            let popped2 = vec.pop();\n            assert_eq(popped2, 1);\n            assert_eq(vec.len(), 0);\n        }\n\n        #[test(should_fail_with = \"push out of bounds\")]\n        fn push_to_full_vector() {\n            let mut vec: BoundedVec<u32, 2> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n            vec.push(3); // should panic\n        }\n\n        #[test(should_fail_with = \"cannot pop from an empty vector\")]\n        fn pop_from_empty_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let _ = vec.pop(); // should panic\n        }\n\n        #[test]\n        fn push_pop_cycle() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n\n            // push to full\n            vec.push(1);\n            vec.push(2);\n            vec.push(3);\n            assert_eq(vec.len(), 3);\n\n            // pop all\n            assert_eq(vec.pop(), 3);\n            assert_eq(vec.pop(), 2);\n            assert_eq(vec.pop(), 1);\n            assert_eq(vec.len(), 0);\n\n            // push again\n            vec.push(4);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 4);\n        }\n    }\n\n    mod extend {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn extend_from_array() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_slice() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_bounded_vec() {\n            let mut vec1: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut vec2: BoundedVec<u32, 3> = BoundedVec::new();\n\n            vec1.push(1);\n            vec2.push(2);\n            vec2.push(3);\n\n            vec1.extend_from_bounded_vec(vec2);\n\n            assert_eq(vec1.len(), 3);\n            assert_eq(vec1.get(0), 1);\n            assert_eq(vec1.get(1), 2);\n            assert_eq(vec1.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"extend_from_array out of bounds\")]\n        fn extend_array_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3, 4]); // should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_slice out of bounds\")]\n        fn extend_slice_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3, 4]); // S]should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_bounded_vec out of bounds\")]\n        fn extend_bounded_vec_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            let other: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            vec.extend_from_bounded_vec(other); // should panic\n        }\n\n        #[test]\n        fn extend_with_empty_collections() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let original_len = vec.len();\n\n            vec.extend_from_array([]);\n            assert_eq(vec.len(), original_len);\n\n            vec.extend_from_slice(&[]);\n            assert_eq(vec.len(), original_len);\n\n            let empty: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.extend_from_bounded_vec(empty);\n            assert_eq(vec.len(), original_len);\n        }\n    }\n\n    mod storage {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn storage_consistency() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            // test initial storage state\n            assert_eq(vec.storage(), [0, 0, 0, 0, 0]);\n\n            vec.push(1);\n            vec.push(2);\n\n            // test storage after modifications\n            assert_eq(vec.storage(), [1, 2, 0, 0, 0]);\n\n            // storage doesn't change length\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.max_len(), 5);\n        }\n\n        #[test]\n        fn storage_after_pop() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n\n            let _ = vec.pop();\n            // after pop, the last element should be zeroed\n            assert_eq(vec.storage(), [1, 2, 0]);\n            assert_eq(vec.len(), 2);\n        }\n\n        #[test]\n        fn vector_immutable() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let storage = vec.storage();\n\n            assert_eq(storage, [1, 2, 3]);\n\n            // Verify that the original vector is unchanged\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n    }\n}\n"
    },
    "62": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push(self, value: T)\n    where\n        T: Serialize,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get(self, index: u32) -> T\n    where\n        T: Deserialize,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n\n    global SLOT: Field = 1230;\n\n    #[test]\n    unconstrained fn empty_array() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            let _: Field = array.get(0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            assert_eq(array.len(), 1);\n            assert_eq(array.get(0), 5);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            let _ = array.get(1);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(5);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            assert_eq(array.len(), 3);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 8);\n            assert_eq(array.get(2), 9);\n\n            array.remove(1);\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 9);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            array.remove(1);\n            array.remove(1);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n            // we do not care about the order in which each tuple was passed to the closure.\n            let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n            array.for_each(|index, value| { called_with.push((index, value)); });\n\n            assert_eq(called_with.len(), 3);\n            assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n            assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n            assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| {\n                if index == 1 {\n                    array.remove(index);\n                }\n            });\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 4);\n            assert_eq(array.get(1), 6);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all_no_copy() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We test that the utilityCopyCapsule was never called, which is the expensive operation we want to avoid.\n            let mock = std::test::OracleMock::mock(\"utilityCopyCapsule\");\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(mock.times_called(), 0);\n        });\n    }\n}\n"
    },
    "63": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PrivateCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    /// Makes the call to this private function.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// This enables contracts to interact with each other while maintaining\n    /// privacy. This \"composability\" of private contract functions is a key\n    /// feature of the Aztec network.\n    ///\n    /// If a user's transaction includes multiple private function calls, then\n    /// by the design of Aztec, the following information will remain private[1]:\n    /// - The function selectors and contract addresses of all private function\n    ///   calls will remain private, so an observer of the public mempool will\n    ///   not be able to look at a tx and deduce which private functions have\n    ///   been executed.\n    /// - The arguments and return values of all private function calls will\n    ///   remain private.\n    /// - The person who initiated the tx will remain private.\n    /// - The notes and nullifiers and private logs that are emitted by all\n    ///   private function calls will (if designed well) not leak any user\n    ///   secrets, nor leak which functions have been executed.\n    ///\n    /// [1] Caveats: Some of these privacy guarantees depend on how app\n    /// developers design their smart contracts. Some actions _can_ leak\n    /// information, such as:\n    /// - Calling an internal public function.\n    /// - Calling a public function and not setting msg_sender to Option::none\n    ///   (see https://github.com/AztecProtocol/aztec-packages/pull/16433)\n    /// - Calling any public function will always leak details about the nature\n    ///   of the transaction, so devs should be careful in their contract\n    ///   designs. If it can be done in a private function, then that will give\n    ///   the best privacy.\n    /// - Not padding the side-effects of a tx to some standardised, uniform\n    ///   size. The kernel circuits can take hints to pad side-effects, so a\n    ///   wallet should be able to request for a particular amount of padding.\n    ///   Wallets should ideally agree on some standard.\n    ///   - Padding should include:\n    ///     - Padding the lengths of note & nullifier arrays\n    ///     - Padding private logs with random fields, up to some standardised\n    ///       size.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Advanced\n    /// * The call is added to the private call stack and executed by kernel\n    ///   circuits after this function completes\n    /// * The called function can modify its own contract's private state\n    /// * Side effects from the called function are included in this transaction\n    /// * The call inherits the current transaction's context and gas limits\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub fn call(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n\n        // If T is () (i.e. if the function does not return anything) then `get_preimage` will constrain that the\n        // returns hash is empty as per the protocol rules.\n        returns_hash.get_preimage()\n    }\n\n    /// Makes a _read-only_ call to this private function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// See `call` for more general info on private function calls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub fn view(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        // If T is () (i.e. if the function does not return anything) then `get_preimage` will constrain that the\n        // returns hash is empty as per the protocol rules.\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PrivateCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PrivateStaticCallInterface<M, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    /// Makes a read-only call to this private function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn view(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PrivateStaticCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PublicCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    /// Makes the call to this public function.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[external(\"public\")] function as `context`, through the\n    ///               #[external(\"public\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn call(self, context: &mut PublicContext) -> T {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        // If T is () (i.e. if the function does not return anything) then `as_array` will constrain that `returns` has\n        // a length of 0 (since that is ()'s deserialization length).\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Makes a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[external(\"public\")] function as `context`, through the\n    ///               #[external(\"public\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn view(self, context: &mut PublicContext) -> T {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        // If T is () (i.e. if the function does not return anything) then `as_array` will constrain that `returns` has\n        // a length of 0 (since that is ()'s deserialization length).\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Enqueues a call to this public function, to be executed later.\n    ///\n    /// Unlike private functions which execute immediately on the user's device,\n    /// public function calls are \"enqueued\" and executed some time later by a\n    /// block proposer.\n    ///\n    /// This means a public function cannot return any values back to a private\n    /// function, because by the time the public function is being executed,\n    /// the private function which called it has already completed execution.\n    /// (In fact, the private function has been executed and proven, along with\n    /// all other private function calls of the user's tx. A single proof of the\n    /// tx has been submitted to the Aztec network, and some time later a\n    /// proposer has picked the tx up from the mempool and begun executing all\n    /// of the enqueued public functions).\n    ///\n    /// # Privacy warning\n    /// Enqueueing a public function call is an inherently leaky action.\n    /// Many interesting applications will require some interaction with public\n    /// state, but smart contract developers should try to use public function\n    /// calls sparingly, and carefully.\n    /// _Internal_ public function calls are especially leaky, because they\n    /// completely leak which private contract made the call.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        self.enqueue_impl(context, false, false)\n    }\n\n    /// Enqueues a call to this public function, to be executed later.\n    ///\n    /// As per `enqueue`, but hides this calling contract's address from the\n    /// target public function.\n    /// This means the origin of the call (msg_sender) will not be publicly\n    /// visible to any blockchain observers, nor to the target public function.\n    /// When the target public function reads `context.msg_sender()` it will\n    /// receive an `Option<AztecAddress>::none`.\n    ///\n    /// NOTES:\n    /// - Not all public functions will accept a msg_sender of \"none\". Many\n    ///   public functions will require that msg_sender is \"some\" and will\n    ///   revert otherwise. Therefore, if using `enqueue_incognito`, you must\n    ///   understand whether the function you're calling will accept a\n    ///   msg_sender of \"none\".\n    ///   Lots of public bookkeeping patterns rely on knowing which address made\n    ///   the call, so as to ascribe state against the caller's address.\n    ///   (There are patterns whereby bookkeeping could instead be done in\n    ///   private-land).\n    /// - If you are enqueueing a call to an _internal_ public function (i.e.\n    ///   a public function that will only accept calls from other functions\n    ///   of its own contract), then by definition a call to it cannot possibly\n    ///   be \"incognito\": the msg_sender must be its own address, and indeed the\n    ///   called public function will assert this. Tl;dr this is not usable for\n    ///   enqueued internal public calls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    /// Advanced:\n    /// - The kernel circuits will permit _any_ private function to set the\n    ///   msg_sender field of any enqueued public function call to\n    ///   NULL_MSG_SENDER_CONTRACT_ADDRESS.\n    /// - When the called public function calls `PublicContext::msg_sender()`,\n    ///   aztec-nr will translate NULL_MSG_SENDER_CONTRACT_ADDRESS into\n    ///   `Option<AztecAddress>::none` for familiarity to devs.\n    ///\n    pub fn enqueue_incognito(self, context: &mut PrivateContext) {\n        self.enqueue_impl(context, false, true)\n    }\n\n    /// Enqueues a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        self.enqueue_impl(context, true, false)\n    }\n\n    /// Enqueues a read-only call to this public function.\n    ///\n    /// As per `enqueue_view`, but hides this calling contract's address from\n    /// the target public function.\n    ///\n    /// See `enqueue_incognito` for more details relating to hiding msg_sender.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn enqueue_view_incognito(self, context: &mut PrivateContext) {\n        self.enqueue_impl(context, true, true)\n    }\n\n    fn enqueue_impl(\n        self,\n        context: &mut PrivateContext,\n        is_static_call: bool,\n        hide_msg_sender: bool,\n    ) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            is_static_call,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a call to this public function, and designates it to be the\n    /// teardown function for this tx. Only one teardown function call can be\n    /// made by a tx.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase ensures the fee payer\n    /// has sufficient balance to pay the proposer their fees.\n    /// The teardown phase is primarily intended to: calculate exactly\n    /// how much the user owes, based on gas consumption, and refund the user\n    /// any change.\n    ///\n    /// Note: in some cases, the cost of refunding the user (i.e. DA costs of\n    /// tx side-effects) might exceed the refund amount. For app logic with\n    /// fairly stable and predictable gas consumption, a material refund amount\n    /// is unlikely. For app logic with unpredictable gas consumption, a\n    /// refund might be important to the user (e.g. if a hefty function reverts\n    /// very early). Wallet/FPC/Paymaster developers should be mindful of this.\n    ///\n    /// See `enqueue` for more information about enqueuing public function calls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        self.set_as_teardown_impl(context, false);\n    }\n\n    /// Enqueues a call to this public function, and designates it to be the teardown\n    /// function for this tx. Only one teardown function call can be made by a\n    /// tx.\n    ///\n    /// As per `set_as_teardown`, but hides this calling contract's address from\n    /// the target public function.\n    ///\n    /// See `enqueue_incognito` for more details relating to hiding msg_sender.\n    ///\n    pub fn set_as_teardown_incognito(self, context: &mut PrivateContext) {\n        self.set_as_teardown_impl(context, true);\n    }\n\n    fn set_as_teardown_impl(self, context: &mut PrivateContext, hide_msg_sender: bool) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PublicCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let M: u32, T> PublicStaticCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    /// Makes the read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[external(\"public\")] function as `context`, through the\n    ///               #[external(\"public\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn view(self, context: &mut PublicContext) -> T {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Enqueues a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n            false,\n        )\n    }\n\n    pub fn enqueue_view_incognito(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n            true,\n        )\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PublicStaticCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// UtilityCallInterface\n\npub struct UtilityCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n}\n\nimpl<let M: u32, T> CallInterface<M> for UtilityCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        false\n    }\n}\n\nimpl<let M: u32, T> UtilityCallInterface<M, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n\n    pub fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    pub fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    pub fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    pub fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n}\n"
    },
    "70": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        logs::notify_created_contract_class_log,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        block_header::BlockHeader,\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log_hash::LogHash,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::{PrivateLog, PrivateLogData},\n        public_call_request::PublicCallRequest,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, MAX_CONTRACT_CLASS_LOGS_PER_CALL,\n        MAX_ENQUEUED_CALLS_PER_CALL, MAX_INCLUDE_BY_TIMESTAMP_DURATION,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        NULL_MSG_SENDER_CONTRACT_ADDRESS, PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    hash::poseidon2_hash,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    side_effect::Counted,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::{ClaimedLengthArray, trimmed_array_length_hint},\n};\n\n/// # PrivateContext\n///\n/// The **main interface** between an #[external(\"private\")] function and the Aztec blockchain.\n///\n/// An instance of the PrivateContext is initialized automatically at the outset\n/// of every private function, within the #[external(\"private\")] macro, so you'll never\n/// need to consciously instantiate this yourself.\n///\n/// The instance is always named `context`, and it is always be available within\n/// the body of every #[external(\"private\")] function in your smart contract.\n///\n/// > For those used to \"vanilla\" Noir, it might be jarring to have access to\n/// > `context` without seeing a declaration `let context = PrivateContext::new(...)`\n/// > within the body of your function. This is just a consequence of using\n/// > macros to tidy-up verbose boilerplate. You can use `nargo expand` to\n/// > expand all macros, if you dare.\n///\n/// Typical usage for a smart contract developer will be to call getter\n/// methods of the PrivateContext.\n///\n/// _Pushing_ data and requests to the context is mostly handled within\n/// aztec-nr's own functions, so typically a smart contract developer won't\n/// need to call any setter methods directly.\n///\n/// > Advanced users might occasionally wish to push data to the context\n/// > directly for lower-level control. If you find yourself doing this, please\n/// > open an issue on GitHub to describe your use case: it might be that\n/// > new functionality should be added to aztec-nr.\n///\n/// ## Responsibilities\n/// - Exposes contextual data to a private function:\n///   - Data relating to how this private function was called.\n///     - msg_sender\n///     - this_address - (the contract address of the private function being\n///                      executed)\n///     - See `CallContext` for more data.\n///   - Data relating to the transaction in which this private function is\n///     being executed.\n///     - chain_id\n///     - version\n///     - gas_settings\n/// - Provides state access:\n///   - Access to the \"Anchor block\" header.\n///     Recall, a private function cannot read from the \"current\" block header,\n///     but must read from some historical block header, because as soon as\n///     private function execution begins (asynchronously, on a user's device),\n///     the public state of the chain (the \"current state\") will have progressed\n///     forward. We call this reference the \"Anchor block\".\n///     See `BlockHeader`.\n///   - Enables consumption of L1->L2 messages.\n/// - Enables calls to functions of other smart contracts:\n///   - Private function calls\n///   - Enqueueing of public function call requests\n///     (Since public functions are executed at a later time, by a block\n///     proposer, we say they are \"enqueued\").\n/// - Writes data to the blockchain:\n///   - New notes\n///   - New nullifiers\n///   - Private logs (for sending encrypted note contents or encrypted events)\n///   - New L2->L1 messages.\n/// - Provides args to the private function (handled by the #[external(\"private\")] macro).\n/// - Returns the return values of this private function (handled by the\n///   #[external(\"private\")] macro).\n/// - Makes Key Validation Requests.\n///   - Private functions are not allowed to see master secret keys, because we\n///     do not trust them. They are instead given \"app-siloed\" secret keys with\n///     a claim that they relate to a master public key. They can then request\n///     validation of this claim, by making a \"key validation request\" to the\n///     protocol's kernel circuits (which _are_ allowed to see certain master\n///     secret keys).\n///\n/// ## Advanced Responsibilities\n///\n/// - Ultimately, the PrivateContext is responsible for constructing the\n///   PrivateCircuitPublicInputs of the private function being executed.\n///   All private functions on Aztec must have public inputs which adhere\n///   to the rigid layout of the PrivateCircuitPublicInputs, in order to be\n///   compatible with the protocol's kernel circuits.\n///   A well-known misnomer:\n///   - \"public inputs\" contain both inputs and outputs of this function.\n///     - By \"outputs\" we mean a lot more side-effects than just the\n///       \"return values\" of the function.\n///   - Most of the so-called \"public inputs\" are kept _private_, and never leak\n///     to the outside world, because they are 'swallowed' by the protocol's\n///     kernel circuits before the tx is sent to the network. Only the\n///     following are exposed to the outside world:\n///     - New note_hashes\n///     - New nullifiers\n///     - New private logs\n///     - New L2->L1 messages\n///     - New enqueued public function call requests\n///     All the above-listed arrays of side-effects can be padded by the\n///     user's wallet (through instructions to the kernel circuits, via the\n///     PXE) to obscure their true lengths.\n///\n/// ## Syntax Justification\n///\n/// Both user-defined functions _and_ most functions in aztec-nr need access to\n/// the PrivateContext instance to read/write data. This is why you'll see the\n/// arguably-ugly pervasiveness of the \"context\" throughout your smart contract\n/// and the aztec-nr library.\n/// For example, `&mut context` is prevalent. In some languages, you can access\n/// and mutate a global variable (such as a PrivateContext instance) from a\n/// function without polluting the function's parameters. With Noir, a function\n/// must explicitly pass control of a mutable variable to another function, by\n/// reference. Since many functions in aztec-nr need to be able to push new data\n/// to the PrivateContext, they need to be handed a mutable reference _to_ the\n/// context as a parameter.\n/// For example, `Context` is prevalent as a generic parameter, to give better\n/// type safety at compile time. Many `aztec-nr` functions don't make sense if\n/// they're called in a particular runtime (private, public or utility), and so\n/// are intentionally only implemented over certain\n/// [Private|Public|Utility]Context structs. This gives smart contract\n/// developers a much faster feedback loop if they're making a mistake, as an\n/// error will be thrown by the LSP or when they compile their contract.\n///\n#[derive(Eq)]\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub include_by_timestamp: u64,\n\n    pub note_hash_read_requests: BoundedVec<Counted<Field>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<Counted<Field>, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<Counted<NoteHash>, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Counted<Nullifier>, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<Counted<L2ToL1Message>, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub anchor_block_header: BlockHeader,\n\n    pub private_logs: BoundedVec<Counted<PrivateLogData>, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<Counted<LogHash>, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        let max_allowed_include_by_timestamp = inputs.anchor_block_header.global_variables.timestamp\n            + MAX_INCLUDE_BY_TIMESTAMP_DURATION;\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            include_by_timestamp: max_allowed_include_by_timestamp,\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            anchor_block_header: inputs.anchor_block_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: Since Aztec doesn't have a concept of an EoA (\n    /// Externally-owned Account), the msg_sender is \"null\" for the first\n    /// function call of every transaction.\n    /// The first function call of a tx is likely to be a call to the user's\n    /// account contract, so this quirk will most often be handled by account\n    /// contract developers.\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called\n    ///   this function (be it an app contract or a user's account contract).\n    ///   Returns `Option<AztecAddress>::none` for the first function call of\n    ///   the tx. No other _private_ function calls in the tx will have a `none`\n    ///   msg_sender, but _public_ function calls might (see the PublicContext).\n    ///\n    pub fn msg_sender(self) -> Option<AztecAddress> {\n        let maybe_msg_sender = self.inputs.call_context.msg_sender;\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// \"Unsafe\" versus calling `context.msg_sender()`, because it doesn't\n    /// translate `NULL_MSG_SENDER_CONTRACT_ADDRESS` as\n    /// `Option<AztecAddress>::none`.\n    /// Used by some internal aztecnr functions.\n    pub fn msg_sender_unsafe(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    /// Returns the contract address of the current function being executed.\n    ///\n    /// This is equivalent to `address(this)` in Solidity (hence the name).\n    /// Use this to identify the current contract's address, commonly needed for\n    /// access control or when interacting with other contracts.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The contract address of the current function being\n    ///                    executed.\n    ///\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    /// Returns the chain ID of the current network.\n    ///\n    /// This is similar to `block.chainid` in Solidity. Returns the unique\n    /// identifier for the blockchain network this transaction is executing on.\n    ///\n    /// Helps prevent cross-chain replay attacks. Useful if implementing\n    /// multi-chain contract logic.\n    ///\n    /// # Returns\n    /// * `Field` - The chain ID as a field element\n    ///\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    /// Returns the Aztec protocol version that this transaction is executing\n    /// under. Different versions may have different rules, opcodes, or\n    /// cryptographic primitives.\n    ///\n    /// This is similar to how Ethereum has different EVM versions.\n    ///\n    /// Useful for forward/backward compatibility checks\n    ///\n    /// Not to be confused with contract versions; this is the protocol version.\n    ///\n    /// # Returns\n    /// * `Field` - The protocol version as a field element\n    ///\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    /// Returns the gas settings for the current transaction.\n    ///\n    /// This provides information about gas limits and pricing for the\n    /// transaction, similar to `tx.gasprice` and gas limits in Ethereum.\n    /// However, Aztec has a more sophisticated gas model with separate\n    /// accounting for L2 computation and data availability (DA) costs.\n    ///\n    /// # Returns\n    /// * `GasSettings` - Struct containing gas limits and fee information\n    ///\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    /// Returns the function selector of the currently executing function.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to access this.\n    ///\n    /// This is similar to `msg.sig` in Solidity, which returns the first 4\n    /// bytes of the function signature. In Aztec, the selector uniquely\n    /// identifies which function within the contract is being called.\n    ///\n    /// # Returns\n    /// * `FunctionSelector` - The 4-byte function identifier\n    ///\n    /// # Advanced\n    /// Only #[external(\"private\")] functions have a function selector as a protocol-\n    /// enshrined concept. The function selectors of private functions are\n    /// baked into the preimage of the contract address, and are used by the\n    /// protocol's kernel circuits to identify each private function and ensure\n    /// the correct one is being executed.\n    ///\n    /// Used internally for function dispatch and call verification.\n    ///\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    ///\n    /// Very low-level function: You shouldn't need to call this. The #[external(\"private\")]\n    /// macro calls this, and it makes the arguments neatly available to the\n    /// body of your private function.\n    ///\n    /// # Returns\n    /// * `Field` - Hash of the function arguments\n    ///\n    /// # Advanced\n    /// * Arguments are hashed to reduce proof size and verification time\n    /// * Enables efficient argument passing in recursive function calls\n    /// * The hash can be used to retrieve the original arguments from the PXE.\n    ///\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    /// Pushes a new note_hash to the Aztec blockchain's global Note Hash Tree\n    /// (a state tree).\n    ///\n    /// A note_hash is a commitment to a piece of private state.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new note hashes.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The new note_hash.\n    ///\n    /// # Advanced\n    /// From here, the protocol's kernel circuits will take over and insert the\n    /// note_hash into the protocol's \"note hash tree\" (in the Base Rollup\n    /// circuit).\n    /// Before insertion, the protocol will:\n    /// - \"Silo\" the `note_hash` with the contract address of this function,\n    ///   to yield a `siloed_note_hash`. This prevents state collisions\n    ///   between different smart contracts.\n    /// - Ensure uniqueness of the `siloed_note_hash`, to prevent Faerie-Gold\n    ///   attacks, by hashing the `siloed_note_hash` with a unique value, to\n    ///   yield a `unique_siloed_note_hash` (see the protocol spec for more).\n    ///\n    /// In addition to calling this function, aztec-nr provides the contents\n    /// of the newly-created note to the PXE, via the `notify_created_note`\n    /// oracle.\n    ///\n    /// > Advanced users might occasionally wish to push data to the context\n    /// > directly for lower-level control. If you find yourself doing this,\n    /// > please open an issue on GitHub to describe your use case: it might be\n    /// > that new functionality should be added to aztec-nr.\n    ///\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(Counted::new(note_hash, self.next_counter()));\n    }\n\n    /// Pushes a new nullifier to the Aztec blockchain's global Nullifier Tree\n    /// (a state tree).\n    ///\n    /// See also: `push_nullifier_for_note_hash`.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifiers.\n    ///\n    /// A nullifier can only be emitted once. Duplicate nullifier insertions are\n    /// rejected by the protocol.\n    ///\n    /// Generally, a nullifier is emitted to prevent an action from happening\n    /// more than once, in such a way that the action cannot be linked (by an\n    /// observer of the blockchain) to any earlier transactions.\n    ///\n    /// I.e. a nullifier is a random-looking, but deterministic record of a\n    /// private, one-time action, which does not leak what action has been\n    /// taken, and which preserves the property of \"tx unlinkability\".\n    ///\n    /// Usually, a nullifier will be emitted to \"spend\" a note (a piece of\n    /// private state), without revealing which specific note is being spent.\n    ///\n    /// (Important: in such cases, use the below `push_nullifier_for_note_hash`).\n    ///\n    /// Sometimes, a nullifier might be emitted completely unrelated to any\n    /// notes. Examples include initialization of a new contract; initialization\n    /// of a PrivateMutable, or signalling in Semaphore-like applications.\n    /// This `push_nullifier` function serves such use cases.\n    ///\n    /// # Arguments\n    /// * `nullifier`\n    ///\n    /// # Advanced\n    /// From here, the protocol's kernel circuits will take over and insert the\n    /// nullifier into the protocol's \"nullifier tree\" (in the Base Rollup\n    /// circuit).\n    /// Before insertion, the protocol will:\n    /// - \"Silo\" the `nullifier` with the contract address of this function,\n    ///   to yield a `siloed_nullifier`. This prevents state collisions\n    ///   between different smart contracts.\n    /// - Ensure the `siloed_nullifier` is unique (the nullifier tree is an\n    ///   indexed merkle tree which supports efficient non-membership proofs).\n    ///\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: 0 }.count(self.next_counter()));\n    }\n\n    /// Pushes a nullifier that corresponds to a specific note hash.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifiers.\n    ///\n    /// This is a specialized version of `push_nullifier` that links a nullifier\n    /// to the specific note hash it's nullifying. This is the most common\n    /// usage pattern for nullifiers.\n    /// See `push_nullifier` for more explanation on nullifiers.\n    ///\n    /// # Arguments\n    /// * `nullifier`\n    /// * `nullified_note_hash` - The note hash of the note being nullified\n    ///\n    /// # Advanced\n    /// Important: usage of this function doesn't mean that the world will _see_\n    /// that this nullifier relates to the given nullified_note_hash (as that\n    /// would violate \"tx unlinkability\"); it simply informs the user's PXE\n    /// about the relationship (via `notify_nullified_note`). The PXE can then\n    /// use this information to feed hints to the kernel circuits for\n    /// \"squashing\" purposes: If a note is nullified during the same tx which\n    /// created it, we can \"squash\" (delete) the note and nullifier (and any\n    /// private logs associated with the note), to save on data emission costs.\n    ///\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash }.count(\n            nullifier_counter,\n        ));\n    }\n\n    /// Returns the anchor block header - the historical block header that this\n    /// private function is reading from.\n    ///\n    /// A private function CANNOT read from the \"current\" block header,\n    /// but must read from some older block header, because as soon as\n    /// private function execution begins (asynchronously, on a user's device),\n    /// the public state of the chain (the \"current state\") will have progressed\n    /// forward.\n    ///\n    /// # Returns\n    /// * `BlockHeader` - The anchor block header.\n    ///\n    /// # Advanced\n    /// * All private functions of a tx read from the same anchor block header.\n    /// * The protocol asserts that the `include_by_timestamp` of every tx\n    ///   is at most 24 hours beyond the timestamp of the tx's chosen anchor\n    ///   block header. This enables the network's nodes to safely prune old txs\n    ///   from the mempool. Therefore, the chosen block header _must_ be one\n    ///   from within the last 24 hours.\n    ///\n    pub fn get_anchor_block_header(self) -> BlockHeader {\n        self.anchor_block_header\n    }\n\n    /// Returns the header of any historical block at or before the anchor\n    /// block.\n    ///\n    /// This enables private contracts to access information from even older\n    /// blocks than the anchor block header.\n    ///\n    /// Useful for time-based contract logic that needs to compare against\n    /// multiple historical points.\n    ///\n    /// # Arguments\n    /// * `block_number` - The block number to retrieve (must be <= anchor\n    ///                    block number)\n    ///\n    /// # Returns\n    /// * `BlockHeader` - The header of the requested historical block\n    ///\n    /// # Advanced\n    /// This function uses an oracle to fetch block header data from the user's\n    /// PXE. Depending on how much blockchain data the user's PXE has been set\n    /// up to store, this might require a query from the PXE to another Aztec\n    /// node to get the data.\n    /// > This is generally true of all oracle getters (see `../oracle`).\n    ///\n    /// Each block header gets hashed and stored as a leaf in the protocol's\n    /// Archive Tree. In fact, the i-th block header gets stored at the i-th\n    /// leaf index of the Archive Tree. Behind the scenes, this\n    /// `get_block_header_at` function will add Archive Tree merkle-membership\n    /// constraints (~3k) to your smart contract function's circuit, to prove\n    /// existence of the block header in the Archive Tree.\n    ///\n    /// Note: we don't do any caching, so avoid making duplicate calls for the\n    /// same block header, because each call will add duplicate constraints.\n    ///\n    /// Calling this function is more expensive (constraint-wise) than getting\n    /// the anchor block header (via `get_block_header`). This is because the\n    /// anchor block's merkle membership proof is handled by Aztec's protocol\n    /// circuits, and is only performed once for the entire tx because all\n    /// private functions of a tx share a common anchor block header. Therefore,\n    /// the cost (constraint-wise) of calling `get_block_header` is effectively\n    /// free.\n    ///\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    /// Sets the hash of the return values for this private function.\n    ///\n    /// Very low-level function: this is called by the #[external(\"private\")] macro.\n    ///\n    /// # Arguments\n    /// * `serialized_return_values` - The serialized return values as a field array\n    ///\n    pub fn set_return_hash<let N: u32>(&mut self, serialized_return_values: [Field; N]) {\n        let return_hash = hash_args_array(serialized_return_values);\n        self.return_hash = return_hash;\n        execution_cache::store(serialized_return_values, return_hash);\n    }\n\n    /// Builds the PrivateCircuitPublicInputs for this private function, to\n    /// ensure compatibility with the protocol's kernel circuits.\n    ///\n    /// Very low-level function: This function is automatically called by the\n    /// #[external(\"private\")] macro.\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            include_by_timestamp: self.include_by_timestamp,\n            note_hash_read_requests: ClaimedLengthArray::from_bounded_vec(\n                self.note_hash_read_requests,\n            ),\n            nullifier_read_requests: ClaimedLengthArray::from_bounded_vec(\n                self.nullifier_read_requests,\n            ),\n            key_validation_requests_and_generators: ClaimedLengthArray::from_bounded_vec(\n                self.key_validation_requests_and_generators,\n            ),\n            note_hashes: ClaimedLengthArray::from_bounded_vec(self.note_hashes),\n            nullifiers: ClaimedLengthArray::from_bounded_vec(self.nullifiers),\n            private_call_requests: ClaimedLengthArray::from_bounded_vec(self.private_call_requests),\n            public_call_requests: ClaimedLengthArray::from_bounded_vec(self.public_call_requests),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: ClaimedLengthArray::from_bounded_vec(self.l2_to_l1_msgs),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: ClaimedLengthArray::from_bounded_vec(self.private_logs),\n            contract_class_logs_hashes: ClaimedLengthArray::from_bounded_vec(\n                self.contract_class_logs_hashes,\n            ),\n            anchor_block_header: self.anchor_block_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    /// Designates this contract as the fee payer for the transaction.\n    ///\n    /// Unlike Ethereum, where the transaction sender always pays fees, Aztec\n    /// allows any contract to voluntarily pay transaction fees. This enables\n    /// patterns like sponsored transactions or fee abstraction where users\n    /// don't need to hold fee-juice themselves. (Fee juice is a fee-paying\n    /// asset for Aztec).\n    ///\n    /// Only one contract per transaction can declare itself as the fee payer,\n    /// and it must have sufficient fee-juice balance (>= the gas limits\n    /// specified in the TxContext) by the time we reach the public setup phase\n    /// of the tx.\n    ///\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    /// Declares the end of the \"setup phase\" of this tx.\n    ///\n    /// Only one function per tx can declare the end of the setup phase.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase enables such a payment to\n    /// be made, because the setup phase _cannot revert_: a reverting function\n    /// within the setup phase would result in an invalid block which cannot\n    /// be proven. Any side-effects generated during that phase are guaranteed\n    /// to be inserted into Aztec's state trees (except for squashed notes &\n    /// nullifiers, of course).\n    ///\n    /// Even though the end of the setup phase is declared within a private\n    /// function, you might have noticed that _public_ functions can also\n    /// execute within the setup phase. This is because any public function\n    /// calls which were enqueued _within the setup phase_ by a private\n    /// function are considered part of the setup phase.\n    ///\n    /// # Advanced\n    /// * Sets the minimum revertible side effect counter of this tx to be the\n    /// PrivateContext's _current_ side effect counter.\n    ///\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    /// Sets a deadline (an \"include-by timestamp\") for when this transaction\n    /// must be included in a block.\n    ///\n    /// Other functions in this tx might call this setter with differing\n    /// values for the include-by timestamp. To ensure that all functions'\n    /// deadlines are met, the _minimum_ of all these include-by timestamps will\n    /// be exposed when this tx is submitted to the network.\n    ///\n    /// If the transaction is not included in a block by its include-by\n    /// timestamp, it becomes invalid and it will never be included.\n    ///\n    /// This expiry timestamp is publicly visible. See the \"Advanced\" section\n    /// for privacy concerns.\n    ///\n    /// # Arguments\n    /// * `include_by_timestamp` - Unix timestamp (seconds) deadline for inclusion.\n    ///                            The include-by timestamp of this tx will be\n    ///                            _at most_ the timestamp specified.\n    ///\n    /// # Advanced\n    /// * If multiple functions set differing `include_by_timestamp`s, the\n    ///   kernel circuits will set it to be the _minimum_ of the two. This\n    ///   ensures the tx expiry requirements of all functions in the tx are met.\n    /// * Rollup circuits will reject expired txs.\n    /// * The protocol enforces that all transactions must be included within\n    ///   24 hours of their chosen anchor block's timestamp, to enable safe\n    ///   mempool pruning.\n    /// * The DelayedPublicMutable design makes heavy use of this functionality,\n    ///   to enable private functions to read public state.\n    /// * A sophisticated Wallet should cleverly set an include-by timestamp\n    ///   to improve the privacy of the user and the network as a whole.\n    ///   For example, if a contract interaction sets include-by to some\n    ///   publicly-known value (e.g. the time when a contract upgrades), then\n    ///   the wallet might wish to set an even lower one to avoid revealing that\n    ///   this tx is interacting with said contract.\n    ///   Ideally, all wallets should standardise on an approach in order to\n    ///   provide users with a large anonymity set -- although the exact apprach\n    ///   will need to be discussed. Wallets that deviate from a standard might\n    ///   accidentally reveal which wallet each transaction originates from.\n    ///\n    // docs:start:include-by-timestamp\n    pub fn set_include_by_timestamp(&mut self, include_by_timestamp: u64) {\n        // docs:end:include-by-timestamp\n        self.include_by_timestamp = std::cmp::min(self.include_by_timestamp, include_by_timestamp);\n    }\n\n    /// Makes a request to the protocol's kernel circuit to ensure a note_hash\n    /// actually exists.\n    ///\n    /// \"Read requests\" are used to prove that a note hash exists without\n    /// revealing which specific note was read.\n    ///\n    /// This can be used to prove existence of both settled notes (created in\n    /// prior transactions) and transient notes (created in the current\n    /// transaction).\n    /// If you need to prove existence of a settled note _at a specific block\n    /// number_, use `note_inclusion::prove_note_inclusion`.\n    ///\n    /// Low-level function. Ordinarily, smart contract developers will not need\n    /// to call this directly. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new note_hash read\n    /// requests.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The note hash to read and verify\n    ///\n    /// # Advanced\n    /// In \"traditional\" circuits for non-Aztec privacy applications, the merkle\n    /// membership proofs to check existence of a note are performed _within_\n    /// the application circuit.\n    ///\n    /// All Aztec private functions have access to the following constraint\n    /// optimisation:\n    /// In cases where the note being read was created earlier in the same tx,\n    /// the note wouldn't yet exist in the Note Hash Tree, so a hard-coded\n    /// merkle membership check which then gets ignored would be a waste of\n    /// constraints.\n    /// Instead, we can send read requests for all notes to the protocol's\n    /// kernel circuits, where we can conditionally assess which notes actually\n    /// need merkle membership proofs, and select an appropriately-sized\n    /// kernel circuit.\n    ///\n    /// For \"settled notes\" (which already existed in the Note Hash Tree of the\n    /// anchor block (i.e. before the tx began)), the kernel does a merkle\n    /// membership check.\n    ///\n    /// For \"pending notes\" (which were created earlier in _this_ tx), the\n    /// kernel will check that the note existed _before_ this read request was\n    /// made, by checking the side-effect counters of the note_hash and this\n    /// read request.\n    ///\n    /// This approach improves latency between writes and reads:\n    /// a function can read a note which was created earlier in the tx (rather\n    /// than performing the read in a later tx, after waiting for the earlier tx\n    /// to be included, to ensure the note is included in the tree).\n    ///\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = Counted::new(note_hash, self.next_counter());\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    /// Requests to read a specific nullifier from the nullifier tree.\n    ///\n    /// Nullifier read requests are used to prove that a nullifier exists without\n    /// revealing which specific nullifier preimage was read.\n    ///\n    /// This can be used to prove existence of both settled nullifiers (created in\n    /// prior transactions) and transient nullifiers (created in the current\n    /// transaction).\n    /// If you need to prove existence of a settled nullifier _at a specific block\n    /// number_, use `nullifier_inclusion::prove_nullifier_inclusion`.\n    ///\n    /// Low-level function. Ordinarily, smart contract developers will not need\n    /// to call this directly. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifier read\n    /// requests.\n    ///\n    /// # Arguments\n    /// * `nullifier` - The nullifier to read and verify\n    ///\n    /// # Advanced\n    /// This approach improves latency between writes and reads:\n    /// a function can read a nullifier which was created earlier in the tx\n    /// (rather than performing the read in a later tx, after waiting for the\n    /// earlier tx to be included, to ensure the note is included in the tree).\n    ///\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = Counted::new(nullifier, self.next_counter());\n        self.nullifier_read_requests.push(request);\n    }\n\n    /// Requests the app-siloed nullifier secret key (nsk_app) for the given\n    /// (hashed) master nullifier public key (npk_m), from the user's PXE.\n    ///\n    /// Advanced function: Only needed if you're designing your own notes and/or\n    /// nullifiers.\n    ///\n    /// Contracts are not allowed to compute nullifiers for other contracts, as\n    /// that would let them read parts of their private state. Because of this,\n    /// a contract is only given an \"app-siloed secret key\", which is\n    /// constructed by hashing the user's master nullifier secret key with the\n    /// contract's address.\n    /// However, because contracts cannot be trusted with a user's master\n    /// nullifier secret key (because we don't know which contracts are honest\n    /// or malicious), the PXE refuses to provide any master secret keys to\n    /// any app smart contract function. This means app functions are unable to\n    /// prove that the derivation of an app-siloed nullifier secret key has been\n    /// computed correctly. Instead, an app function can request to the kernel\n    /// (via `request_nsk_app`) that it validates the siloed derivation, since\n    /// the kernel has been vetted to not leak any master secret keys.\n    ///\n    /// A common nullification scheme is to inject a nullifier secret key into\n    /// the preimage of a nullifier, to make the nullifier deterministic but\n    /// random-looking. This function enables that flow.\n    ///\n    /// # Arguments\n    /// * `npk_m_hash` - A hash of the master nullifier public key of the user\n    ///                  whose PXE is executing this function.\n    ///\n    /// # Returns\n    /// * The app-siloed nullifier secret key that corresponds to the given\n    ///   `npk_m_hash`.\n    ///\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    /// Requests the app-siloed nullifier secret key (nsk_app) for the given\n    /// (hashed) master nullifier public key (npk_m), from the user's PXE.\n    ///\n    /// See `request_nsk_app` and `request_sk_app` for more info.\n    ///\n    /// The intention of the \"outgoing\" keypair is to provide a second secret\n    /// key for all of a user's outgoing activity (i.e. for notes that a user\n    /// creates, as opposed to notes that a user receives from others). The\n    /// separation of incoming and outgoing data was a distinction made by\n    /// zcash, with the intention of enabling a user to optionally share with a\n    /// 3rd party a controlled view of only incoming or outgoing notes.\n    /// Similar functionality of sharing select data can be achieved with\n    /// offchain zero-knowledge proofs. It is up to an app developer whether\n    /// they choose to make use of a user's outgoing keypair within their\n    /// application logic, or instead simply use the same keypair (the address\n    /// keypair (which is effectively the same as the \"incooming\" keypair)) for\n    /// all incoming & outgoing messages to a user.\n    ///\n    /// Currently, all of the exposed encryption functions in aztec-nr ignore\n    /// the outgoing viewing keys, and instead encrypt all note logs and event\n    /// logs to a user's address public key.\n    ///\n    /// # Arguments\n    /// * `ovpk_m_hash` - Hash of the outgoing viewing public key master\n    ///\n    /// # Returns\n    /// * The application-specific outgoing viewing secret key\n    ///\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    /// Pushes a Key Validation Request to the kernel.\n    ///\n    /// Private functions are not allowed to see a user's master secret keys,\n    /// because we do not trust them. They are instead given \"app-siloed\" secret\n    /// keys with a claim that they relate to a master public key.\n    /// They can then request validation of this claim, by making a \"key\n    /// validation request\" to the protocol's kernel circuits (which _are_\n    /// allowed to see certain master secret keys).\n    ///\n    /// When a Key Validation Request tuple of (sk_app, Pk_m, app_address) is\n    /// submitted to the kernel, it will perform the following derivations\n    /// to validate the relationship between the claimed sk_app and the user's\n    /// Pk_m:\n    ///\n    ///       (sk_m) ----> * G ----> Pk_m\n    ///         |                     |\n    ///         v                       We use the kernel to prove this\n    ///  h(sk_m, app_address)         | sk_app-Pk_m relationship, because app\n    ///         |                       circuits must not be trusted to see sk_m.\n    ///         v                     |\n    ///      sk_app - -  - - - - - - -\n    ///\n    /// The function is named \"request_\" instead of \"get_\" to remind the user\n    /// that a Key Validation Request will be emitted to the kernel.\n    ///\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    /// Sends an \"L2 -> L1 message\" from this function (Aztec, L2) to a smart\n    /// contract on Ethereum (L1). L1 contracts which are designed to\n    /// send/receive messages to/from Aztec are called \"Portal Contracts\".\n    ///\n    /// Common use cases include withdrawals, cross-chain asset transfers, and\n    /// triggering L1 actions based on L2 state changes.\n    ///\n    /// The message will be inserted into an Aztec \"Outbox\" contract on L1,\n    /// when this transaction's block is proposed to L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target portal contract. The message will need to be manually\n    /// consumed from the Outbox through a separate Ethereum transaction: a user\n    /// will need to call a function of the portal contract -- a function\n    /// specifically designed to make a call to the Outbox to consume the\n    /// message.\n    /// The message will only be available for consumption once the _epoch_\n    /// proof has been submitted. Given that there are multiple Aztec blocks\n    /// within an epoch, it might take some time for this epoch proof to be\n    /// submitted -- especially if the block was near the start of an epoch.\n    ///\n    /// # Arguments\n    /// * `recipient` - Ethereum address that will receive the message\n    /// * `content` - Message content (32 bytes as a Field element).\n    ///               This content has a very specific layout.\n    /// docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        let message = L2ToL1Message { recipient, content };\n        self.l2_to_l1_msgs.push(message.count(self.next_counter()));\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2).\n    ///\n    /// Common use cases include token bridging, cross-chain governance, and\n    /// triggering L2 actions based on L1 events.\n    ///\n    /// Use this function if you only want the message to ever be \"referred to\"\n    /// once. Once consumed using this method, the message cannot be consumed\n    /// again, because a nullifier is emitted.\n    /// If your use case wants for the message to be read unlimited times, then\n    /// you can always read any historic message from the L1-to-L2 messages tree;\n    /// messages never technically get deleted from that tree.\n    ///\n    /// The message will first be inserted into an Aztec \"Inbox\" smart contract\n    /// on L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target L2 contract. The message will need to be manually\n    /// consumed by the target contract through a separate Aztec transaction.\n    /// The message will not be available for consumption immediately. Messages\n    /// get copied over from the L1 Inbox to L2 by the next Proposer in batches.\n    /// So you will need to wait until the messages are copied before you can\n    /// consume them.\n    ///\n    /// # Arguments\n    /// * `content` - The message content that was sent from L1\n    /// * `secret` - Secret value used for message privacy (if needed)\n    /// * `sender` - Ethereum address that sent the message\n    /// * `leaf_index` - Index of the message in the L1-to-L2 message tree\n    ///\n    /// # Advanced\n    /// Validates message existence in the L1-to-L2 message tree and nullifies\n    /// the message to prevent double-consumption.\n    ///\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let nullifier = process_l1_to_l2_message(\n            self.anchor_block_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n\n    /// Emits a private log (an array of Fields) that will be published to an\n    /// Ethereum blob.\n    ///\n    /// Private logs are intended for the broadcasting of ciphertexts: that is,\n    /// encrypted events or encrypted note contents.\n    /// Since the data in the logs is meant to be _encrypted_, private_logs are\n    /// broadcast to publicly-visible Ethereum blobs.\n    /// The intended recipients of such encrypted messages can then discover and\n    /// decrypt these encrypted logs using their viewing secret key.\n    /// (See `../messages/discovery` for more details).\n    ///\n    /// Important note: This function DOES NOT _do_ any encryption of the input\n    /// `log` fields. This function blindly publishes whatever input `log` data\n    /// is fed into it, so the caller of this function should have already\n    /// performed the encryption, and the `log` should be the result of that\n    /// encryption.\n    ///\n    /// The protocol does not dictate what encryption scheme should be used:\n    /// a smart contract developer can choose whatever encryption scheme they\n    /// like.\n    /// Aztec-nr includes some off-the-shelf encryption libraries that\n    /// developers might wish to use, for convenience. These libraries not only\n    /// encrypt a plaintext (to produce a ciphertext); they also prepend the\n    /// ciphertext with a `tag` and `ephemeral public key` for easier message\n    /// discovery. This is a very dense topic, and we will be writing more\n    /// libraries and docs soon.\n    ///\n    /// > Currently, AES128 CBC encryption is the main scheme included in\n    /// > aztec.nr.\n    /// > We are currently making significant changes to the interfaces of the\n    /// > encryption library.\n    ///\n    /// In some niche use cases, an app might be tempted to publish\n    /// _un-encrypted_ data via a private log, because _public logs_ are not\n    /// available to private functions. Be warned that emitting public data via\n    /// private logs is strongly discouraged, and is considered a \"privacy\n    /// anti-pattern\", because it reveals identifiable information about _which_\n    /// function has been executed. A tx which leaks such information does not\n    /// contribute to the privacy set of the network.\n    ///\n    /// * Unlike `emit_raw_note_log`, this log is not tied to any specific note\n    ///\n    /// # Arguments\n    /// * `log` - The log data that will be publicly broadcast (so make sure\n    ///           it's already been encrypted before you call this function).\n    ///   Private logs are bounded in size (PRIVATE_LOG_SIZE_IN_FIELDS), to\n    ///   encourage all logs from all smart contracts look identical.\n    /// * `length` - The actual length of the `log` (measured in number of\n    ///              Fields). Although the input log has a max size of\n    ///   PRIVATE_LOG_SIZE_IN_FIELDS, the latter values of the array might all\n    ///   be 0's for small logs. This `length` should reflect the trimmed length\n    ///   of the array. The protocol's kernel circuits can then append random\n    ///   fields as \"padding\" after the `length`, so that the logs of this\n    ///   smart contract look indistinguishable from (the same length as) the\n    ///   logs of all other applications. It's up to wallets how much padding\n    ///   to apply, so ideally all wallets should agree on standards for this.\n    ///\n    /// # Advanced\n    ///\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS], length: u32) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter: 0 }\n            .count(counter);\n        self.private_logs.push(private_log);\n    }\n\n    // TODO: rename.\n    /// Emits a private log that is explicitly tied to a newly-emitted note_hash,\n    /// to convey to the kernel: \"this log relates to this note\".\n    ///\n    /// This linkage is important in case the note gets squashed (due to being\n    /// read later in this same tx), since we can then squash the log as well.\n    ///\n    /// See `emit_private_log` for more info about private log emission.\n    ///\n    /// # Arguments\n    /// * `log` - The log data as an array of Field elements\n    /// * `length` - The actual length of the `log` (measured in number of\n    ///              Fields).\n    /// * `note_hash_counter` - The side-effect counter that was assigned to the\n    ///                         new note_hash when it was pushed to this\n    //                          `PrivateContext`.\n    ///\n    /// Important: If your application logic requires the log to always be\n    /// emitted regardless of note squashing, consider using `emit_private_log`\n    /// instead, or emitting additional events.\n    ///\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        length: u32,\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter };\n        self.private_logs.push(private_log.count(counter));\n    }\n\n    pub fn emit_contract_class_log<let N: u32>(&mut self, log: [Field; N]) {\n        let contract_address = self.this_address();\n        let counter = self.next_counter();\n\n        let log_to_emit: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS] =\n            log.concat([0; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS - N]);\n        // Note: the length is not always N, it is the number of fields we want to broadcast, omitting trailing zeros to save blob space.\n        // Safety: The below length is constrained in the base rollup, which will make sure that all the fields beyond length are zero.\n        // However, it won't be able to check that we didn't add extra padding (trailing zeroes)\n        let length = unsafe { trimmed_array_length_hint(log_to_emit) };\n        // We hash the entire padded log to ensure a user cannot pass a shorter length and so emit incorrect shorter bytecode.\n        let log_hash = poseidon2_hash(log_to_emit);\n        // Safety: the below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\n        unsafe {\n            notify_created_contract_class_log(contract_address, log_to_emit, length, counter);\n        }\n\n        self.contract_class_logs_hashes.push(LogHash { value: log_hash, length: length }.count(\n            counter,\n        ));\n    }\n\n    /// Calls a private function on another contract (or the same contract).\n    ///\n    /// Very low-level function.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the called function\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    /// This enables contracts to interact with each other while maintaining\n    /// privacy. This \"composability\" of private contract functions is a key\n    /// feature of the Aztec network.\n    ///\n    /// If a user's transaction includes multiple private function calls, then\n    /// by the design of Aztec, the following information will remain private[1]:\n    /// - The function selectors and contract addresses of all private function\n    ///   calls will remain private, so an observer of the public mempool will\n    ///   not be able to look at a tx and deduce which private functions have\n    ///   been executed.\n    /// - The arguments and return values of all private function calls will\n    ///   remain private.\n    /// - The person who initiated the tx will remain private.\n    /// - The notes and nullifiers and private logs that are emitted by all\n    ///   private function calls will (if designed well) not leak any user\n    ///   secrets, nor leak which functions have been executed.\n    ///\n    /// [1] Caveats: Some of these privacy guarantees depend on how app\n    /// developers design their smart contracts. Some actions _can_ leak\n    /// information, such as:\n    /// - Calling an internal public function.\n    /// - Calling a public function and not setting msg_sender to Option::none\n    ///   (feature not built yet - see github).\n    /// - Calling any public function will always leak details about the nature\n    ///   of the transaction, so devs should be careful in their contract\n    ///   designs. If it can be done in a private function, then that will give\n    ///   the best privacy.\n    /// - Not padding the side-effects of a tx to some standardised, uniform\n    ///   size. The kernel circuits can take hints to pad side-effects, so a\n    ///   wallet should be able to request for a particular amount of padding.\n    ///   Wallets should ideally agree on some standard.\n    ///   - Padding should include:\n    ///     - Padding the lengths of note & nullifier arrays\n    ///     - Padding private logs with random fields, up to some standardised\n    ///       size.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Advanced\n    /// * The call is added to the private call stack and executed by kernel\n    ///   circuits after this function completes\n    /// * The called function can modify its own contract's private state\n    /// * Side effects from the called function are included in this transaction\n    /// * The call inherits the current transaction's context and gas limits\n    ///\n    pub fn call_private_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    /// Makes a read-only call to a private function on another contract.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L2 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// See `call_private_function` for more general info on private function\n    /// calls.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the called function\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn static_call_private_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    /// Calls a private function that takes no arguments.\n    ///\n    /// This is a convenience function for calling private functions that don't\n    /// require any input parameters. It's equivalent to `call_private_function`\n    /// but slightly more efficient to use when no arguments are needed.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    /// Makes a read-only call to a private function which takes no arguments.\n    ///\n    /// This combines the optimisation of `call_private_function_no_args` with\n    /// the safety of `static_call_private_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    /// Low-level private function call.\n    ///\n    /// This is the underlying implementation used by all other private function\n    /// call methods. Instead of taking raw arguments, it accepts a\n    /// hash of the arguments.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args_hash` - Pre-computed hash of the function arguments\n    /// * `is_static_call` - Whether this should be a read-only call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values\n    ///\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1; // TODO: call `next_counter` instead, for consistency\n        ReturnsHash::new(returns_hash)\n    }\n\n    /// Enqueues a call to a public function to be executed later.\n    ///\n    /// Unlike private functions which execute immediately on the user's device,\n    /// public function calls are \"enqueued\" and executed some time later by a\n    /// block proposer.\n    ///\n    /// This means a public function cannot return any values back to a private\n    /// function, because by the time the public function is being executed,\n    /// the private function which called it has already completed execution.\n    /// (In fact, the private function has been executed and proven, along with\n    /// all other private function calls of the user's tx. A single proof of the\n    /// tx has been submitted to the Aztec network, and some time later a\n    /// proposer has picked the tx up from the mempool and begun executing all\n    /// of the enqueued public functions).\n    ///\n    /// # Privacy warning\n    /// Enqueueing a public function call is an inherently leaky action.\n    /// Many interesting applications will require some interaction with public\n    /// state, but smart contract developers should try to use public function\n    /// calls sparingly, and carefully.\n    /// _Internal_ public function calls are especially leaky, because they\n    /// completely leak which private contract made the call.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the public function\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn call_public_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n        hide_msg_sender: bool,\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a read-only call to a public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// See also `call_public_function` for more important information about\n    /// making private -> public function calls.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the public function\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn static_call_public_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n        hide_msg_sender: bool,\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            true,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a call to a public function that takes no arguments.\n    ///\n    /// This is an optimisation for calling public functions that don't\n    /// take any input parameters. It's otherwise equivalent to\n    /// `call_public_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        hide_msg_sender: bool,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a read-only call to a public function with no arguments.\n    ///\n    /// This combines the optimisation of `call_public_function_no_args` with\n    /// the safety of `static_call_public_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        hide_msg_sender: bool,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            true,\n            hide_msg_sender,\n        )\n    }\n\n    /// Low-level public function call.\n    ///\n    /// This is the underlying implementation used by all other public function\n    /// call methods. Instead of taking raw arguments, it accepts a\n    /// hash of the arguments.\n    ///\n    /// Advanced function: Most developers should use `call_public_function`\n    /// or `static_call_public_function` instead. This function is exposed for\n    /// performance optimization and advanced use cases.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `calldata_hash` - Hash of the function calldata\n    /// * `is_static_call` - Whether this should be a read-only call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n        hide_msg_sender: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let msg_sender = if hide_msg_sender {\n            NULL_MSG_SENDER_CONTRACT_ADDRESS\n        } else {\n            self.this_address()\n        };\n\n        let call_request =\n            PublicCallRequest { msg_sender, contract_address, is_static_call, calldata_hash };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    /// Enqueues a public function call, and designates it to be the teardown\n    /// function for this tx. Only one teardown function call can be made by a\n    /// tx.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase ensures the fee payer\n    /// has sufficient balance to pay the proposer their fees.\n    /// The teardown phase is primarily intended to: calculate exactly\n    /// how much the user owes, based on gas consumption, and refund the user\n    /// any change.\n    ///\n    /// Note: in some cases, the cost of refunding the user (i.e. DA costs of\n    /// tx side-effects) might exceed the refund amount. For app logic with\n    /// fairly stable and predictable gas consumption, a material refund amount\n    /// is unlikely. For app logic with unpredictable gas consumption, a\n    /// refund might be important to the user (e.g. if a hefty function reverts\n    /// very early). Wallet/FPC/Paymaster developers should be mindful of this.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the teardown\n    ///                        function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - An array of fields to pass to the function.\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    pub fn set_public_teardown_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n        hide_msg_sender: bool,\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n\n    /// Low-level function to set the public teardown function.\n    ///\n    /// This is the underlying implementation for setting the teardown function\n    /// call that will execute at the end of the transaction. Instead of taking\n    /// raw arguments, it accepts a hash of the arguments.\n    ///\n    /// Advanced function: Most developers should use\n    /// `set_public_teardown_function` instead.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the teardown\n    ///                        function\n    /// * `calldata_hash` - Hash of the function calldata\n    /// * `is_static_call` - Whether this should be a read-only call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n        hide_msg_sender: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let msg_sender = if hide_msg_sender {\n            NULL_MSG_SENDER_CONTRACT_ADDRESS\n        } else {\n            self.this_address()\n        };\n\n        self.public_teardown_call_request =\n            PublicCallRequest { msg_sender, contract_address, is_static_call, calldata_hash };\n    }\n\n    /// Increments the side-effect counter.\n    ///\n    /// Very low-level function.\n    ///\n    /// # Advanced\n    ///\n    /// Every side-effect of a private function is given a \"side-effect counter\",\n    /// based on when it is created. This PrivateContext is in charge of\n    /// assigning the counters.\n    ///\n    /// The reason we have side-effect counters is complicated. Consider this\n    /// illustrative pseudocode of inter-contract function calls:\n    /// ```\n    /// contract A {\n    ///    let x = 5; // pseudocode for storage var x.\n    ///    fn a1 {\n    ///        read x; // value: 5, counter: 1.\n    ///        x = x + 1;\n    ///        write x; // value: 6, counter: 2.\n    ///\n    ///        B.b(); // start_counter: 2, end_counter: 4\n    ///\n    ///        read x; // value: 36, counter: 5.\n    ///        x = x + 1;\n    ///        write x; // value: 37, counter: 6.\n    ///    }\n    ///\n    ///    fn a2 {\n    ///        read x; // value: 6, counter: 3.\n    ///        x = x * x;\n    ///        write x; // value: 36, counter: 4.\n    ///    }\n    /// }\n    ///\n    /// contract B {\n    ///     fn b() {\n    ///         A.a2();\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// Suppose a1 is the first function called. The comments show the execution\n    /// counter of each side-effect, and what the new value of `x` is.\n    ///\n    /// These (private) functions are processed by Aztec's kernel circuits in an\n    /// order that is different from execution order:\n    /// All of A.a1 is proven before B.b is proven, before A.a2 is proven.\n    /// So when we're in the 2nd execution frame of A.a1 (after the call to\n    /// B.b), the circuit needs to justify why x went from being `6` to `36`.\n    /// But the circuit doesn't know why, and given the order of proving, the\n    /// kernel hasn't _seen_ a value of 36 get written yet.\n    /// The kernel needs to track big arrays of all side-effects of all\n    /// private functions in a tx. Then, as it recurses and processes B.b(), it\n    /// will eventually see a value of 36 get written.\n    ///\n    /// Suppose side-effect counters weren't exposed:\n    /// The kernel would only see this ordering (in order of proof verification):\n    /// [ A.a1.read, A.a1.write, A.a1.read, A.a1.write, A.a2.read, A.a2.write ]\n    /// [         5,          6,        36,         37,         6,         36 ]\n    /// The kernel wouldn't know _when_ B.b() was called within A.a1(), because\n    /// it can't see what's going on within an app circuit. So the kernel\n    /// wouldn't know that the ordering of reads and writes should actually be:\n    /// [ A.a1.read, A.a1.write, A.a2.read, A.a2.write, A.a1.read, A.a1.write ]\n    /// [         5,          6,        6,         36,         36,         37 ]\n    ///\n    /// And so, we introduced side-effect counters: every private function must\n    /// assign side-effect counters alongside every side-effect that it emits,\n    /// and also expose to the kernel the counters that it started and ended\n    /// with.\n    /// This gives the kernel enough information to arrange all side-effects in\n    /// the correct order.\n    /// It can then catch (for example) if a function tries to read state\n    /// before it has been written (e.g. if A.a2() maliciously tried to read\n    /// a value of x=37) (e.g. if A.a1() maliciously tried to read x=6).\n    ///\n    /// If a malicious app contract _lies_ and does not count correctly:\n    /// - It cannot lie about its start and end counters because the kernel\n    ///   will catch this.\n    /// - It _could_ lie about its intermediate counters:\n    ///   - 1. It could not increment its side-effects correctly\n    ///   - 2. It could label its side-effects with counters outside of its\n    ///        start and end counters' range.\n    ///   The kernel will catch 2.\n    ///   The kernel will not catch 1., but this would only cause corruption\n    ///   to the private state of the malicious contract, and not any other\n    ///   contracts (because a contract can only modify its own state). If\n    ///   a \"good\" contract is given _read access_ to a maliciously-counting\n    ///   contract (via an external getter function, or by reading historic\n    ///   state from the archive tree directly), and they then make state\n    ///   changes to their _own_ state accordingly, that could be dangerous.\n    ///   Developers should be mindful not to trust the claimed innards of\n    ///   external contracts unless they have audited/vetted the contracts\n    ///   including vetting the side-effect counter incrementation.\n    ///   This is a similar paradigm to Ethereum smart contract development:\n    ///   you must vet external contracts that your contract relies upon, and\n    ///   you must not make any presumptions about their claimed behaviour.\n    ///   (Hopefully if a contract imports a version of aztec-nr, we will get\n    ///   contract verification tooling that can validate the authenticity\n    ///   of the imported aztec-nr package, and hence infer that the side-\n    ///   effect counting will be correct, without having to re-audit such logic\n    ///   for every contract).\n    ///\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            include_by_timestamp: 0,\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            anchor_block_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "71": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::{MAX_U32_VALUE, NULL_MSG_SENDER_CONTRACT_ADDRESS};\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\n/// # PublicContext\n///\n/// The **main interface** between an #[external(\"public\")] function and the Aztec blockchain.\n///\n/// An instance of the PublicContext is initialized automatically at the outset\n/// of every public function, within the #[external(\"public\")] macro, so you'll never\n/// need to consciously instantiate this yourself.\n///\n/// The instance is always named `context`, and it will always be available\n/// within the body of every #[external(\"public\")] function in your smart contract.\n///\n/// Typical usage for a smart contract developer will be to call getter\n/// methods of the PublicContext.\n///\n/// _Pushing_ data and requests to the context is mostly handled within\n/// aztec-nr's own functions, so typically a smart contract developer won't\n/// need to call any setter methods directly.\n///\n/// ## Responsibilities\n/// - Exposes contextual data to a public function:\n///   - Data relating to how this public function was called:\n///     - msg_sender, this_address\n///   - Data relating to the current blockchain state:\n///     - timestamp, block_number, chain_id, version\n///   - Gas and fee information\n/// - Provides state access:\n///   - Read/write public storage (key-value mapping)\n///   - Check existence of notes and nullifiers\n///     (Some patterns use notes & nullifiers to store public (not private)\n///     information)\n///   - Enables consumption of L1->L2 messages.\n/// - Enables calls to other public smart contract functions:\n/// - Writes data to the blockchain:\n///   - Updates to public state variables\n///   - New public logs (for events)\n///   - New L2->L1 messages\n///   - New notes & nullifiers\n///     (E.g. pushing public info to notes/nullifiers, or for completing\n///     \"partial notes\")\n///\n/// ## Key Differences from Private Execution\n///\n/// Unlike private functions -- which are executed on the user's device and which\n/// can only reference historic state -- public functions are executed by a block\n/// proposer and are executed \"live\" on the _current_ tip of the chain.\n/// This means public functions can:\n/// - Read and write _current_ public state\n/// - Immediately see the effects of earlier transactions in the same block\n///\n/// Also, public functions are executed within a zkVM (the \"AVM\"), so that they\n/// can _revert_ whilst still ensuring payment to the proposer and prover.\n/// (Private functions cannot revert: they either succeed, or they cannot be\n/// included).\n///\n/// ## Optimising Public Functions\n///\n/// Using the AVM to execute public functions means they compile down to \"AVM\n/// bytecode\" instead of the ACIR that private functions (standalone circuits)\n/// compile to. Therefore the approach to optimising a public function is\n/// fundamentally different from optimising a public function.\n///\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl Eq for PublicContext {\n    fn eq(self, other: Self) -> bool {\n        (self.args_hash == other.args_hash)\n        // Can't compare the function compute_args_hash\n    }\n}\n\nimpl PublicContext {\n    /// Creates a new PublicContext instance.\n    ///\n    /// Low-level function: This is called automatically by the #[external(\"public\")]\n    /// macro, so you shouldn't need to be called directly by smart contract\n    /// developers.\n    ///\n    /// # Arguments\n    /// * `compute_args_hash` - Function to compute the args_hash\n    ///\n    /// # Returns\n    /// * A new PublicContext instance\n    ///\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    /// Emits a _public_ log that will be visible onchain to everyone.\n    ///\n    /// # Arguments\n    /// * `log` - The data to log, must implement Serialize trait\n    ///\n    pub fn emit_public_log<T>(_self: &mut Self, log: T)\n    where\n        T: Serialize,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    /// Checks if a given note hash exists in the note hash tree at a particular\n    /// leaf_index.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The note hash to check for existence\n    /// * `leaf_index` - The index where the note hash should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the note hash exists at the specified index\n    ///\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: u64) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    /// Checks if a specific L1-to-L2 message exists in the L1-to-L2 message\n    /// tree at a particular leaf index.\n    ///\n    /// Common use cases include token bridging, cross-chain governance, and\n    /// triggering L2 actions based on L1 events.\n    ///\n    /// This function should be called before attempting to consume an L1-to-L2\n    /// message.\n    ///\n    /// # Arguments\n    /// * `msg_hash` - Hash of the L1-to-L2 message to check\n    /// * `msg_leaf_index` - The index where the message should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the message exists at the specified index\n    ///\n    /// # Advanced\n    /// * Uses the AVM l1_to_l2_msg_exists opcode for tree lookup\n    /// * Messages are copied from L1 Inbox to L2 by block proposers\n    ///\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        // TODO(alvaro): Make l1l2msg leaf index a u64 upstream\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index as u64) } == 1\n    }\n\n    /// Checks if a specific nullifier has been emitted by a given contract.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. An example is to check\n    /// whether a contract has been published: we emit a nullifier that is\n    /// deterministic, but whose preimage is _not_ private. This is more\n    /// efficient than using mutable storage, and can be done directly\n    /// from a private function.\n    ///\n    /// Nullifiers can be tested for non-existence in public, which is not the\n    /// case in private. Because private functions do not have access to\n    /// the tip of the blockchain (but only the anchor block they are built\n    /// at) they can only prove nullifier non-existence in the past. But between\n    /// an anchor block and the block in which a tx is included, the nullifier\n    /// might have been inserted into the nullifier tree by some other\n    /// transaction.\n    /// Public functions _do_ have access to the tip of the state, and so\n    /// this pattern is safe.\n    ///\n    /// # Arguments\n    /// * `unsiloed_nullifier` - The raw nullifier value (before siloing with\n    ///                          the contract address that emitted it).\n    /// * `address` - The claimed contract address that emitted the nullifier\n    ///\n    /// # Returns\n    /// * `bool` - True if the nullifier has been emitted by the specified contract\n    ///\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2) -- effectively\n    /// marking it as \"read\".\n    ///\n    /// Use this function if you only want the message to ever be \"referred to\"\n    /// once. Once consumed using this method, the message cannot be consumed\n    /// again, because a nullifier is emitted.\n    /// If your use case wants for the message to be read unlimited times, then\n    /// you can always read any historic message from the L1-to-L2 messages tree,\n    /// using the `l1_to_l2_msg_exists` method. Messages never technically get\n    /// deleted from that tree.\n    ///\n    /// The message will first be inserted into an Aztec \"Inbox\" smart contract\n    /// on L1. It will not be available for consumption immediately. Messages\n    /// get copied-over from the L1 Inbox to L2 by the next Proposer in batches.\n    /// So you will need to wait until the messages are copied before you can\n    /// consume them.\n    ///\n    /// # Arguments\n    /// * `content` - The message content that was sent from L1\n    /// * `secret` - Secret value used for message privacy (if needed)\n    /// * `sender` - Ethereum address that sent the message\n    /// * `leaf_index` - Index of the message in the L1-to-L2 message tree\n    ///\n    /// # Advanced\n    /// * Validates message existence in the L1-to-L2 message tree\n    /// * Prevents double-consumption by emitting a nullifier\n    /// * Message hash is computed from all parameters + chain context\n    /// * Will revert if message doesn't exist or was already consumed\n    ///\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    /// Sends an \"L2 -> L1 message\" from this function (Aztec, L2) to a smart\n    /// contract on Ethereum (L1). L1 contracts which are designed to\n    /// send/receive messages to/from Aztec are called \"Portal Contracts\".\n    ///\n    /// Common use cases include withdrawals, cross-chain asset transfers, and\n    /// triggering L1 actions based on L2 state changes.\n    ///\n    /// The message will be inserted into an Aztec \"Outbox\" contract on L1,\n    /// when this transaction's block is proposed to L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target portal contract. The message will need to be manually\n    /// consumed from the Outbox through a separate Ethereum transaction: a user\n    /// will need to call a function of the portal contract -- a function\n    /// specifically designed to make a call to the Outbox to consume the\n    /// message.\n    /// The message will only be available for consumption once the _epoch_\n    /// proof has been submitted. Given that there are multiple Aztec blocks\n    /// within an epoch, it might take some time for this epoch proof to be\n    /// submitted -- especially if the block was near the start of an epoch.\n    ///\n    /// # Arguments\n    /// * `recipient` - Ethereum address that will receive the message\n    /// * `content` - Message content (32 bytes as a Field element)\n    ///\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    /// Calls a public function on another contract.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Arguments to pass to the function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Makes a read-only call to a public function on another contract.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Useful for querying data from other contracts safely.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Array of arguments to pass to the called function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Adds a new note hash to the Aztec blockchain's global Note Hash Tree.\n    ///\n    /// Notes are ordinarily constructed and emitted by _private_ functions, to\n    /// ensure that both the content of the note, and the contract that emitted\n    /// the note, stay private.\n    ///\n    /// There are however some useful patterns whereby a note needs to contain\n    /// _public_ data. The ability to push a new note_hash from a _public_\n    /// function means that notes can be injected with public data immediately\n    /// -- as soon as the public value is known. The slower alternative would\n    /// be to submit a follow-up transaction so that a private function can\n    /// inject the data. Both are possible on Aztec.\n    ///\n    /// Search \"Partial Note\" for a very common pattern which enables a note\n    /// to be \"partially\" populated with some data in a _private_ function, and\n    /// then later \"completed\" with some data in a public function.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The hash of the note to add to the tree\n    ///\n    /// # Advanced\n    /// * The note hash will be siloed with the contract address by the protocol\n    ///\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n\n    /// Adds a new nullifier to the Aztec blockchain's global Nullifier Tree.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. Hence why you're seeing this\n    /// function within the PublicContext.\n    /// An example is to check whether a contract has been published: we emit\n    /// a nullifier that is deterministic, but whose preimage is _not_ private.\n    ///\n    /// # Arguments\n    /// * `nullifier` - A unique field element that represents the consumed\n    ///   state\n    ///\n    /// # Advanced\n    /// * Nullifier is immediately added to the global nullifier tree\n    /// * Emitted nullifiers are immediately visible to all\n    ///   subsequent transactions in the same block\n    /// * Automatically siloed with the contract address by the protocol\n    /// * Used for preventing double-spending and ensuring one-time actions\n    ///\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    /// Returns the address of the current contract being executed.\n    ///\n    /// This is equivalent to `address(this)` in Solidity (hence the name).\n    /// Use this to identify the current contract's address, commonly needed for\n    /// access control or when interacting with other contracts.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The contract address of the current function being\n    ///                    executed.\n    ///\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: If the calling function is a _private_ function, then\n    /// it had the option of hiding its address when enqueuing this public\n    /// function call. In such cases, this `context.msg_sender()` method will\n    /// return `Option<AztecAddress>::none`.\n    /// If the calling function is a _public_ function, it will always return\n    /// an `Option<AztecAddress>::some` (i.e. a non-null value).\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called\n    ///   this function (be it an app contract or a user's account contract).\n    ///\n    /// # Advanced\n    /// * Value is provided by the AVM sender opcode\n    /// * In nested calls, this is the immediate caller, not the original\n    ///   transaction sender\n    ///\n    pub fn msg_sender(_self: Self) -> Option<AztecAddress> {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let maybe_msg_sender = unsafe { sender() };\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// \"Unsafe\" versus calling `context.msg_sender()`, because it doesn't\n    /// translate `NULL_MSG_SENDER_CONTRACT_ADDRESS` as\n    /// `Option<AztecAddress>::none`.\n    /// Used by some internal aztecnr functions.\n    pub fn msg_sender_unsafe(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n\n    /// Returns the function selector of the currently-executing function.\n    ///\n    /// This is similar to `msg.sig` in Solidity, returning the first 4\n    /// bytes of the function signature.\n    ///\n    /// # Returns\n    /// * `FunctionSelector` - The 4-byte function identifier\n    ///\n    /// # Advanced\n    /// * Extracted from the first element of calldata\n    /// * Used internally for function dispatch in the AVM\n    ///\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    ///\n    /// Very low-level function: The #[external(\"public\")] macro uses this internally.\n    /// Smart contract developers typically won't need to access this\n    /// directly as arguments are automatically made available.\n    ///\n    /// # Returns\n    /// * `Field` - Hash of the function arguments\n    ///\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n\n    /// Returns the \"transaction fee\" for the current transaction.\n    /// This is the final tx fee that will be deducted from the fee_payer's\n    /// \"fee-juice\" balance (in the protocol's Base Rollup circuit).\n    ///\n    /// # Returns\n    /// * `Field` - The actual, final cost of the transaction, taking into account:\n    ///             the actual gas used during the setup and app-logic phases,\n    ///             and the fixed amount of gas that's been allocated by the user\n    ///             for the teardown phase.\n    ///             I.e. effectiveL2FeePerGas * l2GasUsed + effectiveDAFeePerGas * daGasUsed\n    ///\n    /// This will return `0` during the \"setup\" and \"app-logic\" phases of\n    /// tx execution (because the final tx fee is not known at that time).\n    /// This will only return a nonzero value during the \"teardown\" phase of\n    /// execution, where the final tx fee can actually be computed.\n    ///\n    /// Regardless of _when_ this function is called during the teardown phase,\n    /// it will always return the same final tx fee value. The teardown phase\n    /// does not consume a variable amount of gas: it always consumes a\n    /// pre-allocated amount of gas, as specified by the user when they generate\n    /// their tx.\n    ///\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    /// Returns the chain ID of the current network.\n    ///\n    /// This is similar to `block.chainid` in Solidity. Returns the unique\n    /// identifier for the blockchain network this transaction is executing on.\n    ///\n    /// Helps prevent cross-chain replay attacks. Useful if implementing\n    /// multi-chain contract logic.\n    ///\n    /// # Returns\n    /// * `Field` - The chain ID as a field element\n    ///\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n\n    /// Returns the Aztec protocol version that this transaction is executing\n    /// under. Different versions may have different rules, opcodes, or\n    /// cryptographic primitives.\n    ///\n    /// This is similar to how Ethereum has different EVM versions.\n    ///\n    /// Useful for forward/backward compatibility checks\n    ///\n    /// Not to be confused with contract versions; this is the protocol version.\n    ///\n    /// # Returns\n    /// * `Field` - The protocol version as a field element\n    ///\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    /// Returns the current block number.\n    ///\n    /// This is similar to `block.number` in Solidity.\n    ///\n    /// Note: the current block number is only available within a public function\n    /// (as opposed to a private function).\n    ///\n    /// Note: the time intervals between blocks should not be relied upon as\n    /// being consistent:\n    /// - Timestamps of blocks fall within a range, rather than at exact regular\n    ///   intervals.\n    /// - Slots can be missed.\n    /// - Protocol upgrades can completely change the intervals between blocks\n    ///   (and indeed the current roadmap plans to reduce the time between\n    ///   blocks, eventually).\n    /// Use `context.timestamp()` for more-reliable time-based logic.\n    ///\n    /// # Returns\n    /// * `u32` - The current block number\n    ///\n    pub fn block_number(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n\n    /// Returns the timestamp of the current block.\n    ///\n    /// This is similar to `block.timestamp` in Solidity.\n    ///\n    /// All functions of all transactions in a block share the exact same\n    /// timestamp (even though technically each transaction is executed\n    /// one-after-the-other).\n    ///\n    /// Important note: Timestamps of Aztec blocks are not at reliably-fixed\n    /// intervals. The proposer of the block has some flexibility to choose a\n    /// timestamp which is in a valid _range_: Obviously the timestamp of this\n    /// block must be strictly greater than that of the previous block, and must\n    /// must be less than the timestamp of whichever ethereum block the aztec\n    /// block is proposed to. Furthermore, if the timestamp is not deemed close\n    /// enough to the actual current time, the committee of validators will not\n    /// attest to the block.\n    ///\n    /// # Returns\n    /// * `u64` - Unix timestamp in seconds\n    ///\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n\n    /// Returns the fee per unit of L2 gas for this transaction (aka the \"L2 gas\n    /// price\"), as chosen by the user.\n    ///\n    /// L2 gas covers the cost of executing public functions and handling\n    /// side-effects within the AVM.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of L2 gas\n    ///\n    /// Wallet developers should be mindful that the choice of gas price (which\n    /// is publicly visible) can leak information about the user, e.g.:\n    /// - which wallet software the user is using;\n    /// - the amount of time which has elapsed from the time the user's wallet\n    ///   chose a gas price (at the going rate), to the time of tx submission.\n    ///   This can give clues about the proving time, and hence the nature of\n    ///   the tx.\n    /// - the urgency of the transaction (which is kind of unavoidable, if the\n    ///   tx is indeed urgent).\n    /// - the wealth of the user.\n    /// - the exact user (if the gas price is explicitly chosen by the user to\n    ///   be some unique number like 0.123456789, or their favourite number).\n    /// Wallet devs might wish to consider fuzzing the choice of gas price.\n    ///\n    pub fn base_fee_per_l2_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_l2_gas()\n        }\n    }\n\n    /// Returns the fee per unit of DA (Data Availability) gas (aka the \"DA gas\n    /// price\").\n    ///\n    /// DA gas covers the cost of making transaction data available on L1.\n    ///\n    /// See the warning in `fee_pre_l2_gas` for how gas prices can be leaky.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of DA gas\n    ///\n    pub fn base_fee_per_da_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_da_gas()\n        }\n    }\n\n    /// Returns the remaining L2 gas available for this transaction.\n    ///\n    /// Different AVM opcodes consume different amounts of gas.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining L2 gas units\n    ///\n    pub fn l2_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n\n    /// Returns the remaining DA (Data Availability) gas available for this\n    /// transaction.\n    ///\n    /// DA gas is consumed when emitting data that needs to be made available\n    /// on L1, such as public logs or state updates.\n    /// All of the side-effects from the private part of the tx also consume\n    /// DA gas before execution of any public functions even begins.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining DA gas units\n    ///\n    pub fn da_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n\n    /// Checks if the current execution is within a staticcall context, where\n    /// no state changes or logs are allowed to be emitted (by this function\n    /// or any nested function calls).\n    ///\n    /// # Returns\n    /// * `bool` - True if in staticcall context, false otherwise\n    ///\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    /// Reads raw field values from public storage.\n    /// Reads N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to read from\n    ///\n    /// # Returns\n    /// * `[Field; N]` - Array of N field values from consecutive storage slots\n    ///\n    /// # Generic Parameters\n    /// * `N` - the number of consecutive slots to return, starting from the\n    ///         `storage_slot`.\n    ///\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    /// Reads a typed value from public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to read from\n    ///\n    /// # Returns\n    /// * `T` - The deserialized value from storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type that the caller expects to read from the `storage_slot`.\n    ///\n    pub fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    /// Writes raw field values to public storage.\n    /// Writes to N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// Public storage writes take effect immediately.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to write to\n    /// * `values` - Array of N Fields to write to storage\n    ///\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    /// Writes a typed value to public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to write to\n    /// * `value` - The typed value to write to storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type to write to storage.\n    ///\n    pub fn storage_write<T>(self, storage_slot: Field, value: T)\n    where\n        T: Packable,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> u32 {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn base_fee_per_l2_gas() -> u128 {\n    base_fee_per_l2_gas_opcode()\n}\nunconstrained fn base_fee_per_da_gas() -> u128 {\n    base_fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> u32 {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> u32 {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> u1 {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: u64) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: u64) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\n\nunconstrained fn call(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\nunconstrained fn call_static(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeBaseFeePerL2Gas)]\nunconstrained fn base_fee_per_l2_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeBaseFeePerDaGas)]\nunconstrained fn base_fee_per_da_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> u1 {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "72": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr",
      "source": "use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\n/// A hash that represents a private contract function call's return value. Call `get_preimage` to get the underlying\n/// value.\n///\n/// The kernels don't process the actual return values but instead their hashes, so it is up to contracts to populate\n/// oracles with the preimages of these hashes on return to make them available to their callers.\n///\n/// Public calls don't utilize this mechanism since the AVM does process the full return values.\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    /// Fetches the underlying return value from an oracle, constraining that it corresponds to the return data hash.\n    pub fn get_preimage<T>(self) -> T\n    where\n        T: Deserialize,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it. If `T`\n        // is `()`, then `preimage` must be an array of length 0 (since that is `()`'s deserialization length).\n        // `hash_args_array` handles empty arrays following the protocol rules (i.e. an empty args array is signaled\n        // with a zero hash), correctly constraining `self.hash`.\n        let preimage = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage), \"Preimage mismatch\");\n\n        Deserialize::deserialize(preimage)\n    }\n}\n\nmod test {\n    use crate::{\n        hash::hash_args_array,\n        oracle::execution_cache,\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use super::ReturnsHash;\n    use protocol_types::traits::Serialize;\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn retrieves_preimage() {\n        let env = TestEnvironment::new();\n        env.private_context(|_| {\n            let value = MockStruct::new(4, 7);\n            let serialized = value.serialize();\n\n            let hash = hash_args_array(serialized);\n            execution_cache::store(serialized, hash);\n\n            assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n        });\n    }\n\n    #[test]\n    unconstrained fn retrieves_empty_preimage() {\n        let env = TestEnvironment::new();\n        env.private_context(|_| {\n            let value = ();\n            let serialized = [];\n\n            let hash = hash_args_array(serialized);\n            execution_cache::store(serialized, hash);\n\n            assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n        });\n    }\n\n    #[test(should_fail_with = \"Preimage mismatch\")]\n    unconstrained fn rejects_bad_preimage() {\n        let value = MockStruct::new(4, 7);\n        let serialized = value.serialize();\n\n        let mut bad_serialized = serialized;\n        bad_serialized[0] += 1;\n\n        let hash = hash_args_array(serialized);\n\n        let _ = OracleMock::mock(\"privateLoadFromExecutionCache\").returns(bad_serialized);\n        assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n    }\n\n    // This test passes due to a Noir bug.\n    // #[test(should_fail_with=\"Preimage mismatch\")]\n    // unconstrained fn rejects_bad_empty_preimage() {\n    //     let value = ();\n    //     let serialized = [];\n\n    //     let hash = hash_args_array(serialized);\n\n    //     let _ = OracleMock::mock(\"privateLoadFromExecutionCache\").returns([1]);\n    //     assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n    // }\n}\n"
    },
    "73": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{execution::get_utility_context, storage::storage_read};\nuse protocol_types::{address::AztecAddress, traits::Packable};\n\n// If you'll modify this struct don't forget to update utility_context.ts as well.\npub struct UtilityContext {\n    block_number: u32,\n    timestamp: u64,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        get_utility_context()\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        // We get a context with default contract address, and then we construct the final context with the provided\n        // contract address.\n        let default_context = get_utility_context();\n\n        Self {\n            block_number: default_context.block_number,\n            timestamp: default_context.timestamp,\n            contract_address,\n            version: default_context.version,\n            chain_id: default_context.chain_id,\n        }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        // We get a context with default contract address and block number, and then we construct the final context\n        // with the provided contract address and block number.\n        let default_context = get_utility_context();\n\n        Self {\n            block_number,\n            timestamp: default_context.timestamp,\n            contract_address,\n            version: default_context.version,\n            chain_id: default_context.chain_id,\n        }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn timestamp(self) -> u64 {\n        self.timestamp\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "76": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/event/event_selector.nr",
      "source": "use dep::protocol_types::{\n    hash::poseidon2_hash_bytes,\n    traits::{Deserialize, Empty, FromField, Serialize, ToField},\n};\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "78": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_BYTECODE, GENERATOR_INDEX__PUBLIC_CALLDATA,\n        GENERATOR_INDEX__SECRET_HASH, MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS,\n    },\n    hash::{\n        poseidon2_hash_subarray, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice,\n        sha256_to_field,\n    },\n    point::Point,\n    traits::ToField,\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n}\n\n/**\n * Computes the public bytecode commitment for a contract class.\n * The commitment is `hash([separator, ...bytecode])` where bytecode omits the length prefix present\n * in `packed_bytecode`.\n *\n * @param packed_bytecode - The packed bytecode of the contract class. 0th word is the length in bytes.\n *    packed_bytecode is mutable so that we can avoid copying the array to construct one starting with\n *    separator instead of length.\n * @returns The public bytecode commitment.\n */\npub fn compute_public_bytecode_commitment(\n    mut packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS],\n) -> Field {\n    // First field element contains the length of the bytecode\n    let bytecode_length_in_bytes: u32 = packed_public_bytecode[0] as u32;\n    let bytecode_length_in_fields: u32 =\n        (bytecode_length_in_bytes / 31) + (bytecode_length_in_bytes % 31 != 0) as u32;\n    // Don't allow empty public bytecode.\n    // AVM doesn't handle execution of contracts that exist with empty bytecode.\n    assert(bytecode_length_in_fields != 0);\n    assert(bytecode_length_in_fields < MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS);\n\n    // Packed_bytecode's 0th entry is the length. Replace it with separator before hashing.\n    let separator = GENERATOR_INDEX__PUBLIC_BYTECODE.to_field();\n    packed_public_bytecode[0] = separator;\n\n    // `fields_to_hash` is the number of fields from the start of `packed_public_bytecode` that should be included in\n    // the hash. Fields after this length are ignored.\n    // +1 to account for the separator.\n    let num_fields_to_hash = bytecode_length_in_fields + 1;\n\n    poseidon2_hash_subarray(packed_public_bytecode, num_fields_to_hash)\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = [0; 100];\n    for i in 0..100 {\n        input[i] = i as Field;\n    }\n    let hash = hash_args_array(input);\n    dep::std::println(hash);\n    // Used in yarn-project/stdlib test snapshots:\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_calldata_hash() {\n    let mut input = [0; 100];\n    for i in 0..input.len() {\n        input[i] = i as Field;\n    }\n    let hash = hash_calldata_array(input);\n    dep::std::println(hash);\n    let hash_check = hash_calldata(input.as_slice());\n    assert(hash == hash_check);\n    // Used in cpp vm2 tests:\n    assert(hash == 0x191383c9f8964afd3ea8879a03b7dda65d6724773966d18dcf80e452736fc1f3);\n}\n\n#[test]\nunconstrained fn public_bytecode_commitment() {\n    let mut input = [0; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS];\n    let len = 99;\n    for i in 1..len + 1 {\n        input[i] = i as Field;\n    }\n    input[0] = (len as Field) * 31;\n    let hash = compute_public_bytecode_commitment(input);\n    dep::std::println(hash);\n    // Used in cpp vm2 tests:\n    assert(hash == 0x16d621c3387156ef53754679e7b2c9be8f0bceeb44aa59a74991df3b0b42a0bf);\n}\n"
    },
    "90": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/history/public_storage.nr",
      "source": "use dep::protocol_types::{\n    abis::block_header::BlockHeader, address::AztecAddress,\n    constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX, hash::poseidon2_hash_with_separator,\n    utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\nuse protocol_types::traits::{Hash, ToField};\n\nmod test;\n\npub trait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        // Safety: The witness is only used as a \"magical value\" that makes the proof below pass. Hence it's safe.\n        let witness = unsafe {\n            get_public_data_witness(self.global_variables.block_number, public_data_tree_index)\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert_eq(\n            self.state.partial.public_data_tree.root,\n            root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path),\n            \"Proving public value inclusion failed\",\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(\n                preimage.slot,\n                public_data_tree_index,\n                \"Public data tree index doesn't match witness\",\n            );\n            preimage.value\n        };\n\n        value\n    }\n}\n"
    },
    "95": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n\nmod test {\n    use super::get_public_keys;\n\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use protocol_types::traits::Serialize;\n    use std::test::OracleMock;\n\n    global KEY_ORACLE_RESPONSE_LENGTH: u32 = 13; // 12 fields for the keys, one field for the partial address\n\n    #[test(should_fail_with = \"Invalid public keys hint for address\")]\n    unconstrained fn get_public_keys_fails_with_bad_hint() {\n        let mut env = TestEnvironment::new();\n        let account = env.create_light_account();\n\n        // Instead of querying for some unknown account, which would result in the oracle erroring out, we mock a bad oracle\n        // response to check that the circuit properly checks the address derivation.\n        let mut random_keys_and_partial_address = [0; KEY_ORACLE_RESPONSE_LENGTH];\n        // We use randomly generated points on the curve, and a random partial address to ensure that\n        // this combination does not derive the address and we should see the assertion fail.\n        // npk_m\n        random_keys_and_partial_address[0] =\n            0x292364b852c6c6f01472951e76a39cbcf074591fd0e063a81965e7b51ad868a5;\n        random_keys_and_partial_address[1] =\n            0x0a687b46cdc9238f1c311f126aaaa4acbd7a737bff2efd7aeabdb8d805843a27;\n        random_keys_and_partial_address[2] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // ivpk_m\n        random_keys_and_partial_address[3] =\n            0x173c5229a00c5425255680dd6edc27e278c48883991f348fe6985de43b4ec25f;\n        random_keys_and_partial_address[4] =\n            0x1698608e23b5f6c2f43c49a559108bb64e2247b8fc2da842296a416817f40b7f;\n        random_keys_and_partial_address[5] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // ovpk_m\n        random_keys_and_partial_address[6] =\n            0x1bad2f7d1ad960a1bd0fe4d2c8d17f5ab4a86ef8b103e0a9e7f67ec0d3b4795e;\n        random_keys_and_partial_address[7] =\n            0x206db87110abbecc9fbaef2c865189d94ef2c106202f734ee4eba9257fd28bf1;\n        random_keys_and_partial_address[8] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // tpk_m\n        random_keys_and_partial_address[9] =\n            0x05e3bd9cfe6b47daa139613619cf7d7fd8bb0112b6f2908caa6d9b536ed948ed;\n        random_keys_and_partial_address[10] =\n            0x051066f877c9df47552d02e7dc32127ff4edefc8498e813bca1cbd3f5d1be429;\n        random_keys_and_partial_address[11] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // partial address\n        random_keys_and_partial_address[12] =\n            0x236703e2cb00a182e024e98e9f759231b556d25ff19f98896cebb69e9e678cc9;\n\n        let _ = OracleMock::mock(\"utilityGetPublicKeysAndPartialAddress\").returns(\n            random_keys_and_partial_address.serialize(),\n        );\n        let _ = get_public_keys(account);\n    }\n}\n"
    },
    "99": {
      "path": "/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::macros::{\n    dispatch::generate_public_dispatch,\n    functions::{stub_registry, utils::check_each_fn_macroified},\n    notes::NOTES,\n    storage::STORAGE_LAYOUT_NAME,\n    utils::{get_trait_impl_method, module_has_storage},\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_private_state` utility function.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[external(...)], #[contract_library_method], or #[test] are not allowed in contracts.\n    check_each_fn_macroified(m);\n\n    // We generate `_compute_note_hash_and_nullifier`, `sync_private_state` and `process_message`\n    // functions only if they are not already implemented. If they are implemented we just insert empty\n    // quotes.\n    let contract_library_method_compute_note_hash_and_nullifier = if !m.functions().any(|f| {\n        f.name() == quote { _compute_note_hash_and_nullifier }\n    }) {\n        generate_contract_library_method_compute_note_hash_and_nullifier()\n    } else {\n        quote {}\n    };\n    let sync_private_state = if !m.functions().any(|f| f.name() == quote { sync_private_state }) {\n        generate_sync_private_state()\n    } else {\n        quote {}\n    };\n    let process_message = if !m.functions().any(|f| f.name() == quote { process_message }) {\n        generate_process_message()\n    } else {\n        quote {}\n    };\n    let public_dispatch = generate_public_dispatch(m);\n\n    quote {\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_private_state\n        $process_message\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    if NOTES.len() > 0 {\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..NOTES.len() {\n            let typ = NOTES.get(i);\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret its raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = <$typ as $crate::protocol_types::traits::Packable>::N;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided note nonce.\n                        let note_hash_for_nullification = aztec::note::utils::compute_note_hash_for_nullification(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(note_nonce).into()\n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullification);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `note_nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_message` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                note_nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_sync_private_state() -> Quoted {\n    // We obtain the `external` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::external(\"utility\")]` in the returned quote because the latter would result in\n    // the function attribute having the full path in the ABI. This is undesirable because we use the information in\n    // the ABI only to determine whether a function is `external(\"private\")`, `external(\"public\")`, or `external(\"utility\")`.\n    let external = crate::macros::functions::external;\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[external(\"utility\")] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[$external(\"utility\")]\n        unconstrained fn sync_private_state() {\n        }\n    }\n}\n\ncomptime fn generate_process_message() -> Quoted {\n    // We obtain the `external` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::external(\"utility\")]` in the returned quote because the latter would result in\n    // the function attribute having the full path in the ABI. This is undesirable because we use the information in\n    // the ABI only to determine whether a function is `external(\"private\")`, `external(\"public\")`, or `external(\"utility\")`.\n    let external = crate::macros::functions::external;\n\n    quote {\n        #[$external(\"utility\")]\n        unconstrained fn process_message(\n            message_ciphertext: BoundedVec<Field, aztec::messages::encoding::MESSAGE_CIPHERTEXT_LEN>,\n            message_context: aztec::messages::processing::message_context::MessageContext,\n        ) {\n            aztec::messages::discovery::process_message::process_message_ciphertext(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n                message_ciphertext,\n                message_context,\n            );\n        }\n    }\n}\n"
    }
  },
  "functions": [
    {
      "abi": {
        "error_types": {
          "11594563071547591162": {
            "error_kind": "string",
            "string": "Function _validate_emitter_and_update_value can only be called internally"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "18173155084464344029": {
            "error_kind": "string",
            "string": "Emitter not registered"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "emitter_chain_id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 16
            },
            "visibility": "private"
          },
          {
            "name": "emitter_address",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "value",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "internal",
        "public"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "_validate_emitter_and_update_value"
    },
    {
      "abi": {
        "error_types": {
          "14415304921900233953": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "9967937311635654895": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          }
        },
        "parameters": [
          {
            "name": "wormhole_address",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "chain_id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 16
            },
            "visibility": "private"
          },
          {
            "name": "owner",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "message_fee",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JwACBAEoAAABBIBJJwAABEknAgUEBCcCBgQAHwoABQAGAEUcAEZGAxwASEgGLQhFAS0IRgItCEcDLQhIBCUAAABXJQAAAIInAgEESScCAgQAOw4AAgABLAAAQwAwZE5y4TGgKbhQRbaBgVhdKDPoSHm5cJFD4fWT8AAAACcARAQDJiUAABO1HgIABgAtCAEHJwIIBAMACAEIAScDBwQBACIHAgg2DgAGAAgAJwIIBAEAKgcICi0LCgknAgoEAgAqBwoMLQsMCxwKCQcABCoHCwwnAgcBASQCAAkAAADnJwILBAA8BgsBLQgBCScCCwQDAAgBCwEnAwkEAQAiCQILNg4ABgALAgAqCQgLLQsLBgAqCQoNLQsNCxwKBgkABCoJCw0kAgAGAAABMycCCQQAPAYJAScCBgQALQgBCScCCwQCAAgBCwEnAwkEAQAiCQILHzoACAAGAAsAKgkIDi0LDgscCgsOBBwKDgkALQgBCwAAAQIBJwIOAAItDg4LLQgBDgAAAQIBJwIPAAMtDg8OJwIPBAQtCAEQJwIRBAUACAERAScDEAQBACIQAhEfOgAPAAgAES0IAREAAAECAScCEgAAJwITACwtCAEUJwIVBAYACAEVAScDFAQBACIUAhUtChUWLQ4TFgAiFgIWLQ4SFgAiFgIWLQ4SFgAiFgIWLQ4SFgAiFgIWLQ4SFi0OFBEnAhMEBS0KBgUjAAACHQwqBQ8UJAIAFAAAE18jAAACLy0LERAtCAERJwIUBAQACAEUAScDEQQBACIRAhQtChQVLQ4SFQAiFQIVLQ4SFQAiFQIVLQ4SFSsCABQAAAAAAAAAAAUAAAAAAAAAAC0IARUnAhYEBQAIARYBJwMVBAEAIhUCFi0KFhctDhIXACIXAhctDhIXACIXAhctDhIXACIXAhctDhQXLQgBFAAAAQIBLQ4RFC0IAREAAAECAS0OFREtCAEVAAABAgEtDgYVLQgBFgAAAQIBJwIXAQAtDhcWLQoGBSMAAAL3DCoFExgkAgAYAAARmyMAAAMJLQsWEAoqEBcTJAIAEwAAAyMnAhgEADwGGAEtCgYFIwAAAywMIgVEECQCABAAABEVIwAAAz4tCxQQLQsREy0LFRgtCxMZACIZAhktDhkTLQgBGScCGgQFAAgBGgEnAxkEAQAiEwIaJwIbBAQAIhkCHD8PABoAHC0OEBQtDhkRLQ4YFS0OBxYAKhkIES0LERAtCwsRLQsOEy0OEQstDhMOJwILAA0tCAEOJwIRBAQACAERAScDDgQBACIOAhEtChETLQ4LEwAiEwITLQ4JEwAiEwITLQ4QEy0IAQknAgsEBAAIAQsBJwMJBAEAIgkCCy0KCxAtDhIQACIQAhAtDhIQACIQAhAtDhIQKwIACwAAAAAAAAAAAwAAAAAAAAAALQgBECcCEQQFAAgBEQEnAxAEAQAiEAIRLQoREy0OEhMAIhMCEy0OEhMAIhMCEy0OEhMAIhMCEy0OCxMtCAERAAABAgEtDgkRLQgBCQAAAQIBLQ4QCS0IARAAAAECAS0OBhAtCAETAAABAgEtDhcTLQoGBSMAAASeDCIFRBQkAgAUAAAPUSMAAASwLQsTDgoqDhcUJAIAFAAABMonAhUEADwGFQEtCgYFIwAABNMMIgVEDiQCAA4AAA7LIwAABOUtCxEFLQsJDi0LEBQtCw4VACIVAhUtDhUOLQgBFScCFgQFAAgBFgEnAxUEAQAiDgIWJwIYBAQAIhUCGT8PABYAGS0OBREtDhUJLQ4UEC0OBxMAKhUICS0LCQUKKg0FCSQCAAkAAAVRJQAAE9sKKgwSBR4CAAkBCiIJQw0WCg0OHAoOEAAEKhAJDgoqDRcJJAIACQAABYQnAhAEADwGEAEKKgwOCRIqBQkMJAIADAAABZslAAAT7S0IAQUnAgkEBAAIAQkBJwMFBAEAIgUCCS0KCQwtDhIMACIMAgwtDhIMACIMAgwtDhIMKwIACQAAAAAAAAAAAgAAAAAAAAAALQgBDCcCDQQFAAgBDQEnAwwEAQAiDAINLQoNDi0OEg4AIg4CDi0OEg4AIg4CDi0OEg4AIg4CDi0OCQ4tCAEJAAABAgEtDgUJLQgBBQAAAQIBLQ4MBS0IAQ0AAAECAS0OBg0tCAEOAAABAgEtDhcOJwIQAAYkAgAXAAAGqiMAAAZjLQgBEScCEwQEAAgBEwEnAxEEAQAiEQITLQoTFC0OEBQAIhQCFC0OEhQAIhQCFC0OEhQtDhEJLQ4MBS0OCA0tDhcOIwAABzYtCgYMIwAABrMMIgxEESQCABEAAA5FIwAABsUtCwkMLQsFES0LDhMtCxEUACIUAhQtDhQRLQgBFCcCFQQFAAgBFQEnAxQEAQAiEQIVJwIWBAQAIhQCGD8PABUAGC0CDAMnAAQEBCUAABP/LQgFEQAqEQgVLQ4QFS0OEQktDhQFLQ4IDS0OEw4jAAAHNi0LCQwtCwUQLQsOEQoqERcTJAIAEwAAB1gnAhQEADwGFAEnAhEAASQCABcAAAeaIwAAB2otAgwDJwAEBAQlAAAT/y0IBRMAKhMKFC0OERQtDhMJLQ4QBS0OCg0tDhcOIwAACCYtCgYKIwAAB6MMIgpEDCQCAAwAAA2/IwAAB7UtCwkKLQsFDC0LDhAtCwwTACITAhMtDhMMLQgBEycCFAQFAAgBFAEnAxMEAQAiDAIUJwIVBAQAIhMCFj8PABQAFi0CCgMnAAQEBCUAABP/LQgFDAAqDAgULQ4RFC0ODAktDhMFLQ4IDS0OEA4jAAAIJi0LDgwKKgwXECQCABAAAAhAJwITBAA8BhMBLQoGCiMAAAhJDCIKRAwkAgAMAAANOSMAAAhbLQsJDC0LBRAtCw0TLQsQFAAiFAIULQ4UEC0IARQnAhUEBQAIARUBJwMUBAEAIhACFScCFgQEACIUAhg/DwAVABgtDgwJLQ4UBS0OEw0tDgcOACoUCAktCwkFNAIABRwKAgUAHAoEAgAtCAEEJwIJBAQACAEJAScDBAQBACIEAgktCgkMLQ4BDAAiDAIMLQ4FDAAiDAIMLQ4CDC0LBAkAIgkCCS0OCQQtCAEJJwIMBAQACAEMAScDCQQBACIJAgwtCgwNLQ4SDQAiDQINLQ4SDQAiDQINLQ4SDS0IAQwnAg0EBQAIAQ0BJwMMBAEAIgwCDS0KDQ4tDhIOACIOAg4tDhIOACIOAg4tDhIOACIOAg4tDgsOLQgBCwAAAQIBLQ4JCy0IAQkAAAECAS0ODAktCAEMAAABAgEtDgYMLQgBDQAAAQIBLQ4XDS0KBgojAAAJrAwiCkQOJAIADgAAC3UjAAAJvi0LDQoKKgoXDiQCAA4AAAnYJwIQBAA8BhABLQoGBCMAAAnhDCIERAokAgAKAAAK7yMAAAnzLQsLCi0LCQ4tCwwQLQsOEwAiEwITLQ4TDi0IARMnAhQEBQAIARQBJwMTBAEAIg4CFCcCFQQEACITAhY/DwAUABYtDgoLLQ4TCS0OEAwtDgcNACoTCAktCwkHLQgBCScCCgQFAAgBCgEnAwkEAQAiCQIKLQoKCy0OAQsAIgsCCy0OBQsAIgsCCy0OAgsAIgsCCy0OBwstCgYEIwAACpEMKgQPASQCAAEAAArDIwAACqMnAgEABTAKAAMAAScCAQAHMAoAEgABHgIAAQA0AgABJhwKBAEAACoRAQIAIgkCBQAqBQQGLQsGATAKAAEAAgAqBAgBLQoBBCMAAAqRLQsLCi0LCQ4tCwwQLQsNEwwqBBAUJAIAFAAACxEjAAALZwAiDgIVACoVBBYtCxYUACIKAhYAKhYEFy0LFxUAKhQVFi0CDgMnAAQEBSUAABP/LQgFFAAiFAIVACoVBBctDhYXLQ4KCy0OFAktDhAMLQ4TDSMAAAtnACoECAotCgoEIwAACeEAIgQCEAAqEAoTLQsTDi0LCxAtCwkTLQsMFC0LDRUKKhUXFiQCABYAAAupJwIYBAA8BhgBCiIURBUkAgAVAAAMGSMAAAu7DCIURBUkAgAVAAALzSUAABRjLQIQAycABAQEJQAAE/8tCAUVACIVAhYAKhYUGC0ODhgAKhQIDg4qFA4QJAIAEAAADAQlAAAUdS0OFQstDhMJLQ4ODC0OFw0jAAAMpS0KBhAjAAAMIgwiEEQTJAIAEwAADLMjAAAMNC0LCxAtCwkTLQsNFC0LExUAIhUCFS0OFRMtCAEVJwIWBAUACAEWAScDFQQBACITAhYnAhgEBAAiFQIZPw8AFgAZLQIQAycABAQEJQAAE/8tCAUTACoTCBYtDg4WLQ4TCy0OFQktDggMLQ4UDSMAAAylACoKCA4tCg4KIwAACawtCwsTLQsJFC0LDBUtCw0WDCoQFRgkAgAYAAAM1SMAAA0rACIUAhkAKhkQGi0LGhgAIhMCGgAqGhAbLQsbGQAqGBkaLQIUAycABAQFJQAAE/8tCAUYACIYAhkAKhkQGy0OGhstDhMLLQ4YCS0OFQwtDhYNIwAADSsAKhAIEy0KExAjAAAMIi0LCQwtCwUQLQsNEy0LDhQMKgoTFSQCABUAAA1bIwAADbEAIhACFgAqFgoYLQsYFQAiDAIYACoYChktCxkWACoVFhgtAhADJwAEBAUlAAAT/y0IBRUAIhUCFgAqFgoZLQ4YGS0ODAktDhUFLQ4TDS0OFA4jAAANsQAqCggMLQoMCiMAAAhJLQsJDC0LBRAtCw0TLQsOFAwqChMVJAIAFQAADeEjAAAONwAiEAIWACoWChgtCxgVACIMAhgAKhgKGS0LGRYAKhUWGC0CEAMnAAQEBSUAABP/LQgFFQAiFQIWACoWChktDhgZLQ4MCS0OFQUtDhMNLQ4UDiMAAA43ACoKCAwtCgwKIwAAB6MtCwkRLQsFEy0LDRQtCw4VDCoMFBYkAgAWAAAOZyMAAA69ACITAhgAKhgMGS0LGRYAIhECGQAqGQwaLQsaGAAqFhgZLQITAycABAQFJQAAE/8tCAUWACIWAhgAKhgMGi0OGRotDhEJLQ4WBS0OFA0tDhUOIwAADr0AKgwIES0KEQwjAAAGsy0LEQ4tCwkULQsQFS0LExYMKgUVGCQCABgAAA7tIwAAD0MAIhQCGQAqGQUaLQsaGAAiDgIaACoaBRstCxsZACoYGRotAhQDJwAEBAUlAAAT/y0IBRgAIhgCGQAqGQUbLQ4aGy0ODhEtDhgJLQ4VEC0OFhMjAAAPQwAqBQgOLQoOBSMAAATTACIOAhUAKhUFFi0LFhQtCxEVLQsJFi0LEBgtCxMZCioZFxokAgAaAAAPhScCGwQAPAYbAQoiGEQZJAIAGQAAD/UjAAAPlwwiGEQZJAIAGQAAD6klAAAUYy0CFQMnAAQEBCUAABP/LQgFGQAiGQIaACoaGBstDhQbACoYCBQOKhgUFSQCABUAAA/gJQAAFHUtDhkRLQ4WCS0OFBAtDhcTIwAAEIEtCgYVIwAAD/4MIhVEFiQCABYAABCPIwAAEBAtCxEVLQsJFi0LExgtCxYZACIZAhktDhkWLQgBGScCGgQFAAgBGgEnAxkEAQAiFgIaJwIbBAQAIhkCHD8PABoAHC0CFQMnAAQEBCUAABP/LQgFFgAqFggaLQ4UGi0OFhEtDhkJLQ4IEC0OGBMjAAAQgQAqBQgULQoUBSMAAASeLQsRFi0LCRgtCxAZLQsTGgwqFRkbJAIAGwAAELEjAAARBwAiGAIcACocFR0tCx0bACIWAh0AKh0VHi0LHhwAKhscHS0CGAMnAAQEBSUAABP/LQgFGwAiGwIcACocFR4tDh0eLQ4WES0OGwktDhkQLQ4aEyMAABEHACoVCBYtChYVIwAAD/4tCxQQLQsREy0LFRgtCxYZDCoFGBokAgAaAAARNyMAABGNACITAhsAKhsFHC0LHBoAIhACHAAqHAUdLQsdGwAqGhscLQITAycABAQFJQAAE/8tCAUaACIaAhsAKhsFHS0OHB0tDhAULQ4aES0OGBUtDhkWIwAAEY0AKgUIEC0KEAUjAAADLAAiEAIZACoZBRotCxoYLQsUGS0LERotCxUbLQsWHAoqHBcdJAIAHQAAEc8nAh4EADwGHgEKIhtEHCQCABwAABI/IwAAEeEMIhtEHCQCABwAABHzJQAAFGMtAhkDJwAEBAQlAAAT/y0IBRwAIhwCHQAqHRseLQ4YHgAqGwgYDiobGBkkAgAZAAASKiUAABR1LQ4cFC0OGhEtDhgVLQ4XFiMAABLLLQoGGSMAABJIDCIZRBokAgAaAAAS2SMAABJaLQsUGS0LERotCxYbLQsaHAAiHAIcLQ4cGi0IARwnAh0EBQAIAR0BJwMcBAEAIhoCHScCHgQEACIcAh8/DwAdAB8tAhkDJwAEBAQlAAAT/y0IBRoAKhoIHS0OGB0tDhoULQ4cES0OCBUtDhsWIwAAEssAKgUIGC0KGAUjAAAC9y0LFBotCxEbLQsVHC0LFh0MKhkcHiQCAB4AABL7IwAAE1EAIhsCHwAqHxkgLQsgHgAiGgIgACogGSEtCyEfACoeHyAtAhsDJwAEBAUlAAAT/y0IBR4AIh4CHwAqHxkhLQ4gIS0OGhQtDh4RLQ4cFS0OHRYjAAATUQAqGQgaLQoaGSMAABJIACoFCBQAIhACFgAqFgUXLQsXFS0LERYMKhQTFyQCABcAABOIJQAAFGMtAhYDJwAEBAYlAAAT/y0IBRcAIhcCGAAqGBQZLQ4VGS0OFxEtChQFIwAAAh0oAAAEBHhJDAAABAMkAAADAAAT2ioBAAEF2sX11rRKMm08BAIBJioBAAEFilU6LCtnyO88BAIBJioBAAEFyA1zc27NtOE8BAIBJi0BAwYKAAYCByQAAAcAABQVIwAAFB4tAAMFIwAAFGItAAEFAAABBAEAAAMECS0AAwotAAULCgAKCQwkAAAMAAAUWC0BCggtBAgLAAAKAgoAAAsCCyMAABQ0JwEFBAECAAYCBiYqAQABBeQIUEUCtYwfPAQCASYqAQABBdAH6/TLxmeQPAQCASY=",
      "custom_attributes": [
        "external",
        "initializer",
        "public"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "constructor"
    },
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "14067204867181196045": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "9921926525851912681": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "wormhole_address",
                "type": {
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                }
              },
              {
                "name": "chain_id",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 16
                }
              },
              {
                "name": "message_fee",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              }
            ],
            "kind": "struct",
            "path": "config::Config"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "utility"
      ],
      "debug_symbols": "TJ3JjvU8c6Tv5V/34nDIgb6VXjR6NAwYNtDDyjffpQwmIzb+nvD/FoMilSEdnSzVf/zjf/zP//b//vm//Mu//a9//z//+Kf//B//+G//+1/+9V//5Z//y7/++3//r//3X/793/7+v//xj9/3f/b4xz+t//SPPf/xT/73n/WPf8q//2z8x/Afx38C/0n859R/7If/DPxn4j8YxTCKYRTDKIZRDKMYRnGM4hjFMYpjFMcojlEcozhGcYziGCUwSmCUwCiBUQKjBEYJjBIYJTBKYJTEKIlREqMkRkmMkhglMUpilMQoiVEORjkY5WCUg1EORjkY5WCUg1EORjkYZfx+97/j/nfe/677333/a/e/fv8b9795/3vHG3e8cccbd7xxxxt3vHHHG3e8cccbd7xxx5t/443fB6NhNqyGvzHH+sAavCEa/sYd/sHfwPP7qfVrGA2zYTXshr+R5/7AG6IhG76R7Q/2r2E0fHP+Duc7/QG74W/kNT7whmjIhnPhKwbAaJgNq2E39MjWI1uP/BXH+pblK4+Cr0AAo2E2rIbdYA3eEA09svfI0SNHjxw9cvTI0SNHjxw9cvTI0SNHj5w9cvbI2SNnj/wV1Pq24CspgDdEQzacC19xAUbDbFgNPfLpkU+PfHrk0yOfO/L8/RpGw2xYDbvBGrwhGrKhRx498uiRR488euTRI48eefTIo0cePfLokWePPHvk2SPPHnn2yLNHnj3y7JFnjzx75NUjrx559cirR1498uqRV4+8euTVI68eeffIu0fePfLukXePvHvk3SPvHnn3yLtHrhrMD0bDbFgNu8EavCEasuFc8B7Ze2Tvkb8a3OOD3WANfyNv/yAasuFc+GoQMBpmw2rYDdbQI0ePHD1y3ESa+WsYDbNhNewGa/CGaMiGHvn0yKdH/mpwnw9Ww26wBm+Ihmw4gPXVIGA0zIbVsBus4W9k+30QDdlwLnw1CBgNs2E17AZr6JFHjzx65K8GLf7gq0HAaJgNq2E3WIM3REM29MirR1498uqRV4+8euTVI68eefXIq0dePfLukXePvHvk3SPvHnn3yLtH3j3y7pF3j2w9svXI1iNbj2w9svXI1iNbj2w9svXI3iN7j+w9svfI3iN7j+w9svfI3iN7jxw9cvTI0SNHjxw9cvTI0SNHjxw9cvTI2SNnj5w9cvbI2SNnj5w9cvbI2SNnj3x65NMjnx759MinRz498umRT498euRzR96/X8NomA2rYTdYgzdEQzb0yKNHHj3y6JFHjzx65NEjjx559MijR+4a3F2Du2twdw3ursHdNbi7BnfX4O4a3F2Du2twdw3ursHdNbi7BnfX4O4a3F2Du2twdw3ursHdNbi7BnfX4O4a3F2Du2twdw3ursHdNbi7BnfX4O4a3F2Du2twdw3ursHdNbi7BnfX4O4a3F2Du2twdw3ursHdNbi7BnfX4O4a3F2Du2twdw3ursHdNbi7BnfX4O4a3F2Du2twdw3ursHdNbi7BnfX4O4a3F2Du2twdw3ursHdNbi7BnfX4O4a3F2Du2twdw3ursHdNbi7BnfX4O4atK5B6xq0rkHrGrSuQesatK5B6xq0rkHrGrSuQesatK5B6xq0rkHrGrSuQesatK5B6xq0rkHrGrSuQesatK5B6xq0rkHrGrSuQesatK5B6xq0rkHrGrSuQesatK5B6xq0rkHrGrSuQesatK5B6xq0rkHrGrSuQesatK5B6xq0rkHrGrSuQesatK5B6xq0rkHrGrSuQesatK5B6xq0rkHrGrSuQesatK5B6xq0rkHrGrSuQesatK5B6xq0rkHrGrSuQesatK5B6xq0rkHrGrSuQesatK5B6xq0rkHrGrSuQesatK5B6xq0rkHrGrSuQesatK5B6xq0rkHrGvSuQe8a9K5B7xr0rkHvGvSuQe8a9K5B7xr0rkHvGvSuQe8a9K5B7xr0rkHvGvSuQe8a9K5B7xr0rkHvGvSuQe8a9K5B7xr0rkHvGvSuQe8a9K5B7xr0rkHvGvSuQe8a9K5B7xr0rkHvGvSuQe8a9K5B7xr0rkHvGvSuQe8a9K5B7xr0rkHvGvSuQe8a9K5B7xr0rkHvGvSuQe8a9K5B7xr0rkHvGvSuQe8a9K5B7xr0rkHvGvSuQe8a9K5B7xr0rkHvGvSuQe8a9K5B7xr0rkHvGvSuQe8a9K5B7xr0rkHvGvSuQe8a9K5B7xr0rkHvGvSuQe8a9K5B7xqMrsHoGoyuwegajK7B6BqMrsHoGoyuwegajK7B6BqMrsHoGoyuwegajK7B6BqMrsHoGoyuwegajK7B6BqMrsHoGoyuwegajK7B6BqMrsHoGoyuwegajK7B6BqMrsHoGoyuwegajK7B6BqMrsHoGoyuwegajK7B6BqMrsHoGoyuwegajK7B6BqMrsHoGoyuwegajK7B6BqMrsHoGoyuwegajK7B6BqMrsHoGoyuwegajK7B6BqMrsHoGoyuwegajK7B6BqMrsHoGoyuwegajK7B6BqMrsHoGoyuwegajK7B6BqMrsHoGoyuwegajK7B6BqMrsHoGoyuwegazK7B7BrMrsHsGsyuwewazK7B7BrMrsHsGsyuwewazK7B7BrMrsHsGsyuwewazK7B7BrMrsHsGsyuwewazK7B7BrMrsHsGsyuwewazK7B7BrMrsHsGsyvBv33gTV4w9/Ivj/IhnPhq0HAaJgNq2E3WIM39Mi7R949svXI1iNbj2w9svXI1iNbj2w9svXI1iN7j+w9svfI3iN7j+w9svfI3iN7j+w9cvTI0SNHjxw9cvTI0SNHjxw9cvTI0SNnj5w9cvbI2SNnj5w9cvbI2SNnj5w98umRT498euTTI58e+fTIp0c+PfLpkc8d+fx+DaNhNqyG3WAN3hAN2dAjjx559MijRx498uiRR488euTRI48eefTIs0eePfLskWePPHvk2SPPHnn2yLNHnj3y6pFXj7x65NUjrx559cirR+4aPF2Dp2vwdA2ersHTNXi6Bk/X4OkaPF2Dp2vwdA2ersHTNXi6Bk/X4OkaPF2Dp2vwdA2ersHTNXi6Bk/X4OkaPF2Dp2vwdA2ersHTNXi6Bk/X4OkaPF2Dp2vwdA2ersHTNXi6Bk/X4OkaPF2Dp2vwdA2ersHTNXi6Bk/X4OkaPF2Dp2vwdA2ersHTNXi6Bk/X4OkaPF2Dp2vwdA2ersHTNXi6Bv++j/89Go/mo/VoP7JH/ige5aPnMZ7HeB7jeYznMZ7HeB7jeYznMZ7HeB7zecznMZ/HfB7zecznMZ/HfB7zecznsZ7Heh7reaznsZ7Heh7reaznsZ7Heh77eeznsZ/Hfh77eeznsZ/Hfh77eeznYc/Dnoc9D3se9jzsedjzsOdhz8Oehz8Pfx7+PPx5+PPw5+HPw5+HPw9/HvE84nnE84jnEc8jnkc8j3ge8TzieeTzyOeRzyOfRz6PfB75PPJ55PPI53Gex3ke53mc53Gex3ke53mc53Gex6vz8ep8vDofr87Hq/Px6ny8Oh+vzser8/HqfLw6H6/Ox6vz8ep8vDofr87Hq/Px6ny8Oh+vzser8/HqfLw6H6/Ox6vz8ep8vDofr87Hq/Px6ny8Oh+vzser8/HqfLw6H6/Ox6vz8ep8vDofr87Hq/Px6ny8Oh+vzser8/HqfLw6H6/Ox6vz8ep8vDofr87Hq/Px6ny8Oh+vzser8/HqfLw6H6/Ox6vz8ep8vDofr87Hq/Px6ny8Oh+vzser8/HqfLw6H6/Ox6vz8ep8vDofr87Hq/Px6ny8Oh+vzser8/HqfLw6H6/Ox6vz8ep8vDofr87Hq/Px6ny8Oh+vzser8/HqfLw6H6/Ox6vz8ep8vDofr87Hq/P56ny+Op+vzuer8/nqfL46n6/O56vz+ep8vjqfr87nq/P56ny+Op+vzuer8/nqfL46n6/O56vz+ep8vjqfr87nq/P56ny+Op+vzuer8/nqfL46n6/O56vz+ep8vjqfr87nq/P56ny+Op+vzuer8/nqfL46n6/O56vz+ep8vjqfr87nq/P56ny+Op+vzuer8/nqfL46n6/O56vz+ep8vjqfr87nq/P56ny+Op+vzuer8/nqfL46n6/O56vz+ep8vjqfr87nq/P56ny+Op+vzuer8/nqfL46n6/O56vz+ep8vjqfr87nq/P56ny+Op+vzuer8/nqfL46n6/O56vz+ep8vjqfr87nq/P56ny+Op+vzuer8/XqfL06X6/O16vz9ep8vTpfr87Xq/P16ny9Ol+vzter8/XqfL06X6/O16vz9ep8vTpfr87Xq/P16ny9Ol+vzter8/XqfL06X6/O16vz9ep8vTpfr87Xq/P16ny9Ol+vzter8/XqfL06X6/O16vz9ep8vTpfr87Xq/P16ny9Ol+vzter8/XqfL06rzYkz6LxaD768wg0D+9H9sgfxaN8dJq+Or80Hs1Hz8Ofhz8Pfx7+PPx5+POI5xHPI55HPI94HvE84nnE84jnEc8jn0c+j3we+TzyeeTzyOeRzyOfRz6P8zzO8zjP4zyP8zzO8zjP4zyP8zxOe1Tj0qXxaD5aj/Yje+SP4lE+eh7jeYznMZ7HeB7jeYznMZ7HeB7jeYznMZ/HfB7zecznMZ/HfB7zecznMZ/HfB7reaznsZ7Heh7reaznsZ7Heh7reaznsZ/Hfh77eeznsZ/Hfh77eeznsZ/Hfh72POx52PN4db5fne9X5/vV+X51Xi1PMYtOU9U5aDyaj9aj/cge+aN49Dz8ecTziOcRzyOeRzyPeB7xPOJ5xPOI55HPI59HPo98Hvk88nnk88jnkc8jn8d5Hud5nOdxnsd5Hud5nOdxnsd5Hqc9qjnq0ng0H61H+5E98kfxKB89j/E8xvMYz2M8j/E8xvMYz2M8j/E8xvOYz2M+j/k85vOYz2M+j/k85vOYz2M+j/U81vNYz2M9j/U81vNYz2M9j/U81vPYz2M/j/089vPYz2M/j/089vPYz2M/D3se9jzsedjzsOdhz8Oehz2PV+f26txendurc3t1bq/O7dW5vTq3V+f26txendurc3t1bq/O7dW5vTq3V+f26txendurc3t1bq/O7dW5vTq3V+f26txendur82q5CiuKR/noNFWdg8aj+Wg92o/s0fM4z+M8j9Me1YB1aTyaj9aj/cge+aN4lI+ex3ge9Wtxo2g+Wo/2I3vkj+JRPjpNX51feh5fnecsWo/2I3vkj+JRPjpNX51fGo+ex3oe63ms5/HVee6ieJSPTtNX55fGo/loPdqP7NHz2M9jP4/9POx52POw52HPw56HPQ97HvY87HnY8/Dn4c/Dn4c/D38e/jz8efjz8OfhzyOeR/1Kap1h9VupoPXo8/Aie+SPPo8syken6avzU2fTV+eX5qM/jxNF+5E9+vM4GCUe5aPz/f7md0NUvV2NgziJi7iJRnRiEJP43Krfq3EQy20ULuImltsudGIQk3gejh9xECdxETeRboNug26j3KzwPMTvywIHcRIXcRON6MQg0m3SbdFt0W3RbdFt0W3RbdFt0W3RbdFt023TbdNt023TbdNt023TbdNt083oZnQzuhndjG5GN6Ob0c3oZnRzujndnG5ON6eb083p5nRzujndgm5Bt6Bb0C3oFnQLugXdgm5Bt6Rb0i3plnRLuiXdkm5Jt6Rb0u3Q7dDt0O3Q7dDt0O3Q7dDt0O08t/z9iIM4iYu4iUZ0YhCTSLdBt0G3QbdBt0G3QTdkSRYGMYnnIbIEOIiTuIibaES6TbpNuk26Lbotui26Lbotui26Lbotui26Lbptum26bbptum26bbptum26bbptuhndjG5GN6Ob0c3oZnQzuhndjG5ON6eb083p5nRzujndnG5ON6db0C3oFnQLugXdgm5Bt6Bb0C3olnRLuiXdkm5Jt6Rb0i3plnRLuh26Hboduh26Hboduh26Hbodup3ndn4/4iBO4iJuohGdGMQk0m3QbdBt0G3QbdBt0I1Zcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZUl2CY4zCTTSiE4OYxPOwsuTiIE4i3Q7dDt0qS8YsDGISz8VZbYSNgziJi7iJRnRiEJNIt0G3QbdBt0G3QbdBt0G3QbdBt0G3SbdJt0m3SbdJt0m3SbdJt0m3SbdFt0W3RbdFt0W3RbdFt0W3RbdFt023TbdNt023TbdNt023TbdNt003o5vRzehmdDO6VZaMXejEIJZbFJ6HlSUXB3ESF3ETjejEINLN6RZ0C7oF3YJuQbegW9At6BZ0C7ol3ZJuSbekW9It6ZZ0S7ol3ZJuh26Hboduh26Hboduh26Hbodu57mN3484iJO4iJtoRCcGMYl0G3QbdBt0G3QbdBt0G3QbdBt0G3SbdJt0m3SbdJt0m3SbdJt0m3SbdFt0W3RbdFt0W3RbdFt0W3RbdFt023TbdNt023TbdNt023TbdNt023QzuhndjG5GN6Ob0c3oZnRjlgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJYpYsZslilixmyWKWLGbJYpYsZslilixmyWKWLGbJYpYsZslilixmyWKWLGbJYpYsZslilixmyWKWVCfm+N5NOqsVs9GITgxiEs/DypKLgziJdFt0W3SrLJmjMIhJPA8rSy4O4iQu4iYakW6bbptum25GN6Ob0c3oZnQzuhndjG5GN6Ob083p5nRzujndnG5ON6eb083pFnQLugXdgm5Bt6Bb0C3oFnQLuiXdkm5Jt6Rb0i3plnRLuiXdkm6Hboduh26Hboduh26Hboduh27nuVVbZ+MgTuIibqIRnRjEJNJt0K2yZK7CSVzEcvNCIzoxiEk8DytLLg7iJC4i3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0W3TbdNt023TbdNt023TbdNt023TbdjG5GN6Ob0c3oZnQzuhndjG5GN6eb083p5nRzujndnG5ON6eb0y3oFnQLugXdgm5Bt6Bb0C3oFnRLuiXdkm5Jt6Rb0i3plnRLuiXdDt0O3Q7dDt0O3Q7dDt0O3Q7dznOz3484iJO4iJtoRCcGMYl0G3QbdBt0G3RjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLMkmCXBLAlmSTBLglkSzJJglqDvdZ7CJJ6HyBLgIE7iIm6iEZ1It0G3QbfKku8vfkz0vV6cxEXcRCM6MYhJPA8X3RbdFt0W3RbdFt0W3RbdFt0qS9b3dSv6Xi8O4iQu4iYa0YlBTCLdjG5GN6Ob0c3oZnQzuhndjG5GN6eb083p5nRzujndnG5ON6eb0y3oFnQLugXdgm5Bt6Bb0C3oFnRLuiXdkm5Jt6Rb0i3plnRLuiXdDt0O3Q7dDt0O3Q7dDt0O3Q7dznND3+vFQZzERdxEIzoxiEmk26DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26LbohuzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMksOs+QwSw6z5DBLDrPkMEsOs+QwSw6z5DBLDrPkMEsOs+QwSw6z5DBLDrMEfa9rFybxPESWAAdxEhdxE43oRLpNuk26Lbotui26Lbotui26Lbotui26Lbptum26bbptum26bbptum26bbptuhndjG5GN6Ob0c3oZnQzuhndjG5ON6eb083p5nRzujndnG5ON6db0C3oFnQLugXdgm5Bt6AbssQLz0NkCbDcsnASF3ETjejEICbxPESWAOl26Hboduh26Hboduh26HbabaHv9eIgTuIibqIRnRjEJNJt0G3QbdBt0G3QbdBt0G3QbdBt0G3SbdJt0m3SbdJt0m3SbdJt0m3SbdFt0W3RbdFt0W3RbdFt0W3RbdFt023TbdNt023TbdNt023TbdNt083oZnQzuhndjG5GN6Ob0c3oZnRzujndnG5ON6eb083p5nRzujndgm5Bt6Bb0C3oFnQLugXdgm5Bt6Rb0i3plnRLuiXdkm5Jt6Rb0u3Q7dDt0O3Q7dDt0O3Q7dDt0I1ZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZgr7X76/6LvS9XpzEz22vwk00ohODmMTzsLLk4iBOIt2cbsiSKHRiEJN4HiJLgIM4iYu4iXQLugXdgm5Bt6Rb0i3plnRLuiXdkm5Jt6Rb0u3Q7dDt0O3Q7dDt0O3Q7dDt0O08N/S9XhzESVzETTSiE4OYRLoNug26DboNug26DboNug26VZbYLDwPK0sufm62CidxEeuc3IVGdGIQk3geVpZcHMRJXES6Lbotui26Lbotum26bbptum26bbptum26bbptum26Gd2MbkY3o5vRzehmdDO6Gd2Mbk43p5vTzenmdHO6Od2cbk43p1vQLegWdAu6Bd2CbkG3oFvQLeiWdEu6Jd2Sbkm3pFvSLemWdEu6Hboduh26Hboduh26Hboduh26neeGvteLgziJi7iJRnRiEJNIt0G3QbdBt0G3QTdkySh0YhCTeB7ivgQ4iJO4iJtIt0m3SbdJt0m3RbdFt0W3RbdFt0W3RbdFt0W3RbdNt023TbdNt023TbdNt023TbdNN6Ob0c3oZnQzuhndjG5GN6Ob0c3p5nRzujndnG5ON6eb083p5nQLugXdgm5Bt6Bb0C3oFnQLugXdkm5Jt6Rb0i3plnRLuiXdkm5Jt0O3Q7dDt0O3Q7dDt0O3Q7dDt/Pc0Pd6cRAncRE30Yifm2VhEJP4uXn928qSi4P4ufkqXMRNNKITg5jE87Cy5OIg0m3SbdJt0m3SbdJt0m3SbdFt0W3RbdFt0W3RbdFt0W3RbdFt023TbdNt023TbdNt023TbdNt083oZnQzuhndjG5GN6Ob0c3oZnRzujndnG5ON6eb083p5nRzujndgm5Bt6Bb0C3oFnQLugXdgm5Bt6Rb0i3plnRLuiXdkm5Jt6Rb0u3Q7dDt0O3Q7dDt0O3Q7dDt0O08N/S9XhzESVzETTSiE4OYRLoNug26MUucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXoe/3+WshC3+tFJwYxiechsgQ4iJO4iHSbdJt0m3SrLAkvPA8rSy6W2yycxEXcRCM6MYhJPA+RJUC6bbptum26bbptum26bbptuhndjG5GN6Ob0c3oZnQzuhndjG5ON6eb083p5nRzujndnG5ON6db0C3oFnQLugXdgm5Bt6Bb0C3olnRLuiXdkm5Jt6Rb0i3plnRLuh26Hboduh26Hboduh26Hbodup3nhr7Xi4M4iYu4iUZ0YhCTSLdBt0G3QbdBt0G3QbdBt0G3QbdBt0m3SbdJt0m3SbdJt0m3SbdJt0m3RTdmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWoO81V+EibuLn9r3QfaHv9WIQP7c8hedhZcnFz+38CidxETfRiE4MYhLPw8qSi3QLugXdgm6VJccLnRjEP7e/b0ELz8MvSxrHh7UOX5Y0LuKf2/xelbiq77XRifFh7cWXJY3n4Zclf199Fg7iJC7iJhrRiUFM4mmsvtfGQZzERdxEIzoxiEmk26DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26ab0c3oZnQzuhndjG5GN6Ob0c3o5nRzujndnG5ON6eb083p5nRzugXdgm5Bt6Bb0C3oFnQLugXdgm5Jt6Rb0i3plnRLuiXdkm5Jt6Qbs+QwSw6z5DBLDrPkMEsOs+QwSw6z5Lws2b+XJfv3smT/Xpbs38uS/XtZsn8vS/bvZcn+vSzZv5cl+/ej26DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26ZbZcn31phdfa+N52FlyczCQZzEz+37jcpdfa+NRvzcVrlVllxM4uf2fcO/q++1cRA/t+97vV19r42b+LltK3RiED83qwOqLAFWllz83KwGqyy5uIifm/8KjejEz81rvpUlF8/DyhKvNassuTiJn1vUfCtLLhrxc4tas8qSi0n83KJWvbLk4iBO4iJuohGdGMQkPrfqe20cxElcxE00ohODmES6DboNug26DboNug26DboNug26DbpNulWWfPfVu/peGxfxc/v+gtKuvtdGJwYxiedhZcnFQZzERaTbotui26JbZcn3F5h29b1erCy5+LmdWTiJi/i5nTrMypKLTgxiEs/DypKLgziJi0g3o9uXJetX8/2ypDGJ58Oa75cljYM4P8zCRdxE+7C2250YjeiUzKJv2PEr/Ab4PhHsaolsdGIQk3gefqdZ4yBO4iLSbdJt0m3SbdJt0m3RbdFt0W3RbdFt0W3RbdFt0W3RbdNt023TbdNt023TbdNt023TbdPN6GZ0M7oZ3YxuRjejm9HN6GZ0c7o53ZxuTjenm9PN6Van2bDCJJ6H8SMO4iSWW52osYlGdOLnNuv8/S5ZjZ/b96a5XS2RjYM4iYu4iUb83OYuDGISy+27elVLZOMgllvN9yziJhrRiUH83L5XJOxqiQRWS2TjIH5u32/C7WqJbNzEz23/Cp0YxM9tY7Dz8AuNxjqKKPzGrVuYanNc2wtrhFN4HlY+XBzESVzEb9y6sak2x0YnBvFzq3ucanO8WPlgNcnKh4uTuIibaMTP7euw2NXm2JjE87Dy4XvitavNsfFz85pk5cPFTTRiuZVx5cPFJJ6HlQ8XB/Fzi5pO5cPFTTTi5xY1ycqHi0kst68gq82xcRCdWCPUUVR1161cNSmuxP93EhdxE43oxG/cuvhXk2LjeVjVnXXCVHVfnMRF3EQjfm51d1BNio1J/NxOTaeq++IgfoPVtb16EBuDmMTTWD2I6/ubkLt6EBsncRE30Yh/brtuCaoHsTGJ5+FXvPt7orirB7FxEteHNbOvpBuNWG5eWG5RWG6n8DycP+IgTuIifuPWpaO6DRuTeB5+Jd04Hu5CK5zEz6I+IVbT3677nWr6a0zieWg/4njo9f+t+fogTuIibqIRnRjEJJ6HQbegW9At6BZ0C7p91bLrWlgNd7uuZNVwt+szcTXcNW7iN0Jd1KrhrjGISTwPv7porHFrA06NUBtwaoSa2Uniaawmul0fxquJrnESF3ETjfi5rV9hED+3r8tuVxPdxSqGi9+431sNdjXG7bqEVmNcY803CmuE7zCrMa5xECexxrXCTTRiuXlhEJNIt0W3RbdFt7WIu/eiGuManRjEJL7drBY4bGE1u2ELq9ntbtYOYhLP2wvjbhp307ibxt007qbZ2zfjblq8zTLupnE3qwqxhVVv2Dfnbla9YQur3rBQzvUNrm9wfavesFnB3QzuZtUbNiu4m8HdDLoF3ZJuSbd8u1ldYPv71ahdXWCNk/hNp27Vqgus0YhODGISz8MqhouD+LnVbV11gTVuohGdGMRyq/lW4QCrcC4OYrmdwkXcxM/NamZVOBeD+LnZKDwPq3AuDuLn9v22za5+r103kdXv1RjEJNa4385Xv9ffGVRY40bhJC7iJpZbHXGV08UgJvFzq8dy1eS1636ymrx23S5Wk9eu269q8tr1AK6avBqdGMQknod1fbtYbrXqVVkXP7e6w6smr0YjOjGISfzcotah6u3iIE5iudV0qt4uGrHcamZVbxeT+LllbXfVW91PVpNX4yQu4iYa8Rs3a7vrqgesq97F+v9+xtV21fi5fd8D72q7alzETTSiE79jq2db1Xa164602q4uVvFeHMRJXMQadxXWCF+ZVivV/v5w+a5WqsZJrBG8cBON6MQgJrHcvn2rVqrGcquFqoK8uIh/49qv1uErPaunY9Ue1VgjWOF8C1Wld3ETjVjj1pJ8pdeYxPM2oK5kF7mbRjejm9HN6FZVCPyqxepmutqYGoNY529ZoFoKUS3AQZzERdzfYLUkYUQnBjGJ52H+iOvD2sLcRCM6MYhJPA/PjziIk0i3Q7dDt0O3Q7dDt/PcqmGpcRAncRE30YhODGIS6TboNug26DboNug26DboNug26DboNuk26TbpNuk26TbpNuk26TbpNum26Lbotui26Lbotui26Lbotui26Lbptum26bbptum26bbptum26bbpZnQzuhndjG5GN6Ob0c3oZnQzujndnG5ON6eb083p5nRzujndnG5Bt6Bb0C3oFnQLugXdgm5Bt6Bb0i3plnRjliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMksSWZKFSTyNBwFihZO4iJtoRCcGMYkvdM/4Eek26DboNug26DboNug26DboNuk26TbpNuk26TbpNuk26TbpNum26Lbotui26Lbotui26Lbotui26Lbptum26bbptum26bbptum26bbpZnQzuhndjG5GN6Ob0c3oZnQzujndnG5ON6eb083p5nRzujndnG5Bt6Bb0C3oxtuOw9uOw9uOw9uOw9uOw9uOw9uOk3RLuiXdkm5Jt6Rb0i3plnQ7dDt0O3Q7dDt0O3Q7dDt0O3Q77Wa/3484iJO4iJtoRCd+bl9jp1WXUuN5WFkyVuEgTuLn9j05tepSajSiE4OYxHLzDytLLg7iJC7iJhrRiUFMIt0W3RbdKktGrU5lycVNNKITg1huWXgeVpZcLLdTOImLuInfuN+zV6vOI5u1LZUPFyfxG2HWtlQ+XDTiN9/vuZxV51FjEs/DyodZB1T5cHESF7HGreWrmv8ej1l1EzUOYh1xWVTNX9xEIzoxiEn83FatTtX8xUGs+dZKVs1f3EQjOjGISTwPq+YvDiLdDt2q5lftUNX8qtO+av5iEJN4GqubqHEQJ3ERN9GI5WaFQUxiuX1nSXUTNQ5iuUXhIm7i57ZrsKr5i0H83L5vdK26iS5WzV/83L5neFbdRI2L+LlZTadq/qITy62mUzV/8Tysmv8ehFl1EzVO4uf2fQlr1U3UaMTPzWu+VfMXk/i5eblVzV8cxM8tduEibuLnFrVmdf9wMYifW9bG1v0DsPLh4ueWtSSVDxcX8XPLmk7lw0Unfm6nplP5cPE8rHz4nq1YdRM1TuKfm/9qUb/7h0Yj+ofl9t0/NCbxfFg7/2VJ4yD+uXmFbr1Fr3ETP7fK9XqLXmMQP7cKvHqL3sUvSxo/t0q5eote4yJ+blXd9Ra9RicGMYnn4ZcljYM4iYtIt0O3Q7dTbrU6J4mnsd6i9/f0uXAQJ/Fzq4Kst+g1GvFzq3Kqt+g1JvFz+56kW/WGNQ7i5/Y9/LZ6i17jJn5uVm5fljQG8XP7nmJbtYxd/LKk8XP7nm1btYw1LuLn5uX2ZUmjEz+3wGBJPA+/LPGowb4saZzEzy1qUb8saTTi55a1JF+WNObDSo2K12oDs1UHX/lw0YlBTOJ5WPlwcRC/+X7Ptq3awBo30YhODGISz8MvH/xrArVqA2ucxHKrlax8uGjEuh7XSVufLy4msdxqsyoJsg6okuDiJhrRiUFM4nlYSXBxEOmWdEu6Jd2Sbkm3pFvS7dDt0O3Q7dDt0O3Q7dDt0O3Q7Ty3avhqHMRJXMRNNKITg5hEug26DboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptum26Gd2MbkY3o5vRzehmdDO6Gd2Mbk43p5vTzenmdHO6Od2cbk43p1vQLejGLFnMksUsWcySxSxZzJLFLFnMkoUsicJBnMRF3EQjOjGISfzcvq+VrNrLGgex3LJwETfRiE4MYhJP40aWAAdxEhdxEz+37wtFq/6zxiB+bnU/Wf1nFytLLv65Rd1PVqfZ/bHKh+97Mquessbz/dvv4lM9ZY2DOImLuIn2YU39y4fGICax3GqS60ccxM9t1NS/fGjcxM+tnsPUe+0ag5jEz60eqNR77aI+H1fbWtStcL3BrtGITqxxo7DGraP4kiDq+UM1s0U9aahmtsZJXMTPbdZ0viRodGIQP7e6267OuKj76uqMi3qmUJ1xUZf86oyLutOtzrhGIzoxiEk8D7/yj/p8XJ1xjeudRsEzKnimBs/U4JlaNX/xPKyavziIk0i3pFvSLemWdMs6oFqzPA/Pj1gHVCv51XzjIm6iEZ0YxCSexmqzaxzESSy3LNxEIzoxiEn83PZ3xNVm1ziIk/i5fR3lVu+qazTi51aPIqolL+rTTLXkNZbbVwHVktdYbjWdyoeLi7iJRnRiEJN4HlY+XKTbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26ab0c3oZnQzuhndjG5GN6Ob0c3o5nRzujndnG5ON6eb060C5GsZs2r1azwPK0Aujr4kVatf4yJuohGdGMQkvqteNfVFfYCu98/hqlfvn4uvFc3q/XONSTwPKx8uDuIkfuNaldPh+p53xNVN2DiIk/itbz2Mq27CRiM68e1mdRM2vt308SMO4iQu4n5zQM0DnRjEfHOomgdWzV+kG2veWfPOmnfWvLPmnTXv8507PrmSiyu5uJJV85jD4kouriRr3lnzzpp31ryz5p0176x539w31DyQK7m5kpv7VjV/kSvJmnfWvLPmnTXvrHlnzTtr3lnzbtw340oaV9K5ks6V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",
      "is_unconstrained": true,
      "name": "get_config"
    },
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "14067204867181196045": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "9921926525851912681": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 128
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "utility"
      ],
      "debug_symbols": "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bdCNWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWVI9gmOMwklcxE00ohODmMTzsLLkIt0O3Q7dKkvGLDSiE4OYxHNxViNh4yBO4iJuohGdGMQk0m3QbdBt0G3QbdBt0G3QbdBt0G3QbdJt0m3SbdJt0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0W3TbdNt023TbdNt023TbdNt023TzehmdDO6VZaMXbiJRiy3KAxiEs/DypKLgziJi7iJRqSb083p5nQLugXdgm5Bt6Bb0C3oFnQLugXdkm5Jt6Rb0i3plnRLuiXdkm5Jt0O3Q7dDt0O3Q7dDt0O3Q7dDt/Pcxu9HHMRJXMRNNKITg5hEug26DboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptum26Gd2MbkY3o5vRzejGLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLFLFnMksUsWcySxSxZzJLFLFnMksUsWcySxSxZzJLFLFnM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",
      "is_unconstrained": true,
      "name": "get_current_value"
    },
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "14067204867181196045": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "9921926525851912681": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
          },
          "visibility": "public"
        }
      },
      "bytecode": "H4sIAAAAAAAA/+y9CZxc1XEuflvTM6hhpEYSq5FhQCwym9gRmyWxL5IRkkBmibFAYwEGCQsJGy/xAgIbGxCLWIyNZ9i9AF6SPCd52exsz/47cVbnZbOd5dlJHC+J7TiJk/x9rVsz33z93dPn3q6eaaF7fz9Qzz11qurUqapTp85ya8n2p5H9u25409Ub3rx+eGP6Ry17WU8mPrWkzVMLvGuhdPei7S+mZwXToELfT/4bSqKe2nQiVKz+u35mOiMsVD/5af1aUpb+9vandUq2PxnI/r0K6iMvhneXn/w3CL8PzX4PBup3yNtV06FOifq12Tn0jbf0OQsqDCVRT5/VPVvV/f4tX3n2i/d85jef3/TcMw/P+vMZj+125K7v3LLlO/t9e+4Hv7vlKat7DvBUS6JpD1j9cxXtV/+vviuu+9R/bNjtvNtfevOf/9/XbJ4xd83nDnjvM1f81v0H/MPVd1rd81Tdb37g8Xc2X3pgZOiIL/1g4Lz7vnX1v17Qv/DPv/T2fT//nh//w3cftLrnq7p/eMWP/+rnmg++9S33/OLbFs6fs+YTD37le//4O198sfmvX3/hTV850epeAG2uJ8V0PH0uLFd/zMYvKld/mtVfCvXL+Jhl5ervbvVfAy+H7Me7n37+r5bc86Vj/vbHu969bM0dbzn+/X+0+p/fus9zh/z9DS/M/cQsq3uxqvs3m866f9PeN530z9N//55jR/d75Ve//9zPfeOHtw0v/NY3vvkLB/6r1V2u6rZ5rO4lou4+xx12ys2PfnmPv5x/0F8s/vVPHP3Qvt8/+PS//Oz5o9/9j//zI6i7Ivu3oLzG+mtlufp1q7+qXP0x/3Ap1C9g42P6clm5+mP0V5erPya/18LLoXCdsbHb6l4eX9eefqt7hah7+OmN7z5z989uSb723D/d+8PD//fio2btv2TW0X/8+J/ut37jlft+1+peCQwV6LO5uybbx7VTs7hit5/8d3BWuHnT9Tdev+m2JbfcMrxx01kbbrp5zabrr7lx+OKNa669cfiy4Y23XL9hPSOs0d9n5bxP6ewzkc55w5su3f7rrA3rNw2/ZVM/4a3R39Po7z76u05/G77+nHpcp91j4/QA8TgUV3251d+lXP1hqz+9XP2NVr9Rrv4brP6u5epvsPq7lat/k9UfLFf/eqs/o1z99VZ/Zrn666x+s1z9Iau/e7n6t1j9WeXqr7H6s8vVX2v155Srf63V36Nc/Vut/p7l6t82mMHvBS/NRxnuveF9Ab/8yhrhS5KJfioh/A3ipWisViN8Ro/bZz7X2r6P4KUpythH7iPo7CPoKFy7OOKa7oir4Yhr1x5t426OuAYdcc1wxDXTEVfTEZen7D1taPcexTXLEZenTnjK3lO/Zjvi8rRtT52Y44jL00fv4YirV8dHi7MsdsBYo5bzr9Hhd0anQbhqSbm4R7Vrb0FvetLariJ5Z6O3r6Cn4iyDf0Ukf+kYYT4hm1efPXzN5nVLN6xL6OGp7jk5LM5NJrK/T4A1xluj//g94+4TsPikzTMxZc07d3jTtdetWrNu3fDanzTyFq7BmM7OeW9Kua+oa53+CuJ0KIl6psUoNeJvEC9llVopDbYPlcacfybVpRvWrD1rzc23bL5xmNMsOMVgqSBWfKf6tAac4bs+gjub/l4q6iUCN+rSflCmJGE4Zyatbdovpx6bLL+bJuBfQbheIeoZ732B+ogD67HGhLQ6RiutHenTTPLbHzMVLmk9e5S1nk6nwiFZpw8PCfuVozcnpKOI0/gxWc8VZYbrldnfAzm4rG6d4D+U/dtMWv3zcqIxV/CL70w+abr1EeIdZct60okcEZ/xhe8QfyPpSC9roX7D9rGezC1Hb3aM3JEfk/UrRZnh2j/7eyAHl9WtE/xHs3+bBJc+rCevFPziO9STp4l3lC3rSUk5LonVE8PfSDrSy1qo37B9rCevLEdvcYzckR+T9f6izHAdkP09kIPL6tYJ/heyf5sElz6sJ/sLfvEd6smnst/Tc/gdSqKeG5WsC9R/8/SkVXYF6m+y+geUq3/ddIIvWP9tVv/AcvWPsfoHlav/DtO9efCS7fxgeF9kaTPWzg1/g3gpa+cHEz1uH6fQDxG8NEUZp9APEXQOEXQUrumOuHZ1xDXHEdcujrh271Fcg464ZjjimumIq+mIa64jLk+971V5vdIRl6eu7u+I6wBHXJ6y92zjLEdcvaqrQ464DnTEZbGRjfcYH9Syf6eLekXnhojP+MR3iL9BvBSkVwvJBdvHc5pDy9GbVaP6SA9xGj8m68NEmeGan/09kIPL6tYJvj8TaJPg0ofnNIcJfvEdzmmso2YKfjm/U1QfsT7LCOuxPnbSX4jP+MR3iL+RdKT/tZB+KLlY+w4rR2/3mP5FfkzW80WZ4XpV9vdADi6rWyf4PUkf5wNPrI/zBb/4DvVx99pE3lG2rCcl5XhOrJ4Y/kbSkV7WQv2G7WM9mV+O3tkxckd+TNavEmWG6/Ds74EcXFa3TvAHkZ68CnhiPXmV4BffoZ7YXrXpOfwOJXEP24jhQNwol/h+qH0vVs8MfyPpqN9rITkqe7P2HV6KXu27rBtID3EaPybrI0SZ4Toy+3sgB5fVrRP8MaRnSIN1w8qQX3yHenYE+SOULetJOTkmZ8bqieFvJJ3o5bieqH5T9mbtO6IcvSUxckd+TNZHijLDdVT290AOLqtbJ/gzSE+OBJ7YHx0p+MV3qCcLyR8hv+kzlEQ9NSXrAvVbZIc4DPdR8L5AP/5PrJ4a/kbS2o9l9PQoopfXD9b2owUvTVGGMsYypHO0oFPhqnBVuCpcFa4KV4Vrx8Z1eIXrZYFrZ9Cvyoaqfqz8RGWPOyquSr8qXd0ZdbWKJyp5VW2sZL+j4qp0tdKJnVFelX5V/bgz4qpsqNKJnVH2lV+tbKiSV4WrHa5qblW1sfLRla7uqLgq/ar4qnBV9jiZbaxwVT6nGoeqNlZtrHxOJa+qHyv92nFxVbmOqo2Vz6n8RIWr0vvKhirZVzZU4eplXa3iiUonKtlXsp9MXNU4VMmrsqEKVztcva4TM7O/8c4w/p6Lup/rqAAdrG9wg6JeLft3uuAvpTOURD3R95YZ/kbS2uYC9Goh+Su5WNsXCF6aooz7eYGgs0DQqXB1juuIHsVVtfHlIa+dga8K18vDHis/UeGqdLXy95PJV9WPVRsr/arGjh2Vr0onKnlV+lX1Y4WrsqFKJ3ZO2Vd+tbKhSl4Vrna4qrlV1cbKR1e6uqPiqvSr4qvCVdnjZLaxwlX5nGocqtpYtbHyOZW8qn6s9GvHxVXlOqo2Vj6n8hMVrkrvKxuqZF/ZUIWrl3W1iicqnahkX8l+MnFV41Alr8qGKlztcFU6UeGqcFW4KlwVrgpXhevljsvuLcM7w44iOkXvR8P6BqfuJkv/G0qinlXTRRsK1L/a6h9Trv6brP6x5eq/xe4uOw5e1rJ/Dffx8L4vHvexNcKXZPXxHeJvEC8F6Y3d23Y80eP2mV5Y208QvDRFGevICYLOCYKOwnWAI65dHHE1HXHNccQ11xHXLEdcg464dnPE5akTsx1xLXDEtbsjrmMccU13xLW/Iy5P2x5yxOXpCz3tcYYjLs9+PMgRl6dOeMre07Y92+ipE7s64upVP+HJ184QM1Vj2tTJ3tMeG464PNt4bI/yNeSIy7ONNtaquTDy3ebZzHNNw4G4T4T3Bea9r64RviTR82zD30ha21lmnn0i0cuTq7X9JMFLU5TxPPskQeckQUfhOsAR1y6OuJo92sZBR1wzHHHt74jLU/ZDjriqfiyG6yBHXJ46MdsR166OuDz91+6OuDxl76mrnrLvVf/lqaue+rWbIy7PfvTUL08b8tSv6Y64ZvVoG3s1lvNso2c80av92Kux3LGOuHo1zvGMMat44uVhQ55+wpMvT/06xhHX8Y64PGXvGQPYWGt5oGOgXi37t8Mc2IE1wmd84jvE30ha+9IrB4btM7lY+04qR28oph+QH5P1yaLMcC3M/h7IwWV16wR/xsD2f5uCxmFEw8qQX3xn8ulP8Wd4Zwp+2eaU3E8UeJuiPssI67E+luyvvlh9NPyNpCP9r4X0Q8lF6YfVVf3K8o/t1xAuzgtbefpMF/UKyKMeK3/D30g66u9aSC7KT1rbFwpemlSWPssBjsv6xLtpk4yL+yt9hpLgY93RIgvjDfGeAu8L9Et/rB4Y/kbS2i9l9OAUopcnU2v7qYKXJpWlD/fdqYLOqYLOjoILdYh9lJWnT4d6MausXpT0R0G9UH7T2odyKUBv95h+QH5M1qeJMsN1evb3QA4uq1sn+A0ULyANjhesDPnFdxgv3EDxAvJ7MuFVcj9F4FXjlcG93OgMinpsXyX1L9rvGv5G0pE910L6ruSi9N3qKj1l+cfq6Y6Iy/Tv1ACdov4d659a0XGnc1KHdE6KpLOwQzoLBZ1BUY/9EOppvF+ofS3WDxn+RtKR36uF7FDJxdp3eil6ta/y2Iz0EKfxY7I+Q5QZrldnfw/k4LK6dYJ/msZ5pMHjvJUhv/gOx/mP0DiP/PK8tKj/w/osI6zH+liuv5JmrD4a/kbSif6P66PSDyUXa98Z5ejNjOlf5Mdk/WpRZrgWZX8P5OCyunWC/znSx1cDTzxfebXgF9+hPr6U4Z2ew+9QEvW8Rsm6QP2vT09aZVeg/rFWf1G5+iNWf3G5+q+y+kvK1f+s1T+zXP1zrP5Z5er/gtU/u1z9d1v9c8rVf63VP7dc/Z+x+ueVqz/f6p9frv7xVv+CcvW/afUvLFf/fKt/Ubn6v2j1l5arf7PVX1au/v1W/zXl6p9l9S8uV/8HVn95ufoPWv1LytX/rtVfCfWLrKlY/UvL1e8zflfhS8GT4bexbgXA13L+NVxcZrQahKsg77UQ78gfx0urgB62MQ/XqoK4pouyMn2yMslvF+IfDPCi+DwQfnfa5tmOuE53xDXdEdcZjrhe7YhrkSOuxY64ljjiGnDEdaYjrrMccZ3do7jOccR1riOu8xxxne+I6wJHXBc64trTEddFjriWOuJa5ojrNY64PMeOix1xLXfEdYkjrsN6EFf6WPzbYb7jgg7zFad2mK9Y1mG+YmWH+YYlHeYbzuswX3B2h/mCpRZrnw8va9m/KhdQIO5/TY3wJYmePxn+BvFSkN7Y/OkCosft4/XGCwUvTVHGNnKhoHOhoKNwzXDEtYcjrlmOuOY64hp0xDXbEVfTEddujrh2ccS1e4/i8tTVmY64PGW/yBGXp6562uP+PdpGT3s83hGXpw31quwPcMTl6Sc8x1pPP+Epe0959ap+ecYmnv3oKfudwU8MOeJa7IjrTEdcS3oU11mOuM52xOUp+wU9ytc5jrgGHHF56sTpjrjOdcTl2Y+efHnq6mJHXJ7yOtoRl6euevajJ1+9Ki9PXT3PEZenrnr6r4MccXnGXw1HXJ45Bc+Y3HOu4Jl7tPje8tjnQL1a9m+HOfyZNcJnfOI7xN8gXgrSC+bwsX28N/rCcvRmxPQD8mOyvkiUGS5bux3IwWV16wT/hUxpmwSXPry+eZHgF9/h3ujf2mUi7yhb1pOScpwbqyeGv5F0pJe1UL9h+3it5yLBS1OUcUwcK2+Fa7ojrl0dcc1xxLWLI67dexTXoCOuGY64ZjriajriWuqIy9OGPPtxD0dcsxxx7e+Iy9O2PfXL04Y8/erOIPvdHHF5+mjzhXYuEeOZvYlO0dgb6xtch+ddVnR43uWyDs+rXNzheZNzLa5aDi9r2b/qLEmBGO/dNcKXJDqmNPwN4qUgvbGY8hKix+3jmHKl4KUpynj/kDoPsVLQUbhmOOLawxHXLEdccx1xDTrimu2Iq+mIa6kjrumOuDxl36u6ur8jrl0ccXnql6fP2dUR184g+916tI279yguT9ue6YjLU/aLHHF56mqvxgCeuKpxuxiuatyeOv2qxu2pk301bk+dbffquO0pr17V1eMdcXnKy9PneMr+AEdcnjbkOW73qo/u1XjCs42esa9nP3rKfmfwE0OOuAYccV3oiMszT36RI66zHHEd7YjrTEdcCxxxne6Ia5kjrp1B9osdcS1xxHW2Iy5Peb3GEZenrnraUK/qfa+2cWfwhZ58VWPHy2PsuNgRl2cs5ymv8xxxneuIa4kjLk+d8JRXr44dBzni8pzzNRxxea7peOYBPPMTnvtz+IwN7g2rZf92eOfxjBrhMz7xHeJvEC8F6dVCcsH2mVw6vP93sEb1kZ6649dkfakoM1yXZX8P5OCyunWC3z8zpibBpQ+fsblU8IvvTD7pGZt9GxN5R9mynpSU48GxesL3UZfUy+B91Mp+VL9Z3aYo4/xTrLwVrumOuHZ1xDXHEdcujrh271Fcg464ZjjimumIq+mIa6kjrlmOuDztcX9HXJ765SmvuY64PPXL04Y8/aqnTnj61V61bU979LShPRxxedrjzqBfuzni8owB+AwXxst8hqvoHdhYP+97I1aePh1+j+b+GuEzPvEd4m8krW0uE7Mr+Su5WNsvE7w0RRnn8y4TdC4TdBSuGY649nDENcsR11xHXIOOuGY74mo64lrqiGu6Iy5P2feqru7viGsXR1ye+uXpc3Z1xLUzyH63Hm3j7j2Ky9O2Zzri8pT9IkdcnrraqzGAJ65eHbc9Ze8ZA3j6aM94old1tRq3p86vVjF5MVxVTD51+lXFhVOnX70aF3rKq1d19XhHXJ7y8vQ5nrI/wBGXpw15jh296qN7dUzzbKNn7OvZj56y3xn8xJAjrgFHXGc54rrQEdfRjrg814c85XWeI64FjrhOd8S1zBGXp06c6YjLU/aetu1pj542dJEjLk973Bn0a7EjriWOuM52xOUpr9c44vL0hZ4+ulf1vlfbuDOMtZ58VbHJy2PsuNgRl2c84Skvz5j8XEdcSxxxeeqEp7x6dew4yBGXZ06h4YjLc93KM8/kmf/y3F/IZzBxb2st+3e6qJfSGUqinsEa4TM+8R3ibxAvBenVQnJR+6StfavL0dutRvWRHuI0fkzWrxVlhuvy7O+BHFxWt07wT2QL8E2CSx8+g/lawS++M/mkZzAf23Ui7yhb1pOScvyNWD0x/I2kI72shfpN2Y+177Xl6P16jNyRH6N3eTl6fdZXVwrcxstV2d8DObxY3TrBf4r04QpRp0ll6cM6iGV94t20KcJ1pcCFcrQ+SW3juUwWSv/T/4aSqOc49guGA3GX1IXVsbZl+BtJR7peYz9m9PJ8jNIjq9sUZWfB7076Pv29f4/i2sUR126OuJY64vKU16AjrhmOuGY64mr2aBt37VG+5jji8rRHz36c7YjL04Z2d8Tl2Y+eurqHIy5P/ZruiGtPR1yeet+rPsezjUOOuA50xHWQIy5PeXnGJp761atxoafe92osN8sR11xHXDtDLNereu8Zm1RjWjFcvRrL9aov9IzlPH2hZz96yqtX469XO+Lq1fir4YjL07Y9bchTXp7jkKcN9arsPf2XZ16uV3NDnvrlGfv2aozZq2PHakdcNnYMEm4rT58O15teWSN8xie+Q/yNpLWdXutN2L6y6028n71X/KGnHfVqrtzTh3niqtabiuHyzM152pBnP3quB3jGOr2ah/HUL0++enVdp1dzFJ796LlXwdPf892pGBvx3akqDrk8QAfrG9ygqFfL/p0u+CsQL22pET7jE98h/kbS2uYy8ZmSv5KL2rtmdZuijPfhh/ZvIR2Fa4Yjrj0ccc1yxDXXEdegI67ZjriajriWOuKa7ojLU/a9qqv7O+LaxRGXp3558uXZj558efpVT53w7MfdHHF5yn73HsXl6SdmOuLylP0iR1yeutqr8YQnrioGmLqxo4oBpo6vKgaYun6sYoCp8xO9GgN4yqtXdfV4R1ye8upVP3GAIy5PG+rVsaNXY99e1S/PONqzHz1lvzP4iSFHXAOOuC50xOWZv7/IEddZjriOdsR1piOuBT3Kl2c/evJ1uiMuT53w7MfFjriWOOI62xGXp7xe44hrmSOuXtXVyh6nro29ql/VOFTpPeO62BGXZ4zp2Y/nOeI61xHXEkdcnjrhKa9etceDHHF5zkUbjrg816088xOeeRPP/UyW67D9hziXP4noDAg6AwE6WN/gpot6Q0nUc5rt3zsaXtYIL/rjvnjc9RrhS7L6+A7xN4iXgvTG9i6eQfS4fSZTa/siwUtTlHFOZpGgs0jQaYqy5V3ANT2Hz6Ek6rlU9XeB+m9keRoO5G0xvC/Qt/vE6tLi7Hcjae2/Mrq0mOjl9Yu1fYngpSnKuI+WCDpLBB2Fa4YjrjN6lK9dHXG90hGXZxubjrh2c8S1uyOumY64POW1vyOuPR1xLXXEtYsjLk/ZDzrimt2jbRxyxHWgIy6bv0xWrKroLOyQzkJBZ1DUq2X/dhiLHFkjfMYnvkP8jaS1zV6xiJJL0VjkYvjdqT55jtPHO+LyHKd71cfs4YhrliOuuY64doaxolfjZk++5jji8oxrPGNdT51oOOLy1Inpjrg85eXpv3p1nuHZj5589erY4dmPnrL3tO2dac7Sa/Lq1XHb07a7MdbafGUx1Ktl/04X9boxVzP8DeKlIL1aSC6L4R3P1c4WvDRFGa8bny3onC3oKFyDjrh2d8Q1xxHXro649nDEtYsjruk9ytdsR1xNR1xDjrgOdMR1kCMuT3nNcMTlaY/7O+Ly1HtPX+jZjw1HXJ4+x1MndnPE5Sn7WT3K11JHXJ464RmbeI7bnv3Yq/7LU7887bFXfbQnLk/9mumIy2Rv63dLoOwSorNE0FkSoIP1l0wyHTW/TP8bSqKea3j+ZjgQN+6DLTCXvLZG+JJEz10NfyNp7bcyc9fziF6enljbLxS8NEXZmfAby5DOhYKOwnWsI66ljrh2ccQ1xxHX/j3axtmOuJqOuDx1YpYjLk+dOMMR186gEzMcce3qiKtXbdtT9p7yavRoG+c64vLsR0+9n+mIy1PvD3DE5akTQ464PHWiir9eHj7ac6xd4IhrZ/CFBzni8vQ5SxxxHe+Iy9OGPOXlOabt6oirV+U15IirV+dWnrL3tCFPeXn66GrseHmMHZ5zq10dcU13xFXlFKbOhjxl79nGPR1x9ep8yFP2g464ejVfOOSIq/ITxXB5xhOVn5g62feqn7D4i+/MSJ+hJOqp2frpmfiS8JZcO+6vEb4kiVs7PrMcveDaMbav7Nqx11pV+izvcVy29wH7/hyio+R8XoAO1je4QVGP9Q/7oIA+nBarf4a/kXSk77WQ/JVcrO0XCV6aouxi+I1lSOciQUfhmuWIa9AR11xHXLs44prtiKvpiGt/R1y7OuLybOOcHm3jbo64ljriOt4Rl6d+edqjp355+kJPvmY44vLU+51BJw5wxOWpX7v3aBs9Zd9wxOWp99MdcVV+4uXhJzzbuKcjLs94oldlP+SIq7KhYrgWOOKqbGjqZO85d/ecIx+U/Z4p2sx3Ai4QdBYE6GD9BQE6CzukszCSTjfaM13UG0qCT91+cF7UcCNe7Ktu5IQNf4N4KUivFtJFlRO1ti8TvDSpLH0497pM0Fkm6OwouNrpLueEi+ruOZF0KpvvnfZMT/Q4NJREPW9VPqRA/aPYRg0H8nYFvC/gL5bG+ifD30ha7aWMf7qC6OXZp7X9SsFLU5R5fmdkV0dcO8M32nv1m729+n1pzzZ68rXAEZenrk53xOVp256yn9Gjbaz818vDf3m20VP2cxxxeer98Y64PG27V+3R00f36ljr2Y+e30DbGcahnaGNnnx5+tVeHbcv6lG+POV1rCMuz29LesYmvTqmVfY4dW3s1XF7Z5ineerEEkdcvar3Sx1x9WquYw9HXN3w0WpN4EyiU3RNAOv3whrHhR3SubDH2lOtQVXtSX9f0iGdSyLpVHrQO+0psW/DnhNsbfBYeFkjvLgeWGCdcmaN8CWJXhc1/A3ipSC9sXXR04ket4/XRa8QvDRFGfYjliGdKwSdpihbXuGqcFW4XHD18P44C6nHfA36JvazJfefRO+P4/0nJf16cP8Jto/97JWCF56HpA/rSNk5Ta/i2sljkWm/P+d1mwee/plrjzpsxjnf22f2Q7cv+s173rPosCN5PDbciBdlWEBn67E2YvgbSUc2WQvpiPJv1varBC9NUcb3Clwl6Fwl6ChcCxxxHZH9ruYMO7Cdfv+Wrzz7xXs+85vPb3rumYdn/fmMx3Y7ctd3btnynf2+PfeD393ydIe2uNrqX1Wu/hyr/zPl6s+2+q8rV3+W1b+6XP2zrf7ry9VfYvXXlKpfG+v7a+DtUFTd8bZfO4atEO+Lrf7acvUPsPrD5er/t9V/Q6n6te9a/XWl6if/ZfWvg5dD9uPV/6vvius+9R8bdjvv9pfe/Of/9zWbZ8xd87kD3vvMFb91/wH/cPVdVvf6crQHrf4N5ervZvXfWK7+flb/Rng5FFU1mWZ1bwLa0+LrT7f668vVP8nqbyhX/2SrfzPULyC7Iav/pnL1x9q/sVT92let/i3IVPbvwX/6S7v828fuq3/6z7674c0/OPzBL5x3z69+/PQHvnTUq9+18m8f/vYyq7upFO1khtXfLGi34XvM19069qZYDsvqv7kw7aRudd+i6n7zA4+/s/nSAyNDR3zpBwPn3fetq//1gv6Ff/6lt+/7+ff8+B+++5DVvU3V/cMrfvxXP9d88K1vuecX37Zw/pw1n3jwK9/7x9/54ovNf/36C2/6ypiuvjUDL9jmPaz+28rV77f6by9Xf8Dqv6Nc/V2s/s+Wq9+w+u8sV39Xq/8ueDmURD1Nq/tuUXfOsclXDvjqibcdsddJGy6+9Y6vrnrhZ/d46lXfaO7z7c2n3/rvf7nB6r5H1G3znNj/k//dnG1EsRjU4sj0977wO/3PDv6l9SwG3QdgrG6d4H9wyHi9TRm9QapjONJnOtUv2Bf71ghfkuh5n+FvJK1tLzPvqxM9bh/P+/oFL01RNgS/sQzp9As6CtdBjriajriWOuLaxRHXDEdcsx1xDfZoG2c64upV/ZrliGu6I679HXF56penvOY64vLUL08b2tURl6dOePpV2/86KOrVsn8tDtgL3hcYl6fVCJ/xie8Qf0PwWSYO2Ivo5cllt2R8TNi86fobr99029INa9aetebmWzbfOMyREUZDLBXEiu9qycTWY1kfvesjuHPp76WiXiJw9wHdvaFMScJwWvSJbdo7px7KIhHvpgn4vQjXXqKe8d4XqJ8+g4KHqdbYkpFyUGOxfRy57i14aYoylGGex1ARclG+dkvGvXlmSWcPX7N53dIN6xJ6WHXOyWFxH4JbmsNaTeCt0X/8fh9615eETTU0WYpRmSRpdcYo6n2ITuWMK2e8YzjjPlGPNWameM9bJouGMpcIeorOpR3SuVTQmS7qDdmPdz/9/F8tuedLx/ztj3e9e9maO95y/Pv/aPU/v3Wf5w75+xtemPuJ2Wmdr1DKB+XPDtj6HVM+qr/qBL/kkPF6f5HR2w3KMws7c/ONb1wxvGnj9cO3Dv/EV2OieUxECZBjdX8N/X2xqKeemDG8pOOJdnSG32sMV6qVN1bGOzpWCJQKYsV3taS8o7uY/i7j6NpFDezoQs4Je2WaoGvvpiX5jkg5Mc41hhxZ+lRD8/anuMbuzENzjMbGDs15Gps3NHO9/iRfw+sE+6NsyOhQsydknpjHagzY/lRjwI4yBvSJeqwxIa2O0cokaQ1CVfunJ63yGLIff7PprPs37X3TSf88/ffvOXZ0v1d+9fvP/dw3fnjb8MJvfeObv3Dg9zu0rss69AqXpnQHM9dg/Y9ZC57c2TooBsG47ml16wT/ilnj9XbPfqeWl8XGZnmXrbnx+rVrNg2fs/5Nm4c3D699zYZNw7csWb/2nFuH128qHBKfR3+fL+qpp4sLstHucKoWZIU7XLlpw8Y164ZXDK9Zyy4NpcD/5rk8NkfujcupnPEsFXgSQauPfteSVnpKEuwOawLnrlB2tKCzt8Bn8LbldADwIQybkMHvn5lNuvSweNH238otGT+DVN/K08e0+BjifSiJeqK12PA3iJeyWnwM0eP2lRvU0eGxVBArvgtp+GQM6sdBmZIEazG26biceqy5/G6agD+GcB0j6vGgruojDqzHGsNWhAPR0YI2W9ECsKKzFuXTPTpplQNb0jRBz6zuOIJNH7O6E6hNQ0nUszrW6gx/g3gpa3UnED1uXzmrQ01BKpcRVoNBWHwuA84Qnv/m3usX9fgxPHXi+XwIZ06h8AnbdTDxrbQd33G4ifUNTtHZr0M6+wk6psm49e0IKpsXKDsEyg6mskOhjFdcDgM+l1PZ/KS1zVZ2ZADnUQJn2nffmDVeJ/1vMcApTWevughoYl38u1/A2vGlOsFeCXq1jPQKrZj16rg2fIf06rgkn85+HdLZT9CxPkH9Zd05QbTVyk6EMu7nk4EX1p1TRLus7NQAztMEzrR//nrWRLjFAMce/3x4X2R6F+vxDX+DeCnr8c8netw+nvpeUI7epTWqj/QQp/Fjsl4uygzXiuzvgRxcVrdO8Ndl/dkkuCRpPfq6XPCL7zDRdy3pCcq2lvOv4eV3bF/Y9sXJRDrob/YBfm7K8XkYSWFdSy2wrzoa1rVuJl+F9bnvrL6Vq3+TJK79i5PWNs5MWmXzCvidp9/nB+i8ItCebvXnK4jOcaKtqezfTv15AZT1ibp2bLBO8HtDf76T+lPZopIzj0tF5XywoNNtOfP4styRDvoNTJOl/60kXCxn6yeT8wooW0n1VkEZwuGsayW8XyVoK/yGo50Obp2l25ang0arTvA/Pni83oMldZCvxcA+WJxM5NP4QDkg/M8kul0DOfB57fogzDrPXTQRJ8YUqi/Y/xr8hwHnBYs0n9iuRfCOlzGUPqwU7VIyXZW0p41yXppDeyAJ62Kd4J8WMlXjwkriHXG/inhZ0YZ3tm+sb3CDol6nfkTx3M4mXyhok6/PfrPu/j3Y5CfJJkM6gjzzPKKonPcTdLotZ54jrHKkgzbD48LlhIvl/Prst8l5NZRdTvXwigKEw3HhcnivrutQ+GPHhd+YpduWp4NGq07wXwAd/M3AvDikg6uoDGW6OJnIZzt/+HqCN74HkvB4Wyf4LwbGBWWvqDc8Lhj87wXGBaOL7QqNC0oXV4t2KZleTrgWCVwoZx4XlEyx/Yuo/Qb/J5HjgtVX+YjDqQzzERdQGeYjOGY9GcpC+QjOjWA+gv3daVCGOsL5iH0D7ZkHZZzvw7zdCVSGebsTqewwKDuZyjBvdwqVYd7uVCo7CspOg7Za3o6Xmf8xe9/h+pbcLJOXF2U4/DdJ4saDfYlPpHOMIx3EdS7ROc6RDq84IJ0TBR3rr5Op3lAS9USvRxr+RtJqu2XyZCcTPW5fuZUR9DYsFcSK72rJxNZj2WSsR54CZUoSnDnHNp2SUw9lkYh30wT8yYTrZFHPeO8L1EccWI81pkbv89YjDUed4PsytUhHq6U0WitaKA8eMY33vJ0FzIPB7wI8LF6kcdZz2nViDs5XzB6Xx66zNc5E4FTtOoXaxTycTDwY/Exo17m01nuKqJ/kvEv/xsjolBz+VD8xrzjK5bWH+8ng9wj00wmCB7TJpW14YJhTcnjYR/AgvNtZG26+LfNuCT2h/T9K8rxue4LAk/cY/lQLTSN5PYM9lXrHGmB105bb5wzGDtvdOLxpOKft0wRviiZvrbQnZgwtudYUPYbyWlOnY6jKEasx1Nqu8oBNUbYYfuPf7eikfWqfn4EdcHldGju41gRbSZI/yNaSiV2Bdbq45FhaDRaXo1d4ybFYKIXKyVJBrPguJPl2ve1xAkIthi4WOFXy+4Kceu2c3DQBfz7hOl/UM977AvURB9ZbTDjYQvJCKQ45DP4kGJrOWqTbaX9fB79565ZaaOpwoXtWrFUZ/kbSkRXXQrqkFuCKWdVi+I1UdiesBoOw+OwOnCF83rBozzJRjx/Dw1pyIQSmi7LfM5NW7eTjqshDaPhQx1U5VYKbGvO2vqQPp4xitreoslNFu1Q6ibe+LBI4U7l9YPZEuMUAV8v5N31CqQOTs9pagRrL3k9t7TBcK9rgCi1rrSBcK9vg4lSoWsLiNKSqhynUSyJ4wHeho9kGNyjqle2zZoDn0HatVIeupEnhKihTo4Xd+srLgJ+BpYHXkT1jupiXAZFntvWicr5U0Om2nNmOVzvSwRQ/L0+pJSKUs/WTyVktL1k9vAGbl5bUEpa6mV3hNxztdHDDbN22PB00WnWCfxR0cGNgTAnp4GoqQ5kuTibyqZZxVB/UiO+8pZS8ZbfbRAIlZK/I1zLCafBvB5y8PKWWm1S0EtLFy0W7lEyvJFwqWsX2cAJFyRTt5nxqv8HfLmSqlqd4KQljhiLLU7FLULzMhDEDxy9qCUptO0QdsZiBD2Tcl72fnrTaS4GIVy7ZGC71VQFc5sKyJBnvz9BXBbB+6OsF8zukM1/QGRT1rN0dyjF6/m/4vY52qfhayYVjTqyr7IiTqfOyv/fIcjypbj5B8SwegmK58lLdUBL1nBQrV8PfIF7KynVfosftY7nOE7w0RRnnteYJOvMEHYVrV0dcxzvimuGIa7YjrqYjLs82evajZxvn9Ggbd3PEtdQR11xHXLs44trfEdegIy5PnfC0R08b8tQJT3nNdMS1uyMuT9k3HHF5yn66Iy5PeXn6wlmOuDzl1au+0FNenj5nZ4iZPHXCc9z2lP0rHXF56r2n7A9wxOUpe882evoJzxjAU15DjrgOyn5bjgnzEAuIjprz7xugg/X3jcCl8gehNqo8juM95cYiLxPnhQE1gbdG//F73kDQJ2ARN16s1sXtOsfVCF+S9NZ2naK7tl4Dv7EM6Vwg6Chcuzri2s0R11JHXHMdce3iiGt/R1yDjrg8dWKGI66mIy5PnfCU10xHXJ7yajji8pTX8Y64PHV1tiOunaEfpzvi8pSX5zg0yxGXp7x6dRzylJenv/fUL0+f42mPnjrhGTN5yp7TJL2i956yP8ARl6fsPdvo6Sd6Nf4acsR1UPZbHY5YQHSK3k6F9c+PwLVY4Aq1sctpEmPxWILLCwNqAm+N/uP3x9K7dmkS3pVzR7ZUb2mRBYRrKIl71G4wwzWTaKa/cbcbliVJXKYO688L0DmkQzqHCDqDop61u0M5zkD5IZ/4DvE3ktY2l0kvLSB6eXKx9i0uR2+wlrSaap/AafzwGSHlVsx+BnJw8c5Qg38k0/1m0upS+GRDrOtK05APzJnIO8q2lvOv4eV3IZcYo49l6aA+8UWPi6GM7Xgx0clzy8qOF+fgwh3P1wPMaQSP/axwHgHlCP901l9paHlxtp223U72Z+e05/VEwSufjnor7GT/aIZTydn6XenBYiqbJ+gqnOwbrSxJ4vruEMFDCBf216EEb30xkANv+LjvPgN9xzvm8QIbpT+Lc3hA/UEe8vTnf5XQn1+c055XrHso0Tb4q0B//jfpD9YP6Q/v5kX9WZxMxIllvNO66NiK9UNj+HFUpngPjWMLAjwoGSk6l3VI5zJBp9vjw2VE5zRHOuoUo5oCvBZ+Y5nR4XdMB+uHLiGd3yGd+YJOn6BzJODgpTaDSR+LkzCOKBAn1WP6BfE3iJeC9MbiQHUaVE0F+TJIrNsUZXmXhiOd0IWUiGueI66TCZfSm9cKXEXl1YVp5WUEtyqHtT6Bt0b/8fvL6F3etNJwK5PMuwoiSeJMUt3zN1mmr+ic1CGdkyLpLOyQzsJIOmd3SOfsSDpndkjnzEg653VI57xIOi83PZis9lzYIZ0Le6w9L7f+maz2LOuQzrJIOpPldyr7Kdeeyn52vvZ08cqn6NS54W8krW0uM2VSK0tKLh1OCcdS56FvISE/aoqGsk3/K/t9jdOzSxh5SpUkcZcCqelZmsI6OcOrLhtivS+6aon1DU7RWdghnYWRdF5u7Tm2QzrHRtKZLLmd3iGd03usPZOlB1d0SOeKSDqVP+id9oS+M5r69ev20DRxuQPrWpqVl2wP3nu83htprJgH9QeojUWXJrB+aGliAZVhG3jp7UiBs0ZlyN+RAf6w/pE59ZCf9OFvPBhM+kyn9tSSQrFJ9CU2vG3hqHL0gtsWsH2crj5F8NIUZSjDPDoDgk6NcLXjyzEtbCweQXB5l7vXBN4a/cfvj6B3eWlh+9tUH7uZVR/FEhKVUv2jJpkO48JL+pXrqxP8udk3hFL3dVfmvmLuluIL74eSqOf4WLM0/I2kIzdQC6m/Wh1V95tZXbXSeC78xjKkc5qgo3ANOuLa3RHXHEdcuzri2sMR1y6OuKb3KF+zHXE1HXENOeI60BHXQY64POU1wxGXpz3u74jLU+89faFnPzYccXn2o6f/8pTXUkdcsxxxecrL04Y84wlPec11xFX51anzq56yf6UjLk+995T9AY64PGXv2UZPPzHTEVevxquvdsRl8arlHnCOPo/oqPnwKQE6WJ8/34r1atm/0wV/BebtfTXCZ3ziO8TfSFrbXCZPoOSv5KJOAVndpijj9F3RpWvExR8HVanaBQJXjeq3a6NjKtBYPI7gVuSwNk3grdF//J6/XpuXCjTcKgt+ag7fSRKXBcf6RwbonNghnRMj6RzSIZ1DIunM75DO/Eg6oYMX7OJUhnxBgIfQKgrSOadDOucIOn2CzmLAwSsl6W9czdpzz4k8HQdlfaIuH94x+OV7jtfbZ8+JMkD52H1r6io6/ko2rvjw8IBfDO/G6o7hbxAvZYeHw4getw9dZ/zH1NhKUSqIFd/VklbPVgPO8N08+ntfqrdU1EsEbvSo86FMSYI/0oVtmp9TD2WRiHfTBPxhhOswUc947wvURxxYjzWmRu/zPlFoOOoEf3hmVeprz4oWyoMTIMZ73hd8mQeDPxp44K8IHwZ1VLvYmufT3+gJzsihfxZ4meP21PQTQZ/bh6ND3peUDyMeDP4kkAF/GfpIUT/JeYcywLp5fyPs3tQW/tAH6yJ/RfqoNm3n/jf4MwL9f4jgAS/7XNqGB4bZO4eHJYKHzr4izV6Oe4l74hCBJ+8xaaQaa9rL0mHrYDr2t9KATr8iPS+H5rREP4OJ5i19picdjZXRY7PhbyRa84aSqKfG3tPocft46naY4KUpyvKstB2dDr8inTdoK2fB9ROqWxPv0gevqLWBGmeXPB1SM0d8F5oOGZyic2KHdE6MpHNIh3QOiaQzv0M68yPpzOuQzjxBh3HlTSGuzX7XCf4acOz8dT+c3jPO9OEDoyobM0+0x+AXC/jTRBtVhmxxBG2UJQ+E5xfkNbRJH+mrezIuKMjriknmNfQ1wi4ctIgecqbqoEWx6SBqLEsFseK7WjKx9VjGI8uRBHce/V1mOujxzeaQZiXi3TQBfwHhukDUM977AvURB9ZjjVH10r/fIuqELCBGg9OHg5jljrhWCFxmmfid2gKWsmesZRr+BvFS1jLV95vVER9ru/pOdFOUcR5/laCzStBRuE52xHWKE670WV7hqnBVuCpcOzgutXa6gspw/DQcanbAM9Si6+dY/5QAnXM6pHOOoBNap+d/jQ6/YzqKZ2sPjt0st6I3I2F9/j75cVCGi2G/sqemiTNZrHt99rtO8CfD2Yhf3zO/jShnaxfzPB1oWFmBuGZmOpteQTf5YYzTD3jz7AdjuE3ZbxVLLKAy7Gv+1nteH3yB+uAUKFN9YPzUCX4I+uBL1AdYn/2HshtFj3VkIAf+FOLP4P9QLCMo/s7PoYfyQDm/NYfen4rsitI7o92h3u2p9A7tlfUuNu6O1VM+e4N6uphwHSdwoR5wxsbqDyS6Dwwf35D6ddHnsXrO/WrwfxfZr07+RPYryor7dTGUhcahkB4sBhiTSTNp7fMTCNcJAhf2dUy/Hifwc79+J9CvakMF8sn9avD/EtmvJstu9CvKKqZfEZ77VY3fiwHGZNJMWsfJwwiX8tGhDOvi7O+BRPcB+2iD/69Av6osd8gPj/G31zjOqfLDKKuYflUrAbH9yn4Y+3URlYX2Kk6Wjx6E/rE+55if/UIef0puHS7u8Vr0BTls7CHqJ1S3Ru/2yMFleNJ3mFZlkVtz8y6+ZpEb/BwhcmWmyI9yUdaeDo8aRy8K8FHj48rRCx41Vi616FHjosNiF1Q1fc7LYaMm6ieEqybeYZlSVVwfNFVV2yFxhN6TZgqoQjGXQanI3+AtAs2LLviCKoM/RJgH40QeMIJib71awGNkzNtksQ2rqQzrnZ9DB0dH9Pw8Ohr8kZGjo9HuxuiIMuLR8XIo6xPwLO8rBfzlAMNZpSuhjE0aZbya6LRzHaz/Sk/V7FtF4ycG2ttuVsb6hTrBWTQ1m1O6YHDdyJRge1gXQraUPiybkO6gbJpJez1Bu+S9DyG/lD4hXcDsgmXDpgNupDOURD2HGR21+my4sT8L9Nm1yJM9aqi2dw3ipexQ3Uf0uH08VLNOpk9TlJ0Fv7EM6dQFHYWr6YhrqSOuWY64pjvi2t8R16AjLk95zXXE5alfMxxx7eqIy1MndnHEVXPEtbsjLk+dmOOIy1MndnPE5elXPW3bU1d71a966oSn//K0IU+d8JTXTEdcnvKa7YjLU1c9+arG7amTl2e86umjPWOA4x1xefqvXtUJTz/Rq+OQ5xzGs417OuKq/OrLw3959uMSR1ye8upVn9OrcWHDEZenPXqOtZ792Kvx6kU9ypenXz3AEZenn+hVH+3Jl6fse9VPeMbkO8O81nPc3qNH+fKc13r2o6c9es5hPPO+nrg8dYJtqJb9jTBHwO/DoRzh7UM5Ha4Vr+W1WMOBuPtL4q4RviSZyGdC+AcFPeOrkVM2lISf933q848v/ef/8w81qm+88DvenzAg4NWatskKdaWArK5ReziMtpWhjvRTGcrFeEj/XbdoIn8DJfmLkR/ibwp43isW2xezklY7MjnZvhjEzaekQh9URDpNUX95gM78DunMF3QYV94HtK7NftcJ/qjML6j7QtQemPmCP4MPnT5BfpRs+GSTOg0f4x+QL7Vb+kSis9KRDu61Wkx0VjnSUafY1b67Tungvio+zXi5Ix3cozWP6FzpSAf3BS4gOlc50rkKYE6DeunfV0OZ+hjbGsGH+eJr4H0BX1yPaQfibxAvBemN7e+6huhx+3h/11rBS1OU3Qi/sQzprBV0FK6jHHFZ385MWvuaP+Z4taBzdYDOSZF0FnZIZ6GgMyjqdWojSjZG5xpHOmgzC4nOWkc6qAf7EJ1hRzrDAHME0blA8JDGA8N7j79P/3sDlPVR3fSx8aVO8P81b7zedRlO08E1QBt5xPoYj60R7WB6N9GcZR3UKeCPJsw5E8LVTnYbSHZroCxGdgb/NZDdRpIdtott+41Qdg2V3QRla6lsPZQhDixLoA34jnUO6xvcoKjH49UGeF+gv/pjbAPxN5LWNpcZrzYQPWx7+vDc7eZy9OpGb6Ogp/ph90TLFOkbLrMx5WfXURn6xvVUhv7sJipD+z4cfiPOvDbxTWTIH+s38reCyjCmX0llGIfzeQiMnfksDraZ41trcz/hSR+bx9QJ9gH4OPG92W/lb9iPrxG4rewNoizF/9H9JrYFfQrKEcvSp0+8C42hBqfonN0hnbMFHcZVT1rnlunDftfgP01jCPqyAja7zuR/E7xkf1fS/6yL9Xd5vhf5Ur4wJu9V/52nfuOXbvj+8qJjRMh3ni3gO/SdMu9ltFXeaz2VYe7JeFB5r5Jj1zUx8kP8TQF/FsAV6QuFa5UTLva5neIqy5fl9jD24fhGnZ/DcYnHoBUBvta1wcXjEtZnH/bGNrh4rFon2shxCcP1C9xMezBpbRv7spJ+MjrXYPgbog1lYjclWzXWsB/Huk1Rxjp/k6Bzk6CjcK1yxMX5Uo88ptLhM4nnojfDYf1VVLZS0OE5c/ob52Nf2lvzg3qP822OC+zv34P52JdpPoa0Q7El53RU/ludI1c5nRCdCzukc6Gg0+38N+d03uhIB33ThUTnJkc6aG+c01nvSAfHRZ4LrBI8pDr792QHG6BM2aX1TZ3gN4AdfDNgB8gj1sdYS+WmmN4/UzxeMg6UOR3D1U523yHZ4dxOyY59iMGvANn9SwEfgrHlG6kM5XETlW2EMsSBZQm0Ad+xzmF9gxsU9Uy+1l+3wPtu5HQMfyNpbXOZuOAWoodtTx+el2wuR28sp3OroKf6AXM6KFOkb7g4p4N+dpjK0DdupDL0ZzdTGdo353SG27SJ42nFXygXPlUx53A5esGYE9tXNuY8A35jGdIpGid64OL83FTEQgs7pLNQ0Hm5xEK8vrWzxEKH7DP+Hv177Hhu8P960Hi9+RnObsZCR2U0pjIWWkCyKxsL/SnI7jiSHdJm20Y5cSyEMQrHQigrXm+0sgTagO9Ca6osN6zH41XJ2CQ6FjL8jaQj/Rgbr1SMqMarDmO9sVhos6Cn+gFjIZSpiotCsRDnF9A3cryD/iwvF5v+5lhoVZs2hWIh3gOGuYv0b9xfwWtKBvtrYGcXZHam9phdlkwsQx2/GuguJVtFuXD+smjsgPVvIn48xia11s35qqI5aqzPa6I3CTo8prN/Xb2P5gf9K8YD7F8N/gXo9yuoz5A2+0nkmWO0ov15UiSdCzukc6Gg0+2YhmO0bsU0nK/a4EgHx0uO0W52pIPjEMdo6wQPP91HQ3awEcpUvp7zVQb/GrCDjQE7QB6xPsZobxTtYHpvphit5JgoYzTD1U52t5Hs3ghlSnbsQwz+WJDd2wv4EByT11MZymMDlWEuA3FgWQJtwHesc1jf4AZFPZOv9det8L4bMZrhbyStbS4To8Xmj6x9t5WjNxaj3S7oqX7AGA1livQNF8doobwH+sbNVIb+7BYqQ/vmGO2mNm3iGE3pfhf3e0Tnqwx/I2mVYxndUrGQGod5bMK6qm84X6X2gqicq8L1RkdcnK/C9XCOhdS+tWsCdE6KpLOwQzoLBZ1u75OeqnxVt2IujoW6FXPFxkIv0Xh+M5TFjOcG/4cHjtf7dGAex2tFNwO+RMAfkUPvf1EsVDL/IWMhXoPKk90vkuxugrIY2Rn8z4Ps/ndAdmzbOO5wvio2TuLYVK1R4btQ/M0xJNbj8apkbBIdCxn+RtLa5jLjVWz+qMNYbywWuk3QU/2AsZBar0NcHAuhn+V91egbOd5Bf8bremjfHAu9sU2bOBZSe8YYF54tVzknnnf8SWZfqa39EeWs1D7lFO7KfSfCVXHYxLqq798Mv7EM6cTGTmsdcVVx2DgdflckDutWfMRx2MstJ5WXm/1+RE4qlJs1+MsOHK/3b4FYIiYnFYrDDP7Hk5iTypPdf0fEYSHZGfwpILta5vNj4rAqJzXOJ75D/FVOKj8nFYrDeiEnpfhjXLFxmMHvm9lXh3GT9Bt8NqmK1ybWZf1Jn7MAjsuKxljDjriqeG2cDr+r4jUfOmXitYX7jr/HMahovPbnQ+P1TgvEHF7x2mLyu1MRr51Jsisbr/3K0Hi9c0h2sXcVcLym9rWrWI7HwaJ5M6y/s+XN1Hi1o+bNQmuIHJOhP+O8WShe88ibxea4mGZeXLeayg3+9fuO43wd5c2Qr3VA+/9V+bWXTX6N72RA3ByvFb3f6iTBs6KzsEM6CwWdbt/TxPHaOkc6aPMv93XOvJjjneTf1DpnKOYw+NcNjdd7TyBe81rnvIvitW6uc+bJ7n1O8dqSofF6HwjIjm0bx0b2L9U65/anWufMj9dC90ehb/Ra51zXpk0cryF/obuG7F0oDjP4p8lvlIxjpN/gfWnqPtkO78mLjtcMf4N4Kav/qu/UnRLqHCXfaYZx3lkAx2WhuFDNF4cdcYXiqCpem0gnFK8NO9LB/uV4rVtxIcdr3TrbEBuvfZ5ijrJnVf7mgPF6vx3IEXE+Zz3gSwT8ETn0vkh+F8eJTv2u4Wp3jvJLOXP52HOUBv9bILsvk+yQNts2ymmYynBM5VjOc+8t1me5qblIh+deo+M1w99IOtKPsfFKnS8N3RNacv4wFq/F3mGB8Zq6GxRxheI1PkeJvnEDlaE/C52X43htbZs2cbymdF/luPBMJee41Lg0XbSxQB/NjNVBw99IWuVdRgfVnRxqvN7tJ/8dkv3evOn6G6/fdNt5w5uWb77mxuuvvWj4tluWrF+7fM3GTdevuXHJ2rUbh2+5BZlGQjPgPZbjwzD2e4V4jzjWtWkMKwN2Vswle4iLL+xTl+wZrpva4OIL+9Tgxn/3J6182mHfaRF40NDy+OJD9mrxJeTkUTnfRriwfl7CJQ/X2wkX1ufFRUwWMZ8srxCePAeKfL2D+Mo7hJ7+t7kNrjcRrrzLfdL/bm2D62cJl5qE89/9SSufLK8QnvS/29rw9U7iK2/zTfrf7W1w3UC41OYdw3VHG1zXEy6sj3Xx7/6klU+WVwhP+t+WNnxtIr7ugLItVIb1zic6RSdpWH+yJmnnE50tjnS2AMw+UC/9+04oU5edqkNMNvjfBe+7kTAx/A3ipSC9scH/LqLH7eOEyXsFL01RxkmO9wo67xV0FK51jrjupPbkXgT0iok0y15m8yJMwuZnOFXssYXaqOIYdRlpjdo1IOARX53gj8p42uUn/52bXVytbGRdDi88nsZcCIz21Q0bMfxeFwLfSfS4fWwjdwlemqKMkxbKFu8SdBSu9Y64+KK9PBs53clGHgEbWdSDNnK2g41gDBVjI51cHon4kiRu4alTG1GxbMhG7hS8NEUZb6xXtninoKNw3eKIK9ZGVjrZyLvARi7roo2YvGNtxOCvdLARjJtjbKSTZBjiM37wHeL3shF1aVrIRm4RvDRFGc6ZsAzphBbHEddtjrhibeQGJxu5Hmzkph60kY0FbUTx3o25l8pfHQu/82QU+gDPsaI9ao53LLUnT0fe/grNj9KR9LfN33lhfTXoyDsDOtILC6und0jndEHn5bIR7nSis9GRDo4rvLB6iyMd9JWxF9Q+RHawGcqUHVi+qE7wP9p/vN4jATvIy1nW4f2waAfT+1BGo8ONR3Jh1XC1k90TTuPMX4DsRgv4EIzp2cejPDZSGY7JnPdV+VV8xzqH9Q1uUNQz+Vp/Yd6yGwurhr+RtLa5TKylcsXq4Ke1b0s5emMLq2ouofoBF1ZRpkjfcIUWVoepDH3jbVSG/uxWKkP7jrmsH9sU2gjHsZ/aYDNVm8xKLtAGN5lh+ziO3yh4UX3zLviNZUgn9CEOxLXWEZetMVSbzFrf9eKhgJ0lFvrjArFQkrSO5wb/dhjPvzIJsdBf9kAs9NdOsdDVILuvV7FQ6NlhYqE7ytEbi4W2CHpFYiG1pv1yiIX6BH8Ih7an8kmJeFcL0GMa00TddxPfWHYF0SiaA7pC8NvFvG5frH3tKHldXkPvJBcbE/N0uIExOh6fjA2MV8A7p020faF+WBegV3Itb5rRC+3tQnqpPx1IWvuw3YdQkAb2V57Nl91PubENrtB+Sl4HvKUNLt5PmbdxGcsOyz58n/rhvfebCGN7AfcDmH2z32xTKIef7iUhuNCHgDr5UA7iSxJte/xRxE4/BKT6Ie/DPLskYR3BPsrbZ7pBtCVGZ0Mf1lH8FO1Ttak8hXtVAO4mAadopX+rD4tzLH5khiOV88ZFE9uI9Xlv8opx0mPywnehwxlss0jnpA7pnBRJZ2GHdBYKOoOiXi3nX6PD75iOkk3oEGZZOqhjnBsYdqSDdsO5gW7lOjg3sFbwkNrMWfuNv2dbC40XdYJPYH57boZT7dHP+8AV5gZCB9AM/qKMxmRcrJcnu2UkO3UALSQ7g//bV47XWx6QHdu2+tC9OjMwTGU4NvDeuqIH0NRlEDvLAbTQBU87wgE0NdYp38gH0NCf8QE0tO+YD/mFDqCpsTw9XJW5GjhcddHwbZetufH6tWs2Xb9h/YrhN20evmVTHTCrkYM9PHtivBoq76nR39OobAWVLxdw+IRG0w6vOIiOfA1/I2nthTKWo050qSiDr+rBuuqqivfAbyxDOusFHYXrGkdc/ImK6irPfDqhqzyrTzbn00F9i4307qBoBY/txkQr9vcdEK3cRdEKjhq8034t4EsEPEd6Bv8BivRKZt1kpMer7+jrUHb3RsgOfVqe7NaB7O4n2SFttm2UE/sX7G/+jCDKindnqmygWp1XEcEk7FqIjvQmY9eCuhqnw6svxiI9FVmqfsBID2WqTuJypId+dgWVqWssQlfoKB8UE+lhm2IiPdOtCwQdK1sDZSup7A2izandfZTsDj8XfR61w8qwHfiObeQ8wY+iw9dZWRs/R76u5DVPZwwSHcOBuK8piTvWLvPiBuSrIcrqEbz825zFR/3LyPcer1F944XfTQP8qMsIf56A73DMOXUQaCRE28pwPLyGyvqhzHhIs5brFk3kr+TK0Kkx8lO2j2X8KcqisSbiWlkS16xkol6h7Zj9oR+5PPs9mLTaNNtJSRuMnm8Z/kbSKoMy45fyvcpnsY/Auk1RxlfxrhZ0Vgs6CtcFjrjWZL9VP/N86wJB54IAnZMEz4rOwg7pLBR0BkW9Ws6/RoffMR0lm8nOrK92pIN6wPOtyx3pXA4wPN/KmzP8Dc0ZroGymDmDwU+HOcPfB2IX5BHr4/iyUrSD6f0jxSAlxxY53+LdFXmy+xbJbiWUxcjO4P9p7ni97wRkx7atrrdS863VVIZxAueUis63sP7ONt9SY7y1r+RNHmPzLZWPLDLfUjdF8XwL/exKKlPzaOXPOOZC++b51so2beL5luKvioXiYqH0OQvguKxo/HK1I65QjFLFQhPpVLFQOTplYqGD5o6/R/9eNBb6AIznh2S/uxkLHZ7RmMpY6EiSXdlYaAPIbgHJDmmzbaOcOBZSOR0VJ/G8vuipJKw/CTt0o2Ohydihq8YrjxOB6X/tbu5UsVDerkReL1d+lnPPajeg8mfXUFkoFlrRpk2hWIjX3TFvzLDLob0Iey7Y2Y1z82ldSXwsh7KrqCzWPhEHyhd9BcJfS20w+GUZ32mucfMijXNaonUU8/dJMtFurB3Tga6VFdDf30j5WrFonA7qS/pg3hT1JUnCMZXBXyngUec4NrwSyjieU/qI8YXpo5KX8dgNeSEPMfJSa2Cx8mK7R3mtIVwq/kUZhuRlPHZDXshDjLzUHpdYeZkMlLzeQLjazXGWErzhHki0T+D4weCvB5/At/KEfPxygRt9Y41wYDsOFe0YpDKsm+K9bo/tvycrz8OxprpxB/037oNA+Fth3HgfyUaN06H1LZXjCO0kxXH8pghcKwO01d6pmwK0kS/eI8N7c1S8ofzAWO40+7ekH+hXfgDzVewHVD+pE08hWal+UmvuvDcuNufENyvE5pzwpMX7cuYk2I48n832gPMZnuuoeUJI91T8jHbMuqdyrMr+2W+ofTXKlthvYN+y3yi7E/4RmqN2Yyc863c90fqdt8P9BfBtH8zxbf0FcX4YxqMLwEaTRK+3d+gL6soXoL2zLwj54PQp6jfZbkP7V9W6OcqUYwKT0YCAR3y8N+/5yJggtLs8lAMPzfvMHlK5fzHjo90eyJdI99Cnqbli3gmy3wN9/jTN8Tz8xuVUpvZohcYcpWdq9z5/Njl0Y3vJfefRuRTed97pje2x6zwen1xO/9sg6Kl+wFxKu9Ob5qsm26+hnGL8mlprUnsI2Z7RR7AfUHte1VoM00MfgbH4F3Ny0NiO2JgF89cHkf2jfbH9o42HvmTDcQPKkOOG9cCLinn4E+cG/yfgw75JslG6HIpj1R5W3JfKt9qgrt8cgWs4QHujgL85QBv54hug+MS5sklliyabbsw3MC5gW1T9pM6phGSl+kndAnMzlcXaLp8Qw/Gd7Rp1G0+ifjNn3MZ2qBxvu9PpLwXWkHo5V/AvYLv9r5yIs8oVtPJZ5Qomlk1mroD10ytXwHvEqlzB+O+8XMGcrC96OVfwKtjvuFeObyuaK9g3w1PlCqYuV3Aw9MFU5grOy/holys4gnSvbK7gQtDno7PfVa5APlWugOhVuYKpyRWcR7bvlSv4G9qDvqPkCi4BH7aWZFPlCvJtssoVFLNdj1zB2pxxG9tRJldwBI3dyDef11c2pWyez+uvE7Lg/svLFRjeOsGvB9t9N8km9PXo9ClqPzxnUvYTwhXaY3SLgN8YoI188Q3sbMvqDH0Xx1Fpu2ifbLshn5k+MbJS/dQkeJSNOofE+95wHNpAZTgOsc2jbuO4y/qp9jbFjru414jv7xhug5flGfqShRo3VA4ldEZM2T/7DdRR9hvYt+w3rD9RVxGecwUGfx/lCkreuCpzBfyFALy3Quk3z60M/hnwbQ/k+Lb+gji3ReYKrB+7EVOjvbMvCPng9CnqN9lusW/4zpjYG9zYzgYSHUPkzZlHArkC9EccZ6ibJpU/Yj+m7lNK5f55yhWg7WKu4DnSPZXXR5/D7Tb43wZ9/hjFGx5+Yz2VoR/gmznVmKP0rCnq4xjK9cwPdHhTYnSugG+x7/Qm59hb7D1uqk7/U18Mzrs5WslU3WQeyhV006+F1kPayZXn7thGtmf0EewH0Eew/7gpQE/N79BHhHxk7HwDY5Y7KFegcqzKxtn+Ud85bkAZctxwC/CiYh4csxH+S+DDvkayUbocimPVjf54Gz+vw4S+9qtwhfIU6is5twZoq6/kMC9Jkm+TyhZNNt2Yb2BcwLao+kl9QSMkK9VPTYJH2RS13VuoDMd3tmvU7Y3Q5q/ljNvYDpWvVPEAjvnP0djd7Vuc88buvDyf4eXY9x/Bdv+LZKP8s7oBmf0Hwqsv74Xm6yFcofWxkP4q2sgX1mXazKfVU7ZrsumG7XrOD5SsVD81k1a7ZhuMvVGa7RPtiHOA6q5DpZ/tzrKGxl1cV+Zb3UP7LtKH5RnKsyrdUzeoK/sP5dbYb6COst/AvmW/wTeFMzznCgx+t+xK7g6/5CNzBfz1OsxnKP3muZXBHwhfKJi5v8bZXxDnrAxPu1yB9WM3Ymq0d/YFIR+cPkX9Jtst9k3MXjD1dRm2s4FE5yxxzwvCz4U+4FwB+iPOa8becM97p9RXNlK5L8r44LWY9DfmCuaR7qm8Pvoc1j2DPxP0+dDst6ff4LylyhmFxhylZ01RH8dQrmd+oMO5dHSugL/6VDI3Efzqk5rvdOg3x3IFao6j+gFzBe2+dBbKFXTTr4XWQ9rJlefu2Ea2Z/QR7AfQR7D/CO1jULkw9BEhHxkbs+Ca51mUK0D7Cq2Lhb7+Fppbc9ygviis5lx1gr8AfNhVJBuly6E4tt18nXOfar4ewhXKU9wu4G8L0Ea+sC7TzrNJZYsmm27MNzAuYFsM5WjSJ0ZWqp+aBI+yKWq7m6kMx3e2a9RtzIFdlTNuYztw3GbbzcsfzqOxO7Su6PE1aJ5b3w688Do8jwMI/waw3dtINnck40+MTmwR8HcADPsp1IktEbhCe4LuFPBbArSRL6zLtJlPq6ds12TTDdtFe2PbVf2E8DGyUv3UJHiUjZWpfTbKBm+nMhyjQl+mvg3azPqp1v/z7uRhe8A9Qfx1eOULQ7rXbsxi3VNjlrJ/9hto/+w3UEfZb2Dfst+w/kRdRXjOFRj8XZQrQB0poOsyV3An8XgH8KD0m+dWBv9h8G135/i2/oI474nMFVg/diOmRntnXxDywelT1G+y3WLfcE5H5R1QppwrMBkNCHjEVyf4RwO5AvRHdxDv6I84BlG5Y+WPMFfwy5QrQNvFXMFHSPfQp7G/SB/WPYP/VdDnJyne8PAbt1AZ+gGOrdWYo/RMrRXhGMr1zA+YX0Fd7EauwPA3ktY2l8kVKPvD8YFzBSX95liu4C5BT/UD5gpQpkjfcIVyBd30ayinGL+G8Dx3xzayPaOPYD+APoL9x8YAPfQRGIv/Mtm+8pGxMQvOz/84i1mUjbP9o42z/aO+c9yAMuS44U7gRcU8OGYj/G+BD/szko3S5VAc+14BfxfA3ErtQV1/bwSu2wK03yfg3xugjXxhXaadZ5PKFk023ZhvYFzAtqj6CeFjZKX6qUnwKJuitnsnleH4znaNur0F2vxnOeM2tgPHbbbdWwWvGA/saLmCvwHb/QHJRvnnUK6g6HwdfdidEbhC87WQ/irayBfWZdrMp9XrpVyB6qeQj1WyUv3UTFrtmm1wMnMFP+hSruCJl3muIGbMR11FeM4VGHzfAdv/tfgTdaSArstcwV3EI+YzYub1Br9vxmPaxwMHaJyxuYKxOUWGZypzBWjv7AtCPjh9ivpNtlvsm6nKFewBfRDKFXBe0ztXcHLGR7tcwX6ke2VzBaeCPu+f/e5mrgD9AOcK1Jij9EzlCnAM5XrmBzqcS0fnCgx/I2ltc5lcgbK/UK6gpN8cyxWoOY7qB8wVqLkI4urFXEE7ufLcXeU0i8432H+UyRWcTLbvlSt4yClXgPrOcQPKkOOGu4AXFfPgmI3wS8CHrSLZKF0OxbEe8/UQrlCu4G4B/74AbeQL6zLtPJuc7FwBxgVsi6EcTfrEyEr1U5PgUTZFbfcuKsPxne0adRtzYKtyxm1sR5lcAccD6myD8gk14hfhQ/OTdntHQ3uNNlOZ2qvPdNAnYJ9syn7zXqOrI2Nqo92hvs/s9j6advNBPjuDvpv3vKCM8TwSjw14xuXtNDZgLmoL8Rq664HrYh8M5MDzfjKDXy9i9pA+h85/FdVnbEOn+oy2cT211eA3T64+z5hqfWadRX3mnJDS51rS6sM6yefc0IP6v2Un0v8P9Lj+q7lESP/b5UhY/zF+mwr9X1lA/+8M0FT6b23L03/MJyL8hwL6r+Qb0v92a4Qh/X8vlWG9tTl0UP+x31n/Df6pSP032t3Qf5QR639o3pQ+Rec6vCaA8XtI/3m91kv/Ty+g/6HYW+m/tTVP/w0f58s/E9B/ZYOhc4xF17qwDXdRGdZbm0MnL55n/Tf4X4rUf6PdDf33nL+2yzNwPI+2EdJ/Xufw0v9DSP/xjDvnhtYLHKFz7KG7K6wd6symOtPHZzb/P8gNfZXmyCpGwj393ZjzhnCF7LPd3RhMW92Nwbwkgk+r18XzX/3dPteqZKX6qUnwKBtlW3zGHX1g6FwJn1VRd1co/VRn3GNtF8+4f2nfiXg3tMFb9A5XvoNmvWifsv/QnRDsN9Q5dqXr7Df4DiSG57Vog/9nWotGHSmg63Itmu+qwXP4Sr957c7g+4a2/5v28XdzfFt/QZz/GjnOOt1VU+/2XTXt/CbbrTqbVqO/EZdav2E7G0j0XJfvZTH4/45ci+b7ONAf8dn9dYKu8ke4Fn3g0PbffEY3/Y1r0f1DE9td9i7Gg4fG603Pfnv6Db4PS911EBpzlJ41RX0cQ7me+YEOz4BHr0Ub/kbS2uYya9Gx99N16DfH1qJVnlD1A65FqzO0iCu0Ft1Nvxa6x6edXHltGNvI9ow+InT3DvuPdQF66CMwFj9waGI72t2fwzGL+sZTivfzWcyibJztv+g5drVnjuOGW4EXFfPgmI3wRwyN13v10EScSpdDceztAh7z4Hx/kDpnHsIVOl9/h4C/PUBbndthXpIk3yaVLZpsujHfwLiAbbHdmmyMrFQ/NQkeZVPUdnl9W51jV7aL+XfWz3b3jrPtbhC8Yjyg7rwKjd2hO2j4TgW0a76fRq0xoJ/Ju5/i/KHxelcOTcTpfT8Fz5mK3k8Ruouvnd9g2tX9FBPhVT/F3E+Bthu6R4pzDOruFHV3Es7pWD/bfVMsNO7i3TLvo1yB9z2Qoftqea9o6P7I2HE9dBcL+w2ODxmecwUGf/3Q9n8t/kQdKaDrMlfA4zieuVH6zXMrg3/n0PZ/0z6+cUjj7C+Ic0OGp12uwGkcr3d7HG/nN9lusW9ivlWEMuVcgcloINF5Cr5/2eDfOrT933a5giLxgsrfKX+EuYIPD23/zfnc9DfmCt49NLHdZfNUI0Pj9e7Ifnv6jVBszftW1Zij9EztDcQxlOuZHzC/grrYjVyB4W8krW0ukyuInbt36DfHcgUqDlf9gLkClCnSx3PJ6TPZfi2UA20nV567YxvZnkP5RPQR7D/WB+ihj8BY3HxEyEfGxiw433gn5QpCdz/HnpPluEHN53jcyNvTlHdO9rmh8Xq/NDQRp9LlTu7U4n34qOtbInCFcuztzuiG7hmq7tTS/VT0Tq2Q7XKOAcd3tmvUbdxfzvrZbk2WbVetMWM8oHIF1yQTy4rmA5TNc5ymYl/13QGOfX9zaLzeV4Ym4vTO88XM10O4QvO1dnk+pl3l+SbCq36KyfNdA2WcK4i1T7Z51G0cd1k/vXIFZ1KuQPmEkO6120/Duhd7hoT9RtF8gNJ19hvWn6irCM+5AoP/+6Ht/1r8iTpSQNdlruAO4hHzGUq/884E/+fQ9n/TPv7mkMbZXxDnP2V4Jmn/duGzoCEfnD5F/SbbrRrja/Q34lJnwNjOBhKds8w7L/DDoe3/qlwB+iPOa6I/4hzIBkFX+SPMFex74PbfPNdJf2Ou4L+GkgntVnl99DmsewY/98Dxekn229Nv8B4nlTMKjTlKz9Q6L46hXM/8QIdz6ehcgeFvJK1tLpMrUPan5jsd+s2xXIGa46h+wFyBmosgrlCuoJt+LbQe0k6uPHfHNoa+DRxaw2D/sSFAD30ExuLmI0I+MjZmwf0KCylXgPbF9l80H6Dm1hw33AG8qJgHx2yEnwc+7CSSjdLlUBzbbr4eut8z5k6tTs49he4LaXenlrLJLt430d/tO3fb3anF8X/oTq1Y272DylQ+QNku5sBYP9vt2WTbVd8owXhgR8sVLAbbXUmyqXIFrXxWuYKJZZOZK2D99MoV/Pc+E/FWuYLx33m5gjVZX/RyruDN4NvW5vi2ormCdRmeKlcwdbmCjdAHU5kr2Jbx0S5XcBvpXtlcwaOgz2/Pfle5AvlUuQKiV+UKpiZXsI1s3ytX8P3MwexouYKPgA/7NMmmyhXk22SVKyhmux65gk/njNvYjjK5gtto7A7lCpC30Dyi0zMIuCcj7wzC/wbb/X2SjfcZhND+x26fQQjtveLcwM5+BoHvAsExg+0slCvAcc7jDALrp8oVqDOFg0mrPWCu4BcpV+B9BiF070joDAL7jVD+YbLPIPxV1he9fAbhX8G3fS3HtxU9g/C3GZ7qDMLUnUH4NvRBKFfAeQ6VO+/kDMKsg7b/bncG4Qeke2XPIOxx0Hi9H2U4Pf1GdQahOoPwU+TZvy/XMwjoI9gPoI/wOINgPiLkI2NjFjyD8BLlCmJzhaH1usk4g7Af+LCjSTbVGYR8m6zOIBSzXV7TLHMGgfXT6wzCD2jsVmuYk72vQJ3P5Nh3IdjuRSQb730FMfP1EK7Q3Ybt1seYdrWvYCK86qeYfQWYE+P9CN77Clg/1d2GseMu3m14W8S+gpDutdtXELqTJLSvgP1GL+0ruDzri17eV7ABfNtVOb6t6L6CqzM81b6CqdtXcAP0AecK0B91e1/BPZQryNtX8CbSvbL7CraCPm/Kfnv6jWpfQbWv4KfIs39frvsK1F1m3dpXcA/ZvvKRsTEL7ivYENhXwPbfS/sKHgEf9jGSTbWvIN8mq30FxWzXY1/Bx3LGbWxHmX0FHA+sF3jVXqMa8Yvwoe/SKJ8T2q+gYiG1zhnzfQVs28rsX177+fnImLqba/Ge3w5oNx80majYaAOVqTtz2917u5rGhhrALSNea0krrzXRtmZOfYUL++UI+H04lCP8n9JcEuVZoF+XDUKdBHAg7pI6swzbao+KJzF2UvTSpyHK6hG8fH7hr1/05H8eP6NG9Y0Xfsd62S/glwl4k9UA8T6URD0XKds12lbGbccytD/jIbXZdYsm8tdfkr8Y+SH+poBfDnBF+mJWMlEXUN/NXoehbCWVoW8O3YMZk3Nm/4Z+G78Dwmv2Bv9XEMt9N2KsxPiZdTO03wn5UfPdWyNwDQdot9vjxrTVXJZ5SZL8GKCLd8b3d/tbGEpWqp/Umi3nklZC2TCVhfZ1qG/fhPagKf0cFu0o802rBZQ7VrFZSPfaxWase7GxGfuN0P25RXNHbGeoqwjPuWOD/28a70vmXGTumPec4rd7iuTa9pi3/d+0j2vzNM6i+bt6hmeS4tzCOZaie07b+U2229Degw0Cl5pbsZ0NJDrGNnx1gm9CH3DuGP0Rzy3V+Q7ljzh+R5vB3PFxGR/8XY/0N+aO9yLdU3Ms9DmsewZ/IujzvtlvT7/BeSX1faTQmKP0rCnq4xjK9cwPdPjdmOjcseFvJK1tLpM7Vvan5pkd+s2x3PHtgp7qB8wdq7VwxBXKHXfTr4Xm7+3kyrlctZaqfAT7gdDe+JsC9NBHYCx+HNm+8pGxMcsGwHsI5QfQvtj+Y/eZxuScedxQPozHbIQ/HXzYxSQbpcuhOLbdumdoLeyOCFyh/FAof6poI1+8r4z3riib7OI6Tn+316eVrFQ/NQkeZVPUdjk/HJtzxnWfi3PGbWyH+jaXigdwzN+Lxu4dJVdwOdjujTnxdJJUuYKE6lW5glbb7XaugPXTK1fwnb0n4q1yBeO/83IFb836opdzBVvBt73DKVfwripXMFY2VbmC9/dIruDFyFzBA065gk+BPm+rcgWhp8oVEL0qVzA1uYIXu5Qr+PssZtnRcgWfBR/2xSpX0EI7zyarXEEx2/XIFXyxS7kCjgdWCbzDAm8tafVDBh/aZ6b2saE8jJY6I8cxAdZbmUNH5SCSpHWfmcH/aWRMbbS7oe8oI9Z35bMRnuUd+tYyykTtc+SzWihjo2k8DwucKe9forFhDcBdnUwsewOUXUNluMd5LZWhjiAf2E+oBxcAjOGtE/w3YGz4D7IRpcNvgHfcB6E+Q36UXsfMa9YEaLfrf6aNfGFdps18oj4YLSsz2XTDVtD/sK2EfE36xMhK9ZOyFY7rroayNVSGZ5n57qS1UMZnLFG38Wwi6+ca0Y4L4B2PDRcIXn96foByUesE3pDuhc5eKt17g2ifsn/2G2j/7DdC34THvmW/gfP9RMBzLmos33pw9m/SqiMFdF3movh8xXrgQek3z90Nfv+Mx7SPdztY4+wviHNmhqfduGn92I0522SOm2y32DdvIFxvELjU/I3tbCDRMZLhqxP8vtAHnItCf8R7y9Ef8Zi/VtBV/ghzUadnfKjzSZiLGiLdQ5+mYknWPYNfBPo8L/vt6Tc4JkU/gDjyxhylZ2qewDEV1jM/YH4FdbEbuSjD30ha21wmF6XsT52X79BvjuWi1PxI9QPmolCmar4UykV106+hnGL8mjoXpM44sT2jj2A/gD6C/cfaAD30ERiLn062r3xkbMzyBsA7TPMNtC+2/9BdrajvHDegDDluwLuaVMyDYzbCnws+7HKSzVTcSxnC1e17LpiXJMm3ycmem2NcwLbYLicTIyvVT+oMGK+Fxdpu6LvsbNeo25jvvTxn3MZ2lLljZYjG7tMAbkEysex8KJuXTOTnAsEPwp9I8Muzvwdy4A1fneCvEfHWTIJJfx+SQw/5w3ccI2D95Tm40N9g+16Xw/t1Il43nCsEf4cI/gx+pYBfATDGj5IN5+1WiPagr7+e2mPw6yPnH6ZTHfqGGco3oNzYN4RklD4sU5WHRVlxLgLXZpZT2QIoW0FlaDvnEw+nCR5OhHds16h3VjeVwy/O2f7b+n8xwPWiXb8r0q5PzaGH/IXsGusXtesbcni/s6Bdnyr46yW7/kCkXS/Ofld23d6uFwseYu3a6qZyeHbORLxXQpnSWe5jg388oLNXJa28ogxZvlcL+KsAhnX2Sijj+QHW43VsjLdWEw9rklY5IDzbrsE/BXLYHNB146tDXR9Uur4GAFjXr4GymPzvWgGPsajJRMWiVxKuKwUu7GvOoZmMBhLdB4avTvAvBnJoaKdriPfVBXmPtTe0qQ2zt/82HUTfsJhorg7Q5Lrpf5dnfw/kwBu+OsF/VsiLfR3aAfK1jHAa/C8H/MHlSWu7zod3rINK9peLdimZXkll2MemC8o+Da4bYxG2n+0z1Nb0Ydko34q6a/3fTFr9Ia8bo21cTnTUmBer/6hDV86eiPdyKDO8x0Hd12e/WWe/FNAvJUMc44vK0PiZmbTK5ioqw3orqEzJnsc8lAPCX5tMlIPB/0nkeGN8dajPS5Q+ow9nfV4DZcrnc1+ExieUicqLsM4qP4N9zeONyWgg0X1g+Dj2+VpgvMFYm8fKVQV5P07wPpi02gza1G9ki5Cmg2jji4nmqgBNros+ciAHntd6DP4fA+PNSuCdY8X0916E0+D/OeAP1Di6CN6xDirZrxbtUjK9nMqQd9MFZZ8G16F9nqnsE9vP9hlqa/oUHYut/5tJqz9cSWVoGxx/qzlZrP6jDr0wS+PNG29+JvvN+vU/Af1SdoN5Dpah0kfUEx5vUL9Csc75VIYy5dyEGncRnnOOBr/LIeNyCI03Tvo8e6rjJ5OJip/YHyqdxb7m8cZkNJDoPuD9jQY/G/qAxxvME1xOvC8vyHsZe9tK4w3mhxYTzeUBmlwX/UXeeGP4OP80V8irRjTQDlBOPN4Y/AGAMyZHFxpv2uXojB8lU85pIO+mC8o+Da5D+5wz1bk2Hm/QH3IeDm1jBdFReelY/UcdejuNN4sJL+JCvQjp42KAMXmyPh4X0MeQnaUPy1zpL+rV4uy30kee8yyGspA+GlyH+niZ0kdsP+tjqK3pU9RWrT/VnDqkjzw+LxZ00IewPqIeLYa23jRrIhyuAdayf23vzKHwvoDMp9UIn/GM7xB/g3gpSG9sP9KhRI/bZ32320/+y9IOyeZN1994/abblm5Ys/asNTffsvnG4WmIOmldsUKpIFZ8V0smth7L+uhdH8GdS38vFfUSgbsP6B4GZUoShtOsEtt0WE49lEUi3k0T8IcSrkNFPeO9L1AfcWA91pgavUevuZegXSf4S8BrnrUon+5eSasc9qK/rxP0umh1s3YOq9udsBoMwuKzO3CG8Pw39+gyUY8fw1Mnnl+XNf+n+c3st/X83lDX9tda2b6AG9eKHyAc84gH9S/yju94/PLwFLw+mT6cEzkM6l0SwcNhguemqG9wg6JeWdk0AzwbHfQmuP/5jYckE9o2H8qUJ+L1U4P/a9Ch9dlvkyVarPGo5HxpMpGXonK+VNDptpwvJTrzHenMB5h94Hf631GEi+Vs/WRyPhLKjqJ6R0MZwuEodxS8P1rQVvgNRzsdfOchum15Omi06gT/edDB95AOqtGUR98kCes86+VADvwhxJ/B3xWYx+8l2ox88Tqlwd8dmDftJdqlfGWoXahTe+W0695APkdFIWpsOZzK9oUy8+E4ttQJx7bs/fSktT8KRAnyzFMe3whndOeVoxs9BzH8jaRVhmWioXlEj9tXLhpC6bNUECu+qyUTW49l7eYgr6G/y8xBlBfYW+A0j6Lieq7HVsjvpgn4eYRLWRB7Z1UfcWA91hhVL/27X9SJsYCS8XlfrAUYfi8LaNfvpqvW9kMFL01RhrxjGdI5VNBRuPYlXPtG8pxabbZBzqx25aYNG4czs03oaTfpmJfDxjRRP6G6bNoc2O8tmoSmszSHdt4gbPjqBP9pMViF6qdPjNpjF3XD8Rt+L7WPVSGexGHd0CBfS1r7cJJUNX1ek8OGGlESwlUT79JHxZJTpca/EYi5pon6qTf/yu4TabeLs3muZ/C/HYg51dwgdG5jgYDH+YjxM5N4wLozRT2eZ+I+5fnEwzFJqxwQnvfKGvzvRa4lG1/d2Ct7DADw2gCukfQJeO6LEwQ8rhOZTJoEz/2CfyMu7Gu2A5PRQKL7wPDVCf7/BuwA5+nHEO/zC/KubFjNa9Gm3klzUKTJQ+mRAZpKZ41Ont/ImyP/bWAOqnI/yBfPQQ3+/wX8QShPkT6sg8p/HCXapWR6NJVhTgLzQYabcXZjryy2n+0z1Nb0Kesr1dmM+VSGtsH6P1/QidV/1CHOLb4P4AzvNIHX4O/O/jYdZxirWyf4fwd9XEw+AcO091E77gZebMy38O79xPtQEvVEh3eGv0G8FKQ3Ft69n+hx+8rN61kjUSqIFd/Vkomtx7J2UdzZ9HeZef0HoExJguf12KYP5NRjzeV30wT8+wnX+0U9470vUB9xYD3WGLYi9OrvE7TZinbNJqBqbRHpvi9plQNb0gJBz6zuAwSbPmZ191CbhpKo57WxVmf4G8RLWau7h+hx+8pZHWoKUllNWA0GYfFZDZwhPP/NvXelqMeP4akTz/MyLUq1b4/s98ykVWNfQXwjDyH/1RT1DU7R2a9DOvsJOqbJGDfwWmm/aKuV3Q5l+1DZHcDLcirbItplZXcGcN4VwPleUZby/vyhE+HQG9Vy/k2fPvGOZfp+wav1HXoATi0oa7snQAfrG9ygqNdpexTPHGNgW1P5Hn1oMqFt90KZGg1sH2+d4OctGq93LNnbvVDfeFRyZlssKudXCDrdljPb1H2OdO4DGF6HvZ9wsZz5fNVWKLuf6j0AZQiHEcH98P4BQVvhNxztdPDMQ3Xb8nTQaNUJfjro4DkldfA+KsM+4PHQ+EA5IPxViW7XQA58XruWQkTEuYb3i/qK90OJl/sCvKdPaFXA4Lqt84cSnTz9uZT0ZyuUKf2x82R1gv/eq8frvZb0ByO0brQ/ZNcYyfGsQdkdy1LVQxt9VQQP9wuem6K+wQ2Kep3qhuK5nW68gXTjAShTuvH67Hed4P8cdON60g30n8ajkjPHgEXlvJ+g0205c3z3oCOdBwGGx7dthIvl/Prst8n5ISjbRvUehjKEw/FtG7x/WNBW+GPHt7ceqtuWp4NGq07wvwY6+I7AnCakgw9SGcoUfS/3dagPasT3QA78g9Qug79DjG8he0W9YV9u8HcBTs4NG11sl5oth3TxIdEuJdNtSXvaKOelObQHEt3+PF25NyBTq9+f0x6WqcHfH5CpklFIpsrGtol2zRRtfphwqUwbyjlGptj+D1D7Df7RQBx2n6ivYgeOIVUchvBXE7yyMRWbsI09ERlDcmyDuQXeK4e5hXup7HYo47nYHVC2lcowt8B5Dswt8Ph3F5Q9QGXvhTLUfcst1KmtH8/ed5iDl3v63k+81QG+lvNvksSNp7x+hHS6lTdhOh9wpIO4LCOv5mzz4DeWGR1+x3Swfmhu2N8hnX5Bh3GhT8aYyOypTvC/Anb9FvLJ9wr++uHd0kBb2Z4Rl/WZ2Qf6vm6sURn+BvFSkF4t5HOxfbxSsFXw0hRleX2KdOYJOkX52i2jnz5ZFv/s4Ws2r1u6YV1CT53+PieHxf0IbmkOazWBt0b/8fv96F2fgEXck2V6U0nn4A7pHCzodDvVeTDRyZvufKVgSpmvzDD4F2C68+eB6U6e2aGumftMH9Zto5e33H97Dn9fBde7mFzv7aLNrwvwfC/QYLrp7yNyePg7ClVKumIZqnAqFPmpUxnyjX2DZUkyLgt8xzp3t6DDuPKGSZMrh3T/VHCYDC3UI0/3UhkOTSwHRUe5dyWHEJ1DOqRziKATGvbL+hLFs5pKoC/5EfmS+6BMhTTLsn/rBP84+JL/DPgS5JH/Vn45b5zM8yX35PBn+6KUL+HQENupeMYpINNVvmRMphkP5kt4KWgoiXuUL+GlCeSHtxgWHQux/mSNhfOJTreX/VS6n/2LWo7aGqCjltTa2eOcwzRNZY88riH8tWCPex02sY1qbI9Zquu272VcsWOQwe8PNt7pGHRPBH/1pNWm0t+HQZvzcCXincGjX+F5wH0Ee28ANs9vpb+vyX53277OyH4r+zqS+CtqX1g/1r6OKmhfw9lvtq/XgH0dQ/aFywEsV14CQNgzCPYBaHcs3n6qmz7LCfZ+wos6yVeJjo3vh43jPzn7PShodao7mNpn3cEU9VHwG8uMDr9jOljf4NgWWHcWHaZpou5gXdYdg78TZHnmYflt5DSrh5zt/UPwnunyEuQ2gsVUPqeJH6K66t92PDYFnW2E9+EA/7xM/4Co1+3l1m1EZ5sjHcR1BdHJ091VpLsPQ5nSXft0Up3grwTdXU26i/VZd9Gn8hZKlf5L4X+NeH4E4ExOV4q6Bv8owSOO9OG5xWPZ33lzC6tbJ/jXi7mFte1hQS9t2zU5bcP+wGW4R4m2wb8L+mOY+gPlZf0xM2mVDdvAY8ALw56RI4ObgI8bDsunxXah2pji2HBYPtwZAo5xTBMyMBzKL1i9mYIe2+4jROPhAI1top6iwf4YZfYY0Dfd+GCb8sdE2xLxbpqAfySnvYmg/WgbvA8LPMq/P0plD4oy9l3YXrUVS/lE9HurAvaSZxNKrx4J8P4Y8f6I4P3hAO9Kfug/QnGD/R0z1tfE38bfOnjHPlYt9SOM1eWl/g8E8jFq+w7yNZyD8z7AydsnlM6EjuSF+gn5mZnk27niHX0JvwvFMongAX2h0tm8OI7loXhQ22+U3+TtNyoOj7VNjKcX7aRzjKec5hinwPz02R18jsE5816YY9xLeKo5RpJ81mmOMRN095dLzjF4K1W7OYaVmXyniXp8fMDo/R3Evp8jfP1AC/UmffhqZdxqmIg28bqCwf82jHtvo09KYv0TiB6u66i1HtaJEwRfee1UYxjL7eu0HsJbh4eSqGdJSP8N98MlccfYj7J5NX9oiLJ6BC/r/23N8WsG3vp/2K6MF34XE8ucIOBNVjxvHkqinjMGgUZCtK0MdfthKkNdNR5SnV63aCJ/j5TkL0Z+iL8pym6E30X6QuHa6ojr3pK4ZiUTdRTtUPl7zt2oPHPaj9OyBTzlh44jXov6IaxfxA/xuo3B/g/5IT5eN5REPSeE4hPDva0k7lg/lBcTIF8NURbjh6778ZKbP7fij15ZS1r9bZ94F7MlXX3uoUM7P0b5IfY16Ie2URnqqvGg/FDJMeWYGPkhfpVLYj8U2xcK11ZHXPeWxGV+KLS2gH6I4zt1xBb9EK9nNeaPw9TnT8QVylWr+I1jTFV2v8CZ0tkH7uRBfzWQ/XsJlPF6oJqj29/4DnUd6/A6usHPAtnMJP5wLRvbifyp/sI9NnPm58M9EIALxfdqHTwU+8f2C48V+2XvO7zIRO7hMVzp9uO9st/Z9uPzhjetvG7NxuG1K4ev3Ti8qQ8wIXeMyf62VmM9fowT3kXwXvqbd6xtpb/vF3ja0VQ7TI6B30w3ZofJMYLnqaRzYod0ThR0ur2L8ESig54EZ/6Hz08mtE3tIkR9WJH9y175tNPH6x0ViCBZzmiFJycTeSm62w3r31PRcadzSod0ThF0ur0b8RRqD9oIy62oXWP9eyeZTju7Pn++phlr1wb/7dPG610UsOu8XfvYxqIHrNgn5eHiD8Rhfd4JeV+AZ0UH34X0LEQnpj0hOlPZHsOldvhhH6wK8MWzlPvb4FpJuNRFHkoHmeei2Qms3x+gs7VDOlsj6UxWe+7ukM7dkXRO7pDOyYLOoKjX6fiheG7nb99E/lZd1IT+dln2L19o9JfgbzeRv8UZz8tdzt1aNeaL9/L6813Un2o1N9SfBv+b0J+3R/Snkk3erkikG+prdXFOTeAK7dxmOSC8GlO6mFGN/kwhr96UXKUaOxwduvwmffAQ8h7Z7ywLsGT4lmOPW3j2T1IAt928KS+7ujsSTSaurCN8Qn9zvZQ3Ph3YL2ikD+vPAwTH/W7vGX8MT+1g25UrX/dQTjuTJM7XYf3+HFxo83iaxfqHM03bMjtXp1lUTKYuZAnFA2pFHuH6RBt2zan3pkTzZ21GnlSbDf5DgTZvbdNmjt9V7Mi+ieH6RBumJ606gDiUjE9NJvJeVJ+w/mSNnacSnbwx7Xka09QJGqy7MfvNJ2g+BWPax2lMU7Fgt9vP8au6XnsjwOTNbfJOavPuDYP/Ocool1x9lBllXkGpC/7T9v0C9alqe6hPDf4p6NNfjOjTkH2oy5pDvuDeALyaK6ocUyhutP7hHbJDScxT+1qMjiL+BvFSUB/G4g11IRq2r2y8YXi/Cg1C/tvFG1wvFG8wbJ7tcQxwP71vF28onvJgO4k3HshpZ5LEjQ9Y3+BMP0t+YGLIeLkH+FA7mPNO/k5LWm1LwasYQ+3SYF9UT/Q4vA+UI/yXIJb42cCuuNNy+EuSuL7A+pM1Vp1GdO52pKNunVH51RXwG8uMTp6PbYr6ofWCBzqk84CgE6vrN2e/28VEXy2QJ0e6nCdfCePn39D4qW5RCuXhQqf92baSJDzuqtxuXrzUzk5Vfv18wlV0bQPrh07rK97zbv6pZTcgd3jzz3K1O8Tsr8OYb3mMjSN+tevB+GqIsphdYf/QOP0L//SZx3+/RvWNF34Xkzs6X8B3Fn8ly9SuMNyxkj6oI/dTGeqy8aB2hZWM15bFyA/xN0UZngYq0hdNUba0JC7byaXm2FPlk/JyL9anHDvsktl+7E0i6sYi1dZ7qd69gvf0YZ+TPkOJfv6HHsNn8t9F0LqP2j2Wy4B2v5s+DXWf4NV8RF+ARiLe1ZJ82TCNaaLuLclE3rZG8KbyQYjj7hw+UxxqDZH1tujtJfcIfhSdczqkc46gExqT+F+jw+9C65HnEJ28uGnoVcmEtoXWu9Lfm7LfvN61BOKmeRnOmaI+r7mqmwzV/gKWfd4NAexPDH4+2BWfdlX54U2AM0/PYk8JGfxRFM90I8/Ebaonrb41fS5IdJvy8sUsA6Un+wTg1XoTrruxzw5dqm9tO/7IcR5OeFWx9l+Yg/O4I8ZxnlwQ50U5OM9/1TjOUwO2sSiZSK/orZJYn3fg8p7S9JmetOpuAT2MvtzY8DeS1jaXyaep/ICSi7qonddnsSxmn8YiQadGuNrx5Xi5sbG4N8EtzWGtJvDW6D9+vze9Uyk5xJ3y9IeZaZqabwGY1YR/C+DoE+9YzbG+wSk6e3dIZ29BJ4RrtcBl8HcK+L0FvKNqGItzAYa9NLPGeNupBuPOUw17+ohm+vteqs9dwzzOFDjqgTb1iXfc1XVBS9G5vEM6lws6HCWspygB6RfwlnfxZyMMB+Iumam+K9bz8+ctkJ7xpT7LHJP1OPxX3/HkafOuu7hG9Y0XfscmqWaRlwv4DrNPd6isB+7+TR+VGVNZD+NBZT3uLclfjPwQv8pSc9ajaAZB3QNaFJdlPfAzKSFbniyf0Q06IVyhu5tNNgOJXilin2Twb4HZ07mUlVDyTsS7aUmrP3pt9u9MgeukHN4VbcOfPk1R3+C66BP7i/rERtLa5jLRsLIPJRd1Ts/q8g719FkOcHn+MrQi0Ou4UDcHk1b9reX8a3T4HcvZY0XQ83QZn/XsBJfKkh0Nv7HMcPE77hesv5XK7hR01Dh0F5Wh3JZSGY7nR1C70CbZfxf1Q3XBnzpPi1m5J16laWK2BevyaqbBf/Hw8Xqjr8pvY8xOKoTPy3A9OwkZrnaye76A7NJnFbXF4F8E2X08IDse+1UmXO0U55NmeZ+oxrIkCe8gUpngmPvFOlzZix77vHdWqayi8jEd3m9UN3qhT7Yivd0TLVN115nZmPJ17M/Q1/EqJI5reZ9JTn8fDr/z/Bm2iTOzir/J8puKziUd0rlE0AnFiTG6rugontv5si+QL1OrqVj3+uw3Z6c/BL7sS+TLsD7yyH/HzC+MXuy3YQz+DwOrM6rN1wd4RhpJ0mo3PHYZ/Fdo7Co5n5ZjF5/2VaekO6QbnY03/A3ipawPbrcaj6nN2dnvLLW5dMOatWetufmWzTcO882VeXsca4QV39WSia3Hsj56dzvBnU9/LxX1EoEbM57qTEhoX4Jaq1ez8rsFXV6bV+euQ3scjPe+QH3EkbdfpC+nXvr3baKO5z0BnjOaLu4RmxNrmYa/QbyUtUy1X0hFR+oGp9AXHG6H31iGdELRKeLa4oQrfZZXuCpcFa4K1xTgCu0p41lY+qzI/lUL13w2q+jCNdYPLZCf0yGdcwSdQVGv7JjcDPCssi0st6IZSHW2tN3+uYMO1zTz9s/xDM3g74EZ2iGHT+RZzdBQBjgDwn4wHFx3OvBgZQXii5npLG0FfWUH5cr9EIpD0t+2107tp+b9OqgLsX10DPWR2u8X2uNo8LdCHx2f/Vb7uGL2ESl6bIcDOfC8x9HgF2Y84Sqd4u+eHHp5WYWfyaF3OtC7APTB2pkQ7Q71bo7SO/QzrHcqE6T8WchfoG2xLqIO88qs2rsX2tdq9QcS3QeGr07w54k+j9Vz7leDvzCyX02W3ehXlBX3q1r1RnjuV6UHaoVeZeruIFx3CFxqH2usLRs+tq1LA/1q9bFfkU/uV4N/bWS/miy70a8oq5g4R+2fDOkBjg8mE5VZfy+VoU/MOwONdFAPYvoc+yfPf68Vfa4y+P0R/OXtO52T/c4ycCs3bdg4nKXgEnpCKbP073tz2Jgt6idUt0bvZlOZcp+hTUJGeyDRKSt2nwb/RiHykPtNn5gt1djd3UjiGn6vLdXt3BqnikJmFprKTIGqps/5OWzURP2EcNXEuyTR25zVXr0Y76ZEpfZqIbzh43XrtwVGDjUShm4JU5G7WuNT7ecbHrFezGkSVCMe0Qz+PZEjmtPMR45oKCPuQ5VZCJ3EVevZKlvaJHiUvRrR8k4HIR0VxaiZFUaVPLNqdyNozMljPv2cPmq2z99TxXqhWbDBdWMWjO1hXQj1bfrk3e6C8NjfHLXi3gLOPKEt8W0OatYTqwuY7eBMiNqXGJoBqRsbcAjnWbnBjwgfYDjva9O2mBmgOnWrVvD4BCnWw30FhjshuA71cYZnViZ9itoq+x/UM947jmMBZ3GQT1z7/8Ik78Hi8VvdHKrGuzrB/zxkjX6XbETZeKgP1P4jdfPhzKTVX2yLwHVXgLa6NXNbgDbylfet00Twid++MlpWZrLp0Fb6la2gf2ZbCfni9ImRleqnJsGjbIruB+NvxMbuB8PvvbB+qnhR+XBlu7jv8nmyXbRPnm0Xzdqr8Yhj4i/DGPGWnJg4z6435eD8o8C4025MjYmzQ7eLo+/jOFtlJZXvY7+o/LXyI+wX1TczET7vm5l/ncmvw1uE5X6rvG8i1xMde/EeYIP/Pvjurx+ucfYXxPl3kXMWJ19X77avazcm8T5V7Ju8/YaIS+1FZTsbSPR8yfDxatt3Apk29LfsU9Hfsk+9V9ANnTVI5T47+4PjtfQ3rmD9MGeehbqHPod1z+D3hNsN/p1WsDz8Bt8ypL5By/aTJGE9U6uC/C1v9X3nDvd8R+9p5286ltxDH7wtVOUMOvSbY3vaVayi+mH3RMtUfS8Rb58wvAbTTb8WysW0kyufD8I2sj2jj2A/EBOTKXp5MZn5iJCPLBOTPUExGdoX2z/aONu/ujlUzQE4btgGvKiYh299Mfi54MMWkGyULodyLOq7zOr7wDOTVl1/JAJXKNf3qIB/JEAb+cK6TDvPJkO373VjPoVxAdtiaC6ZPjGyUv3UJHiUTVHb5XkYju9s16jbD0GbWT/b5VzYdrcKXjEeMN3A5aaVyUSaamkH3/E4i/UNTtHZu0M6ews6IVwrBS6D3yLgu3y9irE4D2DS9/sEWGO8NfqP3zPuPgGLj+qmeg7fSRLXTWqzAuMyF54+KwCGLxXGNPQqwqW6cEuAL6zPS2HG1+rM/KYL+gXc24Oh4+GGu+Qx/gdrhC9JdJiZdzQN+VJXCtQjePml5y+Z8UefWzh2FUjsETqDV6n+VQK+w6tUtqohjK9LUccGi16lUvIKiK0x8kP8Kh3OV6kUPc6IZStK4rKrVHCoNNuZLB/DU9erMlvGFN5k82LD8RrBS8iPoc/njd/IO8t4S6BdRf1lPZLOpR3SuVTQ6fam8EuJDto5plHWUzh2J5Sp1O8N2W/edDl05Hi9N2U41RYI5FGNPzhGpg/bK28KZZh7cvi7FfSTj9OqNt8Q4BlTaEnS6hc4vTu2DYXG3pI+VaZ3+VoxdUy7Q7rRO7Gm6jqfYsdpeXsySgWx4rtaMrH1WNZH724nuHPp7zLHadVnJu4SOENXmqvRt8glVYhXbUrgy/lCoz3iUIt6hkPVS/++TtTxvKhgso7mmmWWPN4a/dlI/qxCyahzzDJDm0PSh9uuPvGgktk8qyr7yYD09wOOuO51wpU+yytcFa4KV8/hUjPQ+6gMxwP+PLw61lCjMuQvNPPC+qHE4yUd0rlE0BkU9cqOfc0Az2rjIMut6IWGWJ8vmsGoHWdCnztC08w7KsYzIYOfBTOh3zpiIs9qJoQyUGcIunjMTG6QRLlyP6jNo9hvdpQ3dERH6UJsH32Z+gg3Xqs+4qPFBv8fsGD2RzRbxfq8KT+0SRzpsR3GHls1+D+D2Wro2OpdOfTU7D19luXQ+0ugNwnHVmcpvUM/w3qnMi7Kn4X8hTqDoxay+Bhc6OhjXdAJbeg2HmKPtBr8N4U+8FjEupHHn5Kb8zG4u3PY2F3UT6hujd7tnoPL8KTvcPoacwxOnXRlF/EdIfJQl6VPdQxuhzsGd24OGzVRPyFcNfEuSdofg+NRJSRiJSrlRUI5eoP/H6HSIQ+rIqxQJKBy86FjgCrquSuHDo5oKC8e0Qx+4Mjxtk7CgX05oqGMuA9jMycG3247NJta6BiKmtnEmmHsMTiO1JS+9Afa2+7YEetX7LGjUFT9cjl2ZHzHHDvC4Wgr0VFRVKwu4OzpczlrTIgXdSFvjRZ9AA7heccRDhY+wHDe3aZtMf5OZb1DV4mr64JxPdBwM84O9XFQ6SO2P2aWF/psTDtbZf+DesbbSHEs4DCynd6EtnniGt96mvEhHf4IYNHPtlwg+Fd09u6Qzt6CTgjXBQJXqL+7vFXMWNwPYNL3+wRYY7w1+o/fM+4+AYuP6qYtOXwnSVw3KXVWdOod0qlH0lneIZ3lgg5vBbkic7sdLjffHrNgVvJkwe01wpckejaVd6oC+VKnHGK2mH27eelv3fj9Zz9Wo/rGC7+LOQ2/XMB3eCriXWpo4hOpqH8PUhm6YeNBbTEreSrlXTHyQ/zqpgjeYlb0JA6WLS2Ja1YyUa+mwmfwFrOrIYTiLWZT4b8u6ZDOJYKOColqOf8aHX7HdBTP7bZi3XBkMqFtauqLdTm5bfAL4LvTNwXSEHlhA46VoS8bjE21k3GZhL5sYPAbQad4K9Y9os3XB3i+D2gw3fT3ETk8vJnGqJIbL+RWLJ5+Ij8caqsNPepLAWph654Ancs6pHOZoOO5GaYZ4Dk07pelgz7VbE6d8nwt/MYyo8PvmA7W3xqgs6VDOlsEHZUWwimTOhFoMuswnqrH9AvibxAvBekFv3akFvyt7Q8JXtTpRk6FqFjrIUFH4brdEVfMTUWvFbiKystxqmcsXkZwq3JY6xN4a/Qfv7+M3uVN9Qz3ZF2VPVmm327dfORITTNv3TzvQ8z/dtR4vacotEC+BqiNRXfMY/3QznweAjGzxlk3dSV4jcqQv9CJErVi0SfoKPe7M37oiId0rKuG6JhLMAYEnaJ8Obo5Y/EIgsu7060m8LZzc0fQuzw3Z39PluorOos7pLM4ks5kteeeDuncI+iEcC0WuCr1noBbdVN/Dt9JEtdNWH+y1U6NIJiUaDfK/x6N8uozgaFR3uB3hVH+D2A3I+9pQFzvTyaWoRw/QPzj+j2PgCiXboyAhr9BvJQdAWN3phU7m8RTBpQKYsV3IUvhXTBslf1Ur8zZJLU6d4fAqeK4O3PqoSwS8W6agN9CuLaIesZ7X6A+4sB6rDE1eo/W9j5Bm/de/h2kw5ZSOkzRQnm021/IMMzD2P7CQEpuC9RR7WJr5hsB0BOckUP/v8DLfOtITT8R9Ll96D0HcvjdQjwY/HdBBrzhT3n+JOcdygDr5v2NsDzQ499KF99H8O9t03buf4P/t0D/3y54QP+ztA0PDDMth4f/FDwIr3nWhptvy9nrx16N/+Ze4p64XeDJe0waqcaa9rJ02DqYjv2tNCBt+R7Z77HQ7cbhTXn7HHlEqOfQnJboZzDRvKXPVG1dvb0cveDWVWxf2a2reVbajk6HW1fzBm3lLLh+QnVr4l2S4bw523I9lesXWzqko5JEjCsvLL42+10n+DlZWKy2k90DfDDO9OFkZ2j7rOFB+HZbrFiWajtkiHZone/+gryGcsxIXyVHHyzI64pJ5vUewWsX11WiXedUrasUm9bwZmOUCmLFd7VkYuuxjD3k7QR3Hv1dZloTe0emuvvxoZx6rNn8bpqAf5Bw5d0/3ZdDT/Uo1mONUfXSv98i6oQsIEaD0ydvpc4D1zaByywT70wsYCl7xlqm4W8QL2UtM/aeSGv7I4KXpijjlIO6u/MRQUfhesAR171OuNJneYWrwlXhqnDt4LjUIS++mxfHT76iottXLSg653RI5xxBR11ZUDZWaAZ4Vndds9zUNx+2BeioXdG8EzX9PeGyvqM0TZzJYl3eIWrw34QFnjcdld9GlLO1i3nuxjfjMMZhObe7n5y/nI6xBB82wr7GO8FDffA26gN1TUjMN9r+APrgZ6kPsD7u/sqzG0WPdSTvM7D3En8GfztkO84N7Py+P4ceygPl/NYceneJ7EroctsO9W7Pbt/P3k5PefuLuufecKld7uq7CTWqP5DoPsg7ufOA6PNYPed+Nfhtkf3q5E/2LHqljcqshQ6+Kz1Q39ZrJq19npeJRFyhTzqrflVXPHK/jgT6VW0SQD65Xw3+qch+NVl2o19Dh1hVv4YOsarxG/vVZNJMWsfJOwhXu/05Mf2KfcA+2uBfDPSrynKH/LDBf6oH/DDKKqZf1UpAbL+yH8Z+5auAcKxjW54sH/0ros/VTvGYQ8F5e8YcrwJ6MIeNPUT9hOrW6N0eObgMT/oO06oscmvuQKJToCxyg/9NIXJlpmqvljpUNlW7fUsexA3u9lUutehu36LDYhdUNX3Oy2GjJuonhKsm3mFZu+smQldp4Aj9e7QFD1WIZwrK86nI3+AtAs2LLgxfneD/NDAKhaLg9GFv3e4LUHw2FNvwKJVhvftz6ODoiJ6fR0eD/6vI0dFod2N0RBnx6PgYlPUJeJb3BwX8YwDDWaUPQhmbNMr4UaLTznWw/is9VbNvFY33B9rbblbG+qW+bjZT1AtlSgyuG5kSbA/rQsiW0odlE9IdlE0zaa8naJf8VbiQX0qfkC5gdmE9ZU3UlVc1KkOaoYuBsT5/TRjpbOmQzhZBh3HF7lMZo3P09n/UPhW1ChzaHxH68i3yo2SDd0Qw7VrOv0aH3+Xdt4B95blyHIqoQ6vKZemgn3mA6DzsSCfPZ7Fv6JSOWllW41endNA/8Tn1xxzpoK+7D+rxmKhuA31c8GFTgA/B+wJjQfR5a8PfIF4K0hubAnyI6HH7eArwYcFLU5TdCL+xDOl8WNBRuO5yxGV9OzNp7euTiI6KpT4YoHNSJJ2FHdJZKOgMinqd2oiSjdH5kCMdtJmFROfDjnRQD/YhOk840nkCYI4gOnlfP1949Pj79L+PQBlnudKHv35u8F8+dbzeaRlO00H0Fcgj1sd45HHRDqa3OKNh/m8E6hTwR/LelZHsdzvZnUmyexzKYmRn8J8B2Z1DshsB2mzbo1D2ISp7Eso+TGVPQRniwLIE2oDvWOewvsENino8Xj0N7wv0V/SX4w1/I2ltc5nx6mmih21PH74j7Zly9Ma+HP+soKf6YfdEyxTpGy6+zhX97AiVoW98isrQnz1JZWjfh8NvxJnXJt4Bi/yxfiN/D1KZ2jk7k/5Of2+jMvVl75mizRzfWpv7CU/62E6bOsEOHz1eZ032W/kb9uOPC9xW9hFRluJ/+3ET2zIC+FGOWJY+feJdaAw1OEXn7A7pnC3oMC48WIhzRPa7Br+FxpBRwFvAZteZ/J+El+zvSvqfdbH+Ls/3Il/KF8bcL1n/nad+45du+P7yomNEyHeeLeA79J3XqJyZ0Vb3Sz5FZZirMR7U/ZIlx65rYuSH+JsC/iyAK9IXCtcqJ1zsczvFta0kLrv3EmOfUcKlcoY4LoVOYTBfI21w8eeIsf4I4Rptg4t3Xo6INnJcwnD9AjfTHkxa28a+rKSfjM41GP6GaEOZ2E3JdgTeca5B6U9TlLHOPynoPCnoKFzbHHFxvtQjj6l0+EziuejOVayft+sY4XjOnP6ecDnZ0Zof1Hucb3NcYPCjMB97iuZjSDsUW3JOp+hdfSdF0rmwQzoXCjrdzn9zTmfUkQ76pguJzpOOdNDeOKfzlCMdHBd5LrBN8JDq7GfJDp6GMmWXK7N/6wR/JtjBLwfsAHnE+hhrqdwU0/t1isdLxoEyp2O42snucyQ7nNsp2bEPMfhDQHa/VcCHYGw5SmUojyep7FkoQxxYlkAb8B3rHNY3uEFRz+Rr/fUcvO9GTsfwN5LWNpeJC54jetj29OF5yfPl6I3ldD4q6Kl+wJwOyhTpGy7O6aCffYLKRqHsWSpDf/YMlaF9c07niTZt4nha8RfKhU9VzPlEOXrBmBPbVzbm5O8LeMSJHrg4PzcVsdDCDuksFHReLrEQr2/tLLHQjwrGQjyeG/xvnzJe7z8nIRZKFmz/ZypjoWkLJralbCz0UZBdf4ZTzSfZtlFOo1SGMQrHQigrXm+0sgTagO9Ca6osN6zH41XJ2CQ6FjL8jaQj/Rgbr1SMqMarDmO9sVjoeUFP9QPGQihTFReFYiHOL4xCGcc76M/ycrHpb46FtrVpUygW4j1gmLtI/8b9FbymZLAPgJ3NzexM7THj72Ogjn8Q6B5AtopyGYHfWJY+MbED1n+S+PEYm9Ra95nEc9EcNdbnNdEnBR0e09m/Hr5A84P+dRT4Yf9q8O+Cfj+K+gxps59EnjlGK9qfJ0XSubBDOhcKOt2OaThG61ZMw/mqpx3p4HjJMdozjnRwHOIYbUTw8NN9NGQHz0KZytdzvsrgDwQ7OCdgB8gj1scYbVS0g+ldSDFayTFRxmiGq53slpLsRqFMyY59iMHXQXYXF/AhOCY/RWUoj6epDHMZiAPLEmgDvmOdw/oGNyjqmXytvz4K77sRoxn+RtLa5jIxWmz+yNr3sXL0xmK0jwt6qh8wRkOZIn3DxTFaKO+BvvF5KkN/9hyVoX1zjPZkmzZxjKZ0v4v7PaLzVYa/kbTKsYxuqVhIjcM8NmFd1Tecr1J7QVTOVeEadcQV2k/GsZDat/ahAJ2TIuks7JDOQkGn2/ukpypf1a2Yi2OhbsVcsbHQe2g8fwbKYsZzg39m4Xi9LYF5HK8VPQP4EgF/RA69uykWKpn/kLEQr0GNQBnK7gMkuyehLEZ2Bv9ekN19AdmxbeO4M0plsXESx6ZqjQrfheJvjiGxHo9XJWOT6FjI8DeS1jaXGa9i80cdxnpjsdDHBD3VDxgLqfU6xMWxEPrZJ6lsFMo43kF/xut6aN8cCxnOvDZxLKT2jDGuOrxTOSeedzyf2Vdqa89SzmoEaBjtFO7oYybCVXHYxLqq798Mv7EM6cTGTh92xFXFYeN0+F2ROKxb8RHHYS+3nNSo4CH1Mb8TkZMaBZocSxj8qyCW+EIglojJSYXiMIP//UnMSeXJ7g8i4rCQ7Mbm2SC7Py4Qh1U5qXE+8R3ir3JS+TmpUBzWCzkpxR/jio3DDP5b5DdKxk3SbxiuKl6Li9fS5yyA47KiMdYTjriqeG2cDr+r4jUfOmXitd2OGX+PY1DReO2Fk8frzcxwdjNem5PRmMp4bU+SXdl4bSvIbh+SHdIO3VXA8Zra165iOR4Hi+bNsP7OljdT49WOmjcbpTL0jRyTqXMOMfHaaJs2xeTNYnNcTDMvrltN5QZ//DHjOI+lvJk6u5/C/WKVX3vZ5NdGst/qHguO14reb3WS4FnRWdghnYWCTrfvaeJ4bcSRzgjAvNzXOUcFD6mPWUH+Ta1zjgLNvHXOYyHmuDQQr3mtc15B8Vo31znzZHeVU7y2B8ju6oDs2LZxbByhsmqdc/tTrXPmx2uh+6NGoMxrndNw5rWJ4zXkbyQHV2wcZvBvJr9RMo6RfoP3pYW+UjpSjm50vDaS/fb6SukI0eP2cbz2pOCF53jpcxbAcVkoLlTzxScccYXiqCpem0gnFK91615NjtdGHOmMAAzHa0860lFxTruY42GKOZ6CspiYw+B//qTxeo8FckScz3kK8CUC/ogcek+Q38VxolO/i3eLsa+bcC9Nzlw+9hylwT8KsnuKZIe02bZRTk9QGY6pI1TmufcW67Pc1Fykw3Ov0fGa4W8kHenH2Hj1DNFju+B4reT8YSxei73DAuM1lKk6UxmK1/gcJfpGPis5AmWcO0H75njtw23axPGa0n2V48IzlZzjUuPSdNHGAn00M1YHDX8jaZV3GR1Ud3Ko8Tr97NEh2e/ss0fnDW9avvmaG6+/9qLh225Zsn7t8jUbN12/5sYla9duHL7lFmQaCc2A91iOD8PY7wfFe8Qx0qYxrAzYWSOEa7QNLr6wD+uzA3yyDS6+sE8Nbvx3f9LKpx32nRaBBw0tj6+VxJdafAk5eVTOtxEurJ+XcMnD9XbChfV5cRGTRcwnyyuEJ8+BIl/vIL7yDqGn/z3fBtebCFfe5T7pfx9tg+tnCZeahPPf/UkrnyyvEJ70v4+14eudxFfe5pv0v4+3wXUD4VKbdwzXJ9rgup5wYX2si3/3J618srxCeNL/XmjD1ybi6xNQ9gKVYb1LiE7RSRrWn6xJ2iVE5wVHOi8AzD5QL/37RSgbBRyhQ0w2+L8E77uRMDH8DeKlIL2xwf8losft44TJJwUvTVHGSY5PCjqfFHQUrhFHXC9Se3IvAqJJWNnLbN4Nk7D/pEkYyugFauNI0tpGdRlpjdo1IOARX53gk2O3/7NL0vpZ1xdEfYUbx9OYC4HRvrphI4bf60LgF4ket49t5CXBS1OUcdJC2eJLgo7C9ZQjLr5oL89GmsdOpFnWRm4AG5md4ewlG9nbwUYwhoqxkU4uj0R8xg++Q/xeNqJi2RF4xzbyouClKcp4Y72yxRcFHYXrOUdcsTZyqJONrAQbeVUXbcTkHWsjBn+0g41g3BxjI50kwxCf8YPvEL+XjahL00bgHdvIc4KXpijDOROWIZ3Q4jji+pgjrlgbOcPJRk4HG1ncgzZyTkEbUbx3Y+6l8lfHwu88GY0IXE1Rf4TKPizotNORi4/V/CgdSX/b/J0X1g8HHVkR0JFeWFg9vUM6pws6L5eNcKcTnWcd6eC4wgurzznSQV8Ze0HtOrKD56FM2YHli+oE/8UTx+vdELCDvJwlLqyGLqg1+A0ZjQ43HsmFVcPVTnZvchpnXgTZbSrgQzCmH6EylMezVIZjMud9VX4V37HOYX2DGxT1TL7WX5i37MbCquFvJK1tLhNrxR78tPa9UI7e2MKqmkuofsCFVZQp0jdcoYVVvqx/BMo+RmXozz5KZWjfMZf1Y5tCG+GKXNY/Au+7EcePZL+9LusfIXrcPo7jnxW8qL55F/zGMqQT+hAH4vqwIy5bY6g2mbW+68VDATtLLPRcgVgofXg8N/iLYTz/2CTEQi/1QCz0KadY6DiQ3c9VsVDo2WFioU+UozcWC6k17CKxkFrTfjnEQn2CP4RD21P5pES8qwXoMY1pou67iW8su4JojADemBzQFYLfLuZ1+2Lta0fJ6/Iaeie52JiYp8MNjNHx+GRsYLwC3jltou0L9cNIgF7JtbxpRi+0twvppf50IGntw3YfQkEa2F95Nl92P+WzbXCF9lPyOuBzbXDxfsq8jctY9h9Z/JL64X88diLMMxnMtwHmW9lvtimUw0/3khCc4TLY9PH4UA7iSxJte/xRxJIb5oMfRcT2oW7ukoR1BPsI90Y8Bb/VpVkxOos8xehs0T5Vm8pTuB8H4J4UcIpW+rf6sDjH4v8D60sbF01sI9Yfhd9Ylj594l3ocIbBKTondUjnpEg6Czuks1DQGRT1ajn/Gh1+x3SUbEKHMMvSQR3j3EC3DrpxbmDEkc4IwHBu4MOCh9Rm9jpu/D3bWmi84EPvf3TCeL19M5xqj/5IounFHkAz+P0zGpNxsV6e7IZIdqNQFiM7g/8FkN28gOzYttH3b6MylAcfTsOxAXFgWQJtCB1AU5dB7CwH0EIXPO0IB9DUWKd8Ix9AUx/mVD4o5kN+oQNoaixPD1ftn/0eP1x10fBtl6258fq1azZdv2H9iuE3bR6+ZVMdMDN1bEWSaE9sEkE8/NTo72lU9iCVLxdw+IRG0w6vOIiOfA1/I2nthTKWo050qSiDr+rBuuqqivfAbyxDOk8JOgrXhxxxmd5UV3m2vmM6vfAJnCcd6aBtTtUnm/OildUUreCx3ZhoxeBXQ7RyBUUrOGogj4gbI71toh11gr+aIr2SWTcZ6fHqO/o6lN2aCNmhT8uT3akgu7UkO6TNto1yGqUyde2PmrEjDixLkvDqvIoIJmHXQnSkN5L97uauBXU1TodXX4xFeiqyVP2Akd4I0FQncUNXeT5IZaNQxitE6god5YNiIj1sU0ykZ7q1VdCxsseh7CEq+4hoc2p3bye7w89Fn0ftsDJsB75jGzlP8KPoPJz9rlMbt5GvK3nN0xmDRMdwIO4PlcQda5d5cQPy1RBl9Qhe/m3O4qP+ZeR7j9eovvHC76YBftRlhD9PwHc45pw6CDQSom1lOB5+iMr6ocx4SLOW6xZN5K/kytCpMfJTto9lZ8DvIn2hcD1UEtesZKJeoe2Y/aEfeST7PZi02jTbSUkbjJ5vGf5G0iqDMuOX8r3KZ7GPwLpNUcZX8T4s6Dws6ChcWx1x2Rig+pnnW1sFna0BOicJnhWdhR3SWSjoDIp6tZx/jQ6/YzpKNpOdWX/YkQ7qAc+3HnGk8wjA8Hwrb87w8zRnwGvIY+YMBv8Xx4/X+2wgdkEesT6OLw+JdjC9X6EYpOTYIudbvLsiT3a/RrJ7CMpiZGfwvwqy+1xAdmzb6norNd96mMowTuCcUtH5Ftbf2eZbaoy39o2Wozc231L5yCLzLaTPq1fKzz5EZWoerfwZx1xo3zzfeqhNm3i+pfirYqG4WCh9zgI4Lisav3zQEVcoRqlioYl0qlioHJ0ysdAPnGKhq2E8/9EkxEL/1QOx0P84xUJnguymZb9V/o1tG+XEsZDK6ag4ief1RU8lYf1J2KEbHQtNxg5dNV55nAhM/xsV9PJ2zCqZjsBvwxWKhTj3rHYDKn/2ISoLxUIPtmlTKBbidXfMGzPs/dBehN0X7GzR8fm0HiU+7oeyx6gs1j4RB8oXfQXCX0ttMPihjO8017h5kcY5LdE6av5H5T6tHdOBrpUV0N/fSPlasWicDupL+mDeFPUlScIxlcE/KuBR5zg2fBTKOJ5T+ojxhemjkpfx2A15IQ8x8lJrYLHyYrtHeT1OuFT8izIMyct47Ia8kIcYeak9LrHyMhkoeX2EcLWb4ywleMM9kGifwLumDf508Al8K0/Ix98vcKNvrBEObEddtGOQyrBuinfkyO2/JyvPw7HmCPDCuoB4+cadC2DcuIpkM5qMPzHrWyrHMQowvJN0BMqejMD1UID2UwL+yQBt5Iv3yPDenBH4bfWUHzDZdOgH+pUfGEEAwJvXTwgfIyvVT2rNnffGxeacRqgsNueEJy1YP1X+Kc9nsz3gfIbnOmqeENK90BX9SvdUjlXZP/sNta9G2RL7Dexb9htld8LfkPVFN3fCs37XE63feTvc3wW+7aYc39ZfEOfNMB5dADaaJHq9vUNfUFe+YBQA2BeEfHD6FPWbI9nvmP2rat18BN5xTGAyGhDwiI/35r0tMiYYJd5jc+CheZ/ZQyr3JzI+2u2BfA/pnrrNIbQH0uBHQZ+30BzPw288QmXoB/i0M+pUSM/U7n2DC+257XDfeXQuhfedj5ajF9x3rtZ5PD65nP6nTs6ofsBcSrvTm+arJtuvoZxi/Jpaa1J7CNme0UewH1B7XtVaDNNDHzECbXiCbF/5yNiYBfPXP6A8NNoX2/8IlLH9o75z3IAy5LjhKeBFxTyGlz/h9jz4sF8m2ShdHoF3PHY9I+BxXyrfaoO6/kwEricCtNVp+WcCtJEvvgHqGfpb2aSyxZHsdzfmGxgXsC2qfkL4GFmpflK3wDxDZbG2+xSV4fg+SmWo23gS9Zdzxm1sh8rxtjud/h4au3eUXMFvge3+WZUraKHNfFq9KlfQarvdzhX8WZdyBb9W5QoK5wr+3w6QK/gx+LZ/cMoVfKvKFYyVTVWu4N96JFfwihO2/26XK/hvp1zBK+HMXy37XeUK5FPlCohelSuYmlyB+YiQjyyTK/j5HTRXcDD4sJNJNlWuIN8mq1xBMdv1yBWwfnrlCv6bcgXIN5/XVzalbJ7P648krbLg/svLFRjeOsEvAdtdRbJR9qP2/8XaD8+ZlP2EcIX2GKkbkZ4N0Ea++AZ2tmV1hr6L46i0XbRPtt2Qz0yfGFmpflI34PJNuyrvpe4O4FuicBxim0fdHknG28z6qfY2xY67uNeI7+94og1elueIgA/d2q5yKKEzYsr+2W+oW9uUrrPfsP5EXUV4zhUY/DVZX3R446rMFfAXAp4BHpR+89zK4N8Cvm04x7f1F8R5XYanXa7A+rEbMTXaO/uCkA9On6J+k+0W+4bvjIm9wY3tbCDRMUTeDa23QB9wrgD9EccZo1A2QmVPCrqh+5RSuT9MuQJ1k2cK91bSvREoU3Ep657BPwb6/A7KFXj4jaeoDP0A4sgbc5SeqZv/cAzleuYHOrwpMTpXwLfYP1OOXuFb7D1uqk7/e17QU/2AuYJ2N5mHcgXd9GsjABDj1xCe5+7YRrZn9BEjVDYKZew/ngzQU/M79BEhHxk738CYZTXlCkYAju0fbZztH/Wd4waUIccNzwEvKubBMRvhR8CHfYZko3Q5FMeqG/3xNn5ehwl97VfhGgnQVl/J+WiAtvpKDvOSJPk2qWzRZNON+QbGBWyLqp/UFzRCslL91CR4lE1R232OynB8Z7tG3X4W2vyZnHEb26HylSoeGAG8b6WxG/nuxi3OI8nEdqjYF/2M4eXY91fAdr9MslH+Gf1l0biT50xqvh7CNRqgHdJfRRv5wrpMm/m0esp2TTbdsF3P+YGSleqnZtJq12yDsTdKs33G3iiN4y7r56hoR+y4Owp4+VZ3tdYa0r1QnlXp3pOifcr+Q7k19huoo+w31Fc22c5QVxGecwUG/9eUKyj5JR+ZK+Cv12E+Q+k3z60M/vvg276e49v6C+L8u8hcgfVjN2JqtHf2BSEfnD5F/SbbLfZNzF4wlCnnCkxGA4nOWeKeF4T/TiBXgP6I85qxN9zz3qkRKMNcwewTt//mtZj0N+YKfpizfoa6hz6Hdc/g94QvSv47xRsefmOEylTOKDTmhL6aq9YFlD6bH+hwLh2dK+CvPpXMTQS/+qTmOx36zbFcgZrjqH7AXEG7L52FcgXd9Guh9ZB2cuW5O7aR7Rl9BPsB9BHsP0L7GEagHsbi5iNCPjI2ZsE1z70oV4D2FVoXY/tHfQ/NrUeSie1QXxRWc646wc8FH7aAZKN0ORTHtpuvc+5TzddDuEJ5CvXl2I8FaCNfWJdp59mkskWTTTfmGxgXsC2GcjTpEyMr1U9NgkfZFLXd56lMffVR2S7mwFg/2+2nYNvNyx/+MJDn78bXoHlu/XHghdfheRxA+FPAdpeSbD6RjD8xOqG+hPwJgGE/hTrxQgSu0J6gFwX8CwHayBfWZdrMp9VTtmuy6Ybtor2x7ap+QvgYWal+ahI8ysbKYr9M/XEqi/0y9cegzayfav0/704etgfcE8Rfh1e+MKR77cYs1j01Zin7Z7+B9j9CZaij7Dewb9lv8BfHGZ5zBQZ/RdYXFn+ijhTQdZkreJF4/ATwoPSb51YGfzP4tp/J8W39BXG+PsPTLldg/diNmBrtnX1ByAenT1G/yXaLfcM5HZV3QJlyrsBkNCDgEV+d4N8IfcC5AvRHnyDeR6CMYxCVO1b+CHMF91KuAG0XcwUbSffQp7G/SB/WPYO/H/R5c/bb0288R2XoBzi2VmOO0jO1VoRjKNczP2B+BXWxG7kCw99IWttcJleg7A/HB84VlPSbY7mClwQ91Q+YK0CZIn3DFcoVdNOvoZxi/BrC89wd28j2jD6C/cAIlLH/eDZAD30ExuL3ku0rHxkbs+D8/LksZlE2zvaPNj5CZajvHDegDDlueBF4UTEPjtkI/yj4sI+TbJQuh+LYTwr4lwDmo9Qe1PVPRuD6WID2pwT8JwO0kS+sy7TzbFLZosmmG/MNjAvYFlU/IXyMrFQ/NQkeZVPUdl+kMhzf2a5Rt1+ANn88Z9zGduC4zbb7UcErxgM7Wq7g58F2f5dko/xzKFdQdL6OPuzFCFyh+VpIfxVt5AvrMm3m0+r1Uq5A9VPIxypZqX5qJq12zTY4mbmC3+1SruBNL/NcQcyYj7qK8JwrMPg/pVwB6kinuYKXiEfMZ8TM6w3+W+Db/m+Ob4vNFRj8X/ZArgDtnX1ByAenT1G/yXaLfTNVuYJvROYKOK85AmUeuYJds4+TtMsVfNspVzDjpPF635uEXAH6Ac4VqDFH6ZnKFeAYyvXMD3Q4l47OFRj+RtLa5jK5AmV/oVxBSb85litQcxzVD5grUHMRxNWLuYJ2cuW5u8ppFp1vsP8okyswHxHykWVyBeuccgWo7xw3oAw5bngJeFExD47ZCL8H+LDDSDZKl0NxrMd8PYQrlCv4tID/VIA28oV1mXaeTU52rgDjArbFUI4mfWJkpfqpSfAom6K2+xKV4fjOdo26jTkw1k+vXAHHAyMCr/IJNeIX4UPzk3Z7R0N7jZ6nMrVXn+mgTxgBmE3Zb95rdFwm53YxtdHuUN9ndnsfTbv54Ej2W8VGvOcFZYznkXhsGAHeL6axAXNRvCcjdNcD18U+GMiB5/1kBr8E+vjcRRon8jAC7zrVZ2xDp/qMtnE9tdXgz59cfZ4x1frMOov6zDkhpc+1pNWHdZLPOaMH9f+1O5H+X93j+q/mEiH9b5cjYf3H+G0q9P/QAvr/YoCm0n9rW57+Yz4R4TcE9F/JdwTeFV0jDOn/J6kM6304hw7qP/Y767/B3xqp/0a7G/qPMmL9D82b0qfoXIfXBDB+D+k/r9d66X+zgP6PBGgq/be25um/4eN8+Z0B/Vc2OArvOl3rwja8RGVY78M5dPLiedZ/g78nUv+Ndjf033P+2i7PMJL9VmvdIf3ndQ4v/f/RMdt/Wx+PAlzoDseYc+zqrAqfL1RnNtWZPj6z+RHIDX2a5t4qRnoK3nVjzhvCNRqg3e5uDKat7sZgXhLBp9Xr4vmv/m6fa1WyUv3UJHiUjbKtUSqLPVcSuisPz4uxfo6KdsTa7ijgHTlmIt6n2+Ateoer0VL2/wyVhe5+RfuPOceudJ39Bq73JQKe16IN/tezvrD1DdSRArou16L5rho8h6/0m9fuDP5Pwbd9Pse39RfE+duR46zTXTX1bt9V085vst2qs2k1+htxqfUbtrOBRM91DR+f9f4DEdcpf8T3caj7mpQ/eorK0GZwLfr7tBaNtotr0X9Guoc+jf1F+uTdxfhvoM9/kf329Bt8H5a66yA05ig9a4r6OIZyPfMDHZ4Bj16LNvyNpLXNZdaiY++n69Bvjq1Fqzyh6gdci1ZnaBFXaC26m34N5RTj1xCe14axjWzP6CPYD6CPYP8xEqCHPgJj8e+T7SsfOSrwDlIZ1k3xPkzzDbSv0H1OMefY1Z45jhs+CryomAfHbIT/b/Bhs06eiFPpciiObXfOnO8PUufMQ7ieCdD+hID/eIC2OrfDvCRJvk0qWzTZdGO+gXEB22K7NdkYWal+ahI8yqao7fL69giUhe7Kw/w762cozk8ftt2nBa8YD8wU9ENj9wiVqVhJ2TXfT6PWGEYBJu9+iv1OHq93NMnG+36KUWpP0fspQnfxtfMbTLu6n2IivOqnmPsp1H0tyj45x4DzDJ6PqDFH6We7b4qFxl28W+YqyhV43wPJuqfiZmX/7Ddix3X2G9i37Dc4PmR4zhUY/OlZX1j8iTrSaa6Ax3E8c6P0m+dWBr8CfNuiHN/WXxDnmRmedrkCp3G83u1xvJ3fZLvFvuH5oxpLUaacKzAZDSQ6T2H4OL+9DPoglCsoEi+o/J3yR5gruDnjg/O56W/MFawi3Subp7oF9Hl19tvTb4Ria963qsYcpWdqbyCOoVzP/ID5FdTFbuQKDH8jaW1zmVxB7Ny9Q785litQcbjqB8wVoEzV/T2hXEE3/VooB9pOrjx3xzayPYfyiSNQxv7jqQA99BEYi98cMd8YFXhVzILzjRWUK1D7j4qek+W4Qc3neNzI29OUd072reDD7iHZKF3u5E4t3odf9E6tUI79RQEfOgNQ3ak1EV71kzpzErpTK2S7nGPA8Z3tGnUb95ffkzNuYzvUWoiKB3DMX0VjN+YK+LsXRfMByuY5TlOx76jglWPfR8B2P9blPN8otadoni80X2uX52PaVZ5vIrzqp5g8H373gnMFsfbJNo+6jePux7qUK9iTcgXKJ4R0r91+Gta92DMk7DeK5gOUrrPfsP5EXUV4zhUY/GcpV4A60mmu4BPEI+YzlH7nnQn+PfBtv5zj2/oL4vzVyFyB0/7twmdBQz44fYr6TbZbNcbX6G/Epc6AsZ0NJDpnmXde4P8EcgXojzivif6IcyBPC7rKH2Gu4FuUK0DbxVzBl0n3VF4ffQ7rnsF/B/T5jyje8PAbvMdJ5YxCY47SM7XOi2Mo1zM/0OFcOjpXYPgbSWuby+QKlP2p+U6HfnMsVxB7/x7mCtRcBHGFcgXd9Guh9ZB2cuW5u7rzRfmI0BoG+4+nA/TQR2As/i2yfeUjRwVeFbPgfoXdKFeA9sX2XzQfoObWHDd8AnhRMQ+O2Qj/Q/BhjYUTcSpdDsWx7ebrvA6j5ushXJ2cewrdF9LuTi1lk128b0LONzAuYFsseueukpXqJ3VGjM/PxNruJ6hM5QOU7WIOjPWz3Z5Ntt3nBK8YD+xouYI5C8frHUqyqXIFrXxWuYKJZZOZK2D99MoV/MGCiXirXMH477xcwQlZX/RyruBC8G0n5/i2ormCUzM8Va5g6nIF50AfTGWu4LqMj3a5gqU5MUfRXMEbQZ8vzn5XuQL5VLkColflCqYmV3Ad2b5XruB3sphlR8sVbAQftqXKFbTQzrPJKldQzHY9cgVbupQrWEpjdyhXgLyNUpnnGYQRgMk7g3Af2O6TJBvvMwgj1J7JPIMwQrSrMwgT4UN3+4XOIIRyBaNQ5nEG4cmIXMEIvGPbHRG8png/QLkC7zMII9nvomcQ2G+E8g+TfQbhk5QrKBnTd/UMwm+Db/tMjm8regbhFyJzBdUZhFaZep1B+I3IXAHnOUahzOMMwt9RriDvDMLvku6VPYPwDdDnL1K84eE3qjMI1RmEnyLP/n25nkFAH8F+YBTKPM4g/B3ZvvKRIwKvilnwDMJ7KFcQmytk+5/sMwjfBh9WO2UizuoMQr5NVmcQitmuxxkE1k+vMwi/S2M38s13Bk3WvoIRwSvHvrudMl5vf5KN976CEWpP0X0FowHa7dbHRoh2ta9gIrzqp5h9BZgTG6Uy730FrJ+joh0j8C407o4C3qUR+wpCutduX8FI9rvovgL2G720r+DIrC96eV/BmeDbFuT4tqL7Co7L8FT7CqZuX8EZ0AecK0B/1O19Ba/P+Gi3r+Bs0r2y+wquBX0+L/vt6TeqfQXVvoKfIs/+fbnuK1B3mXVrX8HryfaVjxwReFXMgvsKzgzsK2D776V9BTeAD3sHyabaV5Bvk9W+gmK267Gv4B054za2o8y+Ao4HnhJ4RwXeGvGL8CPwjuWvfE5ov4KKhdQ655M5dNAnYNtWZv/y2s97I2Pqbq7Fe347oN180GSiYiO+51Pdmav2nD0FvB9OY0MN4JYRr7WkldeaaFszp77Chf1yBPw+HMoR/qM0l0R5FujXZYNQJwEciLukzizDttqj4kmMnRS99GmIsnoEL59f+OsXPfmfx8+oUX3jhd+xXvYL+GUC3mQ1QLwPJVHPRcp2jbaVcduxDO3PeEhtdt2iifz1l+QvRn6IvynglwNckb6YlUzUBdR3s1e8o/chKkPfPEplyjeHcs7s39Bv43dAeM3e4D8JsdznI8ZKjJ+78W2aEK7Qd2jb7XFj2mouy7wkSX4MoOzDZNONsS20BtsupomRleontWbLuaSHoIy/RzUKZRwfqm/fhPagKf30+qbVNModq9gspHvtYjPWvdjYjP1G6P7corkjtjPUVYTn3LHB/wGN9yVzLjJ3zHtOnwceiuTavgG+7Y+d8ndfmdw4t3COpeie03Z+k+02tPfgaYFLza3YzgYSHWMbvjrB/00gd4z+iOeWo1AWyidx/I42g7nj/lO3/x5MWm0Xc8f/kJM/Qt1Dn8O6N7Ymeep4vW9R7tjDb3BeCf0ArxOoMUfpWVPUxzGU65kfML9Sct9XdO7Y8DeS1jaXyR0r+1PzzA795ljuODZXjbljtRaOuEK54276tdD8vZ1cOZer1lKVj2A/MApl7D+eDNBDH4GxuPmIkI+MjVmeBrw/Onr7b2XjbP+x+0xjcs48bigfxmM2wjfBhx1EslG6HIpj2617htbCPhGBK5QfarfHjWmrPW7MS5Lk22QX13H6u70+rWSl+qlJ8CiborbL+eHYnDOu+7B+huL89GHbfUbwivHAjpYrOBJsdxHJpsoVtPJZ5Qomlk1mroD10ytX8LmjJ+KtcgXjv/NyBcuyvujlXMG14NuW5/i2ormClRmeKlcwdbmC10EfTGWu4N2RuYLhnJijaK7gDtDn67LfVa5APlWugOhVuYKpyRW8u0u5gs/uoLmC94MPe6LKFbTQzrPJKldQzHY9cgVPdClXwPHANoH3CYG3lrT6oZh9Zk8JeJQHf1cb5cgxAdZ7KIeOykGkD+8zM/iPRsbURrsb+o4yYn1XPhvhWd5q/oixMs+v1Z4/pe9G03h+QuBMeR+hseFxgPtgMrHsI1DGZ5lHoIy/tYY6gnxgP6EebAUYw1sn+F+CseFLZCNKhz8C77gPQn2G/Ci9jpnXPB6g3a7/mTbyhXWZNvOJ+mC0rMxk0w1bQf/DthLyNekTIyvVT8pWOK77IJQ9TmWhu5PwW2sjVIa6PZqMt5n183HRjq3wjseGrYLXn54foFzUiMAb0r1RAT8CMKx7HxHtU/bPfgPtn/0G6ij7Dexb9hs4308EPOeiDP4vKBeFOlJA12Uu6hni8SngQek3z90N/nvg2/46x7f1F8T59chxcyT73Y0522SOm2y32DcfIVwfEbjU/I3tbCDRMZLhqxP8twK5KPRHTxHv6I9GqezDgq7yR5iLap62/bc6n4S5qH8l3UOfpmJJ1j2Dn33aeL0fUi4KaZf1GxyToh9AHKxTIT1T8wSOqbCe+QHzK6iL3chFGf5G0trmMrkoZX+j8I5zUSX95lguSs2PVD9gLgplquZLoVzUCPCPsB5+DeUU49cQnnND2Ea2Z/QR7AfQR7D/+HCAHvoIjMXNR4R8ZGzM8hHAu5DmG2hfbP+hu1pR3zluQBly3PAM8KJiHhyzEX5f8GFHkmym4l7KEK7RAO1255pGiLbKxTMvSZJvk5M9N8e4gG2xXU4mRlaqn9QZMF4Li7Vdzm/h+M52jbqN+V7Wz1HRjhF4F3vHCscD9wm8/QKvwW8FXH2EI/29KftdJ/jjs/Zg7Go47xc8hM5PPSjg7wcY42dm0urHHqQyrHd39lvpu8F1qO8zlL5je1jfH4KyPgHPslG5RcwpGf4mwaOcrOxuKDOag4QH5Z2+u+HIify061vWrwcAl+rbW7PfdYI/J6BfSl/ugXcsw5DMkZ+ZxAPWnSnqmXyVfhlch/o1U+kXtof1K6Qv6cOyeVjAow4Z302CRzlZGdql0VTnNe8H3odeNREO/Vct51/jld/xPAFxLSd+tjrSwXYfQXTuhTKcx11J4wHKpE/UvTn7XSf4N0MM9Lrs90xRfyvVt7I1YGd3LMqvzz4Yx4h+KkN5oM/JayfC35rTznXA5+ZArsT46tDumsru0PfF+HWEL+rX2XejTd5LuO4VuNQ8gGOEgUT3geGrE/xG6APOlaA87ife7y7IuxpPlB+xuintr87f/lvFAQ8QTTWGqb5qivr35+CaJvhHu+V+70v0eMjwphOYr1T+uU7w74S+umuRxpnk8HBvDs8DOfAPEQ8Gf7vQl5AfQP1/kHAa/J2A8y0FcW7Mwfm+QKyh7PQBeFd0POV4AuX4MJUh7zwubgP6DLuZ6GMZ6jnTTQL88pjajl8eb6xsBMarh7Lf0wlfQV/dF+qrFYLf2L66N9A+xmX16kmrPoZsBOXx+GkaZ39BnE+IMV3FKocD/pGceCRJWuOR9GG/jD4D7fBKikmQfj/xb+PEs8Ie1VhvuDob62tfU2P93QDBY72SDcKzT3hAwGM/coyN481hVIa8cGx1t6ATO5beDW39hfkT8W4N4E1/v474aBfjvSH7zX745wN+WMkwJHM1R0S58joq9gfnFJTOTrY+YvtZH0NtTZ+i82HWRzV+KH3kOCukN+kT0kfMSz1PsR3yynOPhwL8tIu56wRvPn4gB559vsF/IRD3PCJ4CM0THhXwjwieZxIPWJdp5+3vWkbtMfgvR/pjp5zHLKX/KDfW/5CM0odl+piAR1nx/q7HoOxhKkNeHqEylUcK2WysbVjdlPa7yFd75+fYVxv81wrm50K+ulv5uZCv7qau9mp+DnmJzc+9KSIW6A/wr/Rxq+Bf5ZW437HefUl7vrYKvtQ8ZmuAzskd0jlZ0Ol2DvJkas/9gfYUzYVg/fupPfc7tkfx3C6nOu30ZELblG/DOQyPdwY/9/Txev3Z71BOtaju3pNM5DOUQ0qfFdD+JOlGzKnXbScz5uS4EsfLmJwh6h6OnQaTEI/dkBfac8ycUfmNkHxVjq6ZtMryPipDfdtKdLzyr+fPb8//fYH2ttMPzsX00BrdlMcArAtF1+jYXyId5S+5j9G/Yr/wmpXBH5n5VBU7Kj0I6U27OZ3xo3SDz/WrPH8XfUhP682DVKbyjrF6E8oV4hht43coR1ZLJo6TqM8In7e+spXw1Oj9rvAe691EbeYYiXGvJ3hr50AOvOHjWOQssJVzAzkxhXMD8fBgGx4eIB4M/jzBQ0j+6ROKCacnrbZYwG7qNcJn/OA7xN9ItH4MJVFPjeVn9JQepA/bsrIntVYS8oHKzhWumHXpWFwWN6gY9iSiU3RehPVD86+FHdJZKOh0e/51EtF50JEO2sxCovOQIx3Ug32IzjZHOjge8d6Z+wQPqX6vo3new1CmYoZV2b+cp33pjPF6N9A8D30F8oj1Vc4E28H0NmQ0zP9hHreAP5LnnAxXO9m9iWSn1mpCsjP4B0B2mwKyY9tWMcbMpFUeHNNjfpbXXlX+F9+xzqkc+aCox+MV5oGLzBVjbAPxN5LWNpcZr1SeG2NCPj/ywXL0xs6PqDOUqh92T7RM1flPzm+qeEP5xkepDP0Z5+nRvg+H30gjr00W284M8KfiUIzdVL6FdW+yY6UHytELxkoqP1Q0VuL9V70aKyGfHCsVzbli/fsDdBZ2SGehoNPt3G4VK8XTKRMrPe8UKx0P4/3HabxHXxETKz0g2sH0PtkDsdKnI9YTQrIz+L1Adj8fkB3bdhUrjfOJ7xB/FSvlx0oq3uhmrPRAmzZxrKT4U/FO+gwlcU9MLIXtK9B3B8bqpuH3iqVUXKJiKWvftnL0hlJd2zWrh3HsGvit9j9hf3n1n8rNTFX/bS1HL9h/Kmfl2X9oW0X6T9nmMfAby7A9obgS609WXHkM0ckb479OY7xa08IxnvcMGPz3YM/A39EYH7sv4F7gmdvstM7fV/RcU2jvcvoU3XfLY1Ro3VrtKa8lrX1SdN0az7cenrNuXQO8N4u6bNsI/6Dgw+D5LA3D8LkXg/8hrMEsztlvl3fuJW8d9t8D67DdPveCcuZzJFgvtA5rcB3axIHKJrA9bBNqD6+KFQ2+3R5e1nuMZR8kXGxf6bNM4ArxurUDXrkfsa94v7HBol5ie1gvDX63bL7Ubr+xybwb/R9ah1cyDa3Dt5Mp57tCe5FD6/Dt9tywT7xP8IBj4mTNUTln8Bjw0id4Nbx1gn8lzLOPOWMiTpsvJUmczar5Gc65+Dw0zs0ej8AV8qUfEvCPB2gjX1iXaTOfVq+LtiX3yeFcm21L9RPCx8hK9ZO614XvmIydLz9GZbHz5UehzayfKs6KtV3MS3HOSvmqkO7FjlWh8ybK/tlvqDFO2RL7Dexb9hucB2F4zjUa/KuzvrD5F+pIAV2XucYPEY8fBB6UfnMO0eBXgW9bkuPb+gviPDtynLV+7MY9bWjv7AtCPjh9ivpNtlvsm5izwShTjutNRgMCHvHx2aqLoQ/4TgX0Rx8k3mPzd3xeSa0hpHLfmPHB563S3zhfvox0D30a+4v0Yd0z+M2gz5dnvz39Bu/tRD/Acaoac5SeqfgMx1CuZ37A/ArqYjdy4oa/kbS2uUzeKjZH3aHfHMuJf1jQU/2AOXGUKdI3XKH7J7vp11BOMX5N5cmbSWsb2Z7RR7AfQB/B/uOhAD30ERiLbyTbVz4yNmbBdcjnab6B9sX2jzbO9o/6znEDypDjhg8BLyrmwTEb4d8OPuw+ko3S5VAcq76Fh/cMPkLtQV1/IgLXowHa6h7RJwK01f3GzEuS5NukskWTTTfmGxgXsC2qfkL4GFmpfmoSPMqmqO1+iMpwfGe7Rt3Ge+nvyxm3sR04brPtPiJ4xXhgsvb+eeUKHgPb/USP5wpC+fYqVzDOTzsf65kriN2H6JErYP1U62+x4+6Es90RuYJO7qYomytgv9FLuYJf2gFyBV8G3/YrTrmCX69yBWNlU5Ur+GIgV4D+qNu5gm9H5gr+0ClX8D3Q5z8J5ArK+o0qV1DlCn6KPPv35ZorQB/R7VzBt7uUK1gXyBWw/fdSruBH4MN2e/VEnFWuIN8mq1xBMdv1yBWwfnrlCjge4D396XMlvOO9LLzHO48Pgzc9ydtrlZcbmJO1H/daqX1BS6Fte75atw39hJr/cIx3/KvH6+2T/VaxDt9roWKdJGn1ywx7Ro4MhoCPV746n5bp0GCgjSmOg16dD3eGgGMc04QMeHx7QNRTc08+k/MI0Xg4QGObqKdoPEQ4UWbqrMEH25Q/JtqWiHfTBPwjOe1NBO1H2+B9WOBRvibkozim9ooNPptdlqvsJc8mlF49EuD9MeK93V5A5l3JD/2H2h/JZxlYtx4U7ayJv42/dfCOfay66x1hrC7vT10kfCbjzNsHOJyD80zAyftTlc4cBe94LA71E/Kj9jU+QvXUHUKJeKf6516C5VzCGYKnvL+3CTx5PITO14bO73ntKXyKbFPd5Wh/30+8IyzflcJnM1i/8/azo34jDOu3wa8K6Lc6F4h8DefgXB3QbyX3I+Fd0fvTeG6k7k9TvKPv4Xeqf1i/2R+dIXjK+/sBgSePB7XuZPp9Xw5Opsn6kD6s3/2CTvruKNJvpMP3tKu9fmpPXlPU5zuajIfrQJf4uxjIp2rjshycbwzop/d97KFvCD0YqIf9N13QGrIf/xN+DJ/Zwi5Jvg7yfvVbQE7vXqR5qTE/bZ4unmMcqhG+JNE5wh30HOMBHucY+WxU+htz2++g+Z6yMay7NvvNNnY7zLPelYMzSTrzTXMOm4i3W3e3KtsNnfvhOzPU926MBxVDIjzfU27w7wfb3Nz1u+tr31M5JYwROR4JnZtKn6JxLH+vR62PhPRL5XpZb/K+h8Df/DH4h6EPeN0K76blsy73FeQ97w5gtkW0DbZjda5Q2VzI7pFv+zYK2/1HAmOr9/dleB1exXdq/07oPKrBdeMO1Mm8d9rwqxwGx5Hq3lLle/F86Y8OnciPum8Z+5b1C3H1CT5+JvvN3+r7VEC/vO/w57uZY887m+138bzz7Kk+72x9G3PeGX0hn5NX31BMef8K6ZcaJ7Hu67PfPE5+rmCuJWRz7cYo4yeUa1E5VdYlld8zHkJ7DdLf1yYT5WDwX4iMF5z2vC0puh4c+nZN+nBfhPbIoUyaBM/9gn8jrtD6i/p+0iMCP9/99CeBeCF2z2wM78rvKntDm3prZm//f3HXDhpFFEV3s5P9TWIIsYgsREEMgp8isI0iCwuBIH4LJaJRCz8gCMZGQQvBQoJLYiNoldJCJIgKFtoZQbQIFiISEINYKJomijYqE+aSw8mdOzPZPHaaWd6779w37913f8Pe0eJ89lmt7+DwWLQ9+Qj6qPjzo7JerM+icq8nCFPo5wx9oNnUBrSlrdHOuVctH6nFD1ZtgNXx5zP1VtdoZ/th1fZPW6M9qfyjDJ0h+Ud7fpN4Wn4sj0U+UfIfVSP9lyH/cXH5UcIU+j8pc1+W/Mf5CJaPZNXlEX3j0D8fbLV/zvJv+edp87xJ5R9l6BD5W1r9ZBx7LPzN9ZP9cE2TyhfGDSv1QTUZsnQv52c035X3McrOcJwi9D2wDpa/tUrf3OhptT7nd2+af2vpT6u2kKY/NXvJ+rMP9sDKz3BuaSLl3JOeNzxTdbI3GPuyvZkwePJYPNdR9kbw2DZsVtYrSzyi8kFsb4R+i6EPNN1l2Zu4eJ3zQVqdLS2Wt+J1oWvyfK51/V2tuFwZ2xvUh/y9nLTf1Uoq/yhD20P5b25dL49kYS6CnVMoPboLTS3ckxLwl7uXYB4fpn++e7x74Dz/7yW4ZI/KTeBXnp2eqc1+nXWFPzbgdY8f2TvkCn+m8G3h9cuzt1zhfy4eGGx70ljvCv/Owr7q9d6N867wb7/YNjR/8HtfHP6a8Hce+nM0phDePejLK3ge0R8Oz0BwdobJV2lX+C3GSwZdNuKuzRnnI20lhT6n0AvvskIvfT70oY5FGlwvxCpBP9KfCp9d9qQIY2R8l8K/SPy1eWNbG9H7Cr2v0AfPOUJ6DZ897Tvu4MrTeGxD3vJ+OrgKmeXzxX2UOcm6FhV66UOZYHkpQ3tOwSrQOKEfpX3E55HxXQp/XItMxLyxjfdRk++SQh+sz7na0pxXqmOuvrl472/3/S+udNij6tYdncP911zhd04/3f/p94V+V/g35v69b1xZ98MV/q7JS2Md1amHrvAf+G/rzyeLx13h79w03lt5NdrhCr/dq9zdMHVyTxz+f3sdTcq9FAkA",
      "custom_attributes": [
        "external",
        "utility"
      ],
      "debug_symbols": "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INJt0G3QbdBt0I1ZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkllSP4BijcBIXcRON6MRDDGI+rCy5SLekW9KtsmTMQiM68RCDmBdnNRI2DuIkLuImGtGJhxhEug26DboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptum26Gd2Mbka3ypKxCzfRiOV2Cg8xiPmwsuTiIE7iIm6iEenmdHO6Od0O3Q7dDt0O3Q7dDt0O3Q7dDt0O3YJuQbegW9At6BZ0C7oF3YJuQbekW9It6ZZ0S7ol3ZJuSbekWz638fsRB3ESF3ETjejEQwwi3QbdBt0G3QbdBt0G3QbdBt0G3QbdJt0m3SbdJt0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0W3TbdNt023TbdNt023TbdNt023TbdjG5GN6Ob0c3oZnRjlgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslilixmyWKWLGbJYpYsZslilixmyWKWLGbJYpYsZslilixm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wSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksQd/r9zd9F/pegZUlFz+3vQoncRE30YhOPMQg5sPKkot0c7ohS07hJhrRiYcYxHyILAEO4iTS7dDt0O3Q7dDt0O3QLegWdAu6Bd2CbkG3oFvQLegWdEu6Jd2Sbkm3pFvSLemWdEu65XND3+vFQZzERdxEIzrxEINIt0G3QbdBt0G3QbdBt8oSm4WHGMTPzb5LDn2vFwexrslduIibaEQnHmIQ82FlycVBpNui26Lbotui26Lbotui26bbptum26bbptum26bbptum26ab0c3oZnQzuhndjG5GN6Ob0c3o5nRzujndnG5ON6eb083p5nRzuh26Hboduh26Hboduh26Hboduh26Bd2CbkG3oFvQLegWdAu6Bd2Cbkm3pFvSLemWdEu6Jd2Sbkm3fG7oe704iJO4iJtoRCceYhDpNug26DbohiwZhZtoRCceYhDzIe5LgIM4iXSbdJt0m3SbdJt0m3RbdFt0W3RbdFt0W3RbdFt0W3RbdNt023TbdNt023TbdNt023TbdNt0M7oZ3YxuRjejm9HN6GZ0M7oZ3ZxuTjenm9PN6eZ0c7o53ZxuTrdDt0O3Q7dDt0O3Q7dDt0O3Q7dDt6Bb0C3oFnQLugXdgm5Bt6Bb0C3plnRLuiXdkm5Jt6Rb0i3pls8Nfa8XB3ESF/Fzsyg0ohM/N8e/DWI+rCzxVTiIk7iIm2hEJx5iEPPhpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26ab0c3oZnQzuhndjG5GN6Ob0c3o5nRzujndnG5ON6eb083p5nRzuh26Hboduh26Hboduh26Hboduh26Bd2CbkG3oFvQLegWdAu6Bd2Cbkm3pFvSLemWdEu6Jd2Sbkm3fG7oe704iJO4iJto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",
      "is_unconstrained": true,
      "name": "get_owner"
    },
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14067204867181196045": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "9921926525851912681": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [
          {
            "name": "chain_id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 16
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "array",
            "length": 32,
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            }
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "utility"
      ],
      "debug_symbols": "TL3NkjQ7j5x5L2etRRIkALJvZRay0Ywka7M2tZl+Vn3zqoATdN/0eby/t+gMkvCMikRl/sc///9//S//57//53/9H//t3//XP//y//zHP//lf/7rv/3bv/73//xv//7//b//+1///X/8/X//45/f939W/vMv8z/9s/Y//xJ//zn//Mv+T//4D/8Z+I/hPxP/WfiP4z+B/yT+s/EfjBIYJTBKYJTAKIFRAqMERgmMEhglMEpilMQoiVESoyRGSYySGCUxSmKUxCgbo2yMsjHKxigbo2yMsjHKxigbo2yMcjDKwSgHoxyMcjDKwSgHoxyMcjDKwSjj97v/Hfe/dv8773/X/a/f/8b9b97/7vvfO96444073rjjjTveuOONO96444073rjjjTue3fHsjmd3PLvj2R3P7nj2N974fZANu+FcmH9jjvnBaLCG2fA37ogP/ga2+qloyIbdcC6sX8PfyLY+sIbZsBq+kf2DaMiGb87f5XxFUPCVAeBv5Dk+sIbZsBq8IRqyYTecC19pAHrk6JGjR/5KZH7L8hUJIBqyYTecC1+5AEaDNcyGHjl75OyRs0fOHjl75N0j7x5598i7R9498u6Rd4+8e+TdI+8e+Sur+W3BV1gAa5gNq8EboiEbdsMB2O/XMBqsYTasBm+IhmzYDT3y6JFHjzx65NEjjx559MijRx498uiRR49sPbL1yNYjW49sPbL1yNYjW49sPbL1yLNHnj3y7JFnjzx75Nkjzx559sizR5498uqRV4+8euTVI68eefXIq0dePfLqkVeP7D2y98jeI3uP7D2y98hVg/uDbNgN50LVYMFosIbZsBq8oUeOHjl65K8G11/l2leDgNHwN/KKD2bDavCGaMiG3XAufDUIGA098u6Rd4+8byLZjoZs2A03kez8GkaDNcyG1dAjnx759MhfDa7zwQHMrwYBo8EaZsNq8IZoyIbd0COPHnn0yF8N+u+D2bAavCEasmE3nAtfDQJGQ49sPbL1yF8Nen4QDdmwG86FrwYBo8EaZsNq6JFnjzx75Nkjzx559cirR1498uqRV4+8euTVI68eefXIq0f2Htl7ZO+RvUf2Htl7ZO+RvUf2Htl75OiRo0eOHjl65OiRo0eOHjl65OiRo0fOHjl75OyRs0fOHjl75OyRs0fOHjl75N0j7x5598i7R9498u6Rd4+8e+TdI+8e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Yz+P/Tz289jP4zyP8zzO8zjP4zyP8zzO8zjP4zyP0x7VHHVpPLJH89F65I/iUT7aj57HeB7jeYznMZ7HeB7jeYznMZ7HeB7jedjzsOdhz8Oehz0Pex72POx52POw5zGfx3we83nM5zGfx3we83nM5zGfx3we63ms57Gex3oe63ms57Gex3oe63ms5+HPw5+HPw9/Hv48/Hn48/Dn4c/Dn0c8j3ge8Tziebw691fn/urcX537q3N/de6vzv3Vub8691fn/urcX537q3N/de6vzv3Vub8691fn/urcX537q3N/de6vzv3Vub8691fn/urcX51X41V60Xy0HvmjeJSP9qNzqRqwLo1H9mg+Wo/8UTzKR/vR8xjPYzyP8TzG8xjPYzyP8Tzqj+PwJ1r70WmqP5EDjUf2aD5aj/xRPHoeX51vKzpNX51fGo/s0Xy0HvmjeJSPnsd8Hut5rOfx1fleRfPReuSP4lE+2o9OU/01KWg8eh7+PPx5+PPw5+HPw5+HP494HvE84nnE84jnEc8jnkc8j3ge8TzyeeTzyOeRzyOfRz6PfB7156l1wuovVEGnqf5ONYrGI3v0eeyi9cgf/XmcOk1fnV/aj/48Tn701fml8ejP49QoX51fWo/8+yvOX2EQk7iJp7E6vRoH0YiTuIhODGISy20UnofjRyy3VWjESVxEJwYxiZt4HtqPSDejm9HNys0LnRjEJG7ieVh/PXtxEI04iXSbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0W3RzujndnG5ON6eb083p5nRzujndgm5Bt6Bb0C3oFnQLugXdgm5Bt6Rb0i3plnRLuiXdkm5Jt6Rb0m3TbdNt023TbdNt023TbdNt023T7dDt0O3Q7dDt0O3Q7dDt0O3Q7Ty3/fsRB9GIk7iITgxiEjeRboNug26DboNug26DboNug26DboNuRjejG7JkF07iIjoxiEncxPMQWQIcRLpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui26Od2cbk43p5vTzenmdHO6Od2cbkG3oFvQLegWdAu6Bd2CbkG3oFvSLemWdEu6Jd2Sbkm3pFvSLem26bbptum26bbptum26bbptum26Xboduh26Hboduh26Hboduh26Hae2/n9iINoxElcRCcGMYmbSLdBt0G3QbdBt0G3QbdBt0G3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mCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1lizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZgr7X77t9J/peL27i57bmh5UlFwfRiJO4iE4MYhI3kW5JN2RJFhpxEhfRiUFM4iaeh8gSIN023TbdNt023TbdNt023TbdDt0O3Q7dDt0O3Q7dDt0O3Q7dznND3+vFQTTiJC6iE4OYxE2k26DboNug26DboNug26DboNug26Cb0c3oZnQzulWWuBU6MYifm8/CTTwPK0vWKhxEI07iIjoxiEncxPNw0W3RbdFt0W3RbdFt0W3RbdFt0c3p5nRzujndnG5ON6eb083p5nQLugXdgm5Bt6Bb0C3oFnQLugXdkm5Jt6Rb0i3plnRLuiXdkm5Jt023TbdNt023TbdNt023TbdNt023Q7dDt0O3Q7dDt0O3Q7dDt0O389zQ93pxEI04iYvoxCAmcRPpNug26DboNug26DboNug26DboNuhmdEOWjEIjTuIiOjGISdzE8xD3JUC6TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui26Od2cbk43p5vTzenmdHO6Od2cbkG3oFvQLegWdAu6Bd2CbkG3oFvSLemWdEu6Jd2Sbkm3pFvSLem26bbptum26bbptum26bbptum26Xboduh26Hboduh26Hboduh26HaeG/peLw6iESdxEZ0YxCRuIt0G3QbdKkt8F07iIn5ugX8bxCR+bjELz8PKkouDaMRJXEQnBjGJdDO6TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26LbotujndnG5ON6eb083p5nRzujndnG5Bt6Bb0C3oFnQLugXdgm5Bt6Bb0i3plnRLuiXdkm5Jt6Rb0i3ptum26bbptum26bbptum26bbptul26Hboduh26Hboduh26Hboduh2nhv6Xi8OohEncRGdGMQkbiLdBt0G3QbdBt0G3Qbd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",
      "is_unconstrained": true,
      "name": "get_registered_emitter"
    },
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14067204867181196045": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "9921926525851912681": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [
          {
            "name": "chain_id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 16
            },
            "visibility": "private"
          },
          {
            "name": "emitter_address",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "boolean"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "utility"
      ],
      "debug_symbols": "TJ3LsjS7bpzf5Yw9aAIkQOpVPHD4qlCEQorwZaSX9yokwcyJz5fW/pksspBdXYVV/R//+B//87/9v3/+L//yb//r3//PP/7pP//HP/7b//6Xf/3Xf/nn//Kv//7f/+v//Zd//7e//9//+Mfv+39O/OOf/D/94+Q//in+/mf/45/23/+c+p/x+93/Hfd/7f6v3/+d93/X/d+4/5v3f/f93zveuOONO96444073rjjjTveuOONO9644407nt3x7I5ndzy749kdz+54dsezO57d8eyO53c8v+P5Hc/veH7H8zue3/H8jud3PL/jzTvevOPNO96848073rzjzTvevOPNO96846073rrjrTveuuOtO96646073rrjrTveuuPFHS/ueHHHizte3PHijhd3vLjjxR0v7nh5x8s7Xt7x8o6Xd7z8G2/8PoiGbNgNf2OOvzNz7F/DaLCGv3FHfPA3sH3/aq+GaMiG3XAunL+RbX4wGqzBG76R1werIRq+OX+H81UN4ADsKxwfH4wGa/CG2bAaoiEbdsO5MHrk0SOPHvmrIvcPZsNqiIZs2A3nwldMgNFgDT2y9cjWI1uPbD2y9cjWI3uP7D2y98jeI3uP7D2y98jeI3uP/NWX/22BfQUGGA3W4A2zYTVEQzbshh559cirR1498uqRV4+8euTVI68eefXIq0eOHjl65OiRo0eOHjl65OiRo0eOHjl65OyRs0fOHjl75OyRs0fOHjl75OyRs0fePfLukXePvHvk3SPvHnn3yLtH3j3y7pFPj3x65NMjnx759MinRz498umRT4987sj++zWMBmvwhtnwjbw/iIZs2A3nQtVgwWiwBm+YDT3y6JFHj/zV4BwfnAtfDQL+Rp7xgTV4w2xYDdGQDbvhXPhqENAje4/sPbLfRHJfDdGQDbvhJpLPX8NosAZv6JFnjzx75K8G5/lgN5wLXw0CRoM1eMNsWA3R0COvHnn1yNEjfzW4fh9YgzfMhtUQDdmwG86FrwYBPXL2yNkjfzW48oPVEA3ZsBvOha8GAaPBGryhR9498u6Rd4+8e+TdI58e+fTIp0c+PfLpkU+PfHrk0yOfHvnckefv1zAarMEbZsNqiIZs2A098uiRR488euTRI48eefTIo0cePfLokUePbD2y9cjWI1uPbD2y9cjWI1uPbD2y9cjeI3uP7D2y98jeI3uP7D2y98jeI3uPPHvk2SPPHnn2yLNHnj3y7JFnjzx75Nkjrx559cirR1498uqRV4+8euTVI68eefXI0SNHjxw9cvTI0SNHjxw9cvTI0SNHj5w9cvbI2SNnj9w1OLsGZ9fg7BqcXYOza3B2Dc6uwdk1OLsGZ9fg7BqcXYOza3B2Dc6uwdk1OLsGZ9fg7BqcXYOza3B2Dc6uwdk1OLsGV9fg6hpcXYOra3B1Da6uwdU1uLoGV9fg6hpcXYOra3B1Da6uwdU1uLoGV9fg6hpcXYOra3B1Da6uwdU1uLoGV9fg6hpcXYOra3B1Da6uwdU1uLoGV9fg6hpcXYOra3B1Da6uwdU1uLoGV9fg6hpcXYOra3B1Da6uwdU1uLoGV9fg6hpcXYOra3B1Da6uwdU1uLoGV9fg6hpcXYOra3B1Da6uwdU1uLoGV9fg6hpcXYOra3B1Da6uwdU1uLoGV9fg6hpcXYOra3B1Da6uwdU1uLoGV9fg6hpcXYOra3B1Da6uwdU1uLoGV9fg6hpcXYOra3B1Da6uwdU1uLoGV9fg6hpcXYOrazC6BqNrMLoGo2swugajazC6BqNrMLoGo2swugajazC6BqNrMLoGo2swugajazC6BqNrMLoGo2swugajazC6BqNrMLoGo2swugajazC6BqNrMLoGo2swugajazC6BqNrMLoGo2swugajazC6BqNrMLoGo2swugajazC6BqNrMLoGo2swugajazC6BqNrMLoGo2swugajazC6BqNrMLoGo2swugajazC6BqNrMLoGo2swugajazC6BqNrMLoGo2swugajazC6BqNrMLoGo2swugajazC6BqNrMLoGo2swugajazC6BqNrMLoGo2swugajazC6BqNrMLoGo2swuwazazC7BrNrMLsGs2swuwazazC7BrNrMLsGs2swuwazazC7BrNrMLsGs2swuwazazC7BrNrMLsGs2swuwazazC7BrNrMLsGs2swuwazazC7BrNrMLsGs2swuwazazC7BrNrMLsGs2swuwazazC7BrNrMLsGs2swuwazazC7BrNrMLsGs2swuwazazC7BrNrMLsGs2swuwazazC7BrNrMLsGs2swuwazazC7BrNrMLsGs2swuwazazC7BrNrMLsGs2swuwazazC7BrNrMLsGs2swuwazazC7BrNrMLsGs2swuwazazC7BrNrMLsGs2swuwazazC7BrNrcHcN7q7B3TW4uwZ31+DuGtxdg7trcHcN7q7B3TW4uwZ31+DuGtxdg7trcHcN7q7B3TW4uwZ31+DuGtxdg7trcHcN7q7B3TW4uwZ31+DuGtxdg7trcHcN7q7B3TW4uwZ31+DuGtxdg7trcHcN7q7B3TW4uwZ31+DuGtxdg7trcHcN7q7B3TW4uwZ31+DuGtxdg7trcHcN7q7B3TW4uwZ31+DuGtxdg7trcHcN7q7B3TW4uwZ31+DuGtxdg7trcHcN7q7B3TW4uwZ31+DuGtxdg7trcHcN7q7B3TW4uwZ31+DuGtxdg7trcHcN7q8G4+8e0f5qEDAa/kaO+YE3zIbVEA3ZsBsO4Hw1CBgN1uANs2E1REM27IYeefTIo0cePfLokUePPHrk0SOPHnn0yKNHth7ZemTrka1Hth7ZemTrka1Hth7ZemTvkb1H9h7Ze2Tvkb1H9h7Ze2Tvkb1Hnj3y7JFnjzx75Nkjzx559sizR5498uyRV4+8euTVI68eefXIq0dePfLqkVePvHrk6JGjR44eOXrk6JGjR44eOXrk6JGjR84eOXvk7JGzR84eOXvk7JGzR84eOXvk3SPvHnn3yLtH3j3y7pF3j7x75N0j7x759MinR+4aPF2Dp2vwdA2ersHTNXi6Bk/X4N+D9d+j8cge+aP5aD2KR/loP3oe43mM5zGex3ge43mM5zGex3ge43mM52HPw56HPQ97HvY87HnY87DnYc/Dnoc/D38e/jz8efjz8Ofhz8Ofhz8Pfx7zecznMZ/HfB7zecznMZ/HfB7zecznsZ7Heh7reaznsZ7Heh7reaznsZ7Heh7xPOJ5xPOI5xHPI55HPI94HvE84nnk88jnkc8jn0c+j3we+TzyeeTzyOexn8d+Hvt57Oexn8d+Hvt57Oexn8d+Hud5nOdxnsd5Hud5nOdxnsd5Hud5vDofr87Hq/Px6ny8Oh+vzser8/HqfLw6H6/Ox6vz8ep8vDofr87Hq/Px6ny8Oh+vzser8/HqfLw6H6/Ox6vz8ep8vDofr87Hq/Px6ny8Oh+vzser8/HqfLw6H6/Ox6vz8ep8vDofr87Hq/Px6ny8Oh+vzser8/HqfLw6H6/Ox6vz8ep8vDofr87Hq/Px6ny8Oh+vzser8/HqfLw6H6/Ox6vz8ep8vDofr87Hq/Px6ny8Oh+vzser8/HqfLw6H6/Ox6vz8ep8vDofr87Hq/Px6ny8Oh+vzser8/HqfLw6H6/Ox6vz8ep8vDofr87Hq/Px6ny8Oh+vzser8/HqfLw6H6/Ox6vz8ep8vDofr87Hq/Px6ny8OrdX5/bq3F6d26tze3Vur87t1bm9OrdX5/bq3F6d26tze3Vur87t1bm9OrdX5/bq3F6d26tze3Vur87t1bm9OrdX5/bq3F6d26tze3Vur87t1bm9OrdX5/bq3F6d26tze3Vur87t1bm9OrdX5/bq3F6d26tze3Vur87t1bm9OrdX5/bq3F6d26tze3Vur87t1bm9OrdX5/bq3F6d26tze3Vur87t1bm9OrdX5/bq3F6d26tze3Vur87t1bm9OrdX5/bq3F6d26tze3Vur87t1bm9OrdX5/bq3F6d26tze3Vur87t1bm9OrdX5/bq3F6d26tze3Vur87t1bm9OrdX5/bq3F6d26tzf3Xur8791bm/OvdX5/7q3F+d+6tzf3Xur8791bm/OvdX5/7q3F+d+6tzf3Xur8791bm/OvdX5/7q3F+d+6tzf3Xur8791bm/OvdX5/7q3F+d+6tzf3Xur8791bm/OvdX5/7q3F+d+6tzf3Xur8791bm/OvdX5/7q3F+d+6tzf3Xur8791bm/OvdX5/7q3F+d+6tzf3Xur8791bm/OvdX5/7q3F+d+6tzf3Xur8791bm/OvdX5/7q3F+d+6tzf3Xur8791bm/OvdX5/7q3F+d+6tzf3Xur8791bm/OvdX5/7q3F+d+6tzf3Xur8791bm/OvdX5/7q3F+d+6tzf3Xur8791bm/Op+vzuer8/nqfL46n6/Oq3sp0PQdj/LRn0f+ik7TV+eXxiN75I/mo/UoHuWj5zGehz0Pex72POx52POw52HPw56HPQ97Hv48/Hn48/Dn4c/Dn4c/D38e/jz8ecznMZ/HfB7zecznMZ/HfB7zecznMZ/Heh7reaznsZ7Heh7reaznsZ7Heh7recTziOcRzyOeRzyPeB7xPOJ5xPOI55HPI59HPo98Hvk88nnk88jnkc8jn8d+Hvt57Oexn8d+Hvt57Oexn8d+Hvt5nOdxnsd5Hud5nOdxnsd5Hud5nOdx2qOaoy6NR/bIH81H61E8ykf70fN4db5ena9X59UplVY0H61H8Sgf7UenqeocNB7Zo+dhz8Oehz0Pex72POx5+PPw5+HPw5+HPw9/Hv48/Hn48/DnMZ/HfB7zecznMZ/HfB7zecznMZ/HfB7reaznsZ7Heh7reaznsZ7Heh7reaznEc8jnkc8j3ge8TziecTziOcRzyOeRz6PfB75PPJ55PPI55HPI59HPo98Hvt57Oexn8d+Hvt57Oexn8d+Hvt57Odxnsd5Hud5nOdxnsd5Hud5nOdxnsdpj2rAujQe2SN/NB+tR/EoH+1Hz2M8j/E8xvN4dR6vzuPVebw6j1fn8eo8Xp3Hq/N4dR6vzuPVebw6j1fn8eo8Xp3Hq/N4dR6vzuPVebw6j1fn8eo8Xp3Hq/N4dR6vzuPVebw6r06tXEX2yB/NR+tRPMpH+9FpqjoHPY/1PNbzWM9jPY/1PNbzWM9jPY94HvE84nnE84jnEc+j/ppuFOWj/eg01V/VgcYje+SP5qP16Hl8db5rxb86v3Savjq/NB7ZI380H61H8eh57Oexn8d5Hl+d71lkj/zRfLQexaN8tB+dS9XkdWk8skf+aD5aj+JRPtqPnsd4HuN5jOcxnsd4HuN5jOcxnsd4HuN52POw52HPw56HPQ97HvVXrqsoH+1Hn8f3N5PVAnZpPPo88Ceb/mg++vM4oyge5aM/j5NFp+mr80t/Hgd/BGqP/NH8/uzzV7iIQUziJp6HX7U3DqIRnUi3RbdFt1VudVRrE8/DKLda7hhEIzpxEhcxiEncxPMw6ZZ0S7pludX+5iQuYhCTuInnYf3B7cVBNCLdNt023TbdNt023TbdDt0O3Q7dDt0O3Q7dDt0O3Q7dznOrBrTGQTSiEydxEYOYxE2k26DboNug26DboNug26DboNug26Cb0c3oZnQzuhndjG5GN6Ob0c3o5nRzujndnG5ON6eb083p5nRzuk26TbpNuk26TbpNuk26TbpNuk26Lbotui26Lbotui26Lbotui26LboF3YJuQbegW9At6BZ0C7oF3YJuSTdkyS40ohMncRGDmMRNPA+RJUC6bbptum26bbptum26bbptuh26Hboduh26Hboduh26Hbodup3ndn4/4iAa0YmTuIhBTOIm0m3QbdBt0G3QbdBt0G3QbdBt0G3QzehmdDO6Gd2MbkY3o5vRzehmdHO6Od2cbk43p5vTzenmdHO6Od0m3SbdJt0m3SbdJt0m3SbdJt0m3RbdFt0W3RbdFt0W3RbdFt0W3Rbdgm5Bt6Bb0C3oFnQLugXdgm5Bt6Qbs+QwSw6z5DBLDrPkMEsOs+QwSw6z5DBLDrPkMEsOs+QwSw6z5DBLDrPkMEsOs+QwSw6z5DBLDrPkMEsOs+QwSw6z5DBLzssS+70ssd/LEvu9LLHfyxL7vSyx38sS+70ssd/LEvu9LLHfj26DboNug26DboNug26DboNug26DbkY3o5vRzehmdDO6Gd2MbkY3o5vTzenmdHO6Od2cbk43p1tlycAbXM7DypKLg2hEJ07iIgYxiXSbdFt0qywZVmhEJ07iIgYxiZt4HlaWXKRb0C3oFnQLugXdgm5Bt6Bb0i3plnRLuiXdkm5Jt6Rb0i3ptum26bbptum26bbptum26bbptul26Hboduh26Hboduh26Hboduh2nlv1HDYOohGdOImLGMQkbiLdKkvGLBxEI5ZbFk7iIgYxiZt4HlaWXBxEI9LN6GZ0M7oZ3YxuRjenm9PN6eZ0c7o53ZxuTjenm9Nt0m3SbdJt0m3SbdJt0m3SbdJt0m3RbdFt0W3RbdFt0W3RbdFt0W3RLegWdAu6Bd2CbkG3oFvQLegWdEu6Jd2Sbkm3pFvSLemWdEu6Jd023TbdNt023TbdNt023TbdNt023Q7dDt0O3Q7dDt0O3Q7dDt0O3c5zs9+POIhGdOIkLmIQk7iJdBt0G3QbdGOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWZJdWKO75WmVq2YFytLLg6iEZ04iYsYxCTSbdPt0K2yxEahEZ04iYsYxCRu4mms/szGQTSiEydxEYOYxE2k26DboNug26DboNug26DboNug26Cb0c3oZnQzuhndjG5GN6Ob0c3o5nRzujndnG5ON6eb083p5nRzuk26TbpNuk26TbpNuk26TbpNuk26Lbotui26Lbotui26Lbotui26LboF3YJuQbegW9At6FZZYl6YxE0st/iwsuTiIBrRiZO4iEFM4ibSbdNt023TbdNt023TbdNt023TbdPt0O3Q7dDt0O3Q7dDt0O3Q7dDtPLf1+xEH0YhOnMRFDGISN5Fug26DboNug26DboNug26DboNug25GN6Ob0c3oZnQzuhndjG5GN6Ob083p5nRzujndnG5ON6eb083pNuk26TbpNuk26TbpNuk26TbpNum26Lbotui26Lbotui26Lbotui26BZ0C7oF3YJuQbegW9At6BZ0Y5YsZslilixmyWKWLGbJYpYsZslilixmyWKWLGbJYpYsZslilixmyWKWLGbJYpYsZslilixmyWKWLGbJYpYsZslilixmyWKWLGbJYpYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJkl6Hu1U+jESVzEICZxE89DZAlwEOmWdEu6VZbUD4Wg7/ViEjfxPMQPzQAH0YhOnES6bbptum26bboduh26HbodulWWuBUuYhCTuImnEX2vFwfRiE6cxEUMYhI3kW6DboNug26DboNug26DboNug26DbkY3o5vRzehmdDO6Gd2MbkY3o5vTzenmdHO6Od2cbk43p5vTzek26TbpNuk26TbpNuk26TbpNuk26bbotui26Lbotui26Lbotui26LboFnQLugXdgm5Bt6Bb0C3oFnQLuiXdkm5Jt6Rb0i3plnRLuiXdkm6bbptum26bbptum26bbptum26bboduh26HboduzJLNLNnMks0s2cySzSw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsOcySwyxB36vPQidO4iIGMYmbeB4iS4CDSLdNt023TbdNt023TbdNt0O3Q7dDt0O3Q7dDt0O3Q7dDt9Nujr7Xi4NoRCdO4iIGMYmbSLdBt0G3QbdBt0G3QbdBt0G3QbdBN6Ob0c3oZnQzuhndjG5GN6Ob0c3p5nRzuiFLonASF7HcdmESN/E8RJYAB9GITpzERaTbpNuk26Tbotui26Lbotui26Lbotui26LbolvQLegWdAu6Bd2CbkG3oFvQLeiWdEu6Jd2Sbkm3pFvSLemWdEu6bbptum26bbptum26bbptum26bboduh26Hboduh26Hboduh26Hbqd54a+14uDaEQnTuIiBjGJm0i3QbdBt0G3QbdBt0G3QbdBt0G3QTejm9HN6GZ0M7oZ3YxuRjejm9HN6eZ0c7o53ZxuTjdmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJM0ucWeLMEmeWOLMEfa/1Y8Doe72YxM9teuF5WFlycRCN6MRJXMQgJpFug27IkiwcRCM6cRIXMYhJ3MTz0OnmdHO6Od2cbk43p5vTzenmdJt0m3SbdJt0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0W3QLugXdgm5Bt6Bb0C3oFnQLugXdkm5Jt6RbZcmywklcxM9t1SlXWXJxE+uc/L7oou/14iAa0YmTuIhBTOIm0u3Q7dDt0O3Q7dDt0O3Q7dDt0O08N/S9XhxEIzpxEhcxiEncRLoNug26DboNug26DboNug26DboNuhndjG5GN6Ob0c3oZnQzuhndjG5ON6eb083p5nRzujndnG5ON6fbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26LbotuiW9At6BZ0C7oF3YJuQbegW9At6IYswS/HD6IRnTiJixjEJG7iebjptum26bbptum26bbptum26bbpduh26Hboduh26Hboduh26Hbodp4b+l4vDqIRnTiJixjEJG4i3QbdBt0G3QbdBt0G3QbdBt0G3QbdjG5GN6Ob0c3oZnQzuhndjG5GN6eb083p5nRzujndnG5ON6eb023SbdJt0m3SbdJt0m3SbdJt0m3SbdFt0W3RbdFt0W3RbdFt0W3RbdEt6FZZsnahEZ34uQX+20UM4ucWXriJ52FlycVBNKITJ3ERg0i3pFvSbdNt023TbdNt023TbdNt023TbdPt0O3Q7dDt0O3Q7dDt0O3Q7dDtPDf0vV4cRCM6cRIXMYhJ3ES6DboNug26DboNug26DboNug26DboZ3YxuRjejm9HN6GZ0M7oZ3YxuTjenm9PN6eZ0c7o53ZxuTjen26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26LbolvQLegWdAu6Bd2CbkE3ZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYkswR9r9+vhTj6Xi8OohGdOImLGMQkbiLdNt023TbdKksyCidxEcvNCpO4iechsgQ4iEZ04iQuIt0O3Q7dznND3+vFQTSiEydxEYOYxE2k26DboNug26DboNug26DboNug26Cb0c3oZnQzuhndjG5GN6Ob0c3o5nRzujndnG5ON6eb083p5nRzuk26TbpNuk26TbpNuk26TbpNuk26Lbotui26Lbotui26Lbotui26LboF3YJuQbegW9At6BZ0C7oF3YJuSbekW9It6ZZ0S7ol3ZJuSbek26bbptum26bbptumG7NkM0s2s2QzSzazZDNLNrNkM0s2s2QzSzazZDNLNrNkM0sOs+QwSw6z5DBLDrPkMEsOswR9r9sLN/E8rCz5Xuju6Hu9aMTPbZ/CSVzEz+38CpO4iedhZcnFQTSiEydxEelmdDO6Gd0qS04UDqIR/9z+HrEXTuIixoe1Dl+WNG7in5t9r0r06nttHET7sPbiy5LGSfzcRk3ny5LGJG7iebh+xEE0ohMnkW6Lbotui26LbkG3oFvQLegWdAu6Bd2CbkG3oFvSLemWdEu6Jd2Sbkm3pFvSLem26bbptum26bbptum26bbptum26Xboduh26Hboduh26Hboduh26HbabVbfa+MgGtGJk7iIQUziJtJt0G3QbdBt0G3QbdBt0G3QbdBt0M3oZnQzuhndjG5GN6Ob0c3oZnRzujndnG5ON6eb083p5nRzujndJt0m3SbdJt0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0W3YJuQbegW9At6BZ0C7oF3YJuQbekW9It6ZZ0S7ol3ZJuSbekW9Jt023TbdNt023TbdNt023T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",
      "is_unconstrained": true,
      "name": "is_emitter_registered"
    },
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "14067204867181196045": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "9921926525851912681": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [
          {
            "name": "message_ciphertext",
            "type": {
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 17,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec"
            },
            "visibility": "private"
          },
          {
            "name": "message_context",
            "type": {
              "fields": [
                {
                  "name": "tx_hash",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "unique_note_hashes_in_tx",
                  "type": {
                    "fields": [
                      {
                        "name": "storage",
                        "type": {
                          "kind": "array",
                          "length": 64,
                          "type": {
                            "kind": "field"
                          }
                        }
                      },
                      {
                        "name": "len",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "std::collections::bounded_vec::BoundedVec"
                  }
                },
                {
                  "name": "first_nullifier_in_tx",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "recipient",
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::messages::processing::message_context::MessageContext"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "utility"
      ],
      "debug_symbols": "TJ3LsjS7bpzf5Yw9aIIEQOpVPHD4qlCEQorwZaSX9yokwcyJ95fW+ZmoYiG7uhrd6z/+8T/+53/7f//8X/7l3/7Xv/+ff/zTf/6Pf/y3//0v//qv//LP/+Vf//2//9f/+y///m9//7//8Y/f9//sv/93/qd/7PGPf4q//9g//mn9/WfiPwv/8X/80/77T+A/if9s/OfUf84P/xn4j+E/E/9Z+A9WOVjlYJWDVQ5WGb/f/e+4/7X733n/u+5//f437n/z/nff/971xl1v3PXGXW/c9cZdb9z1xl1v3PXGXW/c9eyuZ3c9u+vZXc/uenbXs7ue3fXsrmd3vXnXm3e9edebd71515t3vXnXm3e9edebd71111t3vXXXW3e9dddbd71111t3vXXXW3c9v+v5Xc/ven7X87ue3/X8rud3Pb/r+V0v7npx14u/9cbvg9mwGrzhb80xP8iG3XAu5N+6Iz74W9i+f5XWMBtWgzdEw9/Ktj7YDefC1x6Ab2X/wBpmw1fzdzhfowCi4W/lOT7YDefC1zKA0WANs2E1eEM09MqnVz53Zfu6aM4PRoM1zIbV4A3RkA274VwYvfLolUevPHrl0SuPXnn0yqNXHr3y6JWtV7Ze2Xpl65WtV7Ze+euv6R9kw244F74eA4wGa5gNq8EbeuXZK89eefbKq1devfLqlVevvHrl1SuvXnn1yqtXXr2y98reK3uv7L2y98reK3uv7L2y98reK0evHL1y9MrRK0evHL1y9MrRK0evHL1y9srZK2evnL1y9srZK2evnL1y9srZK+9eeffKu1fevfLulXevvHvl3SvvXnn3yqdXPr1y9eD+YDasBm+IhmzYDQcwqwcLRoM1zIbV8LfyGh9EQzb8rbzig3Ph60HAaLCG2bAavCEasqFXHr2y9cp2E2maNcyG1eAN0ZANu+Em0py/hl559sqzV/56cJ0PvCEasmE3nAtfDwJGgzXMhl559cqrV1698teD/vvgXPh6EDAarGE2rAZviIZs6JW9V45e+etBzw+sYTasBm+IhmzYDefC14OAXjl75eyVs1fOXjl75eyVs1fOXnn3yrtX3r3y7pV3r7x75d0r715598q7Vz698umVT698euXTK59e+fTKp1c+vfK5K6/fr2E0WMNsWA3eEA3ZsBt65dErj1559MqjVx698uiVR688euXRK49e2Xpl65WtV7Ze2Xpl65WtV7Ze2Xpl65Vnrzx75dkrz1559sqzV5698uyVZ688e+XVK69eefXKq1devfLqlVevvHrl1SuvXtl7Ze+VvVf2Xtl7Ze+VvVf2Xtl7Ze+Vo1fuHlzdg6t7cHUPru7B1T24ugdX9+DqHlzdg6t7cHUPru7B1T24ugdX9+DqHlzdg6t7cHUPru7B1T24ugdX9+DqHlzdg6t7cHUPru7B1T24ugdX9+DqHlzdg6t7cHUPru7B1T24uge9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwez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qmEjr3dUNWzk9Taqho0ag/itUG8qatio8TysPr44iLVuHVD1Zr3zqQEir3dUNUB0sXrz4iAacRIX0YlBLLc64urNi+dh9Wa93akBokYjTuLnVu9maoCoMYifW72FqQGixvOw+rje7tQAUaMRJ3ERnVhudVKrjy9uYrnVqa4+vjiIRnRirVDbEudhdWy9YaqhoEYjfvV6nZ3q44tODGISN/E8rD6+OIhGpNum26bbptum26bbptuh26Hboduh26Hboduh26HboVv18fd20msoqHEQy20WTuIilpsXBrHcduEmnofV3RcHsdxO4SR+bt/7Qq+hII+qrHr+e2PjNRTUuImfW6wPq+cvDuLn9t3bew0FNS6iE4OYDysJvsfOXoM+HnUU1fNRpVfPXwxiEr96sw6oeh5YPX9xEI34uWUdZvV81lmvns8qp3o+y6J6HljdvetMVh/vWqw6dtdi1bEXN/GrbNd2V8deHEQjTuIiOrHc6vTVK+/F/bBaGpVVS180YlnUqa6WvujEz+Lgf5vETfwO6FQ51dIXP7dTR1wtfXESP7dT10619MUgJnETz8Nq6YuDaMRJpNuh26Hboduh23luNZvTOIhGnMRFdGIQk1huXngeVktfLLcsNOIkltsudGIQk1hup/DPLb43Cl6zOfG9O/CazWk04vxwFi6iE4OYxE08D+ePOIhGpNuk26TbLLdRmMRNPA/XjziIRpzEcquzvpwYxHKLwk08D/1HLLfaITfiJAaxVqht+UIhRm3LFwqNRpzEb4VRO/S9jMeos5M/4iAacRIX8TviUYeZQUziJp6H+0ccRCOWW53fvYhODGK51enbm1hudf2eH3EQPzerU/L1fOMiOjGI2VjTMvHdunvNxcT3YYjXXEx89+teczGNQUziV+93F+81F3Nx/IiDaMTPbVYNXx83OjGISdzEz+278fb6PbjGQTRiuZVx9fFFJ5ZbFn5uqyyqjy9+bqtOVPXxxc9t1TmrPr44iYvoxCAmcRPPw+rji3RbdFt0W3RbdFt0W3RbdFt0c7o53ZxuTjenm9PN6eZ0c7o53YJuQbegW9At6BZ0C7oF3YJuQbekW9It6Vb5sOqqrny46MQglltdO5UPF8/DyoeLg2jESVxEJwaRbptum26Hboduh26Hboduh26n1v1ypwaa/j65KDRirbALF9GJQUziJp6HlQTf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",
      "is_unconstrained": true,
      "name": "process_message"
    },
    {
      "abi": {
        "error_types": {
          "11594563071547591162": {
            "error_kind": "string",
            "string": "Function _validate_emitter_and_update_value can only be called internally"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14415304921900233953": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15546539856497705002": {
            "error_kind": "string",
            "string": "u16 to u8 conversion failed"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16810041750452690220": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 27
          },
          "18173155084464344029": {
            "error_kind": "string",
            "string": "Emitter not registered"
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "6788092787179896647": {
            "error_kind": "string",
            "string": "Caller is not owner"
          },
          "8228371833434187583": {
            "error_kind": "string",
            "string": "Trying to read from uninitialized PublicImmutable"
          },
          "9967937311635654895": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          }
        },
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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HwAqDw4PLQoOEA4qDxARJAIAEQAADjUtDgMQACIQAhAjAAAOGi0LDQ4AIg4CDi0ODg0tCw0OACIOAg4tDg4NLQsNDgAiDgIOLQ4ODS0LDQ4AIg4CDi0ODg0tCw0OACIOAg4tDg4NLQsNDgAiDgIOLQ4ODS0IAQ4AAAECAScCDwMIGioKDxAcChARAhwKEQ8DHAoPEAIcCgoSAhwKEhEDHAoREgIoAgATAwEABCoPExQGKhQTFgoqFg8VJAIAFQAADtclAAAnCgAqFBEPDioUDxMkAgATAAAO7iUAACO1CioPChEkAgARAAAPACUAACccKAIACgQBACcCEQEALQgBDycCEwQRAAgBEwEnAw8EAQAiDwITJwIUBBBDA6oACQAKABQAEQATLQgBCScCCgQgAAgBCgEnAwkEAQAiCQIKLQoKES0OEBEAIhECES0OEhEAIhECES0OAxEAIhECES0OAxEAIhECES0OAxEAIhECES0OAxEAIhECES0OAxEAIhECES0OAxEAIhECES0OAxEAIhECES0OAxEAIhECES0OAxEAIhECES0OAxEAIhECES0OAxEAIhECES0OAxEAIhECES0OAxEAIhECES0OAxEAIhECES0OAxEAIhECES0OAxEAIhECES0OAxEAIhECES0OAxEAIhECES0OAxEAIhECES0OAxEAIhECES0OAxEAIhECES0OAxEAIhECES0OAxEAIhECES0OAxEAIhECES0OAxEAIhECES0OAxEAIhECES0OAxEAIhECES0OAxEAIhECES0OAxEtCAEKJwIQBAkACAEQAScDCgQBACIKAhAtChARLQ4JEQAiEQIRLQ4NEQAiEQIRLQ4NEQAiEQIRLQ4NEQAiEQIRLQ4NEQAiEQIRLQ4NEQAiEQIRLQ4NEQAiEQIRLQ4NES0OCg4nAgkEECcCCgQfLQhHBSMAABDaDCoFCQ0kAgANAAAdUiMAABDsLQsOCS0IAQ0AAAECAS0IAQ4AAAECAS0IAQ8nAhAE/gAIARABJwMPBAEAIg8CECcCEQT9ACoREBEtChASDioREhMkAgATAAARQy0MSBIAIhICEiMAABEoLQ4PDS0MSg4tCAEPJwIQBPkACAEQAScDDwQBACIPAhAnAhEE+AAqERARLQoQEg4qERITJAIAEwAAEYwtDEgSACISAhIjAAARcS0IARAAAAEC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",
      "custom_attributes": [
        "external",
        "public"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "public_dispatch"
    },
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "14067204867181196045": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15711892660910782274": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16216212843441549037": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "2014890719615096298": {
            "error_kind": "string",
            "string": "Field failed to decompose into specified 40 limbs"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "3378875131383195299": {
            "error_kind": "string",
            "string": "Invalid destination chain ID"
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "4648451262681811962": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "7555607922535724711": {
            "error_kind": "string",
            "string": "Preimage mismatch"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9589626482238399944": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "9921926525851912681": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "anchor_block_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "sponge_blob_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "vaa",
            "type": {
              "kind": "array",
              "length": 2000,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "length",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "note_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 32,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "log",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "fields",
                                          "type": {
                                            "kind": "array",
                                            "length": 18,
                                            "type": {
                                              "kind": "field"
                                            }
                                          }
                                        },
                                        {
                                          "name": "length",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::log::Log"
                                    }
                                  },
                                  {
                                    "name": "note_hash_counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "anchor_block_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "sponge_blob_hash",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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Q+hyCl0uocstdHmELq/Q5RO6/EJXQOgKCl0hoSssdEWErqjQFRO64kJXQuhKCl0poSstdGWErqzQlRO68kJXQegqCl0loassdFWErqrQVRO66kJXQ+hqCl0toastdHWErq7Q1RO6+kLXQOgaCl0joWssdE2ErqnQNRO65kLXQuhaCl0roWstdG2Erq3QtRO69kLXQeg6Cl0noessdF2ErqvQdRO67kLXQ+h6Cl0voestdH2Erq/Q9RO6/kI3QOgGCt0goRssdEOEbqjQDRO64UI3QuhGCt0ooRstdGOEbqzQjRO68UI3QegmCt0koZssdFOEbqrQTRO66UI3Q+hmCt0soZstdHOEbq7QzRO6+UK3QOgWCt0ioVssdEuEbqnQLRO65UK3QuhWCt0qoVstdGuEbq3QrRO69UK3Qeg2Ct0modssdFuEbqvQbRO67UK3Q+h2Ct0uodstdHuEbq/Q7RO6/UJ3QOgOCt0hoTssdEeE7qjQHRO640J3QuhOCt0poTstdGeE7qzQnRO680J3QeguCt0lobssdFeE7qrQXRO660J3Q+huCt0tobstdHeE7q7Q3RO6+0L3QOgeCt0joXssdE+E7qnQPRO650L3QuheCt0roXstdG+E7q3QvRO690L3Qeg+Ct0nofssdF+E7qvQfRO670L3Q+j8BPx/Oy+h8yt0/oTOv9AFELqAQhdI6AILXRChCyp0wYQuuNCFELqQQhdK6EILXRihCyt04YQuvNBFELqIQhdJ6CILXRShiyp00YQuutB5C52P0MUQuphCF0voYgtdHKGLK3TxhC6+0CUQuoRCl0joEgtdEqFLKnTJhC650KUQupRCl0roUgtdGqFLK3TphC690GUQuoxCl0noMgtdFqHLKnTZhC670OUQupxCl0vocgtdHqHLK3T5hC6/0BUQuoJCV0joCgtdEaErKnTFhK640JUQupJCV0roSgtdGaErK3TlhK680FUQuopCV0noKgtdFaGrKnTVhK660NUQuppCV0voagtdHaGrK3T1hK6+0DUQuoZC10joGgtdE6FrKnTNhK650LUQupZC10roWgtdG6FrK3TthK690HUQuo5C10noOgtdF6HrKnTdhK670PUQup5C10voegtdH6HrK3T9hK6/0A0QuoFCN0joBgvdEKEbKnTDhG640I0QupFCN0roRgvdGKEbK3TjhG680E0QuolCN0noJgvdFKGbKnTThG660M0QuplCN0voZgvdHKGbK3TzhG6+0C0QuoVCt0joFgvdEqFbKnTLhG650K0QupVCt0roVgvdGqFbK3TrhG690G0Quo1Ct0noNgvdFqHbKnTbhG670O0Qup1Ct0vodgvdHqHbK3T7hG6/0B0QuoNCd0joDgvdEaE7KnTHhO640J0QupNCd0roTgvdGaE7K3TnhO680F0QuotCd0noLgvdFaG7KnTXhO660N0QuptCd0vobgvdHaG7K3T3hO6+0D0QuodC90joHgvdE6F7KnTPhO650L0QupdC90roXgvdG6F7K3TvhO690H0Quo9C90noPgvdF6H7KnTfhO670P0QOj+B/t/OS+j8Cp0/ofMvdAGELqDQBRK6wEIXROiCCl0woQsudCGELqTQhRK60EIXRujCCl04oQsvdBGELqLQRRK6yEIXReiiCl00oYsudN5C5yN0MYQuptDFErrYQhdH6OIKXTyhiy90CYQuodAlErrEQpdE6JIKXTKhSy50KYQupdClErrUQpdG6NIKXTqhSy90GYQuo9BlErrMQpdF6LIKXTahyy50OYQup9DlErrcQpdH6PIKXT6hyy90BYSuoNAVErrCQldE6IoKXTGhKy50JYSupNCVErrSQldG6MoKXTmhKy90FYSuotBVErrKQldF6KoKXTWhqy50NYSuptDVErraQldH6OoKXT2hqy90DYSuodA1ErrGQtdE6JoKXTOhay50LYSupdC1ErrWQtdG6NoKXTuhay90HYSuo9B1ErrOQtdF6LoKXTeh6y50PYSup9D1ErreQtdH6PoKXT+h6y90A4RuoNANErrBQjdE6IYK3TChGy50I4RupNCNErrRQjdG6MYK3TihGy90E4RuotBNErrJQjdF6KYK3TShmy50M4RuptDNErrZQjdH6OYK3Tyhmy90C4RuodAtErrFQrdE6JYK3TKhWy50K4RupdCtErrVQrdG6NYK3TqhWy90G4Ruo9BtErrNQrdF6LYK3Tah2y50O4Rup9DtErrdQrdH6PYK3T6h2y90B4TuoNAdErrDQndE6I4K3TGhOy50J4TupNCdErrTQndG6M4K3TmhOy90F4TuotBdErrLQndF6K4K3TWhuy50N4TuptDdErrbQndH6O4K3T2huy90D4TuodA9ErrHQvdE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1RlMp7tvnnvB5RxCElISyvX7Z6J7aAXcdXM9d33bQ2gX5x1bA3fdO/Pc9c0/jIvj3wa4635vz13f/MO67Hrofj/3DKMzrE533zz3wsk5vCSCJKLr989E99AWuOvmeu76todILs47tgPuunfmueubf2QXx789cNf93p67vvlHcdn10P1+7hlZZxSd7r557kWVczRJdEkM1++fie6hA3DXzfXc9W0PMV2cd+wI3HXvzHPXN/9YLo5/J+Cu+709d33zj+2y66H7/dwzls7YOt1989yL42ZI4kriuX7/THQPnYG7/+Lq/+HbHuK7OO/YBbjr3pnnrm/+CVwc/67A3bguv/sndNn10P1+7plAZ0Kd7r557iWSc2JJEklS1++fie6hG3DXzfXc9W0PyVycd+wO3HXvzHPXN//kLo5/D+Cu+709d33zT+Gy66H7/dwzuc4UOt1989xLKedUktSSNK7fPxPdQ0/grpvruevbHnxcnHfsBdx178xz1zf/tC6Of2/grvu9PXd980/nsuuh+/3cM63OdDrdffPcSy/nDJKMkkyu3z8T3UMf4K6b67nr2x4yuzjv2Be4696Z565v/llcHP9+wF33e3vu+uaf1WXXQ/f7uWcWnVl1uvvmuZdNztklOSQ5Xb9/JrqH/sBdN9dz17c95HJx3nEAcNe9M89d3/xzuzj+A4G77vf23PXNP4/Lrofu93PP3Drz6HT3zXMvr5zzSfJLCrh+/0x0D4OAu26u565veyjo4rzjYOCue2eeu775F3Jx/IcAd93v7bnrm39hl10P3e/nnoV0Ftbp7pvnXhE5F5UUkxR3/f6Z6B6GAnfdXM9d3/ZQwsV5x2HAXffOPHd98y/p4vgPB+6639tz1zf/Ui67Hrrfzz1L6iyl0903z73Sci4jKSsp5/r9M9E9jADuurmeu77tobyL844jgbvunXnu+vq/ruLi+I8C7rrf23PX1/91FJddD93v554VdFbU6e6b514lOVeWVJFUdf3+megeRgN33VzPXV//RwBcnHccA9x178xz19f/sQAXx38scNf93p67vv6L+112PXS/n3tW11lDp7tvnns15VxLUltSx/X7Z6J7GAfcdXM9d33bQ10X5x3HA3fdO/Pc9c2/novjPwG4635vz13f/Ou77Hrofj/3rKezvs46rn/fayDnhpJGksau3z8T3cNE4K6b67nr2x6auDjvOAm4696Z565v/k1dHP/JwF33e3vu+ubfzGXXQ/f7uWdTnc10uvvmuddczi0kLSWtXL9/JrqHKcBdN9dz17c9tHZx3nEqcNe9M89d3/zbuDj+04C77vf23PXNv63Lrofu93PPNjrb6nT3zXOvnZzbSzpIOrp+/0x0D9OBu26u565ve+jk4rzjDOCue2eeu775d3Zx/GcCd93v7bnrm38Xl10P3e/nnp11dtHp7pvnXlc5d5N0l/Rw/f6Z6B5mAXfdXM9d3/bQ08V5x9nAXffOPHd98+/l4vjPAe6639tz1zf/3i67Hrrfzz176eyt0903z70+cu4r6Sfp7/r9M9E9zAXuurmeu77tYYCL847zgLvunXnu+uY/0MXxnw/cdb+3565v/oNcdj10v597DtQ5SKe7b557g+U8RDJUMsz1+2eie1gA3HVzPXd928NwF+cdFwJ33Tvz3PXNf4SL478IuOt+b89d3/xHuux66H4/9xyhc6ROd98890bJebRkjGSs6/fPRPewGLjr5nru+raHcS7OOy4B7rp35rnrm/94F8d/KXDX/d6eu775T3DZ9dD9fu45XucEne6+ee5NlPMkyWTJFNfvn4nuYRlw18313PVtD1NdnHdcDtx178xz1zf/aS6O/wrgrvu9PXd985/usuuh+/3cc5rO6TrdffPcmyHnmZJZktmu3z8T3cNK4K6b67nr2x7muDjvuAq4696Z565v/nNdHP/VwF33e3vu+uY/z2XXwzmu/5lzdc7T6e6b5958OS+QLJQscv3+mege1gB33VzPXd/2sNjFece1wF33zjx3ffNf4uL4rwPuut/bc9c3/6Uuux663889l+hcqtPdN8+9ZXJeLlkhWen6/TPRPawH7rq5nru+7WGVi/OOG4C77p157vrmv9rF8d8I3HW/t+eub/5rXHY9dL+fe67WuUanu2+ee2vlvE6yXrLB9ftnonvYBNx1cz13fdvDRhfnHTcDd90789z1zX+Ti+O/Bbjrfm/PXd/8N7vseuh+P/fcpHOzTnffPPe2yHmrZJtku+v3z0T3sBW46+Z67vq2hx0uzjtuA+66d+a565v/ThfHfztw1/3enru++e9y2fXQ/X7uuVPnLp3uvnnu7ZbzHsleyT7X75+J7mEHcNfN9dz1bQ/7XZx33Anc3ePyu/8BF8d/F3DX/d6e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",
      "custom_attributes": [
        "external",
        "private"
      ],
      "debug_symbols": "TL3LzjQ7j5x7L2vsQelAiuxb2QNjex+MBhpuwIdRw/fuNxmiIib9PdH/ehXKlBiVlcXK+o9//t//77/8r//6n//1v/3///4//vmX/+s//vkv//1f/+3f/vW//ud/+/f/5//+n//67//t7//7H//8vv8z9j//Ms3n//5P/4xPr/znX8Z/+mf/8M/APxP/LPyz8Y/hH8c/B/8E/sEohlEMoxhGMYxiGMUwimEUwyiGUQyjOEZxjOIYxTGKYxTHKI5RHKM4RnGMcjDKwSgHoxyMcjDKwSgHoxyMcjDKwSiBUQKjBEYJjBIYJTBKYJTAKIFRAqMkRkmMkhglMUpilMQoiVESoyRGSYwyfr/777j/zvvvuv/u+6/df/3+e+6/cf+944073rjjjTveuOONO964442/8db377n/xv038e/8G8+/f8f9d95/1/33b7z8/v3Gqz/whtMQDXlh/Rq+WZ4PZsNq2A3fyPGBN5yGb+TvKGrHf1B7vuBv5Lk/mA2rYTdYgzechmjIC18dAHpk65GtR/7qYX5n5asIgDechmjIC19tAEbDbFgNPbL3yN4je4/sPbL3yKdHPj3y6ZFPj3x65NMjnx759MinRz498ldD81uCr4oAs2E17AZr8IbTEA15IXvk7JGzR84eOXvk7JGzR84eOXvkvCPP369hNMyG1bAbrMEbTkM09MijRx498uiRR488euTRI48eefTIo0cePfLskWePPHvk2SPPHnn2yLNHnj3y7JFnj7x65NUjrx559cirR1498uqRV4+8euTVI+8eeffIu0fePfLukXeP/NXgGh+chmjIC18NAkbDbFgNu8EaemTrka1H/mpw/VXu/GoQMBq+kfOD1bAbrMEbTkM05IWvBgGjoUc+PfLpkc9NpHm84TREw02kGb+G0TAbVsNu6JGjR44e+avBPT/IC18NAkbDbFgNu8EavOE09Mh5R16/X8No+EZeH6yG3WAN3nAaoiEvfDUIGA098uiRR4/81aD9PvCG0xANeeGrQcBomA2rYTf0yLNHnj3y7JFnj7x65NUjrx559cirR1498uqRV4+8euTVI+8eeffIu0fePfLukXePvHvk3SPvHnn3yNYjW49sPbL1yNYjW49sPbL1yNYjW4/sPbL3yN4je4/sPbL3yN4je4/sPbL3yKdHPj3y6ZFPj3x65NMjnx759MinRz49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V+fj1fl4dT5enY9X5+PV+Xh1Pl6dj1fn49X5eHU+Xp2PV+fj1fl4dT5enY9X5+PV+Xh1Pl6dj1fn49X5eHU+Xp2PV+fj1fl4dT5enY9X5+PV+Xh1Pl6dj1fn49X5eHU+Xp2PV+fj1fl4dT5enY9X5+PV+Xh1Pl6dj1fn49X5eHU+Xp2PV+fj1fl4dT5enY9X5+PV+Xh1Pl6dj1fn49X5eHU+Xp2PV+fj1fl4dT5enY9X5+PV+Xh1Pl6dj1fn49X5eHU+Xp2PV+fj1fl4dT5enY9X5+PV+Xh1Pl6dj1fn49X5fHU+X53PV+fz1fl8dT5fnc9X5/PV+Xx1Pl+dz1fn89X5fHU+X53PV+fz1fl8dT5fnc9X5/PV+Xx1Pl+dz1fn89X5fHU+X53PV+fz1fl8dT5fnc9X5/PV+Xx1Pl+dz1fn89X5fHU+X53PV+fz1fl8dT5fnc9X5/PV+Xx1Pl+dz1fn89X5fHU+X53PV+fz1fl8dT5fnc9X5/PV+Xx1Pl+dz1fn89X5fHU+X53PV+fz1fl8dT5fnc9X5/PV+Xx1Pl+dz1fn89X5fHU+X53PV+fz1fl8dT5fnc9X5/PV+Xx1Pl+dz1fn89X5fHU+X53PV+fz1fl8dT5fnc9X5/PV+Xx1Pl+dz1fn89X5fHU+X53PV+fz1fl6db5ena9X5+vV+Xp1vl6dr1fn69X5enW+Xp2vV+fr1fl6db5ena9X5+vV+Xp1vl6dr1fn69X5enW+Xp2vV+fr1fl6db5ena9X5+vV+Xp1vl6dr1fn69X5enW+Xp2vV+fr1fl6db5ena9X5+vV+Xp1vl6dr1fn69X5enW+Xp1XC5JXS+9X55fi0Z+HV+PwV+eXxqP5aD3aj+yRPzqP4tHz8Ofhz8Ofhz8Pfx7+PPx5+PPw5+HP4zyP8zzO8zjP4zyP8zzO8zjP4zyP8zziecTziOcRzyOeRzyPeB7xPOJ5xPPI55HPI59HPo98Hvk88nnk88jnke1RjUuXxqP5aD3aj+yRPzqP4tHzGM9jPI/xPMbzGM9jPI/xPMbzGM9jPI/5PObzmM9jPo/5PObzmM9jPo/5PObzWM9jPY/1PNbzWM9jPY/1PNbzWM9jPY/9PPbz2M9jP4/9PPbz2M9jP4/9PF6d71fn+9X5fnW+X51Xu5NbkT3yR+dRPMqmqnPQeDQfrUfPw5+HPw9/Hv48/Hmc53Gex3ke53mc53Gex3ke53mc53GeRzyPeB7xPOJ5xPOI5xHPI55HPI94Hvk88nnk88jnkc8jn0c+j3we+TyyPao56tJ4NB+tR/uRPfJH51E8eh7jeYznMZ7HeB7jeYznMZ7HeB7jeYznMZ/HfB7zecznMZ/HfB7zecznMZ/HfB7reaznsZ7Heh7reaznsZ7Heh7reaznsZ/Hfh77eeznsZ/Hfh77eeznsZ/Hfh72POx52POw5/Hq3F6d26tze3Vur87t1bm9OrdX5/bq3F6d26tze3Vur87t1bm9OrdX5/bq3F6d26tze3Vur87t1bm9OrdX5/bq3F6d26tze3Ve7VYeRevRfmSP/NF5FI+yqeocNB49j3we+TzyeeTzyOeRzyPboxqwLo1H89F6tB/ZI3/053F2UTzKpq/OL41H89F6tB/ZI3/0PL46P1aUTV+dXxqP5qP1aD+yR/7oPHoe83ms57Gex1fn5xStR/uRPfJH51E8yqavzi+NR89jP4/9PPbz2M9jP4/9PPbzsOdhz8Oehz0Pex72POx52POw52HPw5+HPw9/Hv48/Hn48/Dn8dX5qR321fmlbPrq/GTReDQf/XnEKNqP7NGfR9Ru+ur8Ujz688jfR1+dXxqP/jyyRvnq/NJ+9OeRq8gfnUfxKJu+Or80Hs1H69F+9DzyeeTz+Oo86zi+Oi+qJq9Ln8cpmo/Wo/3IHvmj8ygeZdNX55eex3ge43l8dZ5RZI/80XkUj7Lpq/NL49F8tB49j/k85vOYz2M+j/k81vNYz2M9j/U81vNYz2M9j/U81vNYz2M/j/089vPYz2M/j/089vPYz2M/j/087HnY87DnYc/Dnoc9D3se9jzsedjz8Ofhz8Ofhz8Pfx7+PPx5+PPw5+HP4zyP8zzO8zjP4zyP8zzO8zjP4zyP8zziecTziOcRzyOeRzyPeB7xPOJ5xPPI55HPI59HPo98Hvk88nnk88jnke1RjWSXxqP5aD3aj+yRPzqP4tHzGM9jPI/6jvtvFC7iJhrRiYcYxHz41XvjINJt0m3SbdJt0m3SbdJt0m3RbdFt0W3RbdFt0W3RbdFt0W3RbdNt023TbdNt023TbdNt023TbdPN6GZ0M7oZ3YxuRjejm9HN6GZ0c7o53ZxuTjenm9PN6eZ0c7o53Q7dDt0O3Q7dDt0O3Q7dDt0O3Q7dgm5Bt6Bb0C3oFnQLugXdgm5Bt6Rb0i3plnRLuiXdkm5Jt6RbPrdqgmscxElcxE00ohMPMYh0G3QbdGOWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJYks+a7GE1kCHMRJXMRNNKITDzGIdEu6Jd2QJVa4iJtoRCceYhDz4vwhS4CDOImLuIlGdOIhBpFug26DboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptum25GN2TJKZzERfzcxq/QiE48xCDmw8qSi4M4iYtIN6eb083p5nRzuh26Hboduh26Hboduh26Hboduh26Bd2CbkG3oFvQLegWdAu6Bd2Cbkm3pFvSLemWdEu6Jd2Sbkm3fG54RtfFQZzERdxEIzrxEINIt0G3QbdBt0G3QbdBt0G3QbdBt0G3SbdJt0m3SbdJt0m3SbdJt0m3SbdFt0W3RbdFt0W3RbdFt0W3RbdFt023TbdNt023TbdNt023TbdNt003o5vRzehmdGOWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJYpYsZslilixmyWKWLGbJYpYsZslilixmyWKWLGbJYpYsZslilixmyWKWLGbJYpYsZMn6EFkCHMRJXMRNNKITDzGIdFt0W3RDluzCRdxEIzrxEIOYD5ElwEGk26bbptum26bbptum26ab0c3oZnQzuhndjG5GN6Ob0c3o5nRzujndnG5ON6eb083p5nRzuh26Hboduh26Hboduh26Hboduh26Bd2CbkG3oFvQLegWdAu6Bd2Cbkm3pFvSLemWdEu6Jd2Sbkm3fG779yMO4iQu4iYa0Ynl5oVBzIfIkiwcxElcxE00ohMPMYj5cNJt0m3SbdJt0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0W3TbdNt023TbdNt023TbdNt023TzehmdDO6Gd2MbkY3o5vRzehmdHO6Od2cbk43p5vTzenmdHO6Od0O3Q7dDt0O3Q7dDt0O3Q7dDt0O3YJuQbegW9At6BZ0C7oF3YJuQbekW9It6ZZ0S7ol3ZJuSbekWz43+/2IgziJi7iJRnTiIQaRbswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZslhlhxmyWGWVCvq32cfhZtoRCceYhDzYWXJxUGcRLoNug26VZZ8P7cxqzG1MYj5sLLk4iBO4iJuohHpNuk26Tbptui26Lbotui26FZZMq3QiYcYxHxYWXJxECdxETeRbptum26bbptuRjejm9HN6GZ0M7oZ3YxuRjejm9PN6eZ0c7o53ZxuTjenm9PN6Xboduh26Hboduh26Hboduh26HboFnQLugXdgm5Bt6Bb0C3oFnQLuiXdkm5Jt6Rb0i3plnRLuiXd8rlVr2vjIE7iIm6iEZ14iEGk26DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26IbsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWYK+13kKN9GITjzEIOZDZAlwECeRbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptum25GN6Ob0c3oZnQzuhndjG5GN6Ob083p5nRzujndnG5ON6eb083pduh26HboduiGLMlCIzrxc6uf90Lf68V8WFlycRAncRE30YhOpFvQLeiWdEu6Jd2Sbkm3pFvSLemWdMt2W+h7vTiIk7iIm2hEJx5iEOk26DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26Tbptui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26WZ0M7oZ3YxuRjejm9HN6GZ0M7o53ZxuTjenm9PN6eZ0c7o53Zxuh26Hboduh26Hboduh26Hboduh25Bt6Bb0C3oFnQLugXdgm5Bt6Bb0i3plnRLuiXdkm5Jt6Rb0o1ZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1mCvtfvJ3UX+l4vBrHc/ENkCXAQJ3ERN9GITjzEINLN6YYs+RVO4iJuohGdeIhBzIfIEiDdDt0O3Q7dDt0O3Q7dDt0O3YJuQbegW9At6BZ0C7oF3YJuQbekW9It6ZZ0S7ol3ZJuSbekWz439L1eHMRJXMRNNKITDzGIdBt0G3QbdBt0qyzZVmhEJ35u2wuDmA+RJadwECdxETfRiE48xCDmw0W3RbdFt0W3RbdFt0W3RbdFt0W3TbdNt023TbdNt023TbdNt023TTejm9HN6GZ0M7oZ3YxuRjejm9HN6eZ0c7o53ZxuTjenm9PN6eZ0O3Q7dDt0O3Q7dDt0O3Q7dDt0O3QLugXdgm5Bt6Bb0C3oFnQLugXdkm5Jt6Rb0i3plnRLuiXdkm753ND3enEQJ3ERN9GITjzEINJt0A33XnfhJC7iJhrRiYcYxHyIe69Auk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptum26Gd2MbkY3o5vRzehmdDO6Gd2Mbk43p5vTzenmdHO6Od2cbk43p9uh26Hboduh26Hboduh26HboduhW9At6BZ0C7oF3YJuQbegW9At6JZ0S7ol3ZJuSbekW9It6ZZ0y+eGvteLg/i52ShcxE383Az/rRMP8XMzL8yHlSUXB3ESF3ETjejEQ6TboNuk26TbpNuk26TbpNuk26TbpNuk26Lbotui26Lbotui26Lbotui26Lbptum26bbptum26bbptum26bbppvRzehmdDO6Gd2MbkY3o5vRzejmdHO6Od2cbk43p5vTzenmdHO6Hboduh26Hboduh26Hboduh26HboF3YJuQbegW9At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KXil4JWCVwpeKXil4JWCVwpeKXil4JWCVwpeKXil4JWCVwpeKXil4JWCVwpeKXil4JWCVwpeKXil4JWCVwpeKXil4JWCVwpeKXil4JWCVwpeKXil4JWCVwpeKXil4JWCVwpeKXil4JWCVwpeKXil4JWCVwpeKXil4JWCVwpeKXil4JWCVwpeKXil4JWCVwpeKXil4JWCVwpeKXil4JWCVwpeKXil4JWCVwpeKXil4JWCVwpeKXil4JWCVwpeKXil4JWCVwpeKXil4JWCVwpeKXil4JWCVwW8KuBVAa8KeFXAqwJeFfCqgFcFvCrgVQGvCnhVwKsCXhXwqoBXBbwq4FUBrwp4VcCrAl4V8KqAVwW8KuBVAa8KeFXAqwJeFfCqgFcFvCrgVQGvCnhVwKsCXhXwqoBXBbwq4FUBrwp4VcCrAl4V8KqAVwW8KuBVAa8KeFXAqwJeFfCqgFcFvCrgVQGvCnhVwKsCXhXwqoBXBbwq4FUBrwp4VcCrAl4V8KqAVwW8KuBVAa8KeFXAqwJeFfCqgFcFvCrgVQGvCnhVwKsCXhXwqoBXBbwq4FUBrwp4VcCrAl4V8KqAVwW8KuBVAa8KeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eFXBqwpeVfCqglcVvKrgVQWvKnhVwasKXlXwqoJXFbyq4FUFryp4VcGrCl5V8KqCVxW8quBVBa8qeFXBqwpeVfCqglcVvKrgVQWvKnhVwasKXlXwqoJXFbyq4FUFryp4VcGrCl5V8KqCVxW8quBVBa8qeFXBqwpeVfCqglcVvKrgVQWvKnhVwasKXlXwqoJXFbyq4FUFryp4VcGrCl5V8KqCVxW8quBVBa8qeFXBqwpeVfCqglcVvKrgVQWvKnhVwasKXlXwqoJXFbyq4FUFryp4VcGrCl5V8KqCVxW8quBVBa8qeFXBqwpeVfCqglcNvGrgVQOvGnjVwKsGXjXwqoFXDbxq4FUDrxp41cCrBl418KqBVw28auBVA68aeNXAqwZeNfCqgVcNvGrgVQOvGnjVwKsGXjXwqoFXDbxq4FUDrxp41cCrBl418KqBVw28auBVA68aeNXAqwZeNfCqgVcNvGrgVQOvGnjVwKsGXjXwqoFXDbxq4FUDrxp41cCrBl418KqBVw28auBVA68aeNXAqwZeNfCqgVcNvGrgVQOvGnjVwKsGXjXwqoFXDbxq4FUDrxp41cCrBl418KqBVw28auBVA68aeNXAqwZeNfCqgVcNvGrgVQOv2smrxwtHKCeUM8qCsqJcUDaUHeWKMupNqDeh3oR6E+pNqDeh3oR6E+pNqDeh3ox6M+rNqDej3ox6M+rNqDej3ox6M+oV1CuoV1CvoF5BvYJ6BfUK6hXUK6hXUa+iXkW9inoV9SrqVdSrqFdRr6LegnoL6i2ot6DegnoL6i2ot6DegnoL6jXUa6jXUK+hXkO9hnoN9RrqNdRrqNdRr6NeR72Oeh31Oup11Ouo11Gvo96Keivqrai3ot6Keivqrai3ot6Keivqbai3od6Gehvqbai3od6GehvqbagXvILfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv30vo17wCn67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDbBX67wG8X+O0Cv13gtwv8doHfLvDb92Em6gWv4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaB3y7w2wV+u8BvF/jtAr9d4LcL/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2/cy6gWv4Lcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF367w2xV+u8JvV/jtCr9d4bcr/HaF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VQGvCnhVwKsCXhXwqoBXBbwq4FUBrwp4VcCrAl4V8KqAVwW8KuBVAa8KeFXAqwJeFfCqgFcFvCrgVQGvCnhVwKsCXhXwqoBXBbwq4FUBrwp4VcCrAl4V8KqAVwW8KuBVAa8MvDLwysArA68MvDLwysArA68MvDLwysArA68MvDLwysArA68MvDLwysArA68MvDLwysArA68MvDLwysArA68MvDLwysArA68MvDLwysArA68MvDLwysArA68MvDLwysArA68MvDLwysArA68MvDLwysArA68MvDLwysArA68MvDLwysArA68MvDLwysArA68MvDLwysArA68MvDLwysArA68MvDLwysArA68MvDLwysArA68MvDLwysArA68MvDLwysArA68MvDLwysArA68MvDLwysArA68MvDLwysArA68cvHLwysErB68cvHLwysErB68cvHLwysErB68cvHLwysErB68cvHLwysErB68cvHLwysErB68cvHLwysErB68cvHLwysErB68cvHLwysErB68cvHLwysErB68cvHLwysErB68cvHLwysErB68cvHLwysErB68cvHLwysErB68cvHLwysErB68cvHLwysErB68cvHLwysErB68cvHLwysErB68cvHLwysErB68cvHLwysErB68cvHLwysErB68cvHLwysErB68cvHLwysErB68cvHLwysErB68cvHLwysErB68qeFXBqwpeVfCqglcVvKrgVQWvKnhVwasKXlXwqoJXFbyq4FUFryp4VcGrCl5V8KqCVxW8quBVBa8qeFXBqwpeVfCqglcVvKrgVQWvKnhVwasKXlXwqoJXFbyq4FUFryp4VcGrCl5V8KqCVxW8quBVBa8qeFXBqwpeVfCqglcVvKrgVQWvKnhVwasKXlXwqoJXFbyq4FUFryp4VcGrCl5V8KqCVxW8quBVBa8qeFXBqwpeVfCqglcVvKrgVQWvKnhVwasKXlXwqoJXFbyq4FUFryp4VcGrCl5V8KqCVxW8quBVBa8qeFXBqwpeVfCqgVcNvGrgVQOvGnjVwKsGXjXwqoFXDbxq4FUDrxp41cCrBl418KqBVw28auBVA68aeNXAqwZeNfCqgVcNvGrgVQOvGnjVwKsGXjXwqoFXDbxq4FUDrxp41cCrBl418KqBVw28auBVA68aeNXAqwZeNfCqgVcNvGrgVQOvGnjVwKsGXjXwqoFXDbxq4FUDrxp41cCrBl418KqBVw28auBVA68aeNXAqwZeNfCqgVcNvGrgVQOvGnjVwKsGXjXwqoFXDbxq4FUDrxp41cCrBl418KqBVw28auBVA68aeNXAqwZeNfCqgVcNvGrgVTt5ZdvJK9tOXtl28sq2k1e2nbyy7eSVbSevbDt5ZdvJK9s21JtQb0K9CfUm1JtQb0K9CfUm1JtQb0K9GfVm1JtRb0a9GfVm1JtRb0a9GfVm1CuoV1CvoF5BvYJ6BfUK6hXUK6hXUK+iXkW9inoV9SrqVdSrqFdRr6JeRb0F9RbUW1BvQb0F9RbUW1BvQb0F9RbUa6jXUK+hXkO9hnoN9RrqNdRrqNdQr6NeR72Oeh31Oup11Ouo11Gvo15HvRX1VtRbUW9FvRX1VtRbUW9FvRX1VtTbUG9DvQ31NtTbUG9DvQ31NtTbUC94lcCrBF4l8CqBVwm8SuBVAq8SeJXAqwReJfAqgVcJvErgVQKvEniVwKsEXiXwKoFXCbxK4FUCrxJ4lcCrBF4l8CqBVwm8SuBVAq8SeJXAqwReJfAqgVcJvErgVQKvEniVwKsEXiXwKoFX8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC372XUC17Bbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC3G/x2g99u8NsNfrvBbzf47Qa/3eC378Nw1AtewW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Gv93gtxv8doPfbvDbDX67wW83+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX77Xka94BX8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8doff7vDbHX67w293+O0Ov93htzv8dv/w20t6lDuvPspHvaUc5aPe4kdZUD7qLfUoF5SPeu3I33llPedRr/V/285y59VHOaGcURaUFeWCsqHsKB/1+nEMnVe93Hn1UU4oZ5QFZUW5oGwoO8q93uMcdl71cufVRzmhnFEWlBXlgrKh7CijXkW9BfV2XtV2lDPKgrKifNTbjt/VedX0KB/1NjvKFeW93n3h6Dj/D16NckI5oywoK8oFZUPZUa4oo15HvY56HfU66nXU66jXUa+jXke9jnor6q2ot6Leinor6q2ot6Leinor6q2ot6Hehnob6m2ot6Hehnob6m2ot6HedtZ7+O2jnFDOKB/1Jj3KinJB2VA+6k393x715u0ot7Ocjnpz/tdvf/i/f/zHX/74v/765//8w//47z38P//1tz/98y9//9tH+M//9z+e/+V//eMvf/3rX/6ff/+Pf/z9T3/+3//1jz//+1///qfHf/vD9vh/j5T/M9lvOf3b/pfTx5/vf5L3n5Ee2+r9229/kP4nuT7+ROr+Jx//LFX57fH/jz9K/W9pfvwt1Ue+PKrY/1T98Ufy+KNHQk2/lfRMVfJv5fjPeh5U+y0fScr4o6y/5fb4Ixt/JPqbHH/kz7yy15RH3r0Se/znev6L9ls/uPb8F/vvOn/U+M/p985PimtJ5w/O6be8/9m//vVv//r/AA==",
      "is_unconstrained": false,
      "name": "receive_value",
      "verification_key": "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"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "6788092787179896647": {
            "error_kind": "string",
            "string": "Caller is not owner"
          }
        },
        "parameters": [
          {
            "name": "source_chain_id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 16
            },
            "visibility": "private"
          },
          {
            "name": "emitter_address",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "public"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "register_emitter"
    },
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "14067204867181196045": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "14401109495927734611": {
            "error_kind": "string",
            "string": "Field failed to decompose into specified 16 limbs"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15546539856497705002": {
            "error_kind": "string",
            "string": "u16 to u8 conversion failed"
          },
          "15711892660910782274": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16216212843441549037": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "2014890719615096298": {
            "error_kind": "string",
            "string": "Field failed to decompose into specified 40 limbs"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "4648451262681811962": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "7555607922535724711": {
            "error_kind": "string",
            "string": "Preimage mismatch"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9589626482238399944": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "9921926525851912681": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "anchor_block_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "sponge_blob_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "destination_chain_id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 16
            },
            "visibility": "private"
          },
          {
            "name": "value",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "fee_nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "note_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 32,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "log",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "fields",
                                          "type": {
                                            "kind": "array",
                                            "length": 18,
                                            "type": {
                                              "kind": "field"
                                            }
                                          }
                                        },
                                        {
                                          "name": "length",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::log::Log"
                                    }
                                  },
                                  {
                                    "name": "note_hash_counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "anchor_block_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "sponge_blob_hash",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "private"
      ],
      "debug_symbols": "TL3LzjQ7j5x7L2vsQelAiuxb2QNjex+MBhpuwIdRw/fuNxmiIib9PdH/ehXKlBiVlcXK+o9//t//77/8r//6n//1v/3///4//vmX/+s//vkv//1f/+3f/vW//ud/+/f/5//+n//67//t7//7H//8vv8z9j//Ms33//5P/4xPr/znX8Z/+mf/8M/APxP/LPyz8Y/hH8c/B/8E/sEohlEMoxhGMYxiGMUwimEUwyiGUQyjOEZxjOIYxTGKYxTHKI5RHKM4RnGMcjDKwSgHoxyMcjDKwSgHoxyMcjDKwSiBUQKjBEYJjBIYJTBKYJTAKIFRAqMkRkmMkhglMUpilMQoiVESoyRGSYwyfr/777j/zvvvuv/u+6/df/3+e+6/cf+944073rjjjTveuOONO964442/8db377n/xv038e/8G8+/f8f9d95/1/33b7z8/v3Gqz/whtMQDXlh/Rq+WZ4PZsNq2A3fyPGBN5yGb+TvKGrHf1B7vuBv5Lk/mA2rYTdYgzechmjIC18dAHpk65GtR/7qYX5n5asIgDechmjIC19tAEbDbFgNPbL3yN4je4/sPbL3yKdHPj3y6ZFPj3x65NMjnx759MinRz498ldD81uCr4oAs2E17AZr8IbTEA15IXvk7JGzR84eOXvk7JGzR84eOXvkvCPP369hNMyG1bAbrMEbTkM09MijRx498uiRR488euTRI48eefTIo0cePfLskWePPHvk2SPPHnn2yLNHnj3y7JFnj7x65NUjrx559cirR1498uqRV4+8euTVI+8eeffIu0fePfLukXeP/NXgGh+chmjIC18NAkbDbFgNu8EaemTrka1H/mpw/VXu/GoQMBq+kfOD1bAbrMEbTkM05IWvBgGjoUc+PfLpkc9NpHm84TREw02kGb+G0TAbVsNu6JGjR44e+avBPT/IC18NAkbDbFgNu8EavOE09Mh5R16/X8No+EZeH6yG3WAN3nAaoiEvfDUIGA098uiRR4/81aD9PvCG0xANeeGrQcBomA2rYTf0yLNHnj3y7JFnj7x65NUjrx559cirR1498uqRV4+8euTVI+8eeffIu0fePfLukXePvHvk3SPvHnn3yNYjW49sPbL1yNYjW49sPbL1yNYjW4/sPbL3yN4je4/sPbL3yN4je4/sPbL3yKdHPj3y6ZFPj3x65NMjnx759MinRz49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V+fj1fl4dT5enY9X5+PV+Xh1Pl6dj1fn49X5eHU+Xp2PV+fj1fl4dT5enY9X5+PV+Xh1Pl6dj1fn49X5eHU+Xp2PV+fj1fl4dT5enY9X5+PV+Xh1Pl6dj1fn49X5eHU+Xp2PV+fj1fl4dT5enY9X5+PV+Xh1Pl6dj1fn49X5eHU+Xp2PV+fj1fl4dT5enY9X5+PV+Xh1Pl6dj1fn49X5eHU+Xp2PV+fj1fl4dT5enY9X5+PV+Xh1Pl6dj1fn49X5eHU+Xp2PV+fj1fl4dT5enY9X5+PV+Xh1Pl6dj1fn49X5fHU+X53PV+fz1fl8dT5fnc9X5/PV+Xx1Pl+dz1fn89X5fHU+X53PV+fz1fl8dT5fnc9X5/PV+Xx1Pl+dz1fn89X5fHU+X53PV+fz1fl8dT5fnc9X5/PV+Xx1Pl+dz1fn89X5fHU+X53PV+fz1fl8dT5fnc9X5/PV+Xx1Pl+dz1fn89X5fHU+X53PV+fz1fl8dT5fnc9X5/PV+Xx1Pl+dz1fn89X5fHU+X53PV+fz1fl8dT5fnc9X5/PV+Xx1Pl+dz1fn89X5fHU+X53PV+fz1fl8dT5fnc9X5/PV+Xx1Pl+dz1fn89X5fHU+X53PV+fz1fl8dT5fnc9X5/PV+Xx1Pl+dz1fn89X5fHU+X53PV+fz1fl6db5ena9X5+vV+Xp1vl6dr1fn69X5enW+Xp2vV+fr1fl6db5ena9X5+vV+Xp1vl6dr1fn69X5enW+Xp2vV+fr1fl6db5ena9X5+vV+Xp1vl6dr1fn69X5enW+Xp2vV+fr1fl6db5ena9X5+vV+Xp1vl6dr1fn69X5enW+Xp1XC5JXS+9X55fi0Z+HV+PwV+eXxqP5aD3aj+yRPzqP4tHz8Ofhz8Ofhz8Pfx7+PPx5+PPw5+HP4zyP8zzO8zjP4zyP8zzO8zjP4zyP8zziecTziOcRzyOeRzyPeB7xPOJ5xPPI55HPI59HPo98Hvk88nnk88jnke1RjUuXxqP5aD3aj+yRPzqP4tHzGM9jPI/xPMbzGM9jPI/xPMbzGM9jPI/5PObzmM9jPo/5PObzmM9jPo/5PObzWM9jPY/1PNbzWM9jPY/1PNbzWM9jPY/9PPbz2M9jP4/9PPbz2M9jP4/9PF6d71fn+9X5fnW+X51Xu5NbkT3yR+dRPMqmqnPQeDQfrUfPw5+HPw9/Hv48/Hmc53Gex3ke53mc53Gex3ke53mc53GeRzyPeB7xPOJ5xPOI5xHPI55HPI94Hvk88nnk88jnkc8jn0c+j3we+TyyPao56tJ4NB+tR/uRPfJH51E8eh7jeYznMZ7HeB7jeYznMZ7HeB7jeYznMZ/HfB7zecznMZ/HfB7zecznMZ/HfB7reaznsZ7Heh7reaznsZ7Heh7reaznsZ/Hfh77eeznsZ/Hfh77eeznsZ/Hfh72POx52POw5/Hq3F6d26tze3Vur87t1bm9OrdX5/bq3F6d26tze3Vur87t1bm9OrdX5/bq3F6d26tze3Vur87t1bm9OrdX5/bq3F6d26tze3Ve7VYeRevRfmSP/NF5FI+yqeocNB49j3we+TzyeeTzyOeRzyPboxqwLo1H89F6tB/ZI3/053F2UTzKpq/OL41H89F6tB/ZI3/0PL46P1aUTV+dXxqP5qP1aD+yR/7oPHoe83ms57Gex1fn5xStR/uRPfJH51E8yqavzi+NR89jP4/9PPbz2M9jP4/9PPbzsOdhz8Oehz0Pex72POx52POw52HPw5+HPw9/Hv48/Hn48/Dn8dX5qR321fmlbPrq/GTReDQf/XnEKNqP7NGfR9Ru+ur8Ujz688jfR1+dXxqP/jyyRvnq/NJ+9OeRq8gfnUfxKJu+Or80Hs1H69F+9DzyeeTz+Oo86zi+Oi+qJq9Ln8cpmo/Wo/3IHvmj8ygeZdNX55eex3ge43l8dZ5RZI/80XkUj7Lpq/NL49F8tB49j/k85vOYz2M+j/k81vNYz2M9j/U81vNYz2M9j/U81vNYz2M/j/089vPYz2M/j/089vPYz2M/j/087HnY87DnYc/Dnoc9D3se9jzsedjz8Ofhz8Ofhz8Pfx7+PPx5+PPw5+HP4zyP8zzO8zjP4zyP8zzO8zjP4zyP8zziecTziOcRzyOeRzyPeB7xPOJ5xPPI55HPI59HPo98Hvk88nnk88jnke1RjWSXxqP5aD3aj+yRPzqP4tHzGM9jPI/6jvtvFC7iJhrRiYcYxHz41XvjINJt0m3SbdJt0m3SbdJt0m3RbdFt0W3RbdFt0W3RbdFt0W3RbdNt023TbdNt023TbdNt023TbdPN6GZ0M7oZ3YxuRjejm9HN6GZ0c7o53ZxuTjenm9PN6eZ0c7o53Q7dDt0O3Q7dDt0O3Q7dDt0O3Q7dgm5Bt6Bb0C3oFnQLugXdgm5Bt6Rb0i3plnRLuiXdkm5Jt6RbPrdqgmscxElcxE00ohMPMYh0G3QbdGOWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJYks+a7GE1kCHMRJXMRNNKITDzGIdEu6Jd2QJVa4iJtoRCceYhDz4vwhS4CDOImLuIlGdOIhBpFug26DboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptum25GN2TJKZzERfzcxq/QiE48xCDmw8qSi4M4iYtIN6eb083p5nRzuh26Hboduh26Hboduh26Hboduh26Bd2CbkG3oFvQLegWdAu6Bd2Cbkm3pFvSLemWdEu6Jd2Sbkm3fG54RtfFQZzERdxEIzrxEINIt0G3QbdBt0G3QbdBt0G3QbdBt0G3SbdJt0m3SbdJt0m3SbdJt0m3SbdFt0W3RbdFt0W3RbdFt0W3RbdFt023TbdNt023TbdNt023TbdNt003o5vRzehmdGOWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJYpYsZslilixmyWKWLGbJYpYsZslilixmyWKWLGbJYpYsZslilixmyWKWLGbJYpYsZMn6EFkCHMRJXMRNNKITDzGIdFt0W3RDluzCRdxEIzrxEIOYD5ElwEGk26bbptum26bbptum26ab0c3oZnQzuhndjG5GN6Ob0c3o5nRzujndnG5ON6eb083p5nRzuh26Hboduh26Hboduh26Hboduh26Bd2CbkG3oFvQLegWdAu6Bd2Cbkm3pFvSLemWdEu6Jd2Sbkm3fG779yMO4iQu4iYa0Ynl5oVBzIfIkiwcxElcxE00ohMPMYj5cNJt0m3SbdJt0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0W3TbdNt023TbdNt023TbdNt023TzehmdDO6Gd2MbkY3o5vRzehmdHO6Od2cbk43p5vTzenmdHO6Od0O3Q7dDt0O3Q7dDt0O3Q7dDt0O3YJuQbegW9At6BZ0C7oF3YJuQbekW9It6ZZ0S7ol3ZJuSbekWz43+/2IgziJi7iJRnTiIQaRbswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZslhlhxmyWGWVCvq32cfhZtoRCceYhDzYWXJxUGcRLoNug26VZZ8P7cxqzG1MYj5sLLk4iBO4iJuohHpNuk26Tbptui26Lbotui26FZZMq3QiYcYxHxYWXJxECdxETeRbptum26bbptuRjejm9HN6GZ0M7oZ3YxuRjejm9PN6eZ0c7o53ZxuTjenm9PN6Xboduh26Hboduh26Hboduh26HboFnQLugXdgm5Bt6Bb0C3oFnQLuiXdkm5Jt6Rb0i3plnRLuiXd8rlVr2vjIE7iIm6iEZ14iEGk26DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26IbsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWYK+13kKN9GITjzEIOZDZAlwECeRbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptum25GN6Ob0c3oZnQzuhndjG5GN6Ob083p5nRzujndnG5ON6eb083pduh26HboduiGLMlCIzrxc6uf90Lf68V8WFlycRAncRE30YhOpFvQLeiWdEu6Jd2Sbkm3pFvSLemWdMt2W+h7vTiIk7iIm2hEJx5iEOk26DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26Tbptui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26WZ0M7oZ3YxuRjejm9HN6GZ0M7o53ZxuTjenm9PN6eZ0c7o53Zxuh26Hboduh26Hboduh26Hboduh25Bt6Bb0C3oFnQLugXdgm5Bt6Bb0i3plnRLuiXdkm5Jt6Rb0o1ZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1mCvtfvJ3UX+l4vBrHc/ENkCXAQJ3ERN9GITjzEINLN6YYs+RVO4iJuohGdeIhBzIfIEiDdDt0O3Q7dDt0O3Q7dDt0O3YJuQbegW9At6BZ0C7oF3YJuQbekW9It6ZZ0S7ol3ZJuSbekWz439L1eHMRJXMRNNKITDzGIdBt0G3QbdBt0qyzZVmhEJ35u2wuDmA+RJadwECdxETfRiE48xCDmw0W3RbdFt0W3RbdFt0W3RbdFt0W3TbdNt023TbdNt023TbdNt023TTejm9HN6GZ0M7oZ3YxuRjejm9HN6eZ0c7o53ZxuTjenm9PN6eZ0O3Q7dDt0O3Q7dDt0O3Q7dDt0O3QLugXdgm5Bt6Bb0C3oFnQLugXdkm5Jt6Rb0i3plnRLuiXdkm753ND3enEQJ3ERN9GITjzEINJt0A33XnfhJC7iJhrRiYcYxHyIe69Auk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptum26Gd2MbkY3o5vRzehmdDO6Gd2Mbk43p5vTzenmdHO6Od2cbk43p9uh26Hboduh26Hboduh26HboduhW9At6BZ0C7oF3YJuQbegW9At6JZ0S7ol3ZJuSbekW9It6ZZ0y+eGvteLg/i52ShcxE383Az/rRMP8XMzL8yHlSUXB3ESF3ETjejEQ6TboNuk26TbpNuk26TbpNuk26TbpNuk26Lbotui26Lbotui26Lbotui26Lbptum26bbptum26bbptum26bbppvRzehmdDO6Gd2MbkY3o5vRzejmdHO6Od2cbk43p5vTzenmdHO6Hboduh26Hboduh26Hboduh26HboF3YJuQbegW9At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",
      "is_unconstrained": false,
      "name": "send_value_private",
      "verification_key": "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"
    },
    {
      "abi": {
        "error_types": {
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15546539856497705002": {
            "error_kind": "string",
            "string": "u16 to u8 conversion failed"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "8228371833434187583": {
            "error_kind": "string",
            "string": "Trying to read from uninitialized PublicImmutable"
          }
        },
        "parameters": [
          {
            "name": "destination_chain_id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 16
            },
            "visibility": "private"
          },
          {
            "name": "value",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "fee_nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "public"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "send_value_public"
    },
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "14067204867181196045": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "9921926525851912681": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "utility"
      ],
      "debug_symbols": "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4iYa0YmHGES6DboNug26MUuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySahEcYxQO4iQu4iYa0YmHGMR8mHRLuiXdKkvGLNxEIzrxEIOYF2d1EjYO4iQu4iYa0YmHGES6DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26bboZ3YxulSVjFy7iJpbbKXTiIQYxH1aWXBzESVzETaSb083p5nRzuh26Hboduh26Hboduh26Hboduh26Bd2CbkG3oFvQLegWdAu6Bd2Cbkm3pFvSLemWdEu6Jd2Sbkm3fG7j9yMO4iQu4iYa0YmHGES6DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26bboZ3YxuRjejm9GNWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWbKYJYtZspgli1mymCWLWbKYJYtZspgli1mymCWLWbKYJYtZspgli1mymCWLWbKYJYtZUp2Y4/ti0lmtmI2TuIibaEQnHmIQ8+Gi26LboltlyRyFm2hEJx5iEPNhZcnFQZxEum26bbptum26bbptuhndjG5GN6Ob0c3oZnQzuhndjG5ON6eb083p5nRzujndnG5ON6fboduh26Hboduh26Hboduh26HboVvQLegWdAu6Bd2CbkG3oFvQLeiWdEu6Jd2Sbkm3pFvSLemWdMvnVp2djYM4iYu4iUZ04iGW2yrMh5UlF8vNCydxETfRiE48xCDmQ2QJkG6TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26bbkY3o5vRzehmdDO6Gd2MbkY3o5vTzenmdHO6Od2cbk43p5vTzel26Hboduh26Hboduh26Hboduh26BZ0C7oF3YJuQbegW9At6BZ0C7ol3ZJuSbekW9It6ZZ0S7ol3fK52e9HHMRJXMRNNKITDzGIdBt0Y5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZslhlhxmyWGWHGYJ+l5nFhrRiYcYxHyILAEO4iQuIt0G3QbdKku+P/cx0fd6MR9WllwcxElcxE00ohPpNuk26bbotui26Lbotui26FZZsmbhIQYxH1aWXBzESVzETTQi3TbdNt023YxuRjejm9HN6GZ0M7oZ3YxuRjenm9PN6eZ0c7o53ZxuTjenm9Pt0O3Q7dDt0O3Q7dDt0O3Q7dDt0C3oFnQLugXdgm5Bt6Bb0C3oFnRLuiXdkm5Jt6Rb0i3plnRLuuVzQ9/rxUGcxEXcRCM68RCDSLdBt0G3QbdBt0G3QbdBt0G3QbdBt0m3SbdJt0m3SbdJt0m3SbdJt0m3RbdFt0W3RbdFt0U3ZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYkswR9r2sXGtGJhxjEfIgsAQ7iJC4i3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0W3TbdNt023TbdNt023TbdNt023TbdjG5GN6Ob0c3oZnQzuhndjG5GN6eb083p5nRzujndnG5ON6eb0+3Q7dDt0O3Q7dANWeKFTjzEcovCfIgsAQ7iJC7iJhrRiYdIt6Bb0i3plnRLuiXdkm5Jt6Rb0i3bbaHv9eIgTuIibqIRnXiIQaTboNug26DboNug26DboNug26DboNuk26TbpNuk26TbpNuk26TbpNuk26Lbotui26Lbotui26Lbotui26Lbptum26bbptum26bbptum26bbppvRzehmdDO6Gd2MbkY3o5vRzejmdHO6Od2cbk43p5vTzenmdHO6Hboduh26Hboduh26Hboduh26HboF3YJuQbegW9At6BZ0C7oF3YJuSbekW9It6ZZ0S7ol3ZJuSTdmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJag7/X7k74Lfa8X82FlyV6FgziJi7iJRnTiIQYxHzrdnG7IklO4iJtoRCceYhDzIbIEOIh0O3Q7dDt0O3Q7dDt0O3QLugXdgm5Bt6Bb0C3oFnQLugXdkm5Jt6Rb0i3plnRLuiXdkm753ND3enEQJ3ERN9GITjzEINJt0G3QbdBt0G3QrbLEZqETD/Fzs1WYDytLLtaZ3IWTuIibaEQnHmIQ82FlyUW6Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptum26Gd2MbkY3o5vRzehmdDO6Gd2Mbk43p5vTzenmdHO6Od2cbk43p9uh26Hboduh26Hboduh26HboduhW9At6BZ0C7oF3YJuQbegW9At6JZ0S7ol3ZJuSbekW9It6ZZ0y+eGvteLgziJi7iJRnTiIQaRboNug27IklG4iJtoRCceYhDzIe5LgINIt0m3SbdJt0m3SbdJt0m3RbdFt0W3RbdFt0W3RbdFt0W3RbdNt023TbdNt023TbdNt023TbdNN6Ob0c3oZnQzuhndjG5GN6Ob0c3p5nRzujndnG5ON6eb083p5nQ7dDt0O3Q7dDt0O3Q7dDt0O3Q7dAu6Bd2CbkG3oFvQLegWdAu6Bd2Sbkm3pFvSLemWdEu6Jd2Sbvnc0Pd6cRAn8XOzKNxEI35ujn97iEH83Py7PUDf68VBnMRF3EQjOvEQg0i3SbdJt0m3SbdJt0m3SbdJt0m3SbdFt0W3RbdFt0W3RbdFt0W3RbdFt023TbdNt023TbdNt023TbdNt003o5vRzehmdDO6Gd2MbkY3o5vRzenmdHO6Od2cbk43p5vTzenmdDt0O3Q7dDt0O3Q7dDt0O3Q7dDt0C7oF3YJuQbegW9At6BZ0C7oF3ZJuSbekW9It6ZZ0S7ol3ZJu+dzQ93pxECdxETfRiE48xCDSjVnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLEHf6/fXQhb6Xi8u4iYa0YmHGMR8iCwB0m3SbdJt0q2y5HihEw+x3GZhPkSWAAdxEhdxE43oxEOk26Lbptum26bbptum26bbptum26bbppvRzehmdDO6Gd2MbkY3o5vRzejmdHO6Od2cbk43p5vTzenmdHO6Hboduh26Hboduh26Hboduh26HboF3YJuQbegW9At6BZ0C7oF3YJuSbekW9It6ZZ0S7ol3ZJuSbd8buh7vTiIk7iIm2hEJx5iEOk26DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNunGLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMEvS9xhf86Hu9OIif2/eF7gt9rxc38XOLLHTiIX5u+SvMh5UlFwdxEhdxE43oxEOkm9Pt0O3QrbIkvXARN/HP7e9DzkInHmJ8WOvwZcnFL0sa/9zm91WJq/peGxdxf1h78WVJoxM/t1HT+bKkMR9+WdI4iJO4iJtoRCfSLemWz636XhsHcRIXcRON6MRDDCLdBt0G3QbdBt0G3QbdBt0G3QbdBt0m3SbdJt0m3SbdJt0m3SbdJt0m3RbdFt0W3RbdFt0W3RbdFt0W3RbdNt023TbdNt023TbdNt023TbdNt2MbkY3o5vRzehmdDO6Gd2MbkY3p5vTzenmdHO6Od2cbk43p5vT7dDt0O3Q7dDt0O3Q7dDt0O3Q7dAt6BZ0C7oF3YJuQbegG7MkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkm+LNm/lyX797Jk/16W7N/Lkv17WbJ/L0v272XJ/r0s2b+XJfv3o9ug26DboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptumW2XJ960xu/peG534uc0oDGI+rCz5fqNyV99r4yR+bqvcKksuGvFz+z7h39X32hjEz+37XG9X32vjIH5u2woXcRM/N6sLqiy5eIifm2GwfFhZcvFz81/hJC7i5+Y138qSi0783LzWrLLkYj6sLDk138qSi5P4uZ1as8qSi0b83E6temXJxSDmw8qSi4M4iYu4iUakW9It6ZbPrfpeGwdxEhdxE43oxEMMIt0G3QbdBt0G3QbdBt0G3QbdKku+++pdfa8XK0sufm7fX1Da1ffauIibaEQnHmIQ82FlyUW6Lbotui26VZZ8f4FpV99r4yF+bjkL82FlycXPLesyK0suLuImGtGJhxjEfFhZcpFuRrcvS9av5vtlSaMR/cOa75cljUHMD796q77XxkGcH9Z2+yLuRnRKRtE37Piqv1oi1/eOYFdLZOMibqIRnXiIQcyH3zFrpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptumm9HN6GZ0M7oZ3YxuRjejm9HN6OZ0c7o53ZxudcyGFRrRiYcYxHx4yq0O6hnESVzEz23W+f1esho/t++b5na1RDYGMR9+L1mNgziJn9vchZtoxHLzwkMMYrnVfPNHHMRJXMRN/Ny+r0jY1RLZeIhB/Ny+34Tb1RLZOIif2/4VLuImfm5f2+uulsjG83DUVZzCb9y6hak2x7W9sEbIQiceYhDzYeXDxW/curGpNsfGRdzEz63ucarNsfFzs5pk5cPFfFj5cHEQJ/Fz+zosdrU5NhrRiZ/b98RrV5tj4+fmNcnKh4uDOInlVsaVDxeN6MRDDOLndmo6lQ8XB3ESP7dTk6x8uGjEcrPCQ4yHVfMXa4S6iqruupWrzsS/J+AfVklfHMRJXMRvsKhJVklfdOIhBjEfVknXPUN1JjZO4iKWW823SvqiE8utZlYlfTEfVklHHdoq6awaqpKuu47qTGzcRCM68TRWD+LfvyocxElcxE20h1WF35+d3NUg2FgW33yrFXDXXUe1AjZO4iJuoj1c9f+t+S4jOvEQg5gP9484iJO4iHTbdNt023TbdNt0sxp3FdYIu7BG8MJDDGKN8G13teE1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",
      "is_unconstrained": true,
      "name": "sync_private_state"
    }
  ],
  "name": "MessageBridge",
  "noir_version": "1.0.0-beta.14+82ec52a8c755d30ce655a2005834186a4acfa0c7-aztec",
  "outputs": {
    "globals": {
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "minters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Wormhole"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "state",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "sequences",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "owner",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "receiver_address",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000009"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "token_address",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000d"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_1",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000011"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_2",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000012"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_3",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000013"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_4",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000014"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_5",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000015"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_6",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000016"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_7",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000017"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_8",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000018"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_9",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000019"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_10",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_11",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001b"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_12",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001c"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_13",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001d"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_14",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001e"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_15",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001f"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_16",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000020"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_17",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000021"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_18",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000022"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_19",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000023"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "current_guardian_set_index",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000024"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "MessageBridge"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "config",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "owner",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "registered_emitters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "current_value",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "emitter_chain_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 16
                    }
                  },
                  {
                    "name": "emitter_address",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "value",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "MessageBridge::_validate_emitter_and_update_value_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::_validate_emitter_and_update_value_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "wormhole_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "chain_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 16
                    }
                  },
                  {
                    "name": "owner",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "message_fee",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "MessageBridge::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "MessageBridge::get_config_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "wormhole_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "chain_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 16
                    }
                  },
                  {
                    "name": "message_fee",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "config::Config"
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::get_config_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "MessageBridge::get_current_value_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::get_current_value_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "MessageBridge::get_owner_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::get_owner_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "chain_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 16
                    }
                  }
                ],
                "kind": "struct",
                "path": "MessageBridge::get_registered_emitter_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "array",
                "length": 32,
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 8
                }
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::get_registered_emitter_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "chain_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 16
                    }
                  },
                  {
                    "name": "emitter_address",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "MessageBridge::is_emitter_registered_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "boolean"
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::is_emitter_registered_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "message_ciphertext",
                    "type": {
                      "fields": [
                        {
                          "name": "storage",
                          "type": {
                            "kind": "array",
                            "length": 17,
                            "type": {
                              "kind": "field"
                            }
                          }
                        },
                        {
                          "name": "len",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 32
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "std::collections::bounded_vec::BoundedVec"
                    }
                  },
                  {
                    "name": "message_context",
                    "type": {
                      "fields": [
                        {
                          "name": "tx_hash",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "unique_note_hashes_in_tx",
                          "type": {
                            "fields": [
                              {
                                "name": "storage",
                                "type": {
                                  "kind": "array",
                                  "length": 64,
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              },
                              {
                                "name": "len",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "std::collections::bounded_vec::BoundedVec"
                          }
                        },
                        {
                          "name": "first_nullifier_in_tx",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "recipient",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::messages::processing::message_context::MessageContext"
                    }
                  }
                ],
                "kind": "struct",
                "path": "MessageBridge::process_message_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::process_message_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "vaa",
                    "type": {
                      "kind": "array",
                      "length": 2000,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "length",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "MessageBridge::receive_value_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::receive_value_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "source_chain_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 16
                    }
                  },
                  {
                    "name": "emitter_address",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "MessageBridge::register_emitter_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::register_emitter_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "destination_chain_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 16
                    }
                  },
                  {
                    "name": "value",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "fee_nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "MessageBridge::send_value_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::send_value_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "destination_chain_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 16
                    }
                  },
                  {
                    "name": "value",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "fee_nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "MessageBridge::send_value_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::send_value_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "MessageBridge::sync_private_state_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "MessageBridge::sync_private_state_abi"
        }
      ]
    }
  },
  "transpiled": true
}
